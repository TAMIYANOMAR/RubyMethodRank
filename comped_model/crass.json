{" Crass parse":{"type":"method","name":"parse","children":[],"call":[]}," Crass Tokenizer valid_escape?":{"type":"method","name":"valid_escape?","children":[],"call":["(and\n  (send\n    (send\n      (lvar :text) :[]\n      (int 0)) :==\n    (str \"\\\\\"))\n  (send\n    (send\n      (lvar :text) :[]\n      (int 1)) :!=\n    (str \"\\n\"))) ! ! ","(and\n  (send\n    (send\n      (lvar :text) :[]\n      (int 0)) :==\n    (str \"\\\\\"))\n  (send\n    (send\n      (lvar :text) :[]\n      (int 1)) :!=\n    (str \"\\n\"))) ! ","text [] != ","text [] ","text [] == ","@s peek ","text nil? ","@s current + ","@s current ","(and\n  (send\n    (send\n      (lvar :@s peek ) :[]\n      (int 0)) :==\n    (str \"\\\\\"))\n  (send\n    (send\n      (lvar :@s peek ) :[]\n      (int 1)) :!=\n    (str \"\\n\"))) ! ! ","(and\n  (send\n    (send\n      (lvar :@s current + ) :[]\n      (int 0)) :==\n    (str \"\\\\\"))\n  (send\n    (send\n      (lvar :@s current + ) :[]\n      (int 1)) :!=\n    (str \"\\n\"))) ! ! ","(and\n  (send\n    (send\n      (lvar :@s peek ) :[]\n      (int 0)) :==\n    (str \"\\\\\"))\n  (send\n    (send\n      (lvar :@s peek ) :[]\n      (int 1)) :!=\n    (str \"\\n\"))) ! ","(and\n  (send\n    (send\n      (lvar :@s current + ) :[]\n      (int 0)) :==\n    (str \"\\\\\"))\n  (send\n    (send\n      (lvar :@s current + ) :[]\n      (int 1)) :!=\n    (str \"\\n\"))) ! ","@s peek  [] != ","@s current +  [] != ","@s peek  [] ","@s current +  [] ","@s peek  [] == ","@s current +  [] == ","@s peek  nil? ","@s current +  nil? "]}," Crass Tokenizer tokenize":{"type":"method","name":"tokenize","children":[],"call":[" consume ","tokens << ","token [] != ","token [] ","@s reset "," consume s << "," consume  [] != "," consume  [] "]}," Crass Tokenizer token":{"type":"method","name":"token","children":[],"call":["(pair\n  (sym :node)\n  (lvar :type)) merge! ","@s marked ","@s marker "]}," Crass Tokenizer start_number?":{"type":"method","name":"start_number?","children":[],"call":["(send\n  (send\n    (lvar :text) :[]\n    (int 1)) :=~\n  (const nil :RE_DIGIT)) ! ! ","(send\n  (send\n    (lvar :text) :[]\n    (int 1)) :=~\n  (const nil :RE_DIGIT)) ! ","text [] =~ ","text [] ","(or\n  (send\n    (send\n      (lvar :text) :[]\n      (int 1)) :=~\n    (const nil :RE_DIGIT))\n  (begin\n    (and\n      (send\n        (send\n          (lvar :text) :[]\n          (int 1)) :==\n        (str \".\"))\n      (send\n        (send\n          (lvar :text) :[]\n          (int 2)) :=~\n        (const nil :RE_DIGIT))))) ! ! ","(or\n  (send\n    (send\n      (lvar :text) :[]\n      (int 1)) :=~\n    (const nil :RE_DIGIT))\n  (begin\n    (and\n      (send\n        (send\n          (lvar :text) :[]\n          (int 1)) :==\n        (str \".\"))\n      (send\n        (send\n          (lvar :text) :[]\n          (int 2)) :=~\n        (const nil :RE_DIGIT))))) ! ","text [] == ","@s peek ","text nil? ","@s current + ","@s current ","(send\n  (send\n    (lvar :@s peek ) :[]\n    (int 1)) :=~\n  (const nil :RE_DIGIT)) ! ! ","(send\n  (send\n    (lvar :@s current + ) :[]\n    (int 1)) :=~\n  (const nil :RE_DIGIT)) ! ! ","(send\n  (send\n    (lvar :@s peek ) :[]\n    (int 1)) :=~\n  (const nil :RE_DIGIT)) ! ","(send\n  (send\n    (lvar :@s current + ) :[]\n    (int 1)) :=~\n  (const nil :RE_DIGIT)) ! ","@s peek  [] =~ ","@s current +  [] =~ ","@s peek  [] ","@s current +  [] ","(or\n  (send\n    (send\n      (lvar :@s peek ) :[]\n      (int 1)) :=~\n    (const nil :RE_DIGIT))\n  (begin\n    (and\n      (send\n        (send\n          (lvar :@s peek ) :[]\n          (int 1)) :==\n        (str \".\"))\n      (send\n        (send\n          (lvar :@s peek ) :[]\n          (int 2)) :=~\n        (const nil :RE_DIGIT))))) ! ! ","(or\n  (send\n    (send\n      (lvar :@s current + ) :[]\n      (int 1)) :=~\n    (const nil :RE_DIGIT))\n  (begin\n    (and\n      (send\n        (send\n          (lvar :@s current + ) :[]\n          (int 1)) :==\n        (str \".\"))\n      (send\n        (send\n          (lvar :@s current + ) :[]\n          (int 2)) :=~\n        (const nil :RE_DIGIT))))) ! ! ","(or\n  (send\n    (send\n      (lvar :@s peek ) :[]\n      (int 1)) :=~\n    (const nil :RE_DIGIT))\n  (begin\n    (and\n      (send\n        (send\n          (lvar :@s peek ) :[]\n          (int 1)) :==\n        (str \".\"))\n      (send\n        (send\n          (lvar :@s peek ) :[]\n          (int 2)) :=~\n        (const nil :RE_DIGIT))))) ! ","(or\n  (send\n    (send\n      (lvar :@s current + ) :[]\n      (int 1)) :=~\n    (const nil :RE_DIGIT))\n  (begin\n    (and\n      (send\n        (send\n          (lvar :@s current + ) :[]\n          (int 1)) :==\n        (str \".\"))\n      (send\n        (send\n          (lvar :@s current + ) :[]\n          (int 2)) :=~\n        (const nil :RE_DIGIT))))) ! ","@s peek  [] == ","@s current +  [] == ","@s peek  nil? ","@s current +  nil? "]}," Crass Tokenizer start_identifier?":{"type":"method","name":"start_identifier?","children":[],"call":[" valid_escape? ","text [] ","(or\n  (send\n    (send\n      (lvar :text) :[]\n      (int 1)) :=~\n    (const nil :RE_NAME_START))\n  (send nil :valid_escape?\n    (send\n      (lvar :text) :[]\n      (int 1)\n      (int 2)))) ! ! ","(or\n  (send\n    (send\n      (lvar :text) :[]\n      (int 1)) :=~\n    (const nil :RE_NAME_START))\n  (send nil :valid_escape?\n    (send\n      (lvar :text) :[]\n      (int 1)\n      (int 2)))) ! ","text [] =~ ","@s peek ","text nil? ","(or\n  (or\n    (send\n      (lvar :nextChar) :==\n      (str \"-\"))\n    (send\n      (lvar :nextChar) :=~\n      (const nil :RE_NAME_START)))\n  (send nil :valid_escape?\n    (send\n      (lvar :text) :[]\n      (int 1)\n      (int 2)))) ! ! ","(or\n  (or\n    (send\n      (lvar :nextChar) :==\n      (str \"-\"))\n    (send\n      (lvar :nextChar) :=~\n      (const nil :RE_NAME_START)))\n  (send nil :valid_escape?\n    (send\n      (lvar :text) :[]\n      (int 1)\n      (int 2)))) ! ","nextChar =~ ","nextChar == ","@s current + ","@s current ","@s peek  [] ","@s current +  [] ","(or\n  (send\n    (send\n      (lvar :@s peek ) :[]\n      (int 1)) :=~\n    (const nil :RE_NAME_START))\n  (send nil :valid_escape?\n    (send\n      (lvar :@s peek ) :[]\n      (int 1)\n      (int 2)))) ! ! ","(or\n  (send\n    (send\n      (lvar :@s current + ) :[]\n      (int 1)) :=~\n    (const nil :RE_NAME_START))\n  (send nil :valid_escape?\n    (send\n      (lvar :@s current + ) :[]\n      (int 1)\n      (int 2)))) ! ! ","(or\n  (send\n    (send\n      (lvar :@s peek ) :[]\n      (int 1)) :=~\n    (const nil :RE_NAME_START))\n  (send nil :valid_escape?\n    (send\n      (lvar :@s peek ) :[]\n      (int 1)\n      (int 2)))) ! ","(or\n  (send\n    (send\n      (lvar :@s current + ) :[]\n      (int 1)) :=~\n    (const nil :RE_NAME_START))\n  (send nil :valid_escape?\n    (send\n      (lvar :@s current + ) :[]\n      (int 1)\n      (int 2)))) ! ","@s peek  [] =~ ","@s current +  [] =~ ","@s peek  nil? ","@s current +  nil? ","(or\n  (or\n    (send\n      (lvar :nextChar) :==\n      (str \"-\"))\n    (send\n      (lvar :nextChar) :=~\n      (const nil :RE_NAME_START)))\n  (send nil :valid_escape?\n    (send\n      (lvar :@s peek ) :[]\n      (int 1)\n      (int 2)))) ! ! ","(or\n  (or\n    (send\n      (lvar :nextChar) :==\n      (str \"-\"))\n    (send\n      (lvar :nextChar) :=~\n      (const nil :RE_NAME_START)))\n  (send nil :valid_escape?\n    (send\n      (lvar :@s current + ) :[]\n      (int 1)\n      (int 2)))) ! ! ","(or\n  (or\n    (send\n      (lvar :text [] ) :==\n      (str \"-\"))\n    (send\n      (lvar :text [] ) :=~\n      (const nil :RE_NAME_START)))\n  (send nil :valid_escape?\n    (send\n      (lvar :text) :[]\n      (int 1)\n      (int 2)))) ! ! ","(or\n  (or\n    (send\n      (lvar :nextChar) :==\n      (str \"-\"))\n    (send\n      (lvar :nextChar) :=~\n      (const nil :RE_NAME_START)))\n  (send nil :valid_escape?\n    (send\n      (lvar :@s peek ) :[]\n      (int 1)\n      (int 2)))) ! ","(or\n  (or\n    (send\n      (lvar :nextChar) :==\n      (str \"-\"))\n    (send\n      (lvar :nextChar) :=~\n      (const nil :RE_NAME_START)))\n  (send nil :valid_escape?\n    (send\n      (lvar :@s current + ) :[]\n      (int 1)\n      (int 2)))) ! ","(or\n  (or\n    (send\n      (lvar :text [] ) :==\n      (str \"-\"))\n    (send\n      (lvar :text [] ) :=~\n      (const nil :RE_NAME_START)))\n  (send nil :valid_escape?\n    (send\n      (lvar :text) :[]\n      (int 1)\n      (int 2)))) ! ","text []  =~ ","text []  == "]}," Crass Tokenizer preprocess":{"type":"method","name":"preprocess","children":[],"call":["input gsub! ","input to_s encode ","input to_s ","input to_s encode  gsub! ","input to_s encode  to_s encode ","input to_s encode  to_s "]}," Crass Tokenizer convert_string_to_number":{"type":"method","name":"convert_string_to_number","children":[],"call":["s * * ","10 ** ","t * ","s * ","i + ","f * ","d -@ ","matches [] to_i ","matches [] ","matches [] == ","matches [] length ","RE_NUMBER_STR  match ","Float MAX  -@ ","value < ","value > ","matches [] to_i  + ","matches [] to_i  * ","matches [] length  -@ ","matchmatches [] to_i s [] to_i ","matches [] to_matches [] to_i  ","RE_NUMBER_STR  match  [] to_i ","matchmatches [] to_i s [] ","RE_NUMBER_STR  match  [] ","matchmatches [] to_i s [] == ","RE_NUMBER_STR  match  [] == ","matchmatches [] to_i s [] lmatches [] to_i ngth ","RE_NUMBER_STR  match  [] length ","valumatches [] to_i  < ","Float MAX  -@  < ","s * *  < ","valumatches [] to_i  > ","Float MAX  -@  > ","s * *  > "]}," Crass Tokenizer consume_url":{"type":"method","name":"consume_url","children":[],"call":[" token ","value << ","value + "," consume_bad_url "," consume_escaped "," valid_escape? ","@s consume ","@s peek == ","@s peek ","@s eos? ","@s scan ","@s eos? ! ","string [] ","string [] + ","string [] == "," consume_string ","@s peek =~ "," create_token ","char + ","next_char == ","String  new ","string []  << ","String  new  << ","string []  + ","String  new  + "," consume_string  [] "," consume_string  [] + "," consume_string  [] == "," consume_ consume_string  ","@s consume  + ","next_@s consume  == ","@s peek  == "]}," Crass Tokenizer consume_unicode_range":{"type":"method","name":"consume_unicode_range","children":[],"call":[" token ","range []= ","range [] ","end_value hex ","range [] << << ","@s scan ","range [] << ","@s consume ","@s peek =~ ","@s peek ","value hex ","value gsub hex ","value gsub ","value include? ","value << ","@s peek == ","value length < ","value length "," create_token ","(or\n  (send\n    (ivar :@s) :scan\n    (const nil :RE_HEX))\n  (str \"\")) hex ","String  new ","@s scan  hex ","end_@s scan  hex ","@s scan  gsub hex ","@s scan  gsub ","@s scan  include? ","@s scan  << ","@s scan  length < ","@s scan  length "]}," Crass Tokenizer consume_string":{"type":"method","name":"consume_string","children":[],"call":[" token ","value << "," consume_escaped ","@s consume ","@s peek "," create_token ","@s reconsume ","@s eos? ","@s current ","ending nil? ","String  new ","String  new  << ","@s current  nil? "]}," Crass Tokenizer consume_numeric":{"type":"method","name":"consume_numeric","children":[],"call":[" token ","number [] ","@s consume ","@s peek == ","@s peek "," consume_name "," start_identifier? "," consume_number "," create_token ","value to_f ","value to_i ","type == "," consume_number  [] "," consume_ consume_number  ","value to_f  to_f ","value to_i  to_f ","number []  to_f ","value to_f  to_i ","value to_i  to_i ","number []  to_i ","number []  == "]}," Crass Tokenizer consume_number":{"type":"method","name":"consume_number","children":[],"call":[" convert_string_to_number ","repr << ","@s scan ","@s consume ","@s peek =~ ","@s peek ","String  new ","String  new  << "]}," Crass Tokenizer consume_name":{"type":"method","name":"consume_name","children":[],"call":["result << ","@s consume ","char == ","@options [] "," consume_escaped "," valid_escape? ","char =~ ","@s peek ","@s scan ","@s reconsume ","@s eos? ","String  new ","String  new  << ","@s peek  == ","@s consume  == ","@s peek  =~ ","@s consume  =~ "]}," Crass Tokenizer consume_ident":{"type":"method","name":"consume_ident","children":[],"call":[" token ","@s consume ","@s peek == ","@s peek "," consume_url ","value downcase == ","value downcase "," consume_name "," create_token ","@s peek =~ "," consume_name  downcase == "," consume_name  downcase "]}," Crass Tokenizer consume_escaped":{"type":"method","name":"consume_escaped","children":[],"call":["@s consume ","codepoint chr ","codepoint > ","codepoint between? ","codepoint == ","hex_str hex ","@s peek =~ ","@s peek ","@s scan ","@s eos? ","hex_str hex  chr ","hex_str hex  > ","hex_str hex  between? ","hex_str hex  == ","@s scan  hex "]}," Crass Tokenizer consume_bad_url":{"type":"method","name":"consume_bad_url","children":[],"call":["text << ","char == ","@s consume "," consume_escaped "," valid_escape? ","@s eos? ","@s current + ","@s peek ","@s current ","String  new ","String  new  << ","@s consume  == "]}," Crass Tokenizer consume":{"type":"method","name":"consume","children":[],"call":[" token ","@s consume ","@s peek == ","@s peek "," consume_ident ","@s reconsume "," consume_unicode_range ","@s peek =~ "," consume_numeric "," valid_escape? ","char + "," consume_name "," start_identifier? "," consume ","@options [] ","@s rest ","text slice! ","@s scan_until "," start_number? "," consume_string ","@s scan ","@s mark ","@s eos? "," create_token ","@s consume_rest ","char to_sym ","nextTwoChars == "," consume_comments ","@s consume  + ","@s rest  slice! ","@s scan_until  slice! ","@s consume_rest  slice! ","@s consume  to_sym ","@s peek  == "]}," Crass Tokenizer initialize":{"type":"method","name":"initialize","children":[],"call":["Scanner  new "," preprocess "]}," Crass TokenScanner reset":{"type":"method","name":"reset","children":[],"call":[]}," Crass TokenScanner reconsume":{"type":"method","name":"reconsume","children":[],"call":["@pos > "]}," Crass TokenScanner consume":{"type":"method","name":"consume","children":[],"call":["@tokens [] "]}," Crass TokenScanner collect":{"type":"method","name":"collect","children":[],"call":["@tokens [] "]}," Crass TokenScanner initialize":{"type":"method","name":"initialize","children":[],"call":[" reset ","tokens to_a "]}," Crass Scanner scan_until":{"type":"method","name":"scan_until","children":[],"call":["@string [] ","@chars [] ","@pos - ","match end ","match nil? ","pattern match ","match size ","@scanner scan_until ","match [] ","match end  - ","pattern match  end ","@scanner scan_until  end ","pattern match  nil? ","@scanner scan_until  nil? ","pattern pattern match  ","pattern @scanner scan_until  ","pattern match  size ","@scanner scan_until  size ","pattern match  [] ","@scanner scan_until  [] "]}," Crass Scanner scan":{"type":"method","name":"scan","children":[],"call":["match [] ","@chars [] ","@pos - ","match end ","match begin != ","match begin ","match nil? ","pattern match ","match size ","@scanner scan ","pattern match  [] ","@scanner scan  [] ","match end  - ","pattern match  end ","@scanner scan  end ","pattern match  begin != ","@scanner scan  begin != ","pattern match  begin ","@scanner scan  begin ","pattern match  nil? ","@scanner scan  nil? ","pattern pattern match  ","pattern @scanner scan  ","pattern match  size ","@scanner scan  size "]}," Crass Scanner reset":{"type":"method","name":"reset","children":[],"call":["@string length ","@chars size ","@string size "]}," Crass Scanner reconsume":{"type":"method","name":"reconsume","children":[],"call":["@pos > ","@scanner unscan "]}," Crass Scanner peek":{"type":"method","name":"peek","children":[],"call":["result join ","@chars [] ","@scanner peek ","@string [] "," pos ","@chars []  join "]}," Crass Scanner marked":{"type":"method","name":"marked","children":[],"call":["result join ","@chars [] ","@pos - ","@string [] ","@chars []  join ","@string []  join "]}," Crass Scanner mark":{"type":"method","name":"mark","children":[],"call":[]}," Crass Scanner eos?":{"type":"method","name":"eos?","children":[],"call":["@pos == "]}," Crass Scanner consume_rest":{"type":"method","name":"consume_rest","children":[],"call":["rest [] ","@string [] ","@scanner rest ","result [] ","@scanner rest  [] "]}," Crass Scanner consume":{"type":"method","name":"consume","children":[],"call":["@chars [] ","@scanner getch ","@pos == ","@pos < "]}," Crass Scanner initialize":{"type":"method","name":"initialize","children":[],"call":[" reset ","@string chars to_a ","@string chars ","input to_s ","input read ","input is_a? ","StringScanner  new ","string chars to_a ","string chars ","input to_s  chars to_a ","input read  chars to_a ","@input to_s  chars to_a ","@input read  chars to_a ","input to_s  chars ","input read  chars ","@input to_s  chars ","@input read  chars "]}," Crass Parser parse_value":{"type":"method","name":"parse_value","children":[],"call":["string strip ","string << "," parse_value ","node [] ","node key? ","node [] is_a? ","nodes each ","nodes is_a? ","String  new ","String  new  strip ","String  new  << "]}," Crass Parser parse_style_rule":{"type":"method","name":"parse_style_rule","children":[],"call":[" create_node "," parse_selector ","rule [] ","children << ","decl [] "," parse_value ","decl [] == "," consume_declarations each "," consume_declarations ","TokenScanner  new ","rule [] [] "]}," Crass Parser parse_selector":{"type":"method","name":"parse_selector","children":[],"call":[" create_node "," parse_value "]}," Crass Parser create_node":{"type":"method","name":"create_node","children":[],"call":["(pair\n  (sym :node)\n  (lvar :type)) merge! "]}," Crass Parser consume_simple_block":{"type":"method","name":"consume_simple_block","children":[],"call":[" create_node ","block [] concat ","block [] << "," consume_component_value ","block [] ","tokens reconsume ","token [] == ","token [] ","tokens consume ","tokens collect ","tokens current ","end_token to_s ","start_token to_s ","BLOCK_END_TOKENS  [] ","tokens current [] ","input reconsume ","input consume ","input collect ","input current ","input current [] ","tokens consume s reconsume ","input consume s reconsume ","tokens consume  [] == ","input consume  [] == ","tokens consume  [] ","input consume  [] ","tokens consume s consume ","input consume s consume ","tokens consume s collect ","input consume s collect ","tokens consume s current ","input consume s current ","end_tokens consume  to_s ","end_input consume  to_s ","BLOCK_END_TOKENS  []  to_s ","start_tokens consume  to_s ","start_input consume  to_s ","tokens current []  to_s ","input current []  to_s ","tokens consume s current [] ","input consume s current [] "]}," Crass Parser consume_rules":{"type":"method","name":"consume_rules","children":[],"call":["rules << "," consume_qualified_rule ","@tokens reconsume "," consume_at_rule ","flags [] ","token [] ","@tokens consume "," consume_qualified_rule s << "," consume_at_rule s << "," consume_qualified_ consume_qualified_rule  "," consume_qualified_ consume_at_rule  ","@@tokens consume s reconsume "," consume_at_ consume_qualified_rule  "," consume_at_ consume_at_rule  ","@tokens consume  [] ","@@tokens consume s consume "]}," Crass Parser consume_qualified_rule":{"type":"method","name":"consume_qualified_rule","children":[],"call":[" create_node ","rule []= ","rule [] << "," consume_component_value ","rule [] ","tokens reconsume "," consume_simple_block ","token [] == ","token [] ","tokens consume ","tokens collect ","input reconsume ","input consume ","input collect "," consume_simple_block [] ","tokens consume s reconsume ","input consume s reconsume ","tokens consume  [] == ","input consume  [] == ","tokens consume  [] ","input consume  [] ","tokens consume s consume ","input consume s consume ","tokens consume s collect ","input consume s collect "]}," Crass Parser consume_function":{"type":"method","name":"consume_function","children":[],"call":[" create_node ","function [] concat ","function [] << "," consume_component_value ","function [] ","tokens reconsume ","token [] ","tokens consume ","tokens collect ","tokens current ","tokens current [] ","input reconsume ","input consume ","input collect ","input current ","input current [] ","tokens consume s reconsume ","input consume s reconsume ","tokens consume  [] ","input consume  [] ","tokens consume s consume ","input consume s consume ","tokens consume s collect ","input consume s collect ","tokens consume s current ","input consume s current ","tokens consume s current [] ","input consume s current [] "]}," Crass Parser consume_declarations":{"type":"method","name":"consume_declarations","children":[],"call":[" consume_component_value ","token [] != ","token [] ","declarations << "," consume_declaration ","TokenScanner  new ","tokens consume ","tokens current [] == ","tokens current [] ","tokens current ","decl_tokens << "," consume_at_rule ","input consume ","input current [] == ","input current [] ","input current ","input reconsume ","next_token [] == ","next_token [] ","input peek "," create_node ","options [] "," consume_component_value  [] != ","tokens consume  [] != ","input consume  [] != "," consume_component_value  [] ","tokens consume  [] ","input consume  [] "," consume_declaration arations << "," consume_ consume_declaration aration "," consume_component_value s consume ","tokens consume s consume ","input consume s consume "," consume_component_value s current [] == ","tokens consume s current [] == ","input consume s current [] == "," consume_component_value s current [] ","tokens consume s current [] ","input consume s current [] "," consume_component_value s current ","tokens consume s current ","input consume s current ","decl_ consume_component_value s << ","decl_tokens consume s << ","decl_input consume s << "," consume_declaration _tokens << ","next_ consume_component_value  [] == ","next_tokens consume  [] == ","next_input consume  [] == ","input peek  [] == ","next_ consume_component_value  [] ","next_tokens consume  [] ","next_input consume  [] ","input peek  [] "]}," Crass Parser consume_declaration":{"type":"method","name":"consume_declaration","children":[],"call":[" create_node ","declaration []= ","maybe_important [] [] downcase == ","maybe_important [] [] downcase ","maybe_important [] [] ","maybe_important [] ","maybe_important [] [] == ","(send\n  (lvar :value) :reject) [] ","v [] == ","v [] ","value reject ","value << ","tokens consume ","token [] != ","token [] ","token [] == ","tokens consume [] ","tokens collect ","input consume ","input consume [] ","input collect ","value slice! ","pos - ","prev_token [] == ","prev_token [] ","value [] ","token [] downcase == ","token [] downcase ","type == ","token ! ","value size - ","value size ","value index ","important_tokens [] ","important_tokens [] [] downcase == ","important_tokens [] [] downcase ","important_tokens [] [] ","important_tokens [] [] == ","important_tokens size == ","important_tokens size ","(send\n  (lvar :value) :reject) last ","node == "," consume_component_value ","input peek nil? ","input peek ","next_token [] == ","next_token [] "," create_token []  ","(send\n  (lvar :value) :reject) []  [] [] downcase == ","(send\n  (lvar :value) :reject) []  [] [] downcase ","(send\n  (lvar :value) :reject) []  [] [] ","(send\n  (lvar :value) :reject) []  [] ","(send\n  (lvar :value) :reject) []  [] [] == ","tokens consume s consume ","input consume s consume ","value [] s consume ","tokens consume  [] != ","input consume  [] != ","value []  [] != ","tokens consume  [] ","input consume  [] ","value []  [] ","tokens consume  [] == ","input consume  [] == ","value []  [] == ","tokens consume s consume [] ","input consume s consume [] ","value [] s consume [] ","tokens consume s collect ","input consume s collect ","value [] s collect ","prev_tokens consume  [] == ","prev_input consume  [] == ","prev_value []  [] == ","prev_tokens consume  [] ","prev_input consume  [] ","prev_value []  [] ","tokens consume  [] downcase == ","input consume  [] downcase == ","value []  [] downcase == ","tokens consume  [] downcase ","input consume  [] downcase ","value []  [] downcase ","token []  == ","tokens consume  ! ","input consume  ! ","value []  ! ","important_tokens consume s [] ","important_input consume s [] ","important_value [] s [] ","(send\n  (lvar :value) :reject) last  [] ","important_tokens consume s [] [] downcase == ","important_input consume s [] [] downcase == ","important_value [] s [] [] downcase == ","(send\n  (lvar :value) :reject) last  [] [] downcase == ","important_tokens consume s [] [] downcase ","important_input consume s [] [] downcase ","important_value [] s [] [] downcase ","(send\n  (lvar :value) :reject) last  [] [] downcase ","important_tokens consume s [] [] ","important_input consume s [] [] ","important_value [] s [] [] ","(send\n  (lvar :value) :reject) last  [] [] ","important_tokens consume s [] [] == ","important_input consume s [] [] == ","important_value [] s [] [] == ","(send\n  (lvar :value) :reject) last  [] [] == ","important_tokens consume s size == ","important_input consume s size == ","important_value [] s size == ","(send\n  (lvar :value) :reject) last  size == ","important_tokens consume s size ","important_input consume s size ","important_value [] s size ","(send\n  (lvar :value) :reject) last  size ","next_tokens consume  [] == ","next_input consume  [] == ","next_value []  [] == ","input peek  [] == ","next_tokens consume  [] ","next_input consume  [] ","next_value []  [] ","input peek  [] "]}," Crass Parser consume_component_value":{"type":"method","name":"consume_component_value","children":[],"call":[" consume_function "," consume_simple_block ","token [] ","tokens consume ","input consume ","token key? ","tokens consume  [] ","input consume  [] ","tokens consume s consume ","input consume s consume ","tokens consume  key? ","input consume  key? "]}," Crass Parser consume_at_rule":{"type":"method","name":"consume_at_rule","children":[],"call":[" create_node ","rule []= ","rule [] << "," consume_component_value ","rule [] ","tokens reconsume "," consume_simple_block ","token [] ","tokens consume ","tokens collect ","input reconsume ","input consume "," parse_value ","input collect ","token [] == ","input consume [] "," consume_simple_block [] ","node == ","node === "," create_token []  ","tokens consume s reconsume ","input consume s reconsume ","tokens consume  [] ","input consume  [] ","tokens consume s consume ","input consume s consume ","tokens consume s collect ","input consume s collect ","tokens consume  [] == ","input consume  [] == ","token []  == ","token []  === "]}," Crass Parser initialize":{"type":"method","name":"initialize","children":[],"call":["TokenScanner  new ","Tokenizer  tokenize ","input kind_of? ","Tokenizer  tokenize  kind_of? "]}," Crass Parser stringify":{"type":"method","name":"stringify","children":[],"call":[]}," Crass Parser parse_stylesheet":{"type":"method","name":"parse_stylesheet","children":[],"call":[]}," Crass Parser create_style_rule":{"type":"method","name":"create_style_rule","children":[],"call":[" create_node "," create_selector ","rule [] ","children << ","decl [] "," parse_value ","decl [] == "," consume_declarations each "," consume_declarations ","TokenScanner  new ","rule [] [] "," parse_properties "]}," Crass Parser create_selector":{"type":"method","name":"create_selector","children":[],"call":[" create_node "," parse_value "]}," Crass parse_properties":{"type":"method","name":"parse_properties","children":[],"call":[]}," Crass Tokenizer create_token":{"type":"method","name":"create_token","children":[],"call":["(pair\n  (sym :node)\n  (lvar :type)) merge! ","@s marked ","@s marker "]}," Crass string":{"type":"method","name":"string","children":[],"call":["@scanner string "]}," Crass Parser parse_properties":{"type":"method","name":"parse_properties","children":[],"call":["properties << "," create_node ","decl [] ","decl [] == "," parse_value "," consume_declarations each "," consume_declarations ","TokenScanner  new ","input is_a? ","children pop ","children last [] == ","children last [] ","children last ","decl [] dup "," parse_declarations each "," parse_declarations ","TokenScanner  new  is_a? ","decl [] dup  pop ","decl [] dup  last [] == ","decl [] dup  last [] ","decl [] dup  last "]}," Crass Parser parse_rules":{"type":"method","name":"parse_rules","children":[],"call":[]}," Crass Tokenizer consume_comments":{"type":"method","name":"consume_comments","children":[],"call":[" create_token ","@s consume_rest ","text slice! ","@s scan_until ","@s consume ","@s peek == ","@s peek ","@s consume_rest  slice! ","@s scan_until  slice! "]}," Crass TokenScanner peek":{"type":"method","name":"peek","children":[],"call":["@tokens [] "]}," Crass Parser parse_rule":{"type":"method","name":"parse_rule","children":[],"call":[" create_node ","input peek nil? ","input peek ","input consume ","input peek [] == ","input peek [] "," consume_qualified_rule "," consume_at_rule ","TokenScanner  new ","input is_a? ","TokenScanner  new  peek nil? ","TokenScanner  new  peek ","TokenScanner  new  consume ","TokenScanner  new  peek [] == ","TokenScanner  new  peek [] "," consume_qualified_ consume_qualified_rule  "," consume_qualified_ consume_at_rule  "," consume_at_ consume_qualified_rule  "," consume_at_ consume_at_rule  ","TokenScanner  new  is_a? "]}," Crass Parser parse_declarations":{"type":"method","name":"parse_declarations","children":[],"call":[" consume_declarations ","TokenScanner  new ","input is_a? ","TokenScanner  new  is_a? "]}," Crass Parser parse_declaration":{"type":"method","name":"parse_declaration","children":[],"call":[" create_node "," consume_declaration ","input peek [] != ","input peek [] ","input peek ","input peek nil? ","input consume ","input peek [] == ","TokenScanner  new ","input is_a? "," consume_ consume_declaration aration ","TokenScanner  new  peek [] != ","TokenScanner  new  peek [] ","TokenScanner  new  peek ","TokenScanner  new  peek nil? ","TokenScanner  new  consume ","TokenScanner  new  peek [] == ","TokenScanner  new  is_a? "]}," Crass Parser parse_component_values":{"type":"method","name":"parse_component_values","children":[],"call":["tokens << "," consume_component_value ","TokenScanner  new ","input is_a? "," consume_component_value s << ","TokenScanner  new  is_a? "]}," Crass Parser parse_component_value":{"type":"method","name":"parse_component_value","children":[],"call":[" create_node ","input peek nil? ","input peek ","input consume ","input peek [] == ","input peek [] "," consume_component_value ","TokenScanner  new ","input is_a? ","TokenScanner  new  peek nil? ","TokenScanner  new  peek ","TokenScanner  new  consume ","TokenScanner  new  peek [] == ","TokenScanner  new  peek [] "," consume_component_ consume_component_value  ","TokenScanner  new  is_a? "]}}