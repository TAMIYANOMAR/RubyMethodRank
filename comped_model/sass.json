{" Sass compile_file":{"type":"method","name":"compile_file","children":[],"call":[]}," Sass compile":{"type":"method","name":"compile","children":[],"call":[]}," Sass Version revision_number":{"type":"method","name":"revision_number","children":[],"call":["ref == ","l strip split ","l strip ","f each ","File  open ","File  exists? ","File  read strip ","File  read "," scope ","rev =~ ","rev == ","Sass Util  scope ","File  exist? ","File  read strip  =~ ","File  read strip  == "]}," Sass Version version":{"type":"method","name":"version","children":[],"call":["@@version [] << ","@@version [] ","@@version [] << << ","rev [] ","rev [] == ","@@version []= "," revision_number ","@@version [] dup ","numbers join ","numbers [] ","numbers [] is_a? ","File  read strip ","File  read "," scope ","n to_i ","n =~ ","File  read strip split map ","File  read strip split "," version_date ","Sass Util  scope "," revision_number  [] "," revision_number  [] == ","  revision_number ision_number "," version_ version_date  "]}," Sass Util lcs_backtrace":{"type":"method","name":"lcs_backtrace","children":[],"call":[" lcs_backtrace ","i - ","j - ","c [] [] > ","c [] [] ","c [] "," lcs_backtrace << ","y [] ","x [] ","j == ","i == ","(send nil :lcs_backtrace\n  (lvar :c)\n  (lvar :x)\n  (lvar :y)\n  (send\n    (lvar :i) :-\n    (int 1))\n  (send\n    (lvar :j) :-\n    (int 1))) << "]}," Sass Util lcs_table":{"type":"method","name":"lcs_table","children":[],"call":["c [] []= ","(send\n  (send\n    (lvar :c) :[]\n    (lvar :i)) :[]\n  (send\n    (lvar :j) :-\n    (int 1))) max ","c [] [] ","c [] ","i - ","j - ","c [] [] + ","y [] ","x [] ","(erange\n  (int 1)\n  (send\n    (lvar :y) :size)) each ","y size ","(erange\n  (int 1)\n  (send\n    (lvar :x) :size)) each ","x size ","y size times ","x size times ","Array  new "]}," Sass Util StaticConditionalContext method_missing":{"type":"method","name":"method_missing","children":[],"call":["@set include? ","block nil? ","args empty? "," block_given? ! "," block_given? "]}," Sass Util StaticConditionalContext initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Util inspect_obj":{"type":"method","name":"inspect_obj","children":[],"call":["\" + + ","\" + ","s inspect [] ","s inspect ","obj gsub ","obj inspect ","obj is_a? ",": + "," inspect_obj ","obj to_s "," version_geq "]}," Sass Util set_eql?":{"type":"method","name":"set_eql?","children":[],"call":["(send\n  (send\n    (send\n      (lvar :set1) :to_a) :uniq) :sort_by) eql? ","e hash ","set2 to_a uniq sort_by ","set2 to_a uniq ","set2 to_a ","set1 to_a uniq sort_by ","set1 to_a uniq ","set1 to_a ","set1 eql? "," ruby1_8_6? "]}," Sass Util set_hash":{"type":"method","name":"set_hash","children":[],"call":["(send\n  (lvar :set) :map) uniq sort hash ","(send\n  (lvar :set) :map) uniq sort ","(send\n  (lvar :set) :map) uniq ","e hash ","set map ","set hash "," ruby1_8_6? "]}," Sass Util flatten":{"type":"method","name":"flatten","children":[],"call":["res << ","res concat "," flatten ","n - ","e is_a? ","arr inject ","n == ","arr flatten "," ruby1_8_6? "]}," Sass Util ord":{"type":"method","name":"ord","children":[],"call":["c ord ","c [] "," ruby1_8? "]}," Sass Util enum_slice":{"type":"method","name":"enum_slice","children":[],"call":["enum each_slice ","enum enum_slice "," ruby1_8? "]}," Sass Util enum_cons":{"type":"method","name":"enum_cons","children":[],"call":["enum each_cons ","enum enum_cons "," ruby1_8? "]}," Sass Util enum_with_index":{"type":"method","name":"enum_with_index","children":[],"call":["enum each_with_index ","enum enum_with_index "," ruby1_8? "]}," Sass Util has?":{"type":"method","name":"has?","children":[],"call":["klass send include? ","method to_sym ","method to_s "," ruby1_8? ","klass send "]}," Sass Util _enc":{"type":"method","name":"_enc","children":[],"call":["string encode force_encoding ","string encode "]}," Sass Util check_sass_encoding":{"type":"method","name":"check_sass_encoding","children":[],"call":["str encoding ","str encode "," check_encoding ","str force_encoding ","charset << ","Encoding  find ","charset + ","encoding [] ","charset force_encoding encode ","charset force_encoding ","bin =~ ","Sass Util CHARSET_REGEXPS  [] ","Sass Util ENCODINGS_TO_CHECK  find ","str dup force_encoding ","str dup "," ruby1_8? "," find_encoding_error ","str encode gsub tr ","str encode gsub ","str valid_encoding? ","str encoding name == ","str encoding name ","binary force_encoding ","encoding name == ","encoding name ","charset downcase == ","charset downcase "," ruby1_9_2? ","1 force_encoding ","binary =~ ","binary slice! ","UTF_16LE_BOM  length ","binary start_with? ","UTF_16BE_BOM  length ","UTF_8_BOM  length ","str gsub gsub ","str gsub "," check_encoding  encoding ","str force_encoding  encoding ","binary force_encoding  encoding ","str Encoding  find  "," check_encoding  encode ","str force_encoding  encode ","binary force_encoding  encode "," check_Encoding  find  "," check_encoding  force_encoding ","str force_encoding  force_encoding ","binary force_encoding  force_encoding ","str force_Encoding  find  ","charset force_encoding encode  << ","1 force_encoding  << ","charset force_encoding encode  + ","1 force_encoding  + ","Encoding  find  [] ","charset force_encoding encode  force_encoding encode ","1 force_encoding  force_encoding encode ","charset force_Encoding  find  encode ","charset force_encoding encode  force_encoding ","1 force_encoding  force_encoding ","charset force_Encoding  find  ","str dup force_encoding  =~ "," check_encoding  dup force_encoding ","str force_encoding  dup force_encoding ","binary force_encoding  dup force_encoding ","str dup force_Encoding  find  "," check_encoding  dup ","str force_encoding  dup ","binary force_encoding  dup "," find_Encoding  find _error "," check_encoding  encode gsub tr ","str force_encoding  encode gsub tr ","binary force_encoding  encode gsub tr "," check_encoding  encode gsub ","str force_encoding  encode gsub ","binary force_encoding  encode gsub "," check_encoding  valid_encoding? ","str force_encoding  valid_encoding? ","binary force_encoding  valid_encoding? ","str valid_Encoding  find ? "," check_encoding  encoding name == ","str force_encoding  encoding name == ","binary force_encoding  encoding name == ","str Encoding  find  name == "," check_encoding  encoding name ","str force_encoding  encoding name ","binary force_encoding  encoding name ","str Encoding  find  name ","str dup force_encoding ary force_encoding ","binary force_Encoding  find  ","str dup force_encoding  force_encoding ","Encoding  find  name == ","Encoding  find  name ","charset force_encoding encode  downcase == ","1 force_encoding  downcase == ","charset force_encoding encode  downcase ","1 force_encoding  downcase ","1 force_Encoding  find  ","str dup force_encoding ary =~ ","str dup force_encoding ary slice! ","str dup force_encoding  slice! ","str dup force_encoding ary start_with? ","str dup force_encoding  start_with? "," check_encoding  gsub gsub ","str force_encoding  gsub gsub ","binary force_encoding  gsub gsub "," check_encoding  gsub ","str force_encoding  gsub ","binary force_encoding  gsub "]}," Sass Util check_encoding":{"type":"method","name":"check_encoding","children":[],"call":["i + ","(str \"Invalid \") rstrip ","e error_char dump ","e error_char ","encoding name ","line encode ","str force_encoding split each_with_index ","str force_encoding split ","str force_encoding ","Regexp  new ","\r\n|\r|\n encode force_encoding ","\r\n|\r|\n encode ","str encoding ","str gsub ","\\Aï»¿ encode ","str encoding name ","str encoding name =~ ","str valid_encoding? "," ruby1_8? "," undefined_conversion_error_char ","str encoding  name ","str force_str encoding  split each_with_index ","str force_str encoding  split ","str force_str encoding  ","\r\n|\r|\n encode force_str encoding  ","str str encoding  ","str str encoding  name ","str str encoding  name =~ ","str valid_str encoding ? "]}," Sass Util ruby1_8_6?":{"type":"method","name":"ruby1_8_6?","children":[],"call":["Sass Util RUBY_VERSION  [] < ","Sass Util RUBY_VERSION  [] "," ruby1_8? ","RUBY_VERSION_COMPONENTS  [] < ","RUBY_VERSION_COMPONENTS  [] "]}," Sass Util ruby1_8?":{"type":"method","name":"ruby1_8?","children":[],"call":["Sass Util RUBY_VERSION  [] < ","Sass Util RUBY_VERSION  [] ","Sass Util RUBY_VERSION  [] == "," ironruby? ","RUBY_VERSION_COMPONENTS  [] < ","RUBY_VERSION_COMPONENTS  [] ","RUBY_VERSION_COMPONENTS  [] == "]}," Sass Util ironruby?":{"type":"method","name":"ironruby?","children":[],"call":["RUBY_ENGINE  == "]}," Sass Util windows?":{"type":"method","name":"windows?","children":[],"call":["RbConfig CONFIG  [] =~ ","RbConfig CONFIG  [] "]}," Sass Util av_template_class":{"type":"method","name":"av_template_class","children":[],"call":["ActionView Template  const_get ","name to_s ","ActionView  const_get ","ActionView  const_defined? "]}," Sass Util ap_geq?":{"type":"method","name":"ap_geq?","children":[],"call":[" version_geq "]}," Sass Util ap_geq_3?":{"type":"method","name":"ap_geq_3?","children":[],"call":[" ap_geq? "]}," Sass Util rails_env":{"type":"method","name":"rails_env","children":[],"call":["RAILS_ENV  to_s "," Rails  env to_s "," Rails  env "]}," Sass Util rails_root":{"type":"method","name":"rails_root","children":[],"call":["RAILS_ROOT  to_s "," raise "," Rails  root to_s "," Rails  root "]}," Sass Util sass_warn":{"type":"method","name":"sass_warn","children":[],"call":[" warn ","Sass  logger warn ","Sass  logger ","msg + "," ruby1? ","msg +  + "]}," Sass Util silence_sass_warnings":{"type":"method","name":"silence_sass_warnings","children":[],"call":["Sass  logger log_level= ","Sass  logger ","Sass  logger log_level "]}," Sass Util silence_warnings":{"type":"method","name":"silence_warnings","children":[],"call":["StringIO  new "]}," Sass Util abstract":{"type":"method","name":"abstract","children":[],"call":[" raise ","NotImplementedError  new "," caller_info [] "," caller_info ","obj class "]}," Sass Util version_geq":{"type":"method","name":"version_geq","children":[],"call":[" version_gt ! "," version_gt "]}," Sass Util version_gt":{"type":"method","name":"version_gt","children":[],"call":["p1 > ","p1 == ","release2 ! ","release1 ! ","p2 to_i ","p1 to_i ","p2 =~ ","p1 =~ ","Array  new zip ","v2 split ","v1 split ","Array  new ","(send\n  (lvar :v1) :length) max ","v2 length ","v1 length ","p2 =~  ! ","p1 =~  ! "]}," Sass Util caller_info":{"type":"method","name":"caller_info","children":[],"call":["info [] sub! ","info [] ","info []= ","info [] to_i ","entry scan first ","entry scan "," caller [] "," caller ","entry scan first  [] sub! ","entry scan first  [] ","entry scan first  []= ","entry scan first  [] to_i "]}," Sass Util lcs":{"type":"method","name":"lcs","children":[],"call":[" lcs_backtrace ","y size - ","y size ","x size - ","x size "," lcs_table ","a == "," proc "]}," Sass Util paths":{"type":"method","name":"paths","children":[],"call":[" flatten ","path + ","paths map ","arr map ","arrs inject ","(send\n  (lvar :arr) :map) flatten "]}," Sass Util strip_string_array":{"type":"method","name":"strip_string_array","children":[],"call":["arr last rstrip! ","arr last ","arr last is_a? ","arr first lstrip! ","arr first ","arr first is_a? ","arr []= ","Sass Util  rstrip_except_escapes ","arr [] "]}," Sass Util substitute":{"type":"method","name":"substitute","children":[],"call":["res []= ","i + ","from size ","res [] == ","res [] ","i < ","res size ","ary dup ","ary dup  []= ","ary dup  [] == ","ary dup  [] ","ary dup  size "]}," Sass Util intersperse":{"type":"method","name":"intersperse","children":[],"call":["(send\n  (lvar :enum) :inject\n  (array)) [] ","a << << ","a << ","enum inject "]}," Sass Util merge_adjacent_strings":{"type":"method","name":"merge_adjacent_strings","children":[],"call":["a << ","e dup ","a last << ","a last ","a last is_a? ","e is_a? ","arr inject ","arr size < ","arr size ","enum inject "]}," Sass Util restrict":{"type":"method","name":"restrict","children":[],"call":["(send\n  (array\n    (lvar :value)\n    (send\n      (lvar :range) :first)) :max) min ","range last ","(lvar :value) max ","range first "]}," Sass Util powerset":{"type":"method","name":"powerset","children":[],"call":["new_powerset << ","subset + ","powerset each ","Set  new ","arr inject ","(send\n  (const nil :Set) :new) to_set ","Set  new  << "]}," Sass Util map_hash":{"type":"method","name":"map_hash","children":[],"call":[" to_hash ","hash map ","rv []= ","hash denormalize ","new_key == ","hash is_a? ","hash each ","hash class new ","hash class ","rv delete ","hash class new  []= ","hash denormalize  == ","hash class new  delete "]}," Sass Util map_vals":{"type":"method","name":"map_vals","children":[],"call":[" to_hash ","hash map ","rv []= ","hash each ","hash as_stored ","hash is_a? ","hash class new ","hash class "," to_hash as_stored  ","hash as_stored  map ","hash class new  []= ","hash as_stored  each ","hash as_stored  as_stored ","hash as_stored  is_a? ","hash as_stored  class new ","hash as_stored  class "]}," Sass Util map_keys":{"type":"method","name":"map_keys","children":[],"call":[" to_hash ","hash map "," map_hash "]}," Sass Util to_hash":{"type":"method","name":"to_hash","children":[],"call":["Hash  [] ","arr compact ","h []= ","arr compact inject "," ordered_hash "]}," Sass Util scope":{"type":"method","name":"scope","children":[],"call":["File  join "]}," Sass Util SubsetMap []":{"type":"method","name":"[]","children":[],"call":[" get map "," get "]}," Sass Util SubsetMap get":{"type":"method","name":"get","children":[],"call":["@vals [] ","res map! ","res sort! ","res uniq! ","res compact! ","Sass Util  flatten ","subset subset? ","subsets map ","@hash [] ","set map ","(send\n  (lvar :set) :map) flatten ","Sass Util  flatten  map! ","(send\n  (lvar :set) :map) flatten  map! ","Sass Util  flatten  sort! ","(send\n  (lvar :set) :map) flatten  sort! ","Sass Util  flatten  uniq! ","(send\n  (lvar :set) :map) flatten  uniq! ","Sass Util  flatten  compact! ","(send\n  (lvar :set) :map) flatten  compact! ","@hash []  map "]}," Sass Util SubsetMap []=":{"type":"method","name":"[]=","children":[],"call":["@hash [] << ","set to_set ","@hash [] ","set each ","@vals << ","@vals size "," raise ","ArgumentError  new ","set empty? "]}," Sass Util SubsetMap empty?":{"type":"method","name":"empty?","children":[],"call":["@hash empty? "]}," Sass Util SubsetMap initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree WhileNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree WarnNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," ToCss debug_info_rule":{"type":"method","name":"debug_info_rule","children":[],"call":["node options= ","options merge ","node << ","rule << ","prop resolved_value= ","Sass SCSS RX  escape_ident ","v to_s ","prop resolved_name= ","Sass Tree PropNode  new ","rule resolved_rules= ","Sass Selector CommaSequence  new ","Sass Selector Sequence  new ","Sass Selector SimpleSequence  new ","Sass Selector Element  new ","k to_s gsub ","k to_s ","Sass Tree RuleNode  new ","(send\n  (lvar :debug_info) :map) sort each ","(send\n  (lvar :debug_info) :map) sort ","debug_info map ","Sass Tree DirectiveNode  new ","Sass Script String  new ","Sass Util  hash_to_a each ","Sass Util  hash_to_a ","Sass Tree DirectiveNode  resolved ","Sass Script Value String  new ","(send\n  (lvar :debug_info) :map) to_a each ","(send\n  (lvar :debug_info) :map) to_a ","Sass Tree DirectiveNode  new  options= ","Sass Tree DirectiveNode  resolved  options= ","Sass Tree DirectiveNode  new  << ","Sass Tree DirectiveNode  resolved  << ","Sass Tree RuleNode  new  << ","Sass Tree PropNode  new  resolved_value= ","Sass Tree PropNode  new  resolved_name= ","Sass Tree RuleNode  new  resolved_Sass Tree RuleNode  new s= "]}," ToCss visit_rule":{"type":"method","name":"visit_rule","children":[],"call":["to_return << ","node group_end ","\n + ","node style == ","node style ","(send\n  (send\n    (lvar :node) :children) :map) join "," visit ","node children map ","node children "," with_tabs ","@tabs + ","node filename ","Pathname  new relative_path_from to_s ","Pathname  new relative_path_from ","Pathname  new ","File  dirname ","node options [] ","node options ","node line ","to_return << << "," debug_info_rule ","node debug_info ","node style != ","   * ","total_indent << ","joined_rules gsub! ","joined_rules sub! ","(send\n  (send\n    (send\n      (lvar :node) :resolved_rules) :members) :map) join ","rule_part gsub! ","seq to_a join ","seq to_a ","node resolved_rules members map ","node resolved_rules members ","node resolved_rules ","(sym :nested) include? ","node tabs ","total_indent + ","(send\n  (send\n    (send\n      (block\n        (send\n          (send\n            (send\n              (lvar :node) :resolved_rules) :members) :map)\n        (args\n          (arg :seq))\n        (send\n          (send\n            (send\n              (lvar :seq) :to_a) :join) :gsub\n          (regexp\n            (str \"([^,])\\\\n\")\n            (regopt :m))\n          (if\n            (send\n              (send\n                (lvar :node) :style) :==\n              (sym :compressed))\n            (str \"\\\\1 \")\n            (str \"\\\\1\\n\")))) :join\n      (lvar :rule_separator)) :split\n    (str \"\\n\")) :map) join ","per_rule_indent + ","line strip ","(send\n  (send\n    (send\n      (lvar :node) :resolved_rules) :members) :map) join split map ","(send\n  (send\n    (send\n      (lvar :node) :resolved_rules) :members) :map) join split ","seq to_a join gsub ","node stack_trace join ","node stack_trace ","@in_directive ! ","rule_part strip! ","(send\n  (send\n    (send\n      (lvar :node) :resolved_rules) :members) :map) compact join ","(send\n  (send\n    (send\n      (lvar :node) :resolved_rules) :members) :map) compact ","seq has_placeholder? "," output ","} + ","i > ","node children each_with_index "," for_node ","Sass Util  pathname relative_path_from to_s ","Sass Util  pathname relative_path_from ","Sass Util  pathname ","node stack_trace gsub ","joined_rules lstrip! ","seq to_s ","Sass Util  relative_path_from to_s ","Sass Util  relative_path_from "," erase! "," ends_with? ","separator start_with? "," trailing_semicolon? ","match tr ","seq invisible? ","Sass Util  strip_except_escapes "," with_@tabs +  ","@@tabs +  + ","(send\n  (send\n    (send\n      (lvar :node) :resolved_rules) :members) :map) join  gsub! ","(send\n  (send\n    (send\n      (lvar :node) :resolved_rules) :members) :map) compact join  gsub! ","(send\n  (send\n    (send\n      (lvar :node) :resolved_rules) :members) :map) join  sub! ","(send\n  (send\n    (send\n      (lvar :node) :resolved_rules) :members) :map) compact join  sub! ","seq to_a join  gsub! ","seq to_s  gsub! ","Sass Util  strip_except_escapes  gsub! ","node @tabs +  ","per_   *  + ","seq to_a join  strip! ","seq to_s  strip! ","Sass Util  strip_except_escapes  strip! ","(send\n  (send\n    (send\n      (lvar :node) :resolved_rules) :members) :map) join  lstrip! ","(send\n  (send\n    (send\n      (lvar :node) :resolved_rules) :members) :map) compact join  lstrip! "]}," ToCss visit_prop":{"type":"method","name":"visit_prop","children":[],"call":["node important ","node resolved_value ","node resolved_name ","node style == ","node style ","   * ","@tabs + ","node tabs ","node resolved_value empty? "," output "," for_node "," format_custom_property_value ","node custom_property? ","node custom_property? ! "]}," ToCss visit_media":{"type":"method","name":"visit_media","children":[],"call":["str gsub! ","node group_end ","node style == ","node style "," visit_directive "," with_tabs ","@tabs + ","node tabs "," output "," erase! ","@result [] != ","@result [] ","node style != "]}," ToCss visit_directive":{"type":"method","name":"visit_directive","children":[],"call":["result rstrip + ","(if\n  (send\n    (send\n      (lvar :node) :style) :==\n    (sym :expanded))\n  (str \"\\n\")\n  (str \" \")) + ","node style == ","node style ","result rstrip ","result << ","(send nil :with_tabs\n  (send\n    (ivar :@tabs) :+\n    (int 1))) + "," visit "," with_tabs ","@tabs + ","child is_a? ","result << << ","rendered rstrip + ","rendered rstrip ","rendered lstrip "," visit dup ","result []= ","child invisible? ","node children each ","node children ","(begin\n  (send\n    (str \"  \") :*\n    (ivar :@tabs))) + ","node value ","   * ","node value + ","node children empty? ","node has_children ","node is_a? ! ","node is_a? ","(begin\n  (lvar :tab_str)) + ","tab_str + + ","tab_str + ","node resolved_value ","node resolved_value + "," output ","node style != "," rstrip! "," lstrip "," erase! "," for_node ","node has_children ! ","child has_children ","had_children ! "," ends_with? "," trailing_semicolon? ","(begin\n  (send\n    (str \"  \") :*\n    (ivar :@tabs))) +  rstrip + ","(begin\n  (lvar :tab_str)) +  rstrip + ","(begin\n  (send\n    (str \"  \") :*\n    (ivar :@tabs))) +  rstrip ","(begin\n  (lvar :tab_str)) +  rstrip ","(begin\n  (send\n    (str \"  \") :*\n    (ivar :@tabs))) +  << ","(begin\n  (lvar :tab_str)) +  << ","(begin\n  (send\n    (str \"  \") :*\n    (ivar :@tabs))) +  << << ","(begin\n  (lvar :tab_str)) +  << << ","rendered lstrip  rstrip + ","rendered lstrip  rstrip ","rendered lstrip  lstrip ","(begin\n  (send\n    (str \"  \") :*\n    (ivar :@tabs))) +  []= ","(begin\n  (lvar :tab_str)) +  []= ","(begin\n  (lvar :   * )) + ","   *  + + ","   *  + ","child has_children  ! "]}," ToCss visit_comment":{"type":"method","name":"visit_comment","children":[],"call":["content gsub! ","node loud ! ","node loud ","node style == ","node style ","content =~ ","Sass Util  sass_warn ","node filename ","node line ","node value gsub gsub ","node value gsub ","node value ","   * ","(send\n  (ivar :@tabs) :-\n  (send\n    (send\n      (send\n        (lvar :node) :value) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","@tabs - ","node value [] size ","node value [] ","node invisible? ","node resolved_value gsub gsub ","node resolved_value gsub ","node resolved_value ","(send\n  (ivar :@tabs) :-\n  (send\n    (send\n      (send\n        (lvar :node) :resolved_value) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","node resolved_value [] size ","node resolved_value [] ","node silent ","node type != ","node type ","node type == "," output "," for_node ","node resolved_value split join ","\n + ","node resolved_value split ","node value gsub  gsub! ","node resolved_value gsub  gsub! ","node resolved_value split join  gsub! ","node value gsub  =~ ","node resolved_value gsub  =~ ","node resolved_value split join  =~ "]}," ToCss visit_charset":{"type":"method","name":"visit_charset","children":[],"call":["node name "," output "," for_node "]}," ToCss visit_root":{"type":"method","name":"visit_root","children":[],"call":[" raise ","node template ","e sass_template ","(str \"@charset \\\"\") encode + ","(str \"@charset \\\"\") encode ","result encoding ","node style == ","node style ","result encoding name ","result encode ","Encoding  find ","encoding << ","encoding =~ ","node children first name ","node children first ","node children ","node children first is_a? ","result ascii_only? ","Sass Util  ruby1_8? ","result << ","result empty? ","result rstrip! ","child_str + "," visit ","child invisible? ","node children each ","String  new "," prepend! ","@result encoding ","@result encoding name ","@result encode ","@result ascii_only? "," output ","@result empty? "," rstrip! ","child bubbles? ! ","child bubbles? ","child has_children ","child is_a? "," erase! "," ends_with? "," trailing_semicolon? ","(str \"@charset \\\"\") encode +  encoding ","result encode  encoding ","String  new  encoding ","result node children first name  ","(str \"@charset \\\"\") encode +  encoding name ","result encode  encoding name ","String  new  encoding name ","result node children first name  name ","(str \"@charset \\\"\") encode +  encode ","result encode  encode ","String  new  encode ","node children first name  << ","node children first name  =~ ","(str \"@charset \\\"\") encode +  ascii_only? ","result encode  ascii_only? ","String  new  ascii_only? ","(str \"@charset \\\"\") encode +  << ","result encode  << ","String  new  << ","(str \"@charset \\\"\") encode +  empty? ","result encode  empty? ","String  new  empty? ","(str \"@charset \\\"\") encode +  rstrip! ","result encode  rstrip! ","String  new  rstrip! "," visit  + ","@(str \"@charset \\\"\") encode +  encoding ","@result encode  encoding ","@String  new  encoding ","@result node children first name  ","@(str \"@charset \\\"\") encode +  encoding name ","@result encode  encoding name ","@String  new  encoding name ","@result node children first name  name ","@(str \"@charset \\\"\") encode +  encode ","@result encode  encode ","@String  new  encode ","@(str \"@charset \\\"\") encode +  ascii_only? ","@result encode  ascii_only? ","@String  new  ascii_only? ","@(str \"@charset \\\"\") encode +  empty? ","@result encode  empty? ","@String  new  empty? "]}," ToCss with_tabs":{"type":"method","name":"with_tabs","children":[],"call":[]}," ToCss visit":{"type":"method","name":"visit","children":[],"call":[" raise ","e modify_backtrace ","node line ","node filename "]}," ToCss initialize":{"type":"method","name":"initialize","children":[],"call":["Sass Source Map  new ","String  new "]}," Perform handle_include_loop!":{"type":"method","name":"handle_include_loop!","children":[],"call":[" raise ","Sass SyntaxError  new ","msg << << ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (lvar :mixins)\n    (int 2)) :map) join ","Sass Util  enum_cons map ","Sass Util  enum_cons ","msg << ","mixins << ","node name ","mixins [] == ","mixins [] ","mixins size == ","mixins size ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact ","s [] ","@environment stack map ","@environment stack ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (send\n      (send\n        (lvar :mixins) :reverse) :+\n      (array\n        (send\n          (lvar :node) :name)))\n    (int 2)) :map) join ","mixins reverse + ","mixins reverse ","mixins empty? ","content_count > ","s == ","(send\n  (send\n    (ivar :@stack) :reverse) :map) compact select ","(send\n  (send\n    (ivar :@stack) :reverse) :map) compact ","@stack reverse map ","@stack reverse ","mixins include? ","name == ","(send\n  (send\n    (block\n      (send\n        (send\n          (ivar :@stack) :frames) :select)\n      (args\n        (arg :f))\n      (send\n        (lvar :f) :is_mixin?)) :reverse) :map) select ","f name ","(send\n  (send\n    (ivar :@stack) :frames) :select) reverse map ","(send\n  (send\n    (ivar :@stack) :frames) :select) reverse ","f is_mixin? ","@stack frames select ","@stack frames ","(send\n  (send\n    (block\n      (send\n        (send\n          (send\n            (ivar :@environment) :stack) :frames) :select)\n      (args\n        (arg :f))\n      (send\n        (lvar :f) :is_mixin?)) :reverse) :map) select ","(send\n  (send\n    (send\n      (ivar :@environment) :stack) :frames) :select) reverse map ","(send\n  (send\n    (send\n      (ivar :@environment) :stack) :frames) :select) reverse ","@environment stack frames select ","@environment stack frames ","mixins select ","(send\n  (send\n    (send\n      (ivar :@environment) :stack) :frames) :select) reverse! map! ","(send\n  (send\n    (send\n      (ivar :@environment) :stack) :frames) :select) reverse! ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (lvar :(send\n  (send\n    (ivar :@environment) :stack) :map) compact )\n    (int 2)) :map) join ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  << ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  [] == ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  [] ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  size == ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  size ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (send\n      (send\n        (lvar :(send\n  (send\n    (ivar :@environment) :stack) :map) compact ) :reverse) :+\n      (array\n        (send\n          (lvar :node) :name)))\n    (int 2)) :map) join ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  reverse + ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  reverse ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  empty? ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  include? ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  select "]}," Perform run_interp":{"type":"method","name":"run_interp","children":[],"call":["(send\n  (lvar :text) :map) join strip ","(send\n  (lvar :text) :map) join ","val to_s ","val value ","val is_a? ","r perform ","r is_a? ","text map "," run_interp_no_strip strip "," run_interp_no_strip ","Sass Util  strip_except_escapes ","r perform  to_s ","r perform  r perform ue ","r perform  is_a? "]}," Perform visit_directive":{"type":"method","name":"visit_directive","children":[],"call":["node value= "," run_interp ","Sass Engine  parse_interp ","node options ","node line ","node value ","node value [] ","Sass Util  sass_warn ","node filename ","node value =~ ","node resolved_value= ","node children= ","(send\n  (send\n    (lvar :node) :children) :map) flatten "," visit ","node children map ","node children "," with_environment ","Sass Environment  new ","@environment no_selector! ","node normalized_name == ","node normalized_name "]}," Perform visit_while":{"type":"method","name":"visit_while","children":[],"call":["children flatten "," visit ","node children map ","node children ","node expr perform to_bool ","node expr perform ","node expr "," with_environment ","Sass Environment  new ","Sass SemiGlobalEnvironment  new "]}," Perform visit_warn":{"type":"method","name":"visit_warn","children":[],"call":["@environment pop_frame ","Sass Util  sass_warn ","msg << ","entry [] ","msg << << ","i == ","@environment stack reverse each_with_index ","@environment stack reverse ","@environment stack ","res value ","res is_a? ","node expr perform ","node expr ","@environment push_frame ","node line ","node filename ","RUBY_PLATFORM  =~ ","@environment stack_trace join ","@environment stack_trace ","@stack pop "," stack_trace join "," stack_trace ","@stack push ","@environment stack to_s gsub ","@environment stack to_s ","@environment stack with_directive ","res value  value ","node expr perform  value ","res value  is_a? ","node expr perform  is_a? "]}," Perform visit_variable":{"type":"method","name":"visit_variable","children":[],"call":["@environment set_var ","node name ","node expr perform ","node expr ","@environment var nil? ! ","@environment var nil? ","@environment var ","node guarded ","Sass Script String  new ","val value ","val is_a? ","node expr context == ","node expr context ","var null? ! ","var null? ","env set_var ","val source_range= ","node source_range ","node expr source_range ","env var ","Sass Util  sass_warn ","location << ","node filename ","node line ","var_expr << ","node expr to_sass ","env options ","env global_env global_warning_given add ","env global_env global_warning_given ","env global_env ","env global_env global_warning_given include? ! ","env global_env global_warning_given include? ","env is_var_global? ","env parent ","node global ","node global_warning_given= ","node global_warning_given ! ","node global_warning_given ","@environment set_@environment var  ","@environment set_env var  ","@env global_env ironment set_var ","@environment @environment var  nil? ! ","@environment env var  nil? ! ","@env global_env ironment var nil? ! ","@environment @environment var  nil? ","@environment env var  nil? ","@env global_env ironment var nil? ","@environment @environment var  ","@environment env var  ","@env global_env ironment var ","node expr perform  node expr perform ue ","Sass Script String  new  Sass Script String  new ue ","node expr perform  is_a? ","Sass Script String  new  is_a? ","@environment var  null? ! ","env var  null? ! ","@environment var  null? ","env var  null? ","env set_@environment var  ","env set_env var  ","env global_env  set_var ","node expr perform  source_range= ","Sass Script String  new  source_range= ","env @environment var  ","env env var  ","env global_env  var ","@environment var _expr << ","env var _expr << ","env global_env  options ","env global_env  global_env global_env  global_warning_given add ","env global_env  global_env global_env  global_warning_given ","env global_env  global_env global_env  ","env global_env  global_env global_env  global_warning_given include? ! ","env global_env  global_env global_env  global_warning_given include? ","env is_@environment var _global? ","env is_env var _global? ","env global_env  is_var_global? ","env global_env  parent "]}," Perform visit_rule":{"type":"method","name":"visit_rule","children":[],"call":["parser parse_selector ","node filename ","node parsed_rules ","Sass SCSS StaticParser  new ","node line "," run_interp ","node rule ","node parsed_rules= ","@environment pop_frame ","node stack_trace= ","@environment stack_trace ","@environment push_frame ","node options [] ","node options ","e strip ","e != ","e is_a? ","rule map ","node style == ","node style ","@stack pop "," stack_trace ","@stack push ","node children= ","(send\n  (send\n    (lvar :node) :children) :map) flatten "," visit ","node children map ","node children ","@environment selector= ","node resolved_rules "," with_environment ","Sass Environment  new ","@environment stack to_s ","@environment stack ","node resolved_rules= ","node parsed_rules resolve_parent_refs ","old_at_root_without_rule ! ","@environment selector ","old_at_root ! ","keyframe_rule_node children= ","keyframe_rule_node source_range= ","node source_range ","keyframe_rule_node filename= ","keyframe_rule_node line= ","keyframe_rule_node options= ","Sass Tree KeyframeRuleNode  new ","parser parse_keyframes_selector ","keyframe_rule_node has_children= ","node has_children ","Sass SCSS StaticParser  new  parse_selector ","node parsed_node rule s ","node node rule  ","node parsed_node rule s= ","node rule  map ","node resolved_node rule s ","node resolved_node rule s= ","node parsed_node rule s resolve_parent_refs ","old_at_root_without_node rule  ! ","keyframe_node rule _node children= ","Sass Tree KeyframeRuleNode  new  children= ","keyframe_node rule _node source_range= ","Sass Tree KeyframeRuleNode  new  source_range= ","keyframe_node rule _node filename= ","Sass Tree KeyframeRuleNode  new  filename= ","keyframe_node rule _node line= ","Sass Tree KeyframeRuleNode  new  line= ","keyframe_node rule _node options= ","Sass Tree KeyframeRuleNode  new  options= ","Sass SCSS StaticParser  new  parse_keyframes_selector ","keyframe_node rule _node has_children= ","Sass Tree KeyframeRuleNode  new  has_children= "]}," Perform visit_return":{"type":"method","name":"visit_return","children":[],"call":[" throw ","node expr perform ","node expr "]}," Perform visit_prop":{"type":"method","name":"visit_prop","children":[],"call":["node resolved_value= ","val to_s ","node value perform ","node value ","node resolved_name= "," run_interp ","node name ","val value ","val is_a? ","node value context == ","node value context ","node value_source_range= ","val source_range "," run_interp_no_strip ","node custom_property? ","result source_range ","result to_s ","node value first perform ","node value first ","node value first is_a? ","node value length == ","node value length ","node resolved_node value perform ue= ","node value perform  to_s ","node node value perform ue perform ","node node value perform ue ","node value perform  node value perform ue ","node value perform  is_a? ","node node value perform ue context == ","node node value perform ue context ","node node value perform ue_source_range= ","node value perform  source_range ","node value first perform  source_range ","node value first perform  to_s ","node node value perform ue first perform ","node node value perform ue first ","node node value perform ue first is_a? ","node node value perform ue length == ","node node value perform ue length "]}," Perform visit_mixin":{"type":"method","name":"visit_mixin","children":[],"call":["original_env pop_frame "," raise ","e add_backtrace ","node line ","e modify_backtrace ","node name ","node children= ","(send\n  (send\n    (lvar :mixin) :tree) :map) flatten "," visit ","mixin tree map ","mixin tree "," with_environment ","Sass SyntaxError  new ","var inspect ","env var ","var name ","env set_local_var ","default perform ","kv perform ","passed_keywords [] ","var underscored_name ","value perform ","mixin args zip inject ","Sass Environment  new ","mixin environment ","mixin args zip ","mixin args ","var underscored_name == ","mixin args find ","passed_keywords each ","(str \"Mixin \") gsub ","node args size == ","node args size ","node args ","mixin args size != ","mixin args size ","mixin args size < ","passed_args size ","node keywords dup ","node keywords ","node args dup ","@environment mixin ","original_env prepare_frame ","original_env push_frame ","node filename "," handle_include_loop! ","@environment mixins_in_use include? ","@environment mixins_in_use ","Sass Script String  new ","val value ","val is_a? ","default context == ","default context ","@stack pop ","trace_node children= ","Sass Tree TraceNode  from_node ","env content= ","node children ","node has_children ","env caller= "," class perform_arguments "," class ","node splat perform ","node splat ","v perform ","Sass Util  map_hash ","a perform ","node args map ","mixin has_content ! ","mixin has_content ","node children any? ","@stack push ","e [] == ","e [] ","@stack any? ","environment content= ","environment caller= "," class perform_splat ","node kwarg_splat ","Sass Util  map_vals ","@environment stack with_mixin ","@environment stack ","@stack with_mixin ","f name == ","f name ","f is_mixin? ","@stack frames any? ","@stack frames ","@environment stack frames any? ","@environment stack frames ","(send\n  (send\n    (lvar :@environment mixin ) :tree) :map) flatten ","@environment mixin  tree map ","@environment mixin  tree ","passed_keywords []  perform ","node keywords dup  [] ","Sass Script String  new ue perform ","default perform ue perform ","@environment mixin  args zip inject ","@environment mixin  environment ","@environment mixin  args zip ","@environment mixin  args ","@environment mixin  args find ","node keywords dup  each ","@environment mixin  args size != ","@environment mixin  args size ","@environment mixin  args size < ","node args dup  size ","@environment @environment mixin  ","@environment @environment mixin s_in_use include? ","@environment @environment mixin s_in_use ","Sass Script String  new  Sass Script String  new ue ","default perform  default perform ue ","Sass Script String  new  is_a? ","default perform  is_a? ","Sass Tree TraceNode  from_node  children= ","node node splat perform  perform ","node  class perform_splat  perform ","node node splat perform  ","node  class perform_splat  ","@environment mixin  has_content ! ","@environment mixin  has_content "," class perform_node splat perform  "," class perform_ class perform_splat  ","node kwarg_node splat perform  ","node kwarg_ class perform_splat  ","Sass Util  map_Sass Script String  new s ","Sass Util  map_default perform s ","@environment stack with_@environment mixin  ","@stack with_@environment mixin  ","f is_@environment mixin ? "]}," Perform visit_mixindef":{"type":"method","name":"visit_mixindef","children":[],"call":["@environment set_mixin ","Sass Callable  new ","node children ","node args ","node name ","Sass Mixin  new ","@environment set_local_mixin ","node has_content ","node splat ","Sass Environment  new ","node options ","@Sass Environment  new ironment set_mixin ","@Sass Environment  new ironment set_local_mixin "]}," Perform visit_import":{"type":"method","name":"visit_import","children":[],"call":["@environment pop_frame "," raise ","e add_backtrace ","node line ","node filename ","e modify_backtrace ","node imported_file options [] ","node imported_file options ","node imported_file ","node children= ","(send\n  (send\n    (lvar :root) :children) :map) flatten "," visit ","root children map ","root children ","node imported_file to_tree ","@environment push_frame ","Sass Tree DirectiveNode  new ","node css_import? ","Sass Tree Visitors CheckNesting  visit ","file to_tree "," handle_import_loop! ","@environment files_in_use include? ","file options [] ","file options ","@environment files_in_use ","@stack pop ","@stack push ","e [] == ","e [] ","@stack any? ","Sass Tree CssImportNode  resolved ","Sass Tree DirectiveNode  resolved ","@environment stack with_import ","@environment stack ","f filename == ","f filename ","f is_import? ","@environment stack frames any? ","@environment stack frames ","resolved_node source_range= ","node source_range ","@stack with_import ","@stack frames any? ","@stack frames ","resolved_node options= ","node options ","node node imported_file name ","node imported_node imported_file  options [] ","node imported_node imported_file  options ","node imported_node imported_file  ","(send\n  (send\n    (lvar :node imported_file to_tree ) :children) :map) flatten ","(send\n  (send\n    (lvar :file to_tree ) :children) :map) flatten ","node imported_file to_tree  children map ","file to_tree  children map ","node imported_file to_tree  children ","file to_tree  children ","node imported_node imported_file  to_tree ","node imported_file  to_tree ","@environment node imported_file s_in_use include? ","node imported_file  options [] ","node imported_file  options ","@environment node imported_file s_in_use ","f node imported_file name == ","f node imported_file name ","Sass Tree CssImportNode  resolved  source_range= ","Sass Tree CssImportNode  resolved  options= "]}," Perform visit_if":{"type":"method","name":"visit_if","children":[],"call":[" visit ","node else ","node children ","node expr perform to_bool ","node expr perform ","node expr ","node expr nil? ","(send nil :with_environment\n  (send\n    (const\n      (const nil :Sass) :SemiGlobalEnvironment) :new\n    (ivar :@environment))) flatten ","node children map "," with_environment ","Sass SemiGlobalEnvironment  new "]}," Perform visit_function":{"type":"method","name":"visit_function","children":[],"call":["@environment set_function ","Sass Callable  new ","node children ","node args ","node name ","@environment set_local_function ","has_content ! ","node splat ","Sass Environment  new ","node options ","Sass Util  sass_warn ","node filename ","node line ","node name == ","node normalized_name == ","node normalized_name ","@@function_name_deprecation warn ","@Sass Environment  new ironment set_function ","@Sass Environment  new ironment set_local_function "]}," Perform visit_for":{"type":"method","name":"visit_for","children":[],"call":["(send\n  (lvar :range) :map) flatten "," visit ","node children map ","node children ","@environment set_local_var ","Sass Script Number  new ","from denominator_units ","from numerator_units ","node var ","range map "," with_environment ","Sass Environment  new ","Range  new ","node exclusive ","to to_i ","from to_i ","to coerce ","to assert_int! ","from assert_int! ","node to perform ","node to ","node from perform ","node from ","Sass Script Value Number  new ","direction * ","from to_i > ","Sass SemiGlobalEnvironment  new ","(send\n  (lvar :Range  new ) :map) flatten ","from denominato coerce r_units ","from denominanode to perform r_units ","node from perform  denominator_units ","from numerato coerce r_units ","from numeranode to perform r_units ","node from perform  numerator_units ","Range  new  map ","to coerce  to coerce _i ","node to perform  node to perform _i ","from to coerce _i ","from node to perform _i ","node from perform  to_i ","to coerce  coerce ","node to perform  coerce ","to coerce  assert_int! ","node to perform  assert_int! ","node from perform  assert_int! ","node to coerce  perform ","node node to perform  perform ","node to coerce  ","node node to perform  ","node node from perform  perform ","node node from perform  ","from to coerce _i > ","from node to perform _i > ","node from perform  to_i > "]}," Perform visit_extend":{"type":"method","name":"visit_extend","children":[],"call":["node resolved_selector= ","parser parse_selector ","node filename ","Sass SCSS CssParser  new ","node line "," run_interp ","node selector ","Sass SCSS StaticParser  new ","node options [] ","node options ","Sass SCSS CssParser  new  parse_selector ","Sass SCSS StaticParser  new  parse_selector "]}," Perform visit_each":{"type":"method","name":"visit_each","children":[],"call":["(send\n  (send\n    (lvar :list) :to_a) :map) flatten "," visit ","node children map ","node children ","@environment set_local_var ","node var ","list to_a map ","list to_a "," with_environment ","Sass Environment  new ","node list perform ","node list ","Sass Script Value Null  new ","node vars zip ","value to_a ","node vars ","node vars first ","node vars length == ","node vars length ","Sass SemiGlobalEnvironment  new ","(send\n  (send\n    (lvar :node list perform ) :to_a) :map) flatten ","node list perform  to_a map ","node list perform  to_a ","node node list perform  perform ","node node list perform  "]}," Perform visit_debug":{"type":"method","name":"visit_debug","children":[],"call":["$stderr puts ","node line ","node filename ","res value ","res is_a? ","node expr perform ","node expr ","Sass Util  sass_warn ","res to_sass ","res value  value ","node expr perform  value ","res to_sass  value ","res value  is_a? ","node expr perform  is_a? ","res to_sass  is_a? ","res value  to_sass ","node expr perform  to_sass ","res to_sass  to_sass "]}," Perform visit_comment":{"type":"method","name":"visit_comment","children":[],"call":["node value= "," run_interp ","Sass Script String  new ","node value ","1 + ","Sass Script  parse perform to_s ","Sass Script  parse perform ","Sass Script  parse ","node options ","node line ","node value gsub! ","node evaluated? ","node invisible? ","node silent ","node resolved_value gsub! ","node resolved_value ","node resolved_value= "," run_interp_no_strip "," check_for_comment_interp "," check_for_loud_silent_comment "]}," Perform visit_root":{"type":"method","name":"visit_root","children":[],"call":[" raise ","node template ","e sass_template ","@environment options= ","node options ","@environment options empty? ","@environment options ","@environment options nil? "]}," Perform with_environment":{"type":"method","name":"with_environment","children":[],"call":[]}," Perform visit_children":{"type":"method","name":"visit_children","children":[],"call":["parent children= "," flatten "," with_environment ","Sass Environment  new ","parent check_child! ","parent children each ","parent children ","parent options "]}," Perform visit":{"type":"method","name":"visit","children":[],"call":[" raise ","e modify_backtrace ","node line ","node filename ","node dup ","Sass Environment  new ","@environment stack with_base ","@environment stack "," new send "," new ","@stack with_base "]}," Perform initialize":{"type":"method","name":"initialize","children":[],"call":["Sass Environment  new ","Sass Stack  new "]}," Cssize visit_rule":{"type":"method","name":"visit_rule","children":[],"call":["rules last group_end= ","rules last ","rules empty? "," parent is_a? "," parent ","rules unshift ","r tabs ","rules each ","node style == ","node style ","node children= ","props empty? ","c invisible? ","c is_a? ","node children reject ","node children ","node children select ","node parsed_rules resolve_parent_refs ","node parsed_rules ","node resolved_rules "," parent resolved_rules ","c bubbles? "," bubblable? ! "," bubblable? "," debubble ","(send\n  (lvar :rules) :map) flatten "," visit ","rules map "," debubble  last group_end= "," debubble  last "," debubble  empty? "," debubble  unshift "," debubble  each ","node parsed_ debubble  resolve_parent_refs ","node parsed_ debubble  ","node resolved_ debubble  "," parent resolved_ debubble  ","(send\n  (lvar : debubble ) :map) flatten "," debubble  map "]}," Cssize visit_prop":{"type":"method","name":"visit_prop","children":[],"call":["result unshift ","node send ","node children empty? ","node children ","node resolved_value empty? ! ","node resolved_value empty? ","node resolved_value ","node children dup ","node tabs= "," parent tabs + "," parent resolved_value empty? "," parent resolved_value "," parent "," parent tabs ","node style == ","node style ","node resolved_name= ","node resolved_name "," parent resolved_name "," parent is_a? ","node children unshift ","node children dup  unshift "]}," Cssize visit_mixin":{"type":"method","name":"visit_mixin","children":[],"call":[" raise ","e add_backtrace ","node line ","node filename ","e modify_backtrace ","node name ","(send\n  (send\n    (lvar :node) :children) :map) flatten "," visit ","node children map ","node children "," parent check_child! "," parent "]}," Cssize visit_media":{"type":"method","name":"visit_media","children":[],"call":["(if\n  (send\n    (send\n      (lvar :node) :children) :empty?)\n  (array)\n  (array\n    (lvar :node))) + ","node children empty? ","node children ","n query= ","n query ","node query ","media each ","c is_a? ","node children reject! ","node children select ","node children last group_end= ","node children last ","node children= "," Array "," visit "," with_parent ","new_rule children= "," parent dup "," parent "," parent is_a? ","(send\n  (send\n    (lvar :node) :query) :map) flatten ","n query map ","node query map ","n resolved_query= ","n resolved_query merge ","node resolved_query ","n resolved_query ","media select "," bubble ","n query merge ","child resolved_query= ","child resolved_query merge ","child resolved_query ","child resolved_query == ","child is_a? "," debubble ","Bubble  new ","(send\n  (lvar :bubbled) :map) flatten ","n is_a? ","bubbled map "," parent dup  children= ","(send\n  (lvar :(send\n  (lvar :bubbled) :map) flatten ) :map) flatten ","(send\n  (lvar :bubbled) :map) flatten  map "]}," Cssize visit_import":{"type":"method","name":"visit_import","children":[],"call":[" raise ","e add_backtrace ","node line ","node filename ","e modify_backtrace ","node children first filename ","node children first ","node children ","(send\n  (send\n    (lvar :node) :children) :map) flatten "," visit ","node children map "," visit_children_without_parent "]}," Cssize visit_extend":{"type":"method","name":"visit_extend","children":[],"call":["@extends []= "," raise ","Sass SyntaxError  new ","seq members last is_a? ! ","seq members last is_a? ","seq members last ","seq members "," parent resolved_rules members each "," parent resolved_rules members "," parent resolved_rules "," parent ","sseq members ","seq to_a join ","seq to_a ","sseq is_a? ! ","sseq is_a? ","seq members first ","seq members size > ","seq members size ","node resolved_selector members each ","node resolved_selector members ","node resolved_selector ","node disabled? ","Extend  new ","@parent_directives dup ","ss is_a? ","sseq members any? ","member members last is_a? ! ","member members last is_a? ","member members last ","member members ","p is_a? ","@parents select "," parent resolved_rules populate_extends ","seq members first  members ","seq members first  is_a? ! ","seq members first  is_a? ","node resolved_sseq members ector members each ","node resolved_sseq members ector members ","node resolved_sseq members ector ","seq members first  members any? ","@parents sseq members ect "]}," Cssize visit_root":{"type":"method","name":"visit_root","children":[],"call":[" raise ","node template ","e sass_template ","node children unshift ","node children ","c is_a? ","node children reject! ","node children find "," parent nil? "," parent ","Sass Util  ruby1_8? ","node children= ","imports + ","node children [] + + ","node children [] ","index + ","node children [] + ","charset_and_index last ","node children each_with_index find ","node children each_with_index ","c value =~ ","c value ","Sass Util  extract! ","c resolved_value =~ ","c resolved_value ","c is_a? ! ","n is_a? ! ","n is_a? ","imports_to_move << ","charset_and_index last  + ","charset_and_charset_and_index last  last ","node children each_with_charset_and_index last  find ","node children each_with_charset_and_index last  "]}," Cssize with_parent":{"type":"method","name":"with_parent","children":[],"call":["@parent_directives pop ","parent is_a? ","@parent_directives push ","MERGEABLE_DIRECTIVES  any? ","@parents pop ","@parents push "]}," Cssize visit_children":{"type":"method","name":"visit_children","children":[],"call":["parent children= "," flatten "," with_parent "," visit_children_without_parent "]}," Cssize visit":{"type":"method","name":"visit","children":[],"call":[" raise ","e modify_backtrace ","node line ","node filename ","node dup "]}," Cssize initialize":{"type":"method","name":"initialize","children":[],"call":["Sass Util SubsetMap  new "]}," Convert dasherize":{"type":"method","name":"dasherize","children":[],"call":["s gsub ","@options [] ","s tr "]}," Convert tab_str":{"type":"method","name":"tab_str","children":[],"call":["   * ","@tab_chars * "]}," Convert semi":{"type":"method","name":"semi","children":[],"call":["@format == "]}," Convert selector_to_scss":{"type":"method","name":"selector_to_scss","children":[],"call":["(send\n  (lvar :sel) :map) join gsub "," tab_str ","(send\n  (lvar :sel) :map) join ","r to_sass ","r is_a? ","sel map ","(send\n  (lvar :sel) :map) join gsub gsub "," interp_to_src gsub gsub "," interp_to_src gsub "," interp_to_src "]}," Convert selector_to_sass":{"type":"method","name":"selector_to_sass","children":[],"call":["(send\n  (lvar :sel) :map) join ","r to_sass ","1 + ","r gsub ","r is_a? ","sel map "]}," Convert selector_to_src":{"type":"method","name":"selector_to_src","children":[],"call":[" selector_to_scss "," selector_to_sass ","@format == "]}," Convert visit_while":{"type":"method","name":"visit_while","children":[],"call":["node expr to_sass ","node expr "," tab_str "]}," Convert visit_warn":{"type":"method","name":"visit_warn","children":[],"call":[" semi ","node expr to_sass ","node expr "," tab_str "]}," Convert visit_variable":{"type":"method","name":"visit_variable","children":[],"call":[" semi ","node guarded ","node expr to_sass ","node expr "," dasherize ","node name "," tab_str ","(begin\n  (send nil :tab_str)) + ","node global "]}," Convert visit_rule":{"type":"method","name":"visit_rule","children":[],"call":["res << << << ","res << << "," tab_str ","res << ","res slice! ","node children last silent ","node children last ","node children ","node children last is_a? ","name + "," selector_to_scss ","node rule ","@format == ","name gsub + ","name gsub ","\\ + ","name [] == ","name [] "," selector_to_sass ","node children last type == ","node children last type ","node parsed_rules to_a ","node parsed_rules ","node parsed_rules to_s ","name +  << << << ","name +  << << ","name +  << ","name +  slice! "," selector_to_scss  + ","\\ +  + "," selector_to_sass  + ","node node rule  ","node node parsed_rules to_a  "," selector_to_scss  gsub + ","\\ +  gsub + "," selector_to_sass  gsub + "," selector_to_scss  gsub ","\\ +  gsub "," selector_to_sass  gsub "," selector_to_scss  [] == ","\\ +  [] == "," selector_to_sass  [] == "," selector_to_scss  [] ","\\ +  [] "," selector_to_sass  [] ","node parsed_node rule s to_a ","node parsed_node parsed_rules to_a s to_a ","node parsed_node rule s ","node parsed_node parsed_rules to_a s ","node parsed_node rule s to_s ","node parsed_node parsed_rules to_a s to_s "]}," Convert visit_return":{"type":"method","name":"visit_return","children":[],"call":[" semi ","node expr to_sass ","node expr "," tab_str "]}," Convert visit_prop":{"type":"method","name":"visit_prop","children":[],"call":["res + + + ","res + + "," semi ","res + "," rstrip ","node children empty? ","node children "," tab_str + ","node declaration "," tab_str "," tab_str +  + + + "," tab_str +  + + "," tab_str +  + "]}," Convert visit_mixin":{"type":"method","name":"visit_mixin","children":[],"call":[" semi "," dasherize ","node name ","@format == "," tab_str ","keywords empty? ","args empty? ","(send\n  (send\n    (lvar :node) :keywords) :map) join ","v to_sass ","node keywords map ","node keywords ","(send\n  (send\n    (lvar :node) :args) :map) join ","a to_sass ","node args map ","node args ","node keywords empty? ","node args empty? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :keywords)) :map) join ","Sass Util  hash_to_a map ","Sass Util  hash_to_a ","node has_children ","node splat to_sass ","node splat ","node splat nil? ","arg_to_sass [] ","node args map join ","arg separator == ","arg separator ","arg is_a? ","arg to_sass "," lambda ","(begin\n  (send nil :tab_str)) + ","(lvar :args) flatten compact join ","(lvar :args) flatten compact ","(lvar :args) flatten ","node kwarg_splat ","node keywords as_stored ","node kwarg_splat inspect ","node keywords as_stored to_a map ","node keywords as_stored to_a ","(send\n  (send\n    (lvar :node) :keywords) :map) join  empty? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :keywords)) :map) join  empty? ","(send\n  (send\n    (lvar :node) :args) :map) join  empty? ","node args map join  empty? ","node args map  empty? ","(send\n  (send\n    (lvar :node) :(send\n  (send\n    (lvar :node) :keywords) :map) join ) :map) join ","(send\n  (send\n    (lvar :node) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :keywords)) :map) join ) :map) join ","v to_arg to_sass  ","node (send\n  (send\n    (lvar :node) :keywords) :map) join  map ","node (send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :keywords)) :map) join  map ","node (send\n  (send\n    (lvar :node) :keywords) :map) join  ","node (send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :keywords)) :map) join  ","(send\n  (send\n    (lvar :node) :(send\n  (send\n    (lvar :node) :args) :map) join ) :map) join ","(send\n  (send\n    (lvar :node) :node args map join ) :map) join ","(send\n  (send\n    (lvar :node) :node args map ) :map) join ","a to_arg to_sass  ","node (send\n  (send\n    (lvar :node) :args) :map) join  map ","node node args map join  map ","node node args map  map ","node (send\n  (send\n    (lvar :node) :args) :map) join  ","node node args map join  ","node node args map  ","node (send\n  (send\n    (lvar :node) :keywords) :map) join  empty? ","node (send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :keywords)) :map) join  empty? ","node (send\n  (send\n    (lvar :node) :args) :map) join  empty? ","node node args map join  empty? ","node node args map  empty? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :(send\n  (send\n    (lvar :node) :keywords) :map) join )) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :keywords)) :map) join )) :map) join ","node splat to_arg to_sass  ","arg_to_arg to_sass  [] ","node (send\n  (send\n    (lvar :node) :args) :map) join  map join ","node node args map join  map join ","node node args map  map join ","arg to_arg to_sass  ","(lvar :(send\n  (send\n    (lvar :node) :args) :map) join ) flatten compact join ","(lvar :node args map join ) flatten compact join ","(lvar :node args map ) flatten compact join ","(lvar :(send\n  (send\n    (lvar :node) :args) :map) join ) flatten compact ","(lvar :node args map join ) flatten compact ","(lvar :node args map ) flatten compact ","(lvar :(send\n  (send\n    (lvar :node) :args) :map) join ) flatten ","(lvar :node args map join ) flatten ","(lvar :node args map ) flatten ","node (send\n  (send\n    (lvar :node) :keywords) :map) join  as_stored ","node (send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :keywords)) :map) join  as_stored ","node (send\n  (send\n    (lvar :node) :keywords) :map) join  as_stored to_a map ","node (send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :keywords)) :map) join  as_stored to_a map ","node (send\n  (send\n    (lvar :node) :keywords) :map) join  as_stored to_a ","node (send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (lvar :node) :keywords)) :map) join  as_stored to_a "]}," Convert visit_mixindef":{"type":"method","name":"visit_mixindef","children":[],"call":[" dasherize ","node name ","@format == "," tab_str ","( + + ","( + ","(send\n  (send\n    (lvar :node) :args) :map) join ","v to_sass ","d to_sass ","node args map ","node args ","node args empty? ","str << ","str << << ","node splat to_sass ","node splat ","node splat nil? ","(send\n  (send\n    (lvar :node) :( + + ) :map) join ","node ( + +  map ","node ( + +  ","node ( + +  empty? "]}," Convert visit_media":{"type":"method","name":"visit_media","children":[],"call":["node query "," tab_str ","node query join "," media_interp_to_src ","node query to_src "," interp_to_src "," query_interp_to_src "]}," Convert visit_import":{"type":"method","name":"visit_import","children":[],"call":[" semi ","node imported_filename "," tab_str ","@format == "]}," Convert visit_if":{"type":"method","name":"visit_if","children":[],"call":["str << "," visit ","node else ","node expr to_sass ","node expr "," tab_str ","@is_else ! "]}," Convert visit_function":{"type":"method","name":"visit_function","children":[],"call":[" dasherize ","node name "," tab_str ","(send\n  (send\n    (lvar :node) :args) :map) join ","v to_sass ","d to_sass ","node args map ","node args ","args << << ","args << ","node splat to_sass ","node splat ","node args empty? ","(send\n  (send\n    (lvar :node) :(send\n  (send\n    (lvar :node) :args) :map) join ) :map) join ","node (send\n  (send\n    (lvar :node) :args) :map) join  map ","node (send\n  (send\n    (lvar :node) :args) :map) join  ","(send\n  (send\n    (lvar :node) :args) :map) join  << << ","(send\n  (send\n    (lvar :node) :args) :map) join  << ","node (send\n  (send\n    (lvar :node) :args) :map) join  empty? "]}," Convert visit_for":{"type":"method","name":"visit_for","children":[],"call":["(begin\n  (send nil :tab_str)) + ","node to to_sass ","node to ","node exclusive ","node from to_sass ","node from "," dasherize ","node var "," tab_str "]}," Convert visit_extend":{"type":"method","name":"visit_extend","children":[],"call":[" semi "," selector_to_src lstrip "," selector_to_src ","node selector "," tab_str ","node optional? ","(begin\n  (send nil :tab_str)) + "]}," Convert visit_each":{"type":"method","name":"visit_each","children":[],"call":["node list to_sass ","node list "," dasherize ","node var "," tab_str ","(send\n  (send\n    (lvar :node) :vars) :map) join ","node vars map ","node vars ","(send\n  (send\n    (lvar :node) :(send\n  (send\n    (lvar :node) :vars) :map) join ) :map) join ","node (send\n  (send\n    (lvar :node) :vars) :map) join  map ","node (send\n  (send\n    (lvar :node) :vars) :map) join  "]}," Convert visit_directive":{"type":"method","name":"visit_directive","children":[],"call":["res + + ","res + "," semi ","node has_children ","node value "," tab_str ","res gsub! "," interp_to_src "]}," Convert visit_debug":{"type":"method","name":"visit_debug","children":[],"call":[" semi ","node expr to_sass ","node expr "," tab_str "]}," Convert visit_comment":{"type":"method","name":"visit_comment","children":[],"call":["content sub! ","content gsub! ","node silent ","node loud ","(send\n  (lvar :node) :silent) gsub + ","(send\n  (lvar :node) :silent) gsub ","node value ","node value gsub gsub ","node value gsub ","   * ","(send\n  (ivar :@tabs) :-\n  (send\n    (send\n      (send\n        (lvar :node) :value) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","@tabs - ","node value [] size ","node value [] ","content rstrip + ","content rstrip "," tab_str ","content gsub ","  * ","spaces >= ","(send\n  (send\n    (lvar :content) :scan\n    (regexp\n      (str \"\\\\n( *)\")\n      (regopt))) :map) min ","s first size ","s first ","content scan map ","content scan ","content include? ","content =~ ","node value gsub rstrip ","@format == ","value gsub gsub ","value gsub ","(send\n  (ivar :@tabs) :-\n  (send\n    (send\n      (lvar :value) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","value [] size ","value [] ","value gsub rstrip ","(send\n  (send\n    (lvar :node) :value) :map) join ","r to_sass ","r is_a? ","node value map ","node type == ","node type ","(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub + ","(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub ","@tab_chars * "," interp_to_src ","(send\n  (lvar :node) :silent) gsub +  sub! ","node value gsub rstrip  sub! ","value gsub rstrip  sub! ","(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub +  sub! ","content rstrip +  sub! ","(send\n  (lvar :node) :silent) gsub +  gsub! ","node value gsub rstrip  gsub! ","value gsub rstrip  gsub! ","(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub +  gsub! ","content rstrip +  gsub! ","node (send\n  (send\n    (lvar :node) :value) :map) join  ","node  interp_to_src  ","node (send\n  (send\n    (lvar :node) :value) :map) join  gsub gsub ","node  interp_to_src  gsub gsub ","node (send\n  (send\n    (lvar :node) :value) :map) join  gsub ","node  interp_to_src  gsub ","(send\n  (ivar :@tabs) :-\n  (send\n    (send\n      (send\n        (lvar :node) :(send\n  (send\n    (lvar :node) :value) :map) join ) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","(send\n  (ivar :@tabs) :-\n  (send\n    (send\n      (send\n        (lvar :node) : interp_to_src ) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","node (send\n  (send\n    (lvar :node) :value) :map) join  [] size ","node  interp_to_src  [] size ","node (send\n  (send\n    (lvar :node) :value) :map) join  [] ","node  interp_to_src  [] ","(send\n  (lvar :node) :silent) gsub +  rstrip + ","node value gsub rstrip  rstrip + ","value gsub rstrip  rstrip + ","(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub +  rstrip + ","content rstrip +  rstrip + ","(send\n  (lvar :node) :silent) gsub +  rstrip ","node value gsub rstrip  rstrip ","value gsub rstrip  rstrip ","(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub +  rstrip ","content rstrip +  rstrip ","(send\n  (lvar :node) :silent) gsub +  gsub ","node value gsub rstrip  gsub ","value gsub rstrip  gsub ","(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub +  gsub ","content rstrip +  gsub ","(send\n  (send\n    (lvar :content) :scan\n    (regexp\n      (str \"\\n( *)\")\n      (regopt))) :map) min  >= ","(send\n  (send\n    (lvar :(send\n  (lvar :node) :silent) gsub + ) :scan\n    (regexp\n      (str \"\\\\n( *)\")\n      (regopt))) :map) min ","(send\n  (send\n    (lvar :node value gsub rstrip ) :scan\n    (regexp\n      (str \"\\\\n( *)\")\n      (regopt))) :map) min ","(send\n  (send\n    (lvar :value gsub rstrip ) :scan\n    (regexp\n      (str \"\\\\n( *)\")\n      (regopt))) :map) min ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub + ) :scan\n    (regexp\n      (str \"\\\\n( *)\")\n      (regopt))) :map) min ","(send\n  (send\n    (lvar :content rstrip + ) :scan\n    (regexp\n      (str \"\\\\n( *)\")\n      (regopt))) :map) min ","(send\n  (lvar :node) :silent) gsub +  scan map ","node value gsub rstrip  scan map ","value gsub rstrip  scan map ","(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub +  scan map ","content rstrip +  scan map ","(send\n  (lvar :node) :silent) gsub +  scan ","node value gsub rstrip  scan ","value gsub rstrip  scan ","(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub +  scan ","content rstrip +  scan ","(send\n  (lvar :node) :silent) gsub +  include? ","node value gsub rstrip  include? ","value gsub rstrip  include? ","(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub +  include? ","content rstrip +  include? ","(send\n  (lvar :node) :silent) gsub +  =~ ","node value gsub rstrip  =~ ","value gsub rstrip  =~ ","(send\n  (send\n    (lvar :node) :type) :==\n  (sym :silent)) gsub +  =~ ","content rstrip +  =~ ","node (send\n  (send\n    (lvar :node) :value) :map) join  gsub rstrip ","node  interp_to_src  gsub rstrip ","(send\n  (send\n    (lvar :node) :value) :map) join  gsub gsub "," interp_to_src  gsub gsub ","(send\n  (send\n    (lvar :node) :value) :map) join  gsub "," interp_to_src  gsub ","(send\n  (ivar :@tabs) :-\n  (send\n    (send\n      (lvar :(send\n  (send\n    (lvar :node) :value) :map) join ) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","(send\n  (ivar :@tabs) :-\n  (send\n    (send\n      (lvar : interp_to_src ) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","(send\n  (send\n    (lvar :node) :value) :map) join  [] size "," interp_to_src  [] size ","(send\n  (send\n    (lvar :node) :value) :map) join  [] "," interp_to_src  [] ","(send\n  (send\n    (lvar :node) :value) :map) join  gsub rstrip "," interp_to_src  gsub rstrip ","(send\n  (send\n    (lvar :node) :(send\n  (send\n    (lvar :node) :value) :map) join ) :map) join ","(send\n  (send\n    (lvar :node) : interp_to_src ) :map) join ","node (send\n  (send\n    (lvar :node) :value) :map) join  map ","node  interp_to_src  map "]}," Convert visit_charset":{"type":"method","name":"visit_charset","children":[],"call":[" semi ","node name "," tab_str "]}," Convert visit_root":{"type":"method","name":"visit_root","children":[],"call":["(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (send\n      (send\n        (lvar :node) :children) :+\n      (array\n        (nil)))\n    (int 2)) :map) join rstrip + ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (send\n      (send\n        (lvar :node) :children) :+\n      (array\n        (nil)))\n    (int 2)) :map) join rstrip ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (send\n      (send\n        (lvar :node) :children) :+\n      (array\n        (nil)))\n    (int 2)) :map) join "," visit + ","child line + == ","nxt line ","child line + ","child line ","nxt is_a? ","child is_a? ","child line + + == ","child line + + ","child value count ","child value "," visit ","Sass Util  enum_cons map ","Sass Util  enum_cons ","node children + ","node children ","child lines "," visit_rule_level "]}," Convert visit_children":{"type":"method","name":"visit_children","children":[],"call":["(if\n  (send\n    (ivar :@format) :==\n    (sym :sass))\n  (str \"\\n\")\n  (str \" {\\n\")) + + ","@format == ","(if\n  (send\n    (ivar :@format) :==\n    (sym :sass))\n  (str \"\\n\")\n  (str \" {\\n\")) + "," join rstrip "," join ","parent children empty? ","parent children ","@tab_chars * ","@tabs - "," {\n + + "," {\n + ","\n + + ","\n + ","res rstrip "," visit_rule_level "," visit_rule_level  rstrip "]}," Convert initialize":{"type":"method","name":"initialize","children":[],"call":["@options [] "]}," Convert visit":{"type":"method","name":"visit","children":[],"call":[]}," CheckNesting try_send":{"type":"method","name":"try_send","children":[],"call":[" send "," respond_to? "]}," CheckNesting is_any_of?":{"type":"method","name":"is_any_of?","children":[],"call":["val is_a? ","classes any? ","classes each "]}," CheckNesting invalid_return_parent?":{"type":"method","name":"invalid_return_parent?","children":[],"call":["parent is_a? "]}," CheckNesting invalid_prop_parent?":{"type":"method","name":"invalid_prop_parent?","children":[],"call":["Properties are only allowed within rules, directives, or other properties. + ","child pseudo_class_selector_message "," is_any_of? ","Properties are only allowed within rules, directives, mixin includes, or other properties. + "]}," CheckNesting invalid_prop_child?":{"type":"method","name":"invalid_prop_child?","children":[],"call":[" is_any_of? "]}," CheckNesting invalid_mixindef_parent?":{"type":"method","name":"invalid_mixindef_parent?","children":[],"call":["parent is_a? ","(send\n  (block\n    (send\n      (ivar :@parents) :map)\n    (args\n      (arg :p))\n    (send\n      (lvar :p) :class)) :&\n  (const nil :INVALID_IMPORT_PARENTS)) empty? ","(send\n  (ivar :@parents) :map) & ","p class ","@parents map "]}," CheckNesting invalid_import_real_parent?":{"type":"method","name":"invalid_import_real_parent?","children":[],"call":[]}," CheckNesting invalid_import_parent?":{"type":"method","name":"invalid_import_parent?","children":[],"call":[" raise ","e add_backtrace ","child line ","child filename ","e modify_backtrace ","child imported_file options [] ","child imported_file options ","child imported_file "," visit ","child imported_file to_tree children each ","child imported_file to_tree children ","child imported_file to_tree ","child css_import? ","parent is_a? "," is_any_of? ","(send\n  (block\n    (send\n      (ivar :@parents) :map)\n    (args\n      (arg :p))\n    (send\n      (lvar :p) :class)) :&\n  (const nil :INVALID_IMPORT_PARENTS)) empty? ","(send\n  (ivar :@parents) :map) & ","p class ","@parents map "]}," CheckNesting invalid_function_child?":{"type":"method","name":"invalid_function_child?","children":[],"call":[" is_any_of? "]}," CheckNesting invalid_function_parent?":{"type":"method","name":"invalid_function_parent?","children":[],"call":["parent is_a? ","(send\n  (block\n    (send\n      (ivar :@parents) :map)\n    (args\n      (arg :p))\n    (send\n      (lvar :p) :class)) :&\n  (const nil :INVALID_IMPORT_PARENTS)) empty? ","(send\n  (ivar :@parents) :map) & ","p class ","@parents map "]}," CheckNesting invalid_extend_parent?":{"type":"method","name":"invalid_extend_parent?","children":[],"call":[" is_any_of? ","Sass Util  sass_warn ","directive name ","child filename ","child line ","child disable! ","p is_a? ","@parents find ","child disabled? ! ","child disabled? ","(str \"@extend may not be used within directives (e.g. \") rstrip "]}," CheckNesting invalid_charset_parent?":{"type":"method","name":"invalid_charset_parent?","children":[],"call":["parent is_a? "]}," CheckNesting visit_import":{"type":"method","name":"visit_import","children":[],"call":[" raise ","e add_backtrace ","node line ","node filename ","e modify_backtrace ","node children first filename ","node children first ","node children "]}," CheckNesting visit_root":{"type":"method","name":"visit_root","children":[],"call":[" raise ","node template ","e sass_template "]}," CheckNesting visit_children":{"type":"method","name":"visit_children","children":[],"call":[" is_any_of? ","@parents pop ","@parents push ","old_parent is_a? ! ","old_parent is_a? ","parent bubbles? "," transparent_parent? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :@parents) :reverse)) :find) first "," transparent_parent? ! ","@parents [] ","i -@ - ","i -@ ","Sass Util  enum_with_index find ","Sass Util  enum_with_index ","@parents reverse ","parent exclude_node? ","@parents reject ","parent resolved_value ","parent is_a? ","(send\n  (send\n    (send\n      (ivar :@parents) :reverse) :each_with_index) :find) first ","@parents reverse each_with_index find ","@parents reverse each_with_index ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :@parents) :reverse)) :find) first s pop ","(send\n  (send\n    (send\n      (ivar :@parents) :reverse) :each_with_index) :find) first s pop ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :@parents) :reverse)) :find) first s push ","(send\n  (send\n    (send\n      (ivar :@parents) :reverse) :each_with_index) :find) first s push ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :@parents) :reverse)) :find) first s) :reverse)) :find) first ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :(send\n  (send\n    (send\n      (ivar :@parents) :reverse) :each_with_index) :find) first s) :reverse)) :find) first ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :@parents) :reverse)) :find) first s [] ","(send\n  (send\n    (send\n      (ivar :@parents) :reverse) :each_with_index) :find) first s [] ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :@parents) :reverse)) :find) first s reverse ","(send\n  (send\n    (send\n      (ivar :@parents) :reverse) :each_with_index) :find) first s reverse ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :@parents) :reverse)) :find) first s reject ","(send\n  (send\n    (send\n      (ivar :@parents) :reverse) :each_with_index) :find) first s reject ","(send\n  (send\n    (send\n      (ivar :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :@parents) :reverse)) :find) first s) :reverse) :each_with_index) :find) first ","(send\n  (send\n    (send\n      (ivar :(send\n  (send\n    (send\n      (ivar :@parents) :reverse) :each_with_index) :find) first s) :reverse) :each_with_index) :find) first ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :@parents) :reverse)) :find) first s reverse each_with_index find ","(send\n  (send\n    (send\n      (ivar :@parents) :reverse) :each_with_index) :find) first s reverse each_with_index find ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (ivar :@parents) :reverse)) :find) first s reverse each_with_index ","(send\n  (send\n    (send\n      (ivar :@parents) :reverse) :each_with_index) :find) first s reverse each_with_index "]}," CheckNesting visit":{"type":"method","name":"visit","children":[],"call":[" raise ","e modify_backtrace ","node line ","node filename ","Sass SyntaxError  new "," try_send "," node_name ","node class invalid_parent_method_name ","node class ","@parent class invalid_child_method_name ","@parent class "," class node_name "," class "]}," Visitors Base visit_if":{"type":"method","name":"visit_if","children":[],"call":[" visit ","node else "]}," Visitors Base node_name":{"type":"method","name":"node_name","children":[],"call":["node class name gsub downcase ","node class name gsub ","node class name ","node class ","@@node_names [] "]}," Visitors Base visit_children":{"type":"method","name":"visit_children","children":[],"call":[" visit ","parent children map ","parent children "]}," Visitors Base visit":{"type":"method","name":"visit","children":[],"call":[" visit_children "," send "," respond_to? "," node_name ","node class name gsub downcase ","node class name gsub ","node class name ","node class ","node class visit_method "," class node_name "," class "]}," Sass Tree VariableNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree RuleNode try_to_parse_non_interpolated_rules":{"type":"method","name":"try_to_parse_non_interpolated_rules","children":[],"call":["parser parse_selector ","Sass SCSS StaticParser  new ","@rule join strip ","@rule join ","t kind_of? ","@rule all? ","t is_a? ","warnings empty? ","$stderr string ","Sass Util  silence_warnings ","Sass  logger capture ","Sass  logger ","Sass Util  strip_except_escapes ","Sass SCSS StaticParser  new  parse_selector "]}," Tree RuleNode debug_info":{"type":"method","name":"debug_info","children":[],"call":[" line ","file:// + ","URI  escape ","File  expand_path "," filename ","Sass Util  escape_uri ","URI DEFAULT_PARSER  escape "]}," Tree RuleNode do_extend":{"type":"method","name":"do_extend","children":[],"call":["node resolved_rules= "," resolved_rules do_extend "," resolved_rules "," dup "," dup  resolved_rules= "]}," Tree RuleNode continued?":{"type":"method","name":"continued?","children":[],"call":["last [] == ","last [] ","last is_a? ","@rule last ","@rule last  [] == ","@rule last  [] ","@rule last  is_a? ","@rule @rule last  "]}," Tree RuleNode add_rules":{"type":"method","name":"add_rules","children":[],"call":[" try_to_parse_non_interpolated_rules ","Sass Util  strip_string_array ","Sass Util  merge_adjacent_strings ","@rule + + ","node rule ","@rule + ","Sass Util  strip_string_array  + + ","Sass Util  strip_string_array  + "]}," Tree RuleNode ==":{"type":"method","name":"==","children":[],"call":[" rule == ","other rule "," rule "," class == ","other class "," class "]}," Tree RuleNode filename=":{"type":"method","name":"filename=","children":[],"call":["@parsed_rules filename= "]}," Tree RuleNode line=":{"type":"method","name":"line=","children":[],"call":["@parsed_rules line= "]}," Tree RuleNode initialize":{"type":"method","name":"initialize","children":[],"call":[" try_to_parse_non_interpolated_rules ","Sass Util  strip_string_array ","Sass Util  merge_adjacent_strings ","rule to_s ","rule is_a? "]}," Sass Tree RootNode render":{"type":"method","name":"render","children":[],"call":["result to_s ","result do_extend ","extends empty? ","Visitors Cssize  visit ","Visitors CheckNesting  visit ","Visitors Perform  visit "," perform cssize "," perform ","Environment  new ","Visitors Extend  visit "," css_tree css "," css_tree ","result do_extend  to_s ","Visitors Perform  visit  to_s ","result do_extend  do_extend ","Visitors Perform  visit  do_extend "]}," Sass Tree RootNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree ReturnNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree PropNode val_to_sass_div":{"type":"method","name":"val_to_sass_div","children":[],"call":["Sass Script String  new ","node to_sass ","node operand2 original ! ","node operand2 original ","node operand2 ","node operand1 original ! ","node operand1 original ","node operand1 ","node operand2 is_a? ","node operand1 is_a? ","node operator == ","node operator ","node is_a? ","node context == ","node context ","Sass Script Value String  new ","node operand2 value original ! ","node operand2 value original ","node operand2 value ","node operand1 value original ! ","node operand1 value original ","node operand1 value ","node operand2 value is_a? ","node operand1 value is_a? "]}," Tree PropNode val_to_sass_concat":{"type":"method","name":"val_to_sass_concat","children":[],"call":["Sass Script Operation  new ","node operator "," val_to_sass_concat ","node operand2 "," val_to_sass_div ","node operand1 ","node operator == ","node is_a? ","Sass Script Tree Operation  new "]}," Tree PropNode val_to_sass_comma":{"type":"method","name":"val_to_sass_comma","children":[],"call":["Sass Script Operation  new ","node operator "," val_to_sass_comma ","node operand2 "," val_to_sass_concat ","node operand1 ","node operator == ","node is_a? ","Sass Script Tree Operation  new "]}," Tree PropNode val_to_sass":{"type":"method","name":"val_to_sass","children":[],"call":[" val_to_sass_comma to_sass "," val_to_sass_comma "]}," Tree PropNode check!":{"type":"method","name":"check!","children":[],"call":[" raise ","Sass SyntaxError  new ","(str \"Invalid property: \") + "," pseudo_class_selector_message "," declaration dump "," declaration "," resolved_value empty? "," resolved_value ","@options [] inspect ","@options [] ","@options [] != ","@prop_syntax == ","@options [] == ","(str \"Illegal property syntax: can't use \") + "]}," Tree PropNode declaration":{"type":"method","name":"declaration","children":[],"call":["(begin\n  (lvar :initial)) rstrip "," important "," class val_to_sass "," value "," class ","fmt == ","opts [] "," raise ","Sass SyntaxError  new ","name [] == ","name [] ","(send\n  (send\n    (self) :name) :map) join ","n to_sass ","n is_a? "," name map "," name ","(begin\n  (send\n    (str \"  \") :*\n    (lvar :tabs))) rstrip ","   * ","(str \"The \\\"\") + ","(begin\n  (if\n    (lvar :old)\n    (str \":\")\n    (str \"\"))) rstrip "," custom_property? ","value tr "," value_needs_parens? ","(send\n  (send\n    (self) :value) :map) join "," value map "," value tr  "," (send\n  (send\n    (self) :value) :map) join  ","(send\n  (send\n    (self) :name) :map) join  [] == ","(send\n  (send\n    (self) :name) :map) join  [] ","(send\n  (send\n    (self) :(send\n  (send\n    (self) :name) :map) join ) :map) join "," (send\n  (send\n    (self) :name) :map) join  map "," (send\n  (send\n    (self) :name) :map) join  ","value tr  tr ","(send\n  (send\n    (self) :value) :map) join  tr "," value tr _needs_parens? "," (send\n  (send\n    (self) :value) :map) join _needs_parens? ","(send\n  (send\n    (self) :value tr ) :map) join ","(send\n  (send\n    (self) :(send\n  (send\n    (self) :value) :map) join ) :map) join "," value tr  map "," (send\n  (send\n    (self) :value) :map) join  map "]}," Tree PropNode pseudo_class_selector_message":{"type":"method","name":"pseudo_class_selector_message","children":[],"call":[" declaration "," declaration dump "," value value empty? ! "," value value empty? "," value value "," value "," value is_a? ! "," value is_a? ","@prop_syntax == "," value value value empty? ! "," value value value empty? "," value value value "," value value is_a? ! "," value value is_a? "," value first value value empty? ! "," value first value value empty? "," value first value value "," value first value "," value first "," value first value is_a? ! "," value first value is_a? "," value first is_a? ! "," value first is_a? "," custom_property? "]}," Tree PropNode ==":{"type":"method","name":"==","children":[],"call":[" value == ","other value "," value "," name == ","other name "," name "," class == ","other class "," class "]}," Tree PropNode initialize":{"type":"method","name":"initialize","children":[],"call":["Sass Util  strip_string_array ","Sass Util  merge_adjacent_strings "," custom_property? "]}," Sass Tree Node balance":{"type":"method","name":"balance","children":[],"call":[" raise ","Sass SyntaxError  new "," line ","Sass Shared  balance "]}," Sass Tree Node deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node children= ","c deep_copy "," children map "," children "," dup ","Sass Tree Visitors DeepCopy  visit "," dup  children= "]}," Sass Tree Node to_scss":{"type":"method","name":"to_scss","children":[],"call":["Sass Tree Visitors Convert  visit "," to_src "]}," Sass Tree Node to_sass":{"type":"method","name":"to_sass","children":[],"call":["Sass Tree Visitors Convert  visit "," to_src "]}," Sass Tree Node each":{"type":"method","name":"each","children":[],"call":["c each "," children each "," children "]}," Sass Tree Node do_extend":{"type":"method","name":"do_extend","children":[],"call":[" raise ","e modify_backtrace "," line "," filename ","node children= ","c do_extend "," children map "," children "," dup "," dup  children= "]}," Sass Tree Node to_s":{"type":"method","name":"to_s","children":[],"call":["Sass Tree Visitors ToCss  visit "," raise ","e modify_backtrace "," line "," filename "," _to_s "]}," Sass Tree Node style":{"type":"method","name":"style","children":[],"call":["@options [] "]}," Sass Tree Node invisible?":{"type":"method","name":"invisible?","children":[],"call":[]}," Sass Tree Node ==":{"type":"method","name":"==","children":[],"call":["other children == "," children ","other children "," class == ","other class "," class "]}," Sass Tree Node <<":{"type":"method","name":"<<","children":[],"call":["@children << "," has_children= "," << ","child each ","child is_a? ","child nil? "," check_child! "]}," Sass Tree Node filename":{"type":"method","name":"filename","children":[],"call":["@options [] "]}," Sass Tree Node children=":{"type":"method","name":"children=","children":[],"call":["children empty? ! ","children empty? "," has_children "]}," Sass Tree Node options=":{"type":"method","name":"options=","children":[],"call":["c options= "," children each "," children ","Sass Tree Visitors SetOptions  visit ","n options= ","n respond_to? "," subnodes each "," subnodes "," respond_to? "]}," Sass Tree Node initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree MixinNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree MixinDefNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree MediaNode value":{"type":"method","name":"value","children":[],"call":[" query "," query join "," raise "]}," Tree MediaNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree ImportNode import":{"type":"method","name":"import","children":[],"call":[" raise ","SyntaxError  new "," line ","e message ","message << << ","paths join ","message << ","paths first ","paths size == ","paths size ","p find ","@options dup ","paths each ","@options [] find_relative ","@options [] "," options_for_importer ","lines join ","lines << ","paths empty? ! ","paths empty? ","@options []  join ","paths p find irst ","paths @options [] find_relative irst ","@options []  first ","@options []  size == ","@options []  size ","p p find ind ","p @options [] find_relative ind ","@options []  each ","@options [] p find ind_relative ","@options [] @options [] find_relative ind_relative "," options_p find or_importer "," options_@options [] find_relative or_importer ","@options []  empty? ! ","@options []  empty? "]}," Sass Tree ImportNode css_import?":{"type":"method","name":"css_import?","children":[],"call":[" imported_file "," imported_file =~ "," imported_file is_a? ","@imported_filename =~ "]}," Sass Tree ImportNode imported_file":{"type":"method","name":"imported_file","children":[],"call":[" import "]}," Sass Tree ImportNode invisible?":{"type":"method","name":"invisible?","children":[],"call":[" to_s empty? "," to_s "]}," Sass Tree ImportNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree IfNode deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node else= "," else deep_copy "," else "]}," Tree IfNode _load":{"type":"method","name":"_load","children":[],"call":[]}," Tree IfNode _dump":{"type":"method","name":"_dump","children":[],"call":["Marshal  dump "," children "," else "," expr "]}," Tree IfNode options=":{"type":"method","name":"options=","children":[],"call":[" else options= "," else "]}," Tree IfNode add_else":{"type":"method","name":"add_else","children":[],"call":["@last_else else= "]}," Tree IfNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree FunctionNode initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","Sass SyntaxError  new ","(str \"and\") include? "]}," Tree ForNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree ExtendNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree EachNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree DirectiveNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree DebugNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree CommentNode normalize_indentation":{"type":"method","name":"normalize_indentation","children":[],"call":["str gsub ","(send\n  (send\n    (lvar :str) :split\n    (str \"\\n\")) :inject\n  (send\n    (send\n      (lvar :str) :[]\n      (regexp\n        (str \"^[ \\\\t]*\")\n        (regopt))) :split\n    (str \"\"))) join ","arr + ","a != ","line [] split zip inject ","line [] split zip ","line [] split ","line [] ","str split inject ","str [] split ","str [] ","str split ","arr << "]}," Tree CommentNode evaluated?":{"type":"method","name":"evaluated?","children":[],"call":[]}," Tree CommentNode invisible?":{"type":"method","name":"invisible?","children":[],"call":[" style == "," style "]}," Tree CommentNode ==":{"type":"method","name":"==","children":[],"call":[" silent == ","other silent "," silent "," value == ","other value "," value "," class == ","other class "," class "," loud == ","other loud "," loud "," type == ","other type "," type "]}," Tree CommentNode initialize":{"type":"method","name":"initialize","children":[],"call":["@value sub! ","1 to_s ","@value =~ "," normalize_indentation ","Sass Util  with_extracted_values "," normalize_indentation  sub! "," normalize_indentation  =~ "]}," Tree CharsetNode invisible?":{"type":"method","name":"invisible?","children":[],"call":["Sass Util  ruby1_8? ! ","Sass Util  ruby1_8? "]}," Tree CharsetNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Shared human_indentation":{"type":"method","name":"human_indentation","children":[],"call":["indentation length ","indentation length == ","indentation inspect + ","indentation inspect ","indentation include? ! ","indentation include? "]}," Sass Shared balance":{"type":"method","name":"balance","children":[],"call":["scanner rest ","str strip ","count == ","scanner matched [] == ","scanner matched [] ","scanner matched ","str << ","scanner scan ","Regexp  new ","finish chr ","start chr ","StringScanner  new ","scanner is_a? ","Sass Util MultibyteStringScanner  new ","StringScanner  new  rest ","Sass Util MultibyteStringScanner  new  rest ","StringScanner  new  matched [] == ","Sass Util MultibyteStringScanner  new  matched [] == ","StringScanner  new  matched [] ","Sass Util MultibyteStringScanner  new  matched [] ","StringScanner  new  matched ","Sass Util MultibyteStringScanner  new  matched ","StringScanner  new  scan ","Sass Util MultibyteStringScanner  new  scan ","StringScanner  new  is_a? ","Sass Util MultibyteStringScanner  new  is_a? "]}," Sass Shared handle_interpolation":{"type":"method","name":"handle_interpolation","children":[],"call":["scan rest ","scan scan ","StringScanner  new ","Sass Util MultibyteStringScanner  new ","StringScanner  new  rest ","Sass Util MultibyteStringScanner  new  rest ","StringScanner  new  StringScanner  new  ","Sass Util MultibyteStringScanner  new  Sass Util MultibyteStringScanner  new  "]}," Sass Selector SelectorPseudoClass to_a":{"type":"method","name":"to_a","children":[],"call":["(str \":\") + + ","(str \":\") + ","@selector to_a "]}," Sass Selector SelectorPseudoClass initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Pseudo unify":{"type":"method","name":"unify","children":[],"call":["sel arg != "," arg ","sel arg ","sel name != "," name ","sel name ","sel type == ","sel type ","sel is_a? ","sels any? "," type == "," type ","sels + "," final? ","sel selector != "," selector ","sel selector "]}," Sass Selector Pseudo to_a":{"type":"method","name":"to_a","children":[],"call":["(send\n  (lvar :res) :<<\n  (str \"(\")) concat << ","(send\n  (lvar :res) :<<\n  (str \"(\")) concat ","Sass Util  strip_string_array ","res << ","(if\n  (send\n    (ivar :@type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) + ","@type == ","(if\n  (send\n    (send nil :syntactic_type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) + "," syntactic_type == "," syntactic_type ","(send\n  (lvar :(if\n  (send\n    (ivar :@type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) + ) :<<\n  (str \"(\")) concat << ","(send\n  (lvar :(if\n  (send\n    (send nil :syntactic_type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) + ) :<<\n  (str \"(\")) concat << ","(send\n  (lvar :(if\n  (send\n    (ivar :@type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) + ) :<<\n  (str \"(\")) concat ","(send\n  (lvar :(if\n  (send\n    (send nil :syntactic_type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) + ) :<<\n  (str \"(\")) concat ","(if\n  (send\n    (ivar :@type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) +  << ","(if\n  (send\n    (send nil :syntactic_type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) +  << "]}," Sass Selector Pseudo initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Attribute to_a":{"type":"method","name":"to_a","children":[],"call":["res << ","(send\n  (lvar :res) :<<\n  (ivar :@operator)) concat ","res concat ","res concat << ","(send\n  (lvar :res) :<<\n  (str \" \")) concat "]}," Sass Selector Attribute initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Interpolation unify":{"type":"method","name":"unify","children":[],"call":[" raise ","Sass SyntaxError  new "]}," Sass Selector Interpolation to_a":{"type":"method","name":"to_a","children":[],"call":[]}," Sass Selector Interpolation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Element unify":{"type":"method","name":"unify","children":[],"call":["(send\n  (const nil :Element) :new\n  (send nil :name)\n  (lvar :ns)) + ","sels [] ","Element  new "," name "," unify_namespaces ","sels first namespace ","sels first "," namespace ","(self) + "," name == ","sels first name "]}," Sass Selector Element to_a":{"type":"method","name":"to_a","children":[],"call":["@namespace + + ","@namespace + "]}," Sass Selector Element initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Universal unify":{"type":"method","name":"unify","children":[],"call":["(if\n  (send\n    (lvar :name) :==\n    (sym :universal))\n  (send\n    (const nil :Universal) :new\n    (lvar :ns))\n  (send\n    (const nil :Element) :new\n    (lvar :name)\n    (lvar :ns))) + ","sels [] ","Element  new ","Universal  new ","name == "," unify_namespaces ","sels first namespace ","sels first "," namespace ","sels empty? ","(self) + "," namespace == "," namespace nil? ","sels first name "]}," Sass Selector Universal to_a":{"type":"method","name":"to_a","children":[],"call":["@namespace + "]}," Sass Selector Universal initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Id unify":{"type":"method","name":"unify","children":[],"call":[" name != ","sel2 name "," name ","sel2 is_a? ","sels any? "]}," Sass Selector Id to_a":{"type":"method","name":"to_a","children":[],"call":[]}," Sass Selector Id initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Class to_a":{"type":"method","name":"to_a","children":[],"call":[]}," Sass Selector Class initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Parent unify":{"type":"method","name":"unify","children":[],"call":[" raise ","Sass SyntaxError  new "]}," Sass Selector Parent to_a":{"type":"method","name":"to_a","children":[],"call":[]}," Sass Selector SimpleSequence _eql?":{"type":"method","name":"_eql?","children":[],"call":["Sass Util  set_eql? "," rest ","other rest ","other base eql? "," base ","other base ","other subject? == "," subject? ","other subject? ","other pseudo_elements == "," pseudo_elements ","other pseudo_elements ","other rest eql? "]}," Sass Selector SimpleSequence _hash":{"type":"method","name":"_hash","children":[],"call":["(send nil :base) hash ","Sass Util  set_hash "," rest "," base "," rest hash "]}," Sass Selector SimpleSequence inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :members) :map) join ","m inspect "," members map "," members ","res << "," subject? ","(send\n  (send nil :members) :map) join  << "]}," Sass Selector SimpleSequence to_a":{"type":"method","name":"to_a","children":[],"call":["(send\n  (ivar :@members) :map) flatten ","sel to_a ","@members map ","res << "," subject? ","(send\n  (ivar :@members) :map) flatten  << "]}," Sass Selector SimpleSequence superselector?":{"type":"method","name":"superselector?","children":[],"call":[" rest subset? ","sseq rest "," rest "," base eql? ","sseq base "," base "," base nil? "," pseudo_elements eql? ","sseq pseudo_elements "," pseudo_elements ","pseudo superselector? ","pseudos all? ","our_spcs all? ","their_sseq rest include? ","their_sseq rest ","their_sseq is_a? ","their_seq members first ","their_seq members ","their_seq members length == ","their_seq members length ","their_pseudo selector members all? ","their_pseudo selector members ","their_pseudo selector ","their_subselector_pseudos any? ","our_sel selector ","our_sel is_a? "," rest all? ","(send\n  (array\n    (str \"matches\")\n    (str \"any\")\n    (str \"nth-child\")\n    (str \"nth-last-child\")) :map) flatten ","their_spcs [] ","(str \"matches\") map ","their_sseq selector_pseudo_classes "," selector_pseudo_classes ","their_sseq pseudo_elements ","their_sseq base "," selector_pseudo_classes  all? ","their_seq members first  rest include? ","their_seq members first  rest ","their_seq members first  is_a? ","(send\n  (array\n    (str \"matches\")\n    (str \"any\")\n    (str \"nth-child\")\n    (str \"nth-last-child\")) :map) flatten  any? ","their_sseq selector_pseudo_classes  [] ","their_seq members first  selector_pseudo_classes ","their_seq members first  pseudo_elements ","their_seq members first  base "]}," Sass Selector SimpleSequence unify":{"type":"method","name":"unify","children":[],"call":["SimpleSequence  new ","sel unify "," members inject "," members "," subject? ","other subject? ","other members "]}," Sass Selector SimpleSequence do_extend":{"type":"method","name":"do_extend","children":[],"call":["(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","seq do_extend ","seen + ","seen include? ","Sequence  new ","(send\n  (send\n    (lvar :extends) :get\n    (send\n      (send nil :members) :to_set)) :map) compact map ","(send\n  (send\n    (lvar :extends) :get\n    (send\n      (send nil :members) :to_set)) :map) compact ","seq members [] + ","seq members [] ","seq members ","seq members last unify ","seq members last "," members - "," members ","extends get map ","extends get "," members to_set ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","ex extender members [] + ","ex extender members [] ","ex extender members ","ex extender "," check_directives_match! ","ex extender members last unify ","ex extender members last ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :members) :to_set)))\n    (args\n      (arg :ex)\n      (arg :_))\n    (send\n      (lvar :ex) :extender)) :map) compact map ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :members) :to_set)))\n    (args\n      (arg :ex)\n      (arg :_))\n    (send\n      (lvar :ex) :extender)) :map) compact ","new_seq add_sources! "," sources + "," sources ","(send\n  (lvar :group) :map) none? ","group map ","e result= ","group each "," subject? ","(send\n  (lvar :group) :map) flatten ","(send\n  (const\n    (const nil :Sass) :Util) :group_by_to_a\n  (send\n    (lvar :extends) :get\n    (send\n      (send nil :members) :to_set))) map ","Sass Util  group_by_to_a ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :members) :to_set)))\n    (args\n      (arg :seq)\n      (arg :_))\n    (lvar :seq)) :map) compact map ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :members) :to_set)))\n    (args\n      (arg :seq)\n      (arg :_))\n    (lvar :seq)) :map) compact ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","e result == ","e result ","Sass Util  array_minus ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","groups uniq! ","groups flatten! ","groups map! ","groups compact! ","e target ","extends [] ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","groups unshift ","original add_sources! ","SimpleSequence  new "," source_range ","groups empty? ","replace ! ","original ! ","seen_with_pseudo_selectors + ","members to_set ","seen_with_pseudo_selectors << ","sel with_selector ","seq has_placeholder? ","extended members reject! ","extended members ","extended == ","sel selector ","sel selector do_extend ","sel is_a? ","Sass Util  enum_with_index map ","Sass Util  enum_with_index ","seen dup ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ","result each ","seq members length > ","seq members length ","seq members length == ","extended members any? ","sel selector members none? ","sel selector members ","sel normalized_name == ","sel normalized_name ","(send\n  (send\n    (self) :members) :map) flatten "," members map ","e success= ","(send\n  (send\n    (lvar :extends) :[]\n    (send\n      (lvar :members) :to_set)) :group_by) to_a ","extends [] group_by ","seq invisible? ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :Sequence  new ) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :seq members last unify )))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :ex extender members last unify )))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus ))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :(send\n  (lvar :group) :map) flatten ))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :Sequence  new ) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :seq members last unify )))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :ex extender members last unify )))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus ))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :(send\n  (lvar :group) :map) flatten ))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","Sequence  new  do_extend ","(send\n  (send\n    (lvar :extends) :get\n    (send\n      (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)) :map) compact map ","(send\n  (send\n    (lvar :extends) :get\n    (send\n      (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)) :map) compact map ","(send\n  (send\n    (lvar :extends) :get\n    (send\n      (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)) :map) compact ","(send\n  (send\n    (lvar :extends) :get\n    (send\n      (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)) :map) compact ","Sequence  new  members [] + ","seq (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  [] + ","seq (send\n  (send\n    (self) :members) :map) flatten  [] + ","Sequence  new  members [] ","seq (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  [] ","seq (send\n  (send\n    (self) :members) :map) flatten  [] ","Sequence  new  members ","seq (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  ","seq (send\n  (send\n    (self) :members) :map) flatten  ","Sequence  new  members last unify ","seq (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  last unify ","seq (send\n  (send\n    (self) :members) :map) flatten  last unify ","Sequence  new  members last ","seq (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  last ","seq (send\n  (send\n    (self) :members) :map) flatten  last "," (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  - "," (send\n  (send\n    (self) :members) :map) flatten  - "," (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  "," (send\n  (send\n    (self) :members) :map) flatten  "," (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  to_set "," (send\n  (send\n    (self) :members) :map) flatten  to_set ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :seq members last unify )))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :ex extender members last unify )))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar :Sass Util  array_minus ))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :(send\n  (lvar :group) :map) flatten ))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :seq members last unify )))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :ex extender members last unify )))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar :Sass Util  array_minus ))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :(send\n  (lvar :group) :map) flatten ))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)) :map)\n      (args\n        (arg :ex)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (send\n                    (lvar :ex) :extender) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send nil :check_directives_match!\n            (lvar :ex)\n            (lvar :parent_directives)) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (send\n                  (lvar :ex) :extender) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","ex extender (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  [] + ","ex extender (send\n  (send\n    (self) :members) :map) flatten  [] + ","ex extender (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  [] ","ex extender (send\n  (send\n    (self) :members) :map) flatten  [] ","ex extender (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  ","ex extender (send\n  (send\n    (self) :members) :map) flatten  ","ex extender (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  last unify ","ex extender (send\n  (send\n    (self) :members) :map) flatten  last unify ","ex extender (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  last ","ex extender (send\n  (send\n    (self) :members) :map) flatten  last ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n    (args\n      (arg :ex)\n      (arg :_))\n    (send\n      (lvar :ex) :extender)) :map) compact map ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n    (args\n      (arg :ex)\n      (arg :_))\n    (send\n      (lvar :ex) :extender)) :map) compact map ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n    (args\n      (arg :ex)\n      (arg :_))\n    (send\n      (lvar :ex) :extender)) :map) compact ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n    (args\n      (arg :ex)\n      (arg :_))\n    (send\n      (lvar :ex) :extender)) :map) compact ","new_Sequence  new  add_sources! ","Sequence  new  add_sources! ","e sel with_selector = ","(send\n  (const\n    (const nil :Sass) :Util) :group_by_to_a\n  (send\n    (lvar :extends) :get\n    (send\n      (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set))) map ","(send\n  (const\n    (const nil :Sass) :Util) :group_by_to_a\n  (send\n    (lvar :extends) :get\n    (send\n      (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set))) map ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :Sequence  new )\n            (arg :_))\n          (lvar :Sequence  new )) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus ))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :Sequence  new )\n            (arg :_))\n          (lvar :Sequence  new )) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus ))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :members) :to_set)))\n    (args\n      (arg :Sequence  new )\n      (arg :_))\n    (lvar :Sequence  new )) :map) compact map ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n    (args\n      (arg :seq)\n      (arg :_))\n    (lvar :seq)) :map) compact map ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n    (args\n      (arg :seq)\n      (arg :_))\n    (lvar :seq)) :map) compact map ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :members) :to_set)))\n    (args\n      (arg :Sequence  new )\n      (arg :_))\n    (lvar :Sequence  new )) :map) compact ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n    (args\n      (arg :seq)\n      (arg :_))\n    (lvar :seq)) :map) compact ","(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :group_by_to_a\n      (send\n        (lvar :extends) :get\n        (send\n          (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n    (args\n      (arg :seq)\n      (arg :_))\n    (lvar :seq)) :map) compact ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus ))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus ))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :Sequence  new )\n            (arg :_))\n          (lvar :Sequence  new )) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :Sequence  new ) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :seq members last unify )))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :ex extender members last unify )))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus ))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :Sequence  new )\n            (arg :_))\n          (lvar :Sequence  new )) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :Sequence  new ) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :seq members last unify )))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :ex extender members last unify )))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus ))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :seq)\n            (arg :_))\n          (lvar :seq)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :sel with_selector ) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :sel with_selector =\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten )\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten )\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :sel with_selector ) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :sel with_selector =\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten )\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten )\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","e sel with_selector  == ","e sel with_selector  ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :sel with_selector ) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :sel with_selector =\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :sel with_selector ) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :sel with_selector =\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (if\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :e)\n                (arg :_))\n              (send nil :check_directives_match!\n                (lvar :e)\n                (lvar :parent_directives))) :none?)\n          (next) nil)\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (lvar :extends) :[]\n    (send\n      (lvar :members) :to_set)) :group_by) to_a  uniq! ","(send\n  (send\n    (lvar :extends) :[]\n    (send\n      (lvar :members) :to_set)) :group_by) to_a  flatten! ","(send\n  (send\n    (lvar :extends) :[]\n    (send\n      (lvar :members) :to_set)) :group_by) to_a  map! ","(send\n  (send\n    (lvar :extends) :[]\n    (send\n      (lvar :members) :to_set)) :group_by) to_a  compact! ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :sel with_selector ) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :sel with_selector =\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten )\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten )\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :members)\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :sel with_selector ) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :sel with_selector =\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten )\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (const\n              (const nil :Sass) :Util) :array_minus\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten )\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :failed_to_unify)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :sel with_selector ) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :sel with_selector =\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :Sequence  new ))))\n        (array\n          (lvar :sels)\n          (lvar :new_Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :seq members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :ex extender members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :ex extender members last unify )))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :Sass Util  array_minus \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :Sass Util  array_minus )\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :Sequence  new \n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :Sequence  new ) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :Sequence  new )))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :(send\n  (lvar :group) :map) flatten \n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :(send\n  (lvar :group) :map) flatten )))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :(send\n  (lvar :group) :map) flatten )\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :sel with_selector ) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :sel with_selector =\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :sel with_selector =\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (block\n          (send\n            (const\n              (const nil :Sass) :Util) :group_by_to_a\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)))\n          (args\n            (arg :ex)\n            (arg :_))\n          (send\n            (lvar :ex) :extender)) :map)\n      (args\n        (arg :seq)\n        (arg :group))\n      (begin\n        (lvasgn :sels\n          (send\n            (block\n              (send\n                (lvar :group) :map)\n              (args\n                (arg :_)\n                (arg :s))\n              (lvar :s)) :flatten))\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :(send\n  (send\n    (self) :members) :map) flatten ) :-\n            (lvar :sels)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (if\n            (send\n              (send\n                (lvar :e) :result) :==\n              (sym :succeeded)) nil\n            (send\n              (lvar :e) :result=\n              (sym :failed_to_unify))))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :last) :unify\n              (lvar :self_without_sel)\n              (send nil :subject?))) nil\n          (next))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send\n            (lvar :e) :result=\n            (sym :succeeded)))\n        (block\n          (send\n            (lvar :group) :each)\n          (args\n            (arg :e)\n            (arg :_))\n          (send nil :check_directives_match!\n            (lvar :e)\n            (lvar :parent_directives)))\n        (lvasgn :new_seq\n          (send\n            (const nil :Sequence) :new\n            (send\n              (send\n                (send\n                  (lvar :seq) :(send\n  (send\n    (self) :members) :map) flatten ) :[]\n                (erange\n                  (int 0)\n                  (int -1))) :+\n              (array\n                (lvar :unified)))))\n        (send\n          (lvar :new_seq) :add_sources!\n          (send\n            (send nil :sources) :+\n            (array\n              (lvar :seq))))\n        (array\n          (lvar :sels)\n          (lvar :new_seq)))) :compact) :map) flatten ","(send\n  (send\n    (lvar :extends) :[]\n    (send\n      (lvar :members) :to_set)) :group_by) to_a  unshift ","(send\n  (send\n    (lvar :extends) :[]\n    (send\n      (lvar :members) :to_set)) :group_by) to_a  empty? ","Sequence  new  ! ","seen dup  + ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  to_set ","(send\n  (send\n    (self) :members) :map) flatten  to_set ","seen dup  << ","Sequence  new  has_placeholder? ","sel selector do_extend  members reject! ","extended (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  reject! ","extended (send\n  (send\n    (self) :members) :map) flatten  reject! ","sel selector do_extend  members ","extended (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  ","extended (send\n  (send\n    (self) :members) :map) flatten  ","sel selector do_extend  == ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten )) :map) flatten ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :(send\n  (send\n    (self) :members) :map) flatten )) :map) flatten ","sel with_selector  each ","Sequence  new  members length > ","seq (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  length > ","seq (send\n  (send\n    (self) :members) :map) flatten  length > ","Sequence  new  members length ","seq (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  length ","seq (send\n  (send\n    (self) :members) :map) flatten  length ","Sequence  new  members length == ","seq (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  length == ","seq (send\n  (send\n    (self) :members) :map) flatten  length == ","sel selector do_extend  members any? ","extended (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  any? ","extended (send\n  (send\n    (self) :members) :map) flatten  any? ","sel selector (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  none? ","sel selector (send\n  (send\n    (self) :members) :map) flatten  none? ","sel selector (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  ","sel selector (send\n  (send\n    (self) :members) :map) flatten  ","(send\n  (send\n    (self) :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :map) flatten ","(send\n  (send\n    (self) :(send\n  (send\n    (self) :members) :map) flatten ) :map) flatten "," (send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten  map "," (send\n  (send\n    (self) :members) :map) flatten  map ","(send\n  (send\n    (lvar :extends) :[]\n    (send\n      (lvar :(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (self) :members)) :map) flatten ) :to_set)) :group_by) to_a ","(send\n  (send\n    (lvar :extends) :[]\n    (send\n      (lvar :(send\n  (send\n    (self) :members) :map) flatten ) :to_set)) :group_by) to_a ","Sequence  new  invisible? "]}," Sass Selector SimpleSequence resolve_parent_refs":{"type":"method","name":"resolve_parent_refs","children":[],"call":["super_seq members [] + ","SimpleSequence  new ","super_seq members last members + ","@members [] ","super_seq members last members ","super_seq members last ","super_seq members ","super_seq members [] "," raise ","Sass SyntaxError  new ","Invalid parent selector:  + ","super_seq to_a join ","super_seq to_a ","super_seq members last is_a? ","@members size == ","@members size ","@members first is_a? ","@members first "," subject? ","members [] + + ","(lvar :newline) compact ","members [] + ","members last members + ","members last members ","members last ","members [] ","members last is_a? ","members pop ","members last == ","super_seq members dup ","CommaSequence  new ","Sequence  new ","parent_sub + ","(str \"Invalid parent selector for \\\"\") + + ","(str \"Invalid parent selector for \\\"\") + ","parent_sub []= ","parent_sub last class new ","parent_sub last name + ","parent suffix ","parent_sub last name ","parent_sub last ","parent_sub last type ","parent_sub last class ","parent_sub last arg ","parent_sub last namespace ","parent_sub last dup ","parent_sub dup ","parent suffix empty? ","super_cseq members map ","super_cseq members ","(lvasgn :parent\n  (send\n    (ivar :@members) :first)) is_a? ","super_seq to_s ","Sass Selector Pseudo  new ","parent_sub last selector ","parent suffix nil? ","(lvasgn :parent\n  (send\n    (lvar :resolved_members) :first)) is_a? ","resolved_members first ","(send\n  (ivar :@members) :map) flatten ","sel with_selector ","sel selector resolve_parent_refs ","implicit_parent ! ","sel selector ","sel is_a? ","@members map ","resolved_members [] ","super_seq super_seq members dup  [] + ","super_seq super_seq members dup  last super_seq members dup  + ","@super_seq members dup  [] ","super_seq super_seq members dup  last super_seq members dup  ","super_seq super_seq members dup  last ","super_seq super_seq members dup  ","super_seq super_seq members dup  [] ","Invalid @members first  selector:  + ","Invalid resolved_members first  selector:  + ","super_seq super_seq members dup  last is_a? ","@super_seq members dup  size == ","@super_seq members dup  size ","@super_seq members dup  first is_a? ","@super_seq members dup  first ","super_seq members dup  [] + + ","(lvar :members pop ) compact ","super_seq members dup  [] + ","super_seq members dup  last super_seq members dup  + ","super_seq members dup  last super_seq members dup  ","super_seq members dup  last ","super_seq members dup  [] ","super_seq members dup  last is_a? ","super_seq members dup  pop ","super_seq members dup  last == ","super_seq super_seq members dup  dup ","parent_sub dup  + ","members last members  + ","super_seq members last members  + ","@members first _sub + ","resolved_members first _sub + ","(str \"Invalid @members first  selector for \\\"\") + + ","(str \"Invalid resolved_members first  selector for \\\"\") + + ","(str \"Invalid @members first  selector for \\\"\") + ","(str \"Invalid resolved_members first  selector for \\\"\") + ","parent_sub dup  []= ","members last members  []= ","super_seq members last members  []= ","@members first _sub []= ","resolved_members first _sub []= ","parent_sub dup  last class new ","members last members  last class new ","super_seq members last members  last class new ","@members first _sub last class new ","resolved_members first _sub last class new ","parent_sub dup  last name + ","members last members  last name + ","super_seq members last members  last name + ","@members first _sub last name + ","resolved_members first _sub last name + ","@members first  suffix ","resolved_members first  suffix ","parent_sub dup  last name ","members last members  last name ","super_seq members last members  last name ","@members first _sub last name ","resolved_members first _sub last name ","parent_sub dup  last ","members last members  last ","super_seq members last members  last ","@members first _sub last ","resolved_members first _sub last ","parent_sub dup  last type ","members last members  last type ","super_seq members last members  last type ","@members first _sub last type ","resolved_members first _sub last type ","parent_sub dup  last class ","members last members  last class ","super_seq members last members  last class ","@members first _sub last class ","resolved_members first _sub last class ","parent_sub dup  last arg ","members last members  last arg ","super_seq members last members  last arg ","@members first _sub last arg ","resolved_members first _sub last arg ","parent_sub dup  last namespace ","members last members  last namespace ","super_seq members last members  last namespace ","@members first _sub last namespace ","resolved_members first _sub last namespace ","parent_sub dup  last dup ","members last members  last dup ","super_seq members last members  last dup ","@members first _sub last dup ","resolved_members first _sub last dup ","parent_sub dup  dup ","members last members  dup ","super_seq members last members  dup ","@members first _sub dup ","resolved_members first _sub dup ","@members first  suffix empty? ","resolved_members first  suffix empty? ","super_cseq super_seq members dup  map ","super_cseq super_seq members dup  ","(lvasgn :parent\n  (send\n    (ivar :@super_seq members dup ) :first)) is_a? ","(lvasgn :@members first \n  (send\n    (ivar :@members) :first)) is_a? ","(lvasgn :resolved_members first \n  (send\n    (ivar :@members) :first)) is_a? ","parent_sub dup  last selector ","members last members  last selector ","super_seq members last members  last selector ","@members first _sub last selector ","resolved_members first _sub last selector ","@members first  suffix nil? ","resolved_members first  suffix nil? ","(lvasgn :parent\n  (send\n    (lvar :resolved_super_seq members dup ) :first)) is_a? ","(lvasgn :@members first \n  (send\n    (lvar :resolved_members) :first)) is_a? ","(lvasgn :resolved_members first \n  (send\n    (lvar :resolved_members) :first)) is_a? ","(lvasgn :parent\n  (send\n    (lvar :(send\n  (ivar :@members) :map) flatten ) :first)) is_a? ","resolved_super_seq members dup  first ","(send\n  (ivar :@members) :map) flatten  first ","(send\n  (ivar :@super_seq members dup ) :map) flatten ","sel selector resolve_@members first _refs ","sel selector resolve_resolved_members first _refs ","implicit_@members first  ! ","implicit_resolved_members first  ! ","@super_seq members dup  map ","resolved_super_seq members dup  [] ","(send\n  (ivar :@members) :map) flatten  [] "]}," Sass Selector SimpleSequence initialize":{"type":"method","name":"initialize","children":[],"call":["Set  new "]}," Sass Selector SimpleSequence rest":{"type":"method","name":"rest","children":[],"call":["Set  new "," members "," members [] "," base "," members - - "," pseudo_elements "," members - "]}," Sass Selector SimpleSequence base":{"type":"method","name":"base","children":[],"call":[" members first "," members "," members first is_a? "]}," Sass Selector Simple unify_namespaces":{"type":"method","name":"unify_namespaces","children":[],"call":["ns2 == ","ns1 == ","ns2 nil? ","ns1 nil? "]}," Sass Selector Simple unify":{"type":"method","name":"unify","children":[],"call":["sels [] + + ","sels [] ","sels [] + ","sels + ","sel is_a? ","sels_with_ix find ","sels last type == ","sels last type ","sels last "," is_a? ","Sass Util  enum_with_index "," eql? ","sels any? ","sels last final? ","sels last is_a? "," is_a? ! ","sels first unify ","sels first ","sels first is_a? ","sels length == ","sels length ","sels each_with_index find ","sels each_with_index ","Sass Util  enum_with_index  find "]}," Sass Selector Simple eql?":{"type":"method","name":"eql?","children":[],"call":["other to_a eql? "," to_a ","other to_a ","other hash == "," hash ","other hash ","other class == "," class ","other class ","other equality_key eql? "," equality_key ","other equality_key ","other equality_key == "]}," Sass Selector Simple hash":{"type":"method","name":"hash","children":[],"call":[" to_a hash "," to_a "," equality_key hash "," equality_key "]}," Sass Selector Simple inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :to_a) :map) join ","e to_sass ","e is_a? "," to_a map "," to_a "," to_s "]}," Sass Selector Simple to_a":{"type":"method","name":"to_a","children":[],"call":["Sass Util  abstract "]}," Sass Selector Sequence _eql?":{"type":"method","name":"_eql?","children":[],"call":["(send\n  (send\n    (lvar :other) :members) :reject) eql? ","m == "," members reject "," members ","other members reject ","other members "]}," Sass Selector Sequence _hash":{"type":"method","name":"_hash","children":[],"call":["(send\n  (send nil :members) :reject) hash ","m == "," members reject "," members "]}," Sass Selector Sequence subweave_superselector?":{"type":"method","name":"subweave_superselector?","children":[],"call":["sseq1 first superselector? ","sseq2 first ","sseq1 first "," subweave_superselector? ","sseq2 [] ","sseq2 size == ","sseq2 size ","sseq2 [] == ","sseq2 size > ","sseq1 [] ","sseq1 size == ","sseq1 size ","sseq2 [] != ","sseq1 [] == ","sseq1 size > ","sseq2 last is_a? ","sseq2 last ","sseq1 last is_a? ","sseq1 last ","e == ","sseq2 reject ","sseq1 reject "]}," Sass Selector Sequence group_selectors":{"type":"method","name":"group_selectors","children":[],"call":["newseq << ","head << ","tail shift ","tail first is_a? ","tail first ","head last is_a? ","head last ","tail empty? ! ","tail empty? ","seq dup ","seq dup  shift ","seq dup  first is_a? ","seq dup  first ","seq dup  empty? ! ","seq dup  empty? "]}," Sass Selector Sequence chunks":{"type":"method","name":"chunks","children":[],"call":["chunk2 + ","chunk1 + ","chunk2 empty? ","chunk1 empty? ","chunk2 << ","seq2 shift ","chunk1 << ","seq1 shift "]}," Sass Selector Sequence subweave":{"type":"method","name":"subweave","children":[],"call":["p flatten ","Sass Util  paths map ","Sass Util  paths ","c empty? ","diff reject! ","diff << ","s empty? "," chunks ","seq2 shift ","seq1 shift ","diff << << ","lcs shift "," subweave_superselector? ","lcs first ","s first ","lcs empty? ","s2 first is_a? ","s2 first ","s1 first is_a? ","s1 first ","s1 == ","Sass Util  lcs "," group_selectors ","seq2 empty? ","seq1 empty? "," merge_initial_ops "," path_has_two_subjects? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :paths\n    (lvar :diff)) :map) reject ","sel is_a? ","fin map "," parent_superselector? "," merge_final_ops ","seq2 dup ","seq1 dup "," superselector? ","seq1 unshift ","seq2 unshift ","root1 unify "," has_root? ","seq2 first ","seq1 first ","unified members first members ","unified members first ","unified members ","unified members length == ","unified members length ","Sequence  new unify ","Sequence  new "," must_unify? "," group_selectors  shift "," group_selectors  empty? "," merge_ merge_initial_ops ial_ops "," merge_final_ops  map "," merge_ merge_final_ops al_ops "," group_selectors  dup "," group_selectors  unshift ","root1 unify 1 unify "," has_root1 unify ? "," group_selectors  first ","Sequence  new unify  members first members ","Sequence  new unify  members first ","Sequence  new unify  members ","Sequence  new unify  members length == ","Sequence  new unify  members length "]}," Sass Selector Sequence weave":{"type":"method","name":"weave","children":[],"call":["afters empty? ","Sass Util  flatten ","seqs + "," subweave map "," subweave ","befores map ","last_current unshift ","current pop ","current last is_a? ","current last ","last_current first is_a? ","last_current first ","current empty? ! ","current empty? ","afters shift dup ","afters shift ","path dup ","sub map ","prefixes map ","current dup ","path each ","befores map! ","(send\n  (lvar :prefixes) :map) flatten ","path dup  empty? ","  subweave weave map ","  subweave weave ","Sass Util  flatten  map ","last_afters shift dup  unshift ","last_current dup  unshift ","afters shift dup  pop ","current dup  pop ","afters shift dup  last is_a? ","current dup  last is_a? ","afters shift dup  last ","current dup  last ","last_afters shift dup  first is_a? ","last_current dup  first is_a? ","last_afters shift dup  first ","last_current dup  first ","afters shift dup  empty? ! ","current dup  empty? ! ","afters shift dup  empty? ","current dup  empty? ","path dup  shift dup ","path dup  shift "," subweave  map ","(send\n  (lvar :prefixes) :map) flatten  map ","afters shift dup  dup ","current dup  dup ","Sass Util  flatten  map! ","(send\n  (lvar :Sass Util  flatten ) :map) flatten ","(send\n  (lvar :(send\n  (lvar :prefixes) :map) flatten ) :map) flatten "]}," Sass Selector Sequence inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :members) :map) join ","m inspect "," members map "," members "]}," Sass Selector Sequence to_a":{"type":"method","name":"to_a","children":[],"call":["Sass Util  intersperse flatten compact ","Sass Util  intersperse flatten ","Sass Util  intersperse ","seq_or_op to_a ","seq_or_op is_a? ","@members map ","ary flatten compact ","ary flatten ","Sass Util  substitute ","Sass Util  replace_subseq ","Sass Util  substitute  flatten compact ","Sass Util  intersperse  flatten compact ","Sass Util  replace_subseq  flatten compact ","Sass Util  intersperse flatten compact  flatten compact ","Sass Util  substitute  flatten ","Sass Util  intersperse  flatten ","Sass Util  replace_subseq  flatten ","Sass Util  intersperse flatten compact  flatten "]}," Sass Selector Sequence superselector?":{"type":"method","name":"superselector?","children":[],"call":[" members last superselector? "," members last "," members "," members size == "," members size ","sseq1 first superselector? ","sseq2 first ","sseq1 first "," superselector? ","sseq2 [] ","sseq2 [] == ","sseq2 size > ","sseq2 size ","sseq1 [] ","sseq2 [] != ","sseq1 [] == ","sseq1 size > ","sseq1 size ","sseq2 last is_a? ","sseq2 last ","sseq1 last is_a? ","sseq1 last ","e == ","sseq2 reject ","sseq1 reject "," _superselector? ","seq members "]}," Sass Selector Sequence do_extend":{"type":"method","name":"do_extend","children":[],"call":["Sequence  new ","Sass Util  flatten map ","Sass Util  flatten "," weave ","paths map ","Sass Util  paths ","choices unshift ","seq superselector? ","extended any? ","seq members ","extended map ","sseq_or_op do_extend ","sseq_or_op is_a? "," members map "," members "," trim ","Sass Util  paths map "," trim map ","extended first add_sources! ","extended first "," has_placeholder? ! "," has_placeholder? "," invisible? ! "," invisible? ","Sass Util  paths  map ","Sass Util  Sass Util  paths  ","sseq_or_op do_extend  any? ","sseq_or_op do_extend  map ","Sass Util  Sass Util  paths  map ","sseq_or_op do_extend  first add_sources! ","sseq_or_op do_extend  first "]}," Sass Selector Sequence resolve_parent_refs":{"type":"method","name":"resolve_parent_refs","children":[],"call":["Sequence  new ","(send\n  (lvar :members) :map) flatten ","seq_or_op resolve_parent_refs ","seq_or_op is_a? ","members map ","members << ","SimpleSequence  new ","Parent  new ","seq_or_op members first is_a? ","seq_or_op members first ","seq_or_op members ","members any? ","members shift ","members first == ","members first ","members slice! ","@members dup ","CommaSequence  new ","(send\n  (lvar :path) :map) flatten ","path map ","Sass Util  paths map ","Sass Util  paths ","sseq_or_op resolve_parent_refs members ","sseq_or_op resolve_parent_refs ","sseq_or_op is_a? ","contains_parent_ref ! ","implicit_parent ! "," contains_parent_ref? ","path_members flatten ","path_members [] unshift ","path_members [] shift ","path_members [] ","path_members [] [] == ","path_members [] [] ","path_members length == ","path_members length ","(send\n  (lvar :@members dup ) :map) flatten ","@members dup  map ","@members dup  << ","seq_or_op @members dup  first is_a? ","seq_or_op @members dup  first ","seq_or_op @members dup  ","@members dup  any? ","@members dup  shift ","@members dup  first == ","@members dup  first ","@members dup  slice! ","@@members dup  dup ","sseq_or_op resolve_parent_refs @members dup  "," contains_parent_ref?  ! ","  contains_parent_ref? ? ","path_@members dup  flatten ","path_@members dup  [] unshift ","path_@members dup  [] shift ","path_@members dup  [] ","path_@members dup  [] [] == ","path_@members dup  [] [] ","path_@members dup  length == ","path_@members dup  length "]}," Sass Selector Sequence initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Sequence filename=":{"type":"method","name":"filename=","children":[],"call":["m filename= ","m is_a? "," members each "," members "]}," Sass Selector Sequence line=":{"type":"method","name":"line=","children":[],"call":["m line= ","m is_a? "," members each "," members "]}," Sass Selector CommaSequence _eql?":{"type":"method","name":"_eql?","children":[],"call":["other members eql? "," members ","other members ","other class == "," class ","other class "]}," Sass Selector CommaSequence _hash":{"type":"method","name":"_hash","children":[],"call":[" members hash "," members "]}," Sass Selector CommaSequence to_a":{"type":"method","name":"to_a","children":[],"call":["arr delete ","Sass Util  intersperse flatten ","Sass Util  intersperse ","m to_a ","@members map ","Sass Util  replace_subseq ","Sass Util  intersperse flatten  delete "]}," Sass Selector CommaSequence inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :members) :map) join ","m inspect "," members map "," members "]}," Sass Selector CommaSequence do_extend":{"type":"method","name":"do_extend","children":[],"call":["CommaSequence  new ","(send\n  (send nil :members) :map) flatten ","seq do_extend "," members map "," members ","extended unshift ","extended include? ","seq has_placeholder? ","seq do_extend  unshift ","seq do_extend  include? "]}," Sass Selector CommaSequence resolve_parent_refs":{"type":"method","name":"resolve_parent_refs","children":[],"call":["CommaSequence  new ","(send\n  (send\n    (lvar :super_cseq) :members) :map) flatten ","seq resolve_parent_refs ","@members map ","super_cseq members map ","super_cseq members "," raise ","Sass SyntaxError  new ","ssel is_a? ","sel_or_op members any? ","sel_or_op members ","sel_or_op is_a? ","sel members any? ","sel members ","@members any? ","super_cseq nil? ","Sass Util  flatten_vertically ","seq resolve_parent_refs members "," contains_parent_ref? "]}," Sass Selector CommaSequence initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector AbstractSequence eql?":{"type":"method","name":"eql?","children":[],"call":[" _eql? ","other hash == "," hash ","other hash ","other class == "," class ","other class "]}," Sass Selector AbstractSequence hash":{"type":"method","name":"hash","children":[],"call":[" _hash "]}," Sass Selector AbstractSequence filename=":{"type":"method","name":"filename=","children":[],"call":["m filename= "," members each "," members "]}," Sass Selector AbstractSequence line=":{"type":"method","name":"line=","children":[],"call":["m line= "," members each "," members "]}," Sass SCSS StaticParser special_directive":{"type":"method","name":"special_directive","children":[],"call":["(str \"media\") include? ","name == "]}," Sass SCSS StaticParser use_css_import?":{"type":"method","name":"use_css_import?","children":[],"call":[]}," Sass SCSS StaticParser interp_ident":{"type":"method","name":"interp_ident","children":[],"call":[" tok "," ident "]}," Sass SCSS StaticParser interp_string":{"type":"method","name":"interp_string","children":[],"call":[" tok "]}," Sass SCSS StaticParser interpolation":{"type":"method","name":"interpolation","children":[],"call":[]}," Sass SCSS StaticParser script_value":{"type":"method","name":"script_value","children":[],"call":[]}," Sass SCSS StaticParser variable":{"type":"method","name":"variable","children":[],"call":[]}," Sass SCSS StaticParser parse_selector":{"type":"method","name":"parse_selector","children":[],"call":["seq filename= ","seq line= "," expected ","@scanner eos? "," expr! "," init_scanner! "," expr!  filename= "," expr!  line= "]}," Sass SCSS ScriptParser assert_done":{"type":"method","name":"assert_done","children":[],"call":["@lexer unpeek! "]}," Sass SCSS ScriptParser lexer_class":{"type":"method","name":"lexer_class","children":[],"call":["klass send ","Class  new ","Class  new  send "]}," Sass SCSS ScriptLexer variable":{"type":"method","name":"variable","children":[],"call":[" _variable "," scan "]}," Sass SCSS RX quote":{"type":"method","name":"quote","children":[],"call":[]}," Sass SCSS RX escape_char":{"type":"method","name":"escape_char","children":[],"call":[]}," Sass SCSS RX escape_ident":{"type":"method","name":"escape_ident","children":[],"call":[]}," Sass SCSS Parser tok":{"type":"method","name":"tok","children":[],"call":["s << ","@strs each ","rx != ","@strs empty? ! ","@strs empty? ","res count ","@scanner scan ","res slice! ","@scanner [] length -@ ","@scanner [] length ","@scanner [] ","@scanner pos ","res size ","res [] size ","res [] ","res rindex ","newline_count > ","@scanner scan  count ","@scanner scan  slice! ","@scanner scan  size ","@scanner scan  [] size ","@scanner scan  [] ","@scanner scan  rindex ","res count  > "]}," Sass SCSS Parser expected":{"type":"method","name":"expected","children":[],"call":[" class expected "," class "," throw "]}," Sass SCSS Parser rethrow":{"type":"method","name":"rethrow","children":[],"call":["err [] call ","err [] ","@scanner pos= ","StringScanner  new ","@scanner string "," throw ","Sass Util MultibyteStringScanner  new ","StringScanner  new  pos= ","Sass Util MultibyteStringScanner  new  pos= ","StringScanner  new  string ","Sass Util MultibyteStringScanner  new  string "]}," Sass SCSS Parser catch_error":{"type":"method","name":"catch_error","children":[],"call":["@scanner pos= "," catch ","@scanner pos ","logger uninstall! ","logger flush ","Sass Logger Delayed  install! ","@scanner @scanner pos = ","@scanner @scanner pos  ","Sass Logger Delayed  install!  uninstall! ","Sass Logger Delayed  install!  flush "]}," Sass SCSS Parser err":{"type":"method","name":"err","children":[],"call":[" raise ","Sass SyntaxError  new "," throw "]}," Sass SCSS Parser tok!":{"type":"method","name":"tok!","children":[],"call":[" expected ","rx inspect ","string inspect ","rx source == ","Regexp  escape ","rx source ","rx source gsub ","TOK_NAMES  [] "," tok ","source == "," expec tok ed ","rx inspec tok  ","rx source gsub  inspect ","s tok ring inspec tok  ","rx rx source gsub  == ","rx rx source gsub  ","rx rx source gsub  gsub ","  tok ok ","rx source gsub  == "]}," Sass SCSS Parser expr!":{"type":"method","name":"expr!","children":[],"call":[" expected ","name to_s ","EXPR_NAMES  [] "," send ","  send xp send ct send d ","nam send  to_s "," s send nd "]}," Sass SCSS Parser tok?":{"type":"method","name":"tok?","children":[],"call":["@scanner match? "]}," Sass SCSS Parser merge":{"type":"method","name":"merge","children":[],"call":["Sass Util  merge_adjacent_strings ","(lvar :arr) flatten "]}," Sass SCSS Parser sass_script":{"type":"method","name":"sass_script","children":[],"call":[" raise "," throw ","parser line ","parser send "," class sass_script_parser new ","@scanner pos - ","@scanner string [] rindex ","@scanner string [] ","@scanner pos ","@scanner string "," class sass_script_parser "," class ","s << ","@strs each ","result to_sass ","@strs empty? ","parser offset "," class sass_script_parser new  line "," class sass_script_parser new  send "," class sass_script_ class sass_script_parser new  new "," class sass_script_ class sass_script_parser new  ","parser send  to_sass "," class sass_script_parser new  offset "]}," Sass SCSS Parser sass_script_parser":{"type":"method","name":"sass_script_parser","children":[],"call":[]}," Sass SCSS Parser node":{"type":"method","name":"node","children":[],"call":["node line= ","node source_range= "," range ","start_pos line "]}," Sass SCSS Parser str?":{"type":"method","name":"str?","children":[],"call":["@strs pop ","@strs last ","@strs push ","@scanner pos= "," throw_error ","@scanner pos ","@scanner @scanner pos = ","@scanner @scanner pos  "]}," Sass SCSS Parser str":{"type":"method","name":"str","children":[],"call":["@strs pop ","@strs last ","@strs push ","String  new "]}," Sass SCSS Parser interp_name":{"type":"method","name":"interp_name","children":[],"call":[" interp_ident "]}," Sass SCSS Parser interp_ident":{"type":"method","name":"interp_ident","children":[],"call":["res << "," interpolation "," tok "," name "," ident "]}," Sass SCSS Parser _interp_string":{"type":"method","name":"_interp_string","children":[],"call":["res << << "," tok ","res << "," expr! ","res last slice! ","res last ","@scanner pos ","@scanner [] == ","@scanner [] ","Sass Script Lexer STRING_REGULAR_EXPRESSIONS  [] ","Sass Script Lexer STRING_REGULAR_EXPRESSIONS  [] [] "]}," Sass SCSS Parser interp_string":{"type":"method","name":"interp_string","children":[],"call":[" _interp_string "]}," Sass SCSS Parser interpolation":{"type":"method","name":"interpolation","children":[],"call":[" sass_script "," tok "]}," Sass SCSS Parser function":{"type":"method","name":"function","children":[],"call":[" tok! "," expr "," ss "," str ","Sass Shared  balance ","name == "," tok "," tok  == "]}," Sass SCSS Parser term":{"type":"method","name":"term","children":[],"call":[" expr! "," tok "," unary_operator "," function "," var_expr "," interp_ident "," interp_string "," interp_uri "," unary_ unary_operator erator "," unary_ tok erator "]}," Sass SCSS Parser expr":{"type":"method","name":"expr","children":[],"call":["res << << << "," ss "," str ","res << << ","res << "," term "," operator ","res flatten "," s term r ","  term erm "," opera term or ","  operator perat operator r ","res fla term  term en "]}," Sass SCSS Parser nested_properties!":{"type":"method","name":"nested_properties!","children":[],"call":[" block "," err "," raise ","Sass SyntaxError  new ","Sass Util  sass_warn ","node name first start_with? ","node name first ","node name ","node name first is_a? "]}," Sass SCSS Parser plain_value":{"type":"method","name":"plain_value","children":[],"call":["expression << "," tok "," expr "," tok? ! "," tok? ","(send nil :str) empty? ! ","(send nil :str) empty? "," ss "," str "," expr  << "]}," Sass SCSS Parser value!":{"type":"method","name":"value!","children":[],"call":[" sass_script ","Sass Script String  new ","val strip "," tok "," tok? "," tok? ! ","(send nil :str) empty? ! ","(send nil :str) empty? "," ss "," str ","str source_range= "," range ","str line= ","start_pos line ","Sass Script Tree Literal  new ","Sass Script Value String  new "," source_position "," source_position line ","val lstrip sub ","val lstrip ","Sass Util  strip_except_escapes "," tok  strip ","val lstrip sub  strip ","val Sass Script Tree Literal  new ip ","(send nil :Sass Script Tree Literal  new ) empty? ! ","(send nil :Sass Script Tree Literal  new ) empty? "," Sass Script Tree Literal  new  ","Sass Script Tree Literal  new  source_range= ","Sass Script Tree Literal  new  line= "," source_position  line "," tok  lstrip sub ","val lstrip sub  lstrip sub ","val lSass Script Tree Literal  new ip sub "," tok  lstrip ","val lstrip sub  lstrip ","val lSass Script Tree Literal  new ip ","Sass Util  Sass Script Tree Literal  new ip_except_escapes "]}," Sass SCSS Parser declaration":{"type":"method","name":"declaration","children":[],"call":[" nested_properties! "," node ","Sass Tree PropNode  new ","important ! ! ","important ! ","name flatten compact ","name flatten "," tok? "," ss "," tok "," value! "," tok! ","name << ","name is_a? "," interp_ident "," expr! "," str ","s !~ ","node value_source_range= "," range ","node name_source_range= "," source_position "," Array ","name first start_with? ","name first ","name first is_a? "," ne tok ted_propertie tok ! ","  node  ","Sa tok  tok  Tree PropNode  new "," tok  ! ! "," tok  ! "," interp_ident  flatten compact "," Array  flatten compact "," interp_ident  flatten "," Array  flatten ","  tok  tok  ","  value! ! "," interp_ident  << "," Array  << "," interp_ident  is_a? "," Array  is_a? ","name i tok _a? ","  tok tr "," tok  !~ "," node  value_source_range= ","node value_ tok ource_range= ","node  value! _source_range= "," node  name_source_range= ","node  interp_ident _source_range= ","node  Array _source_range= ","node name_ tok ource_range= ","  tok ource_po tok ition "," interp_ident  first start_with? "," Array  first start_with? ","name fir tok t  tok tart_with? "," interp_ident  first "," Array  first ","name fir tok t "," interp_ident  first is_a? "," Array  first is_a? ","name fir tok t i tok _a? "]}," Sass SCSS Parser negation":{"type":"method","name":"negation","children":[],"call":["Selector SelectorPseudoClass  new ","name [] "," tok! "," selector_comma_sequence "," ss "," tok ","  selector_comma_sequence ector_comma_sequence "]}," Sass SCSS Parser pseudo_expr":{"type":"method","name":"pseudo_expr","children":[],"call":["res << << "," ss "," str ","res << "," interpolation "," tok "," interp_string "," pseudo_expr_token ","r pseudo_expr_token s << << ","r pseudo_expr_token s << "," int pseudo_expr_token rpolation "," int pseudo_expr_token rp_string "," ps pseudo_expr_token udo_ pseudo_expr_token xpr_tok pseudo_expr_token n "]}," Sass SCSS Parser pseudo":{"type":"method","name":"pseudo","children":[],"call":["Selector Pseudo  new "," merge ","s == "," tok! "," expr! "," ss "," tok ","arg concat ","arg << << "," str ","arg << ","Selector P tok eudo  new "," tok  == ","  tok  tok  "," expr!  concat "," expr!  << << ","  tok tr "," expr!  << "]}," Sass SCSS Parser attrib_name!":{"type":"method","name":"attrib_name!","children":[],"call":[" expr! "," tok! "," tok "," interp_ident "]}," Sass SCSS Parser attrib":{"type":"method","name":"attrib","children":[],"call":["Selector Attribute  new "," merge "," tok "," ss "," expr! "," attrib_name! "," interp_ident "," tok! "," interp_string "]}," Sass SCSS Parser interpolation_selector":{"type":"method","name":"interpolation_selector","children":[],"call":["Selector Interpolation  new "," interpolation "]}," Sass SCSS Parser element_name":{"type":"method","name":"element_name","children":[],"call":["Selector Element  new "," merge ","Selector Universal  new ","name == "," tok! "," interp_ident "," tok "," tok? "," qualified_name ","Sass Util  destructure "]}," Sass SCSS Parser id_selector":{"type":"method","name":"id_selector","children":[],"call":["Selector Id  new "," merge "," expr! "," tok "]}," Sass SCSS Parser class_selector":{"type":"method","name":"class_selector","children":[],"call":["Selector Class  new "," merge "," expr! "," tok "]}," Sass SCSS Parser parent_selector":{"type":"method","name":"parent_selector","children":[],"call":["Selector Parent  new "," tok "," interp_ident "]}," Sass SCSS Parser simple_selector_sequence":{"type":"method","name":"simple_selector_sequence","children":[],"call":["Selector SimpleSequence  new "," raise ","e message << << ","e message << ","e message "," expected "," tok? ","res << ","Selector Universal  new "," tok "," interpolation_selector "," pseudo "," negation "," attrib "," class_selector "," id_selector "," element_name "," expr "," parent_selector ","Sass Util  sass_warn "," class prior_snippet "," class "," throw_error ","sel =~ ","@scanner pos= "," simple_selector_sequence "," str? ","@scanner pos ","res [] is_a? ","res [] ","res length == ","res length "," placeholder_selector ","allow_var ! "," range "," source_position ","@scanner @scanner pos = ","@scanner @scanner pos  "," source_@scanner pos ition "]}," Sass SCSS Parser combinator":{"type":"method","name":"combinator","children":[],"call":[" tok "," reference_combinator "]}," Sass SCSS Parser _selector":{"type":"method","name":"_selector","children":[],"call":["Selector Sequence  new ","res compact ","res << ","(send nil :str) include? "," ss "," str "," simple_selector_sequence "," combinator "]}," Sass SCSS Parser selector_comma_sequence":{"type":"method","name":"selector_comma_sequence","children":[],"call":["Selector CommaSequence  new ","selectors []= ","Selector Sequence  new ","(str \"\\n\") + ","selectors last members ","selectors last ","ws include? ","selectors << "," _selector ","ws << "," ss "," str "," tok "," expr! "," _selector ectors []= "," _selector ectors last members "," _selector ectors last "," _selector ectors << "," _ _selector ector "]}," Sass SCSS Parser selector":{"type":"method","name":"selector","children":[],"call":["sel to_a "," _selector "," _selector  to_a "," _ _selector ector "]}," Sass SCSS Parser selector_sequence":{"type":"method","name":"selector_sequence","children":[],"call":["rules concat ","rules << << ","rules << "," selector ","ws << "," ss "," str "," tok "," expr! "," range "," source_position ","  tok ector "]}," Sass SCSS Parser declaration_or_ruleset":{"type":"method","name":"declaration_or_ruleset","children":[],"call":[" rethrow "," ruleset "," catch_error "," tok! "," tok? ","decl has_children "," declaration "," raise ","@scanner pos= ","@scanner pos "," block "," node ","Sass Tree RuleNode  new "," range "," merge ","selector << "," almost_any_value ","declaration is_a? ","declaration nil? "," try_declaration "," source_position "," declaration  has_children ","  declaration aration ","  try_declaration  ","@scanner @scanner pos = ","@scanner @scanner pos  "," almost_any_value  << "," declaration aration is_a? "," try_declaration  is_a? "," declaration aration nil? "," try_declaration  nil? "," try_ declaration aration "," try_ try_declaration  "," source_@scanner pos ition "]}," Sass SCSS Parser has_children?":{"type":"method","name":"has_children?","children":[],"call":["child_or_array has_children ","child_or_array last has_children ","child_or_array last ","child_or_array is_a? "]}," Sass SCSS Parser block_child":{"type":"method","name":"block_child","children":[],"call":[" declaration_or_ruleset "," directive "," variable "," ruleset ","context == "]}," Sass SCSS Parser block_contents":{"type":"method","name":"block_contents","children":[],"call":["node << "," block_child "," ss_comments "," block_given? "," has_children? "," tok "," block_ block_child  "," has_ block_child ren? "]}," Sass SCSS Parser block":{"type":"method","name":"block","children":[],"call":[" tok! "," block_contents ","node has_children= ","node source_range end_pos= "," source_position ","node source_range "]}," Sass SCSS Parser ruleset":{"type":"method","name":"ruleset","children":[],"call":[" block "," node ","Sass Tree RuleNode  new ","rules flatten compact ","rules flatten "," selector_sequence "," source_position "," range "," almost_any_value "," selector_sequence  flatten compact "," almost_any_value  flatten compact "," selector_sequence  flatten "," almost_any_value  flatten "]}," Sass SCSS Parser unary_operator":{"type":"method","name":"unary_operator","children":[],"call":[" tok "]}," Sass SCSS Parser operator":{"type":"method","name":"operator","children":[],"call":[" ss "," tok "," str "]}," Sass SCSS Parser variable":{"type":"method","name":"variable","children":[],"call":[" node ","Sass Tree VariableNode  new "," tok "," sass_script "," ss "," tok! "," raise ","Sass SyntaxError  new ","flag_name == "," source_position "," ident! ","flag_ tok!  == ","flag_ ident!  == "," tok!  == "," ident!  == "]}," Sass SCSS Parser charset_directive":{"type":"method","name":"charset_directive","children":[],"call":[" node ","Sass Tree CharsetNode  new "," ss ","@scanner [] "," tok! "," expr! "]}," Sass SCSS Parser media_expr":{"type":"method","name":"media_expr","children":[],"call":[" ss "," tok! "," expr! "," tok ","res << "," sass_script "," interpolation ","Sass Media Expression  new ","  interpolation olation "]}," Sass SCSS Parser media_query":{"type":"method","name":"media_query","children":[],"call":[" ss "," expr! "," tok "," media_expr ! "," media_expr "," tok ! "," tok! ","query expressions << ","query expressions ","Sass Media Query  new ","ident2 [] downcase == ","ident2 [] downcase ","ident2 [] ","ident2 [] is_a? ","ident2 length == ","ident2 length "," interp_ident "," interp_ident_or_var ","  media_expr ! ","  expr! ! "," media_ media_expr  ! "," media_ expr!  ! "," media_ media_expr  "," media_ expr!  ","query  media_expr essions << ","query  expr! essions << ","Sass Media Query  new  expressions << ","query  media_expr essions ","query  expr! essions ","Sass Media Query  new  expressions "," interp_ident  [] downcase == "," interp_ident_or_var  [] downcase == "," interp_ident  [] downcase "," interp_ident_or_var  [] downcase "," interp_ident  [] "," interp_ident_or_var  [] "," interp_ident  [] is_a? "," interp_ident_or_var  [] is_a? "," interp_ident  length == "," interp_ident_or_var  length == "," interp_ident  length "," interp_ident_or_var  length "]}," Sass SCSS Parser media_query_list":{"type":"method","name":"media_query_list","children":[],"call":[" ss "," expr! "," tok "," media_query ","queries << ","(send nil :str) strip "," str ","q strip ","Sass Media QueryList  new "," media_ media_query  "]}," Sass SCSS Parser media_directive":{"type":"method","name":"media_directive","children":[],"call":[" block "," node ","Sass Tree MediaNode  new ","(send nil :str) strip "," media_query_list "," str ","Sass Tree DirectiveNode  new "," media_query_list to_a "," expr! to_a "," expr! "]}," Sass SCSS Parser use_css_import?":{"type":"method","name":"use_css_import?","children":[],"call":[]}," Sass SCSS Parser import_arg":{"type":"method","name":"import_arg","children":[],"call":[" node ","Sass Tree ImportNode  new ","path strip ","Sass Tree DirectiveNode  new ","(str \"@import \") strip "," use_css_import? ","media strip empty? ! ","media strip empty? ","media strip ","path =~ ","(send nil :str) strip "," media_query_list "," str "," ss ","@scanner [] "," tok! "," tok ","Sass Tree CssImportNode  new ","media to_a ","Tree CssImportNode  new "," sass_script "," tok? ","media empty? ! ","media empty? ","Tree DirectiveNode  new ","node line= "," source_position ","str strip ","Sass Script Value String  quote ","str =~ "," string "," supports_clause "," Sass Tree ImportNode  new  "," Sass Tree CssImportNode  new  ","path  sass_script ip ","path  tok ip ","path  string ip ","( sass_script  \"@import \")  sass_script ip ","( tok  \"@import \")  tok ip ","( string  \"@import \")  string ip ","(send nil :str) strip  strip empty? ! "," media_query_list  strip empty? ! ","media  sass_script ip empty? ! ","media  tok ip empty? ! ","media  string ip empty? ! ","(send nil :str) strip  strip empty? "," media_query_list  strip empty? ","media  sass_script ip empty? ","media  tok ip empty? ","media  string ip empty? ","(send nil :str) strip  strip "," media_query_list  strip ","media  sass_script ip ","media  tok ip ","media  string ip ","(send nil : sass_script )  sass_script ip ","(send nil : tok )  tok ip ","(send nil : string )  string ip "," (send nil :str) strip _query_list ","  media_query_list _query_list ","  sass_script  ","  tok  ","  string  ","(send nil :str) strip  to_a "," media_query_list  to_a ","(send nil :str) strip  empty? ! "," media_query_list  empty? ! ","(send nil :str) strip  empty? "," media_query_list  empty? ","Sass Tree ImportNode  new  line= ","Sass Tree CssImportNode  new  line= "," sass_script   sass_script ip "," tok   tok ip "," string   string ip "," sass_script  =~ "," tok  =~ "," string  =~ ","  sass_script ing ","  tok ing ","  string ing ","  supports_clause _clause "]}," Sass SCSS Parser import_directive":{"type":"method","name":"import_directive","children":[],"call":[" tok ! "," tok "," use_css_import? ","values << "," expr! "," loop "," ss "]}," Sass SCSS Parser extend_directive":{"type":"method","name":"extend_directive","children":[],"call":[" node ","Sass Tree ExtendNode  new "," expr! ","optional ! ! ","optional ! "," ss "," tok "," range ","Sass Util  strip_string_array "," source_position "," tok  ! ! "," tok  ! "]}," Sass SCSS Parser else_directive":{"type":"method","name":"else_directive","children":[],"call":[" err "," raise ","Sass SyntaxError  new "]}," Sass SCSS Parser else_block":{"type":"method","name":"else_block","children":[],"call":["@scanner pos= "," else_block "," ss ","@scanner pos ","node add_else "," block ","Sass Tree IfNode  new "," sass_script "," tok "," node "," source_position ","@scanner @scanner pos = ","@scanner @scanner pos  "," source_@scanner pos ition "]}," Sass SCSS Parser if_directive":{"type":"method","name":"if_directive","children":[],"call":["@scanner pos= "," else_block "," ss ","@scanner pos "," block "," node ","Sass Tree IfNode  new "," sass_script ","@scanner @scanner pos = ","@scanner @scanner pos  ","  block  "]}," Sass SCSS Parser while_directive":{"type":"method","name":"while_directive","children":[],"call":[" block "," node ","Sass Tree WhileNode  new "," ss "," sass_script "]}," Sass SCSS Parser each_directive":{"type":"method","name":"each_directive","children":[],"call":[" block "," node ","Sass Tree EachNode  new "," ss "," sass_script "," tok! ","vars << "," tok "," ident! "," tok! s << "]}," Sass SCSS Parser for_directive":{"type":"method","name":"for_directive","children":[],"call":[" block "," node ","Sass Tree ForNode  new "," ss "," sass_script ","(or\n  (send nil :tok\n    (regexp\n      (str \"to\")\n      (regopt)))\n  (send nil :tok!\n    (regexp\n      (str \"through\")\n      (regopt)))) == "," tok! "," tok ","Set  [] "," ident! ","(or\n  (send nil : sass_script k\n    (regexp\n      (str \" sass_script \")\n      (regopt)))\n  (send nil : sass_script k!\n    (regexp\n      (str \"through\")\n      (regopt)))) == ","  sass_script k! ","  sass_script k "]}," Sass SCSS Parser warn_directive":{"type":"method","name":"warn_directive","children":[],"call":[" node ","Sass Tree WarnNode  new "," sass_script "]}," Sass SCSS Parser debug_directive":{"type":"method","name":"debug_directive","children":[],"call":[" node ","Sass Tree DebugNode  new "," sass_script "]}," Sass SCSS Parser return_directive":{"type":"method","name":"return_directive","children":[],"call":[" node ","Sass Tree ReturnNode  new "," sass_script "]}," Sass SCSS Parser function_directive":{"type":"method","name":"function_directive","children":[],"call":[" block "," node ","Sass Tree FunctionNode  new "," ss "," sass_script "," tok! "," ident! "]}," Sass SCSS Parser include_directive":{"type":"method","name":"include_directive","children":[],"call":[" node ","Sass Tree MixinNode  new "," ss "," sass_script "," tok! "," block ","include_node has_children= "," tok? "," ident! "," node  has_children= "]}," Sass SCSS Parser mixin_directive":{"type":"method","name":"mixin_directive","children":[],"call":[" block "," node ","Sass Tree MixinDefNode  new "," ss "," sass_script "," tok! "," ident! "]}," Sass SCSS Parser special_directive":{"type":"method","name":"special_directive","children":[],"call":[" send ","DIRECTIVES  include? ","name gsub to_sym ","name gsub ","name tr to_sym ","name tr ","name gsub to_name gsub to_sym  ","name gsub to_name tr to_sym  ","name tr to_name gsub to_sym  ","name tr to_name tr to_sym  "]}," Sass SCSS Parser directive":{"type":"method","name":"directive","children":[],"call":[" tok! "," block_contents ","node has_children= "," tok "," node ","Sass Tree DirectiveNode  new ","(str \"@\") strip ","CssParser  new parse_selector_string ","CssParser  new "," expr "," str "," special_directive "," ss "," directive_body "," prefixed_directive ","(dstr\n  (str \"@\")\n  (begin\n    (lvar :name))\n  (str \" \")) + ","Sass Util  strip_string_array "," selector "," source_position "," almost_any_value "," ident! "," node  has_children= ","  node  "," special_ special_directive ective "," special_ prefixed_directive ective ","  special_directive ective_body ","  prefixed_directive ective_body "," prefixed_ special_directive ective "," prefixed_ prefixed_directive ective ","(dstr\n  (str \"@\")\n  (begin\n    (lvar : tok! ))\n  (str \" \")) + ","(dstr\n  (str \"@\")\n  (begin\n    (lvar : ident! ))\n  (str \" \")) + "," almost_any_(dstr\n  (str \"@\")\n  (begin\n    (lvar :name))\n  (str \" \")) + ue "," almost_any_ almost_any_value ue "]}," Sass SCSS Parser process_comment":{"type":"method","name":"process_comment","children":[],"call":["node << ","comment line= ","@line - ","text count ","Sass Tree CommentNode  new ","pre_str + ","text sub gsub + ","text sub gsub ","text sub ","@scanner string [] reverse [] reverse gsub ","@scanner string [] reverse [] reverse ","@scanner string [] reverse [] ","@scanner string [] reverse ","@scanner string [] ","@scanner pos ","@scanner string ","text =~ ","value unshift ","str sub gsub + ","str sub gsub ","str sub ","Sass Util  with_extracted_values ","value [] slice! ","value [] ","Sass Engine  parse_interp ","@scanner pos - ","text size ","silent ! ","last_line_before_comment gsub ","string_before_comment [] ","newline_before_comment + ","string_before_comment rindex ","text length ","@scanner string rindex "," node ","Sass Source Position  new ","line_before_comment gsub ","index_before_line + ","comment_start - ","Sass Tree CommentNode  new  line= "," node  line= ","comment @line - = ","@@line -  - ","text sub gsub +  count ","@scanner string [] reverse [] reverse gsub  + ","text sub gsub +  sub gsub + ","text sub gsub +  sub gsub ","text sub gsub +  sub ","text sub gsub +  =~ ","Sass Engine  parse_interp  unshift ","Sass Util  with_extracted_Sass Engine  parse_interp s ","Sass Engine  parse_interp  [] slice! ","Sass Engine  parse_interp  [] ","text sub gsub +  size ","text =~  ! ","last_line_before_Sass Tree CommentNode  new  gsub ","last_line_before_ node  gsub ","last_@line - _before_comment gsub ","string_before_comment []  gsub ","@scanner string []  gsub ","last_@scanner string []  gsub ","string_before_Sass Tree CommentNode  new  [] ","string_before_ node  [] ","@scanner string []  [] ","newline_before_Sass Tree CommentNode  new  + ","newline_before_ node  + ","new@line - _before_comment + ","string_before_comment rindex  + ","@scanner string rindex  + ","new@scanner string []  + ","string_before_Sass Tree CommentNode  new  rindex ","string_before_ node  rindex ","@scanner string []  rindex ","text sub gsub +  length ","line_before_Sass Tree CommentNode  new  gsub ","line_before_ node  gsub ","@line - _before_comment gsub ","index_before_@line -  + ","Sass Tree CommentNode  new _start - "," node _start - ","@scanner pos -  - "]}," Sass SCSS Parser whitespace":{"type":"method","name":"whitespace","children":[],"call":[" ss "," tok "]}," Sass SCSS Parser ss_comments":{"type":"method","name":"ss_comments","children":[],"call":[" process_comment "," tok "," pro tok ess_ tok omment "]}," Sass SCSS Parser ss":{"type":"method","name":"ss","children":[],"call":[" tok "]}," Sass SCSS Parser s":{"type":"method","name":"s","children":[],"call":[" process_comment "," tok "," pro tok ess_ tok omment "]}," Sass SCSS Parser stylesheet":{"type":"method","name":"stylesheet","children":[],"call":[" s "," block_contents "," node ","Sass Tree RootNode  new ","@scanner string "," source_position ","  node  "]}," Sass SCSS Parser init_scanner!":{"type":"method","name":"init_scanner!","children":[],"call":["StringScanner  new ","@template gsub ","@template is_a? ","Sass Util MultibyteStringScanner  new ","@template tr "]}," Sass SCSS Parser parse_interp_ident":{"type":"method","name":"parse_interp_ident","children":[],"call":[" interp_ident "," init_scanner! "]}," Sass SCSS Parser parse":{"type":"method","name":"parse","children":[],"call":[" expected ","@scanner eos? "," stylesheet "," init_scanner! "]}," Sass SCSS Parser initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass SCSS CssParser nested_properties!":{"type":"method","name":"nested_properties!","children":[],"call":[" expected "]}," Sass SCSS CssParser block_child":{"type":"method","name":"block_child","children":[],"call":[" declaration_or_ruleset "," directive "," ruleset "," declaration "," keyframes_ruleset "]}," Sass SCSS CssParser use_css_import?":{"type":"method","name":"use_css_import?","children":[],"call":[]}," Sass SCSS CssParser interp_ident":{"type":"method","name":"interp_ident","children":[],"call":[" tok "]}," Sass SCSS CssParser interp_string":{"type":"method","name":"interp_string","children":[],"call":[" tok "]}," Sass SCSS CssParser interpolation":{"type":"method","name":"interpolation","children":[],"call":[]}," Sass SCSS CssParser parent_selector":{"type":"method","name":"parent_selector","children":[],"call":[]}," Sass SCSS CssParser parse_selector_string":{"type":"method","name":"parse_selector_string","children":[],"call":[" selector "," str "," init_scanner! "]}," Sass Script parse":{"type":"method","name":"parse","children":[],"call":[]}," Sass Script Variable _perform":{"type":"method","name":"_perform","children":[],"call":["val original= ","val dup ","val is_a? "," raise ","SyntaxError  new "," name ","environment var ","val dup  original= ","environment var  original= ","val dup  dup ","environment var  dup ","val dup  is_a? ","environment var  is_a? "]}," Sass Script Variable children":{"type":"method","name":"children","children":[],"call":[]}," Sass Script Variable inspect":{"type":"method","name":"inspect","children":[],"call":[" dasherize "," name "," name == "]}," Sass Script Variable initialize":{"type":"method","name":"initialize","children":[],"call":["name gsub "]}," Script UnaryOperation _perform":{"type":"method","name":"_perform","children":[],"call":[" raise ","Sass SyntaxError  new ","e name to_s == ","operator to_s ","e name to_s ","e name ","literal send ","@operand perform ","@operand perform  send "]}," Script UnaryOperation children":{"type":"method","name":"children","children":[],"call":[]}," Script UnaryOperation to_sass":{"type":"method","name":"to_sass","children":[],"call":["op + + ","op + ","op =~ ","Lexer OPERATORS_REVERSE  [] ","@operand to_sass ","(send\n  (lvar :operand) :=~\n  (const\n    (const\n      (const\n        (const nil :Sass) :SCSS) :RX) :IDENT)) == ","operand =~ ","@operator == ","@operand is_a? ","Lexer OPERATORS_REVERSE  []  + + ","Lexer OPERATORS_REVERSE  []  + ","Lexer OPERATORS_REVERSE  []  =~ ","@Lexer OPERATORS_REVERSE  [] erand to_sass ","@@operand to_sass  to_sass ","(send\n  (lvar :Lexer OPERATORS_REVERSE  [] erand) :=~\n  (const\n    (const\n      (const\n        (const nil :Sass) :SCSS) :RX) :IDENT)) == ","(send\n  (lvar :@operand to_sass ) :=~\n  (const\n    (const\n      (const\n        (const nil :Sass) :SCSS) :RX) :IDENT)) == ","Lexer OPERATORS_REVERSE  [] erand =~ ","@operand to_sass  =~ ","@Lexer OPERATORS_REVERSE  [] erator == ","@Lexer OPERATORS_REVERSE  [] erand is_a? ","@@operand to_sass  is_a? "]}," Script UnaryOperation inspect":{"type":"method","name":"inspect","children":[],"call":["@operand inspect ","@operator inspect "]}," Script UnaryOperation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script StringInterpolation parse_str":{"type":"method","name":"parse_str","children":[],"call":[]}," Script StringInterpolation _perform":{"type":"method","name":"_perform","children":[],"call":[" opts ","Sass Script String  new ","before type ","res << ","@after perform value ","@after perform ","mid to_s ","mid value ","mid is_a? ","@mid perform ","before value ","@before perform ","@before perform  type ","@mid perform  to_s ","@mid perform  value ","@mid perform  is_a? ","@@mid perform  perform ","@before perform  value ","@@before perform  perform "]}," Script StringInterpolation children":{"type":"method","name":"children","children":[],"call":["(ivar :@before) compact "]}," Script StringInterpolation to_sass":{"type":"method","name":"to_sass","children":[],"call":["res << ","res << << << ","res << << ","@mid to_sass ","after_str gsub! ","before_str gsub! ","before_quote_char != ","before_str empty? ! ","before_str empty? ","before_quote_char ! ","after_str empty? ! ","after_str empty? ","after_quote_char ! "," parse_str ","@after to_sass ","@before to_sass "]}," Script StringInterpolation inspect":{"type":"method","name":"inspect","children":[],"call":["@after inspect ","@mid inspect ","@before inspect "]}," Script StringInterpolation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script String to_sass":{"type":"method","name":"to_sass","children":[],"call":[" to_s ","Sass Script String  new to_sass ","Sass Script String  new "," value ","Sass SCSS RX  escape_ident include? ","Sass SCSS RX  escape_ident "," value !~ "," context == "," context "," type == "," type "]}," Script String to_s":{"type":"method","name":"to_s","children":[],"call":[" value gsub "," value "," value include? ","opts [] == ","opts [] ","@value tr ","@type == "," value size == "," value size "," context == "," context "," type == "," type ","@value empty? ","@context == ","@value gsub "]}," Script String plus":{"type":"method","name":"plus","children":[],"call":["Sass Script String  new "," type "," value + "," value ","other to_s ","other value ","other is_a? "]}," Script String initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Script Parser node":{"type":"method","name":"node","children":[],"call":["node line= ","@lexer line ","node filename= ","@options [] ","node source_range= ","source_range start_pos line ","source_range start_pos "," range ","source_range_or_start_pos is_a? ","start_pos line ","node css_variable_warning= ","node  range = "," range  start_pos line "," range  start_pos "," range _or_start_pos is_a? "]}," Sass Script Parser assert_done":{"type":"method","name":"assert_done","children":[],"call":["@lexer expected! ","EXPR_NAMES  [] ","@lexer done? ","@lexer unpeek! "]}," Sass Script Parser try_tok":{"type":"method","name":"try_tok","children":[],"call":["@lexer next ","names include? ","peeked type ","@lexer peek ","name == "," peek_tok ","@lexer peek  type "]}," Sass Script Parser assert_tok":{"type":"method","name":"assert_tok","children":[],"call":["@lexer expected! ","(send\n  (lvar :names) :map) join ","Lexer TOKEN_NAMES  [] ","names map "," try_tok ","name to_s ","@lexer expec try_tok ed! ","  try_tok ry_ try_tok ok ","name  try_tok o_s "]}," Sass Script Parser assert_expr":{"type":"method","name":"assert_expr","children":[],"call":["@lexer expected! ","EXPR_NAMES  [] "," send ","@l send x send r  send xp send ct send d! "," s send nd "]}," Sass Script Parser literal":{"type":"method","name":"literal","children":[],"call":["t value "," try_tok "," literal_node ","t source_range "," try_toks "," try_tok  value "," try_toks  value ","  try_tok ry_ try_tok ok ","  try_toks ry_ try_toks ok "," li try_tok eral_node "," li try_toks eral_node "," try_tok  source_range "," try_toks  source_range ","  try_tok ry_ try_tok oks ","  try_toks ry_ try_toks oks "]}," Sass Script Parser number":{"type":"method","name":"number","children":[],"call":["num original= ","num to_s ","tok value "," literal "," try_tok "," literal_node ","tok source_range start_pos ","tok source_range "," selector ","num options= ","tok value  original= ","tok value  to_s "," try_tok  value "," try_ try_tok  "," try_tok  source_range start_pos "," try_tok  source_range ","tok value  options= "]}," Sass Script Parser string":{"type":"method","name":"string","children":[],"call":["interp line= ","StringInterpolation  new ","first value "," assert_expr "," parse_interpolated ","@lexer line "," try_tok "," number "," node ","first source_range start_pos ","first source_range ","Tree StringInterpolation  new "," literal_node ","interp source_range= "," range "," source_position "," assert_tok "," without_css_variable_warning "," without_stop_at ","first value type ","contents << "," assert_tok value value "," assert_tok value ","first value value ","StringInterpolation  new  line= ","interp @lexer line = "," try_tok  value "," parse_StringInterpolation  new olated ","@lexer @lexer line  "," try_tok  source_range start_pos ","first source_range  source_position  "," try_tok  source_range ","StringInterpolation  new  source_range= "," try_tok  value type "," try_tok  value value "]}," Sass Script Parser variable":{"type":"method","name":"variable","children":[],"call":[" node ","Variable  new ","c value "," string "," try_tok ","Tree Variable  new "," source_position ","@css_variable_warning warn! "," try_tok  value "," sour try_tok e_position ","@ try_tok ss_variable_warning warn! "]}," Sass Script Parser paren":{"type":"method","name":"paren","children":[],"call":[" node ","List  new "," assert_tok "," expr ","@lexer line "," variable "," try_tok "," assert_expr ","Sass Script Tree ListLiteral  new "," source_position "," map ","e force_division! ","@css_variable_warning warn! "," without_stop_at "," nod expr  "," nod assert_expr  "," nod map  ","List  n expr w ","List  n assert_expr w ","List  n map w "," ass expr rt_tok "," ass assert_expr rt_tok "," ass map rt_tok ","  expr xpr ","  assert_expr xpr ","  map xpr ","@l expr x expr r lin expr  ","@l assert_expr x assert_expr r lin assert_expr  ","@l map x map r lin map  ","@lexer @lexer line  "," variabl expr  "," variabl assert_expr  "," variabl map  "," ass expr rt_ expr xpr "," ass assert_expr rt_ assert_expr xpr "," ass map rt_ map xpr ","Sass Script Tr expr  expr  ListLit expr ral  n expr w ","Sass Script Tr assert_expr  assert_expr  ListLit assert_expr ral  n assert_expr w ","Sass Script Tr map  map  ListLit map ral  n map w "," sourc expr _position "," sourc assert_expr _position "," sourc map _position "," expr  forc expr _division! "," assert_expr  forc assert_expr _division! "," map  forc map _division! ","@css_variabl expr _warning warn! ","@css_variabl assert_expr _warning warn! ","@css_variabl map _warning warn! "]}," Sass Script Parser special_fun":{"type":"method","name":"special_fun","children":[],"call":["Script Interpolation  new "," node ","Script String  new ","Sass Util  enum_slice inject ","Sass Util  enum_slice ","tok value [] ","tok value ","tok value first "," paren "," try_tok ","Script Tree Interpolation  new "," literal_node ","i source_range end_pos ","i source_range ","Script Value String  new ","end_pos after ","start_pos after "," source_position ","first source_range start_pos ","first source_range ","Tree Interpolation  new "," assert_expr "," parse_interpolated ","first value "," assert_tok ","wa ! ","wb ! "," without_css_variable_warning "," square_list "," without_stop_at ","Tree StringInterpolation  new ","contents << "," assert_tok value value "," assert_tok value ","first value value "," try_tok  value [] "," try_tok  value ","tok value  node  ","tok value  literal_node  ","tok value  try_tok  "," try_tok  value first "," try_ try_tok  ","i source_range end_pos after  ","i source_range i source_range end_pos  ","end_pos after  after ","i source_range end_pos  after "," source_position  after "," node  source_range start_pos "," literal_node  source_range start_pos "," try_tok  source_range start_pos ","first source_range  source_position  "," node  source_range "," literal_node  source_range "," try_tok  source_range "," node  value "," literal_node  value "," assert_ try_tok  "," assert_ try_tok  value value "," assert_ try_tok  value "," node  value value "," literal_node  value value "," try_tok  value value "]}," Sass Script Parser raw":{"type":"method","name":"raw","children":[],"call":[" node ","Script String  new ","tok value "," special_fun "," try_tok "," literal_node ","tok source_range ","Script Value String  new "," source_position "," try_tok  value "," try_ try_tok  "," try_tok  source_range "]}," Sass Script Parser keyword_arglist":{"type":"method","name":"keyword_arglist","children":[],"call":["(pair\n  (lvar :name)\n  (lvar :value)) merge "," assert_expr "," try_tok "," interpolation ","var [] "," return_tok! ","(pair\n  (lvar :name)\n  (lvar : interpolation )) merge ","(pair\n  (lvar :var [] )\n  (lvar :value)) merge ","(pair\n  (l try_tok  :name)\n  (l try_tok  :value)) merge "," try_tok  [] "]}," Sass Script Parser arglist":{"type":"method","name":"arglist","children":[],"call":["keywords merge "," raise ","SyntaxError  new ","name to_sass ","other_keywords [] ","name underscored_name "," assert_expr "," try_tok ","EXPR_NAMES  [] "," assert_tok ","@lexer expected! ","name is_a? ","@lexer peek type == ","@lexer peek type ","@lexer peek "," send "," interpolation ","other_args empty? ! ","other_args empty? ","args << ","keywords empty? ! ","keywords empty? ","keywords []= ","keywords [] "," loop ","name name ","Sass Util NormalizedMap  new "," without_stop_at ","k send ywords m send rg send  ","k interpolation ywords m interpolation rg interpolation  ","k assert_expr ywords m assert_expr rg assert_expr  ","Sass Util NormalizedMap  new  merge "," rais send  "," rais interpolation  "," rais assert_expr  ","SyntaxError  n send w ","SyntaxError  n interpolation w ","SyntaxError  n assert_expr w ","nam send  to_sass ","nam interpolation  to_sass ","nam assert_expr  to_sass ","oth send r_k send ywords [] ","oth interpolation r_k interpolation ywords [] ","oth assert_expr r_k assert_expr ywords [] ","other_Sass Util NormalizedMap  new  [] ","nam send  und send rscor send d_nam send  ","nam interpolation  und interpolation rscor interpolation d_nam interpolation  ","nam assert_expr  und assert_expr rscor assert_expr d_nam assert_expr  "," ass send rt_ send xpr "," ass interpolation rt_ interpolation xpr "," ass assert_expr rt_ assert_expr xpr "," ass send rt_tok "," ass interpolation rt_tok "," ass assert_expr rt_tok ","@l send x send r  send xp send ct send d! ","@l interpolation x interpolation r  interpolation xp interpolation ct interpolation d! ","@l assert_expr x assert_expr r  assert_expr xp assert_expr ct assert_expr d! ","nam send  is_a? ","nam interpolation  is_a? ","nam assert_expr  is_a? ","@l send x send r p send  send k typ send  == ","@l interpolation x interpolation r p interpolation  interpolation k typ interpolation  == ","@l assert_expr x assert_expr r p assert_expr  assert_expr k typ assert_expr  == ","@l send x send r p send  send k typ send  ","@l interpolation x interpolation r p interpolation  interpolation k typ interpolation  ","@l assert_expr x assert_expr r p assert_expr  assert_expr k typ assert_expr  ","@l send x send r p send  send k ","@l interpolation x interpolation r p interpolation  interpolation k ","@l assert_expr x assert_expr r p assert_expr  assert_expr k "," s send nd "," s interpolation nd "," s assert_expr nd "," int send rpolation "," int interpolation rpolation "," int assert_expr rpolation ","oth send r_args  send mpty? ! ","oth interpolation r_args  interpolation mpty? ! ","oth assert_expr r_args  assert_expr mpty? ! ","oth send r_args  send mpty? ","oth interpolation r_args  interpolation mpty? ","oth assert_expr r_args  assert_expr mpty? ","k send ywords  send mpty? ! ","k interpolation ywords  interpolation mpty? ! ","k assert_expr ywords  assert_expr mpty? ! ","Sass Util NormalizedMap  new  empty? ! ","k send ywords  send mpty? ","k interpolation ywords  interpolation mpty? ","k assert_expr ywords  assert_expr mpty? ","Sass Util NormalizedMap  new  empty? ","k send ywords []= ","k interpolation ywords []= ","k assert_expr ywords []= ","Sass Util NormalizedMap  new  []= ","k send ywords [] ","k interpolation ywords [] ","k assert_expr ywords [] ","Sass Util NormalizedMap  new  [] ","nam send  nam send  ","nam interpolation  nam interpolation  ","nam assert_expr  nam assert_expr  ","Sass Util Normaliz send dMap  n send w ","Sass Util Normaliz interpolation dMap  n interpolation w ","Sass Util Normaliz assert_expr dMap  n assert_expr w "]}," Sass Script Parser mixin_arglist":{"type":"method","name":"mixin_arglist","children":[],"call":[" arglist "]}," Sass Script Parser fn_arglist":{"type":"method","name":"fn_arglist","children":[],"call":[" arglist "," assert_expr "," try_tok "," equals "," ass equals rt_ equals xpr ","  equals quals "]}," Sass Script Parser defn_arglist!":{"type":"method","name":"defn_arglist!","children":[],"call":[" assert_tok "," try_tok ","res << "," raise ","SyntaxError  new ","var inspect "," assert_expr ","Script Variable  new ","c value ","@lexer offset + ","@lexer offset ","@lexer line "," loop ","Script  equals_warning ","@options [] ","val to_sass ","val options= ","val context= ","tok type == ","tok type "," node ","c source_range ","Script Tree Variable  new ","var source_range= "," range ","c offset "," peek_tok "," without_stop_at "," assert_ try_tok  "," try_ try_tok  ","Script Variable  new  inspect "," node  inspect ","var inspe assert_tok t ","S assert_tok ript Variable  new ","c  assert_expr ue "," assert_tok  value ","@lexer @lexer offset +  + ","@lexer @lexer offset  + ","@lexer @lexer offset +  ","@lexer @lexer offset  ","@lexer @lexer line  ","S assert_tok ript  equals_warning "," assert_expr  to_sass "," assert_expr  options= "," assert_expr  context= ","val  assert_tok ontext= "," try_tok  type == "," try_tok  type "," assert_tok  sour assert_tok e_range ","S assert_tok ript Tree Variable  new ","Script Variable  new  source_range= "," node  source_range= ","var sour assert_tok e_range= "," assert_tok  offset ","c @lexer offset +  ","c @lexer offset  "," peek_ try_tok  "]}," Sass Script Parser funcall":{"type":"method","name":"funcall","children":[],"call":[" node ","Script Funcall  new ","tok value "," assert_tok "," fn_arglist "," raw "," try_tok "," source_position ","tok source_range start_pos ","tok source_range ","Script Tree Funcall  new "," token_start_position "," try_tok  value "," assert_ try_tok  "," try_ try_tok  "," try_tok  source_range start_pos "," try_tok  source_range ","  try_tok en_start_position "]}," Sass Script Parser ident":{"type":"method","name":"ident","children":[],"call":[" node ","Script String  new ","name value ","Color  new ","Color HTML4_COLORS  [] ","name value downcase ","@lexer next ","@stop_at include? ","@lexer peek value ","@lexer peek "," funcall ","@lexer peek type == ","@lexer peek type ","Color COLOR_NAMES  [] ","Script Null  new ","name value == ","Script Bool  new "," literal_node ","name source_range ","Sass Script Value String  new ","Sass Script Value Null  new ","Sass Script Value Bool  new ","Sass Script Value Color  new ","Sass Script Value Color COLOR_NAMES  [] "," source_position "," token_start_position ","Script Value String  new "," css_min_max ","first source_range ","first value ","first value == ","first value downcase ","first source_range start_pos ","Sass Script Tree StringInterpolation  new ","contents first is_a? ","contents first ","contents length > ","contents length "," assert_tok ","contents << "," assert_expr "," try_tok ","@lexer next value ","tok type == ","tok type ","@lexer whitespace_before? ","first type == ","first type ","@lexer next  value ","@lexer next  value downcase ","@lexer next  value == ","@lexer next  source_range "," @lexer peek en_start_position ","@lexer peek  source_range ","@lexer peek  value ","@lexer peek  value == ","@lexer peek  value downcase ","@lexer peek  source_range start_pos ","contents @lexer peek  is_a? ","contents @lexer peek  "," assert_@lexer peek  "," try_@lexer peek  ","@lexer peek  type == ","@lexer peek  type "]}," Sass Script Parser space":{"type":"method","name":"space","children":[],"call":[" node ","List  new ","arr first ","arr size == ","arr size ","arr << "," or_expr ","@lexer line ","Sass Script Tree ListLiteral  new "," source_position "," nod or_expr  ","List  n or_expr w ","arr siz or_expr  == ","arr siz or_expr  "," or_ or_expr xpr ","@l or_expr x or_expr r lin or_expr  ","@lexer @lexer line  ","Sass Script Tr or_expr  or_expr  ListLit or_expr ral  n or_expr w "," sourc or_expr _position "]}," Sass Script Parser interpolation":{"type":"method","name":"interpolation","children":[],"call":["e line= ","Script Interpolation  new "," space ","@lexer whitespace? "," parse_interpolated ","@lexer line "," try_tok "," concat "," node ","(or\n  (lvar :e)\n  (lvar :mid)) source_range start_pos ","(or\n  (lvar :e)\n  (lvar :mid)) source_range ","Script Tree Interpolation  new "," assert_tok "," assert_expr ","(or\n  (lvar :e)\n  (lvar :interp)) source_range start_pos ","(or\n  (lvar :e)\n  (lvar :interp)) source_range "," is_unsafe_before? ","wb ! ","char_after =~ ","wa ! ","after_deprecation == ","before_deprecation == ","after deprecation ","after is_a? ","e deprecation ","e is_a? ","@lexer char ","interp pos - ","interp pos "," without_css_variable_warning "," send "," without_stop_at ","Script Interpolation  new  linScript Interpolation  new = "," node  lin node = ","e @lexer line = ","Script IntScript Interpolation  new rpolation  nScript Interpolation  new w ","Script Int node rpolation  n node w "," spacScript Interpolation  new  "," spac node  ","@lScript Interpolation  new xScript Interpolation  new r whitScript Interpolation  new spacScript Interpolation  new ? ","@l node x node r whit node spac node ? "," parsScript Interpolation  new _intScript Interpolation  new rpolatScript Interpolation  new d "," pars node _int node rpolat node d "," parse_ try_tok olated ","@lScript Interpolation  new xScript Interpolation  new r linScript Interpolation  new  ","@l node x node r lin node  ","@lexer @lexer line  "," nodScript Interpolation  new  "," nod node  ","(or\n  (lvar :Script Interpolation  new )\n  (lvar :mid)) sourcScript Interpolation  new _rangScript Interpolation  new  start_pos ","(or\n  (lvar : node )\n  (lvar :mid)) sourc node _rang node  start_pos ","(or\n  (lvar :e)\n  (lvar : parse_interpolated )) source_range start_pos ","(or\n  (lvar :e)\n  (lvar : assert_expr )) source_range start_pos ","(or\n  (lvar :Script Interpolation  new )\n  (lvar :mid)) sourcScript Interpolation  new _rangScript Interpolation  new  ","(or\n  (lvar : node )\n  (lvar :mid)) sourc node _rang node  ","(or\n  (lvar :e)\n  (lvar : parse_interpolated )) source_range ","(or\n  (lvar :e)\n  (lvar : assert_expr )) source_range ","Script TrScript Interpolation  new Script Interpolation  new  IntScript Interpolation  new rpolation  nScript Interpolation  new w ","Script Tr node  node  Int node rpolation  n node w "," assScript Interpolation  new rt_tok "," ass node rt_tok "," assScript Interpolation  new rt_Script Interpolation  new xpr "," ass node rt_ node xpr ","(or\n  (lvar :Script Interpolation  new )\n  (lvar :intScript Interpolation  new rp)) sourcScript Interpolation  new _rangScript Interpolation  new  start_pos ","(or\n  (lvar : node )\n  (lvar :int node rp)) sourc node _rang node  start_pos ","(or\n  (lvar :e)\n  (lvar : try_tok )) source_range start_pos ","(or\n  (lvar :Script Interpolation  new )\n  (lvar :intScript Interpolation  new rp)) sourcScript Interpolation  new _rangScript Interpolation  new  ","(or\n  (lvar : node )\n  (lvar :int node rp)) sourc node _rang node  ","(or\n  (lvar :e)\n  (lvar : try_tok )) source_range "," is_unsafScript Interpolation  new _bScript Interpolation  new forScript Interpolation  new ? "," is_unsaf node _b node for node ? ","@lexer whitespace?  ! ","char_aftScript Interpolation  new r =~ ","char_aft node r =~ ","char_ space  =~ ","char_ send  =~ ","@lexer char  =~ ","aftScript Interpolation  new r_dScript Interpolation  new prScript Interpolation  new cation == ","aft node r_d node pr node cation == ","after deprecation  == "," space _deprecation == "," send _deprecation == ","bScript Interpolation  new forScript Interpolation  new _dScript Interpolation  new prScript Interpolation  new cation == ","b node for node _d node pr node cation == ","e deprecation  == ","aftScript Interpolation  new r dScript Interpolation  new prScript Interpolation  new cation ","aft node r d node pr node cation "," space  deprecation "," send  deprecation ","aftScript Interpolation  new r is_a? ","aft node r is_a? "," space  is_a? "," send  is_a? ","Script Interpolation  new  dScript Interpolation  new prScript Interpolation  new cation "," node  d node pr node cation ","Script Interpolation  new  is_a? "," node  is_a? ","@lScript Interpolation  new xScript Interpolation  new r char ","@l node x node r char ","intScript Interpolation  new rp pos - ","int node rp pos - "," try_tok  pos - ","intScript Interpolation  new rp pos ","int node rp pos "," try_tok  pos "," without_css_variablScript Interpolation  new _warning "," without_css_variabl node _warning "," without_css_variable_@lexer whitespace? rning "," sScript Interpolation  new nd "," s node nd "]}," Sass Script Parser try_ops_after_interp":{"type":"method","name":"try_ops_after_interp","children":[],"call":["interp line= ","@lexer line ","Script Interpolation  new ","wb ! "," assert_expr ","str line= ","Script String  new ","Lexer OPERATORS_REVERSE  [] ","op type ","@lexer whitespace? "," try_op_before_interp "," try_tok ","@lexer after_interpolation? "," node ","(or\n  (lvar :prev)\n  (lvar :str)) source_range start_pos ","(or\n  (lvar :prev)\n  (lvar :str)) source_range ","Script Tree Interpolation  new "," literal_node ","op source_range ","Script Value String  new "," try_toks ","interp source_range= "," range "," source_position ","@lexer next ","@stop_at include? "," peek_toks ","Script Interpolation  new  line= "," try_op_before_interp  line= "," node  line= ","Script String  new  line= "," literal_node  line= "," try_tok  type "," try_toks  type "," peek_toks  type "," try_op_before_Script Interpolation  new  "," try_op_before_ try_op_before_interp  "," try_op_before_ node  "," try_ try_tok _before_interp "," try_ try_toks _before_interp "," try_ peek_toks _before_interp ","@lexer after_Script Interpolation  new olation? ","@lexer after_ try_op_before_interp olation? ","@lexer after_ node olation? ","(or\n  (lvar :prev)\n  (lvar :Script String  new )) source_range start_pos ","(or\n  (lvar :prev)\n  (lvar : literal_node )) source_range start_pos ","(or\n  (lvar :prev)\n  (lvar :str)) source_range  source_position  ","(or\n  (lvar :prev)\n  (lvar :Script String  new )) source_range ","(or\n  (lvar :prev)\n  (lvar : literal_node )) source_range "," try_tok  source_range "," try_toks  source_range "," peek_toks  source_range ","Script Interpolation  new  source_range= "," try_op_before_interp  source_range= "," node  source_range= ","@st try_tok _at include? ","@st try_toks _at include? ","@st peek_toks _at include? "]}," Sass Script Parser try_op_before_interp":{"type":"method","name":"try_op_before_interp","children":[],"call":[" interpolation ","interp line= ","@lexer line ","Script Interpolation  new ","wa ! ","str line= ","Script String  new ","Lexer OPERATORS_REVERSE  [] ","op type ","@lexer whitespace? ","@lexer peek type == ","@lexer peek type ","@lexer peek "," node ","(or\n  (lvar :prev)\n  (lvar :str)) source_range start_pos ","(or\n  (lvar :prev)\n  (lvar :str)) source_range ","Script Tree Interpolation  new "," literal_node ","op source_range ","Script Value String  new ","after_interp ! ","prev ! "," Script Interpolation  new olation ","  node olation ","Script Interpolation  new  line= "," node  line= ","Script String  new  line= "," literal_node  line= ","(or\n  (lvar :prev)\n  (lvar :Script String  new )) source_range start_pos ","(or\n  (lvar :prev)\n  (lvar : literal_node )) source_range start_pos ","(or\n  (lvar :prev)\n  (lvar :Script String  new )) source_range ","(or\n  (lvar :prev)\n  (lvar : literal_node )) source_range ","after_Script Interpolation  new  ! ","after_ node  ! "]}," Sass Script Parser expr":{"type":"method","name":"expr","children":[],"call":[" node ","List  new ","arr first ","arr size == ","arr size ","arr << "," assert_expr "," try_op_before_interp "," try_tok "," interpolation ","@lexer line "," try_ops_after_interp ","list value first ","list value ","list value size == ","list value size ","list value << "," list "," source_position ","list elements first ","list elements ","list elements size == ","list elements size ","list elements << ","Sass Script Tree ListLiteral  new "," space "," nod interpolation  "," nod space  ","List  n interpolation w ","List  n space w ","arr siz interpolation  == ","arr siz space  == ","arr siz interpolation  ","arr siz space  "," ass interpolation rt_ interpolation xpr "," ass space rt_ space xpr "," try_op_before_ try_op_before_interp  "," try_op_before_ try_ops_after_interp  "," try_op_b interpolation for interpolation _int interpolation rp "," try_op_b space for space _int space rp "," try_ try_tok  ","  try_op_before_interp olation ","  try_ops_after_interp olation "," int interpolation rpolation "," int space rpolation ","@l interpolation x interpolation r lin interpolation  ","@l space x space r lin space  ","@lexer @lexer line  "," try_ops_after_ try_op_before_interp  "," try_ops_after_ try_ops_after_interp  "," try_ops_aft interpolation r_int interpolation rp "," try_ops_aft space r_int space rp ","list valu interpolation  first ","list valu space  first "," node  value first ","list valu interpolation  ","list valu space  "," node  value ","list valu interpolation  siz interpolation  == ","list valu space  siz space  == "," node  value size == ","list valu interpolation  siz interpolation  ","list valu space  siz space  "," node  value size ","list valu interpolation  << ","list valu space  << "," node  value << ","  node  "," sourc interpolation _position "," sourc space _position ","list  interpolation l interpolation m interpolation nts first ","list  space l space m space nts first "," node  elements first ","list  interpolation l interpolation m interpolation nts ","list  space l space m space nts "," node  elements ","list  interpolation l interpolation m interpolation nts siz interpolation  == ","list  space l space m space nts siz space  == "," node  elements size == ","list  interpolation l interpolation m interpolation nts siz interpolation  ","list  space l space m space nts siz space  "," node  elements size ","list  interpolation l interpolation m interpolation nts << ","list  space l space m space nts << "," node  elements << ","Sass Script Tr interpolation  interpolation  ListLit interpolation ral  n interpolation w ","Sass Script Tr space  space  ListLit space ral  n space w "," spac interpolation  "," spac space  "]}," Sass Script Parser lexer_class":{"type":"method","name":"lexer_class","children":[],"call":[]}," Sass Script Parser unary":{"type":"method","name":"unary","children":[],"call":[" class_eval ","226 + ","238 + ","232 + ","233 + ","244 + ","284 + ","307 + ","289 + ","293 + ","235 + "]}," Sass Script Parser production":{"type":"method","name":"production","children":[],"call":[" class_eval ","sub inspect ","(send\n  (lvar :ops) :map) join ","o inspect ","ops map ","name inspect ","ops inspect ","206 + ","217 + ","213 + ","214 + ","223 + ","263 + ","282 + ","268 + ","222 + "]}," Sass Script Parser associative?":{"type":"method","name":"associative?","children":[],"call":["ASSOCIATIVE  include? "]}," Sass Script Parser precedence_of":{"type":"method","name":"precedence_of","children":[],"call":[" raise "," Array include? "," Array ","PRECEDENCE  each_with_index ","op inspect "]}," Sass Script Parser parse":{"type":"method","name":"parse","children":[],"call":[" raise ","e modify_backtrace ","@options [] ","@lexer line ","expr options= "," assert_done "," assert_expr ","expr source_range= "," range "," source_position "," check_for_interpolation ","@css_variable_warning value= ","CssVariableWarning  new "," assert_expr  options= "," assert_ assert_expr  "," assert_expr  source_range= ","CssVariableWarning  new  value= "]}," Sass Script Parser parse_function_definition_arglist":{"type":"method","name":"parse_function_definition_arglist","children":[],"call":[" raise ","e modify_backtrace ","@options [] ","@lexer line ","v options= ","k options= ","args each "," assert_done "," defn_arglist! ","splat options= "," check_for_interpolation "," defn_arglist!  each "]}," Sass Script Parser parse_mixin_definition_arglist":{"type":"method","name":"parse_mixin_definition_arglist","children":[],"call":[" raise ","e modify_backtrace ","@options [] ","@lexer line ","v options= ","k options= ","args each "," assert_done "," defn_arglist! ","splat options= "," check_for_interpolation "," defn_arglist!  each "]}," Sass Script Parser parse_mixin_include_arglist":{"type":"method","name":"parse_mixin_include_arglist","children":[],"call":[" raise ","e modify_backtrace ","@options [] ","@lexer line ","v options= ","keywords each ","a options= ","args each "," assert_done "," assert_tok "," mixin_arglist "," try_tok "," arglist ","splat options= ","kwarg_splat options= "," check_for_interpolation "]}," Sass Script Parser parse_until":{"type":"method","name":"parse_until","children":[],"call":[" raise ","e modify_backtrace ","@options [] ","@lexer line ","expr options= "," assert_done "," assert_expr "," check_for_interpolation "," assert_expr  options= "," assert_ assert_expr  "]}," Sass Script Parser parse_interpolated":{"type":"method","name":"parse_interpolated","children":[],"call":[" raise ","e modify_backtrace ","@options [] ","@lexer line ","expr options= "," assert_tok "," assert_expr ","expr source_range= "," range "," source_position "," node ","Sass Script Tree Interpolation  new ","originally_text ! ","wa ! ","wb ! ","Sass Source Position  new "," offset - "," offset "," line "," check_for_interpolation "," assert_expr  options= ","Sass Script Tree Interpolation  new  options= "," assert_ assert_expr  "," assert_Sass Script Tree Interpolation  new  "," assert_expr  source_range= ","Sass Script Tree Interpolation  new  source_range= "]}," Sass Script Parser initialize":{"type":"method","name":"initialize","children":[],"call":[" lexer_class new "," lexer_class ","options delete "]}," Sass Script Parser line":{"type":"method","name":"line","children":[],"call":["@lexer line "]}," Script Operation operand_to_sass":{"type":"method","name":"operand_to_sass","children":[],"call":["op to_sass ","assoc ! ","sub_pred == ","side == ","sub_pred < ","Sass Script Parser  associative? ","Sass Script Parser  precedence_of ","op operator ","op is_a? ","Sass Script Parser  precedence_of < ","Sass Script Parser  associative?  ! ","Sass Script Parser  precedence_of  == ","sub_Sass Script Parser  precedence_of  == ","Sass Script Parser  precedence_of  < ","sub_Sass Script Parser  precedence_of  < ","Sass Script Parser  Sass Script Parser  associative? iative? "]}," Script Operation _perform":{"type":"method","name":"_perform","children":[],"call":[" raise ","Sass SyntaxError  new ","e name to_s == ","@operator to_s ","e name to_s ","e name "," opts ","literal1 send ","@operand2 perform ","@operand1 perform ","Sass Script String  new ","literal2 value ","literal2 is_a? ","literal1 value ","literal1 is_a? "," context == "," context ","@operator == ","res options= ","environment options ","literal1 to_bool ","literal2 inspect ","literal1 inspect ","@operator != ","@operand1 perform  send ","Sass Script String  new  send ","@operand2 perform  value ","Sass Script String  new  value ","@operand2 perform  is_a? ","Sass Script String  new  is_a? ","@operand1 perform  value ","@operand1 perform  is_a? ","literal1 send  options= ","@operand1 perform  to_bool ","Sass Script String  new  to_bool ","@operand2 perform  inspect ","Sass Script String  new  inspect ","@operand1 perform  inspect "]}," Script Operation children":{"type":"method","name":"children","children":[],"call":[]}," Script Operation to_sass":{"type":"method","name":"to_sass","children":[],"call":["Lexer OPERATORS_REVERSE  [] "," operand_to_sass ","Sass Script Parser  precedence_of "]}," Script Operation inspect":{"type":"method","name":"inspect","children":[],"call":["@operand2 inspect ","@operand1 inspect ","@operator inspect "]}," Script Operation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script Number sans_common_units":{"type":"method","name":"sans_common_units","children":[],"call":["(send\n  (lvar :units1) :map) compact ","units2 delete_at ","units2 index ","units1 map ","units2 dup ","units2 dup  delete_at ","units2 dup  index ","units2 dup  dup "]}," Script Number convertable?":{"type":"method","name":"convertable?","children":[],"call":["CONVERTABLE_UNITS  include? "," Array all? "," Array ","CONVERTABLE_UNITS  method "]}," Script Number conversion_factor":{"type":"method","name":"conversion_factor","children":[],"call":["1.0 / "," conversion_factor ","res nil? ","CONVERSION_TABLE  [] [] ","CONVERTABLE_UNITS  [] ","CONVERSION_TABLE  [] ","CONVERSION_TABLE  [] []  nil? "]}," Script Number normalize!":{"type":"method","name":"normalize!","children":[],"call":["@numerator_units delete_at ","@numerator_units index ","@denominator_units delete_at "," conversion_factor ","@numerator_units detect "," method "," convertable? ","@denominator_units each_with_index "," sans_common_units "," unitless? "," denominator_units "," numerator_units ","@n@numerator_units detect merator_@numerator_units detect nits delete_at ","@n@numerator_units detect merator_@numerator_units detect nits index ","@denominator_@numerator_units detect nits delete_at ","@n@numerator_units detect merator_@numerator_units detect nits detect ","@denominator_@numerator_units detect nits each_with_index "," sans_common_@numerator_units detect nits "," @numerator_units detect nitless? "," denominator_@numerator_units detect nits "," n@numerator_units detect merator_@numerator_units detect nits "]}," Script Number compute_units":{"type":"method","name":"compute_units","children":[],"call":["this denominator_units ","this numerator_units ","this denominator_units + ","other numerator_units ","this numerator_units + ","other denominator_units "]}," Script Number coercion_factor":{"type":"method","name":"coercion_factor","children":[],"call":["m * "," conversion_factor ","p [] ","from_units zip inject ","from_units zip "," raise ","Sass UnitConversionError  new ","to_units join ","from_units join "," convertable? ! "," convertable? ","from_units | ","from_units size != ","to_units size ","from_units size "," sans_common_units "]}," Script Number operate":{"type":"method","name":"operate","children":[],"call":["Bool  new ","Number  new "," compute_units ","result is_a? ","value send ","other value ","this value ","this value to_f ","/ == ","other coerce ","this coerce ","other denominator_units ","other numerator_units "," unitless? ","OPERATIONS  include? "," denominator_units "," numerator_units ","(sym :+) include? ","value send  is_a? ","this value  send ","this value to_f  send ","other this value  ","other this value to_f  ","other coerce  value ","this this value  ","this this value to_f  ","this coerce  value ","this this value  to_f ","this this value to_f  to_f ","this coerce  value to_f ","other coerce  coerce ","this coerce  coerce ","other coerce  denominator_units ","other coerce  numerator_units "]}," Script Number round":{"type":"method","name":"round","children":[],"call":[]}," Script Number unit_str":{"type":"method","name":"unit_str","children":[],"call":["rv << ","@denominator_units sort join ","@denominator_units sort ","@denominator_units any? ","@numerator_units sort join ","@numerator_units sort "," denominator_units sort join "," denominator_units sort "," denominator_units "," denominator_units any? "," numerator_units sort join "," numerator_units sort "," numerator_units ","@numerator_units sort join  << "," numerator_units sort join  << "]}," Script Number comparable_to?":{"type":"method","name":"comparable_to?","children":[],"call":[" operate "]}," Script Number coerce":{"type":"method","name":"coerce","children":[],"call":["Number  new "," value * / "," coercion_factor "," value * "," value "," unitless? "," denominator_units "," numerator_units "]}," Script Number legal_units?":{"type":"method","name":"legal_units?","children":[],"call":["@denominator_units empty? ","@numerator_units size == ","@numerator_units size ","@numerator_units empty? "," denominator_units empty? "," denominator_units "," numerator_units size == "," numerator_units size "," numerator_units "," numerator_units empty? "]}," Script Number unitless?":{"type":"method","name":"unitless?","children":[],"call":["@denominator_units empty? ","@numerator_units empty? "," denominator_units empty? "," denominator_units "," numerator_units empty? "," numerator_units "]}," Script Number int?":{"type":"method","name":"int?","children":[],"call":[" value % == "," value % "," value "]}," Script Number to_i":{"type":"method","name":"to_i","children":[],"call":[" value "," int? "]}," Script Number inspect":{"type":"method","name":"inspect","children":[],"call":[" unit_str ","value to_s "," unitless? "," class round "," value "," class ","(send\n  (send\n    (self) :value) :*\n  (const nil :PRECISION)) round / ","(send\n  (send\n    (self) :value) :*\n  (const nil :PRECISION)) round "," value * "," value to_i "," int? "," value nan? "," value infinite? "," value is_a? "," class round  to_s "," value  to_s ","  class round  ","  value  ","(send\n  (send\n    (self) : class round ) :*\n  (const nil :PRECISION)) round / ","(send\n  (send\n    (self) : value ) :*\n  (const nil :PRECISION)) round / ","(send\n  (send\n    (self) : class round ) :*\n  (const nil :PRECISION)) round ","(send\n  (send\n    (self) : value ) :*\n  (const nil :PRECISION)) round ","  class round  * ","  value  * ","  class round  to_i ","  value  to_i ","  class round  nan? ","  value  nan? ","  class round  infinite? ","  value  infinite? ","  class round  is_a? ","  value  is_a? "]}," Script Number to_s":{"type":"method","name":"to_s","children":[],"call":[" inspect "," raise ","Sass SyntaxError  new "," legal_units? "," original "]}," Script Number lte":{"type":"method","name":"lte","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Script Number lt":{"type":"method","name":"lt","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Script Number gte":{"type":"method","name":"gte","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Script Number gt":{"type":"method","name":"gt","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Script Number eq":{"type":"method","name":"eq","children":[],"call":["Sass Script Bool  new ","this value == ","other value ","this value ","other coerce ","this coerce ","other denominator_units ","other numerator_units "," unitless? ","other is_a? "," denominator_units "," numerator_units ","this coerce  value == ","other coerce  value ","this coerce  value ","other coerce  coerce ","this coerce  coerce ","other coerce  denominator_units ","other coerce  numerator_units ","other coerce  is_a? "]}," Script Number mod":{"type":"method","name":"mod","children":[],"call":[" raise ","NoMethodError  new "," operate ","Sass UnitConversionError  new ","other inspect ","other unitless? ","other is_a? "]}," Script Number div":{"type":"method","name":"div","children":[],"call":["res original= ","other original "," original "," operate ","other is_a? "," context != "," context "," operate  original= "]}," Script Number times":{"type":"method","name":"times","children":[],"call":[" raise ","NoMethodError  new ","other times ","other is_a? "," operate "]}," Script Number unary_minus":{"type":"method","name":"unary_minus","children":[],"call":["Number  new "," value -@ "," value "," denominator_units "," numerator_units "]}," Script Number unary_plus":{"type":"method","name":"unary_plus","children":[],"call":[]}," Script Number minus":{"type":"method","name":"minus","children":[],"call":[" operate ","other is_a? "]}," Script Number plus":{"type":"method","name":"plus","children":[],"call":["other plus ","other is_a? "," operate "]}," Script Number initialize":{"type":"method","name":"initialize","children":[],"call":[" normalize! ","denominator_units is_a? ","numerator_units is_a? "]}," Script Node opts":{"type":"method","name":"opts","children":[],"call":["literal options= "," options "]}," Script Node _perform":{"type":"method","name":"_perform","children":[],"call":["Sass Util  abstract "]}," Script Node dasherize":{"type":"method","name":"dasherize","children":[],"call":["s gsub ","opts [] "]}," Script Node to_sass":{"type":"method","name":"to_sass","children":[],"call":["Sass Util  abstract "]}," Script Node children":{"type":"method","name":"children","children":[],"call":["Sass Util  abstract "]}," Script Node perform":{"type":"method","name":"perform","children":[],"call":[" raise ","e modify_backtrace "," line "," _perform "]}," Script Node options=":{"type":"method","name":"options=","children":[],"call":["c options= ","v options= ","c values each ","c values ","c is_a? "," children each "," children "]}," Script Literal _perform":{"type":"method","name":"_perform","children":[],"call":[]}," Script Literal to_s":{"type":"method","name":"to_s","children":[],"call":[" raise ","Sass SyntaxError  new "]}," Script Literal to_a":{"type":"method","name":"to_a","children":[],"call":[]}," Script Literal assert_int!":{"type":"method","name":"assert_int!","children":[],"call":[" to_i "]}," Script Literal to_i":{"type":"method","name":"to_i","children":[],"call":[" raise ","Sass SyntaxError  new "," inspect "]}," Script Literal ==":{"type":"method","name":"==","children":[],"call":[" eq to_bool "," eq "]}," Script Literal to_bool":{"type":"method","name":"to_bool","children":[],"call":[]}," Script Literal inspect":{"type":"method","name":"inspect","children":[],"call":[" value inspect "," value "]}," Script Literal unary_div":{"type":"method","name":"unary_div","children":[],"call":["Sass Script String  new "," to_s "]}," Script Literal unary_minus":{"type":"method","name":"unary_minus","children":[],"call":["Sass Script String  new "," to_s "]}," Script Literal unary_plus":{"type":"method","name":"unary_plus","children":[],"call":["Sass Script String  new "," to_s "]}," Script Literal div":{"type":"method","name":"div","children":[],"call":["Sass Script String  new ","other to_s "," to_s "]}," Script Literal minus":{"type":"method","name":"minus","children":[],"call":["Sass Script String  new ","other to_s "," to_s "]}," Script Literal plus":{"type":"method","name":"plus","children":[],"call":["Sass Script String  new "," to_s + ","other to_s "," to_s ","other type ","other value ","other is_a? "]}," Script Literal single_eq":{"type":"method","name":"single_eq","children":[],"call":["Sass Script String  new ","other to_s "," to_s "]}," Script Literal comma":{"type":"method","name":"comma","children":[],"call":["Sass Script String  new ","other to_s "," options [] == "," options [] "," options "," to_s "]}," Script Literal space":{"type":"method","name":"space","children":[],"call":["Sass Script String  new ","other to_s "," to_s "]}," Script Literal unary_not":{"type":"method","name":"unary_not","children":[],"call":["Sass Script Bool  new "," to_bool ! "," to_bool "]}," Script Literal neq":{"type":"method","name":"neq","children":[],"call":["Sass Script Bool  new "," eq to_bool ! "," eq to_bool "," eq "]}," Script Literal eq":{"type":"method","name":"eq","children":[],"call":["Sass Script Bool  new "," value == ","other value "," value "," class == ","other class "," class "]}," Script Literal or":{"type":"method","name":"or","children":[],"call":[" to_bool "]}," Script Literal and":{"type":"method","name":"and","children":[],"call":[" to_bool "]}," Script Literal options":{"type":"method","name":"options","children":[],"call":[" raise ","Sass SyntaxError  new "," class "]}," Script Literal children":{"type":"method","name":"children","children":[],"call":[]}," Script Literal initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script List sep_str":{"type":"method","name":"sep_str","children":[],"call":["opts [] == ","opts [] "," separator == "," separator "]}," Script List _perform":{"type":"method","name":"_perform","children":[],"call":["list options= "," options ","Sass Script List  new "," separator ","e perform "," value map "," value ","list context= "," context ","Sass Script List  new  options= ","Sass Script List  new  context= "]}," Script List inspect":{"type":"method","name":"inspect","children":[],"call":[" to_sass "]}," Script List to_sass":{"type":"method","name":"to_sass","children":[],"call":["(send\n  (send nil :value) :map) join "," sep_str ","v to_sass ","Sass Script Parser  precedence_of <= ","Sass Script Parser  precedence_of ","v separator ","v is_a? "," value map "," value "," separator "," value empty? ","(send\n  (block\n    (send\n      (send nil :value) :reject)\n    (args\n      (arg :e))\n    (send\n      (lvar :e) :is_a?\n      (const nil :Null))) :map) join ","(send\n  (send nil :value) :reject) map ","e is_a? "," value reject ","v operator == ","v operator "," separator == ","Sass Script Parser  Sass Script Parser  precedence_of _of <= ","Sass Script Parser  Sass Script Parser  precedence_of _of "]}," Script List to_s":{"type":"method","name":"to_s","children":[],"call":["(send\n  (block\n    (send\n      (send nil :value) :reject)\n    (args\n      (arg :e))\n    (and\n      (send\n        (lvar :e) :is_a?\n        (const nil :List))\n      (send\n        (send\n          (lvar :e) :value) :empty?))) :map) join "," sep_str ","e to_s ","(send\n  (send nil :value) :reject) map ","e value empty? ","e value ","e is_a? "," value reject "," value "," raise ","Sass SyntaxError  new "," value empty? ","(send\n  (send nil :value) :map) join "," value map ","(send\n  (block\n    (send\n      (send nil :value) :reject)\n    (args\n      (arg :e))\n    (or\n      (send\n        (lvar :e) :is_a?\n        (const nil :Null))\n      (and\n        (send\n          (lvar :e) :is_a?\n          (const nil :List))\n        (send\n          (send\n            (lvar :e) :value) :empty?)))) :map) join "]}," Script List eq":{"type":"method","name":"eq","children":[],"call":["Sass Script Bool  new "," separator == ","other separator "," separator "," value == ","other value "," value "," class == ","other class "," class ","other is_a? "]}," Script List initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Script Lexer current_position":{"type":"method","name":"current_position","children":[],"call":["@offset + "]}," Sass Script Lexer scan":{"type":"method","name":"scan","children":[],"call":["str [] size ","str [] ","@offset + ","str size ","c == ","str count ","@scanner scan ","str size - + ","str size - ","str rindex ","str [] size + ","@scanner scan  [] size ","@scanner scan  [] ","@scanner scan  size ","str count  == ","str str count ount ","@scanner scan  count ","@sstr count anner sstr count an ","@scanner scan  size - + ","@scanner scan  size - ","@scanner scan  rindex ","@scanner scan  [] size + "]}," Sass Script Lexer raw":{"type":"method","name":"raw","children":[],"call":[" scan "]}," Sass Script Lexer op":{"type":"method","name":"op","children":[],"call":["OPERATORS  [] ","@interpolation_stack << ","op == "," scan ","REGULAR_EXPRESSIONS  [] ","@interpolation_stack empty? ! ","@interpolation_stack empty? ","name == "," scan  == ","OPERATORS  []  == "]}," Sass Script Lexer ident_op":{"type":"method","name":"ident_op","children":[],"call":["OPERATORS  [] "," scan ","REGULAR_EXPRESSIONS  [] "]}," Sass Script Lexer special_fun":{"type":"method","name":"special_fun","children":[],"call":["str1 size + ","str2 size ","str1 size ","Sass Util  merge_adjacent_strings ","(lvar :str1) + ","Sass Engine  parse_interp ","str2 [] size ","str2 [] ","@offset + ","c == ","str2 count ","Sass Shared  balance "," scan ","str2 [] size + "," special_fun_body "," scan  size + "," scan  size ","Sass Util  merge_adjastr2 count ent_strings ","(lvar : scan ) + ","str2 [] size +  + ","@offset +  + ","str2 count  == ","str2 str2 count ount ","Sass Shared  balanstr2 count e "," sstr2 count an "," spestr2 count ial_fun_body "]}," Sass Script Lexer bool":{"type":"method","name":"bool","children":[],"call":["Script Bool  new ","s == "," scan ","REGULAR_EXPRESSIONS  [] ","script_bool source_range= "," range "," source_position ","Script Value Bool  new "," scan  == ","  scan can "," scan cript_bool  scan ource_range= ","Script Bool  new  source_range= ","Script Value Bool  new  source_range= ","  scan ource_po scan ition "]}," Sass Script Lexer color":{"type":"method","name":"color","children":[],"call":["Script Color  new ","num ljust to_i ","num ljust ","s scan first map ","s scan first ","s scan "," raise ","Sass SyntaxError  new ","(str \"Colors must have either three or six digits: '\") rstrip ","s size == ","s size "," scan ","REGULAR_EXPRESSIONS  [] ","Script Value Color  from_hex ","script_color source_range= "," range "," source_position ","Script Value Color  new ","@scanner [] length == ","@scanner [] length ","@scanner [] ","@scanner match? ","num lju scan t to_i ","num lju scan t "," scan   scan can fir scan t map "," scan   scan can fir scan t "," scan   scan can "," rai scan e ","Sa scan  scan  SyntaxError  new ","( scan tr \"Color scan  mu scan t have either three or  scan ix digit scan : '\") r scan trip "," scan   scan ize == "," scan   scan ize ","  scan can "," scan cript_color  scan ource_range= ","Script Value Color  from_hex  source_range= ","Script Color  new  source_range= ","Script Value Color  new  source_range= ","  scan ource_po scan ition ","@ scan canner [] length == ","@ scan canner [] length ","@ scan canner [] ","@ scan canner match? "]}," Sass Script Lexer number":{"type":"method","name":"number","children":[],"call":["Script Number  new "," Array ","@scanner [] ","value -@ ","@scanner [] to_i ","@scanner [] to_f "," scan ","REGULAR_EXPRESSIONS  [] ","Script Value Number  new ","(if\n  (send\n    (ivar :@scanner) :[]\n    (int 1))\n  (send\n    (send\n      (ivar :@scanner) :[]\n      (int 1)) :to_f)\n  (send\n    (send\n      (ivar :@scanner) :[]\n      (int 2)) :to_i)) * ","@scanner pos ","@scanner peek =~ ","@scanner peek ","@scanner pos == ","@scanner peek == ","script_number source_range= "," range "," source_position ","@scanner string [] == ","@scanner string [] ","@scanner pos - ","@scanner string ","@scanner pos != ","10 ** ","Sass Util  normalize_ident_escapes ","value -@  -@ ","@scanner [] to_i  -@ ","@scanner [] to_f  -@ ","(if\n  (send\n    (ivar :@scanner) :[]\n    (int 1))\n  (send\n    (send\n      (ivar :@scanner) :[]\n      (int 1)) :to_f)\n  (send\n    (send\n      (ivar :@scanner) :[]\n      (int 2)) :to_i)) *  -@ ","Script Value Number  new  source_range= ","Script Number  new  source_range= "]}," Sass Script Lexer string":{"type":"method","name":"string","children":[],"call":["Script String  new ","@scanner [] gsub ","@scanner [] ","@scanner [] == ","re == ","@interpolation_stack << ","@scanner pos "," scan ","STRING_REGULAR_EXPRESSIONS  [] ","STRING_REGULAR_EXPRESSIONS  [] [] ","Script Value String  new ","str source_range= "," range "," source_position ","Sass Script Value String  value ","Sass Util  sass_warn ","@options [] ","@scanner [] =~ ","Token  new ","@scanner pos - ","Sass Source Position  new ","@offset - ","Script String  new  source_range= ","Script Value String  new  source_range= "]}," Sass Script Lexer ident":{"type":"method","name":"ident","children":[],"call":["@scanner [] "," scan ","REGULAR_EXPRESSIONS  [] ","Sass Util  normalize_ident_escapes "]}," Sass Script Lexer _variable":{"type":"method","name":"_variable","children":[],"call":["@scanner [] "," scan ","Script  var_warning ","@options [] ","offset + ","@scanner [] != ","@scanner [] == ","Sass Util  normalize_ident_escapes "]}," Sass Script Lexer variable":{"type":"method","name":"variable","children":[],"call":[" _variable ","REGULAR_EXPRESSIONS  [] "]}," Sass Script Lexer token":{"type":"method","name":"token","children":[],"call":[" op "," ident "," ident_op "," special_fun "," raw "," string "," bool "," color "," number "," variable ","@interpolation_stack pop "," after_interpolation? "," special_val "," null "," selector "," raise ","interp_type == "," special_fun_body "," id ","Sass Util  normalize_ident_escapes ","@scanner [] "," scan ","REGULAR_EXPRESSIONS  [] ","@scanner string [] == ","@scanner string [] ","@scanner pos - ","@scanner pos ","@scanner string ","interp_type nil? ","@@interpolation_stack pop olation_stack pop "," after_@interpolation_stack pop olation? ","@interpolation_stack pop  == ","@interpolation_stack pop _type == ","@interpolation_stack pop  nil? ","@interpolation_stack pop _type nil? "]}," Sass Script Lexer whitespace":{"type":"method","name":"whitespace","children":[],"call":[" scan ","REGULAR_EXPRESSIONS  [] "]}," Sass Script Lexer read_token":{"type":"method","name":"read_token","children":[],"call":["Token  new ","@scanner pos - ","@scanner pos "," current_position - "," current_position ","val line= ","val is_a? ","@scanner matched_size "," token "," done? "," range "," source_position ","@offset - "]}," Sass Script Lexer str":{"type":"method","name":"str","children":[],"call":["@scanner string [] ","@scanner string ","@scanner pos ","@tok pos "]}," Sass Script Lexer expected!":{"type":"method","name":"expected!","children":[],"call":["Sass SCSS Parser  expected "," unpeek! "]}," Sass Script Lexer after_interpolation?":{"type":"method","name":"after_interpolation?","children":[],"call":["@prev type == ","@prev type "]}," Sass Script Lexer done?":{"type":"method","name":"done?","children":[],"call":["@tok nil? ","@scanner eos? "," whitespace ","@interpolation_stack last "," after_interpolation? ","@interpolation_stack empty? ! ","@interpolation_stack empty? "]}," Sass Script Lexer unpeek!":{"type":"method","name":"unpeek!","children":[],"call":["@scanner pos= ","@tok pos ","@tok source_range start_pos offset ","@tok source_range start_pos ","@tok source_range ","@tok source_range start_pos line ","@tok offset ","@tok line "," raise "]}," Sass Script Lexer peek":{"type":"method","name":"peek","children":[],"call":[" read_token "]}," Sass Script Lexer whitespace?":{"type":"method","name":"whitespace?","children":[],"call":["@scanner string [] =~ ","@scanner string [] ","@scanner pos - ","@scanner pos ","@scanner string ","tok pos "]}," Sass Script Lexer next":{"type":"method","name":"next","children":[],"call":[" read_token "]}," Sass Script Lexer initialize":{"type":"method","name":"initialize","children":[],"call":["StringScanner  new ","str is_a? ","Sass Util MultibyteStringScanner  new "]}," Sass Script Lexer string_re":{"type":"method","name":"string_re","children":[],"call":[]}," Script Interpolation _perform":{"type":"method","name":"_perform","children":[],"call":[" opts ","Sass Script String  new ","res << ","@after perform to_s ","@after perform ","val to_s ","val value ","val is_a? ","@mid perform ","@before perform to_s ","@before perform ","@mid perform  to_s ","@mid perform  @mid perform ue ","@mid perform  is_a? "]}," Script Interpolation children":{"type":"method","name":"children","children":[],"call":["(ivar :@before) compact "]}," Script Interpolation to_sass":{"type":"method","name":"to_sass","children":[],"call":["res << ","@after to_sass ","@mid to_sass ","@before to_sass "]}," Script Interpolation inspect":{"type":"method","name":"inspect","children":[],"call":["@after inspect ","@mid inspect ","@before inspect "]}," Script Interpolation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script Functions _adjust":{"type":"method","name":"_adjust","children":[],"call":["color with ","Sass Util  restrict ","color send send ","amount value ","color send "," raise ","ArgumentError  new ","range last ","range first ","range include? "," assert_type ","Sass Util  check_range "]}," Script Functions numeric_transformation":{"type":"method","name":"numeric_transformation","children":[],"call":["Sass Script Number  new ","value denominator_units ","value numerator_units ","value value "," assert_type ","Sass Script Value Number  new "]}," Script Functions if":{"type":"method","name":"if","children":[],"call":["condition to_bool "," truth to_bool "," truth "," assert_type "," perform "]}," Script Functions append":{"type":"method","name":"append","children":[],"call":["Sass Script List  new ","separator value to_sym ","separator value ","separator value == ","list to_a + ","list to_a ","list separator ","list is_a? "," raise ","ArgumentError  new ","(str \"auto\") include? "," assert_type "," list ","Sass Script Value List  new ","list with_contents ","list separator arator value to_sym ","separator value to_sym arator value to_sym ","list separator arator value ","separator value to_sym arator value ","list separator arator value == ","separator value to_sym arator value == ","list list separator arator ","list separator value to_sym arator "]}," Script Functions join":{"type":"method","name":"join","children":[],"call":["Sass Script List  new ","separator value to_sym ","separator value ","separator value == ","list1 to_a + ","list2 to_a ","list1 to_a ","list2 separator ","list2 value empty? ! ","list2 value empty? ","list2 value ","list2 is_a? ","list1 separator ","list1 value empty? ! ","list1 value empty? ","list1 value ","list1 is_a? "," raise ","ArgumentError  new ","(str \"auto\") include? "," assert_type "," list ","Sass Script Value List  new ","bracketed to_bool ","list1 bracketed ","bracketed value == ","bracketed value ","bracketed is_a? ","kwargs to_a first ","kwargs to_a ","kwargs empty? ","kwargs delete ","rest length + ","rest length ","rest empty? ","rest pop ","rest unshift ","rest last is_a? ","rest last "," identifier ","separator is_a? ","separator value to_sym arator value to_sym "," identifier  value to_sym ","separator value to_sym arator value "," identifier  value ","separator value to_sym arator value == "," identifier  value == ","list2 separator value to_sym arator ","list2  identifier  ","list1 separator value to_sym arator ","list1  identifier  "," identifier  to_bool "," identifier  is_a? ","rest pop  to_a first ","rest pop  to_a ","rest pop  empty? ","rest pop  delete ","separator value to_sym arator is_a? "]}," Script Functions nth":{"type":"method","name":"nth","children":[],"call":["list to_a [] ","n to_i - ","n to_i ","list to_a "," raise ","ArgumentError  new ","size != ","n to_i > ","list to_a size ","list to_a size == ","n to_i < ","n int? ! ","n int? "," assert_type ","Sass Script Value List  assert_valid_index ","n to_i abs > ","n to_i abs ","n to_i == ","list to_a size  != ","list to_a list to_a size  ","list to_a list to_a size  == ","Sass Script Value List  assert_valid_n to_i  ","Sass Script Value List  assert_valid_n to_i -  "]}," Script Functions length":{"type":"method","name":"length","children":[],"call":["Sass Script Number  new ","list to_a size ","list to_a "," number ","Sass Script Value Number  new "]}," Script Functions abs":{"type":"method","name":"abs","children":[],"call":["n abs "," numeric_transformation "]}," Script Functions floor":{"type":"method","name":"floor","children":[],"call":["n floor "," numeric_transformation "]}," Script Functions ceil":{"type":"method","name":"ceil","children":[],"call":["n ceil "," numeric_transformation "]}," Script Functions round":{"type":"method","name":"round","children":[],"call":["n round "," numeric_transformation ","Sass Util  round "]}," Script Functions percentage":{"type":"method","name":"percentage","children":[],"call":["Sass Script Number  new ","value value * ","value value "," raise ","ArgumentError  new ","value inspect ","value unitless? ","value is_a? "," number ","number value * ","number value ","number inspect ","number unitless? ","number is_a? ","Sass Script Value Number  new "]}," Script Functions comparable":{"type":"method","name":"comparable","children":[],"call":["Sass Script Bool  new ","number_1 comparable_to? "," assert_type ","number1 comparable_to? "," bool ","Sass Script Value Bool  new "]}," Script Functions unitless":{"type":"method","name":"unitless","children":[],"call":["Sass Script Bool  new ","number unitless? "," assert_type "," bool ","Sass Script Value Bool  new "]}," Script Functions unit":{"type":"method","name":"unit","children":[],"call":["Sass Script String  new ","number unit_str "," assert_type "," quoted_string ","Sass Script Value String  new "]}," Script Functions type_of":{"type":"method","name":"type_of","children":[],"call":["Sass Script String  new ","value class name gsub downcase ","value class name gsub ","value class name ","value class ","obj class name gsub downcase ","obj class name gsub ","obj class name ","obj class "," identifier ","Sass Script Value String  new ","value check_deprecated_interp ","value is_a? "]}," Script Functions quote":{"type":"method","name":"quote","children":[],"call":["Sass Script String  new ","string value "," assert_type ","str value "," quoted_string ","string type != ","string type ","Sass Script Value String  new "]}," Script Functions unquote":{"type":"method","name":"unquote","children":[],"call":["Sass Script String  new ","string value ","string is_a? ","str value "," assert_type "," identifier ","string type != ","string type ","Sass Script Value String  new ","string type == ","Sass Util  sass_warn ","string to_sass ","(str \"DEPRECATION WARNING: Passing \") strip "," environment stack to_s gsub ","  * "," environment stack to_s "," environment stack "," environment ","$_sass_warned_for_unquote << ","$_sass_warned_for_unquote include? ","frame line ","frame filename "," environment stack frames last "," environment stack frames ","Set  new ","string check_deprecated_interp "," environment stack frames last  line "," environment stack frames last  filename "," environment stack  environment stack frames last s last "," environment stack  environment stack frames last s "]}," Script Functions invert":{"type":"method","name":"invert","children":[],"call":["color with ","255 - ","color blue ","color green ","color red "," assert_type ","Sass Script String  new ","color is_a? "," identifier ","Sass Script Value String  new "," mix "]}," Script Functions complement":{"type":"method","name":"complement","children":[],"call":[" adjust_hue ","Number  new "," number ","Sass Script Value Number  new "]}," Script Functions grayscale":{"type":"method","name":"grayscale","children":[],"call":[" desaturate ","Number  new ","Sass Script String  new ","color is_a? "," number "," identifier ","Sass Script Value Number  new ","Sass Script Value String  new "]}," Script Functions mix":{"type":"method","name":"mix","children":[],"call":["Color  new ","rgb + ","color1 alpha * + ","color2 alpha * ","1 - ","color2 alpha ","color1 alpha * ","color1 alpha ","v1 * + ","v2 * ","v1 * ","color1 rgb zip map ","color1 rgb zip ","color2 rgb ","color1 rgb ","(send\n  (begin\n    (if\n      (begin\n        (send\n          (send\n            (lvar :w) :*\n            (lvar :a)) :==\n          (int -1)))\n      (lvar :w)\n      (send\n        (begin\n          (send\n            (lvar :w) :+\n            (lvar :a))) :/\n        (begin\n          (send\n            (int 1) :+\n            (send\n              (lvar :w) :*\n              (lvar :a))))))) :+\n  (int 1)) / ","(if\n  (begin\n    (send\n      (send\n        (lvar :w) :*\n        (lvar :a)) :==\n      (int -1)))\n  (lvar :w)\n  (send\n    (begin\n      (send\n        (lvar :w) :+\n        (lvar :a))) :/\n    (begin\n      (send\n        (int 1) :+\n        (send\n          (lvar :w) :*\n          (lvar :a)))))) + ","(send\n  (lvar :w) :+\n  (lvar :a)) / ","1 + ","w * ","w + ","w * == ","color1 alpha - ","p * - ","p * ","weight value / ","weight value "," raise ","ArgumentError  new ","(irange\n  (int 0)\n  (int 100)) include? "," assert_type ","(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ","Sass Util  check_range ","color_1 alpha * + ","color_2 alpha * ","color_2 alpha ","color_1 alpha * ","color_1 alpha ","color_1 rgb zip map ","color_1 rgb zip ","color_2 rgb ","color_1 rgb ","color_1 alpha - "," rgb_color ","rgba << ","(send\n  (begin\n    (if\n      (send\n        (send\n          (lvar :w) :*\n          (lvar :a)) :==\n        (int -1))\n      (lvar :w)\n      (send\n        (begin\n          (send\n            (lvar :w) :+\n            (lvar :a))) :/\n        (begin\n          (send\n            (int 1) :+\n            (send\n              (lvar :w) :*\n              (lvar :a))))))) :+\n  (int 1)) / ","(if\n  (send\n    (send\n      (lvar :w) :*\n      (lvar :a)) :==\n    (int -1))\n  (lvar :w)\n  (send\n    (begin\n      (send\n        (lvar :w) :+\n        (lvar :a))) :/\n    (begin\n      (send\n        (int 1) :+\n        (send\n          (lvar :w) :*\n          (lvar :a)))))) + ","Sass Script Value Color  new ","Color  nep * -  ","color1 color1 alpha * +  * + ","color1 color_1 alpha * +  * + ","color1 color1 alpha - lphcolor1 alpha -  * + ","color1 color_1 alpha - lphcolor_1 alpha -  * + ","color1 alweight value / ha * + ","color1 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha * + ","color2 color1 alpha * +  * ","color2 color_1 alpha * +  * ","color2 color1 alpha - lphcolor1 alpha -  * ","color2 color_1 alpha - lphcolor_1 alpha -  * ","color2 alweight value / ha * ","color2 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha * ","color2 color1 alpha * +  ","color2 color_1 alpha * +  ","color2 color1 alpha - lphcolor1 alpha -  ","color2 color_1 alpha - lphcolor_1 alpha -  ","color2 alweight value / ha ","color2 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha ","color1 color1 alpha * +  * ","color1 color_1 alpha * +  * ","color1 color1 alpha - lphcolor1 alpha -  * ","color1 color_1 alpha - lphcolor_1 alpha -  * ","color1 alweight value / ha * ","color1 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha * ","color1 color1 alpha * +  ","color1 color_1 alpha * +  ","color1 color1 alpha - lphcolor1 alpha -  ","color1 color_1 alpha - lphcolor_1 alpha -  ","color1 alweight value / ha ","color1 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha ","color1 rgb zip mcolor1 alpha - p ","color1 rgb zip mcolor_1 alpha - p ","color1 rgb ziweight value /  maweight value /  ","color1 rgb zi(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f  ma(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f  ","color1 rgb ziweight value /  ","color1 rgb zi(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f  ","(send\n  (begin\n    (if\n      (begin\n        (send\n          (send\n            (lvcolor1 alpha - r :w) :*\n            (lvcolor1 alpha - r :color1 alpha - )) :==\n          (int -1)))\n      (lvcolor1 alpha - r :w)\n      (send\n        (begin\n          (send\n            (lvcolor1 alpha - r :w) :+\n            (lvcolor1 alpha - r :color1 alpha - ))) :/\n        (begin\n          (send\n            (int 1) :+\n            (send\n              (lvcolor1 alpha - r :w) :*\n              (lvcolor1 alpha - r :color1 alpha - ))))))) :+\n  (int 1)) / ","(send\n  (begin\n    (if\n      (begin\n        (send\n          (send\n            (lvcolor_1 alpha - r :w) :*\n            (lvcolor_1 alpha - r :color_1 alpha - )) :==\n          (int -1)))\n      (lvcolor_1 alpha - r :w)\n      (send\n        (begin\n          (send\n            (lvcolor_1 alpha - r :w) :+\n            (lvcolor_1 alpha - r :color_1 alpha - ))) :/\n        (begin\n          (send\n            (int 1) :+\n            (send\n              (lvcolor_1 alpha - r :w) :*\n              (lvcolor_1 alpha - r :color_1 alpha - ))))))) :+\n  (int 1)) / ","(send\n  (begin\n    (if\n      (begin\n        (send\n          (send\n            (lvar :p * - ) :*\n            (lvar :a)) :==\n          (int -1)))\n      (lvar :p * - )\n      (send\n        (begin\n          (send\n            (lvar :p * - ) :+\n            (lvar :a))) :/\n        (begin\n          (send\n            (int 1) :+\n            (send\n              (lvar :p * - ) :*\n              (lvar :a))))))) :+\n  (int 1)) / ","(if\n  (begin\n    (send\n      (send\n        (lvcolor1 alpha - r :w) :*\n        (lvcolor1 alpha - r :color1 alpha - )) :==\n      (int -1)))\n  (lvcolor1 alpha - r :w)\n  (send\n    (begin\n      (send\n        (lvcolor1 alpha - r :w) :+\n        (lvcolor1 alpha - r :color1 alpha - ))) :/\n    (begin\n      (send\n        (int 1) :+\n        (send\n          (lvcolor1 alpha - r :w) :*\n          (lvcolor1 alpha - r :color1 alpha - )))))) + ","(if\n  (begin\n    (send\n      (send\n        (lvcolor_1 alpha - r :w) :*\n        (lvcolor_1 alpha - r :color_1 alpha - )) :==\n      (int -1)))\n  (lvcolor_1 alpha - r :w)\n  (send\n    (begin\n      (send\n        (lvcolor_1 alpha - r :w) :+\n        (lvcolor_1 alpha - r :color_1 alpha - ))) :/\n    (begin\n      (send\n        (int 1) :+\n        (send\n          (lvcolor_1 alpha - r :w) :*\n          (lvcolor_1 alpha - r :color_1 alpha - )))))) + ","(if\n  (begin\n    (send\n      (send\n        (lvar :p * - ) :*\n        (lvar :a)) :==\n      (int -1)))\n  (lvar :p * - )\n  (send\n    (begin\n      (send\n        (lvar :p * - ) :+\n        (lvar :a))) :/\n    (begin\n      (send\n        (int 1) :+\n        (send\n          (lvar :p * - ) :*\n          (lvar :a)))))) + ","(send\n  (lvcolor1 alpha - r :w) :+\n  (lvcolor1 alpha - r :color1 alpha - )) / ","(send\n  (lvcolor_1 alpha - r :w) :+\n  (lvcolor_1 alpha - r :color_1 alpha - )) / ","(send\n  (lvar :p * - ) :+\n  (lvar :a)) / ","p * -  * ","p * -  + ","p * -  * == ","color1 color1 alpha * +  - ","color1 color_1 alpha * +  - ","color1 color1 alpha - lphcolor1 alpha -  - ","color1 color_1 alpha - lphcolor_1 alpha -  - ","color1 alweight value / ha - ","color1 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha - ","weight value /  * - ","(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f  * - ","weight value /  * ","(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f  * ","weight vcolor1 alpha - lue / ","weight vcolor_1 alpha - lue / ","p * - eight value / ","weight vcolor1 alpha - lue ","weight vcolor_1 alpha - lue ","p * - eight value "," rcolor1 alpha - ise "," rcolor_1 alpha - ise ","ArgumentError  nep * -  ","(ircolor1 alpha - nge\n  (int 0)\n  (int 100)) include? ","(ircolor_1 alpha - nge\n  (int 0)\n  (int 100)) include? "," color1 alpha - ssert_type "," color_1 alpha - ssert_type "," assert_tyweight value / e "," assert_ty(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f e ","(send\n  (send\n    (lvcolor1 alpha - r :weight) :vcolor1 alpha - lue) :/\n  (flocolor1 alpha - t 100.0)) to_f ","(send\n  (send\n    (lvcolor_1 alpha - r :weight) :vcolor_1 alpha - lue) :/\n  (flocolor_1 alpha - t 100.0)) to_f ","(send\n  (send\n    (lvar :p * - eight) :value) :/\n  (float 100.0)) to_f ","Scolor1 alpha - ss Util  check_rcolor1 alpha - nge ","Scolor_1 alpha - ss Util  check_rcolor_1 alpha - nge ","color_1 color1 alpha * +  * + ","color_1 color_1 alpha * +  * + ","color_1 color1 alpha - lphcolor1 alpha -  * + ","color_1 color_1 alpha - lphcolor_1 alpha -  * + ","color_1 alweight value / ha * + ","color_1 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha * + ","color_2 color1 alpha * +  * ","color_2 color_1 alpha * +  * ","color_2 color1 alpha - lphcolor1 alpha -  * ","color_2 color_1 alpha - lphcolor_1 alpha -  * ","color_2 alweight value / ha * ","color_2 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha * ","color_2 color1 alpha * +  ","color_2 color_1 alpha * +  ","color_2 color1 alpha - lphcolor1 alpha -  ","color_2 color_1 alpha - lphcolor_1 alpha -  ","color_2 alweight value / ha ","color_2 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha ","color_1 color1 alpha * +  * ","color_1 color_1 alpha * +  * ","color_1 color1 alpha - lphcolor1 alpha -  * ","color_1 color_1 alpha - lphcolor_1 alpha -  * ","color_1 alweight value / ha * ","color_1 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha * ","color_1 color1 alpha * +  ","color_1 color_1 alpha * +  ","color_1 color1 alpha - lphcolor1 alpha -  ","color_1 color_1 alpha - lphcolor_1 alpha -  ","color_1 alweight value / ha ","color_1 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha ","color_1 rgb zip mcolor1 alpha - p ","color_1 rgb zip mcolor_1 alpha - p ","color_1 rgb ziweight value /  maweight value /  ","color_1 rgb zi(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f  ma(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f  ","color_1 rgb ziweight value /  ","color_1 rgb zi(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f  ","color_1 color1 alpha * +  - ","color_1 color_1 alpha * +  - ","color_1 color1 alpha - lphcolor1 alpha -  - ","color_1 color_1 alpha - lphcolor_1 alpha -  - ","color_1 alweight value / ha - ","color_1 al(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f ha - ","rgbcolor1 alpha -  << ","rgbcolor_1 alpha -  << ","(send\n  (begin\n    (if\n      (send\n        (send\n          (lvcolor1 alpha - r :w) :*\n          (lvcolor1 alpha - r :color1 alpha - )) :==\n        (int -1))\n      (lvcolor1 alpha - r :w)\n      (send\n        (begin\n          (send\n            (lvcolor1 alpha - r :w) :+\n            (lvcolor1 alpha - r :color1 alpha - ))) :/\n        (begin\n          (send\n            (int 1) :+\n            (send\n              (lvcolor1 alpha - r :w) :*\n              (lvcolor1 alpha - r :color1 alpha - ))))))) :+\n  (int 1)) / ","(send\n  (begin\n    (if\n      (send\n        (send\n          (lvcolor_1 alpha - r :w) :*\n          (lvcolor_1 alpha - r :color_1 alpha - )) :==\n        (int -1))\n      (lvcolor_1 alpha - r :w)\n      (send\n        (begin\n          (send\n            (lvcolor_1 alpha - r :w) :+\n            (lvcolor_1 alpha - r :color_1 alpha - ))) :/\n        (begin\n          (send\n            (int 1) :+\n            (send\n              (lvcolor_1 alpha - r :w) :*\n              (lvcolor_1 alpha - r :color_1 alpha - ))))))) :+\n  (int 1)) / ","(send\n  (begin\n    (if\n      (send\n        (send\n          (lvar :p * - ) :*\n          (lvar :a)) :==\n        (int -1))\n      (lvar :p * - )\n      (send\n        (begin\n          (send\n            (lvar :p * - ) :+\n            (lvar :a))) :/\n        (begin\n          (send\n            (int 1) :+\n            (send\n              (lvar :p * - ) :*\n              (lvar :a))))))) :+\n  (int 1)) / ","(if\n  (send\n    (send\n      (lvcolor1 alpha - r :w) :*\n      (lvcolor1 alpha - r :color1 alpha - )) :==\n    (int -1))\n  (lvcolor1 alpha - r :w)\n  (send\n    (begin\n      (send\n        (lvcolor1 alpha - r :w) :+\n        (lvcolor1 alpha - r :color1 alpha - ))) :/\n    (begin\n      (send\n        (int 1) :+\n        (send\n          (lvcolor1 alpha - r :w) :*\n          (lvcolor1 alpha - r :color1 alpha - )))))) + ","(if\n  (send\n    (send\n      (lvcolor_1 alpha - r :w) :*\n      (lvcolor_1 alpha - r :color_1 alpha - )) :==\n    (int -1))\n  (lvcolor_1 alpha - r :w)\n  (send\n    (begin\n      (send\n        (lvcolor_1 alpha - r :w) :+\n        (lvcolor_1 alpha - r :color_1 alpha - ))) :/\n    (begin\n      (send\n        (int 1) :+\n        (send\n          (lvcolor_1 alpha - r :w) :*\n          (lvcolor_1 alpha - r :color_1 alpha - )))))) + ","(if\n  (send\n    (send\n      (lvar :p * - ) :*\n      (lvar :a)) :==\n    (int -1))\n  (lvar :p * - )\n  (send\n    (begin\n      (send\n        (lvar :p * - ) :+\n        (lvar :a))) :/\n    (begin\n      (send\n        (int 1) :+\n        (send\n          (lvar :p * - ) :*\n          (lvar :a)))))) + ","Scolor1 alpha - ss Script Vcolor1 alpha - lue Color  new ","Scolor_1 alpha - ss Script Vcolor_1 alpha - lue Color  new ","Sass Script Value Color  nep * -  ","Sass Scriweight value / t Value Color  new ","Sass Scri(send\n  (send\n    (lvar :weight) :value) :/\n  (float 100.0)) to_f t Value Color  new "]}," Script Functions change_color":{"type":"method","name":"change_color","children":[],"call":["color with "," raise ","ArgumentError  new ","kwargs to_a first ","kwargs to_a ","kwargs empty? ","val value ","name to_sym "," assert_type ","kwargs delete ","Sass Util  map_hash ","Sass Util  to_hash ","(str \"red\") map ","Sass Util  check_range ","color Sass Util  to_hash  ","kwargs delete  kwargs delete ue ","val value  val value ue ","Sass Util  check_range  Sass Util  check_range ue "]}," Script Functions scale_color":{"type":"method","name":"scale_color","children":[],"call":["color with "," raise ","ArgumentError  new ","kwargs to_a first ","kwargs to_a ","kwargs empty? ","current + ","diff * ","name to_sym ","max - ","scale > ","val value / ","val value ","color send ","(irange\n  (int -100)\n  (int 100)) include? ! ","(irange\n  (int -100)\n  (int 100)) include? ","(and\n  (send\n    (send\n      (lvar :val) :numerator_units) :==\n    (array\n      (str \"%\")))\n  (send\n    (send\n      (lvar :val) :denominator_units) :empty?)) ! ","val denominator_units empty? ","val denominator_units ","val numerator_units == ","val numerator_units "," assert_type ","kwargs delete ","Sass Util  map_hash ","Sass Util  check_range "," assert_unit ","color send  + ","max -  * ","val value /  > ","kwargs delete  kwargs delete ue / ","kwargs delete  kwargs delete ue ","(and\n  (send\n    (send\n      (lvar :kwargs delete ) :numerator_units) :==\n    (array\n      (str \"%\")))\n  (send\n    (send\n      (lvar :kwargs delete ) :denominator_units) :empty?)) ! ","kwargs delete  denominator_units empty? ","kwargs delete  denominator_units ","kwargs delete  numerator_units == ","kwargs delete  numerator_units "]}," Script Functions adjust_color":{"type":"method","name":"adjust_color","children":[],"call":["color with "," raise ","ArgumentError  new ","kwargs to_a first ","kwargs to_a ","kwargs empty? ","name to_sym ","(int 0) max ","Sass Util  restrict ","color send + ","val value ","color send ","range last ","range first ","range include? ! ","range include? "," assert_type ","kwargs delete ","Sass Util  map_hash ","Sass Util  check_range ","kwargs delete  kwargs delete ue "]}," Script Functions adjust_hue":{"type":"method","name":"adjust_hue","children":[],"call":["color with ","color hue + ","degrees value ","color hue "," assert_type "]}," Script Functions desaturate":{"type":"method","name":"desaturate","children":[],"call":[" _adjust "," adjust "]}," Script Functions saturate":{"type":"method","name":"saturate","children":[],"call":[" _adjust "," adjust ","Sass Script String  new ","amount nil? "," identifier ","Sass Script Value String  new "]}," Script Functions darken":{"type":"method","name":"darken","children":[],"call":[" _adjust "," adjust "]}," Script Functions lighten":{"type":"method","name":"lighten","children":[],"call":[" _adjust "," adjust "]}," Script Functions transparentize":{"type":"method","name":"transparentize","children":[],"call":[" _adjust "," adjust "]}," Script Functions opacify":{"type":"method","name":"opacify","children":[],"call":[" _adjust "," adjust "]}," Script Functions opacity":{"type":"method","name":"opacity","children":[],"call":["Sass Script Number  new ","color alpha "," assert_type ","Sass Script String  new ","color is_a? "," number "," identifier ","Sass Script Value Number  new ","Sass Script Value String  new "]}," Script Functions alpha":{"type":"method","name":"alpha","children":[],"call":[" opacity ","Sass Script String  new ","(send\n  (lvar :args) :map) join ","a to_s ","args map ","a value =~ ","a value ","a type == ","a type ","a is_a? ","args all? ","Sass Script Number  new ","args first alpha ","args first "," assert_type "," raise ","ArgumentError  new ","args size ","args size != "," number "," identifier ","Sass Script Value Number  new ","Sass Script Value String  new "]}," Script Functions lightness":{"type":"method","name":"lightness","children":[],"call":["Sass Script Number  new ","color lightness "," assert_type "," number ","Sass Script Value Number  new "]}," Script Functions saturation":{"type":"method","name":"saturation","children":[],"call":["Sass Script Number  new ","color saturation "," assert_type "," number ","Sass Script Value Number  new "]}," Script Functions hue":{"type":"method","name":"hue","children":[],"call":["Sass Script Number  new ","color hue "," assert_type "," number ","Sass Script Value Number  new "]}," Script Functions blue":{"type":"method","name":"blue","children":[],"call":["Sass Script Number  new ","color blue "," assert_type "," number ","Sass Script Value Number  new "]}," Script Functions green":{"type":"method","name":"green","children":[],"call":["Sass Script Number  new ","color green "," assert_type "," number ","Sass Script Value Number  new "]}," Script Functions red":{"type":"method","name":"red","children":[],"call":["Sass Script Number  new ","color red "," assert_type "," number ","Sass Script Value Number  new "]}," Script Functions hsla":{"type":"method","name":"hsla","children":[],"call":["Color  new ","alpha value "," raise ","ArgumentError  new ","(irange\n  (int 0)\n  (int 100)) include? ","a value ","(lvar :hue) map ","(irange\n  (int 0)\n  (int 1)) include? "," assert_type ","Sass Util  check_range ","hue value ","Sass Script Value Color  new ","lightness value ","saturation value "," check_alpha_unit "," unquoted_string "," calc? "," special_number? "," var? ","alpha nil? ","lightness nil? ","saturation nil? "," percentage_or_unitless ","CoSass Util  check_range or  new ","Colightness value or  new ","aSass Util  check_range pha vaSass Util  check_range ue ","alightness value pha valightness value ue ","alphue value a value "," raiSass Util  check_range e "," raisaturation value e ","(irange\n  (int 0)\n  (int 100)) incSass Util  check_range ude? ","(irange\n  (int 0)\n  (int 100)) inclightness value ude? ","a vaSass Util  check_range ue ","a valightness value ue ","(Sass Util  check_range var :hue) map ","(lightness value var :hue) map ","(lvar :hue value ue) map ","(irange\n  (int 0)\n  (int 1)) incSass Util  check_range ude? ","(irange\n  (int 0)\n  (int 1)) inclightness value ude? "," aSass Util  check_range Sass Util  check_range ert_type "," asaturation value saturation value ert_type ","Sass UtiSass Util  check_range   check_range ","Sass Utilightness value   check_range ","SaSass Util  check_range Sass Util  check_range  Util  check_range ","Sasaturation value saturation value  Util  check_range ","Sass Util  chue value eck_range ","hue vaSass Util  check_range ue ","hue valightness value ue ","hue value ue value ","Sass Script VaSass Util  check_range ue CoSass Util  check_range or  new ","Sass Script Valightness value ue Colightness value or  new ","SaSass Util  check_range Sass Util  check_range  Script Value Color  new ","Sasaturation value saturation value  Script Value Color  new ","Sass Util  check_range ightness vaSass Util  check_range ue ","lightness value ightness valightness value ue ","lightneSass Util  check_range Sass Util  check_range  value ","lightnesaturation value saturation value  value ","lighue value tness value ","saturation vaSass Util  check_range ue ","saturation valightness value ue ","Sass Util  check_range aturation value ","saturation value aturation value "," check_aSass Util  check_range pha_unit "," check_alightness value pha_unit "," chue value eck_alphue value a_unit "," unquoted_Sass Util  check_range tring "," unquoted_saturation value tring "," caSass Util  check_range c? "," calightness value c? "," speciaSass Util  check_range _number? "," specialightness value _number? "," Sass Util  check_range pecial_number? "," saturation value pecial_number? ","aSass Util  check_range pha niSass Util  check_range ? ","alightness value pha nilightness value ? ","alphue value a nil? ","Sass Util  check_range ightness niSass Util  check_range ? ","lightness value ightness nilightness value ? ","lightneSass Util  check_range Sass Util  check_range  nil? ","lightnesaturation value saturation value  nil? ","lighue value tness nil? ","saturation niSass Util  check_range ? ","saturation nilightness value ? ","Sass Util  check_range aturation nil? ","saturation value aturation nil? "," percentage_or_unitSass Util  check_range ess "," percentage_or_unitlightness value ess "," percentage_or_unitleSass Util  check_range Sass Util  check_range  "," percentage_or_unitlesaturation value saturation value  "]}," Script Functions hsl":{"type":"method","name":"hsl","children":[],"call":[" hsla ","Number  new "," number ","Sass Script Value Number  new "," unquoted_string "," calc? "," special_number? "," raise ","ArgumentError  new "," var? ","lightness nil? ","saturation nil? "]}," Script Functions rgba":{"type":"method","name":"rgba","children":[],"call":[" raise ","ArgumentError  new ","args size "," rgba "," rgb ","color with ","alpha value ","(irange\n  (int 0)\n  (int 1)) include? "," assert_type ","Sass Util  check_range "," check_alpha_unit "," unquoted_string "," calc? ","color blue ","color green ","color red "," special_number? ","args join "," var? ","args [] ","color is_a? ","args first "," percentage_or_unitless "]}," Script Functions rgb":{"type":"method","name":"rgb","children":[],"call":["Color  new "," raise ","ArgumentError  new ","(irange\n  (int 0)\n  (int 255)) include? ","v * / ","v * ","(irange\n  (int 0)\n  (int 100)) include? ","c denominator_units empty? ","c denominator_units ","c numerator_units == ","c numerator_units ","c value ","(lvar :red) map "," assert_type ","Sass Util  check_range ","(array\n  (lvar :red)\n  (sym :red)) map ","Sass Script Value Color  new ","c unitless? ","c is_unit? ","c value * / ","c value * "," unquoted_string "," calc? "," special_number? "," var? ","blue nil? ","green nil? "," percentage_or_unitless ","c value  * / ","Sass Util  check_range  * / ","c value  * ","Sass Util  check_range  * ","c c value alue ","c Sass Util  check_range alue ","(lc value ar :red) map ","(lSass Util  check_range ar :red) map ","(array\n  (lc value ar :red)\n  (sym :red)) map ","(array\n  (lSass Util  check_range ar :red)\n  (sym :red)) map ","c c value alue * / ","c Sass Util  check_range alue * / ","c c value alue * ","c Sass Util  check_range alue * "," c value ar? "," Sass Util  check_range ar? "]}," Script Functions include":{"type":"method","name":"include","children":[],"call":["EvaluationContext  send "," update_callable_functions "]}," Script Functions EvaluationContext assert_type":{"type":"method","name":"assert_type","children":[],"call":[" raise ","ArgumentError  new ","(str \"$\") + ","type to_s downcase ","type to_s ","value inspect ","value is_a? ","Sass Script  const_get ","name to_s gsub ","name to_s ","TYPE_NAMES  [] ","value is_pseudo_map? ","type == ","Sass Script Value  const_get ","value value empty? ","value value ","value check_deprecated_interp ","name to_s tr ","type_names join ","t to_s downcase ","t to_s ","valid_types map ","valid_types size == ","valid_types size ","found_type == ","t == ","valid_types find "," Array "," Array  map "," Array  size == "," Array  size "," Array  find "]}," Script Functions EvaluationContext initialize":{"type":"method","name":"initialize","children":[],"call":[" include ","environment options "]}," Script Functions signature":{"type":"method","name":"signature","children":[],"call":[]}," Script Functions declare":{"type":"method","name":"declare","children":[],"call":[]}," Sass Script Funcall perform_sass_fn":{"type":"method","name":"perform_sass_fn","children":[],"call":[" raise ","Sass SyntaxError  new ","Sass Tree Visitors Perform  visit ","function tree each ","function tree "," catch ","var inspect ","env var ","var name ","env set_local_var ","default perform ","keywords [] ","var underscored_name ","function args zip inject ","Sass Environment  new ","function environment ","function args zip ","function args ","ArgumentError  new ","function args size ","args size ","args size > ","var underscored_name == ","function args find ","keywords each ","Sass Tree Visitors Perform  perform_arguments ","(send\n  (lvar :unknown_args) :map) join ","unknown_args map ","unknown_args length > ","unknown_args length ","unknown_args any? ","keywords keys - ","var first underscored_name ","var first ","function args map ","keywords keys ","keywords any? ","keywords include? ","(send\n  (lvar :keywords keys - ) :map) join ","keywords keys -  map ","keywords keys -  length > ","keywords keys -  length ","keywords keys -  any? "]}," Sass Script Funcall construct_ruby_args":{"type":"method","name":"construct_ruby_args","children":[],"call":[" raise ","Sass SyntaxError  new ","keywords keys sort first ","keywords keys sort ","keywords keys ","args << ","signature var_kwargs ","keywords size > ","keywords size ","args + ","keywords delete ","keywords has_key? ","signature args [] map ","signature args [] ","args size ","signature args ","keywords empty? ","args [] inspect ","args [] ","signature args size ","args size > ","signature var_args ! ","signature var_args ","v perform ","Sass Util  map_hash "," keywords empty? "," keywords ","Functions  signature ","@keywords size ","name to_sym ","k to_sym ","signature args include? ","splat keywords ","splat is_a? ","@keywords empty? ","splat keywords_accessed= ","splat keywords size ","splat to_a ","splat keywords  keys sort first ","splat keywords  keys sort ","splat keywords  keys ","args +  << ","signature var_kwargs +  ","Functions  signature  var_kwargs ","splat keywords  size > ","splat keywords  size ","args +  + ","splat keywords  delete ","splat keywords  has_key? ","signature args +  [] map ","Functions  signature  args [] map ","signature args +  [] ","Functions  signature  args [] ","args +  size ","signature args +  ","Functions  signature  args ","splat keywords  empty? ","args +  [] inspect ","args +  [] ","signature args +  size ","Functions  signature  args size ","args +  size > ","signature var_args +  ! ","Functions  signature  var_args ! ","signature var_args +  ","Functions  signature  var_args "," splat keywords  empty? "," splat keywords  ","Functions  Functions  signature  ","@splat keywords  size ","signature args +  include? ","Functions  signature  args include? ","splat splat keywords  ","@splat keywords  empty? ","splat splat keywords _accessed= ","splat splat keywords  size "]}," Sass Script Funcall to_literal":{"type":"method","name":"to_literal","children":[],"call":["Script String  new ","args join "," name "]}," Sass Script Funcall _perform":{"type":"method","name":"_perform","children":[],"call":[" raise ","Sass SyntaxError  new "," name ","e message ","t =~ ","e backtrace any? ","e backtrace "," opts "," to_literal ","Functions EvaluationContext  new send ","Functions EvaluationContext  new ","environment options ","Functions  callable? "," construct_ruby_args ","@name tr "," perform_sass_fn ","v perform ","Sass Util  map_hash ","environment function ","a perform ","@args map ","Script String  new ","(send\n  (lvar :args) :map) join ","args map ","ruby_name !~ ","Sass Util  has? "," name gsub "," args map "," args ","performed_args join ","args join ","result options= "," construct_keyword_args ","@keywords empty? ","e backtrace [] !~ ","e backtrace [] ","e message =~ ","@splat perform ","Sass Util  jruby1_6? ! ","Sass Util  jruby1_6? ","(and\n  (send\n    (send\n      (lvar :trace) :[]\n      (int 0)) :=~\n    (regexp\n      (str \":in `send'$\")\n      (regopt)))\n  (send\n    (send\n      (lvar :trace) :[]\n      (int 1)) :=~\n    (regexp\n      (str \":in `_perform'$\")\n      (regopt)))) ! ","trace [] =~ ","trace [] ","trace shift !~ ","trace shift ","e backtrace dup ","Sass Util  jruby? ","error_name != ","Sass Util  rbx? "," without_original ","RUBY_PLATFORM  !~ ","Environment  new ","environment global_env ","e e message  ","e backe backtrace dup  any? ","e backe backtrace dup  "," construct_ruby_ construct_ruby_args  "," construct_ruby_ construct_keyword_args  "," perform_sass_environment function  ","@ construct_ruby_args  map ","@ construct_keyword_args  map ","(send\n  (lvar : construct_ruby_args ) :map) join ","(send\n  (lvar : construct_keyword_args ) :map) join "," construct_ruby_args  map "," construct_keyword_args  map ","@name tr  !~ "," name gsub  !~ ","  construct_ruby_args  map ","  construct_keyword_args  map ","  construct_ruby_args  ","  construct_keyword_args  ","performed_ construct_ruby_args  join ","performed_ construct_keyword_args  join "," construct_ruby_args  join "," construct_keyword_args  join ","Functions EvaluationContext  new send  options= ","Script String  new  options= "," construct_keyword_ construct_ruby_args  "," construct_keyword_ construct_keyword_args  ","e backe backtrace dup  [] !~ ","e backe backtrace dup  [] ","e e message  =~ ","@@splat perform  perform ","(and\n  (send\n    (send\n      (lvar :e backtrace dup ) :[]\n      (int 0)) :=~\n    (regexp\n      (str \":in `send'$\")\n      (regopt)))\n  (send\n    (send\n      (lvar :e backtrace dup ) :[]\n      (int 1)) :=~\n    (regexp\n      (str \":in `_perform'$\")\n      (regopt)))) ! ","e backtrace dup  [] =~ ","e backtrace dup  [] ","e backtrace dup  shift !~ ","e backtrace dup  shift ","e backe backtrace dup  dup "]}," Sass Script Funcall children":{"type":"method","name":"children","children":[],"call":["@args + ","@keywords values ","res << ","@args +  << "]}," Sass Script Funcall to_sass":{"type":"method","name":"to_sass","children":[],"call":["keywords empty? ","args empty? "," dasherize "," name ","(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ","v to_sass ","(send\n  (ivar :@keywords) :sort_by) map ","@keywords sort_by ","(send\n  (ivar :@args) :map) join ","a to_sass ","@args map ","(send\n  (send nil :args) :map) join "," args map "," args ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join ","Sass Util  hash_to_a map ","Sass Util  hash_to_a "," splat inspect "," splat ","arg_to_sass [] ","@args map join ","arg separator == ","arg separator ","arg is_a? ","arg to_sass "," lambda ","(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join  empty? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  empty? ","(send\n  (ivar :@args) :map) join  empty? ","@args map join  empty? ","(send\n  (block\n    (send\n      (ivar :@(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ","(send\n  (block\n    (send\n      (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join ) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ","(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    ((send\n  (ivar :@args) :map) join \n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ","(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (@args map join \n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ","v to_arg to_sass  ","(send\n  (ivar :@(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ) :sort_by) map ","(send\n  (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join ) :sort_by) map ","@(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join  sort_by ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  sort_by ","(send\n  (ivar :@(send\n  (ivar :@args) :map) join ) :map) join ","(send\n  (ivar :@@args map join ) :map) join ","a to_arg to_sass  ","@(send\n  (ivar :@args) :map) join  map ","@@args map join  map ","(send\n  (send nil :(send\n  (ivar :@args) :map) join ) :map) join ","(send\n  (send nil :@args map join ) :map) join "," (send\n  (ivar :@args) :map) join  map "," @args map join  map "," (send\n  (ivar :@args) :map) join  "," @args map join  ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join )) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join )) :map) join ","arg_to_arg to_sass  [] ","@(send\n  (ivar :@args) :map) join  map join ","@@args map join  map join ","arg to_arg to_sass  "]}," Sass Script Funcall inspect":{"type":"method","name":"inspect","children":[],"call":["keywords empty? ","args empty? "," name ","(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ","v inspect ","(send\n  (ivar :@keywords) :sort_by) map ","@keywords sort_by ","(send\n  (ivar :@args) :map) join ","a inspect ","@args map ","(send\n  (send nil :args) :map) join "," args map "," args ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join ","Sass Util  hash_to_a map ","Sass Util  hash_to_a "," splat inspect "," splat ","(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join  empty? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  empty? ","(send\n  (ivar :@args) :map) join  empty? ","(send\n  (block\n    (send\n      (ivar :@(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ","(send\n  (block\n    (send\n      (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join ) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ","(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    ((send\n  (ivar :@args) :map) join \n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ","(send\n  (ivar :@(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join ) :sort_by) map ","(send\n  (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join ) :sort_by) map ","@(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join  sort_by ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  sort_by ","(send\n  (ivar :@(send\n  (ivar :@args) :map) join ) :map) join ","@(send\n  (ivar :@args) :map) join  map ","(send\n  (send nil :(send\n  (ivar :@args) :map) join ) :map) join "," (send\n  (ivar :@args) :map) join  map "," (send\n  (ivar :@args) :map) join  ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@(send\n  (block\n    (send\n      (ivar :@keywords) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (lvar :k)) :map) join )) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join )) :map) join "]}," Sass Script Funcall initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Script CssParser string":{"type":"method","name":"string","children":[],"call":["tok value ","@lexer peek type == ","@lexer peek type ","@lexer peek "," number "," try_tok "," literal_node ","tok source_range "," try_tok  value "," try_ try_tok  "," try_tok  source_range "]}," Sass Script CssParser lexer_class":{"type":"method","name":"lexer_class","children":[],"call":[]}," Sass Script CssLexer important":{"type":"method","name":"important","children":[],"call":[" scan ","  scan can "]}," Sass Script CssLexer string":{"type":"method","name":"string","children":[],"call":["Script String  new ","(or\n  (send\n    (ivar :@scanner) :[]\n    (int 1))\n  (send\n    (ivar :@scanner) :[]\n    (int 2))) gsub ","@scanner [] "," scan ","re == ","Script Value String  new ","Sass Script Value String  value ","Sass Script Value String  Script Value String  new  "]}," Sass Script CssLexer token":{"type":"method","name":"token","children":[],"call":[" important "]}," Script Color rgb_to_hsl!":{"type":"method","name":"rgb_to_hsl!","children":[],"call":["@attrs []= ","l * ","s * ","h % ","d / ","2 - ","2 * ","l < ","max == ","(send\n  (lvar :max) :+\n  (lvar :min)) / ","max + ","60 * / + ","60 * / ","60 * ","r - ","b - ","g - ","max - ","(lvar :r) min ","(lvar :r) max ","@attrs [] / ","@attrs [] ","(sym :red) map ","(send\n  (lvar :max) :+\n  (lvar :min)) /  * ","max -  / ","(send\n  (lvar :max) :+\n  (lvar :min)) /  < ","(lvar :r) max  == ","(send\n  ((send\n  (lvar :max) :+\n  (lvar :min)) / var :max) :+\n  ((send\n  (lvar :max) :+\n  (lvar :min)) / var :min)) / ","(senmax - \n  (lvar :max) :+\n  (lvar :min)) / ","(send\n  (lvar :max) :+\n  (lvar :(lvar :r) min )) / ","(send\n  (lvar :(lvar :r) max ) :+\n  (lvar :min)) / ","(lvar :r) max  + ","(lvar :r) max  - ","((send\n  (lvar :max) :+\n  (lvar :min)) / var :r) min ","(lvar :r) (lvar :r) min  ","((send\n  (lvar :max) :+\n  (lvar :min)) / var :r) max ","(lvar :r) (lvar :r) max  ","(sym :remax - ) map "]}," Script Color hue_to_rgb":{"type":"method","name":"hue_to_rgb","children":[],"call":["m1 + ","(send\n  (lvar :m2) :-\n  (lvar :m1)) * * ","(send\n  (lvar :m2) :-\n  (lvar :m1)) * ","2.0 / - ","2.0 / ","m2 - ","h * < ","h * ","h > ","h < "]}," Script Color hsl_to_rgb!":{"type":"method","name":"hsl_to_rgb!","children":[],"call":["(send\n  (lvar :c) :*\n  (int 255)) round ","c * ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :m2)\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map "," hue_to_rgb ","h - ","1.0 / ","h + ","@attrs []= ","l * - ","l * ","l + - ","l + ","s + ","l <= ","@attrs [] / ","@attrs [] ","(send\n  (@attrs [] / var :c) :*\n  (int 255)) round ","(@attrs [] / end\n  (lvar :c) :*\n  (int 255)) round ","(send nil :hue_to_rgb\n  (lvar :l * - )\n  (lvar :m2)\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :l + - )\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :l * )\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send ni@attrs [] /  :hue_to_rgb\n  (@attrs [] / var :m1)\n  (@attrs [] / var :m2)\n  (send\n    (@attrs [] / var :h) :+\n    (send\n      (f@attrs [] / oat 1.0) :/\n      (int 3)))) map ","(@attrs [] / end nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :m2)\n  (@attrs [] / end\n    (lvar :h) :+\n    (@attrs [] / end\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :@attrs [] / ue_to_rgb\n  (lvar :m1)\n  (lvar :m2)\n  (send\n    (lvar :@attrs [] / ) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map "," @attrs [] / ue_to_rgb ","@attrs [] /  - ","@attrs [] /  + ","@attr@attrs [] /  []= ","@attrs [] /  * - ","@attrs [] /  * ","@attrs [] /  + - ","@attrs [] /  <= ","@attr@attrs [] /  [] / ","@attr@attrs [] /  [] "]}," Script Color piecewise":{"type":"method","name":"piecewise","children":[],"call":[" with ","result [] "," raise ","Sass SyntaxError  new ","other alpha != "," alpha ","other alpha ","other_num ! ","result []= ","(send\n  (array\n    (lvar :res)\n    (int 255)) :min) max ","(lvar :res) min "," rgb [] send ","other rgb [] ","other rgb ","other value "," rgb [] "," rgb ","other unitless? ! ","other unitless? ","other is_a? "," rgb [] send ult [] ","other is_a?  ! "," rgb [] send ult []= ","(send\n  (array\n    (lvar : rgb [] send )\n    (int 255)) :min) max ","(lvar : rgb [] send ) min "]}," Script Color hex_str":{"type":"method","name":"hex_str","children":[],"call":["num to_s rjust ","num to_s "," rgb map "," rgb "]}," Script Color rgba_str":{"type":"method","name":"rgba_str","children":[],"call":["Number  round "," alpha "," rgb join "," rgb "," options [] == "," options [] "," options "," alpha to_i "," alpha % == "," alpha % "]}," Script Color smallest":{"type":"method","name":"smallest","children":[],"call":["color size <= ","small_hex_str size ","color size ","HTML4_COLORS_REVERSE  [] "," rgb "," hex_str gsub "," hex_str ","COLOR_NAMES_REVERSE  [] ","small_explicit_str size "," rgba "," rgba_str "," alpha? ","HTML4_COLORS_REVERSE  []  size <= ","COLOR_NAMES_REVERSE  []  size <= "," hex_str gsub  size ","HTML4_COLORS_REVERSE  []  size ","COLOR_NAMES_REVERSE  []  size "," rgba_str  size "]}," Script Color inspect":{"type":"method","name":"inspect","children":[],"call":[" hex_str "," rgba_str "," alpha? "]}," Script Color to_s":{"type":"method","name":"to_s","children":[],"call":[" hex_str ","HTML4_COLORS_REVERSE  [] "," rgb "," smallest "," options [] == "," options [] "," options "," rgba_str "," alpha? ","COLOR_NAMES_REVERSE  [] "," rgba "]}," Script Color mod":{"type":"method","name":"mod","children":[],"call":[" raise ","NoMethodError  new "," piecewise ","other is_a? "]}," Script Color div":{"type":"method","name":"div","children":[],"call":[" piecewise ","other is_a? "]}," Script Color times":{"type":"method","name":"times","children":[],"call":[" raise ","NoMethodError  new "," piecewise ","other is_a? "]}," Script Color minus":{"type":"method","name":"minus","children":[],"call":[" piecewise ","other is_a? "]}," Script Color plus":{"type":"method","name":"plus","children":[],"call":[" piecewise ","other is_a? "]}," Script Color with":{"type":"method","name":"with","children":[],"call":["Color  new "," alpha ","attrs [] ","@attrs merge "," send ","(sym :red) each ","(sym :hue) each "," raise ","ArgumentError  new ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ! ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ","(sym :red) & ","attrs keys ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ! ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ","(sym :hue) & ","v nil? ","attrs reject ","@attrs merge  [] ","@@attrs merge  merge ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ! ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ","@attrs merge  keys ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ! ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ","@attrs merge  reject "]}," Script Color eq":{"type":"method","name":"eq","children":[],"call":["Sass Script Bool  new "," alpha == ","other alpha "," alpha "," rgb == ","other rgb "," rgb ","other is_a? "]}," Script Color hsl":{"type":"method","name":"hsl","children":[],"call":["(send nil :hue) freeze "," lightness "," saturation "," hue "]}," Script Color rgb":{"type":"method","name":"rgb","children":[],"call":["(send nil :red) freeze "," blue "," green "," red "]}," Script Color alpha?":{"type":"method","name":"alpha?","children":[],"call":[" alpha < "," alpha "]}," Script Color alpha":{"type":"method","name":"alpha","children":[],"call":["@attrs [] ","@attrs [] to_f "]}," Script Color lightness":{"type":"method","name":"lightness","children":[],"call":["@attrs [] "," rgb_to_hsl! "]}," Script Color saturation":{"type":"method","name":"saturation","children":[],"call":["@attrs [] "," rgb_to_hsl! "]}," Script Color hue":{"type":"method","name":"hue","children":[],"call":["@attrs [] "," rgb_to_hsl! "]}," Script Color blue":{"type":"method","name":"blue","children":[],"call":["@attrs [] "," hsl_to_rgb! "]}," Script Color green":{"type":"method","name":"green","children":[],"call":["@attrs [] "," hsl_to_rgb! "]}," Script Color red":{"type":"method","name":"red","children":[],"call":["@attrs [] "," hsl_to_rgb! "]}," Script Color initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","ArgumentError  new ","(irange\n  (int 0)\n  (int 1)) include? ","@attrs [] ","k to_s capitalize ","k to_s ","(irange\n  (int 0)\n  (int 100)) include? ","@attrs []= ","@attrs [] - > ","@attrs [] - ","@attrs [] - < ","@attrs [] > ","@attrs [] < ","@attrs [] nil? ","(sym :saturation) each ","(irange\n  (int 0)\n  (int 255)) include? ","@attrs [] to_i ","(sym :red) each ","rgb size != ","rgb size ","rgb empty? ! ","rgb empty? ","hsl size != ","hsl size ","hsl empty? ! ","hsl empty? ","allow_both_rgb_and_hsl ! ","(sym :red) & ","attrs keys ","(sym :hue) & ","v nil? ","attrs reject ","attrs [] to_f ","attrs [] ","c to_i ","attrs [] map ","(irange\n  (int 3)\n  (int 4)) include? ","attrs size ","attrs is_a? ","Sass SyntaxError  new ","Sass Util  check_range ","Number  new ","(sym :red) &  size != ","(sym :red) &  size ","(sym :red) &  empty? ! ","(sym :red) &  empty? ","(sym :hue) &  size != ","(sym :hue) &  size ","(sym :hue) &  empty? ! ","(sym :hue) &  empty? ","allow_both_(sym :red) & _and_hsl ! ","allow_both_rgb_and_(sym :hue) &  ! "]}," Script Bool to_s":{"type":"method","name":"to_s","children":[],"call":["@value to_s "]}," Sass Repl parse_input":{"type":"method","name":"parse_input","children":[],"call":[" puts ","e backtrace each ","e backtrace ","@options [] ","e message "," p ","Script Parser  parse perform ","Script Parser  parse ","environment var ","environment set_var ","val perform ","text size - ","3 size ","text size ","3 == ","text size - - ","2 size ","(or\n  (nth-ref 3)\n  (str \"\")) size ","3 ! ! ","3 ! ","Script Parser  parse  perform "]}," Sass Repl run":{"type":"method","name":"run","children":[],"call":[" parse_input ","Readline HISTORY  << "," puts ","Readline  readline "," loop ","environment set_var ","Script String  new ","Environment  new ","Environment  new  set_var "]}," Sass Repl initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Plugin options":{"type":"method","name":"options","children":[],"call":[" compiler options "," compiler "]}," Sass Plugin respond_to?":{"type":"method","name":"respond_to?","children":[],"call":[" compiler respond_to? "," compiler "]}," Sass Plugin method_missing":{"type":"method","name":"method_missing","children":[],"call":[" compiler send "," compiler "," compiler respond_to? "]}," Sass Plugin force_update_stylesheets":{"type":"method","name":"force_update_stylesheets","children":[],"call":[" options= "," update_stylesheets "," options []= "," options "," options dup ","Compiler  new update_stylesheets ","Compiler  new "," options dup merge "]}," Sass Plugin update_stylesheets":{"type":"method","name":"update_stylesheets","children":[],"call":[" compiler update_stylesheets "," compiler "," options [] "," options "]}," Sass Plugin compiler":{"type":"method","name":"compiler","children":[],"call":["Compiler  new "]}," Sass Plugin check_for_updates":{"type":"method","name":"check_for_updates","children":[],"call":[" update_stylesheets ","Sass Plugin  options [] ","Sass Plugin  options ","Sass Plugin  checked_for_updates ! ","Sass Plugin  checked_for_updates "]}," Sass Plugin StalenessChecker tree":{"type":"method","name":"tree","children":[],"call":["importer find to_tree ","importer find ","@parse_trees [] "]}," Sass Plugin StalenessChecker compute_dependencies":{"type":"method","name":"compute_dependencies","children":[],"call":["(send\n  (send nil :tree\n    (lvar :uri)\n    (lvar :importer)) :grep\n  (const\n    (const nil :Tree) :ImportNode)) compact ","@parse_trees []= ","file to_tree ","file options [] ","file options ","n imported_file ","n css_import? "," tree grep "," tree ","n imported_file  to_tree ","n imported_file  options [] ","n imported_file  options ","n imported_n imported_file  "]}," Sass Plugin StalenessChecker dependency_updated?":{"type":"method","name":"dependency_updated?","children":[],"call":[" dependencies_stale? ","sass_mtime > ","sass_mtime ! "," mtime ","Proc  new "," mtime > "," lambda ","@actively_checking delete ","@actively_checking << ","@actively_checking include? "," proc "," mtime  > "," mtime  ! "]}," Sass Plugin StalenessChecker dependencies":{"type":"method","name":"dependencies","children":[],"call":["@dependencies []= "," mtime "," compute_dependencies ","stored_mtime < ","stored_mtime ! ","@dependencies [] ","Sass Util  destructure ","cache []= "," with_dependency_cache ","cache [] ","@ compute_dependencies  []= "," compute_ compute_dependencies  ","@ compute_dependencies  [] "]}," Sass Plugin StalenessChecker mtime":{"type":"method","name":"mtime","children":[],"call":["@dependencies delete ","mtime nil? ","importer mtime ","@mtimes [] ","mtime to_i ","cache delete "," with_dependency_cache ","importer mtime  nil? ","importer importer mtime  ","@importer mtime s [] ","importer mtime  to_i "]}," Sass Plugin StalenessChecker dependencies_stale?":{"type":"method","name":"dependencies_stale?","children":[],"call":["timestamps []= "," dependencies any? "," dependency_updated? "," dependencies ","checked_css_mtime > ","is_stale ! ","checked_css_mtime <= ","timestamps each_pair ","@dependencies_stale [] "]}," Sass Plugin StalenessChecker stylesheet_modified_since?":{"type":"method","name":"stylesheet_modified_since?","children":[],"call":[" dependency_updated? call "," dependency_updated? ","@options [] new ","@options [] "]}," Sass Plugin StalenessChecker stylesheet_needs_update?":{"type":"method","name":"stylesheet_needs_update?","children":[],"call":[" stylesheet_modified_since? ","File  mtime ","File  expand_path "," dependency_updated? call ","@options [] new ","@options [] "," dependency_updated? ","File  mtime to_i "]}," Sass Plugin StalenessChecker initialize":{"type":"method","name":"initialize","children":[],"call":["Sass Engine  normalize_options "," class dependencies_cache "," class ","Set  new "]}," ActionController Base process":{"type":"method","name":"process","children":[],"call":[" sass_old_process ","Sass Plugin  check_for_updates "]}," Configuration default_options":{"type":"method","name":"default_options","children":[],"call":["opts freeze ","opts merge! ","Sass Util  rails_env == ","Sass Util  rails_env ","Sass Util  rails_root + ","Sass Util  rails_root ","Sass Util  rails_env != ","(pair\n  (sym :always_update)\n  (false)) freeze ","env != ","root + ","Merb  environment ","Merb  root to_s ","Merb  root ","version [] < ","version [] ","version [] <= ","n to_i ","Merb VERSION  split map ","Merb VERSION  split ","Sass CacheStores ActiveSupport  new ","Rails  cache ","Sass Importers Rails  new "," require ","Sass Util  ap_geq? ","Sass Util  rails_Merb  environment  == ","Sass Util  rails_Merb  environment  ","Sass Util  rails_Merb  root to_s  + ","Sass Util  rails_Merb  root to_s  ","Sass Util  rails_Merb  environment  != ","Merb  environment  != ","Merb  root to_s  + ","Merb  Merb  environment ironment ","Merb  Merb  root to_s  to_s ","Merb  Merb  root to_s  "]}," Sass Plugin Rack call":{"type":"method","name":"call","children":[],"call":["@app call ","Time  now to_f + ","Time  now to_f ","Time  now ","Sass Plugin  check_for_updates ","Time  now to_f > ","@dwell nil? "]}," Sass Plugin Rack initialize":{"type":"method","name":"initialize","children":[],"call":["Time  now to_f ","Time  now "]}," MerbBootLoader run":{"type":"method","name":"run","children":[],"call":[]}," Sass Plugin Configuration normalize_template_location!":{"type":"method","name":"normalize_template_location!","children":[],"call":[" options []= "," options [] to_a "," options [] "," options ","File  join "," options [] is_a? "," convert_template_location "]}," Sass Plugin Configuration template_location_array":{"type":"method","name":"template_location_array","children":[],"call":[" options []= "," options "," options [] "," normalize_template_location! "," convert_template_location "]}," Sass Plugin Configuration remove_template_location":{"type":"method","name":"remove_template_location","children":[],"call":[" template_location_array delete "," template_location_array "," normalize_template_location! "]}," Sass Plugin Configuration add_template_location":{"type":"method","name":"add_template_location","children":[],"call":[" template_location_array << "," template_location_array "," normalize_template_location! "]}," Sass Plugin Configuration options=":{"type":"method","name":"options=","children":[],"call":[" options merge! "," options ","Sass Util  sass_warn ","Setting Sass::Plugin.options is deprecated  + "]}," Sass Plugin Configuration options":{"type":"method","name":"options","children":[],"call":["Sass CacheStores Filesystem  new ","@options [] "," default_options dup "," default_options ","Sass FileCacheStore  new "]}," Sass Plugin Configuration reset!":{"type":"method","name":"reset!","children":[],"call":[" clear_callbacks! "]}," Sass Plugin Configuration default_options":{"type":"method","name":"default_options","children":[],"call":["(pair\n  (sym :css_location)\n  (str \"./public/stylesheets\")) freeze "]}," Plugin Compiler css_filename":{"type":"method","name":"css_filename","children":[],"call":["(begin\n  (lvar :path)) gsub ","path end_with? "]}," Plugin Compiler css_locations":{"type":"method","name":"css_locations","children":[],"call":["l last "," template_location_array to_a map "," template_location_array to_a "," template_location_array "]}," Plugin Compiler template_locations":{"type":"method","name":"template_locations","children":[],"call":["l first "," template_location_array to_a map "," template_location_array to_a "," template_location_array "]}," Plugin Compiler load_paths":{"type":"method","name":"load_paths","children":[],"call":["(or\n  (send\n    (lvar :opts) :[]\n    (sym :load_paths))\n  (array)) + "," template_locations ","opts [] "]}," Plugin Compiler try_delete_css":{"type":"method","name":"try_delete_css","children":[],"call":["File  delete "," run_deleting_css ","File  exists? "," run_deleting_sourcemap ","Sass Util  sourcemap_name ","File  exist? "," run_deleting_sourceSass Util  sourcemap_name  ","Sass Util  sourceSass Util  sourcemap_name _name "]}," Plugin Compiler update_stylesheet":{"type":"method","name":"update_stylesheet","children":[],"call":["file print ","file set_encoding ","result encoding ","Sass Util  ruby1_8? ","File  open "," options [] "," options ","Sass Util  windows? "," run_updating_stylesheet ","Sass SyntaxError  exception_to_css "," run_compilation_error ","Sass Engine  for_file render ","Sass Engine  for_file "," engine_options ","File  read ","File  readable? ","FileUtils  mkdir_p "," run_creating_directory ","File  exists? ","File  dirname "," run_updated_stylesheet "," write_file ","mapping to_json ","engine render ","engine render_with_sourcemap ","File  basename ","File  exist? "," run_compilation_starting "," raise ","Sass SyntaxError  exception_to_css  encoding ","Sass Engine  for_file render  encoding "," Sass Engine  for_file _options ","FileUtils  mkFile  dirname _p "," run_creating_File  dirname ectory ","File  File  dirname name ","Sass Engine  for_file  render ","Sass Engine  for_file  render_with_sourcemap "]}," Plugin Compiler stylesheet_needs_update?":{"type":"method","name":"stylesheet_needs_update?","children":[],"call":["StalenessChecker  stylesheet_needs_update? "]}," Plugin Compiler engine_options":{"type":"method","name":"engine_options","children":[],"call":["opts []= "," load_paths "," options merge "," options "," options []= "," options [] == "," options [] "," options merge  []= "]}," Plugin Compiler watch":{"type":"method","name":"watch","children":[],"call":[" update_stylesheets "," try_delete_css "," run_template_deleted ","path delete "," run_template_created ","path create "," run_template_modified ","path update ","mon file ","individual_files each ","File  join ","relative gsub ","path glob ","mon path "," template_location_array each "," template_location_array ","FSSM  monitor ","FSSM Backends  const_set ","Sass Util  silence_warnings "," require ","FSSM Backends Default  name == ","FSSM Backends Default  name ","individual_files empty? ","$LOAD_PATH unshift "," raise ","e message << << ","File  exists? "," scope ","e message << ","e message ","$LOAD_PATH include? ","Sass Util  scope ","l file "," lambda ","l directory ","relative !~ ","Sass Plugin Listener  new ","e is_a? ","listener start ","listener force_polling ","Sass Util  windows? ","f gsub ","f =~ ","files [] ","files first == ","files first ","individual_files_hash [] ","File  dirname ","removed each ","added each ","modified each ","Listen MultiListener  new ","template_paths + + ","template_paths + ","individual_files_hash keys ","(or-asgn\n  (send\n    (lvar :h) :[]\n    (lvar :parent))\n  (array)) << ","h [] ","template_paths include? ","individual_files inject "," template_locations ","@options [] "," load_listen! "," listen_to ","Sass Util  listen_geq_2? ! ","Sass Util  listen_geq_2? ","individual_files select "," relative_to_pwd "," css_filename ","f [] ","sass_dir size + ","sass_dir size "," child_of_directory? ","File  expand_path "," watched_file? ","File  expand_path == ","individual_files find ","removed uniq each ","removed uniq ","added uniq each ","added uniq ","modified uniq each ","modified uniq "," create_listener ","listener_args last []= ","listener_args last ","directories + "," remove_redundant_directories ","directories << "," watched_paths ","listener start! "," on_file_changed ","File  writable? ","directories reject ","File  directory? ","directories select "," block_given? ","directories + + "," Array ","options [] ","individual_files is_a? ","@watched_files << ","Sass Util  realpath to_s ","Sass Util  realpath ","@inferred_directories << "," sleep "," try_delete_File  join  ","individual_individual_files_hash []  each ","individual_individual_files_hash []  empty? ","l Sass Util  scope ectory ","individual_files_hash []  [] ","individual_files_hash []  first == ","individual_files_hash []  first ","individual_individual_files_hash [] _hash [] ","File  Sass Util  scope name "," template_locations  + + "," template_locations  + ","individual_individual_files_hash [] _hash keys ","(or-asgn\n  (send\n    (lvar :h) :[]\n    (lvar :File  dirname ))\n  (array)) << "," template_locations  include? ","individual_individual_files_hash []  inject ","individual_individual_files_hash []  select "," File  join _filename ","sass_Sass Util  scope  size + ","File  expand_path  size + ","sass_Sass Util  scope  size ","File  expand_path  size "," child_of_Sass Util  scope ectory? ","individual_individual_files_hash []  find ","directories +  last []= ","directories + +  last []= ","directories +  last ","directories + +  last ","Sass Util  scope ectories + ","template_paths + +  + "," remove_redundant_directories  + "," watched_paths  + "," remove_redundant_Sass Util  scope ectories "," remove_redundant_template_paths + +  "," remove_redundant_ remove_redundant_directories  "," remove_redundant_ watched_paths  ","Sass Util  scope ectories << ","template_paths + +  << "," remove_redundant_directories  << "," watched_paths  << ","Sass Util  scope ectories reject ","template_paths + +  reject "," remove_redundant_directories  reject "," watched_paths  reject ","File  Sass Util  scope ectory? ","Sass Util  scope ectories select ","template_paths + +  select "," remove_redundant_directories  select "," watched_paths  select ","Sass Util  scope ectories + + ","template_paths + +  + + "," remove_redundant_directories  + + "," watched_paths  + + ","individual_individual_files_hash []  is_a? ","@watched_individual_files_hash []  << ","@inferred_Sass Util  scope ectories << ","@inferred_template_paths + +  << ","@inferred_ remove_redundant_directories  << ","@inferred_ watched_paths  << "]}," Plugin Compiler update_stylesheets":{"type":"method","name":"update_stylesheets","children":[],"call":[" run_not_updating_stylesheet "," update_stylesheet ","staleness_checker stylesheet_needs_update? "," options [] "," options "," css_filename ","file sub ","template_location to_s sub ","template_location to_s ","Dir  glob sort each ","Dir  glob sort ","Dir  glob ","File  join "," template_location_array each "," template_location_array ","individual_files each ","StalenessChecker  new "," engine_options ","Sass Plugin  checked_for_updates= "," run_updating_stylesheets ","template_location sub ","individual_files << ","Sass Util  glob sort each ","Sass Util  glob sort ","Sass Util  glob ","individual_files dup ","Sass Util  sourcemap_name "," engine_options [] ","Util  sourcemap_name "," run_updated_stylesheets ","updated_stylesheets << ","files each "," file_list "," engine_options [] != ","StalenessChecker  new  stylesheet_needs_update? ","  css_filename _filename "," css_filefile sub  ","individual_files dup  each ","individual_ file_list  each ","individual_files dup  << ","individual_ file_list  << ","individual_files dup  dup ","individual_ file_list  dup ","Sass Util  sourcemap_file sub  ","Sass Util  Sass Util  sourcemap_name _name ","Sass Util  Util  sourcemap_name _name ","Util  sourcemap_file sub  ","Util  Sass Util  sourcemap_name _name ","Util  Util  sourcemap_name _name "," file_list  each "]}," Plugin Compiler initialize":{"type":"method","name":"initialize","children":[],"call":[" options merge! "," options ","Set  new "]}," Less Engine parse_with_sass":{"type":"method","name":"parse_with_sass","children":[],"call":[" raise ","e modify_backtrace "," parse_without_sass "]}," Less Engine initialize_with_sass":{"type":"method","name":"initialize_with_sass","children":[],"call":["obj path ","obj is_a? "," initialize_without_sass "]}," Less Node FontFamily to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script Operation  new ","(send\n  (ivar :@family) :map) inject ","f to_sass_tree ","@family map "]}," Less Node Quoted to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script String  new "]}," Less Node Anonymous to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script String  new "]}," Less Node Keyword to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script String  new "]}," Less Node Function to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script Funcall  new ","a to_sass_tree ","@args map "]}," Less Node Variable to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script Variable  new ","node line= "," src_line ","Sass Tree VariableNode  new ","@value to_sass_tree "," hide_in_sass ","Sass Tree VariableNode  new  line= "]}," Less Node Number to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script Number  new "," unit "]}," Less Node Color to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script Color  new "," a "," b "," g "," r "]}," Less Node Expression _sass_split":{"type":"method","name":"_sass_split","children":[],"call":["arr [] ","i + "," _to_sass_tree ","parens == ","e == ","arr [] each_with_index ","arr [] to_sass_tree ","arr [] == "]}," Less Node Expression _to_sass_tree_unary":{"type":"method","name":"_to_sass_tree_unary","children":[],"call":[" _sass_split ","arr [] ","Sass Script UnaryOperation  new ","arr [] == "]}," Less Node Expression _to_sass_tree_times_div":{"type":"method","name":"_to_sass_tree_times_div","children":[],"call":["Sass Script Operation  new "," _to_sass_tree_unary ","rest [] ","LESS_TO_SASS_OPERATORS  [] ","(str \"*\") include? ","rest [] is_a? ","Sass Script OpSass Script Operation  new ration  nSass Script Operation  new w "," _to_sass_trSass Script Operation  new Sass Script Operation  new _unary ","rSass Script Operation  new st [] ","(str \"*\") includSass Script Operation  new ? ","rSass Script Operation  new st [] is_a? "]}," Less Node Expression _to_sass_tree_plus_minus_eq":{"type":"method","name":"_to_sass_tree_plus_minus_eq","children":[],"call":["Sass Script Operation  new "," _to_sass_tree_times_div ","rest [] ","LESS_TO_SASS_OPERATORS  [] ","(str \"+\") include? ","rest [] is_a? ","Sass Script OpSass Script Operation  new ration  nSass Script Operation  new w "," _to_sass_trSass Script Operation  new Sass Script Operation  new _timSass Script Operation  new s_div ","rSass Script Operation  new st [] ","(str \"+\") includSass Script Operation  new ? ","rSass Script Operation  new st [] is_a? "]}," Less Node Expression _to_sass_tree":{"type":"method","name":"_to_sass_tree","children":[],"call":["Sass Script Operation  new "," _to_sass_tree_plus_minus_eq ","rest empty? "," _to_sass_tree2 "," _sass_split ","Sass Script UnaryOperation  new "," _to_sass_tree ","arr [] ","arr [] == ","Sass Script OpSass Script Operation  new ration  nSass Script Operation  new w "," _to_sass_trSass Script Operation  new Sass Script Operation  new _plus_minus_Sass Script Operation  new q ","rSass Script Operation  new st Sass Script Operation  new mpty? "," _to_sass_trSass Script Operation  new Sass Script Operation  new 2 ","Sass Script UnaryOpSass Script Operation  new ration  nSass Script Operation  new w "," _to_sass_trSass Script Operation  new Sass Script Operation  new  "]}," Less Node Expression to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["val options= "," _to_sass_tree ","Sass Script Operation  new ","(send nil :map) inject "," map "," first is_a? "," first "," _to_sass_tree  options= "]}," Less Node Property to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Tree PropNode  new ","@value to_sass_tree "," hide_in_sass "]}," Less Node SassNode to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":[" hide_in_sass "]}," Less Node SassNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Less Node Mixin Def to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["mixin << ","r to_sass_tree "," rules each "," rules ","Sass Tree MixinDefNode  new ","v value to_sass_tree ","v value ","Sass Script Variable  new ","v value flatten! ","@params map "," name "," hide_in_sass ","Sass Tree MixinDefNode  new  << "]}," Less Node Mixin Call to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Tree MixinNode  new ","v to_sass_tree ","@params map ","@mixin name gsub ","@mixin name "," hide_in_sass "]}," Less Node Element sass_selector_str":{"type":"method","name":"sass_selector_str","children":[],"call":["@selector + "]}," Less Node Element to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["rule << ","r to_sass_tree ","last_el rules each ","last_el rules ","Sass Tree RuleNode  new ","(send\n  (send nil :group) :map) join ","comma_sel gsub! "," parent root? "," parent ","comma_sel join gsub ","comma_sel join ","el rules first ","el rules ","el rules first is_a? ","el rules size == ","el rules size ","comma_sel << ","el sass_selector_str "," loop "," group map "," group "," equal? ! "," equal? "," group first "," hide_in_sass ","root << "," rules each "," rules ","Sass Tree RootNode  new "," root? ","Sass Tree RuleNode  new  << ","last_el Sass Tree RuleNode  new s each ","last_el rules first  rules each ","last_el Sass Tree RuleNode  new s ","last_el rules first  rules ","comma_(send\n  (send nil :group) :map) join  gsub! ","comma_sel join gsub  gsub! ","comma_sel rules first  gsub! "," parent Sass Tree RootNode  new ? ","comma_(send\n  (send nil :group) :map) join  join gsub ","comma_sel join gsub  join gsub ","comma_sel rules first  join gsub ","comma_(send\n  (send nil :group) :map) join  join ","comma_sel join gsub  join ","comma_sel rules first  join ","el Sass Tree RuleNode  new s first ","el rules first  rules first ","el Sass Tree RuleNode  new s ","el rules first  rules ","el Sass Tree RuleNode  new s first is_a? ","el rules first  rules first is_a? ","el Sass Tree RuleNode  new s size == ","el rules first  rules size == ","el Sass Tree RuleNode  new s size ","el rules first  rules size ","comma_(send\n  (send nil :group) :map) join  << ","comma_sel join gsub  << ","comma_sel rules first  << ","el sass_(send\n  (send nil :group) :map) join ector_str ","el rules first  sass_sel rules first ector_str ","Sass Tree RootNode  new  << "," Sass Tree RuleNode  new s each "," Sass Tree RuleNode  new s "," Sass Tree RootNode  new ? "]}," Less Node Element top":{"type":"method","name":"top","children":[],"call":[" parent top "," parent "," parent equal? "]}," Less StyleSheet Alpha1 build":{"type":"method","name":"build","children":[],"call":["Node Function  new ","Node Expression  new "," variable build "," variable ","Node Operator  new ","Node Keyword  new "]}," Less StyleSheet Import1 build_with_sass":{"type":"method","name":"build_with_sass","children":[],"call":[" raise ","Sass SyntaxError  new "," url text_value "," url ","r hide_in_sass= ","(send\n  (send\n    (lvar :env) :rules) :-\n  (lvar :old_rules)) each ","env rules - ","env rules "," build_without_sass ","env rules dup ","env << ","Node SassNode  new ","import line= "," input line_of "," interval first "," interval "," input ","Sass Tree ImportNode  new "," url value gsub "," url value ","(send\n  (send\n    (lvar :env) :rules) :-\n  (lvar :env rules dup )) each ","Sass Tree ImportNode  new  line= ","import  input line_of = "," input  input line_of _of "]}," Less StyleSheet Accessor1 build":{"type":"method","name":"build","children":[],"call":["Node Anonymous  new "," text_value ","Sass Util  sass_warn "]}," Less StyleSheet Selectors2 build_with_sass":{"type":"method","name":"build_with_sass","children":[],"call":["e group= ","rarr each ","e top ","arr map ","method == "," build_without_sass ","r build_without_sass  each "," build_without_sass  map "]}," Less StyleSheet Declaration3 build_with_sass":{"type":"method","name":"build_with_sass","children":[],"call":["env rules last src_line= "," input line_of "," interval first "," interval "," input ","env rules last ","env rules "," build_without_sass "]}," Less StyleSheet Mixin4 selector_str":{"type":"method","name":"selector_str","children":[],"call":["(send\n  (lvar :path) :map) join gsub ","(send\n  (lvar :path) :map) join ","e sass_selector_str ","path map "]}," Less StyleSheet Mixin4 selector_base":{"type":"method","name":"selector_base","children":[],"call":["(send\n  (const\n    (const nil :Node) :Element) :new\n  (send\n    (lvar :el) :name)\n  (lvar :sel)) + ","path [] ","i + ","Node Element  new ","el name ","el selector ","el selector =~ ","path first ","e selector !~ ","e selector ","Sass Util  enum_with_index to_a reverse find ","Sass Util  enum_with_index to_a reverse ","Sass Util  enum_with_index to_a ","Sass Util  enum_with_index "]}," Less StyleSheet Mixin4 build_with_sass":{"type":"method","name":"build_with_sass","children":[],"call":["env << ","Node SassNode  new ","Sass Tree ExtendNode  new ","Sass Tree CommentNode  new ","Sass Util  sass_warn ","base == "," selector_str "," selector_base ","Node Mixin Call  new ","el is_a? "," raise "," selectors text_value "," selectors ","current descend ","node selector ","path inject ","env root "," selectors build each "," selectors build "," selector_str  == ","  selector_str ector_str "," selector_ selector_str  ","  selector_str ector_base ","  selector_str ectors text_value ","  selector_str ectors ","node  selector_str ector ","  selector_str ectors build each ","  selector_str ectors build "]}," Sass Importers Filesystem join":{"type":"method","name":"join","children":[],"call":["Pathname  new join to_s ","Pathname  new join ","Pathname  new "]}," Sass Importers Filesystem _find":{"type":"method","name":"_find","children":[],"call":["Sass Engine  new ","File  read ","options []= ","File  readable? "," find_real_file ","Sass Util  destructure ","full_filename tr ","Sass Util  windows? ","File  file? ","full_filename tr  tr "]}," Sass Importers Filesystem eql?":{"type":"method","name":"eql?","children":[],"call":[" root eql? ","other root "," root ","other respond_to? ","other nil? ! ","other nil? "]}," Sass Importers Filesystem hash":{"type":"method","name":"hash","children":[],"call":["@root hash "]}," Sass Importers Filesystem split":{"type":"method","name":"split","children":[],"call":["basename =~ ","(send\n  (send\n    (send nil :extensions) :keys) :map) join ","Regexp  escape "," extensions keys map "," extensions keys "," extensions ","File  basename ","File  dirname "]}," Sass Importers Filesystem find_real_file":{"type":"method","name":"find_real_file","children":[],"call":["full_path gsub! ","Dir  [] first ","Dir  [] ","dir == "," possible_files "," remove_root ","File  exists? "," join "," possible_files each ","Pathname  new absolute? ","Pathname  new ","found first ","Sass Util  sass_warn ","File  basename ","File  dirname ","(send\n  (lvar :found) :map) join ","     + ","found map ","found first first ","options [] ","Pathname  new relative_path_from to_s ","Pathname  new relative_path_from ","@same_name_warnings << ","found each ","@same_name_warnings include? ! ","@same_name_warnings include? ","found size > ","found size ","found empty? ","Sass Util  flatten ","Dir  [] map "," possible_files map ","dir gsub ","File ALT_SEPARATOR  nil? "," escape_glob_characters ","Pathname  new cleanpath to_s ","Pathname  new cleanpath "," raise ","Sass SyntaxError  new ","   + ","Sass Util  pathname relative_path_from to_s ","Sass Util  pathname relative_path_from ","Sass Util  pathname ","Sass Util  pathname cleanpath to_s ","Sass Util  pathname cleanpath ","Sass Util  pathname absolute? ","Sass Util  cleanpath to_s ","Sass Util  cleanpath ","name gsub ","(send\n  (send nil :possible_files\n    (send nil :remove_root\n      (lvar :name))) :map) flatten "," find_real_file ","File  directory? "," split [] nil? "," split [] "," split ","Dir  [] first  gsub! "," join  gsub! ","dir gsub  == ","Pathname gsub   new absolute? ","Pathname gsub   new ","Sass Util  flatten  first ","(send\n  (send nil :possible_files\n    (send nil :remove_root\n      (lvar :name))) :map) flatten  first ","File  basename gsub  ","File  dir gsub name ","File  dirname gsub  ","(send\n  (lvar :Sass Util  flatten ) :map) join ","(send\n  (lvar :(send\n  (send nil :possible_files\n    (send nil :remove_root\n      (lvar :name))) :map) flatten ) :map) join ","Sass Util  flatten  map ","(send\n  (send nil :possible_files\n    (send nil :remove_root\n      (lvar :name))) :map) flatten  map ","Sass Util  flatten  first first ","(send\n  (send nil :possible_files\n    (send nil :remove_root\n      (lvar :name))) :map) flatten  first first ","Pathname gsub   new relative_path_from to_s ","Pathname gsub   new relative_path_from ","@same_name gsub _warnings << ","Sass Util  flatten  each ","(send\n  (send nil :possible_files\n    (send nil :remove_root\n      (lvar :name))) :map) flatten  each ","@same_name gsub _warnings include? ! ","@same_name gsub _warnings include? ","Sass Util  flatten  size > ","(send\n  (send nil :possible_files\n    (send nil :remove_root\n      (lvar :name))) :map) flatten  size > ","Sass Util  flatten  size ","(send\n  (send nil :possible_files\n    (send nil :remove_root\n      (lvar :name))) :map) flatten  size ","Sass Util  flatten  empty? ","(send\n  (send nil :possible_files\n    (send nil :remove_root\n      (lvar :name))) :map) flatten  empty? ","dir gsub  gsub ","Pathname gsub   new cleanpath to_s ","Pathname gsub   new cleanpath ","Sass Util  pathname gsub  relative_path_from to_s ","Sass Util  pathname gsub  relative_path_from ","Sass Util  pathname gsub  ","Sass Util  pathname gsub  cleanpath to_s ","Sass Util  pathname gsub  cleanpath ","Sass Util  pathname gsub  absolute? ","name gsub  gsub ","(send\n  (send nil :possible_files\n    (send nil :remove_root\n      (lvar :name gsub ))) :map) flatten ","File  dir gsub ectory? "]}," Sass Importers Filesystem possible_files":{"type":"method","name":"possible_files","children":[],"call":["sorted_exts map "," extensions invert [] "," extensions invert "," extensions "," extensions [] "," extensions sort "," split ","Sass Util  flatten ","(dstr\n  (begin\n    (lvar :dirname))\n  (str \"/\")\n  (begin\n    (lvar :basename))) map "," escape_glob_characters ","f sub ","ret map "," extensions sort  map ","(dstr\n  (begin\n    (lvar :dir escape_glob_characters ))\n  (str \"/\")\n  (begin\n    (lvar :base escape_glob_characters ))) map "]}," Sass Importers Filesystem extensions":{"type":"method","name":"extensions","children":[],"call":[]}," Sass Importers Filesystem remove_root":{"type":"method","name":"remove_root","children":[],"call":["name [] ","root length ","name index == ","name index ","@root + ","@root end_with? ","@root length ","name index != ","@root length + ","@root +  length ","@@root +  + ","@@root +  end_with? ","@@root +  length ","@@root +  length + "]}," Sass Importers Filesystem to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Sass Importers Filesystem key":{"type":"method","name":"key","children":[],"call":["File  basename "," class name + + ","File  dirname ","File  expand_path "," class name + "," class name "," class "]}," Sass Importers Filesystem mtime":{"type":"method","name":"mtime","children":[],"call":["File  mtime "," find_real_file ","Sass Util  destructure "," find_real_ find_real_file  "]}," Sass Importers Filesystem find":{"type":"method","name":"find","children":[],"call":[" _find "]}," Sass Importers Filesystem find_relative":{"type":"method","name":"find_relative","children":[],"call":[" _find ","File  dirname "]}," Sass Importers Filesystem initialize":{"type":"method","name":"initialize","children":[],"call":["File  expand_path ","Set  new ","Sass Util  realpath to_s ","Sass Util  realpath "]}," Sass Importers Base to_s":{"type":"method","name":"to_s","children":[],"call":["Sass Util  abstract "]}," Sass Importers Base key":{"type":"method","name":"key","children":[],"call":["Sass Util  abstract "]}," Sass Importers Base mtime":{"type":"method","name":"mtime","children":[],"call":["Sass Util  abstract "]}," Sass Importers Base find":{"type":"method","name":"find","children":[],"call":["Sass Util  abstract "]}," Sass Importers Base find_relative":{"type":"method","name":"find_relative","children":[],"call":["Sass Util  abstract "]}," Sass Exec SassConvert try_less_note":{"type":"method","name":"try_less_note","children":[],"call":[" warn "]}," Sass Exec SassConvert process_file":{"type":"method","name":"process_file","children":[],"call":[" handle_load_error "," raise ","e message ","e sass_line ","e sass_filename ","@options [] ","output write ","File  open ","input path ","(send\n  (lvar :input) :is_a?\n  (const nil :File)) to_tree send ","(send\n  (lvar :input) :is_a?\n  (const nil :File)) to_tree "," Sass Engine  new ","input read "," Sass Engine  for_file ","input is_a? ","Less Engine  new to_tree to_sass_tree send ","Less Engine  new to_tree to_sass_tree ","Less Engine  new to_tree ","Less Engine  new ","input is_a? ! "," try_less_note "," require ","@options [] == "," Sass CSS  new render "," Sass CSS  new "," Sass Util  silence_sass_warnings ","@options [] []= ","output path ","output is_a? ","@options []= "," write_output ","File  open  write ","input path  write ","input read  path ","(send\n  (lvar :input read ) :is_a?\n  (const nil :File)) to_tree send ","(send\n  (lvar :input read ) :is_a?\n  (const nil :File)) to_tree ","input read  read ","input read  is_a? ","input read  is_a? ! ","File  open  path ","input path  path ","File  open  is_a? ","input path  is_a? "," write_File  open  "," write_input path  "]}," Sass Exec SassConvert process_directory":{"type":"method","name":"process_directory","children":[],"call":[" process_file "," open_file ","@options [] "," puts_action ","File  exists? ","FileUtils  mkdir_p ","File  dirname ","File  directory? ","f gsub ","output_name []= ","@options [] size ","Dir  glob "," raise ","@options [] ! ","@options [] == ","File  directory? ! ","@options []= ","@args shift ","ext == ","from == ","Sass Util  glob "," Sass Util  glob ","File  exist? "," open_file _name []= ","@options []= _name []= ","f gsub  []= ","@options []  == "]}," Sass Exec SassConvert process_result":{"type":"method","name":"process_result","children":[],"call":[" process_file ","@options [] "," raise ","input path ","File  directory? "," process_directory "," require ","@options []  path "]}," Sass Exec SassConvert set_opts":{"type":"method","name":"set_opts","children":[],"call":["Encoding  default_external= ","opts on "," Sass Util  ruby1_8? ","@options [] []= ","@options [] ","@options []= "," raise ","(sym :scss) include? ","name downcase to_sym ","name downcase "," try_less_note ","@options [] == ","(sym :css) include? ","opts banner= ","  * ","indent to_i ","indent == "]}," Sass Exec SassConvert initialize":{"type":"method","name":"initialize","children":[],"call":["@options []= "," require "]}," Sass Exec Scss initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Exec Sass probably_dest_dir?":{"type":"method","name":"probably_dest_dir?","children":[],"call":["Dir  glob empty? ","Dir  glob ","File  join "," colon_path? ","Sass Util  glob empty? ","Sass Util  glob "," Sass Util  glob empty? "," Sass Util  glob "]}," Sass Exec Sass split_colon_path":{"type":"method","name":"split_colon_path","children":[],"call":["one + + ","one + ","two split ","two =~ ","one =~ "," Sass Util  windows? ","path split ","one + +  + + ","one + +  + ","one + +  =~ "]}," Sass Exec Sass colon_path?":{"type":"method","name":"colon_path?","children":[],"call":[" split_colon_path [] nil? ! "," split_colon_path [] nil? "," split_colon_path [] "," split_colon_path "]}," Sass Exec Sass watch_or_update":{"type":"method","name":"watch_or_update","children":[],"call":[" Sass Plugin  watch "," puts "," Sass Plugin  on_template_deleted "," Sass Plugin  on_template_created "," Sass Plugin  on_template_modified "," exit "," Sass Plugin  update_stylesheets ","@options [] "," puts_action ","error message ","error sass_line ","error sass_filename "," raise ","@options [] ! ","error is_a? "," Sass Plugin  on_compilation_error "," Sass Plugin  on_deleting_css "," Sass Plugin  on_creating_directory ","File  exists? "," Sass Plugin  on_updating_stylesheet "," Sass Plugin  options []= "," Sass Plugin  options ","dirs map! ","from gsub ","files map! ","File  directory? ","(send\n  (ivar :@args) :map) partition "," split_colon_path ","@args map ","@args [] ","@args [] =~ ","File  exist? ! ","File  exist? "," probably_dest_dir? "," colon_path? ! "," colon_path? ","@args empty? "," Sass Plugin  options merge! "," require "," Sass Plugin  on_updated_stylesheet ","STDOUT  flush "," Sass Plugin  on_deleting_sourcemap ","(lvar :css) each ","Util  sourcemap_name "," Sass Plugin  on_deleting_Util  sourcemap_name  ","Util  Util  sourcemap_name _name "]}," Sass Exec Sass interactive":{"type":"method","name":"interactive","children":[],"call":[" Sass Repl  new run "," Sass Repl  new "," require "]}," Sass Exec Sass load_compass":{"type":"method","name":"load_compass","children":[],"call":["Compass  configuration sass_load_paths ","Compass  configuration ","@options [] [] ","@options [] ","Dir  pwd ","Compass  configuration project_path ","Compass  add_project_configuration "," exit "," puts "," require "]}," Sass Exec Sass process_result":{"type":"method","name":"process_result","children":[],"call":[" raise ","e sass_backtrace_str ","@options [] ","output close ","output is_a? ","output write ","engine render ","input close ","input is_a? "," Sass Engine  new ","input read "," Sass Engine  for_file ","input path ","@options [] ! ","@options [] [] ","input path =~ ","@options [] []= "," watch_or_update "," interactive "," load_compass ","@options []= "," split_colon_path ","@args first ","@args size == ","@args size "," colon_path? "," require "," write_output ","@options [] is_a? ","@options [] path ","mapping to_json + ","mapping to_json ","engine render_with_sourcemap ","relative_sourcemap_path to_s "," Sass Util  pathname relative_path_from "," Sass Util  pathname dirname "," Sass Util  pathname ","sourcemap close ","sourcemap is_a? ","sourcemap puts ","Pathname  new relative_path_from ","Pathname  new dirname ","Pathname  new ","@options []  close ","@options []  is_a? ","@options []  write "," Sass Engine  new  render "," Sass Engine  for_file  render ","@options []  read ","@options []  path ","@options []  path =~ "," split_colon_path  first "," split_colon_path  size == "," split_colon_path  size "," write_@options []  "," Sass Engine  new  render_with_sourcemap "," Sass Engine  for_file  render_with_sourcemap ","engine render_with_@options []  "," Sass Util  pathname relative_path_from  to_s ","Pathname  new relative_path_from  to_s ","relative_@options [] _path to_s ","@options []  puts "]}," Sass Exec Sass set_opts":{"type":"method","name":"set_opts","children":[],"call":["Encoding  default_external= ","opts on "," Sass Util  ruby1_8? ","@options [] []= ","@options [] "," require ","@options [] [] << ","@options [] [] ","@options []= ","name to_sym ","StringIO  new ","@default_syntax == ","opts banner= "," default_syntax "," Sass Script Number  precision= "," exit ","$stderr puts "," Sass Script Value Number  precision= ","How many digits of precision to use when outputting decimal numbers. + "," Sass Script Value Number  precision "]}," Sass Exec Sass initialize":{"type":"method","name":"initialize","children":[],"call":["@options []= ","(str \".\") + ","(or\n  (send\n    (const nil :ENV) :[]\n    (str \"SASSPATH\"))\n  (str \"\")) split ","ENV  [] "," default_sass_path "]}," Sass Exec Generic handle_load_error":{"type":"method","name":"handle_load_error","children":[],"call":[" exit ","$stderr puts "," raise ","dep empty? ","dep nil? ","@options [] ","err message [] ","err message ","err message scan [] ","err message scan ","err message []  empty? ","err message scan []  empty? ","err message []  nil? ","err message scan []  nil? "]}," Sass Exec Generic open_file":{"type":"method","name":"open_file","children":[],"call":["File  open ","flag == ","@options [] ","filename nil? ","file close "," block_given? ","File  open name nil? ","File  open  close "]}," Sass Exec Generic color":{"type":"method","name":"color","children":[],"call":["COLORS  [] ","STDOUT  tty? ! ","STDOUT  tty? ","ENV  [] empty? ","ENV  [] ","ENV  [] nil? "," raise "]}," Sass Exec Generic puts":{"type":"method","name":"puts","children":[],"call":["Kernel  puts ","@options [] [] ","@options [] "]}," Sass Exec Generic puts_action":{"type":"method","name":"puts_action","children":[],"call":[" printf "," color ","@options [] [] ","@options [] ","STDOUT  flush "]}," Sass Exec Generic process_result":{"type":"method","name":"process_result","children":[],"call":["@options []= "," open_file ","args shift ","@args dup ","@options [] ","Util  sourcemap_name ","@args dup  shift ","@@args dup  dup "]}," Sass Exec Generic set_opts":{"type":"method","name":"set_opts","children":[],"call":[" exit "," puts "," Sass  version [] "," Sass  version ","opts on_tail ","@options []= "," Sass Util  windows? ","opts on "]}," Sass Exec Generic get_line":{"type":"method","name":"get_line","children":[],"call":["(or\n  (send\n    (send\n      (send\n        (send\n          (lvar :exception) :backtrace) :[]\n        (int 0)) :scan\n      (regexp\n        (str \":(\\\\d+)\")\n        (regopt))) :first)\n  (array\n    (str \"??\"))) first ","exception backtrace [] scan first ","exception backtrace [] scan ","exception backtrace [] ","exception backtrace ","(or\n  (send\n    (send\n      (send\n        (lvar :exception) :message) :scan\n      (regexp\n        (str \":(\\\\d+)\")\n        (regopt))) :first)\n  (array\n    (str \"??\"))) first ","exception message scan first ","exception message scan ","exception message ","exception is_a? "]}," Sass Exec Generic to_s":{"type":"method","name":"to_s","children":[],"call":["@opts to_s "]}," Sass Exec Generic parse":{"type":"method","name":"parse","children":[],"call":[" process_result ","@opts parse! ","OptionParser  new "," method ","OptionParser  new  parse! "]}," Sass Exec Generic parse!":{"type":"method","name":"parse!","children":[],"call":[" exit ","$stderr puts ","e message ","$stderr print ","e class ","e class == "," raise ","e is_a? ","@options [] "," parse "]}," Sass Exec Generic initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass SyntaxError header_string":{"type":"method","name":"header_string","children":[],"call":["e sass_backtrace_str + + ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (lvar :section)) :map) join ","line_offset + + ","line_offset + ","Sass Util  enum_with_index map ","Sass Util  enum_with_index ","e sass_backtrace_str + ","e sass_backtrace_str ","section empty? ","section nil? ","e sass_template rstrip split [] ","line_num + ","e sass_template rstrip split ","e sass_template rstrip ","e sass_template ","(send\n  (lvar :line_num) :-\n  (int 6)) max ","line_num - ","e sass_line + - ","e sass_line + ","e sass_line ","options [] ","e message ","e class ","e is_a? ","(send\n  (send\n    (lvar :section) :each_with_index) :map) join ","section each_with_index map ","section each_with_index ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (lvar :e sass_template rstrip split [] )) :map) join ","e sass_template rstrip split []  empty? ","e sass_template rstrip split []  nil? ","e sass_line + -  + ","(send\n  (lvar :e sass_line + - ) :-\n  (int 6)) max ","e sass_line + -  - ","(send\n  (send\n    (lvar :e sass_template rstrip split [] ) :each_with_index) :map) join ","e sass_template rstrip split []  each_with_index map ","e sass_template rstrip split []  each_with_index "]}," Sass SyntaxError exception_to_css":{"type":"method","name":"exception_to_css","children":[],"call":["header gsub gsub ","header gsub ","e backtrace join ","e backtrace "," header_string "," raise ","options [] ","e backtrace join gsub "," header_string  gsub gsub "," header_string  gsub ","  header_string _string "]}," Sass SyntaxError sass_backtrace_str":{"type":"method","name":"sass_backtrace_str","children":[],"call":["(str \"Syntax error: \") + ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send nil :sass_backtrace)) :map) join ","(str \"\\n        \") + + ","entry [] ","(str \"\\n        \") + ","i == ","Sass Util  enum_with_index map ","Sass Util  enum_with_index "," sass_backtrace ","lines [] + ","(send\n  (send\n    (lvar :lines) :[]\n    (irange\n      (int 1)\n      (int -1))) :map) join ","\n + + ","\n + ","  * ","Syntax error:  size ","lines [] map ","lines [] "," message split "," message ","(str \"Error: \") + ","Error:  size ","(send\n  (send\n    (send nil :sass_backtrace) :each_with_index) :map) join "," sass_backtrace each_with_index map "," sass_backtrace each_with_index "," message split  [] + ","(send\n  (send\n    (lvar : message split ) :[]\n    (irange\n      (int 1)\n      (int -1))) :map) join "," message split  [] map "," message split  [] "]}," Sass SyntaxError backtrace":{"type":"method","name":"backtrace","children":[],"call":["(send\n  (send nil :sass_backtrace) :map) + ","(begin\n  (or\n    (send\n      (lvar :h) :[]\n      (sym :filename))\n    (str \"(sass)\"))) + ","h [] "," sass_backtrace map "," sass_backtrace ","h empty? "," sass_backtrace all? "," nil? "]}," Sass SyntaxError to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Sass SyntaxError modify_backtrace":{"type":"method","name":"modify_backtrace","children":[],"call":["attrs empty? ","entry include? ","attrs reject! "," sass_backtrace []= ","attrs merge "," sass_backtrace "," sass_backtrace [] ","(erange\n  (int 0)\n  (send\n    (send nil :sass_backtrace) :size)) to_a reverse each ","(erange\n  (int 0)\n  (send\n    (send nil :sass_backtrace) :size)) to_a reverse ","(erange\n  (int 0)\n  (send\n    (send nil :sass_backtrace) :size)) to_a "," sass_backtrace size ","v nil? ","attrs reject ","(erange\n  (int 0)\n  (send\n    (send nil :sass_backtrace) :size)) to_a reverse_each "," sass_backtrace []  include? "]}," Sass SyntaxError add_backtrace":{"type":"method","name":"add_backtrace","children":[],"call":[" sass_backtrace << ","v nil? ","attrs reject "," sass_backtrace "]}," Sass SyntaxError sass_line":{"type":"method","name":"sass_line","children":[],"call":[" sass_backtrace first [] "," sass_backtrace first "," sass_backtrace "]}," Sass SyntaxError sass_mixin":{"type":"method","name":"sass_mixin","children":[],"call":[" sass_backtrace first [] "," sass_backtrace first "," sass_backtrace "]}," Sass SyntaxError sass_filename":{"type":"method","name":"sass_filename","children":[],"call":[" sass_backtrace first [] "," sass_backtrace first "," sass_backtrace "]}," Sass SyntaxError initialize":{"type":"method","name":"initialize","children":[],"call":[" add_backtrace "]}," Sass Environment inherited_hash":{"type":"method","name":"inherited_hash","children":[],"call":[" class_eval ","109 + ","102 + ","120 + ","134 + ","55 + ","64 + ","135 + ","65 + ","59 + ","67 + ","83 + ","85 + "]}," Sass Environment parent_options":{"type":"method","name":"parent_options","children":[],"call":["@parent options "]}," Sass Environment mixins_in_use":{"type":"method","name":"mixins_in_use","children":[],"call":["@parent mixins_in_use "]}," Sass Environment stack":{"type":"method","name":"stack","children":[],"call":["@parent stack "," global_env stack "," global_env "]}," Sass Environment pop_frame":{"type":"method","name":"pop_frame","children":[],"call":[" mixins_in_use delete ","popped [] "," mixins_in_use "," stack pop "," stack "," stack last [] "," stack last "," pop_and_unuse "," stack pop  [] "]}," Sass Environment prepare_frame":{"type":"method","name":"prepare_frame","children":[],"call":[" push_frame ","frame_info merge "]}," Sass Environment push_frame":{"type":"method","name":"push_frame","children":[],"call":[" mixins_in_use << ","top_of_stack [] "," mixins_in_use ","top_of_stack [] ! "," stack push "," stack ","top_of_stack merge! ","top_of_stack delete "," stack last "," stack last [] "," stack last [] ! "," stack last merge! "," stack last delete "," files_in_use << "," files_in_use "," stack last  [] "," stack last  [] ! "," stack last  merge! "," stack last  delete "]}," Sass Environment options":{"type":"method","name":"options","children":[],"call":[" parent_options "," parent options "," parent "]}," Sass Environment initialize":{"type":"method","name":"initialize","children":[],"call":[" set_var ","Script String  new ","Set  new ","parent options ","Sass Stack  new ","@parent nil? "]}," Sass Engine parse_interp":{"type":"method","name":"parse_interp","children":[],"call":[" class parse_interp "," class "]}," Sass Engine format_comment_text":{"type":"method","name":"format_comment_text","children":[],"call":["/* + + ","/* + ","content join gsub ","content join ","// + ","content first gsub! ","content first ","(if\n  (send\n    (lvar :l) :empty?)\n  (str \"\")\n  (str \" \")) + ","l empty? ","l gsub! ","content map! ","content last gsub! ","content last ","content empty? ","content shift ","content first strip empty? ","content first strip ","text split ","content unshift ","text split  join gsub ","text split  join ","text split  first gsub! ","content content shift  gsub! ","text split  first ","content content shift  ","text split  map! ","text split  last gsub! ","text split  last ","text split  empty? ","text split  shift ","text split  first strip empty? ","content content shift  strip empty? ","text split  first strip ","content content shift  strip ","text split  unshift "]}," Sass Engine parse_script":{"type":"method","name":"parse_script","children":[],"call":["Script  parse ","options [] ","@offset + ","@options merge ","options delete "]}," Sass Engine parse_function":{"type":"method","name":"parse_function","children":[],"call":["Tree FunctionNode  new ","Script Parser  new parse_function_definition_arglist ","Script Parser  new ","arg_string strip ","line offset + - ","arg_string size ","line offset + ","line text size ","line text ","line offset "," raise ","SyntaxError  new ","name nil? ","line text scan first ","line text scan "," to_parser_offset ","line line offset + -  + - ","line line offset + -  + ","line line offset + -  "," to_parser_line offset + -  "]}," Sass Engine parse_mixin_include":{"type":"method","name":"parse_mixin_include","children":[],"call":["Tree MixinNode  new "," raise ","SyntaxError  new ","@line + ","line children empty? ","line children ","Script Parser  new parse_mixin_include_arglist ","Script Parser  new ","arg_string strip ","line offset + - ","arg_string size ","line offset + ","line text size ","line text ","line offset ","name nil? ","line text scan first ","line text scan "," to_parser_offset ","line line offset + -  + - ","line line offset + -  + ","line line offset + -  "," to_parser_line offset + -  "]}," Sass Engine parse_mixin_definition":{"type":"method","name":"parse_mixin_definition","children":[],"call":["Tree MixinDefNode  new ","Script Parser  new parse_mixin_definition_arglist ","Script Parser  new ","arg_string strip ","line offset + - ","arg_string size ","line offset + ","line text size ","line text ","line offset "," raise ","SyntaxError  new ","line text [] ","name nil? ","line text scan first ","line text scan "," to_parser_offset ","line line offset + -  + - ","line line offset + -  + ","line line offset + -  "," to_parser_line offset + -  "]}," Sass Engine parse_import_arg":{"type":"method","name":"parse_import_arg","children":[],"call":["Tree ImportNode  new ","Tree DirectiveNode  new ","val =~ ","scanner scan ","scanner [] ","scanner eos? "," raise ","SyntaxError  new ","scanner rest ","scanner match? ! ","scanner match? ","Tree CssImportNode  new ","media to_a "," uri ","media_parser parse_media_query_list ","Sass SCSS Parser  new ","@options [] ","script_parser parse_string ","Sass Script Parser  new ","parser parse_string ","node source_range= ","Sass Source Range  new ","Sass Source Position  new "," to_parser_offset ","media_parser offset ","scanned length ","str length ","start_parser_offset + ","str source_range start_pos ","str source_range ","str source_range end_pos ","media_parser offset + ","str source_range end_pos offset ","Sass Script Value String  value ","scanner matched length ","scanner matched ","supports_parser parse_supports_clause ","Sass Script Value String  value  =~ ","scanner scan  to_a ","media_parser parse_media_query_list  to_a "," scanner scan  ","scanner scan _parser parse_scanner scan _query_list ","media_parser parse_media_query_list _parser parse_media_parser parse_media_query_list _query_list ","Sass SCSS Parser  new  parse_media_query_list ","media_Sass Script Parser  new  parse_media_query_list ","script_parser parse_scanner scan ing ","script_parser parse_script_parser parse_string ing ","script_parser parse_parser parse_string ing ","Sass Script Parser  new  parse_string ","script_Sass Script Parser  new  parse_string ","parser parse_scanner scan ing ","parser parse_script_parser parse_string ing ","parser parse_parser parse_string ing ","Tree ImportNode  new  source_range= ","Tree CssImportNode  new  source_range= "," to_Sass Script Parser  new _offset ","scanner scan _parser offset ","media_parser parse_media_query_list _parser offset ","Sass SCSS Parser  new  offset ","media_Sass Script Parser  new  offset ","scanner scan  length ","script_parser parse_string  length ","parser parse_string  length ","start_Sass Script Parser  new _offset + "," to_parser_offset  + ","scanner scan  source_range start_pos ","script_parser parse_string  source_range start_pos ","parser parse_string  source_range start_pos ","scanner scan  source_range ","script_parser parse_string  source_range ","parser parse_string  source_range ","scanner scan  source_range end_pos ","script_parser parse_string  source_range end_pos ","parser parse_string  source_range end_pos ","str source_range str source_range end_pos  ","str source_range Sass Source Position  new  ","scanner scan _parser offset + ","media_parser parse_media_query_list _parser offset + ","Sass SCSS Parser  new  offset + ","media_Sass Script Parser  new  offset + ","scanner scan  source_range end_pos offset ","script_parser parse_string  source_range end_pos offset ","parser parse_string  source_range end_pos offset ","str source_range str source_range end_pos  offset ","str source_range Sass Source Position  new  offset ","Sass Script Value String  Sass Script Value String  value ue ","supports_Sass Script Parser  new  parse_supports_clause ","Sass SCSS Parser  new  parse_supports_clause "]}," Sass Engine parse_import":{"type":"method","name":"parse_import","children":[],"call":["scanner scan ","values << "," raise ","SyntaxError  new ","scanner rest inspect ","scanner rest "," parse_import_arg "," loop ","StringScanner  new ","@line + ","line children empty? ","line children ","Sass Util MultibyteStringScanner  new ","offset + ","scanner pos ","StringScanner  new  scan ","Sass Util MultibyteStringScanner  new  scan ","StringScanner  new  rest inspect ","Sass Util MultibyteStringScanner  new  rest inspect ","StringScanner  new  rest ","Sass Util MultibyteStringScanner  new  rest ","StringScanner  new  pos ","Sass Util MultibyteStringScanner  new  pos "]}," Sass Engine parse_else":{"type":"method","name":"parse_else","children":[],"call":["previous add_else "," append_children ","line children ","Tree IfNode  new "," parse_script ","line offset + ","line text index ","line text ","line offset "," raise ","SyntaxError  new ","text !~ ","previous is_a? ","parent children last ","parent children ","parent children last  add_else ","parent children last  is_a? "]}," Sass Engine parse_each":{"type":"method","name":"parse_each","children":[],"call":["Tree EachNode  new "," parse_script ","line offset + ","line text index ","line text ","line offset ","var [] "," raise ","SyntaxError  new ","var =~ ","text !~ ","var nil? ","text scan first ","text scan ","Script  var_warning ","@options [] ","line offset + + ","! + ","var slice! == ","var slice! ","var strip! ","vars split map ","vars split ","vars nil? ","line line offset + +  + ","line line offset + +  ","var []  [] ","var []  =~ ","var []  nil? ","Script  var [] _warning ","line line offset + +  + + ","var []  slice! == ","var []  slice! ","var []  strip! ","var [] s split map ","var [] s split ","var [] s nil? "]}," Sass Engine parse_for":{"type":"method","name":"parse_for","children":[],"call":["Tree ForNode  new ","to_name == "," parse_script ","line offset + ","line text index ","line text ","line offset ","var [] "," raise ","SyntaxError  new ","var =~ ","text !~ ","var nil? ","text scan first ","text scan ","Script  var_warning ","@options [] ","line offset + + ","! + ","var slice! == ","var slice! ","line line offset + +  + ","line line offset + +  ","var []  [] ","var []  =~ ","var []  nil? ","Script  var [] _warning ","line line offset + +  + + ","var []  slice! == ","var []  slice! "]}," Sass Engine parse_directive":{"type":"method","name":"parse_directive","children":[],"call":["Tree DirectiveNode  new ","line text ","Tree MediaNode  new ","directive == ","Tree CharsetNode  new "," raise ","SyntaxError  new ","@line + ","line children empty? ","line children ","value [] ","Tree ReturnNode  new "," parse_script ","line offset + ","line text index to_i ","line text index ","line offset ","Tree WarnNode  new ","Tree ExtendNode  new "," parse_interp ","Tree DebugNode  new ","Tree IfNode  new ","Tree WhileNode  new "," parse_else "," parse_each "," parse_for "," parse_function "," parse_mixin_include "," parse_mixin_definition "," parse_import ","directive size + + ","directive size + ","whitespace size ","directive size ","line text [] split ","line text [] ","s strip ","value split map ","value split ","(dstr\n  (str \"@\")\n  (begin\n    (lvar :directive))\n  (str \" \")) + ","value nil? ","parser parse_media_query_list to_a ","parser parse_media_query_list ","Sass SCSS Parser  new ","@options [] ","value gsub! ! ! ","value gsub! ! ","value gsub! "," parse_content_directive ","Sass SCSS SassParser  new ","Tree SupportsNode  new ","parser parse_supports_condition ","unprefixed_directive == ","directive gsub "," send ","DIRECTIVES  include? ","directive gsub to_sym "," to_parser_offset ","Sass Source Range  new ","Sass Source Position  new "," to_parser_offset + ","line text length ","node source_range= ","line offset + - ","directive tr to_sym ","directive tr ","line line offset +  + ","line directive size + +  + ","line line offset + -  + ","line line offset +  ","line directive size + +  ","line line offset + -  ","Sass SCSS Parser  new  parse_media_query_list to_a ","Sass SCSS SassParser  new  parse_media_query_list to_a ","Sass SCSS Parser  new  parse_media_query_list ","Sass SCSS SassParser  new  parse_media_query_list ","Sass SCSS Parser  new  parse_supports_condition ","Sass SCSS SassParser  new  parse_supports_condition ","directive gsub  == "," to_parser_line offset +  "," to_parser_directive size + +  "," to_parser_line offset + -  "," to_Sass SCSS Parser  new _offset "," to_Sass SCSS SassParser  new _offset "," to_parser_line offset +  + "," to_parser_directive size + +  + "," to_parser_line offset + -  + "," to_Sass SCSS Parser  new _offset + "," to_Sass SCSS SassParser  new _offset + ","Tree MediaNode  new  source_range= ","line line offset +  + - ","line directive size + +  + - ","line line offset + -  + - "]}," Sass Engine parse_comment":{"type":"method","name":"parse_comment","children":[],"call":["Tree RuleNode  new "," parse_interp ","Tree CommentNode  new "," format_comment_text ","line [] ","line [] == ","str gsub [] ","str gsub ","line comment_tab_str "," with_extracted_values ","line text ","value [] slice! ","value [] "," class parse_interp ","line offset ","line index "," class ","line text [] == ","line text [] ","silent ! "," full_line_range ","Sass Util  with_extracted_values "," to_parser_offset ","comment source_range= ","Sass Source Range  new ","@options [] ","Sass Source Position  new ","@line + ","text count ","line offset + ","text length ","text length - ","text rindex ","text include? ","line text rstrip ","comment line= "," format_comment_line text rstrip  "," format_Tree CommentNode  new _text ","str gsub []  gsub [] ","str gsub []  gsub ","line comment_tab_str gsub []  ","line Tree CommentNode  new _tab_str "," with_extracted_ class parse_interp s ","line line text rstrip  "," class parse_interp  [] slice! "," class parse_interp  [] ","line line text rstrip  [] == ","line line text rstrip  [] ","line [] ==  ! ","line text [] ==  ! ","Sass Util  with_extracted_ class parse_interp s ","Tree CommentNode  new  source_range= ","line text rstrip  count ","line text rstrip  length ","line text rstrip  length - ","line text rstrip  rindex ","line text rstrip  include? ","line text rstr gsub [] ip ","line line text rstrip  rstrip ","Tree CommentNode  new  line= "]}," Sass Engine parse_variable":{"type":"method","name":"parse_variable","children":[],"call":["Tree VariableNode  new "," parse_script ","line offset + ","line text index ","line text ","line offset "," raise ","SyntaxError  new ","@line + ","line children empty? ","line children ","line text scan [] ","line text scan ","Script  equals_warning ","@options [] ","expr to_sass ","expr context= ","op =~ ","Script  var_warning ","line text [] == ","line text [] ","flags include? "," to_parser_offset ","1 + ","name length ","f != ","flags find ","flags split "," parse_script  to_sass "," parse_script  context= ","flags split  include? ","flags split  find ","flags split  split "]}," Sass Engine parse_property":{"type":"method","name":"parse_property","children":[],"call":["Tree PropNode  new "," parse_interp "," parse_script ","line offset + ","line text index ","line text ","line offset ","value gsub ","value =~ ","Sass Script String  new ","value strip empty? ","value strip ","Script  equals_warning ","@options [] ","Sass Tree PropNode  val_to_sass ","expr context= ","eq strip [] == ","eq strip [] ","eq strip "," raise ","SyntaxError  new ","(str \"Invalid property: \\\"\") + ","node pseudo_class_selector_message ","node declaration ","line children empty? ","line children ","node value_source_range= ","Sass Source Range  new ","Sass Source Position  new "," to_parser_offset ","line index ","expr source_range end_pos offset - ","expr source_range end_pos offset ","expr source_range end_pos ","expr source_range ","Sass Script Tree Literal  new ","Sass Script Value String  new ","name start_with? ","node custom_property? ! ","node custom_property? ","start_offset + ","value length ","parser parse_declaration_value ","Sass SCSS Parser  new ","@line + ","value gsub  gsub ","value gsub  =~ ","value gsub  strip empty? ","value gsub  strip "," parse_script  context= ","Sass Script String  new  context= ","Sass Script Tree Literal  new  context= ","Tree PropNode  new  pseudo_class_selector_message ","Tree PropNode  new  declaration ","node value gsub _source_range= ","Tree PropNode  new  value_source_range= "," to_Sass SCSS Parser  new _offset "," parse_script  source_range end_pos offset - ","Sass Script String  new  source_range end_pos offset - ","Sass Script Tree Literal  new  source_range end_pos offset - "," parse_script  source_range end_pos offset ","Sass Script String  new  source_range end_pos offset ","Sass Script Tree Literal  new  source_range end_pos offset "," parse_script  source_range end_pos ","Sass Script String  new  source_range end_pos ","Sass Script Tree Literal  new  source_range end_pos "," parse_script  source_range ","Sass Script String  new  source_range ","Sass Script Tree Literal  new  source_range ","Tree PropNode  new  custom_property? ! ","Tree PropNode  new  custom_property? ","value gsub  length ","parser parse_declaration_value gsub  ","Sass SCSS Parser  new  parse_declaration_value "]}," Sass Engine parse_property_or_rule":{"type":"method","name":"parse_property_or_rule","children":[],"call":["Tree RuleNode  new ","res + "," parse_interp ","scanner rest ","res pop "," parse_property ","scanner scan ","line text [] ","scanner pos ","line text ","res << ","res unshift ","parser parse_interp_ident ","Sass SCSS SassParser  new ","StringScanner  new ","scanner [] ","@options [] ","Sass Util MultibyteStringScanner  new ","Sass SCSS Parser  new ","rule << ","Tree CommentNode  new ","Sass Source Range  new ","Sass Source Position  new "," to_parser_offset + ","line text length "," to_parser_offset ","line offset ","ident_range start_pos ","trailing strip! ","property name_source_range= ","scanned length ","comment length ","parser offset - ","parser offset "," full_line_range ","hack_char length ","scanner pos - ","trailing length ","name start_with? ","parser parse_interp_ident  + ","scanner parser parse_interp_ident t ","StringScanner  new  rest ","Sass Util MultibyteStringScanner  new  rest ","parser parse_interp_ident  pop "," parse_ parse_property  ","StringScanner  new  scan ","Sass Util MultibyteStringScanner  new  scan ","StringScanner  new  pos ","Sass Util MultibyteStringScanner  new  pos ","parser parse_interp_ident  << ","parser parse_interp_ident  unshift ","Sass SCSS SassParser  new  parse_interp_ident ","Sass SCSS Parser  new  parse_interp_ident ","StringScanner  new  [] ","Sass Util MultibyteStringScanner  new  [] ","Tree RuleNode  new  << "," to_Sass SCSS SassParser  new _offset + "," to_Sass SCSS Parser  new _offset + "," to_parser_parser offset -  + "," to_parser_line offset  + "," to_Sass SCSS SassParser  new _offset "," to_Sass SCSS Parser  new _offset "," to_parser_parser offset -  "," to_parser_line offset  ","line parser offset -  ","line line offset  ","Sass Source Range  new  start_pos ","property line text [] _source_range= "," parse_property  name_source_range= ","scanner scan  length ","Sass SCSS SassParser  new  offset - ","Sass SCSS Parser  new  offset - ","parser parser offset -  - ","parser line offset  - ","Sass SCSS SassParser  new  offset ","Sass SCSS Parser  new  offset ","parser parser offset -  ","parser line offset  ","StringScanner  new  pos - ","Sass Util MultibyteStringScanner  new  pos - ","line text []  start_with? "]}," Sass Engine parse_line":{"type":"method","name":"parse_line","children":[],"call":[" parse_property_or_rule "," parse_mixin_include ","Tree RuleNode  new "," parse_interp ","line text ","line text [] == ","line text [] ","line text [] nil? "," parse_mixin_definition "," parse_directive "," parse_comment "," parse_variable "," parse_property "," raise ","SyntaxError  new ","value nil? ","name nil? ","line text scan [] ","line text scan ","2 empty? ","line text =~ ","@options [] == ","@options [] ","3 empty? "," full_line_range ","property name_source_range= ","Sass Source Range  new ","Sass Source Position  new "," to_parser_offset ","name_start_offset + - ","name_start_offset + ","line text index ","name length + ","name length ","value empty? ","line offset + ","line offset ","value empty? ! ","@@old_property_deprecation warn "," parse_ parse_property _or_rule "," parse_ parse_property  "," parse_property  name_source_range= ","line offset +  + - ","line offset +  + ","@@old_ parse_property _deprecation warn "]}," Sass Engine check_for_no_children":{"type":"method","name":"check_for_no_children","children":[],"call":["Sass Util  sass_warn ","(str \"WARNING on line \") strip ","node filename ","node line ","node children empty? ","node children ","node is_a? "]}," Sass Engine validate_and_append_child":{"type":"method","name":"validate_and_append_child","children":[],"call":["parent << "," validate_and_append_child ","child each "]}," Sass Engine append_children":{"type":"method","name":"append_children","children":[],"call":[" validate_and_append_child "," check_for_no_children ","continued_comment value << << ","child value ","continued_comment value << ","continued_comment value ","child line == ","continued_comment line + + ","continued_comment line + ","continued_comment value count ","continued_comment line ","child line ","child silent ","child is_a? ","continued_rule children= ","child children ","continued_rule add_rules ","child children empty? ","child continued? "," build_tree ","children each "," raise ","SyntaxError  new ","continued_rule line ","(str \"\\n\") + ","continued_comment lines ","child type == ","child type ","child value first gsub! ","child value first ","continued_comment value last sub! ","continued_comment value last "," validate_and_append_ build_tree  "," check_for_no_ build_tree ren "," build_tree  value "," build_tree  line == "," build_tree  line "," build_tree  silent "," build_tree  is_a? ","continued_rule  build_tree ren= "," build_tree   build_tree ren "," build_tree   build_tree ren empty? "," build_tree  continued? "," build_tree ren each "," build_tree  type == "," build_tree  type "," build_tree  value first gsub! "," build_tree  value first "]}," Sass Engine build_tree":{"type":"method","name":"build_tree","children":[],"call":[" append_children ","line children ","node filename= ","line filename ","node line= ","line index ","node is_a? "," Array each "," Array "," parse_line ","line offset "]}," Sass Engine tree":{"type":"method","name":"tree","children":[],"call":["nodes << "," tree ","nodes last children= ","nodes last "," raise ","SyntaxError  new ","line index ","line tabs - ","line tabs ","line tabs > ","base + ","line tabs >= ","arr [] ","arr [] tabs ","arr [] nil? ","arr []  index ","arr []  tabs - ","arr []  tabs ","arr []  tabs > ","arr [] tabs  + ","arr []  tabs >= "]}," Sass Engine try_comment":{"type":"method","name":"try_comment","children":[],"call":["last text << << ","last text << ","last text "," raise ","SyntaxError  new ","(str \"Inconsistent indentation:\\n\") strip gsub ","(str \"Inconsistent indentation:\\n\") strip ","Sass Shared  human_indentation ","line [] ","line =~ ","last comment? ","last comment_tab_str ","(str \"Inconsistent indentation:\\n\") strip tr "]}," Sass Engine tabulate":{"type":"method","name":"tabulate","children":[],"call":["lines << ","Line  new ","@options [] ","tab_str size ","line strip "," raise ","SyntaxError  new ","(str \"Inconsistent indentation: \") strip gsub ","(str \"Inconsistent indentation: \") strip ","Sass Shared  human_indentation ","tab_str * != ","tab_str * ","line_tab_str scan size ","line_tab_str scan "," try_comment ","lines last tabs ","lines last ","tab_str nil? ","tab_str nil? ! ","tab_str include? ","line_tab_str empty? ","line [] ","lines last text << ","lines last text ","lines last comment? ","line strip empty? ","string gsub scan each_with_index ","string gsub scan ","string gsub ","line_tab_str size ","string scan each_with_index ","string scan ","(str \"Inconsistent indentation: \") strip tr ","line []  scan size ","line []  scan ","line []  empty? ","line []  size "]}," Sass Engine check_encoding!":{"type":"method","name":"check_encoding!","children":[],"call":[" raise ","Sass SyntaxError  new "," check_sass_encoding ","Sass Util  check_sass_encoding "]}," Sass Engine sassc_key":{"type":"method","name":"sassc_key","children":[],"call":["@options [] key ","@options [] "]}," Sass Engine _to_tree":{"type":"method","name":"_to_tree","children":[],"call":[" raise ","e sass_template= ","e modify_backtrace ","@options [] ","root options= ","@options [] store ","root options [] ","root options "," append_children "," tree first "," tree "," tabulate ","Tree RootNode  new ","Sass SCSS Parser  new parse ","Sass SCSS Parser  new ","@options [] == "," check_encoding! ","root options merge ","@options [] retrieve ","Digest SHA1  hexdigest "," sassc_key ","root options merge  [] ","Tree RootNode  new  options= ","Sass SCSS Parser  new parse  options= ","@options [] retrieve  options= ","root options merge  [] store ","Tree RootNode  new  options [] ","Sass SCSS Parser  new parse  options [] ","@options [] retrieve  options [] ","Tree RootNode  new  options ","Sass SCSS Parser  new parse  options ","@options [] retrieve  options ","root options merge  [] == ","Tree RootNode  new  options merge ","Sass SCSS Parser  new parse  options merge ","@options [] retrieve  options merge ","root options merge  [] retrieve "," sassc_ sassc_key  "]}," Sass Engine _render":{"type":"method","name":"_render","children":[],"call":["rendered gsub ","(str \"@charset \\\"\") encode "," source_encoding "," source_encoding name ","Regexp  new ","\\A@charset \"(.*?)\" encode ","rendered encode "," ruby1_8? "," _to_tree render "," _to_tree ","rendered encode  gsub "," _to_tree render  gsub ","rendered encode  encode "," _to_tree render  encode "]}," Sass Engine _dependencies":{"type":"method","name":"_dependencies","children":[],"call":["n imported_file _dependencies ","n imported_file ","n css_import? "," to_tree grep "," to_tree ","engines << ","seen << ","seen include? ","@options [] "]}," Sass Engine dependencies":{"type":"method","name":"dependencies","children":[],"call":["engines - "," _dependencies ","Set  new ","Sass Util  array_minus ","Set  new  - "]}," Sass Engine source_encoding":{"type":"method","name":"source_encoding","children":[],"call":[" check_encoding! "]}," Sass Engine to_tree":{"type":"method","name":"to_tree","children":[],"call":[" _to_tree ","Sass Util  silence_sass_warnings ","@options [] "]}," Sass Engine render":{"type":"method","name":"render","children":[],"call":[" _render ","Sass Util  silence_sass_warnings ","@options [] "," encode_and_set_charset "," _to_tree render "," _to_tree "]}," Sass Engine initialize":{"type":"method","name":"initialize","children":[],"call":[" class normalize_options "," class "]}," Sass Engine for_file":{"type":"method","name":"for_file","children":[],"call":[]}," Sass Engine normalize_options":{"type":"method","name":"normalize_options","children":[],"call":[]}," Sass Engine Line comment?":{"type":"method","name":"comment?","children":[],"call":[" text [] == "," text [] "," text "]}," Sass CSS fold_commas":{"type":"method","name":"fold_commas","children":[],"call":["root children compact! ","root children "," fold_commas ","prev_rule rule first << ","child rule first ","child rule ","prev_rule rule first ","prev_rule rule ","prev_rule children == ","child children ","prev_rule children ","child is_a? ","root children map! ","prev_rule parsed_rules members << "," first_seq ","prev_rule parsed_rules members ","prev_rule parsed_rules ","(send\n  (send\n    (lvar :prev_rule) :children) :map) == ","c to_sass ","child children map ","prev_rule children map "]}," Sass CSS flatten_rule":{"type":"method","name":"flatten_rule","children":[],"call":[" flatten_rules ","rule children= ","child children ","rule rule= ","child rule first ","child rule ","rule rule first ","rule rule ","child rule first gsub ","child rule first [] == ","child rule first [] ","rule children first ","rule children ","rule children first is_a? ","rule children size == ","rule children size ","rule parsed_rules= "," make_seq "," first_seq members "," first_seq "," first_sseq ","child parsed_rules resolve_parent_refs ","rule parsed_rules ","child parsed_rules "," first_simple_sel is_a? "," first_simple_sel "," first_seq members + ","rule rule children first ren= ","rule children first  rule children first ren ","rule children first  rule first ","rule children first  rule ","rule children first  rule first gsub ","rule children first  rule first [] == ","rule children first  rule first [] ","rule rule children first ren first ","rule rule children first ren ","rule rule children first ren first is_a? ","rule rule children first ren size == ","rule rule children first ren size ","rule children first  parsed_rules resolve_parent_refs ","rule children first  parsed_rules "]}," Sass CSS flatten_rules":{"type":"method","name":"flatten_rules","children":[],"call":[" flatten_rules "," flatten_rule ","root children each ","root children "]}," Sass CSS remove_parent_refs":{"type":"method","name":"remove_parent_refs","children":[],"call":[" remove_parent_refs ","child rule first gsub! ","child rule first ","child rule ","root children each ","root children "]}," Sass CSS parent_ref_rules":{"type":"method","name":"parent_ref_rules","children":[],"call":[" parent_ref_rules ","root children each ","root children ","root children uniq! ","root children compact! ","child children ","current_rule children ","current_rule << ","child rule= ","& + ","Tree RuleNode  new ","current_rule rule first != ","current_rule rule first ","current_rule rule ","current_rule nil? ","child rule first scan first ","child rule first scan ","child rule first ","child rule ","child is_a? ","root children map! ","child parsed_rules= "," make_sseq ","rest unshift ","Sass Selector Parent  new ","rest empty? ","current_rule parsed_rules= "," first_sseq members != "," first_sseq members "," first_sseq ","firsts push ","rest shift ","firsts first is_a? ","firsts first ","sseq members [] ","sseq members ","sseq members first ","sseq is_a? ","sseq subject? "," first_sseq subject? ! ! != ","last_simple_subject ! ! ","last_simple_subject ! "," first_sseq subject? ! ! "," first_sseq subject? ! "," first_sseq subject? ","Tree RuleNode  new  children ","Tree RuleNode  new  << ","Tree RuleNode  new  rule first != ","Tree RuleNode  new  rule first ","Tree RuleNode  new  rule ","Tree RuleNode  new  nil? "," make_ first_sseq  ","Tree RuleNode  new  parsed_rules= "," first_ first_sseq  members != "," first_ first_sseq  members "," first_ first_sseq  "," first_sseq  members [] "," first_sseq  members "," first_sseq  members first "," first_sseq  is_a? "," first_sseq  subject? "," first_ first_sseq  subject? ! ! != "," first_ first_sseq  subject? ! ! "," first_ first_sseq  subject? ! "," first_ first_sseq  subject? "]}," Sass CSS expand_commas":{"type":"method","name":"expand_commas","children":[],"call":["root children flatten! ","root children ","node children= ","child children ","Tree RuleNode  new ","rule strip ","child rule first split map ","child rule first split ","child rule first ","child rule "," expand_commas ","child is_a? ","child rule first include? ","root children map! ","rule strip empty? ","node parsed_rules= "," make_cseq ","child parsed_rules members map ","child parsed_rules members ","child parsed_rules ","child parsed_rules members size > ","child parsed_rules members size ","Tree RuleNode  new  children= ","Tree RuleNode  new  parsed_rules= "]}," Sass CSS build_tree":{"type":"method","name":"build_tree","children":[],"call":[" fold_commas "," flatten_rules "," remove_parent_refs "," parent_ref_rules "," expand_commas ","Sass SCSS CssParser  new parse ","Sass SCSS CssParser  new ","@options [] "," dump_selectors "," nest_seqs "," parse_selectors "," bubble_subject "]}," Sass CSS check_encoding!":{"type":"method","name":"check_encoding!","children":[],"call":[" raise ","Sass SyntaxError  new ","Sass Util  check_sass_encoding "]}," Sass CSS source_encoding":{"type":"method","name":"source_encoding","children":[],"call":[" check_encoding! "]}," Sass CSS render":{"type":"method","name":"render","children":[],"call":[" raise ","err modify_backtrace ","@options [] "," build_tree send strip + "," build_tree send strip "," build_tree send "," build_tree "," check_encoding! "]}," Sass CSS initialize":{"type":"method","name":"initialize","children":[],"call":["@options []= ","@options [] == ","@options [] ","options dup ","template read ","template is_a? ","options merge ","options dup  []= ","options merge  []= ","options dup  [] == ","options merge  [] == ","options dup  [] ","options merge  [] ","template read  read ","template read  is_a? "]}," Sass Callbacks define_callback":{"type":"method","name":"define_callback","children":[],"call":[" class_eval ","name inspect ","51 + ","52 + "]}," Sass Callbacks InstanceMethods clear_callbacks!":{"type":"method","name":"clear_callbacks!","children":[],"call":[]}," Sass Callbacks extended":{"type":"method","name":"extended","children":[],"call":[]}," Sass CacheStores Null was_set?":{"type":"method","name":"was_set?","children":[],"call":["@keys [] "]}," Sass CacheStores Null _store":{"type":"method","name":"_store","children":[],"call":["@keys []= "]}," Sass CacheStores Null _retrieve":{"type":"method","name":"_retrieve","children":[],"call":[]}," Sass CacheStores Null initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass CacheStores Memory reset!":{"type":"method","name":"reset!","children":[],"call":[]}," Sass CacheStores Memory store":{"type":"method","name":"store","children":[],"call":["@contents []= "]}," Sass CacheStores Memory retrieve":{"type":"method","name":"retrieve","children":[],"call":["obj dup ","obj deep_copy ","obj respond_to? ","@contents [] [] ","@contents [] ","@contents [] [] == ","@contents has_key? ","@contents [] []  dup ","@contents [] []  deep_copy ","@contents [] []  respond_to? "]}," Sass CacheStores Memory initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass CacheStores Memory _load":{"type":"method","name":"_load","children":[],"call":[]}," Sass CacheStores Memory _dump":{"type":"method","name":"_dump","children":[],"call":[]}," Sass CacheStores Filesystem path_to":{"type":"method","name":"path_to","children":[],"call":["File  join "," cache_location ","%%%03d % ","Sass Util  ord ","key gsub ","c ord "]}," Sass CacheStores Filesystem _store":{"type":"method","name":"_store","children":[],"call":["f write ","f puts ","File  open ","FileUtils  mkdir_p ","File  dirname "," path_to ","File  writable? ! ","File  writable? ","File  exists? ","Sass Util  atomic_create_and_write_file "]}," Sass CacheStores Filesystem _retrieve":{"type":"method","name":"_retrieve","children":[],"call":["Sass Util  sass_warn "," path_to ","File  unlink ","f read ","f readline strip == ","f readline strip ","f readline ","File  open ","File  readable? "]}," Sass CacheStores Filesystem initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass CacheStores Chain retrieve":{"type":"method","name":"retrieve","children":[],"call":["c store ","@caches [] each ","@caches [] ","c retrieve ","@caches each_with_index ","prev store "]}," Sass CacheStores Chain store":{"type":"method","name":"store","children":[],"call":["c store ","@caches each "]}," Sass CacheStores Chain initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass CacheStores Base key":{"type":"method","name":"key","children":[],"call":["Digest SHA1  hexdigest "]}," Sass CacheStores Base retrieve":{"type":"method","name":"retrieve","children":[],"call":["Sass Util  sass_warn "," path_to ","Marshal  load "," _retrieve ","Sass Util  load "]}," Sass CacheStores Base store":{"type":"method","name":"store","children":[],"call":[" _store ","Marshal  dump ","Sass Util  dump ","Sass Util  sass_warn "," path_to ","obj class name ","obj class ","obj after_sass_cache_store ","obj respond_to? ","obj before_sass_cache_store "]}," Sass CacheStores Base _retrieve":{"type":"method","name":"_retrieve","children":[],"call":[" raise "," class "]}," Sass CacheStores Base _store":{"type":"method","name":"_store","children":[],"call":[" raise "," class "]}," Sass Util convert_and_dump":{"type":"method","name":"convert_and_dump","children":[],"call":["Marshal  dump "," dump "," map_hash ","obj is_a? ","obj map "]}," Sass Util inspect":{"type":"method","name":"inspect","children":[],"call":["\" + + ","\" + ","s inspect [] ","s inspect ","obj gsub ","obj inspect ","obj is_a? ",": + "," inspect ","obj to_s "," version_geq "]}," Sass Util load":{"type":"method","name":"load","children":[],"call":["obj _after_load ","obj respond_to? ","Sass Util  load "," map_hash ","obj is_a? ","obj map ","Marshal  load ","Marshal  load  _after_load ","Marshal  load  respond_to? ","Marshal  load  is_a? ","Marshal  load  map "]}," Sass Util dump":{"type":"method","name":"dump","children":[],"call":["obj _after_dump ","obj respond_to? "," convert_and_dump ","obj _around_dump ","obj _before_dump ","obj  convert_and_dump pond_to? "]}," Tree WhileNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Tree WhileNode _perform":{"type":"method","name":"_perform","children":[],"call":[" perform_children ","@expr perform to_bool ","@expr perform ","Sass Environment  new "]}," Tree WhileNode to_src":{"type":"method","name":"to_src","children":[],"call":["(begin\n  (send\n    (str \"  \") :*\n    (lvar :tabs))) + "," children_to_src ","@expr to_sass ","   * "]}," Sass Tree WarnNode _perform":{"type":"method","name":"_perform","children":[],"call":["environment pop_frame ","Sass Util  sass_warn ","msg << ","entry [] ","msg << << ","i == ","environment stack reverse each_with_index ","environment stack reverse ","environment stack ","res value ","res is_a? ","@expr perform ","environment push_frame "," line "," filename ","res value  value ","@expr perform  value ","res value  is_a? ","@expr perform  is_a? "]}," Sass Tree WarnNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi ","@expr to_sass ","   * "]}," Sass Tree VariableNode _perform":{"type":"method","name":"_perform","children":[],"call":["environment set_var ","Sass Script String  new ","val value ","val is_a? ","@expr context == ","@expr context ","@expr perform ","environment var nil? ! ","environment var nil? ","environment var ","Sass Script String  new  Sass Script String  new ue ","@expr perform  @expr perform ue ","Sass Script String  new  is_a? ","@expr perform  is_a? "]}," Sass Tree VariableNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi ","@expr to_sass "," dasherize ","   * "]}," Tree RuleNode debug_info_rule":{"type":"method","name":"debug_info_rule","children":[],"call":["node options= ","@options merge ","node << ","rule << ","prop resolved_value= ","Sass SCSS RX  escape_ident ","v to_s ","prop resolved_name= ","PropNode  new ","rule resolved_rules= ","Sass Selector CommaSequence  new ","Sass Selector Sequence  new ","Sass Selector SimpleSequence  new ","Sass Selector Element  new ","k to_s gsub ","k to_s ","RuleNode  new ","(send\n  (send nil :debug_info) :map) sort each ","(send\n  (send nil :debug_info) :map) sort "," debug_info map "," debug_info ","DirectiveNode  new ","DirectiveNode  new  options= ","DirectiveNode  new  << ","RuleNode  new  << ","PropNode  new  resolved_value= ","PropNode  new  resolved_name= ","RuleNode  new  resolved_RuleNode  new s= "]}," Tree RuleNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Tree RuleNode cssize!":{"type":"method","name":"cssize!","children":[],"call":[" resolved_rules= ","@parsed_rules resolve_parent_refs ","parent resolved_rules "," resolved_rules "]}," Tree RuleNode _cssize":{"type":"method","name":"_cssize","children":[],"call":["rules last group_end= ","rules last ","rules empty? ","rules unshift ","r tabs ","rules each "," style == "," style ","node children= ","props empty? ","c invisible? ","c is_a? ","node children reject ","node children ","node children select ","node children grep ","node children grep  last group_end= ","node children grep  last ","node children grep  empty? ","node children grep  unshift ","node children grep  each "]}," Tree RuleNode perform!":{"type":"method","name":"perform!","children":[],"call":["Sass SCSS StaticParser  new parse_selector "," filename ","Sass SCSS StaticParser  new "," line "," run_interp "]}," Tree RuleNode _to_s":{"type":"method","name":"_to_s","children":[],"call":["to_return << "," group_end ","\n + "," style == "," style ","(send\n  (send nil :children) :map) join ","a to_s ","tabs + "," children map "," children "," filename ","Pathname  new relative_path_from to_s ","Pathname  new relative_path_from ","Pathname  new ","File  dirname ","@options [] "," line ","to_return << << "," debug_info_rule to_s "," debug_info_rule "," style != ","   * ","tabs - ","total_indent + ","(send\n  (send\n    (send\n      (block\n        (send\n          (send\n            (send nil :resolved_rules) :members) :map)\n        (args\n          (arg :seq))\n        (send\n          (send\n            (send\n              (lvar :seq) :to_a) :join) :gsub\n          (regexp\n            (str \"([^,])\\\\n\")\n            (regopt :m))\n          (if\n            (send\n              (send nil :style) :==\n              (sym :compressed))\n            (str \"\\\\1 \")\n            (str \"\\\\1\\n\")))) :join\n      (lvar :rule_separator)) :split\n    (str \"\\n\")) :map) join ","per_rule_indent + ","line strip ","(send\n  (send\n    (send nil :resolved_rules) :members) :map) join split map ","(send\n  (send\n    (send nil :resolved_rules) :members) :map) join split ","(send\n  (send\n    (send nil :resolved_rules) :members) :map) join ","seq to_a join gsub ","seq to_a join ","seq to_a "," resolved_rules members map "," resolved_rules members "," resolved_rules ","(sym :nested) include? "," tabs ","output_style == ","output_style != ","(send\n  (send\n    (send\n      (block\n        (send\n          (send\n            (send nil :resolved_rules) :members) :map)\n        (args\n          (arg :seq))\n        (send\n          (send\n            (send\n              (lvar :seq) :to_a) :join) :gsub\n          (str \"\\n\")\n          (if\n            (send\n              (send nil :style) :==\n              (sym :compressed))\n            (str \" \")\n            (str \"\\n\")))) :join\n      (lvar :rule_separator)) :split\n    (str \"\\n\")) :map) join ","tabs +  + ","tabs +  - ","per_   *  + "," tabs +  "," style  == "," style  != "]}," Tree RuleNode to_scss":{"type":"method","name":"to_scss","children":[],"call":["res << << << ","res << << ","   * ","res << ","res slice! "," children last silent "," children last "," children "," children last is_a? ","name + "," children_to_src "," selector_to_scss "," rule ","name +  << << << ","name +  << << ","name +  << ","name +  slice! "," selector_to_scss  + "]}," Tree RuleNode to_sass":{"type":"method","name":"to_sass","children":[],"call":["name gsub + "," children_to_src ","name gsub ","   * ","\\ + ","name [] == ","name [] "," selector_to_sass "," rule ","\\ +  gsub + "," selector_to_sass  gsub + ","\\ +  gsub "," selector_to_sass  gsub ","\\ +  [] == "," selector_to_sass  [] == ","\\ +  [] "," selector_to_sass  [] "]}," Sass Tree RootNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["Properties aren't allowed at the root of a document. + ","child pseudo_class_selector_message ","child is_a? "]}," Sass Tree RootNode _to_s":{"type":"method","name":"_to_s","children":[],"call":["result + ","result empty? ","result rstrip! ","result << ","child_str + "," style == "," style ","child to_s ","child invisible? "," children each "," children ","String  new ","(str \"@charset \\\"\") encode + ","(str \"@charset \\\"\") encode ","result encoding ","result encoding name ","result encode ","Encoding  find ","encoding << ","encoding =~ "," children first name "," children first "," children first is_a? ","result ascii_only? ","Sass Util  ruby1_8? ","String  new  + ","(str \"@charset \\\"\") encode +  + ","result encode  + ","String  new  empty? ","(str \"@charset \\\"\") encode +  empty? ","result encode  empty? ","String  new  rstrip! ","(str \"@charset \\\"\") encode +  rstrip! ","result encode  rstrip! ","String  new  << ","(str \"@charset \\\"\") encode +  << ","result encode  << ","child to_s  + ","String  new  encoding ","(str \"@charset \\\"\") encode +  encoding ","result encode  encoding ","result  children first name  ","String  new  encoding name ","(str \"@charset \\\"\") encode +  encoding name ","result encode  encoding name ","result  children first name  name ","String  new  encode ","(str \"@charset \\\"\") encode +  encode ","result encode  encode "," children first name  << "," children first name  =~ ","String  new  ascii_only? ","(str \"@charset \\\"\") encode +  ascii_only? ","result encode  ascii_only? "]}," Sass Tree RootNode to_src":{"type":"method","name":"to_src","children":[],"call":["(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (send\n      (send nil :children) :+\n      (array\n        (nil)))\n    (int 2)) :map) join rstrip + ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (send\n      (send nil :children) :+\n      (array\n        (nil)))\n    (int 2)) :map) join rstrip ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (send\n      (send nil :children) :+\n      (array\n        (nil)))\n    (int 2)) :map) join ","child send + ","child line + == ","nxt line ","child line + ","child line ","nxt is_a? ","child is_a? ","child line + + == ","child line + + ","child value count ","child value ","child send ","Sass Util  enum_cons map ","Sass Util  enum_cons "," children + "," children "]}," Sass Tree RootNode to_scss":{"type":"method","name":"to_scss","children":[],"call":[" to_src "]}," Sass Tree RootNode to_sass":{"type":"method","name":"to_sass","children":[],"call":[" to_src "]}," Sass Tree RootNode perform!":{"type":"method","name":"perform!","children":[],"call":["environment options= ","environment options empty? ","environment options ","environment options nil? "]}," Sass Tree RootNode cssize":{"type":"method","name":"cssize","children":[],"call":[" raise ","e sass_template= ","e sass_template "]}," Sass Tree RootNode perform":{"type":"method","name":"perform","children":[],"call":[" raise ","e sass_template= ","environment options= ","environment options empty? ","environment options ","environment options nil? ","e sass_template "]}," Sass Tree RootNode to_s":{"type":"method","name":"to_s","children":[],"call":[" raise ","e sass_template= ","e sass_template "]}," Tree PropNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? ! ","child is_a? "]}," Tree PropNode perform!":{"type":"method","name":"perform!","children":[],"call":["val to_s ","val value ","val is_a? ","@value context == ","@value context ","@value perform "," run_interp ","@value perform  to_s ","@value perform  @value perform ue ","@value perform  is_a? ","@@value perform ue context == ","@@value perform ue context ","@@value perform ue perform "]}," Tree PropNode cssize!":{"type":"method","name":"cssize!","children":[],"call":[" tabs= ","parent tabs + ","parent resolved_value empty? ","parent resolved_value ","parent tabs "," style == "," style "," resolved_name= "," resolved_name ","parent resolved_name "]}," Tree PropNode _cssize":{"type":"method","name":"_cssize","children":[],"call":["result unshift ","node send ","node children empty? ","node children ","node resolved_value empty? ! ","node resolved_value empty? ","node resolved_value ","node children dup ","node children dup  unshift "]}," Tree PropNode _to_s":{"type":"method","name":"_to_s","children":[],"call":["   * + + + + + "," style == "," style ","   * + + + + "," resolved_value ","   * + + + ","   * + + ","   * + "," resolved_name ","   * ","tabs - + "," tabs ","tabs - "]}," Tree PropNode to_src":{"type":"method","name":"to_src","children":[],"call":["res + + + ","res + + "," semi ","res + "," children_to_src rstrip "," children_to_src "," children empty? "," children "," declaration "," declaration  + + + "," declaration  + + "," declaration  + "]}," Sass Tree Node semi":{"type":"method","name":"semi","children":[],"call":["fmt == "]}," Sass Tree Node dasherize":{"type":"method","name":"dasherize","children":[],"call":["s gsub ","opts [] "]}," Sass Tree Node selector_to_scss":{"type":"method","name":"selector_to_scss","children":[],"call":["(send\n  (lvar :sel) :map) join gsub ","   * ","(send\n  (lvar :sel) :map) join ","r to_sass ","r is_a? ","sel map "]}," Sass Tree Node selector_to_sass":{"type":"method","name":"selector_to_sass","children":[],"call":["(send\n  (lvar :sel) :map) join ","r to_sass ","1 + ","r gsub ","r is_a? ","sel map "]}," Sass Tree Node selector_to_src":{"type":"method","name":"selector_to_src","children":[],"call":[" selector_to_scss "," selector_to_sass ","fmt == "]}," Sass Tree Node children_to_src":{"type":"method","name":"children_to_src","children":[],"call":["(if\n  (send\n    (lvar :fmt) :==\n    (sym :sass))\n  (str \"\\n\")\n  (str \" {\\n\")) + + ","fmt == ","(if\n  (send\n    (lvar :fmt) :==\n    (sym :sass))\n  (str \"\\n\")\n  (str \" {\\n\")) + ","(send\n  (send nil :children) :map) join rstrip ","(send\n  (send nil :children) :map) join ","c send ","tabs + "," children map "," children "," children empty? "]}," Sass Tree Node to_src":{"type":"method","name":"to_src","children":[],"call":["Sass Util  abstract "]}," Sass Tree Node invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":[]}," Sass Tree Node run_interp":{"type":"method","name":"run_interp","children":[],"call":["(send\n  (lvar :text) :map) join strip ","(send\n  (lvar :text) :map) join ","val to_s ","val value ","val is_a? ","r perform ","r is_a? ","text map ","r perform  to_s ","r perform  r perform ue ","r perform  is_a? "]}," Sass Tree Node perform_children":{"type":"method","name":"perform_children","children":[],"call":["(send\n  (send nil :children) :map) flatten ","c perform "," children map "," children "]}," Sass Tree Node perform!":{"type":"method","name":"perform!","children":[],"call":[" children= "," perform_children ","Environment  new "," check_child! "," children each "," children "]}," Sass Tree Node _perform":{"type":"method","name":"_perform","children":[],"call":["node perform! "," dup "," dup  perform! "]}," Sass Tree Node cssize!":{"type":"method","name":"cssize!","children":[],"call":[" children= ","(send\n  (send nil :children) :map) flatten ","c cssize "," children map "," children "]}," Sass Tree Node _cssize":{"type":"method","name":"_cssize","children":[],"call":["node cssize! "," dup "," dup  cssize! "]}," Sass Tree Node _to_s":{"type":"method","name":"_to_s","children":[],"call":["Sass Util  abstract "]}," Sass Tree Node _after_load":{"type":"method","name":"_after_load","children":[],"call":["Sass Util  load "]}," Sass Tree Node _around_dump":{"type":"method","name":"_around_dump","children":[],"call":["Sass Util  dump ","@options []= ","old_options [] ","SAVED_OPTIONS  each ","Sass Util  dump  []= "]}," Sass Tree Node perform":{"type":"method","name":"perform","children":[],"call":[" raise ","e modify_backtrace "," line "," filename "," _perform "]}," Sass Tree Node cssize":{"type":"method","name":"cssize","children":[],"call":[" raise ","e modify_backtrace "," line "," filename "," _cssize ","parent class == "," class ","parent class "]}," Sass Tree Node check_child!":{"type":"method","name":"check_child!","children":[],"call":[" raise ","Sass SyntaxError  new ","child line "," invalid_child? "]}," Tree MixinNode handle_include_loop!":{"type":"method","name":"handle_include_loop!","children":[],"call":[" raise ","Sass SyntaxError  new ","msg << << ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (lvar :mixins)\n    (int 2)) :map) join ","Sass Util  enum_cons map ","Sass Util  enum_cons ","msg << ","mixins << ","mixins [] == ","mixins [] ","mixins size == ","mixins size ","(send\n  (send\n    (lvar :environment) :stack) :map) compact ","s [] ","environment stack map ","environment stack ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (lvar :(send\n  (send\n    (lvar :environment) :stack) :map) compact )\n    (int 2)) :map) join ","(send\n  (send\n    (lvar :environment) :stack) :map) compact  << ","(send\n  (send\n    (lvar :environment) :stack) :map) compact  [] == ","(send\n  (send\n    (lvar :environment) :stack) :map) compact  [] ","(send\n  (send\n    (lvar :environment) :stack) :map) compact  size == ","(send\n  (send\n    (lvar :environment) :stack) :map) compact  size "]}," Tree MixinNode perform!":{"type":"method","name":"perform!","children":[],"call":["original_env pop_frame "," raise ","e add_backtrace ","e modify_backtrace "," children= ","(send\n  (send\n    (lvar :mixin) :tree) :map) flatten ","c perform ","mixin tree map ","mixin tree ","Sass SyntaxError  new ","var inspect ","env var ","var name ","env set_local_var ","Sass Script String  new ","val value ","val is_a? ","default context == ","default context ","default perform ","value perform ","mixin args zip inject ","Sass Environment  new ","mixin environment ","mixin args zip ","mixin args ","(str \"Mixin \") gsub ","@args size == ","@args size ","mixin args size != ","mixin args size ","mixin args size < ","environment mixin ","original_env prepare_frame ","original_env push_frame "," line "," filename "," handle_include_loop! ","environment mixins_in_use include? ","environment mixins_in_use ","kv perform ","passed_keywords [] ","var underscored_name ","var underscored_name == ","mixin args find ","passed_keywords each ","passed_args size ","@keywords dup ","@args dup ","(send\n  (send\n    (lvar :environment mixin ) :tree) :map) flatten ","environment mixin  tree map ","environment mixin  tree ","Sass Script String  new  Sass Script String  new ue ","default perform  default perform ue ","Sass Script String  new  is_a? ","default perform  is_a? ","Sass Script String  new ue perform ","default perform ue perform ","environment mixin  args zip inject ","environment mixin  environment ","environment mixin  args zip ","environment mixin  args ","environment mixin  args size != ","environment mixin  args size ","environment mixin  args size < ","environment environment mixin  ","environment environment mixin s_in_use include? ","environment environment mixin s_in_use ","passed_keywords []  perform ","@keywords dup  [] ","environment mixin  args find ","@keywords dup  each ","@args dup  size "]}," Tree MixinNode _cssize":{"type":"method","name":"_cssize","children":[],"call":[" raise ","e add_backtrace "," line "," filename ","e modify_backtrace ","(send\n  (send nil :children) :map) flatten ","c cssize ","parent check_child! "," children map "," children "]}," Tree MixinNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi "," dasherize ","fmt == ","   * ","( + + ","( + ","(send\n  (ivar :@args) :map) join ","a to_sass ","@args map ","@args empty? ","keywords empty? ","args empty? ","(send\n  (ivar :@keywords) :map) join ","v to_sass ","@keywords map ","@keywords empty? ","(send\n  (ivar :@( + + ) :map) join ","(send\n  (ivar :@(send\n  (ivar :@args) :map) join ) :map) join ","@( + +  map ","@(send\n  (ivar :@args) :map) join  map ","@( + +  empty? ","@(send\n  (ivar :@args) :map) join  empty? ","(send\n  (ivar :@keywords) :map) join  empty? ","( + +  empty? ","(send\n  (ivar :@args) :map) join  empty? ","(send\n  (ivar :@(send\n  (ivar :@keywords) :map) join ) :map) join ","@(send\n  (ivar :@keywords) :map) join  map ","@(send\n  (ivar :@keywords) :map) join  empty? "]}," Tree MixinNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Tree MixinNode cssize":{"type":"method","name":"cssize","children":[],"call":[" _cssize "]}," Tree MixinNode options=":{"type":"method","name":"options=","children":[],"call":["a context= ","@args each ","opts [] ","v context= ","@keywords each "]}," Sass Tree MixinDefNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Sass Tree MixinDefNode _perform":{"type":"method","name":"_perform","children":[],"call":["environment set_mixin ","Sass Mixin  new "," children "]}," Sass Tree MixinDefNode to_src":{"type":"method","name":"to_src","children":[],"call":["(begin\n  (send\n    (str \"  \") :*\n    (lvar :tabs))) + "," children_to_src "," dasherize ","fmt == ","   * ","( + + ","( + ","(send\n  (ivar :@args) :map) join ","v to_sass ","d to_sass ","@args map ","@args empty? ","(send\n  (ivar :@( + + ) :map) join ","@( + +  map ","@( + +  empty? "]}," Sass Tree ImportNode perform!":{"type":"method","name":"perform!","children":[],"call":["environment pop_frame "," raise ","e add_backtrace ","e modify_backtrace "," imported_file options [] "," imported_file options "," imported_file "," children= "," perform_children ","root children "," imported_file to_tree ","environment push_frame "," imported_file to_tree  children "]}," Sass Tree ImportNode _perform":{"type":"method","name":"_perform","children":[],"call":["DirectiveNode  new "," css_import? "]}," Sass Tree ImportNode _cssize":{"type":"method","name":"_cssize","children":[],"call":[" raise ","e add_backtrace ","e modify_backtrace "," children first filename "," children first "," children "]}," Sass Tree ImportNode cssize":{"type":"method","name":"cssize","children":[],"call":[" first "]}," Sass Tree ImportNode to_scss":{"type":"method","name":"to_scss","children":[],"call":["   * "]}," Sass Tree ImportNode to_sass":{"type":"method","name":"to_sass","children":[],"call":["   * "]}," Tree IfNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Tree IfNode _perform":{"type":"method","name":"_perform","children":[],"call":["@else perform "," perform_children ","@expr perform to_bool ","@expr perform ","@expr nil? ","Sass Environment  new "]}," Tree IfNode to_src":{"type":"method","name":"to_src","children":[],"call":["str << ","@else send "," children_to_src ","@expr to_sass ","   * ","is_else ! "]}," Tree ForNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Tree ForNode _perform":{"type":"method","name":"_perform","children":[],"call":[" perform_children ","environment set_local_var ","Sass Script Number  new ","from denominator_units ","from numerator_units ","range each ","Sass Environment  new ","Range  new ","to to_i ","from to_i ","to coerce ","to assert_int! ","from assert_int! ","@to perform ","@from perform ","Sass Environment  new  set_local_var ","from denominato coerce r_units ","from denomina@to perform r_units ","@from perform  denominator_units ","from numerato coerce r_units ","from numera@to perform r_units ","@from perform  numerator_units ","Range  new  each ","to coerce  to coerce _i ","@to perform  @to perform _i ","from to coerce _i ","from @to perform _i ","@from perform  to_i ","to coerce  coerce ","@to perform  coerce ","to coerce  assert_int! ","@to perform  assert_int! ","@from perform  assert_int! ","@to coerce  perform ","@@to perform  perform ","@@from perform  perform "]}," Tree ForNode to_src":{"type":"method","name":"to_src","children":[],"call":["(begin\n  (send\n    (str \"  \") :*\n    (lvar :tabs))) + "," children_to_src ","@to to_sass ","@from to_sass "," dasherize ","   * "]}," Tree ExtendNode perform!":{"type":"method","name":"perform!","children":[],"call":["Sass SCSS CssParser  new parse_selector "," filename ","Sass SCSS CssParser  new "," line "," run_interp "]}," Tree ExtendNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi "," selector_to_src lstrip "," selector_to_src ","   * "]}," Tree ExtendNode cssize":{"type":"method","name":"cssize","children":[],"call":["extends []= "," raise ","Sass SyntaxError  new ","seq members last is_a? ! ","seq members last is_a? ","seq members last ","seq members ","parent resolved_rules members each ","parent resolved_rules members ","parent resolved_rules ","sseq members ","seq to_a join ","seq to_a ","sseq is_a? ! ","sseq is_a? ","seq members first ","seq members size > ","seq members size ","@resolved_selector members each ","@resolved_selector members ","seq members first  members ","seq members first  is_a? ! ","seq members first  is_a? ","@resolved_sseq members ector members each ","@resolved_sseq members ector members "]}," Tree DirectiveNode _to_s":{"type":"method","name":"_to_s","children":[],"call":["result rstrip + ","(if\n  (send\n    (send nil :style) :==\n    (sym :expanded))\n  (str \"\\n\")\n  (str \" \")) + "," style == "," style ","result rstrip ","result << ","child to_s + ","child to_s ","tabs + ","child is_a? ","rendered rstrip + ","rendered rstrip ","rendered lstrip ","child to_s dup ","result []= ","child invisible? "," children each "," children ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) + "," value ","   * ","tabs - "," value + "," children empty? "," has_children ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  rstrip + ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  rstrip ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  << ","rendered lstrip  rstrip + ","child to_s dup  rstrip + ","rendered lstrip  rstrip ","child to_s dup  rstrip ","rendered lstrip  lstrip ","child to_s dup  lstrip ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  []= "]}," Tree DirectiveNode to_src":{"type":"method","name":"to_src","children":[],"call":["res + + ","res + "," children_to_src "," semi "," has_children "," value ","   * "]}," Sass Tree DebugNode _perform":{"type":"method","name":"_perform","children":[],"call":["$stderr puts "," line "," filename ","res value ","res is_a? ","@expr perform ","res value  value ","@expr perform  value ","res value  is_a? ","@expr perform  is_a? "]}," Sass Tree DebugNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi ","@expr to_sass ","   * "]}," Tree CommentNode _perform":{"type":"method","name":"_perform","children":[],"call":[]}," Tree CommentNode _to_s":{"type":"method","name":"_to_s","children":[],"call":["content gsub! "," style == "," style "," value gsub "," value ","   * ","(send\n  (send\n    (lvar :tabs) :-\n    (int 1)) :-\n  (send\n    (send\n      (send nil :value) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","tabs - - "," value [] size "," value [] ","tabs - "," invisible? "," value gsub  gsub! "]}," Tree CommentNode to_scss":{"type":"method","name":"to_scss","children":[],"call":["(send nil :silent) gsub + ","(send nil :silent) gsub "," value "," value gsub gsub "," value gsub "," silent ","   * ","(send\n  (lvar :tabs) :-\n  (send\n    (send\n      (send nil :value) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","tabs - "," value [] size "," value [] "]}," Tree CommentNode to_sass":{"type":"method","name":"to_sass","children":[],"call":["content rstrip + ","content rstrip ","content gsub! ","   * "," silent ","content gsub ","  * ","spaces >= ","(send\n  (send\n    (lvar :content) :scan\n    (regexp\n      (str \"\\\\n( *)\")\n      (regopt))) :map) min ","s first size ","s first ","content scan map ","content scan ","content include? ","content sub! ","content =~ "," value gsub rstrip "," value gsub "," value "," value gsub rstrip  rstrip + "," value gsub rstrip  rstrip "," value gsub rstrip  gsub! "," value gsub rstrip  gsub ","(send\n  (send\n    (lvar :content) :scan\n    (regexp\n      (str \"\\n( *)\")\n      (regopt))) :map) min  >= ","(send\n  (send\n    (lvar : value gsub rstrip ) :scan\n    (regexp\n      (str \"\\\\n( *)\")\n      (regopt))) :map) min "," value gsub rstrip  scan map "," value gsub rstrip  scan "," value gsub rstrip  include? "," value gsub rstrip  sub! "," value gsub rstrip  =~ "]}," Sass SCSS CssParser special_directive":{"type":"method","name":"special_directive","children":[],"call":["name == "]}," Sass Script equals_warning":{"type":"method","name":"equals_warning","children":[],"call":[]}," Sass Script var_warning":{"type":"method","name":"var_warning","children":[],"call":[]}," Script String context=":{"type":"method","name":"context=","children":[],"call":["context == "]}," Sass Script Parser concat":{"type":"method","name":"concat","children":[],"call":[" node ","Operation  new "," or_expr "," nod node  "," nod or_expr  ","Op node ration  n node w ","Op or_expr ration  n or_expr w "," or_ node xpr "," or_ or_expr xpr "]}," Script Node initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script Node context=":{"type":"method","name":"context=","children":[],"call":["c context= "," children each "," children "]}," Script Literal concat":{"type":"method","name":"concat","children":[],"call":["Sass Script String  new ","other to_s "," to_s "]}," Script Functions adjust":{"type":"method","name":"adjust","children":[],"call":["color with ","Sass Util  restrict ","color send send ","amount value ","color send "," raise ","ArgumentError  new ","range last ","range first ","range include? "," assert_type ","kwargs to_a first ","kwargs to_a ","kwargs empty? ","name to_sym ","(int 0) max ","color send + ","val value ","range include? ! ","kwargs delete ","Sass Util  map_hash ","amount kwargs delete ue ","kwargs delete  kwargs delete ue "]}," Sass Script Funcall context=":{"type":"method","name":"context=","children":[],"call":["@name == "]}," Script Color value":{"type":"method","name":"value","children":[],"call":[" rgb ","Sass Util  sass_warn "]}," Less Node Expression _to_sass_tree2":{"type":"method","name":"_to_sass_tree2","children":[],"call":["Sass Script Operation  new "," _to_sass_tree ","rest [] "," _to_sass_tree2 "," _sass_split ","op == ","LESS_TO_SASS_OPERATORS  [] ","rest [] is_a? ","rest empty? ","LESS_TO_SASS_OPERATORS  []  == "]}," Sass NullCacheStore was_set?":{"type":"method","name":"was_set?","children":[],"call":["@keys [] "]}," Sass NullCacheStore _store":{"type":"method","name":"_store","children":[],"call":["@keys []= "]}," Sass NullCacheStore _retrieve":{"type":"method","name":"_retrieve","children":[],"call":[]}," Sass NullCacheStore initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass InMemoryCacheStore reset!":{"type":"method","name":"reset!","children":[],"call":[]}," Sass InMemoryCacheStore _store":{"type":"method","name":"_store","children":[],"call":["@contents []= "]}," Sass InMemoryCacheStore _retrieve":{"type":"method","name":"_retrieve","children":[],"call":["@contents [] [] ","@contents [] ","@contents [] [] == ","@contents has_key? "]}," Sass InMemoryCacheStore initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass InMemoryCacheStore _load":{"type":"method","name":"_load","children":[],"call":[]}," Sass InMemoryCacheStore _dump":{"type":"method","name":"_dump","children":[],"call":[]}," Sass FileCacheStore path_to":{"type":"method","name":"path_to","children":[],"call":["File  join "," cache_location "]}," Sass FileCacheStore _store":{"type":"method","name":"_store","children":[],"call":["f write ","f puts ","File  open ","FileUtils  mkdir_p ","File  dirname ","File  writable? ! ","File  writable? ","File  exists? "," path_to "]}," Sass FileCacheStore _retrieve":{"type":"method","name":"_retrieve","children":[],"call":["Sass Util  sass_warn "," path_to ","File  unlink ","f read ","f readline strip == ","f readline strip ","f readline ","File  open ","File  readable? "]}," Sass FileCacheStore initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass CacheStore key":{"type":"method","name":"key","children":[],"call":["Digest SHA1  hexdigest "]}," Sass CacheStore retrieve":{"type":"method","name":"retrieve","children":[],"call":["Sass Util  sass_warn "," path_to "," raise ","Sass Util  load "," _retrieve "]}," Sass CacheStore store":{"type":"method","name":"store","children":[],"call":[" _store ","Sass Util  dump "]}," Sass CacheStore _retrieve":{"type":"method","name":"_retrieve","children":[],"call":[" raise "," class "]}," Sass CacheStore _store":{"type":"method","name":"_store","children":[],"call":[" raise "," class "]}," Tree IfNode _after_load":{"type":"method","name":"_after_load","children":[],"call":["Sass Util  load "]}," Tree IfNode _around_dump":{"type":"method","name":"_around_dump","children":[],"call":["Sass Util  dump "," == "]}," TemplateHandler munge_exception":{"type":"method","name":"munge_exception","children":[],"call":[]}," TemplateHandler dependencies_changed?":{"type":"method","name":"dependencies_changed?","children":[],"call":[]}," TemplateHandler call":{"type":"method","name":"call","children":[],"call":["stylesheet inspect ","Time  now to_i ","Time  now ","Sass SyntaxError  exception_to_css ","Sass Plugin  engine_options ","Sass Plugin TemplateHandler  munge_exception ","view lookup_context ","engine render ","template data []= ","e options [] ","e options ","engine dependencies map ","engine dependencies ","template data ","Sass Engine  new ","Sass Plugin  engine_options merge ","Sass Importers Rails  new ","template virtual_path ","template source ","tree render inspect ","tree render ","template virtual_path inspect ","Sass Engine  new to_tree ","(send\n  (lvar :dependencies) :map) join ","importers [] [] ","importers [] ","e options [] inspect ","dependencies map ","(send\n  (lvar :importers) :map) join ","val [] ","importers map ","Sass Plugin  options ","Sass Util  to_hash ","Sass Util  dump ","importer == ","Sass Util  enum_with_index map ","Sass Util  enum_with_index ","Sass Plugin  options merge ","(lvar :rails_importer) + ","Sass Plugin  options [] ","Sass Plugin  engine_options [] ","(send\n  (const\n    (const\n      (const nil :Sass) :Importers) :Rails) :new) + ","Sass Plugin  Sass Engine  new _options ","Sass Engine  new  render ","Sass Engine  new  dependencies map ","engine engine dependencies  map ","Sass Engine  new  dependencies ","engine engine dependencies  ","Sass Plugin  Sass Engine  new _options merge ","Sass Engine  new to_tree  render inspect ","Sass Engine  new to_tree  render ","Sass Engine  new to_Sass Engine  new to_tree  ","(send\n  (lvar :engine dependencies ) :map) join ","Sass Util  to_hash  [] [] ","e options [] s [] [] ","Sass Util  to_hash  [] ","e options [] s [] ","engine dependencies  map ","(send\n  (lvar :Sass Util  to_hash ) :map) join ","(send\n  (lvar :e options [] s) :map) join ","Sass Util  to_hash  map ","e options [] s map ","e options []  == ","(lvar :Sass Importers Rails  new ) + ","(lvar :rails_e options [] ) + ","Sass Plugin  Sass Engine  new _options [] "]}," TemplateHandler handles_encoding?":{"type":"method","name":"handles_encoding?","children":[],"call":[]}," TemplateHandler initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Importers Rails prepare_template":{"type":"method","name":"prepare_template","children":[],"call":["Sass Engine  new ","template source ","options []= ","template identifier ","template virtual_path ","template handler syntax ","template handler "]}," Sass Importers Rails find_template":{"type":"method","name":"find_template","children":[],"call":["t handler is_a? ","t handler ","options [] find_all find ","options [] find_all ","options [] ","@lookup_context find_all find ","@lookup_context find_all "]}," Sass Importers Rails find_":{"type":"method","name":"find_","children":[],"call":[" prepare_template "," find_template ","partial ! "]}," Sass Importers Rails to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Sass Importers Rails key":{"type":"method","name":"key","children":[],"call":["uri split [] + + ","options [] to_s ","options [] ","uri split [] + ","uri split [] ","uri split "," class name + + ","uri split [] join "," class name + "," class name "," class "]}," Sass Importers Rails mtime":{"type":"method","name":"mtime","children":[],"call":["template updated_at "," find_template ","partial ! ","File  mtime to_i ","File  mtime ","template identifier ","template updated_at to_i "]}," Sass Importers Rails find":{"type":"method","name":"find","children":[],"call":[" find_ "]}," Sass Importers Rails find_relative":{"type":"method","name":"find_relative","children":[],"call":[" find_ ","base split [] join ","base split [] ","base split "]}," Sass Importers Rails initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass CacheStores Memory _store":{"type":"method","name":"_store","children":[],"call":["@contents []= "]}," Sass CacheStores Memory _retrieve":{"type":"method","name":"_retrieve","children":[],"call":["@contents [] [] ","@contents [] ","@contents [] [] == ","@contents has_key? "]}," Sass CacheStores ActiveSupport _store":{"type":"method","name":"_store","children":[],"call":["@store write ","_sass/ + "]}," Sass CacheStores ActiveSupport _retrieve":{"type":"method","name":"_retrieve","children":[],"call":["val [] ","val [] == ","@store fetch ","_sass/ + ","@store fetch  [] ","@store fetch  [] == "]}," Sass CacheStores ActiveSupport initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script Functions set":{"type":"method","name":"set","children":[],"call":["color with "," raise ","ArgumentError  new ","kwargs to_a first ","kwargs to_a ","kwargs empty? ","val value ","name to_sym "," assert_type ","kwargs delete ","Sass Util  map_hash ","kwargs delete  kwargs delete ue "]}," Script Functions scale":{"type":"method","name":"scale","children":[],"call":["color with "," raise ","ArgumentError  new ","kwargs to_a first ","kwargs to_a ","kwargs empty? ","current + ","diff * ","name to_sym ","max - ","scale > ","val value / ","val value ","color send ","(irange\n  (int -100)\n  (int 100)) include? ! ","(irange\n  (int -100)\n  (int 100)) include? ","(and\n  (send\n    (send\n      (lvar :val) :numerator_units) :==\n    (array\n      (str \"%\")))\n  (send\n    (send\n      (lvar :val) :denominator_units) :empty?)) ! ","val denominator_units empty? ","val denominator_units ","val numerator_units == ","val numerator_units "," assert_type ","kwargs delete ","Sass Util  map_hash ","color send  + ","max -  * ","val value /  > ","kwargs delete  kwargs delete ue / ","kwargs delete  kwargs delete ue ","(and\n  (send\n    (send\n      (lvar :kwargs delete ) :numerator_units) :==\n    (array\n      (str \"%\")))\n  (send\n    (send\n      (lvar :kwargs delete ) :denominator_units) :empty?)) ! ","kwargs delete  denominator_units empty? ","kwargs delete  denominator_units ","kwargs delete  numerator_units == ","kwargs delete  numerator_units "]}," Script Functions method_added":{"type":"method","name":"method_added","children":[],"call":[" update_callable_functions "]}," Script Functions update_callable_functions":{"type":"method","name":"update_callable_functions","children":[],"call":["FUNCTIONS  << ","function_name to_s "," public_instance_methods each "," public_instance_methods ","FUNCTIONS  clear "]}," Script Functions callable?":{"type":"method","name":"callable?","children":[],"call":["FUNCTIONS  include? "]}," Sass Script Funcall construct_keyword_args":{"type":"method","name":"construct_keyword_args","children":[],"call":[" raise ","Sass SyntaxError  new ","keywords keys sort first ","keywords keys sort ","keywords keys ","args << ","signature var_kwargs ","keywords size > ","keywords size ","args + ","keywords delete ","keywords has_key? ","signature args [] map ","signature args [] ","args size ","signature args ","keywords empty? ","args [] inspect ","args [] ","signature args size ","args size > ","signature var_args ! ","signature var_args ","Functions  signature ","name to_sym ","v perform ","Sass Util  map_hash ","args +  << ","signature var_kwargs +  ","Functions  signature  var_kwargs ","args +  + ","signature args +  [] map ","Functions  signature  args [] map ","signature args +  [] ","Functions  signature  args [] ","args +  size ","signature args +  ","Functions  signature  args ","args +  [] inspect ","args +  [] ","signature args +  size ","Functions  signature  args size ","args +  size > ","signature var_args +  ! ","Functions  signature  var_args ! ","signature var_args +  ","Functions  signature  var_args ","Functions  Functions  signature  "]}," Sass Tree RootNode cssize!":{"type":"method","name":"cssize!","children":[],"call":[" children unshift "," children ","c is_a? "," children reject! "," children find ","parent nil? ","Sass Util  ruby1_8? "]}," Tree CharsetNode _to_s":{"type":"method","name":"_to_s","children":[],"call":[" name "]}," Tree CharsetNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi "," name ","   * "]}," Tree EachNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Tree EachNode _perform":{"type":"method","name":"_perform","children":[],"call":[" perform_children ","environment set_local_var ","list to_a each ","list to_a ","Sass Environment  new ","@list perform ","Sass Environment  new  set_local_var ","@list perform  to_a each ","@list perform  to_a ","@@list perform  perform "]}," Tree EachNode to_src":{"type":"method","name":"to_src","children":[],"call":["(begin\n  (send\n    (str \"  \") :*\n    (lvar :tabs))) + "," children_to_src ","@list to_sass "," dasherize ","   * "]}," Tree MediaNode _to_s":{"type":"method","name":"_to_s","children":[],"call":["str gsub! "," group_end "," style == "," style ","tabs + "," tabs "]}," Tree MediaNode cssize!":{"type":"method","name":"cssize!","children":[],"call":[" children= "," Array ","new_rule cssize ","new_rule children= "," children ","parent dup ","parent is_a? "," children last group_end= "," children last "," children empty? ","parent dup  cssize ","parent dup  children= "]}," Tree MediaNode _cssize":{"type":"method","name":"_cssize","children":[],"call":["(if\n  (send\n    (send\n      (lvar :node) :children) :empty?)\n  (array)\n  (array\n    (lvar :node))) + ","node children empty? ","node children ","n query= ","n query "," query ","media each ","c is_a? ","node children reject! ","node children select "]}," Tree MediaNode cssize":{"type":"method","name":"cssize","children":[],"call":[" raise ","e modify_backtrace "," line "," filename "," _cssize ","(const nil :MediaNode) include? ","parent class "]}," Sass Script Lexer special_val":{"type":"method","name":"special_val","children":[],"call":["Script String  new "," scan ","Script Value String  new "]}," Sass Util with_extracted_values":{"type":"method","name":"with_extracted_values","children":[],"call":[" inject_values "," extract_values "]}," Sass Util inject_values":{"type":"method","name":"inject_values","children":[],"call":["s == "," merge_adjacent_strings reject "," merge_adjacent_strings ","result []= ","(send\n  (send\n    (begin\n      (send\n        (lvar :str) :+\n        (str \"{{\"))) :scan\n    (regexp\n      (str \"(.*?)(?:(\\\\{\\\\{)|\\\\{(\\\\d+)\\\\})\")\n      (regopt :m))) :map) flatten ","values [] ","n to_i ","(send\n  (lvar :str) :+\n  (str \"{{\")) scan map ","(send\n  (lvar :str) :+\n  (str \"{{\")) scan ","str + ","str gsub ","values empty? ","(send\n  (send\n    (begin\n      (send\n        (lvar :str) :+\n        (str \"{{\"))) :scan\n    (regexp\n      (str \"(.*?)(?:(\\{\\{)|\\{(\\d+)\\})\")\n      (regopt :m))) :map) flatten  []= "]}," Sass Util extract_values":{"type":"method","name":"extract_values","children":[],"call":["(send\n  (lvar :arr) :map) join ","values count - ","values count ","values << ","e gsub ","e is_a? ","arr map ","mapped join "]}," SetOptions visit_while":{"type":"method","name":"visit_while","children":[],"call":["node expr options= ","node expr "]}," SetOptions visit_warn":{"type":"method","name":"visit_warn","children":[],"call":["node expr options= ","node expr "]}," SetOptions visit_variable":{"type":"method","name":"visit_variable","children":[],"call":["node expr options= ","node expr "]}," SetOptions visit_rule":{"type":"method","name":"visit_rule","children":[],"call":["c options= ","c is_a? ","node rule each ","node rule "]}," SetOptions visit_return":{"type":"method","name":"visit_return","children":[],"call":["node expr options= ","node expr "]}," SetOptions visit_prop":{"type":"method","name":"visit_prop","children":[],"call":["node value options= ","node value ","c options= ","c is_a? ","node name each ","node name ","node value each "]}," SetOptions visit_mixin":{"type":"method","name":"visit_mixin","children":[],"call":["v options= ","node keywords each ","node keywords ","a options= ","node args each ","node args ","node kwarg_splat options= ","node kwarg_splat ","node splat options= ","node splat "]}," SetOptions visit_mixindef":{"type":"method","name":"visit_mixindef","children":[],"call":["v options= ","k options= ","node args each ","node args ","node splat options= ","node splat "]}," SetOptions visit_if":{"type":"method","name":"visit_if","children":[],"call":[" visit ","node else ","node expr options= ","node expr "]}," SetOptions visit_function":{"type":"method","name":"visit_function","children":[],"call":["v options= ","k options= ","node args each ","node args ","node splat options= ","node splat "]}," SetOptions visit_for":{"type":"method","name":"visit_for","children":[],"call":["node to options= ","node to ","node from options= ","node from "]}," SetOptions visit_extend":{"type":"method","name":"visit_extend","children":[],"call":["c options= ","c is_a? ","node selector each ","node selector "]}," SetOptions visit_each":{"type":"method","name":"visit_each","children":[],"call":["node list options= ","node list "]}," SetOptions visit_debug":{"type":"method","name":"visit_debug","children":[],"call":["node expr options= ","node expr "]}," SetOptions visit":{"type":"method","name":"visit","children":[],"call":["node instance_variable_set "]}," SetOptions initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Perform check_for_comment_interp":{"type":"method","name":"check_for_comment_interp","children":[],"call":["Sass Util  sass_warn ","node filename ","node line ","esc first size even? ","esc first size ","esc first ","e scan ","e is_a? ","node value each ","node value ","node loud "]}," Perform check_for_loud_silent_comment":{"type":"method","name":"check_for_loud_silent_comment","children":[],"call":["Sass Util  sass_warn ","node filename ","node line ","node silent ","node loud "]}," Perform run_interp_no_strip":{"type":"method","name":"run_interp_no_strip","children":[],"call":["(send\n  (lvar :text) :map) join ","val to_s ","val value ","val is_a? ","r perform ","r is_a? ","text map ","r perform to_s ","r perform  to_s ","r perform  r perform ue ","r perform  is_a? "]}," DeepCopy visit_while":{"type":"method","name":"visit_while","children":[],"call":["node expr= ","node expr deep_copy ","node expr "]}," DeepCopy visit_warn":{"type":"method","name":"visit_warn","children":[],"call":["node expr= ","node expr deep_copy ","node expr "]}," DeepCopy visit_variable":{"type":"method","name":"visit_variable","children":[],"call":["node expr= ","node expr deep_copy ","node expr "]}," DeepCopy visit_rule":{"type":"method","name":"visit_rule","children":[],"call":["node rule= ","c deep_copy ","c is_a? ","node rule map ","node rule "]}," DeepCopy visit_return":{"type":"method","name":"visit_return","children":[],"call":["node expr= ","node expr deep_copy ","node expr "]}," DeepCopy visit_prop":{"type":"method","name":"visit_prop","children":[],"call":["node value= ","node value deep_copy ","node value ","node name= ","c deep_copy ","c is_a? ","node name map ","node name ","node value map "]}," DeepCopy visit_mixin":{"type":"method","name":"visit_mixin","children":[],"call":["node keywords= ","Hash  [] ","v deep_copy ","node keywords map ","node keywords ","node args= ","a deep_copy ","node args map ","node args ","Sass Util NormalizedMap  new "]}," DeepCopy visit_mixindef":{"type":"method","name":"visit_mixindef","children":[],"call":["node args= ","v deep_copy ","k deep_copy ","node args map ","node args "]}," DeepCopy visit_if":{"type":"method","name":"visit_if","children":[],"call":["node else= "," visit ","node else ","node expr= ","node expr deep_copy ","node expr "]}," DeepCopy visit_function":{"type":"method","name":"visit_function","children":[],"call":["node args= ","v deep_copy ","k deep_copy ","node args map ","node args "]}," DeepCopy visit_for":{"type":"method","name":"visit_for","children":[],"call":["node to= ","node to deep_copy ","node to ","node from= ","node from deep_copy ","node from "]}," DeepCopy visit_extend":{"type":"method","name":"visit_extend","children":[],"call":["node selector= ","c deep_copy ","c is_a? ","node selector map ","node selector "]}," DeepCopy visit_each":{"type":"method","name":"visit_each","children":[],"call":["node list= ","node list deep_copy ","node list "]}," DeepCopy visit_debug":{"type":"method","name":"visit_debug","children":[],"call":["node expr= ","node expr deep_copy ","node expr "]}," DeepCopy visit_children":{"type":"method","name":"visit_children","children":[],"call":["parent children= "," visit ","parent children map ","parent children "]}," DeepCopy visit":{"type":"method","name":"visit","children":[],"call":["node dup "]}," Tree CommentNode lines":{"type":"method","name":"lines","children":[],"call":["s + ","e count ","e is_a? ","@value inject "]}," Sass SCSS Parser prior_snippet":{"type":"method","name":"prior_snippet","children":[],"call":[]}," Sass SCSS Parser throw_error":{"type":"method","name":"throw_error","children":[],"call":[]}," Sass Script Variable deep_copy":{"type":"method","name":"deep_copy","children":[],"call":[" dup "]}," Script UnaryOperation deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","@operand deep_copy "," dup "," dup  instance_variable_set "]}," Script StringInterpolation deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","@after deep_copy ","@mid deep_copy ","@before deep_copy "," dup "," dup  instance_variable_set "]}," Script Operation deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","@operand2 deep_copy ","@operand1 deep_copy "," dup "," dup  instance_variable_set "]}," Script Number const_missing":{"type":"method","name":"const_missing","children":[],"call":[]}," Script Number precision_factor":{"type":"method","name":"precision_factor","children":[],"call":[]}," Script Number precision=":{"type":"method","name":"precision=","children":[],"call":[]}," Script Number precision":{"type":"method","name":"precision","children":[],"call":[]}," Script Node deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["Sass Util  abstract "]}," Script Literal deep_copy":{"type":"method","name":"deep_copy","children":[],"call":[" dup "]}," Script List deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","c deep_copy "," value map "," value "," dup "," dup  instance_variable_set "]}," Script Interpolation deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","@after deep_copy ","@mid deep_copy ","@before deep_copy "," dup "," dup  instance_variable_set "]}," Script Functions index":{"type":"method","name":"index","children":[],"call":["Bool  new ","Number  new ","index + ","e eq to_bool ","e eq ","list value index ","list value "," assert_type ","list to_a index ","list to_a ","Sass Script Value DeprecatedFalse  new "," environment "," number ","Sass Script Value Bool  new ","Sass Script Value Number  new "," bool "," null "]}," Script Functions zip":{"type":"method","name":"zip","children":[],"call":["List  new ","new_list_value map ","values first zip ","values [] ","values first ","value slice! ","values each ","(lvar :length) min ","list value length ","list value ","length nil? ","values << ","list value dup "," assert_type ","lists each ","array length ","array dup ","list to_a "," list ","Sass Script Value List  new ","values first zip  map ","(lvar :(lvar :length) min ) min ","(lvar :list value length ) min ","(lvar :array length ) min ","list value (lvar :length) min  ","list value list value length  ","list value array length  ","(lvar :length) min  nil? ","list value length  nil? ","array length  nil? ","array (lvar :length) min  ","array list value length  ","array array length  ","list to_a  length ","list to_a  dup "]}," Sass Script Funcall deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","Hash  [] ","v deep_copy "," keywords map "," keywords ","a deep_copy "," args map "," args "," dup "," dup  instance_variable_set "]}," Sass Logger LogLevel ClassMethods define_logger":{"type":"method","name":"define_logger","children":[],"call":[" class_eval ","name inspect ","options fetch ","39 + ","36 + ","37 + "]}," Sass Logger LogLevel ClassMethods log_level":{"type":"method","name":"log_level","children":[],"call":[" define_logger "," log_levels update "," log_levels ","level + ","level nil? "," log_levels values max "," log_levels values ","level - "," log_levels values min ","options [] "," log_level + s update "," log_ log_levels values max s update "," log_level - s update "," log_ log_levels values min s update "," log_level + s "," log_ log_levels values max s "," log_level - s "," log_ log_levels values min s ","level +  + "," log_levels values max  + ","level -  + "," log_levels values min  + ","level +  nil? "," log_levels values max  nil? ","level -  nil? "," log_levels values min  nil? "," log_level + s values max "," log_ log_levels values max s values max "," log_level - s values max "," log_ log_levels values min s values max "," log_level + s values "," log_ log_levels values max s values "," log_level - s values "," log_ log_levels values min s values ","level +  - "," log_levels values max  - ","level -  - "," log_levels values min  - "," log_level + s values min "," log_ log_levels values max s values min "," log_level - s values min "," log_ log_levels values min s values min "]}," Sass Logger LogLevel ClassMethods log_level?":{"type":"method","name":"log_level?","children":[],"call":[" log_levels [] >= "," log_levels [] "," log_levels "]}," Sass Logger LogLevel ClassMethods log_levels=":{"type":"method","name":"log_levels=","children":[],"call":[]}," Sass Logger LogLevel ClassMethods log_levels":{"type":"method","name":"log_levels","children":[],"call":[]}," Sass Logger LogLevel ClassMethods inherited":{"type":"method","name":"inherited","children":[],"call":["subclass log_levels= ","subclass superclass log_levels dup ","subclass superclass log_levels ","subclass superclass "]}," Sass Logger LogLevel included":{"type":"method","name":"included","children":[],"call":[]}," Base _log":{"type":"method","name":"_log","children":[],"call":["Kernel  warn "," io puts "," io "]}," Base log":{"type":"method","name":"log","children":[],"call":[" _log "," logging_level? "]}," Base logging_level?":{"type":"method","name":"logging_level?","children":[],"call":[" class log_level? "," log_level "," class "," disabled ! "," disabled "]}," Base initialize":{"type":"method","name":"initialize","children":[],"call":[" log_level= "," io= "]}," Sass Importers Filesystem escape_glob_characters":{"type":"method","name":"escape_glob_characters","children":[],"call":["name gsub "]}," Sass Environment stack_trace":{"type":"method","name":"stack_trace","children":[],"call":["trace << ","msg << ","entry [] ","i == "," stack reverse each_with_index "," stack reverse "," stack "]}," Plugin Compiler write_file":{"type":"method","name":"write_file","children":[],"call":["file print ","file set_encoding ","content encoding ","Sass Util  ruby1_8? ","File  open "," options [] "," options ","Sass Util  windows? "]}," Plugin Compiler on_updating_stylesheet_with_deprecation_warning":{"type":"method","name":"on_updating_stylesheet_with_deprecation_warning","children":[],"call":[" on_updating_stylesheet_without_deprecation_warning ","Sass Util  sass_warn "]}," Perform handle_import_loop!":{"type":"method","name":"handle_import_loop!","children":[],"call":[" raise ","Sass SyntaxError  new ","msg << << ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (lvar :files)\n    (int 2)) :map) join ","Sass Util  enum_cons map ","Sass Util  enum_cons ","msg << ","files << << ","node imported_file options [] ","node imported_file options ","node imported_file ","files << ","node filename ","files size == ","files size ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact ","s [] ","@environment stack map ","@environment stack ","node filename == ","(send\n  (ivar :@stack) :map) compact ","@stack map ","(send\n  (block\n    (send\n      (send\n        (send\n          (ivar :@environment) :stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact ","f filename ","(send\n  (send\n    (send\n      (ivar :@environment) :stack) :frames) :select) map ","f is_import? ","@environment stack frames select ","@environment stack frames ","(send\n  (block\n    (send\n      (send\n        (ivar :@stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact ","(send\n  (send\n    (ivar :@stack) :frames) :select) map ","@stack frames select ","@stack frames ","(send\n  (send\n    (lvar :files) :each_cons\n    (int 2)) :map) join ","files each_cons map ","files each_cons ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (lvar :(send\n  (send\n    (ivar :@environment) :stack) :map) compact )\n    (int 2)) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (lvar :(send\n  (ivar :@stack) :map) compact )\n    (int 2)) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (lvar :(send\n  (block\n    (send\n      (send\n        (send\n          (ivar :@environment) :stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact )\n    (int 2)) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (lvar :(send\n  (block\n    (send\n      (send\n        (ivar :@stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact )\n    (int 2)) :map) join ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  << << ","(send\n  (ivar :@stack) :map) compact  << << ","(send\n  (block\n    (send\n      (send\n        (send\n          (ivar :@environment) :stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  << << ","(send\n  (block\n    (send\n      (send\n        (ivar :@stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  << << ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  << ","(send\n  (ivar :@stack) :map) compact  << ","(send\n  (block\n    (send\n      (send\n        (send\n          (ivar :@environment) :stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  << ","(send\n  (block\n    (send\n      (send\n        (ivar :@stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  << ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  size == ","(send\n  (ivar :@stack) :map) compact  size == ","(send\n  (block\n    (send\n      (send\n        (send\n          (ivar :@environment) :stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  size == ","(send\n  (block\n    (send\n      (send\n        (ivar :@stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  size == ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  size ","(send\n  (ivar :@stack) :map) compact  size ","(send\n  (block\n    (send\n      (send\n        (send\n          (ivar :@environment) :stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  size ","(send\n  (block\n    (send\n      (send\n        (ivar :@stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  size ","(send\n  (send\n    (lvar :(send\n  (send\n    (ivar :@environment) :stack) :map) compact ) :each_cons\n    (int 2)) :map) join ","(send\n  (send\n    (lvar :(send\n  (ivar :@stack) :map) compact ) :each_cons\n    (int 2)) :map) join ","(send\n  (send\n    (lvar :(send\n  (block\n    (send\n      (send\n        (send\n          (ivar :@environment) :stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact ) :each_cons\n    (int 2)) :map) join ","(send\n  (send\n    (lvar :(send\n  (block\n    (send\n      (send\n        (ivar :@stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact ) :each_cons\n    (int 2)) :map) join ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  each_cons map ","(send\n  (ivar :@stack) :map) compact  each_cons map ","(send\n  (block\n    (send\n      (send\n        (send\n          (ivar :@environment) :stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  each_cons map ","(send\n  (block\n    (send\n      (send\n        (ivar :@stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  each_cons map ","(send\n  (send\n    (ivar :@environment) :stack) :map) compact  each_cons ","(send\n  (ivar :@stack) :map) compact  each_cons ","(send\n  (block\n    (send\n      (send\n        (send\n          (ivar :@environment) :stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  each_cons ","(send\n  (block\n    (send\n      (send\n        (ivar :@stack) :frames) :select)\n    (args\n      (arg :f))\n    (send\n      (lvar :f) :is_import?)) :map) compact  each_cons "]}," Sass Environment pop_and_unuse":{"type":"method","name":"pop_and_unuse","children":[],"call":[" files_in_use delete ","popped [] "," files_in_use "," mixins_in_use delete "," mixins_in_use "," stack pop "," stack "," stack pop  [] "]}," Sass Environment files_in_use":{"type":"method","name":"files_in_use","children":[],"call":["@parent files_in_use "]}," Sass Util extract!":{"type":"method","name":"extract!","children":[],"call":["out << ","array reject! "]}," Sass Util hash_to_a":{"type":"method","name":"hash_to_a","children":[],"call":["hash sort_by "," has to_a "," has "," ruby1_8? ","hash to_a "]}," MultibyteStringScanner _forward":{"type":"method","name":"_forward","children":[],"call":["str size "]}," MultibyteStringScanner _matched":{"type":"method","name":"_matched","children":[],"call":[" _match "," matched "]}," MultibyteStringScanner _match":{"type":"method","name":"_match","children":[],"call":["str size "]}," MultibyteStringScanner _size":{"type":"method","name":"_size","children":[],"call":["str size "]}," MultibyteStringScanner unscan":{"type":"method","name":"unscan","children":[],"call":[]}," MultibyteStringScanner terminate":{"type":"method","name":"terminate","children":[],"call":[" string size "," string "]}," MultibyteStringScanner string=":{"type":"method","name":"string=","children":[],"call":[]}," MultibyteStringScanner search_full":{"type":"method","name":"search_full","children":[],"call":[" _matched "," _forward "]}," MultibyteStringScanner scan_full":{"type":"method","name":"scan_full","children":[],"call":[" _forward "," _match "]}," MultibyteStringScanner reset":{"type":"method","name":"reset","children":[],"call":[]}," MultibyteStringScanner pos=":{"type":"method","name":"pos=","children":[],"call":[" string [] bytesize "," string [] "," string "," byte_pos + "," byte_pos "," string [] bytesize -@ ","@mb_pos > ","@mb_pos - < ","@mb_pos / ","@mb_pos - "]}," MultibyteStringScanner getbyte":{"type":"method","name":"getbyte","children":[],"call":[" raise "]}," MultibyteStringScanner get_byte":{"type":"method","name":"get_byte","children":[],"call":[" raise "]}," MultibyteStringScanner skip_until":{"type":"method","name":"skip_until","children":[],"call":[" _matched "," _size "," scan_until "]}," MultibyteStringScanner skip":{"type":"method","name":"skip","children":[],"call":[" _size "," scan "]}," MultibyteStringScanner scan_until":{"type":"method","name":"scan_until","children":[],"call":[" _forward "," _matched "]}," MultibyteStringScanner scan":{"type":"method","name":"scan","children":[],"call":[" _forward "," _match "]}," MultibyteStringScanner rest_size":{"type":"method","name":"rest_size","children":[],"call":[" rest size "," rest "]}," MultibyteStringScanner pos":{"type":"method","name":"pos","children":[],"call":[]}," MultibyteStringScanner peek":{"type":"method","name":"peek","children":[],"call":[" string [] "," string "]}," MultibyteStringScanner matched_size":{"type":"method","name":"matched_size","children":[],"call":[]}," MultibyteStringScanner match?":{"type":"method","name":"match?","children":[],"call":[" _size "," check "]}," MultibyteStringScanner getch":{"type":"method","name":"getch","children":[],"call":[" _forward "," _match "]}," MultibyteStringScanner check_until":{"type":"method","name":"check_until","children":[],"call":[" _matched "]}," MultibyteStringScanner check":{"type":"method","name":"check","children":[],"call":[" _match "]}," MultibyteStringScanner initialize":{"type":"method","name":"initialize","children":[],"call":["StringScanner  new "]}," MultibyteStringScanner new":{"type":"method","name":"new","children":[],"call":[]}," Sass Selector Pseudo final?":{"type":"method","name":"final?","children":[],"call":["FINAL_SELECTORS  include? "," name first "," name "," type == "," type "]}," Sass Selector Sequence merge_initial_ops":{"type":"method","name":"merge_initial_ops","children":[],"call":["(if\n  (lvar :newline)\n  (array\n    (str \"\\n\"))\n  (array)) + ","ops1 size > ","ops2 size ","ops1 size ","lcs == ","Sass Util  lcs ","ops2 shift ! ! ","ops2 shift ! ","ops2 shift ","ops2 first == ","ops2 first ","ops1 shift ! ! ","ops1 shift ! ","ops1 shift ","ops1 first == ","ops1 first ","ops2 << ","seq2 shift ","seq2 first is_a? ","seq2 first ","ops1 << ","seq1 shift ","seq1 first is_a? ","seq1 first ","Sass Util  lcs  == ","Sass Util  Sass Util  lcs  "]}," Sass Selector Simple to_s":{"type":"method","name":"to_s","children":[],"call":[" inspect ","Sass Util  abstract "]}," Sass Selector AbstractSequence to_s":{"type":"method","name":"to_s","children":[],"call":["(send\n  (send nil :to_a) :map) join ","e to_sass ","e is_a? "," to_a map "," to_a ","Sass Util  abstract "]}," Sass SCSS Parser supports_declaration_body":{"type":"method","name":"supports_declaration_body","children":[],"call":[" ss "," tok! "," expr! "]}," Sass SCSS Parser supports_declaration_condition":{"type":"method","name":"supports_declaration_condition","children":[],"call":[" supports_declaration_body "," ss "," tok "]}," Sass SCSS Parser supports_condition_in_parens":{"type":"method","name":"supports_condition_in_parens","children":[],"call":[" supports_declaration_body "," ss "," tok! "," supports_condition "," tok ","Sass Supports Declaration  new "," sass_script "," supports_interpolation "," supports_declaration "," supports_ supports_declaration aration_body "," supports_ supports_condition ition "," supports_ supports_interpolation olation "," supports_ supports_declaration aration "]}," Sass SCSS Parser supports_operator":{"type":"method","name":"supports_operator","children":[],"call":[" expr! "," ss "," tok "," tok! "," supports_condition_in_parens ","Sass Supports Operator  new "," supports_Sass Supports Operator  new ition_in_parens "," supports_ supports_condition_in_parens ition_in_parens "]}," Sass SCSS Parser supports_negation":{"type":"method","name":"supports_negation","children":[],"call":[" expr! "," ss "," tok ","Sass Supports Negation  new "]}," Sass SCSS Parser supports_condition":{"type":"method","name":"supports_condition","children":[],"call":[" supports_declaration_condition "," supports_operator "," supports_negation "," supports_interpolation "]}," Sass SCSS Parser supports_directive":{"type":"method","name":"supports_directive","children":[],"call":[" directive_body "," expr! "," str "," tok! "," block_contents ","node has_children= "," node ","Sass Tree SupportsNode  new ","(str \"@\") strip "," node  has_children= ","Sass Tree SupportsNode  new  has_children= ","  node  "," Sass Tree SupportsNode  new  "]}," Sass SCSS Parser moz_document_function":{"type":"method","name":"moz_document_function","children":[],"call":[" ss "," function "," tok "," interpolation ","allow_var ! "," _interp_string "," interp_uri "]}," Sass SCSS Parser _moz_document_directive":{"type":"method","name":"_moz_document_directive","children":[],"call":[" directive_body "," expr! "," ss "," tok "," str ","res flatten ","res << ","res << << "," loop "," dire tok tive_body "]}," Sass SCSS Parser prefixed_directive":{"type":"method","name":"prefixed_directive","children":[],"call":[" send ","PREFIXED_DIRECTIVES  include? ","name gsub gsub to_sym ","name gsub gsub ","name gsub "," deprefix gsub to_sym "," deprefix gsub "," deprefix "," deprefix tr to_sym "," deprefix tr ","name gsub gsub to_name gsub gsub to_sym  ","name gsub gsub to_ deprefix gsub to_sym  ","name gsub gsub to_ deprefix tr to_sym  "," deprefix gsub to_name gsub gsub to_sym  "," deprefix gsub to_ deprefix gsub to_sym  "," deprefix gsub to_ deprefix tr to_sym  "," deprefix tr to_name gsub gsub to_sym  "," deprefix tr to_ deprefix gsub to_sym  "," deprefix tr to_ deprefix tr to_sym  "]}," Sass SCSS Parser directive_body":{"type":"method","name":"directive_body","children":[],"call":[" tok! "," block_contents ","node has_children= "," tok "," node ","Sass Tree DirectiveNode  new ","value strip "," node  has_children= ","Sass Tree DirectiveNode  new  has_children= ","  node  "," Sass Tree DirectiveNode  new  "]}," Listener run_events":{"type":"method","name":"run_events","children":[],"call":["event [] ","File  basename ","File  dirname ","paths each ","event nil? ","paths nil? "]}," Listener file_event_fn":{"type":"method","name":"file_event_fn","children":[],"call":["event call ","base == "," lambda "]}," Listener start!":{"type":"method","name":"start!","children":[],"call":["(send\n  (const\n    (const nil :Listen) :MultiListener) :new\n  (splat\n    (send\n      (ivar :@directories) :keys))) start "," run_events ","e [] ","removed [] ","added [] ","modified [] ","events each ","@directories each ","File  dirname ","removed group_by ","added group_by ","modified group_by ","Listen MultiListener  new ","@directories keys ","(send\n  (const\n    (const nil :Listen) :MultiListener) :new\n  (splat\n    (lvar :args))) start ","args << ","Sass Util  windows? ","@directories keys dup ","(send\n  (const\n    (const nil :Listen) :MultiListener) :new\n  (splat\n    (lvar :@directories keys dup ))) start ","@directories keys dup  << "]}," Listener file":{"type":"method","name":"file","children":[],"call":[" directory "," file_event_fn ","events [] ","File  dirname ","File  basename "]}," Listener directory":{"type":"method","name":"directory","children":[],"call":["(or-asgn\n  (send\n    (ivar :@directories) :[]\n    (lvar :path))\n  (array)) << ","@directories [] ","(or-asgn\n  (send\n    (ivar :@directories) :[]\n    (send\n      (const nil :File) :expand_path\n      (lvar :path)))\n  (array)) << ","File  expand_path "]}," Listener initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","e is_a? "," start! "]}," Sass CSS first_simple_sel":{"type":"method","name":"first_simple_sel","children":[],"call":["sseq members first ","sseq members ","sseq is_a? "," first_sseq "," first_sseq  members first "," first_sseq  members "," first_sseq  is_a? "," first_ first_sseq  "]}," Sass CSS first_sseq":{"type":"method","name":"first_sseq","children":[],"call":[" first_seq members first "," first_seq members "," first_seq "]}," Sass CSS first_seq":{"type":"method","name":"first_seq","children":[],"call":["rule parsed_rules members first ","rule parsed_rules members ","rule parsed_rules "]}," Sass CSS make_sseq":{"type":"method","name":"make_sseq","children":[],"call":[" make_seq ","Sass Selector SimpleSequence  new "]}," Sass CSS make_seq":{"type":"method","name":"make_seq","children":[],"call":[" make_cseq ","Sass Selector Sequence  new "]}," Sass CSS make_cseq":{"type":"method","name":"make_cseq","children":[],"call":["Sass Selector CommaSequence  new "]}," Sass CSS dump_selectors":{"type":"method","name":"dump_selectors","children":[],"call":[" dump_selectors ","child rule= ","child parsed_rules to_s ","child parsed_rules ","child is_a? ","root children each ","root children "]}," Sass CSS nest_seqs":{"type":"method","name":"nest_seqs","children":[],"call":[" nest_seqs ","root children each ","root children ","root children uniq! ","root children compact! ","current_rule << ","child parsed_rules= "," make_seq ","child children ","current_rule children ","rest empty? ","current_rule parsed_rules= ","Tree RuleNode  new "," first_sseq != "," first_sseq ","current_rule nil? ","seq members [] ","seq members ","seq members first ","sseq == ","seq members reject! "," first_seq ","child is_a? ","root children map! "," nest_ first_seq s ","Tree RuleNode  new  << "," make_ first_seq  ","Tree RuleNode  new  children ","Tree RuleNode  new  parsed_rules= "," first_s first_seq  != "," first_s first_seq  ","Tree RuleNode  new  nil? "," first_seq  members [] "," first_seq  members "," first_seq  members first ","s first_seq  == "," first_seq  members reject! "," first_ first_seq  "]}," Sass CSS parse_selectors":{"type":"method","name":"parse_selectors","children":[],"call":["child parsed_rules= ","parser parse_selector ","Sass SCSS CssParser  new ","child line ","child filename ","child rule first ","child rule ","child is_a? "," parse_selectors ","root children each ","root children ","Sass SCSS CssParser  new  parse_selector "]}," Sass Util glob":{"type":"method","name":"glob","children":[],"call":["Dir  glob ","path gsub "," windows? "," block_given? ","path tr ","path gsub  gsub ","path tr  gsub ","path gsub  tr ","path tr  tr "]}," Sass Util check_range":{"type":"method","name":"check_range","children":[],"call":[" raise ","ArgumentError  new ","range last ","range first ","grace include? ","value - ","range include? ","value value ","value is_a? ","value to_s ","value value  - ","value value  value value  ","value value  is_a? ","value value  to_s "]}," Sass Tree Node inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :children) :map) join ","c inspect "," children map "," children "," class "," class to_s "," has_children "]}," CheckNesting initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree ExtendNode disabled?":{"type":"method","name":"disabled?","children":[],"call":[]}," Tree ExtendNode disable!":{"type":"method","name":"disable!","children":[],"call":[]}," Tree DirectiveNode name":{"type":"method","name":"name","children":[],"call":[" value gsub "," value "," value first gsub "," value first "]}," Sass Util subsequence?":{"type":"method","name":"subsequence?","children":[],"call":["seq1 [] == ","seq2 [] ","seq1 [] ","j == ","seq2 size ","i == ","seq1 size "," loop "]}," Extend visit_rule":{"type":"method","name":"visit_rule","children":[],"call":["node resolved_rules= ","node resolved_rules do_extend ","node resolved_rules "]}," Extend visit_children":{"type":"method","name":"visit_children","children":[],"call":["@parent_directives pop ","parent is_a? ","@parent_directives push "]}," Extend visit":{"type":"method","name":"visit","children":[],"call":[" raise ","e modify_backtrace ","node line ","node filename "]}," Extend initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector SimpleSequence check_directives_match!":{"type":"method","name":"check_directives_match!","children":[],"call":["Sass Util  sass_warn ","extend directives last name ","extend directives last ","extend directives ","extend node filename ","extend node ","extend node line ","Sass Util  subsequence? ","d value ","parent_directives map ","extend directives map ","d resolved_value "," raise ","Sass SyntaxError  new ","extend target join ","extend target ","extend node extend node filename  ","extend node extend node line  "]}," Sass Util macruby?":{"type":"method","name":"macruby?","children":[],"call":["RUBY_ENGINE  == "]}," Sass Version version_date":{"type":"method","name":"version_date","children":[],"call":["DateTime  parse ","File  read strip ","File  read "," scope ","File  exists? ","Sass Util  scope ","File  exist? "]}," Tree WhileNode subnodes":{"type":"method","name":"subnodes","children":[],"call":[" Array "," expr "]}," Sass Tree WarnNode subnodes":{"type":"method","name":"subnodes","children":[],"call":[" Array "," expr "]}," Sass Tree VariableNode subnodes":{"type":"method","name":"subnodes","children":[],"call":[" Array "," expr "]}," Tree RuleNode subnodes":{"type":"method","name":"subnodes","children":[],"call":["r is_a? "," rule select "," rule "]}," Sass Tree ReturnNode subnodes":{"type":"method","name":"subnodes","children":[],"call":[" Array "," expr "]}," Tree PropNode subnodes":{"type":"method","name":"subnodes","children":[],"call":["(send\n  (send nil :Array\n    (send nil :name)) :select) + "," value ","n is_a? "," Array select "," Array "," name "]}," Sass Tree Node after_sass_cache_store":{"type":"method","name":"after_sass_cache_store","children":[],"call":[" options= "]}," Sass Tree Node before_sass_cache_store":{"type":"method","name":"before_sass_cache_store","children":[],"call":[" options= "," options ","  options pti options ns= ","  options pti options ns "]}," Tree MixinNode subnodes":{"type":"method","name":"subnodes","children":[],"call":[" Array + ","(or\n  (send nil :keywords)\n  (hash)) values "," keywords "," Array "," args "]}," Sass Tree MixinDefNode subnodes":{"type":"method","name":"subnodes","children":[],"call":[" Array "," args "]}," Tree IfNode subnodes":{"type":"method","name":"subnodes","children":[],"call":[" Array + "," Array "," else "," expr "]}," Sass Tree FunctionNode subnodes":{"type":"method","name":"subnodes","children":[],"call":[" Array "," args "]}," Tree ForNode subnodes":{"type":"method","name":"subnodes","children":[],"call":[" Array + "," Array "," to "," from "]}," Tree EachNode subnodes":{"type":"method","name":"subnodes","children":[],"call":[" Array "," list "]}," Sass Tree DebugNode subnodes":{"type":"method","name":"subnodes","children":[],"call":[" Array "," expr "]}," SetOptions visit_mixin_def":{"type":"method","name":"visit_mixin_def","children":[],"call":["v options= ","k options= ","node args each ","node args "]}," DeepCopy visit_mixin_def":{"type":"method","name":"visit_mixin_def","children":[],"call":["node args= ","v deep_copy ","k deep_copy ","node args map ","node args "]}," Sass load_paths":{"type":"method","name":"load_paths","children":[],"call":[]}," Sass Util group_by_to_a":{"type":"method","name":"group_by_to_a","children":[],"call":["arr []= ","order [] ","(send\n  (lvar :enum) :group_by) each ","order []= ","order size ","order include? ","block [] ","enum group_by ","enum group_by to_a "," ruby1_8? ","groups each ","(send\n  (lvar :enum) :group_by) to_a "]}," Sass Util SubsetMap each_value":{"type":"method","name":"each_value","children":[],"call":["@vals each "]}," ToCss visit_cssimport":{"type":"method","name":"visit_cssimport","children":[],"call":[" visit_directive "]}," ToCss visit_supports":{"type":"method","name":"visit_supports","children":[],"call":[" visit_media "]}," SetOptions visit_supports":{"type":"method","name":"visit_supports","children":[],"call":["node condition options= ","node condition "]}," SetOptions visit_cssimport":{"type":"method","name":"visit_cssimport","children":[],"call":["c options= ","c is_a? ","node query each ","node query "]}," SetOptions visit_media":{"type":"method","name":"visit_media","children":[],"call":["c options= ","c is_a? ","node query each ","node query ","node query options= "]}," SetOptions visit_directive":{"type":"method","name":"visit_directive","children":[],"call":["c options= ","c is_a? ","node value each ","node value "]}," Perform stack_trace":{"type":"method","name":"stack_trace","children":[],"call":["trace << ","msg << ","entry [] ","i == ","stack each_with_index ","e1 []= ","e2 [] ","stack each_cons ","(send\n  (ivar :@stack) :map) reverse ","e dup ","@stack map ","(begin\n  (if\n    (send\n      (lvar :i) :==\n      (int 0))\n    (str \"on\")\n    (str \"from\"))) + + ","caller name ","(begin\n  (if\n    (send\n      (lvar :i) :==\n      (int 0))\n    (str \"on\")\n    (str \"from\"))) + ","frame filename ","frame line ","Sass Util  enum_with_index map ","Sass Util  enum_with_index ","Sass Util  enum_cons ","@stack frames reverse + ","@stack frames reverse ","@stack frames ","(send\n  (ivar :@stack) :map) reverse  each_with_index ","(send\n  (ivar :@stack) :map) reverse  each_cons ","(send\n  (ivar :@(send\n  (ivar :@stack) :map) reverse ) :map) reverse ","@(send\n  (ivar :@stack) :map) reverse  map ","@(send\n  (ivar :@stack) :map) reverse  frames reverse + ","@(send\n  (ivar :@stack) :map) reverse  frames reverse ","@(send\n  (ivar :@stack) :map) reverse  frames "]}," Perform visit_cssimport":{"type":"method","name":"visit_cssimport","children":[],"call":["parser parse_media_query_list ","node resolved_query ","Sass SCSS StaticParser  new ","node line ","node filename "," run_interp ","node query ","node resolved_uri= ","node uri ","node query perform ","node query= ","node query deep_copy ","node options [] ","node options ","node query empty? ! ","node query empty? ","node supports_condition perform ","node supports_condition ","Sass SCSS StaticParser  new  parse_media_query_list "]}," Perform visit_supports":{"type":"method","name":"visit_supports","children":[],"call":["node condition perform ","node condition ","node condition= ","node condition deep_copy "]}," Perform visit_media":{"type":"method","name":"visit_media","children":[],"call":["parser parse_media_query_list ","node resolved_query ","Sass SCSS StaticParser  new ","node line ","node filename "," run_interp ","node query ","node query perform ","node query= ","node query deep_copy ","node options [] ","node options ","Sass SCSS StaticParser  new  parse_media_query_list "]}," Perform visit_content":{"type":"method","name":"visit_content","children":[],"call":["@stack pop "," raise ","e add_backtrace ","node line ","e modify_backtrace ","trace_node children= ","(send\n  (lvar :content) :map) flatten "," visit ","c dup ","content map "," with_environment ","@environment caller ","Sass Tree TraceNode  from_node ","@stack push ","node filename ","@environment content ","Sass SyntaxError  new ","content_env caller= ","Sass Environment  new ","@environment stack with_mixin ","@environment stack ","@stack with_mixin ","Sass Tree TraceNode  from_node  children= ","(send\n  (lvar :@environment content ) :map) flatten ","@environment content  map ","@environment @environment content  ","@environment content _env caller= ","Sass Environment  new  caller= "]}," Perform perform_arguments":{"type":"method","name":"perform_arguments","children":[],"call":[" raise ","e is_a? ","e nil? ","(and\n  (lvar :arg_list)\n  (send\n    (lvar :arg_list) :keywords_accessed)) ! ","arg_list keywords_accessed ","env set_local_var ","callable splat name ","callable splat ","arg_list options= ","env options ","Sass Script Value ArgList  new ","args [] ","callable args length ","callable args ","var name ","Sass SyntaxError  new ","var inspect ","default perform ","keywords delete ","(begin\n  (lvar :desc)) + ","keywords has_key? ","callable args zip ","Sass Environment  new ","callable environment ","splat separator ","splat to_a ","passed == ","takes == ","args size ","callable args size ","callable splat ! ","args size > ","(send\n  (lvar :unknown_args) :map) join ","unknown_args map ","unknown_args length > ","unknown_args length ","unknown_args any? ","(str \"Argument $\") + ","unknown_args include? ","callable splat underscored_name ","Sass Util  array_minus ","var first underscored_name ","var first ","callable args map ","keywords keys ","keywords empty? ","splat keywords_accessed= ","splat keywords ","splat keywords_accessed ","callable name ","callable type ","callable type capitalize ","keywords dup ","var underscored_name ","keywords include? ","splat keywords empty? ! ","splat keywords empty? ","Sass Util  sass_warn ","(str \"WARNING: \") + + + ","(str \"WARNING: \") + + ","(str \"WARNING: \") + ","environment stack to_s gsub ","  * ","environment stack to_s ","environment stack ","args size - <= ","args size - ","splat to_a size ","(and\n  (lvar :Sass Script Value ArgList  new )\n  (send\n    (lvar :Sass Script Value ArgList  new ) :keywords_accessed)) ! ","(and\n  (lvar :arg_list)\n  (send\n    (lvar :arg_list) :splat keywords _accessed)) ! ","(and\n  (lvar :arg_list)\n  (send\n    (lvar :arg_list) :keywords dup _accessed)) ! ","Sass Script Value ArgList  new  keywords_accessed ","arg_list splat keywords _accessed ","arg_list keywords dup _accessed ","Sass Environment  new  set_local_var ","Sass Script Value ArgList  new  options= ","Sass Environment  new  options ","splat keywords  delete ","keywords dup  delete ","splat keywords  has_key? ","keywords dup  has_key? ","callable Sass Environment  new ironment ","args size  == ","callable args size  == ","(send\n  (lvar :Sass Util  array_minus ) :map) join ","Sass Util  array_minus  map ","Sass Util  array_minus  length > ","Sass Util  array_minus  length ","Sass Util  array_minus  any? ","Sass Util  array_minus  include? ","splat keywords  keys ","keywords dup  keys ","splat keywords  empty? ","keywords dup  empty? ","splat splat keywords _accessed= ","splat keywords dup _accessed= ","splat splat keywords  ","splat keywords dup  ","splat splat keywords _accessed ","splat keywords dup _accessed ","splat keywords  dup ","keywords dup  dup ","splat keywords  include? ","keywords dup  include? ","splat splat keywords  empty? ! ","splat keywords dup  empty? ! ","splat splat keywords  empty? ","splat keywords dup  empty? ","Sass Environment  new ironment stack to_s gsub ","Sass Environment  new ironment stack to_s ","Sass Environment  new ironment stack "]}," Extend check_extends_fired!":{"type":"method","name":"check_extends_fired!","children":[],"call":[" raise ","Sass SyntaxError  new ","ex node line ","ex node ","ex node filename ","ex target join ","ex target ","ex extender ","ex result == ","ex result ","ex node optional? ","extends each_value ","ex success "]}," DeepCopy visit_supports":{"type":"method","name":"visit_supports","children":[],"call":["node condition= ","node condition deep_copy ","node condition "]}," DeepCopy visit_media":{"type":"method","name":"visit_media","children":[],"call":["node query= ","c deep_copy ","c is_a? ","node query map ","node query ","node query deep_copy "," query deep_copy "," query "]}," DeepCopy visit_directive":{"type":"method","name":"visit_directive","children":[],"call":["node value= ","c deep_copy ","c is_a? ","node value map ","node value "]}," Cssize bubble":{"type":"method","name":"bubble","children":[],"call":["node children last group_end= ","node children last ","node children ","node children empty? ","node children= "," Array "," visit "," with_parent ","new_rule children= "," parent dup "," parent "," parent is_a? ","Bubble  new "," parent dup  children= "]}," Cssize visit_trace":{"type":"method","name":"visit_trace","children":[],"call":[" raise ","e add_backtrace ","node line ","node filename ","e modify_backtrace ","node name ","(send\n  (send\n    (lvar :node) :children) :map) flatten "," visit ","node children map ","node children "," visit_children_without_parent "]}," Cssize visit_supports":{"type":"method","name":"visit_supports","children":[],"call":[" bubble "," debubble ","node children "," parent is_a? "," parent ","node has_children "," visit_directive "]}," Convert media_interp_to_src":{"type":"method","name":"media_interp_to_src","children":[],"call":["(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (lvar :interp)) :map) join ","r to_sass ","after [] == ","after [] ","before =~ ","before [] == ","before [] ","after is_a? ","before is_a? ","interp [] ","i + ","i - ","r is_a? ","Sass Util  enum_with_index map ","Sass Util  enum_with_index "]}," Convert interp_to_src":{"type":"method","name":"interp_to_src","children":[],"call":["(send\n  (lvar :interp) :map) join ","r to_sass ","r is_a? ","interp map "]}," Convert visit_content":{"type":"method","name":"visit_content","children":[],"call":[" semi "," tab_str "]}," Convert visit_cssimport":{"type":"method","name":"visit_cssimport","children":[],"call":[" semi ","str << "," interp_to_src ","node query ","node query empty? ","node uri "," tab_str ","node uri to_sass ","node uri is_a? ","node query to_src ","node supports_condition to_src ","node supports_condition "]}," Convert visit_supports":{"type":"method","name":"visit_supports","children":[],"call":["node condition to_src ","node condition ","node name "," tab_str "]}," CheckNesting invalid_content_parent?":{"type":"method","name":"invalid_content_parent?","children":[],"call":["@current_mixin_def has_content= "]}," CheckNesting visit_mixindef":{"type":"method","name":"visit_mixindef","children":[],"call":[]}," Tree TraceNode from_node":{"type":"method","name":"from_node","children":[],"call":[]}," Tree TraceNode initialize":{"type":"method","name":"initialize","children":[],"call":[" has_children= "]}," Tree SupportsNode bubbles?":{"type":"method","name":"bubbles?","children":[],"call":[]}," Tree SupportsNode invisible?":{"type":"method","name":"invisible?","children":[],"call":["c invisible? "," children all? "," children "]}," Tree SupportsNode resolved_value":{"type":"method","name":"resolved_value","children":[],"call":[" condition to_css "," condition "," name "]}," Tree SupportsNode value":{"type":"method","name":"value","children":[],"call":[" raise "]}," Tree SupportsNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree RuleNode invisible?":{"type":"method","name":"invisible?","children":[],"call":["seq has_placeholder? "," resolved_rules members all? "," resolved_rules members "," resolved_rules ","seq invisible? "]}," Tree PropNode invisible?":{"type":"method","name":"invisible?","children":[],"call":[" resolved_value empty? "," resolved_value "," custom_property? ! "," custom_property? "]}," Sass Tree Node bubbles?":{"type":"method","name":"bubbles?","children":[],"call":[]}," Tree MediaNode bubbles?":{"type":"method","name":"bubbles?","children":[],"call":[]}," Tree MediaNode invisible?":{"type":"method","name":"invisible?","children":[],"call":["c invisible? "," children all? "," children "]}," Tree MediaNode resolved_value":{"type":"method","name":"resolved_value","children":[],"call":[" resolved_query to_css "," resolved_query "," query to_css "," query "]}," Tree MediaNode name":{"type":"method","name":"name","children":[],"call":[]}," Tree ExtendNode optional?":{"type":"method","name":"optional?","children":[],"call":[]}," Tree DirectiveNode resolved":{"type":"method","name":"resolved","children":[],"call":[]}," Tree CssImportNode resolved_value":{"type":"method","name":"resolved_value","children":[],"call":["str << "," resolved_query to_css "," resolved_query "," resolved_uri "," query to_css "," query "," supports_condition to_css "," supports_condition "]}," Tree CssImportNode value":{"type":"method","name":"value","children":[],"call":[" raise "]}," Tree CssImportNode resolved":{"type":"method","name":"resolved","children":[],"call":[]}," Tree CssImportNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Supports Interpolation options=":{"type":"method","name":"options=","children":[],"call":["@value options= "]}," Supports Interpolation deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["copy value= ","@value deep_copy "," dup "," dup  value= ","@value deep_ dup  "]}," Supports Interpolation to_src":{"type":"method","name":"to_src","children":[],"call":["@value to_sass "]}," Supports Interpolation to_css":{"type":"method","name":"to_css","children":[],"call":[]}," Supports Interpolation perform":{"type":"method","name":"perform","children":[],"call":["val to_s ","val value ","val is_a? "," value perform "," value "," value perform to_s "," value perform  to_s "," value perform   value perform ue "," value perform  is_a? ","  value perform ue perform ","  value perform ue ","  value perform ue perform to_s "]}," Supports Interpolation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Supports Declaration options=":{"type":"method","name":"options=","children":[],"call":["@value options= ","@name options= "]}," Supports Declaration deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["copy value= ","@value deep_copy ","copy name= ","@name deep_copy "," dup "," dup  value= ","@value deep_ dup  "," dup  name= ","@name deep_ dup  "]}," Supports Declaration to_src":{"type":"method","name":"to_src","children":[],"call":["@value to_sass ","@name to_sass "]}," Supports Declaration to_css":{"type":"method","name":"to_css","children":[],"call":[]}," Supports Declaration perform":{"type":"method","name":"perform","children":[],"call":[" value perform "," value "," name perform "," name "]}," Supports Declaration initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Supports Negation parens":{"type":"method","name":"parens","children":[],"call":["@condition is_a? "]}," Supports Negation options=":{"type":"method","name":"options=","children":[],"call":[" condition options= "," condition "]}," Supports Negation deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["copy condition= "," condition deep_copy "," condition "," dup "," dup  condition= "," condition deep_ dup  "]}," Supports Negation to_src":{"type":"method","name":"to_src","children":[],"call":[" parens ","@condition to_src "]}," Supports Negation to_css":{"type":"method","name":"to_css","children":[],"call":[" parens ","@condition to_css "]}," Supports Negation perform":{"type":"method","name":"perform","children":[],"call":["@condition perform "]}," Supports Negation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Supports Operator right_parens":{"type":"method","name":"right_parens","children":[],"call":["@right is_a? "]}," Supports Operator left_parens":{"type":"method","name":"left_parens","children":[],"call":["@left is_a? "]}," Supports Operator options=":{"type":"method","name":"options=","children":[],"call":["@right options= ","@left options= "]}," Supports Operator deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["copy right= ","@right deep_copy ","copy left= ","@left deep_copy "," dup "," dup  right= ","@right deep_ dup  "," dup  left= ","@left deep_ dup  "]}," Supports Operator to_src":{"type":"method","name":"to_src","children":[],"call":[" right_parens ","@right to_src "," op "," left_parens ","@left to_src "," parens "]}," Supports Operator to_css":{"type":"method","name":"to_css","children":[],"call":[" right_parens ","@right to_css "," op "," left_parens ","@left to_css "," parens "]}," Supports Operator perform":{"type":"method","name":"perform","children":[],"call":["@right perform ","@left perform "]}," Supports Operator initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Supports Condition options=":{"type":"method","name":"options=","children":[],"call":["Sass Util  abstract "]}," Supports Condition deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["Sass Util  abstract "]}," Supports Condition to_src":{"type":"method","name":"to_src","children":[],"call":["Sass Util  abstract "]}," Supports Condition to_css":{"type":"method","name":"to_css","children":[],"call":["Sass Util  abstract "]}," Supports Condition perform":{"type":"method","name":"perform","children":[],"call":["Sass Util  abstract "]}," Sass Selector SelectorPseudoClass specificity":{"type":"method","name":"specificity","children":[],"call":[]}," Sass Selector Pseudo specificity":{"type":"method","name":"specificity","children":[],"call":[" type == "," type ","min == ","Sass Util  max ","Sass Util  min ","spec end ","spec begin ","spec is_a? ","seq specificity "," selector members each "," selector members "," selector "," normalized_name == "," normalized_name ","Sass Util  min  == ","Sass Util  max  == ","Sass Util  Sass Util  max  ","Sass Util  Sass Util  min  ","seq specificity  end ","seq specificity  begin ","seq specificity  is_a? ","seq seq specificity ificity "]}," Sass Selector Attribute specificity":{"type":"method","name":"specificity","children":[],"call":[]}," Sass Selector Element specificity":{"type":"method","name":"specificity","children":[],"call":[]}," Sass Selector Universal specificity":{"type":"method","name":"specificity","children":[],"call":[]}," Sass Selector Placeholder specificity":{"type":"method","name":"specificity","children":[],"call":[]}," Sass Selector Placeholder to_a":{"type":"method","name":"to_a","children":[],"call":[]}," Sass Selector Placeholder initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Id specificity":{"type":"method","name":"specificity","children":[],"call":["SPECIFICITY_BASE  ** "]}," Sass Selector Class specificity":{"type":"method","name":"specificity","children":[],"call":[]}," Sass Selector SimpleSequence with_more_sources":{"type":"method","name":"with_more_sources","children":[],"call":["sseq sources merge ","sseq sources ","sseq members= "," members dup "," members "," dup ","sseq sources= "," sources | "," sources "," dup  sources merge "," dup  sources "," dup  members= "," dup  sources= "]}," Sass Selector SimpleSequence subject?":{"type":"method","name":"subject?","children":[],"call":[]}," Sass Selector Sequence extended_not_expanded_to_s":{"type":"method","name":"extended_not_expanded_to_s","children":[],"call":["(send\n  (lvar :extended_not_expanded) :map) join ","choices join ","choices first ","choices include? ! ","choices include? ","choices size == ","choices size ","sel join ","sel first to_s ","sel first ","sel size == ","sel size ","choices map ","extended_not_expanded map "]}," Sass Selector Sequence _sources":{"type":"method","name":"_sources","children":[],"call":["s merge ","sseq_or_op sources ","sseq_or_op is_a? ","seq map ","Set  new ","Set  new  merge ","Set  new Set  new eq_or_op Set  new ourceSet  new  ","Set  new Set  new eq_or_op iSet  new _a? ","Set  new eq map "]}," Sass Selector Sequence path_has_two_subjects?":{"type":"method","name":"path_has_two_subjects?","children":[],"call":["sseq_or_op subject? ","sseq_or_op is_a? ","path each "]}," Sass Selector Sequence trim":{"type":"method","name":"trim","children":[],"call":[" _superselector? "," _specificity >= "," _specificity ","seqs2 any? ","seqs1 equal? ","seqses any? ","seq specificity "," _sources map "," _sources ","seqs1 reject ","seqses map ","seqs1 object_id == ","seqs2 object_id ","seqs1 object_id ","result []= ","result any? ","(send\n  (send nil :_sources\n    (lvar :seq1)) :map) min ","seqses each_with_index ","seqses dup ","seqses size > ","seqses size ","(send\n  (send nil :_sources\n    (lvar :seq1)) :map) max ","Sass Util  flatten ","spec2 >= ","spec2 begin ","spec2 is_a? ","spec max ","spec is_a? ","result flatten ","seqses flatten "," _seq specificity ificity >= "," _seq specificity ificity ","seq seq specificity ificity ","seqses dup  []= ","seqses dup  any? ","spec2 begin  >= "," _specificity  >= ","seq specificity 2 >= ","spec2 begin  begin "," _specificity  begin ","seq specificity 2 begin ","spec2 begin  is_a? "," _specificity  is_a? ","seq specificity 2 is_a? ","seq specificity  max ","seq specificity  is_a? ","seqses dup  flatten "]}," Sass Selector Sequence parent_superselector?":{"type":"method","name":"parent_superselector?","children":[],"call":[" _superselector? ","seq2 + ","seq1 + ","Sass Selector SimpleSequence  new ","Sass Selector Placeholder  new "]}," Sass Selector Sequence _superselector?":{"type":"method","name":"_superselector?","children":[],"call":[" _superselector? ","seq2 [] ","si + ","seq1 [] ","seq2 [] == ","seq2 [] is_a? ","seq1 [] == ","seq2 [] != ","seq1 [] is_a? ","seq1 first superselector? ","seq1 first ","e is_a? ","i == ","seq2 size - ","seq2 size ","Sass Util  enum_with_index find ","Sass Util  enum_with_index ","seq2 last ","seq1 size == ","seq1 size ","seq1 size > ","seq2 first is_a? ","seq2 first ","seq1 first is_a? ","seq2 last is_a? ","seq1 last is_a? ","seq1 last ","e == ","seq2 reject ","seq1 reject ","seq2 length > ","seq2 length ","seq1 length == ","seq1 length ","seq2 each_with_index find ","seq2 each_with_index "]}," Sass Selector Sequence merge_final_ops":{"type":"method","name":"merge_final_ops","children":[],"call":[" merge_final_ops ","res unshift ","seq2 pop ","seq1 pop ","seq1 last superselector? ","seq2 last ","seq1 last ","op2 == ","seq2 last superselector? ","op1 == ","sel1 unify ","sel2 subject? ","sel2 members ","seq2 push ","(str \"~\") include? ","seq1 push ","(array\n  (lvar :tilde_sel)\n  (str \"~\")\n  (lvar :plus_sel)\n  (str \"+\")) compact ","plus_sel unify ","tilde_sel subject? ","tilde_sel members ","tilde_sel superselector? ","(array\n  (lvar :sel1)\n  (str \"~\")\n  (lvar :sel2)\n  (str \"~\")) compact ","sel2 superselector? ","sel1 superselector? ","ops2 first ","ops1 first ","(if\n  (send\n    (send\n      (lvar :ops1) :size) :>\n    (send\n      (lvar :ops2) :size))\n  (lvar :ops1)\n  (lvar :ops2)) reverse ","ops1 size > ","ops2 size ","ops1 size ","lcs == ","Sass Util  lcs ","ops2 size > ","ops2 empty? ","ops1 empty? ","o == ","ops2 reject! ","ops1 reject! ","ops2 << ","seq2 last is_a? ","ops1 << ","seq1 last is_a? "," superselector? "," subweave_superselector? ","seq1 pop  unify ","seq2 pop  subject? ","seq2 pop  members ","(array\n  (lvar :sel1)\n  (str \"~\")\n  (lvar :seq2 pop )\n  (str \"~\")) compact ","(array\n  (lvar :seq1 pop )\n  (str \"~\")\n  (lvar :sel2)\n  (str \"~\")) compact ","seq2 pop  superselector? ","seq1 pop  superselector? ","Sass Util  lcs  == ","Sass Util  Sass Util  lcs  "]}," Sass Selector Sequence add_sources!":{"type":"method","name":"add_sources!","children":[],"call":["m with_more_sources ","m is_a? "," members map! "," members "]}," Sass Selector AbstractSequence _specificity":{"type":"method","name":"_specificity","children":[],"call":["m specificity ","m is_a? ","arr map ","min == ","spec end ","spec begin ","spec is_a? ","arr each ","m m specificity ificity ","m specificity  end ","m specificity  begin ","m specificity  is_a? "]}," Sass Selector AbstractSequence specificity":{"type":"method","name":"specificity","children":[],"call":[" _specificity "," members "]}," Sass Selector AbstractSequence has_placeholder?":{"type":"method","name":"has_placeholder?","children":[],"call":["m is_a? ","m has_placeholder? "," members any? "," members ","m selector has_placeholder? ","m selector "]}," Sass SCSS StaticParser interp_uri":{"type":"method","name":"interp_uri","children":[],"call":[" tok "]}," Sass SCSS StaticParser var_expr":{"type":"method","name":"var_expr","children":[],"call":[]}," Sass SCSS StaticParser moz_document_function":{"type":"method","name":"moz_document_function","children":[],"call":[" ss "," function ","allow_var ! "," tok "]}," Sass SCSS Parser interp_ident_or_var":{"type":"method","name":"interp_ident_or_var","children":[],"call":[" var_expr "," interp_ident ","  var_expr _expr "," interp_ interp_ident ent "]}," Sass SCSS Parser interp_uri":{"type":"method","name":"interp_uri","children":[],"call":[" _interp_string "]}," Sass SCSS Parser var_expr":{"type":"method","name":"var_expr","children":[],"call":["var line= ","Sass Script Variable  new "," tok! "," tok ","Sass Script Tree Variable  new "," ident! ","Sass Script Variable  new  line= ","Sass Script Tree Variable  new  line= "]}," Sass SCSS Parser pseudo_arg":{"type":"method","name":"pseudo_arg","children":[],"call":[" rethrow "," selector "," catch_error "," expected "," tok? "," pseudo_expr ","  selector ector "," pseudo_ pseudo_expr  "]}," Sass SCSS Parser qualified_name":{"type":"method","name":"qualified_name","children":[],"call":[" tok! "," interp_ident "," expr! "," tok "," tok? "]}," Sass SCSS Parser placeholder_selector":{"type":"method","name":"placeholder_selector","children":[],"call":["Selector Placeholder  new "," merge "," expr! "," tok "]}," Sass SCSS Parser reference_combinator":{"type":"method","name":"reference_combinator","children":[],"call":["res join ","e is_a? ","res all? ","res flatten ","res << << "," tok! ","res << "," expr! "," tok ","res join  join ","res flatten  join ","res join  all? ","res flatten  all? ","res join  flatten ","res flatten  flatten ","res join  << << ","res flatten  << << ","res join  << ","res flatten  << "]}," Sass SCSS Parser supports_interpolation":{"type":"method","name":"supports_interpolation","children":[],"call":["Sass Supports Interpolation  new "," ss "," interpolation ","  interpolation olation "]}," Sass SCSS Parser content_directive":{"type":"method","name":"content_directive","children":[],"call":[" node ","Sass Tree ContentNode  new "," ss "]}," Sass SCSS Parser parse_media_query_list":{"type":"method","name":"parse_media_query_list","children":[],"call":[" expected ","@scanner eos? "," media_query_list "," init_scanner! "]}," Sass SCSS CssParser placeholder_selector":{"type":"method","name":"placeholder_selector","children":[],"call":[]}," Sass Script Parser parse_string":{"type":"method","name":"parse_string","children":[],"call":[" raise ","e modify_backtrace ","@options [] ","@lexer line ","@lexer unpeek! ","expr options= "," assert_expr "," lexer expected! "," lexer ","peek value downcase == ","peek value downcase ","peek value ","peek type == ","peek type ","@lexer peek "," check_for_interpolation ","@lexer un@lexer peek ! "," assert_expr  options= "," assert_ assert_expr  ","@lexer peek  value downcase == ","@lexer peek  value downcase ","@lexer peek  value ","@lexer peek  type == ","@lexer peek  type ","@lexer @lexer peek  "]}," Script Null inspect":{"type":"method","name":"inspect","children":[],"call":[]}," Script Null to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Script Null null?":{"type":"method","name":"null?","children":[],"call":[]}," Script Null to_bool":{"type":"method","name":"to_bool","children":[],"call":[]}," Script Null initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script Literal null?":{"type":"method","name":"null?","children":[],"call":[]}," Sass Script Lexer null":{"type":"method","name":"null","children":[],"call":["Script Null  new "," scan ","REGULAR_EXPRESSIONS  [] ","script_null source_range= "," range "," source_position ","Script Value Null  new ","Script Null  new  source_range= ","Script Value Null  new  source_range= "]}," Script Functions max":{"type":"method","name":"max","children":[],"call":["max gt to_bool ","max gt ","values inject "," assert_type ","values each "]}," Script Functions min":{"type":"method","name":"min","children":[],"call":["min lt to_bool ","min lt ","values inject "," assert_type ","values each ","numbers inject ","numbers each "]}," Script Functions ie_hex_str":{"type":"method","name":"ie_hex_str","children":[],"call":["Sass Script String  new ","(str \"#\") upcase ","color send [] ","color send ","(send\n  (send\n    (lvar :color) :alpha) :*\n  (int 255)) round to_s rjust ","(send\n  (send\n    (lvar :color) :alpha) :*\n  (int 255)) round to_s ","(send\n  (send\n    (lvar :color) :alpha) :*\n  (int 255)) round ","color alpha * ","color alpha "," assert_type "," identifier ","Sass Script Value String  new ","Sass Util  round to_s rjust ","Sass Util  round to_s ","Sass Util  round ","(send\n  (send\n    (lvar :color) :(send\n  (send\n    (lvar :color) :alpha) :*\n  (int 255)) round to_s rjust ) :*\n  (int 255)) round to_s rjust ","(send\n  (send\n    (lvar :color) :Sass Util  round to_s rjust ) :*\n  (int 255)) round to_s rjust ","(send\n  (send\n    (lvar :color) :(send\n  (send\n    (lvar :color) :alpha) :*\n  (int 255)) round to_s rjust ) :*\n  (int 255)) round to_s ","(send\n  (send\n    (lvar :color) :Sass Util  round to_s rjust ) :*\n  (int 255)) round to_s ","(send\n  (send\n    (lvar :color) :(send\n  (send\n    (lvar :color) :alpha) :*\n  (int 255)) round to_s rjust ) :*\n  (int 255)) round ","(send\n  (send\n    (lvar :color) :Sass Util  round to_s rjust ) :*\n  (int 255)) round ","color (send\n  (send\n    (lvar :color) :alpha) :*\n  (int 255)) round to_s rjust  * ","color Sass Util  round to_s rjust  * ","color (send\n  (send\n    (lvar :color) :alpha) :*\n  (int 255)) round to_s rjust  ","color Sass Util  round to_s rjust  "]}," Script ArgList _perform":{"type":"method","name":"_perform","children":[],"call":[]}," Script ArgList deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","v deep_copy ","Sass Util  map_hash "]}," Script ArgList children":{"type":"method","name":"children","children":[],"call":[" + ","@keywords values "]}," Script ArgList keywords":{"type":"method","name":"keywords","children":[],"call":[]}," Script ArgList initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Media _interp_to_src":{"type":"method","name":"_interp_to_src","children":[],"call":[]}," Media Query deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["Query  new ","c deep_copy ","c is_a? ","e map "," expressions map "," expressions "," type map "," type "," modifier map "," modifier ","q deep_copy "]}," Media Query to_a":{"type":"method","name":"to_a","children":[],"call":["Sass Util  intersperse flatten ","Sass Util  intersperse "," expressions ","res << "," expressions empty? "," type empty? "," type "," modifier empty? "," modifier "]}," Media Query to_src":{"type":"method","name":"to_src","children":[],"call":["src << ","(send\n  (send nil :expressions) :map) join ","Sass Media  _interp_to_src "," expressions map "," expressions "," expressions empty? "," type empty? "," type "," modifier empty? "," modifier ","e to_src ","Sass Media  _interp_or_var_to_src "]}," Media Query to_css":{"type":"method","name":"to_css","children":[],"call":["css << ","(send\n  (send nil :expressions) :map) join ","(send\n  (lvar :e) :map) join ","c to_s ","c to_sass ","c is_a? ","e map "," expressions map "," expressions "," expressions empty? "," resolved_type empty? "," resolved_type "," resolved_modifier empty? "," resolved_modifier ","e to_css "]}," Media Query merge":{"type":"method","name":"merge","children":[],"call":["q modifier= ","q type= ","Query  new ","other expressions + "," expressions ","other expressions ","m1 empty? ","t1 != ","t1 == ","m2 == ","m1 == ","(send\n  (lvar :m1) :==\n  (str \"not\")) ^ ","t2 empty? ","t1 empty? ","other resolved_type downcase ","other resolved_type ","other resolved_modifier downcase ","other resolved_modifier "," resolved_type downcase "," resolved_type "," resolved_modifier downcase "," resolved_modifier ","q resolved_modifier= ","q resolved_type= ","Query  new  modifier= ","Query  new  type= ","Query  new  resolved_modifier= ","Query  new  resolved_type= "]}," Media Query resolved_type":{"type":"method","name":"resolved_type","children":[],"call":[" type first "," type "]}," Media Query resolved_modifier":{"type":"method","name":"resolved_modifier","children":[],"call":[" modifier first "," modifier "]}," Media Query initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Media QueryList deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["QueryList  new ","q deep_copy "," queries map "," queries "]}," Media QueryList to_a":{"type":"method","name":"to_a","children":[],"call":["Sass Util  intersperse flatten ","Sass Util  intersperse ","q to_a "," queries map "," queries "]}," Media QueryList to_src":{"type":"method","name":"to_src","children":[],"call":["(send\n  (send nil :queries) :map) join ","q to_src "," queries map "," queries "]}," Media QueryList to_css":{"type":"method","name":"to_css","children":[],"call":["(send\n  (send nil :queries) :map) join ","q to_css "," queries map "," queries "]}," Media QueryList merge":{"type":"method","name":"merge","children":[],"call":["QueryList  new ","new_queries empty? ","(send\n  (send nil :queries) :map) flatten compact ","(send\n  (send nil :queries) :map) flatten ","q1 merge ","other queries map ","other queries "," queries map "," queries ","(send\n  (send nil :queries) :map) flatten compact  empty? "]}," Media QueryList initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Environment content":{"type":"method","name":"content","children":[],"call":["@parent content "]}," Sass Environment caller":{"type":"method","name":"caller","children":[],"call":["@parent caller "]}," Sass Engine parse_content_directive":{"type":"method","name":"parse_content_directive","children":[],"call":["Tree ContentNode  new "," raise ","SyntaxError  new ","line index + ","line index ","line children empty? ","line children ","trailing nil? ","line text scan first first ","line text scan first ","line text scan ","line text ","line text scan first first  nil? "]}," Sass CSS bubble_subject":{"type":"method","name":"bubble_subject","children":[],"call":[" first_sseq subject= "," first_sseq ","child children each ","child children "," first_sseq subject? "," first_simple_sel is_a? "," first_simple_sel ","c is_a? ","child children all? ","child is_a? "," bubble_subject ","root children each ","root children ","child children empty? ! ","child children empty? "]}," Media Expression options=":{"type":"method","name":"options=","children":[],"call":[" value options= "," value "," name options= "," name ","v options= ","v is_a? "," value each ","n options= ","n is_a? "," name each "]}," Media Expression deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["Expression  new "," value deep_copy "," value "," name deep_copy "," name ","c deep_copy ","c is_a? "," value map "," name map "]}," Media Expression to_src":{"type":"method","name":"to_src","children":[],"call":["src << ","src << << "," value to_sass "," value "," name to_sass "," name ","Sass Media  _interp_or_var_to_src "," value empty? "]}," Media Expression to_css":{"type":"method","name":"to_css","children":[],"call":["css << ","css << << "," resolved_value "," resolved_value empty? "," resolved_name "]}," Media Expression perform":{"type":"method","name":"perform","children":[],"call":[" value "," name "]}," Media Expression initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Media Query options=":{"type":"method","name":"options=","children":[],"call":["e options= "," expressions each "," expressions ","t options= ","t is_a? "," type each "," type ","m options= ","m is_a? "," modifier each "," modifier "]}," Media Query perform":{"type":"method","name":"perform","children":[],"call":["e perform "," expressions each "," expressions "," type "," modifier "]}," Media QueryList options=":{"type":"method","name":"options=","children":[],"call":["q options= "," queries each "," queries "]}," Media QueryList perform":{"type":"method","name":"perform","children":[],"call":["q perform ","@queries each "]}," Media _interp_or_var_to_src":{"type":"method","name":"_interp_or_var_to_src","children":[],"call":[]}," Sass Util jruby1_6?":{"type":"method","name":"jruby1_6?","children":[],"call":[" jruby_version [] < "," jruby_version [] "," jruby_version "," jruby_version [] == "," jruby? "]}," Sass Util ruby1?":{"type":"method","name":"ruby1?","children":[],"call":["Sass Util RUBY_VERSION  [] <= ","Sass Util RUBY_VERSION  [] ","RUBY_VERSION_COMPONENTS  [] <= ","RUBY_VERSION_COMPONENTS  [] "]}," Sass Util destructure":{"type":"method","name":"destructure","children":[],"call":[]}," Sass Util jruby_version":{"type":"method","name":"jruby_version","children":[],"call":["s to_i "," JRUBY_VERSION  split map "," JRUBY_VERSION  split ","Sass Util  jruby_version "]}," Sass Util jruby?":{"type":"method","name":"jruby?","children":[],"call":["RUBY_PLATFORM  =~ "]}," Sass Util rbx?":{"type":"method","name":"rbx?","children":[],"call":["RUBY_ENGINE  == "]}," Sass Util undefined_conversion_error_char":{"type":"method","name":"undefined_conversion_error_char","children":[],"call":["e message [] ","e message ","e error_char dump ","e error_char "," jruby? "," rbx? "]}," Sass Util array_minus":{"type":"method","name":"array_minus","children":[],"call":["set include? ","minuend select ","Set  new - ","Set  new ","minuend - "," rbx? ","Set  new -  include? "]}," Sass Util Test skip":{"type":"method","name":"skip","children":[],"call":[]}," MultibyteStringScanner is_a?":{"type":"method","name":"is_a?","children":[],"call":[" __getobj__ is_a? "," __getobj__ "]}," SetOptions visit_import":{"type":"method","name":"visit_import","children":[],"call":["node imported_file= "]}," Sass Tree ImportNode options_for_importer":{"type":"method","name":"options_for_importer","children":[],"call":["@options merge "," line "]}," Sass SCSS Parser parse_supports_condition":{"type":"method","name":"parse_supports_condition","children":[],"call":[" expected ","@scanner eos? "," supports_condition "," init_scanner! "," supports_ supports_condition  "]}," Script Null to_sass":{"type":"method","name":"to_sass","children":[],"call":[]}," Script Functions counter":{"type":"method","name":"counter","children":[],"call":["Sass Script String  new ","(send\n  (lvar :args) :map) join ","a to_s "," options ","args map "," identifier ","Sass Script Value String  new "]}," Plugin Compiler load_listen!":{"type":"method","name":"load_listen!","children":[],"call":["$LOAD_PATH unshift ","e message << << ","e message << ","e message "," raise ","File  exists? "," scope ","$LOAD_PATH include? ","Sass Util  scope "," require "," gem ","Sass Util  version_geq "]}," Sass Exec Generic write_output":{"type":"method","name":"write_output","children":[],"call":["destination write ","file write "," open_file ","destination is_a? ","File  open "]}," Sass Util atomic_create_and_write_file":{"type":"method","name":"atomic_create_and_write_file","children":[],"call":["tmpfile unlink ","tmpfile close ","File  rename ","tmpfile path ","tmpfile binmode ","tmpfile respond_to? ","Tempfile  new ","File  dirname ","File  basename "," require ","tmpfile fsync ","tmpfile flush ","File  chmod ","perms & ","File  umask ~ ","File  umask ","ATOMIC_WRITE_MUTEX  synchronize ","Tempfile  new  unlink ","Tempfile  new  close ","Tempfile  new  path ","Tempfile  new  binmode ","Tempfile  new  respond_to? ","Tempfile  new  fsync ","Tempfile  new  flush "]}," Sass Selector Pseudo type":{"type":"method","name":"type","children":[],"call":[" syntactic_type ","ACTUALLY_ELEMENTS  include? "," name first "," name "," normalized_name "]}," Sass Selector SimpleSequence pseudo_elements":{"type":"method","name":"pseudo_elements","children":[],"call":["sel type == ","sel type ","sel is_a? ","(send\n  (send nil :members) :-\n  (array\n    (send nil :base))) select "," members - "," base "," members "," members select "]}," Script Functions counters":{"type":"method","name":"counters","children":[],"call":["Sass Script String  new ","(send\n  (lvar :args) :map) join ","a to_s "," options ","args map "," identifier "]}," Sass Plugin StalenessChecker with_dependency_cache":{"type":"method","name":"with_dependency_cache","children":[],"call":["StalenessChecker  dependencies_cache ","StalenessChecker  dependency_cache_mutex synchronize ","StalenessChecker  dependency_cache_mutex "]}," Sass Script Funcall without_original":{"type":"method","name":"without_original","children":[],"call":["value original= ","value dup ","value is_a? ","value dup  original= ","value dup  dup ","value dup  is_a? "]}," Sass Util absolute_path":{"type":"method","name":"absolute_path","children":[],"call":["File  expand_path ","File  join ","path [] == ","path [] ","File  absolute_path "," ruby1_8? "]}," Sass Util escape_uri":{"type":"method","name":"escape_uri","children":[],"call":["URI_ESCAPE  escape "]}," Sass Util encode_vlq":{"type":"method","name":"encode_vlq","children":[],"call":["result << ","BASE64_DIGITS  [] ","value > ","value & ","(send\n  (begin\n    (send\n      (lvar :value) :-@)) :<<\n  (int 1)) | ","(send\n  (lvar :value) :-@) << ","value -@ ","value < ","String  new ","String  new  << ","(send\n  (begin\n    (send\n      (lvar :value) :-@)) :<<\n  (int 1)) |  > ","(send\n  (begin\n    (send\n      (lvar :value) :-@)) :<<\n  (int 1)) |  & ","(send\n  (begin\n    (send\n      (lvar :(send\n  (begin\n    (send\n      (lvar :value) :-@)) :<<\n  (int 1)) | ) :-@)) :<<\n  (int 1)) | ","(send\n  (lvar :(send\n  (begin\n    (send\n      (lvar :value) :-@)) :<<\n  (int 1)) | ) :-@) << ","(send\n  (begin\n    (send\n      (lvar :value) :-@)) :<<\n  (int 1)) |  -@ ","(send\n  (begin\n    (send\n      (lvar :value) :-@)) :<<\n  (int 1)) |  < "]}," Sass Util json_value_of":{"type":"method","name":"json_value_of","children":[],"call":[" raise ","ArgumentError  new ","v class name ","v class ","[ + + ","[ + ","(send\n  (lvar :v) :map) join "," json_value_of ","v map ","\" + + ","\" + "," json_escape_string ","v to_s "]}," Sass Util json_escape_string":{"type":"method","name":"json_escape_string","children":[],"call":["result << ","result << << ","s split each ","s split ","s !~ "]}," Sass Util sourcemap_name":{"type":"method","name":"sourcemap_name","children":[],"call":["css + "]}," Sass Util flatten_vertically":{"type":"method","name":"flatten_vertically","children":[],"call":["arr empty? ","result << ","arr shift ","arrs reject! ","arrs empty? "," Array ","sub dup ","sub is_a? ","arrs map "]}," Sass Util ordered_hash":{"type":"method","name":"ordered_hash","children":[],"call":["(if\n  (send\n    (lvar :pairs_or_hash) :is_a?\n    (const nil :NormalizedMap))\n  (const nil :NormalizedMap)\n  (const nil :OrderedHash)) [] "," flatten ","pairs_or_hash is_a? ","Hash  [] "," ruby1_8? ","OrderedHash  new merge ","OrderedHash  new ","pairs_or_hash first ","pairs_or_hash first is_a? ","pairs_or_hash length == ","pairs_or_hash length ","OrderedHash  [] "," require ","pairs_or_hash flatten ","(if\n  (send\n    (lvar :pairs_or_pairs_or_hash first ) :is_a?\n    (const nil :NormalizedMap))\n  (const nil :NormalizedMap)\n  (const nil :OrderedHash)) [] ","pairs_or_pairs_or_hash first  is_a? ","pairs_or_pairs_or_hash first  first ","pairs_or_pairs_or_hash first  first is_a? ","pairs_or_pairs_or_hash first  length == ","pairs_or_pairs_or_hash first  length ","pairs_or_pairs_or_hash first  flatten "]}," Sass Util pathname":{"type":"method","name":"pathname","children":[],"call":["Pathname  new ","path tr "," windows? ","path tr  tr "]}," Sass Util listen_geq_2?":{"type":"method","name":"listen_geq_2?","children":[],"call":[" version_geq "," require ","@listen_geq_2 nil? "," load_listen! "]}," Sass Util deprecated":{"type":"method","name":"deprecated","children":[],"call":["Sass Util  sass_warn ","(str \"DEPRECATION WARNING: \") + ","\n + "," caller_info [] "," caller_info ","obj class ","obj is_a? "]}," Sass Util slice_by":{"type":"method","name":"slice_by","children":[],"call":["results << ","results last last << ","results last last ","results last ","results last first == ","results last first ","results empty? ! ","results empty? ","enum each "]}," OrderedHash sync_keys!":{"type":"method","name":"sync_keys!","children":[],"call":[" has_key? ! "," has_key? ","@keys delete_if "]}," OrderedHash inspect":{"type":"method","name":"inspect","children":[],"call":[]}," OrderedHash invert":{"type":"method","name":"invert","children":[],"call":["OrderedHash  [] ","key_value_pair reverse "," to_a map! "," to_a "]}," OrderedHash replace":{"type":"method","name":"replace","children":[],"call":["other keys "]}," OrderedHash merge":{"type":"method","name":"merge","children":[],"call":[" dup merge! "," dup "," block_given? "]}," OrderedHash merge!":{"type":"method","name":"merge!","children":[],"call":[" []= ","other_hash each "," [] "," key? "," block_given? "]}," OrderedHash shift":{"type":"method","name":"shift","children":[],"call":[" delete ","@keys first ","@@keys first eys first "]}," OrderedHash clear":{"type":"method","name":"clear","children":[],"call":["@keys clear "]}," OrderedHash each_pair":{"type":"method","name":"each_pair","children":[],"call":[" [] ","@keys each "," to_enum "," block_given? "]}," OrderedHash each":{"type":"method","name":"each","children":[],"call":[" [] ","@keys each "," to_enum "," block_given? "]}," OrderedHash each_value":{"type":"method","name":"each_value","children":[],"call":[" [] ","@keys each "," to_enum "," block_given? "]}," OrderedHash each_key":{"type":"method","name":"each_key","children":[],"call":["@keys each "," to_enum "," block_given? "]}," OrderedHash to_a":{"type":"method","name":"to_a","children":[],"call":[" [] ","@keys map "]}," OrderedHash to_hash":{"type":"method","name":"to_hash","children":[],"call":[]}," OrderedHash values":{"type":"method","name":"values","children":[],"call":[" [] ","@keys map ","@keys collect "]}," OrderedHash keys":{"type":"method","name":"keys","children":[],"call":["@keys dup "]}," OrderedHash reject":{"type":"method","name":"reject","children":[],"call":[" dup reject! "," dup "]}," OrderedHash reject!":{"type":"method","name":"reject!","children":[],"call":[" sync_keys! "]}," OrderedHash delete_if":{"type":"method","name":"delete_if","children":[],"call":[" sync_keys! "]}," OrderedHash delete":{"type":"method","name":"delete","children":[],"call":["@keys delete_at ","@keys index "," has_key? ","@keys @keys index  "]}," OrderedHash []=":{"type":"method","name":"[]=","children":[],"call":["@keys << "," has_key? "]}," OrderedHash initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["other keys "]}," OrderedHash []":{"type":"method","name":"[]","children":[],"call":[]}," OrderedHash initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Util NormalizedMap respond_to_missing?":{"type":"method","name":"respond_to_missing?","children":[],"call":["@map respond_to? "]}," Sass Util NormalizedMap respond_to?":{"type":"method","name":"respond_to?","children":[],"call":["@map respond_to? "]}," Sass Util NormalizedMap method_missing":{"type":"method","name":"method_missing","children":[],"call":["@map send "," raise ","ArgumentError  new ","Sass  tests_running "]}," Sass Util NormalizedMap update":{"type":"method","name":"update","children":[],"call":[" []= ","map each ","map as_stored ","map is_a? ","map as_stored  each ","map as_stored  as_stored ","map as_stored  is_a? "]}," Sass Util NormalizedMap sort_by":{"type":"method","name":"sort_by","children":[],"call":["@map sort_by "]}," Sass Util NormalizedMap dup":{"type":"method","name":"dup","children":[],"call":["d send ","@map dup "]}," Sass Util NormalizedMap map":{"type":"method","name":"map","children":[],"call":["@map map "]}," Sass Util NormalizedMap to_a":{"type":"method","name":"to_a","children":[],"call":["@map to_a "]}," Sass Util NormalizedMap to_hash":{"type":"method","name":"to_hash","children":[],"call":["@map dup "]}," Sass Util NormalizedMap size":{"type":"method","name":"size","children":[],"call":["@map size "]}," Sass Util NormalizedMap each":{"type":"method","name":"each","children":[],"call":["@map each "]}," Sass Util NormalizedMap keys":{"type":"method","name":"keys","children":[],"call":["@map keys "]}," Sass Util NormalizedMap values":{"type":"method","name":"values","children":[],"call":["@map values "]}," Sass Util NormalizedMap empty?":{"type":"method","name":"empty?","children":[],"call":["@map empty? "]}," Sass Util NormalizedMap as_stored":{"type":"method","name":"as_stored","children":[],"call":["@key_strings [] ","Sass Util  map_keys "]}," Sass Util NormalizedMap delete":{"type":"method","name":"delete","children":[],"call":["@map delete ","@key_strings delete "," normalize "]}," Sass Util NormalizedMap has_key?":{"type":"method","name":"has_key?","children":[],"call":["@map has_key? "," normalize "]}," Sass Util NormalizedMap []":{"type":"method","name":"[]","children":[],"call":["@map [] "," normalize "]}," Sass Util NormalizedMap []=":{"type":"method","name":"[]=","children":[],"call":["@key_strings []= ","@map []= "," normalize "]}," Sass Util NormalizedMap denormalize":{"type":"method","name":"denormalize","children":[],"call":["@key_strings [] "," normalize "]}," Sass Util NormalizedMap normalize":{"type":"method","name":"normalize","children":[],"call":["key tr "]}," Sass Util NormalizedMap initialize":{"type":"method","name":"initialize","children":[],"call":[" []= ","map each ","OrderedHash  new ","Util  ruby1_8? "]}," Sass Util CrossPlatformRandom rand":{"type":"method","name":"rand","children":[],"call":["Kernel  rand ","@random rand "]}," Sass Util CrossPlatformRandom initialize":{"type":"method","name":"initialize","children":[],"call":[" Random  new "," srand ","Sass Util  ruby1_8? "]}," ToCss prepend!":{"type":"method","name":"prepend!","children":[],"call":["@source_mapping shift_output_lines ","@source_mapping shift_output_offsets ","prefix gsub size ","prefix gsub ","prefix count ","@result insert "]}," ToCss lstrip":{"type":"method","name":"lstrip","children":[],"call":[]}," ToCss rstrip!":{"type":"method","name":"rstrip!","children":[],"call":[" erase! ","@result length - - ","@result rindex ","@result length - ","@result length "]}," ToCss output":{"type":"method","name":"output","children":[],"call":["@result << ","s size ","s [] size ","s [] ","s rindex ","newlines > ","s count ","s gsub ","@res gsub ult << ","s gsub  s gsub ize ","s gsub  [] s gsub ize ","s gsub  [] ","s gsub  rindex ","s count  > ","newlines gsub  > ","s gsub  count ","s gsub  gs gsub ub "]}," ToCss erase!":{"type":"method","name":"erase!","children":[],"call":["@result [] size ","@result [] ","@result rindex ","newlines > ","str count ","@result slice! ","chars -@ ","chars == ","str count  > ","@result slice!  count "]}," ToCss for_node":{"type":"method","name":"for_node","children":[],"call":["@source_mapping add ","Sass Source Range  new ","Sass Source Position  new ","node send ","node send ! ","node invisible? "]}," Perform visit_atroot":{"type":"method","name":"visit_atroot","children":[],"call":["node exclude? ","node resolved_value= ","node resolved_type= ","parser parse_static_at_root_query ","Sass SCSS StaticParser  new ","node line ","node options [] ","node options ","node filename "," run_interp ","node query "," children ","Sass SCSS StaticParser  new  parse_static_at_root_query "]}," Perform arg_hash":{"type":"method","name":"arg_hash","children":[],"call":[" raise ","Sass SyntaxError  new ","Variable keyword argument map must have string keys.\n + ","map inspect ","key inspect ","key value ","key is_a? ","Sass Util  map_keys ","map to_h "]}," Perform perform_splat":{"type":"method","name":"perform_splat","children":[],"call":["Sass Script Value ArgList  new ","kwargs update "," arg_hash "," raise ","Sass SyntaxError  new ","Variable keyword arguments must be a map  + ","kwarg_splat inspect ","kwarg_splat is_a? ","kwarg_splat perform ","Sass Util NormalizedMap  new ","splat to_a ","splat is_a? ","splat keywords ","splat separator ","splat perform ","splat keywords merge ","splat value ","kwargs merge ","Sass Util  ordered_hash ","kwsplat to_a  update "," arg_hash  update ","splat keywords  update ","kwargs merge  update ","kwarg_splat perform  inspect ","kwarg_splat perform  is_a? ","kwarg_splat perform  perform ","splat perform  to_a ","splat perform  is_a? ","splat perform  keywords ","splat perform  separator ","splat perform  perform ","splat perform  keywords merge ","splat perform  value ","kwsplat to_a  merge "," arg_hash  merge ","splat keywords  merge ","kwargs merge  merge "]}," Cssize Bubble inspect":{"type":"method","name":"inspect","children":[],"call":[" node inspect "," node "]}," Cssize Bubble bubbles?":{"type":"method","name":"bubbles?","children":[],"call":[]}," Cssize Bubble initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Cssize bubblable?":{"type":"method","name":"bubblable?","children":[],"call":["node bubbles? ","node is_a? "]}," Cssize debubble":{"type":"method","name":"debubble","children":[],"call":["(send\n  (block\n    (send\n      (const\n        (const nil :Sass) :Util) :slice_by\n      (lvar :children))\n    (args\n      (arg :c))\n    (send\n      (lvar :c) :is_a?\n      (const nil :Bubble))) :map) flatten ","(send\n  (lvar :slice) :map) compact ","(send nil :visit\n  (lvar :node)) flatten "," visit ","node group_end= ","bubble group_end ","bubble tabs ","node tabs ","bubble node "," block_given? ","slice map ","new_parent children= ","parent dup ","(send\n  (const\n    (const nil :Sass) :Util) :slice_by\n  (lvar :children)) map ","c is_a? ","Sass Util  slice_by ","results empty? ","previous_parent children push ","previous_parent children ","(send nil :visit\n  (lvar :bubble node )) flatten ","bubble node  group_end= ","bubble node  tabs ","bubble bubble node  ","parent dup  children= ","(send nil :visit\n  (lvar :node)) flatten  empty? "]}," Cssize visit_directive":{"type":"method","name":"visit_directive","children":[],"call":["(lvar :directive_exists) + "," debubble ","node children ","empty_node children= ","node dup ","child node resolved_value == ","node resolved_value ","child node resolved_value ","child node ","child node is_a? ","child is_a? ","node children any? "," bubble "," parent is_a? "," parent ","node has_children ","(if\n  (and\n    (lvar :bubbled)\n    (send\n      (send\n        (lvar :node) :children) :empty?))\n  (array)\n  (array\n    (lvar :node))) + ","node children empty? ","(send\n  (lvar :at_roots) :map!) flatten "," visit ","at_roots map! ","n is_a? ","node children select ","(or\n  (lvar :directive_exists)\n  (send\n    (send\n      (lvar :node) :name) :==\n    (str \"@keyframes\"))) + ","node name == ","node name ","Bubble  new ","node normalized_name == ","node normalized_name ","node dup  children= ","(if\n  (and\n    (lvar : bubble )\n    (send\n      (send\n        (lvar :node) :children) :empty?))\n  (array)\n  (array\n    (lvar :node))) + "]}," Cssize visit_atroot":{"type":"method","name":"visit_atroot","children":[],"call":[" bubble ","Bubble  new ","node exclude_node? "," parent ","results last group_end= ","node group_end ","results last "," bubblable? ","results empty? ! ","results empty? ","node tabs ","c tabs ","results each "," visit_children_without_parent ","@parents none? "," children ","n tabs ","node children= ","new_rule children= ","node children "," parent dup ","@parent_directives any? "," visit_children_without_parent  last group_end= "," visit_children_without_parent  last "," visit_children_without_parent  empty? ! "," visit_children_without_parent  empty? "," visit_children_without_parent  each "," parent dup  children= "]}," Cssize visit_children_without_parent":{"type":"method","name":"visit_children_without_parent","children":[],"call":["(send\n  (send\n    (lvar :node) :children) :map) flatten "," visit ","node children map ","node children "]}," Cssize parent":{"type":"method","name":"parent","children":[],"call":["@parents last "]}," Convert query_interp_to_src":{"type":"method","name":"query_interp_to_src","children":[],"call":["(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (lvar :interp)) :map) join ","r to_sass ","after [] == ","after [] ","before =~ ","before [] == ","before [] ","after is_a? ","before is_a? ","interp [] ","i + ","i - ","r is_a? ","Sass Util  enum_with_index map ","Sass Util  enum_with_index ","e value value ","e value ","e value is_a? ","e is_a? ","interp map "," interp_to_src "]}," Convert visit_atroot":{"type":"method","name":"visit_atroot","children":[],"call":[" tab_str "," visit_children "," selector_to_src ","rule rule ","node children first ","node children ","node children first is_a? ","node children length == ","node children length "," query_interp_to_src ","node query "," selector_to_src lstrip ","node children first  node children first  "]}," Sass Tree RootNode css_tree":{"type":"method","name":"css_tree","children":[],"call":["Visitors Extend  visit ","Visitors Cssize  visit ","Visitors CheckNesting  visit ","Visitors Perform  visit "]}," Sass Tree RootNode render_with_sourcemap":{"type":"method","name":"render_with_sourcemap","children":[],"call":[" css_tree css_with_sourcemap "," css_tree "]}," Sass Tree Node css_with_sourcemap":{"type":"method","name":"css_with_sourcemap","children":[],"call":["visitor source_mapping ","visitor visit ","Sass Tree Visitors ToCss  new ","Sass Tree Visitors ToCss  new  source_mapping ","Sass Tree Visitors ToCss  new  visit "]}," Sass Tree Node css":{"type":"method","name":"css","children":[],"call":["Sass Tree Visitors ToCss  new visit ","Sass Tree Visitors ToCss  new "]}," Sass Tree Node inherited":{"type":"method","name":"inherited","children":[],"call":[]}," Tree DirectiveNode bubbles?":{"type":"method","name":"bubbles?","children":[],"call":[" has_children "]}," Sass Tree AtRootNode bubbles?":{"type":"method","name":"bubbles?","children":[],"call":[]}," Sass Tree AtRootNode exclude_node?":{"type":"method","name":"exclude_node?","children":[],"call":["node is_a? "," exclude? ","node name gsub ","node name ","node class to_s gsub downcase ","node class to_s gsub ","node class to_s ","node class "]}," Sass Tree AtRootNode exclude?":{"type":"method","name":"exclude?","children":[],"call":[" resolved_value include? "," resolved_value "," resolved_value include? ! "," resolved_type == "," resolved_type "]}," Sass Tree AtRootNode initialize":{"type":"method","name":"initialize","children":[],"call":["Sass Util  strip_string_array ","Sass Util  merge_adjacent_strings "]}," Sass Stack with_frame":{"type":"method","name":"with_frame","children":[],"call":["@frames pop ","@frames last type != ","@frames last type ","@frames last ","type == ","@frames push ","Frame  new ","@frames last type == "]}," Sass Stack deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["stack frames replace "," frames ","stack frames ","Stack  new ","Stack  new  frames replace ","Stack  new  frames "]}," Sass Stack to_s":{"type":"method","name":"to_s","children":[],"call":["(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_with_index\n    (send\n      (const\n        (const nil :Sass) :Util) :enum_cons\n      (send\n        (send\n          (send nil :frames) :reverse) :+\n        (array\n          (nil)))\n      (int 2))) :map) join ","(begin\n  (if\n    (send\n      (lvar :i) :==\n      (int 0))\n    (str \"on\")\n    (str \"from\"))) + + ","caller name ","(begin\n  (if\n    (send\n      (lvar :i) :==\n      (int 0))\n    (str \"on\")\n    (str \"from\"))) + ","frame filename ","frame line ","i == ","Sass Util  enum_with_index map ","Sass Util  enum_with_index ","Sass Util  enum_cons "," frames reverse + "," frames reverse "," frames ","(send\n  (send\n    (send\n      (begin\n        (send\n          (send\n            (send nil :frames) :reverse) :+\n          (array\n            (nil)))) :each_cons\n      (int 2)) :each_with_index) :map) join ","(send\n  (send\n    (send nil :frames) :reverse) :+\n  (array\n    (nil))) each_cons each_with_index map ","(send\n  (send\n    (send nil :frames) :reverse) :+\n  (array\n    (nil))) each_cons each_with_index ","(send\n  (send\n    (send nil :frames) :reverse) :+\n  (array\n    (nil))) each_cons "]}," Sass Stack with_mixin":{"type":"method","name":"with_mixin","children":[],"call":[" with_frame "]}," Sass Stack with_import":{"type":"method","name":"with_import","children":[],"call":[" with_frame "]}," Sass Stack with_base":{"type":"method","name":"with_base","children":[],"call":[" with_frame "]}," Sass Stack initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Stack Frame is_base?":{"type":"method","name":"is_base?","children":[],"call":[" type == "," type "]}," Sass Stack Frame is_mixin?":{"type":"method","name":"is_mixin?","children":[],"call":[" type == "," type "]}," Sass Stack Frame is_import?":{"type":"method","name":"is_import?","children":[],"call":[" type == "," type "]}," Sass Stack Frame initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Source Range inspect":{"type":"method","name":"inspect","children":[],"call":[" end_pos inspect "," end_pos "," start_pos inspect "," start_pos "]}," Source Range initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","end_pos is_a? "]}," Source Position after":{"type":"method","name":"after","children":[],"call":["Position  new ","str length - - ","str length - ","str rindex ","str length "," offset + "," offset ","newlines == "," line + "," line ","str count ","str count  == "]}," Source Position inspect":{"type":"method","name":"inspect","children":[],"call":[" offset inspect "," offset "," line inspect "," line "]}," Source Position initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Source Map write_json_field":{"type":"method","name":"write_json_field","children":[],"call":["out << << << << << ","Sass Util  json_value_of ","out << << << << ","out << << << ","Sass Util  json_escape_string ","out << << ","out << "]}," Source Map to_json":{"type":"method","name":"to_json","children":[],"call":["result << "," write_json_field ","source_names push ","id_to_source_uri [] to_s ","id_to_source_uri [] ","(erange\n  (int 0)\n  (lvar :next_source_id)) each ","line_data join ","line_data push ","segment_data_for_line join ","target_pos line ","segment_data_for_line push ","source_pos offset ","segment << ","Sass Util  encode_vlq ","source_pos offset - ","source_pos line ","source_pos line - ","current_source_id - ","target_pos offset ","target_pos offset - ","(send\n  (send\n    (send\n      (lvar :target_pos) :line) :-\n    (int 1)) :-\n  (begin\n    (or\n      (lvar :previous_target_line)\n      (int 0)))) times ","target_pos line - - ","target_pos line - ","segment_data_for_line empty? ","previous_target_line != ","(array\n  (send\n    (send\n      (lvar :m) :input) :start_pos)\n  (send\n    (send\n      (lvar :m) :output) :start_pos)) each ","m output end_pos ","m output ","m input end_pos ","m input ","m output start_pos ","m input start_pos ","id_to_source_uri []= ","source_uri_to_id []= ","source_uri_to_id [] ","importer public_url ","sourcemap_path dirname to_s ","sourcemap_path dirname ","m input importer ","m input file ","@data each ","css_path relative_path_from to_s ","css_path relative_path_from ","Pathname  pwd join cleanpath ","Pathname  pwd join ","Sass Util  pathname ","Pathname  pwd "," raise ","ArgumentError  new ","options [] ","Sass Util  sass_warn ","no_public_url << ","no_public_url include? ","file_path relative_path_from to_s ","file_path relative_path_from ","Pathname  new join ","Pathname  new ","importer root ","importer is_a? ","Set  new ","Sass::Source::Map#to_json requires either  + ","(sym :css_uri) map ","target_pathname basename to_s ","target_pathname basename ","id_to_source_pathname [] to_s ","id_to_source_pathname [] ","id_to_source_pathname []= ","source_pathname_to_id []= ","source_pathname_to_id [] ","source_pathname relative_path_from ","target_pathname dirname ","Sass SyntaxError  new ","css_path relative_path_from to_s tr ","Sass Util  absolute_path ","Sass Util  file_uri_from_path ","id_to_contents [] ","(erange\n  (int 0)\n  (lvar :next_source_id)) map ","options [] == ","id_to_contents []= ","importer find instance_variable_get ","importer find ","Sass Util  relative_path_from ","File  absolute_path ","id_to_file_path relative_path_from to_s  [] to_s ","id_to_importer public_url  [] to_s ","id_to_file_path relative_path_from to_s  [] ","id_to_importer public_url  [] ","source_uri_to_id []  - ","source_pathname_to_id []  - ","(send\n  (send\n    (send\n      (lvar :target_pos) :line) :-\n    (int 1)) :-\n  (begin\n    (or\n      (lvar :target_pos line )\n      (int 0)))) times ","target_pos line  != ","id_to_file_path relative_path_from to_s  []= ","id_to_importer public_url  []= ","file_path relative_path_from to_s _to_id []= ","importer public_url _to_id []= ","file_path relative_path_from to_s _to_id [] ","importer public_url _to_id [] ","Set  new  << ","Set  new  include? ","Pathname  new join  relative_path_from to_s ","Pathname  new join  relative_path_from ","Pathname  pwd join cleanpath  basename to_s ","Pathname  pwd join cleanpath  basename ","id_to_source_pathname relative_path_from  [] to_s ","id_to_Pathname  pwd join cleanpath  [] to_s ","id_to_source_pathname relative_path_from  [] ","id_to_Pathname  pwd join cleanpath  [] ","id_to_source_pathname relative_path_from  []= ","id_to_Pathname  pwd join cleanpath  []= ","source_pathname relative_path_from _to_id []= ","Pathname  pwd join cleanpath _to_id []= ","source_pathname relative_path_from _to_id [] ","Pathname  pwd join cleanpath _to_id [] ","source_pathname relative_path_from  relative_path_from ","Pathname  pwd join cleanpath  relative_path_from ","Pathname  pwd join cleanpath  dirname "]}," Source Map shift_output_offsets":{"type":"method","name":"shift_output_offsets","children":[],"call":["m output end_pos offset ","m output end_pos ","m output ","m output end_pos line > ","m output end_pos line ","m output start_pos offset ","m output start_pos ","m output start_pos line > ","m output start_pos line ","@data each ","delta == "]}," Source Map shift_output_lines":{"type":"method","name":"shift_output_lines","children":[],"call":["m output end_pos line ","m output end_pos ","m output ","m output start_pos line ","m output start_pos ","@data each ","delta == "]}," Source Map add":{"type":"method","name":"add","children":[],"call":["@data push ","Mapping  new "]}," Source Map initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Source Map Mapping inspect":{"type":"method","name":"inspect","children":[],"call":[" output inspect "," output "," input inspect "," input "]}," Sass Selector Parent initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Simple equality_key":{"type":"method","name":"equality_key","children":[],"call":["Sass Util  merge_adjacent_strings "," to_a "," to_s "]}," Sass SCSS StaticParser parse_static_at_root_query":{"type":"method","name":"parse_static_at_root_query","children":[],"call":[" expected ","@scanner eos? "," tok! "," ss "," expr! "," tok! to_sym "," init_scanner! "]}," Sass SCSS Parser pseudo_expr_token":{"type":"method","name":"pseudo_expr_token","children":[],"call":[" interpolation "," tok "," interp_string "]}," Sass SCSS Parser at_root_directive_list":{"type":"method","name":"at_root_directive_list","children":[],"call":[" ss ","arr << "," tok "," ident "," id tok nt "," id ident nt "]}," Sass SCSS Parser at_root_directive":{"type":"method","name":"at_root_directive","children":[],"call":["at_root_node << "," block "," ruleset "," node ","Sass Tree AtRootNode  new "," at_root_query "," tok? "," node  << "]}," Sass SCSS Parser query_expr":{"type":"method","name":"query_expr","children":[],"call":[" ss ","res << "," tok! "," sass_script "," tok "," interpolation ","res << << << ","res << << ","comparison1 == ","Set  [] ","  interpolation olation "," tok  == "]}," Sass SCSS Parser range":{"type":"method","name":"range","children":[],"call":["Sass Source Range  new "]}," Sass SCSS Parser source_position":{"type":"method","name":"source_position","children":[],"call":["Sass Source Position  new "]}," Sass SCSS Parser parse_at_root_query":{"type":"method","name":"parse_at_root_query","children":[],"call":[" expected ","@scanner eos? "," at_root_query "," init_scanner! "," at_root_ at_root_query  "]}," Sass Script const_missing":{"type":"method","name":"const_missing","children":[],"call":[]}," Value String to_sass":{"type":"method","name":"to_sass","children":[],"call":[" to_s ","opts merge "]}," Value String to_s":{"type":"method","name":"to_s","children":[],"call":[" value gsub "," value "," value include? ","opts [] == ","opts [] ","@value gsub ","@type == ","Sass Script Value String  quote ","String  quote "]}," Value String plus":{"type":"method","name":"plus","children":[],"call":["Sass Script Value String  new "," type "," value + "," value ","other to_s ","other value ","other is_a? "]}," Value String initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Value Number sans_common_units":{"type":"method","name":"sans_common_units","children":[],"call":["units1 compact! ","units2 delete_at ","units2 index ","units1 map ","units2 dup ","(send\n  (lvar :units1) :map) compact ","units2 dup  delete_at ","units2 dup  index ","units2 dup  dup "]}," Value Number convertable?":{"type":"method","name":"convertable?","children":[],"call":["CONVERTABLE_UNITS  include? "," Array all? "," Array ","units subset? ","MUTUALLY_CONVERTIBLE  [] ","units first ","units empty? "," Array to_set "," Array to_set  subset? "," Array to_set  first "," Array to_set  empty? "]}," Value Number conversion_factor":{"type":"method","name":"conversion_factor","children":[],"call":["1.0 / "," conversion_factor ","res nil? ","CONVERSION_TABLE  [] [] ","CONVERTABLE_UNITS  [] ","CONVERSION_TABLE  [] ","CONVERSION_TABLE  [] []  nil? "]}," Value Number normalize!":{"type":"method","name":"normalize!","children":[],"call":["@numerator_units delete_at ","@numerator_units index ","@denominator_units delete_at "," conversion_factor ","@numerator_units find "," method "," convertable? ","@denominator_units each_with_index "," sans_common_units "," unitless? ","@numerator_units detect ","@n@numerator_units find merator_@numerator_units find nits delete_at ","@n@numerator_units detect merator_@numerator_units detect nits delete_at ","@n@numerator_units find merator_@numerator_units find nits index ","@n@numerator_units detect merator_@numerator_units detect nits index ","@denominator_@numerator_units find nits delete_at ","@denominator_@numerator_units detect nits delete_at ","@n@numerator_units find merator_@numerator_units find nits find ","@n@numerator_units detect merator_@numerator_units detect nits find ","@denominator_@numerator_units find nits each_with_index ","@denominator_@numerator_units detect nits each_with_index "," sans_common_@numerator_units find nits "," sans_common_@numerator_units detect nits "," @numerator_units find nitless? "," @numerator_units detect nitless? ","@n@numerator_units find merator_@numerator_units find nits detect ","@n@numerator_units detect merator_@numerator_units detect nits detect "]}," Value Number compute_units":{"type":"method","name":"compute_units","children":[],"call":["this denominator_units ","this numerator_units ","this denominator_units + ","other numerator_units ","this numerator_units + ","other denominator_units "]}," Value Number coercion_factor":{"type":"method","name":"coercion_factor","children":[],"call":["m * "," conversion_factor ","p [] ","from_units zip inject ","from_units zip "," raise ","Sass UnitConversionError  new ","to_units join ","from_units join "," convertable? ! "," convertable? ","from_units | ","from_units size != ","to_units size ","from_units size "," sans_common_units "]}," Value Number operate":{"type":"method","name":"operate","children":[],"call":["Bool  new ","Number  new "," compute_units ","result is_a? ","value send ","other value ","this value ","this value to_f ","/ == ","other coerce ","this coerce ","other denominator_units ","other numerator_units "," unitless? ","OPERATIONS  include? ","value send  is_a? ","this value  send ","this value to_f  send ","other this value  ","other this value to_f  ","other coerce  value ","this this value  ","this this value to_f  ","this coerce  value ","this this value  to_f ","this this value to_f  to_f ","this coerce  value to_f ","other coerce  coerce ","this coerce  coerce ","other coerce  denominator_units ","other coerce  numerator_units "]}," Value Number round":{"type":"method","name":"round","children":[],"call":[]}," Value Number unit_str":{"type":"method","name":"unit_str","children":[],"call":["rv << ","@denominator_units sort join ","@denominator_units sort ","@denominator_units any? ","@numerator_units sort join ","@numerator_units sort ","@numerator_units sort join  << "]}," Value Number comparable_to?":{"type":"method","name":"comparable_to?","children":[],"call":[" operate "]}," Value Number coerce":{"type":"method","name":"coerce","children":[],"call":["Number  new "," value * / "," coercion_factor "," value * "," value "," unitless? "]}," Value Number legal_units?":{"type":"method","name":"legal_units?","children":[],"call":["@denominator_units empty? ","@numerator_units size == ","@numerator_units size ","@numerator_units empty? "]}," Value Number is_unit?":{"type":"method","name":"is_unit?","children":[],"call":[" unitless? "," numerator_units first == "," numerator_units first "," numerator_units "," numerator_units size == "," numerator_units size "," denominator_units size == "," denominator_units size "," denominator_units "]}," Value Number unitless?":{"type":"method","name":"unitless?","children":[],"call":["@denominator_units empty? ","@numerator_units empty? "]}," Value Number int?":{"type":"method","name":"int?","children":[],"call":[" value % == "," value % "," value "," basically_equal? "]}," Value Number to_i":{"type":"method","name":"to_i","children":[],"call":[" value "," int? "," value to_i "]}," Value Number inspect":{"type":"method","name":"inspect","children":[],"call":[" unit_str "," unitless? ","(send\n  (dstr\n    (str \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    (str \"f\")) :%\n  (lvar :value)) gsub ","(str \"%0.\") % "," class precision "," class ","str include? ","value to_s "," class round "," value "," original ","str sub! "," options [] == "," options [] "," options ","str =~ "," unit_(send\n  (dstr\n    (str \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    (str \"f\")) :%\n  (lvar :value)) gsub  "," unit_value to_s  ","(send\n  (d(send\n  (dstr\n    (str \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    (str \"f\")) :%\n  (lvar :value)) gsub \n    ((send\n  (dstr\n    (str \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    (str \"f\")) :%\n  (lvar :value)) gsub  \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    ((send\n  (dstr\n    (str \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    (str \"f\")) :%\n  (lvar :value)) gsub  \"f\")) :%\n  (lvar :value)) gsub ","(send\n  (dvalue to_s \n    (value to_s  \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    (value to_s  \"f\")) :%\n  (lvar :value)) gsub ","(send\n  (dstr\n    (str \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    (str \"f\")) :%\n  (lvar : class round )) gsub ","((send\n  (dstr\n    (str \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    (str \"f\")) :%\n  (lvar :value)) gsub  \"%0.\") % ","(value to_s  \"%0.\") % ","(send\n  (dstr\n    (str \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    (str \"f\")) :%\n  (lvar :value)) gsub  include? ","value to_s  include? "," class round  to_s ","  class round  ","(send\n  (dstr\n    (str \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    (str \"f\")) :%\n  (lvar :value)) gsub  sub! ","value to_s  sub! ","(send\n  (dstr\n    (str \"%0.\")\n    (begin\n      (send\n        (send\n          (self) :class) :precision))\n    (str \"f\")) :%\n  (lvar :value)) gsub  =~ ","value to_s  =~ "]}," Value Number to_s":{"type":"method","name":"to_s","children":[],"call":[" inspect "," raise ","Sass SyntaxError  new "," legal_units? "," original "]}," Value Number lte":{"type":"method","name":"lte","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Value Number lt":{"type":"method","name":"lt","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Value Number gte":{"type":"method","name":"gte","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Value Number gt":{"type":"method","name":"gt","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Value Number eql?":{"type":"method","name":"eql?","children":[],"call":[" denominator_units == ","other denominator_units "," denominator_units "," numerator_units == ","other numerator_units "," numerator_units "," value == ","other value "," value "," basically_equal? "]}," Value Number hash":{"type":"method","name":"hash","children":[],"call":["(send nil :value) hash "," denominator_units "," numerator_units "," value "]}," Value Number eq":{"type":"method","name":"eq","children":[],"call":["Bool  new ","this value == ","other value ","this value ","other coerce ","this coerce ","other denominator_units ","other numerator_units "," unitless? ","other is_a? ","Sass Script Value Bool  new "," basically_equal? ","this coerce  value == ","other coerce  value ","this coerce  value ","other coerce  coerce ","this coerce  coerce ","other coerce  denominator_units ","other coerce  numerator_units ","other coerce  is_a? "]}," Value Number mod":{"type":"method","name":"mod","children":[],"call":[" raise ","NoMethodError  new "," operate ","other is_a? ","Sass UnitConversionError  new ","other inspect ","other unitless? ","Number  new ","other value == ","other value "]}," Value Number div":{"type":"method","name":"div","children":[],"call":["res original= ","other original "," original "," operate ","other is_a? "," operate  original= "]}," Value Number times":{"type":"method","name":"times","children":[],"call":[" raise ","NoMethodError  new ","other times ","other is_a? "," operate "]}," Value Number unary_minus":{"type":"method","name":"unary_minus","children":[],"call":["Number  new "," value -@ "," value "]}," Value Number unary_plus":{"type":"method","name":"unary_plus","children":[],"call":[]}," Value Number minus":{"type":"method","name":"minus","children":[],"call":[" operate ","other is_a? "]}," Value Number plus":{"type":"method","name":"plus","children":[],"call":["other plus ","other is_a? "," operate "]}," Value Number initialize":{"type":"method","name":"initialize","children":[],"call":[" normalize! ","denominator_units is_a? ","numerator_units is_a? "]}," Value Number precision_factor":{"type":"method","name":"precision_factor","children":[],"call":[]}," Value Number precision=":{"type":"method","name":"precision=","children":[],"call":[]}," Value Number precision":{"type":"method","name":"precision","children":[],"call":[]}," Value Null inspect":{"type":"method","name":"inspect","children":[],"call":[]}," Value Null to_sass":{"type":"method","name":"to_sass","children":[],"call":[]}," Value Null to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Value Null neq":{"type":"method","name":"neq","children":[],"call":["other neq ","other is_a? "]}," Value Null null?":{"type":"method","name":"null?","children":[],"call":[]}," Value Null to_bool":{"type":"method","name":"to_bool","children":[],"call":[]}," Value Null new":{"type":"method","name":"new","children":[],"call":[]}," Value Map to_sass":{"type":"method","name":"to_sass","children":[],"call":["(send\n  (send nil :value) :map) join ","to_sass [] "," value map "," value ","value to_sass ","value separator == ","value separator ","value is_a? "," lambda "," value empty? "]}," Value Map to_s":{"type":"method","name":"to_s","children":[],"call":[" raise ","Sass SyntaxError  new "," inspect "]}," Value Map hash":{"type":"method","name":"hash","children":[],"call":[" value hash "," value "]}," Value Map eq":{"type":"method","name":"eq","children":[],"call":["Bool  new "," value == ","other value "," value ","other is_a? "]}," Value Map to_a":{"type":"method","name":"to_a","children":[],"call":["list options= "," options ","List  new "," value map "," value ","List  new  options= "]}," Value Map separator":{"type":"method","name":"separator","children":[],"call":[" value empty? "," value "]}," Value Map options=":{"type":"method","name":"options=","children":[],"call":["v options= ","k options= "," value each "," value "]}," Value Map initialize":{"type":"method","name":"initialize","children":[],"call":["Sass Util  ordered_hash "]}," Value List sep_str":{"type":"method","name":"sep_str","children":[],"call":["opts [] == ","opts [] "," separator == "," separator "]}," Value List element_needs_parens?":{"type":"method","name":"element_needs_parens?","children":[],"call":["element operator == ","element operator ","element is_a? "," separator == "," separator ","Sass Script Parser  precedence_of <= ","Sass Script Parser  precedence_of ","element separator ","element value empty? ","element value ","element bracketed ","element value length < ","element value length ","Sass Script Parser  Sass Script Parser  precedence_of _of <= ","Sass Script Parser  Sass Script Parser  precedence_of _of "]}," Value List assert_valid_index":{"type":"method","name":"assert_valid_index","children":[],"call":[]}," Value List inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :value) :map) join "," sep_str ","e inspect "," value map "," value ","(if\n  (send nil :bracketed)\n  (str \"[\")\n  (str \"(\")) + + "," bracketed ","(if\n  (send nil :bracketed)\n  (str \"[\")\n  (str \"(\")) + "]}," Value List is_pseudo_map?":{"type":"method","name":"is_pseudo_map?","children":[],"call":["e to_a length == ","e to_a length ","e to_a ","e is_a? "," value all? "," value "]}," Value List needs_map_warning?":{"type":"method","name":"needs_map_warning?","children":[],"call":["@map ! ","@value empty? ! ","@value empty? "]}," Value List to_h":{"type":"method","name":"to_h","children":[],"call":["Sass Util  to_hash ","e to_a "," value map "," value "," is_pseudo_map? ","Sass Util  ordered_hash "," value empty? "]}," Value List to_sass":{"type":"method","name":"to_sass","children":[],"call":["members join "," sep_str ","members first "," separator == "," separator ","members length == ","members length ","v to_sass "," element_needs_parens? "," value map "," value "," value empty? ","(send\n  (block\n    (send\n      (send nil :value) :reject)\n    (args\n      (arg :e))\n    (send\n      (lvar :e) :is_a?\n      (const nil :Null))) :map) join ","Sass Script Parser  precedence_of <= ","Sass Script Parser  precedence_of ","v separator ","v is_a? ","(send\n  (send nil :value) :reject) map ","e is_a? "," value reject ","v operator == ","v operator "," bracketed ","Sass Script Parser  Sass Script Parser  precedence_of _of <= ","Sass Script Parser  Sass Script Parser  precedence_of _of "]}," Value List to_s":{"type":"method","name":"to_s","children":[],"call":["(send\n  (block\n    (send\n      (send nil :value) :reject)\n    (args\n      (arg :e))\n    (or\n      (send\n        (lvar :e) :is_a?\n        (const nil :Null))\n      (and\n        (send\n          (lvar :e) :is_a?\n          (const nil :List))\n        (send\n          (send\n            (lvar :e) :value) :empty?)))) :map) join "," sep_str ","e to_s ","(send\n  (send nil :value) :reject) map ","e value empty? ","e value ","e is_a? "," value reject "," value "," raise ","Sass SyntaxError  new "," value empty? "," bracketed ","members join "," inspect "," bracketed ! "]}," Value List hash":{"type":"method","name":"hash","children":[],"call":["(send nil :value) hash "," separator "," value "," bracketed "]}," Value List eq":{"type":"method","name":"eq","children":[],"call":["Sass Script Value Bool  new "," separator == ","other separator "," separator "," value == ","other value "," value ","other is_a? "," bracketed == ","other bracketed "," bracketed "]}," Value List options=":{"type":"method","name":"options=","children":[],"call":["v options= "," value each "," value "]}," Value List initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Value Helpers parse_unit_string":{"type":"method","name":"parse_unit_string","children":[],"call":[" raise ","ArgumentError  new ","unit !~ ","units any? ","units size == ","units size ","unit_string =~ ","(array\n  (lvar :numerator_units)\n  (str \"numerator\")) each ","(or\n  (send\n    (lvar :num_over_denominator) :[]\n    (int 1))\n  (str \"\")) split ","num_over_denominator [] ","num_over_denominator [] split ","(irange\n  (int 1)\n  (int 2)) include? ","num_over_denominator size ","unit_string split ","unit_string length > ","unit_string length ","(array\n  (lvar :num_over_denominator [] split )\n  (str \"numerator\")) each ","(or\n  (send\n    (lvar :unit_string split ) :[]\n    (int 1))\n  (str \"\")) split ","unit_string split  [] ","unit_string split  [] split ","unit_string split  size "]}," Value Helpers unquoted_string":{"type":"method","name":"unquoted_string","children":[],"call":["Sass Script String  new "]}," Value Helpers quoted_string":{"type":"method","name":"quoted_string","children":[],"call":["Sass Script String  new "]}," Value Helpers null":{"type":"method","name":"null","children":[],"call":["Sass Script Value Null  new "]}," Value Helpers map":{"type":"method","name":"map","children":[],"call":["Map  new "]}," Value Helpers list":{"type":"method","name":"list","children":[],"call":["Sass Script Value List  new ","elements first ","elements first is_a? ","elements size == ","elements size ","elements pop "," raise ","ArgumentError  new ","elements last is_a? ","elements last ","separator nil? ","elements first  first ","elements first  first is_a? ","elements first  size == ","elements first  size ","elements first  pop ","elements first  last is_a? ","elements first  last ","elements pop  nil? "]}," Value Helpers number":{"type":"method","name":"number","children":[],"call":["Number  new "," parse_unit_string "]}," Value Helpers rgb_color":{"type":"method","name":"rgb_color","children":[],"call":["Color  new ","attrs []= "]}," Value Helpers hsl_color":{"type":"method","name":"hsl_color","children":[],"call":["Color  new ","attrs []= "]}," Value Helpers hex_color":{"type":"method","name":"hex_color","children":[],"call":["Color  from_hex "]}," Value Helpers bool":{"type":"method","name":"bool","children":[],"call":["Bool  new "]}," Value DeprecatedFalse warned=":{"type":"method","name":"warned=","children":[],"call":["@global_env deprecated_false_warning_given << ","@global_env deprecated_false_warning_given "]}," Value DeprecatedFalse warned?":{"type":"method","name":"warned?","children":[],"call":["@global_env deprecated_false_warning_given include? ","@global_env deprecated_false_warning_given "]}," Value DeprecatedFalse neq":{"type":"method","name":"neq","children":[],"call":["Bool  new ","other value != ","other value ","Sass Util  sass_warn ","(str \"DEPRECATION WARNING: The return value of index() will change from \\\"false\\\" to\\n\") + ","@global_env stack to_s gsub ","@global_env stack to_s ","@global_env stack "," warned= "," warned? ! "," warned? ","other value nil? "]}," Value DeprecatedFalse eq":{"type":"method","name":"eq","children":[],"call":["Bool  new ","other value == ","other value ","Sass Util  sass_warn ","(str \"DEPRECATION WARNING: The return value of index() will change from \\\"false\\\" to\\n\") + ","@global_env stack to_s gsub ","@global_env stack to_s ","@global_env stack "," warned= "," warned? ! "," warned? "]}," Value DeprecatedFalse initialize":{"type":"method","name":"initialize","children":[],"call":["frame line ","frame filename ","environment stack frames last ","environment stack frames ","environment stack ","environment global_env ","environment stack frames last  line ","environment stack frames last  filename ","environment stack environment stack frames last s last ","environment stack environment stack frames last s "]}," Value DeprecatedFalse new":{"type":"method","name":"new","children":[],"call":[]}," Value Color rgb_to_hsl!":{"type":"method","name":"rgb_to_hsl!","children":[],"call":["@attrs []= ","l * ","s * ","h % ","d / ","2 - ","2 * ","l < ","max == ","(send\n  (lvar :max) :+\n  (lvar :min)) / ","max + ","60 * / + ","60 * / ","60 * ","r - ","b - ","g - ","max - ","(lvar :r) min ","(lvar :r) max ","@attrs [] / ","@attrs [] ","(sym :red) map ","(send\n  (lvar :max) :+\n  (lvar :min)) /  * ","max -  / ","(send\n  (lvar :max) :+\n  (lvar :min)) /  < ","(lvar :r) max  == ","(send\n  ((send\n  (lvar :max) :+\n  (lvar :min)) / var :max) :+\n  ((send\n  (lvar :max) :+\n  (lvar :min)) / var :min)) / ","(senmax - \n  (lvar :max) :+\n  (lvar :min)) / ","(send\n  (lvar :max) :+\n  (lvar :(lvar :r) min )) / ","(send\n  (lvar :(lvar :r) max ) :+\n  (lvar :min)) / ","(lvar :r) max  + ","(lvar :r) max  - ","((send\n  (lvar :max) :+\n  (lvar :min)) / var :r) min ","(lvar :r) (lvar :r) min  ","((send\n  (lvar :max) :+\n  (lvar :min)) / var :r) max ","(lvar :r) (lvar :r) max  ","(sym :remax - ) map "]}," Value Color hue_to_rgb":{"type":"method","name":"hue_to_rgb","children":[],"call":["m1 + ","(send\n  (lvar :m2) :-\n  (lvar :m1)) * * ","(send\n  (lvar :m2) :-\n  (lvar :m1)) * ","2.0 / - ","2.0 / ","m2 - ","h * < ","h * ","h > ","h < "]}," Value Color hsl_to_rgb!":{"type":"method","name":"hsl_to_rgb!","children":[],"call":["(send\n  (lvar :c) :*\n  (int 255)) round ","c * ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :m2)\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map "," hue_to_rgb ","h - ","1.0 / ","h + ","@attrs []= ","l * - ","l * ","l + - ","l + ","s + ","l <= ","@attrs [] / ","@attrs [] ","Sass Util  round ","(send\n  (@attrs [] / var :c) :*\n  (int 255)) round ","(@attrs [] / end\n  (lvar :c) :*\n  (int 255)) round ","(send nil :hue_to_rgb\n  (lvar :l * - )\n  (lvar :m2)\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :l + - )\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :l * )\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send ni@attrs [] /  :hue_to_rgb\n  (@attrs [] / var :m1)\n  (@attrs [] / var :m2)\n  (send\n    (@attrs [] / var :h) :+\n    (send\n      (f@attrs [] / oat 1.0) :/\n      (int 3)))) map ","(@attrs [] / end nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :m2)\n  (@attrs [] / end\n    (lvar :h) :+\n    (@attrs [] / end\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :@attrs [] / ue_to_rgb\n  (lvar :m1)\n  (lvar :m2)\n  (send\n    (lvar :@attrs [] / ) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map "," @attrs [] / ue_to_rgb ","@attrs [] /  - ","@attrs [] /  + ","@attr@attrs [] /  []= ","@attrs [] /  * - ","@attrs [] /  * ","@attrs [] /  + - ","@attrs [] /  <= ","@attr@attrs [] /  [] / ","@attr@attrs [] /  [] ","Sass Uti@attrs [] /   round ","Sa@attrs [] / @attrs [] /  Util  round "]}," Value Color piecewise":{"type":"method","name":"piecewise","children":[],"call":[" with ","result [] "," raise ","Sass SyntaxError  new ","other alpha != "," alpha ","other alpha ","other_num ! ","result []= ","(send\n  (array\n    (lvar :res)\n    (int 255)) :min) max ","(lvar :res) min "," rgb [] send ","other rgb [] ","other rgb ","other value "," rgb [] "," rgb ","(erange\n  (int 0)\n  (int 3)) each ","other unitless? ! ","other unitless? ","other is_a? "," rgb [] to_f send "," rgb [] to_f "," operation_name "," rgb [] send ult [] "," rgb [] to_f send ult [] ","other is_a?  ! "," rgb [] send ult []= "," rgb [] to_f send ult []= ","(send\n  (array\n    (lvar : rgb [] send )\n    (int 255)) :min) max ","(send\n  (array\n    (lvar : rgb [] to_f send )\n    (int 255)) :min) max ","(lvar : rgb [] send ) min ","(lvar : rgb [] to_f send ) min "]}," Value Color hex_str":{"type":"method","name":"hex_str","children":[],"call":["num to_s rjust ","num to_s "," rgb map "," rgb "]}," Value Color rgba_str":{"type":"method","name":"rgba_str","children":[],"call":["Number  round "," alpha "," rgb join "," rgb "," options [] == "," options [] "," options "]}," Value Color smallest":{"type":"method","name":"smallest","children":[],"call":["color size <= ","small_explicit_str size ","color size ","COLOR_NAMES_REVERSE  [] "," rgba "," hex_str gsub "," hex_str "," rgba_str "," alpha? ","str size ","(send nil :representation) compact min_by ","(send nil :representation) compact "," representation ","COLOR_NAMES_REVERSE  []  size <= "," hex_str gsub  size "," rgba_str  size ","COLOR_NAMES_REVERSE  []  size "]}," Value Color inspect":{"type":"method","name":"inspect","children":[],"call":[" hex_str "," rgba_str "," alpha? "]}," Value Color to_s":{"type":"method","name":"to_s","children":[],"call":[" hex_str "," rgba_str "," alpha? ","COLOR_NAMES_REVERSE  [] "," rgba "," smallest "," options [] == "," options [] "," options "," name "," representation ","Number  basically_equal? "," alpha "]}," Value Color mod":{"type":"method","name":"mod","children":[],"call":[" raise ","NoMethodError  new "," piecewise ","other is_a? "]}," Value Color div":{"type":"method","name":"div","children":[],"call":[" piecewise ","other is_a? "]}," Value Color times":{"type":"method","name":"times","children":[],"call":[" raise ","NoMethodError  new "," piecewise ","other is_a? "]}," Value Color minus":{"type":"method","name":"minus","children":[],"call":[" piecewise ","other is_a? "]}," Value Color plus":{"type":"method","name":"plus","children":[],"call":[" piecewise ","other is_a? "]}," Value Color with":{"type":"method","name":"with","children":[],"call":["Color  new "," alpha ","attrs [] ","@attrs merge "," send ","(sym :red) each ","(sym :hue) each "," raise ","ArgumentError  new ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ! ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ","(sym :red) & ","attrs keys ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ! ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ","(sym :hue) & ","v nil? ","attrs reject ","@attrs merge  [] ","@@attrs merge  merge ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ! ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ","@attrs merge  keys ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ! ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ","@attrs merge  reject "]}," Value Color hash":{"type":"method","name":"hash","children":[],"call":["(send nil :rgb) hash "," alpha "," rgb "]}," Value Color eq":{"type":"method","name":"eq","children":[],"call":["Sass Script Value Bool  new "," alpha == ","other alpha "," alpha "," rgb == ","other rgb "," rgb ","other is_a? "]}," Value Color hsla":{"type":"method","name":"hsla","children":[],"call":["(send nil :hue) freeze "," lightness "," saturation "," hue "," alpha "]}," Value Color hsl":{"type":"method","name":"hsl","children":[],"call":["(send nil :hue) freeze "," lightness "," saturation "," hue "]}," Value Color rgba":{"type":"method","name":"rgba","children":[],"call":["(send nil :red) freeze "," alpha "," blue "," green "," red "]}," Value Color rgb":{"type":"method","name":"rgb","children":[],"call":["(send nil :red) freeze "," blue "," green "," red "]}," Value Color alpha?":{"type":"method","name":"alpha?","children":[],"call":[" alpha < "," alpha "]}," Value Color alpha":{"type":"method","name":"alpha","children":[],"call":["@attrs [] to_f ","@attrs [] "]}," Value Color lightness":{"type":"method","name":"lightness","children":[],"call":["@attrs [] "," rgb_to_hsl! "]}," Value Color saturation":{"type":"method","name":"saturation","children":[],"call":["@attrs [] "," rgb_to_hsl! "]}," Value Color hue":{"type":"method","name":"hue","children":[],"call":["@attrs [] "," rgb_to_hsl! "]}," Value Color blue":{"type":"method","name":"blue","children":[],"call":["@attrs [] "," hsl_to_rgb! "]}," Value Color green":{"type":"method","name":"green","children":[],"call":["@attrs [] "," hsl_to_rgb! "]}," Value Color red":{"type":"method","name":"red","children":[],"call":["@attrs [] "," hsl_to_rgb! "]}," Value Color from_hex":{"type":"method","name":"from_hex","children":[],"call":[]}," Value Color initialize":{"type":"method","name":"initialize","children":[],"call":["@attrs []= ","Sass Util  check_range ","@attrs [] ","k to_s capitalize ","k to_s ","Number  new ","@attrs [] nil? ","(sym :saturation) each ","@attrs [] to_i ","(sym :red) each "," raise ","ArgumentError  new ","rgb size != ","rgb size ","rgb empty? ! ","rgb empty? ","hsl size != ","hsl size ","hsl empty? ! ","hsl empty? ","allow_both_rgb_and_hsl ! ","(sym :red) & ","attrs keys ","(sym :hue) & ","v nil? ","attrs reject ","attrs [] to_f ","attrs [] ","c to_i ","attrs [] map ","(irange\n  (int 3)\n  (int 4)) include? ","attrs size ","attrs is_a? ","Sass Util  restrict ","@attrs delete ","@attrs [] round ","c round ","Sass Util  round ","(sym :red) &  size != ","(sym :red) &  size ","(sym :red) &  empty? ! ","(sym :red) &  empty? ","(sym :hue) &  size != ","(sym :hue) &  size ","(sym :hue) &  empty? ! ","(sym :hue) &  empty? ","allow_both_(sym :red) & _and_hsl ! ","allow_both_rgb_and_(sym :hue) &  ! "]}," Value Color int_to_rgba":{"type":"method","name":"int_to_rgba","children":[],"call":[]}," Value Bool to_s":{"type":"method","name":"to_s","children":[],"call":["@value to_s "]}," Value Bool eq":{"type":"method","name":"eq","children":[],"call":["other eq ","other is_a? "]}," Value Bool new":{"type":"method","name":"new","children":[],"call":[]}," Value Base _perform":{"type":"method","name":"_perform","children":[],"call":[]}," Value Base null?":{"type":"method","name":"null?","children":[],"call":[]}," Value Base to_s":{"type":"method","name":"to_s","children":[],"call":["Sass Util  abstract "]}," Value Base to_h":{"type":"method","name":"to_h","children":[],"call":[" raise ","Sass SyntaxError  new "," inspect "]}," Value Base to_a":{"type":"method","name":"to_a","children":[],"call":[]}," Value Base separator":{"type":"method","name":"separator","children":[],"call":[]}," Value Base assert_int!":{"type":"method","name":"assert_int!","children":[],"call":[" to_i "]}," Value Base to_i":{"type":"method","name":"to_i","children":[],"call":[" raise ","Sass SyntaxError  new "," inspect "]}," Value Base ==":{"type":"method","name":"==","children":[],"call":[" eq to_bool "," eq "]}," Value Base to_bool":{"type":"method","name":"to_bool","children":[],"call":[]}," Value Base inspect":{"type":"method","name":"inspect","children":[],"call":[" value inspect "," value "]}," Value Base eql?":{"type":"method","name":"eql?","children":[],"call":[" == "]}," Value Base hash":{"type":"method","name":"hash","children":[],"call":[" value hash "," value "]}," Value Base unary_div":{"type":"method","name":"unary_div","children":[],"call":["Sass Script Value String  new "," to_s "]}," Value Base unary_minus":{"type":"method","name":"unary_minus","children":[],"call":["Sass Script Value String  new "," to_s "]}," Value Base unary_plus":{"type":"method","name":"unary_plus","children":[],"call":["Sass Script Value String  new "," to_s "]}," Value Base div":{"type":"method","name":"div","children":[],"call":["Sass Script Value String  new ","other to_s "," to_s "]}," Value Base minus":{"type":"method","name":"minus","children":[],"call":["Sass Script Value String  new ","other to_s "," to_s "]}," Value Base plus":{"type":"method","name":"plus","children":[],"call":["Sass Script Value String  new "," to_s + ","other to_s "," to_s ","other type ","other value ","other is_a? ","other other type  "]}," Value Base single_eq":{"type":"method","name":"single_eq","children":[],"call":["Sass Script Value String  new ","other to_s "," to_s "]}," Value Base unary_not":{"type":"method","name":"unary_not","children":[],"call":["Sass Script Value Bool  new "," to_bool ! "," to_bool "]}," Value Base neq":{"type":"method","name":"neq","children":[],"call":["Sass Script Value Bool  new "," eq to_bool ! "," eq to_bool "," eq "]}," Value Base eq":{"type":"method","name":"eq","children":[],"call":["Sass Script Value Bool  new "," value == ","other value "," value "," class == ","other class "," class "]}," Value Base options":{"type":"method","name":"options","children":[],"call":[" raise ","Sass SyntaxError  new "," class "]}," Value Base initialize":{"type":"method","name":"initialize","children":[],"call":["value freeze ","value == ","value nil? "]}," Value ArgList keywords":{"type":"method","name":"keywords","children":[],"call":[]}," Value ArgList initialize":{"type":"method","name":"initialize","children":[],"call":["Sass Util NormalizedMap  new ","keywords is_a? "]}," Tree Variable _perform":{"type":"method","name":"_perform","children":[],"call":["val original= ","val dup ","val original ","val is_a? "," raise ","Sass SyntaxError  new "," name ","environment var ","val dup  original= ","environment var  original= ","val dup  dup ","environment var  dup ","val dup  original ","environment var  original ","val dup  is_a? ","environment var  is_a? "]}," Tree Variable deep_copy":{"type":"method","name":"deep_copy","children":[],"call":[" dup "]}," Tree Variable children":{"type":"method","name":"children","children":[],"call":[]}," Tree Variable inspect":{"type":"method","name":"inspect","children":[],"call":[" dasherize "," name "]}," Tree Variable initialize":{"type":"method","name":"initialize","children":[],"call":["name gsub ","name tr "]}," Tree UnaryOperation _perform":{"type":"method","name":"_perform","children":[],"call":[" raise ","Sass SyntaxError  new ","e name to_s == ","operator to_s ","e name to_s ","e name ","value send ","@operand perform ","@operand perform  send "]}," Tree UnaryOperation deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","@operand deep_copy "," dup "," dup  instance_variable_set "]}," Tree UnaryOperation children":{"type":"method","name":"children","children":[],"call":[]}," Tree UnaryOperation to_sass":{"type":"method","name":"to_sass","children":[],"call":["op + + ","op + ","op =~ ","Sass Script Lexer OPERATORS_REVERSE  [] ","@operand to_sass ","(send\n  (lvar :operand) :=~\n  (const\n    (const\n      (const\n        (const nil :Sass) :SCSS) :RX) :IDENT)) == ","operand =~ ","@operator == ","@operand is_a? ","Sass Script Lexer OPERATORS_REVERSE  []  + + ","Sass Script Lexer OPERATORS_REVERSE  []  + ","Sass Script Lexer OPERATORS_REVERSE  []  =~ ","@Sass Script Lexer OPERATORS_REVERSE  [] erand to_sass ","@@operand to_sass  to_sass ","(send\n  (lvar :Sass Script Lexer OPERATORS_REVERSE  [] erand) :=~\n  (const\n    (const\n      (const\n        (const nil :Sass) :SCSS) :RX) :IDENT)) == ","(send\n  (lvar :@operand to_sass ) :=~\n  (const\n    (const\n      (const\n        (const nil :Sass) :SCSS) :RX) :IDENT)) == ","Sass Script Lexer OPERATORS_REVERSE  [] erand =~ ","@operand to_sass  =~ ","@Sass Script Lexer OPERATORS_REVERSE  [] erator == ","@Sass Script Lexer OPERATORS_REVERSE  [] erand is_a? ","@@operand to_sass  is_a? "]}," Tree UnaryOperation inspect":{"type":"method","name":"inspect","children":[],"call":["@operand inspect ","@operator inspect "]}," Tree UnaryOperation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree StringInterpolation parse_str":{"type":"method","name":"parse_str","children":[],"call":[]}," Tree StringInterpolation _perform":{"type":"method","name":"_perform","children":[],"call":[" opts ","Sass Script Value String  new ","before type ","res << ","@after perform value ","@after perform ","mid to_s ","mid value ","mid is_a? ","@mid perform ","before value ","@before perform "," type ","(send\n  (send nil :contents) :map) join ","value to_s ","value value ","value is_a? ","c perform ","c is_a? "," contents map "," contents ","@before perform  type ","@after perform c perform  ","@mid perform  to_s ","@mid perform  value ","mid c perform  ","@mid perform  is_a? ","@@mid perform  perform ","@before perform  value ","before c perform  ","@@before perform  perform ","c perform  to_s ","c perform  c perform  ","c perform  is_a? "]}," Tree StringInterpolation deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","@after deep_copy ","@mid deep_copy ","@before deep_copy "," dup ","c deep_copy ","c is_a? "," contents map "," contents "," dup  instance_variable_set "]}," Tree StringInterpolation children":{"type":"method","name":"children","children":[],"call":["(ivar :@before) compact ","c is_a? "," contents select "," contents "]}," Tree StringInterpolation to_sass":{"type":"method","name":"to_sass","children":[],"call":["res << ","res << << << ","res << << ","@mid to_sass ","after_str gsub! ","before_str gsub! ","before_quote_char != ","before_str empty? ! ","before_str empty? ","before_quote_char ! ","after_str empty? ! ","after_str empty? ","after_quote_char ! "," parse_str ","@after to_sass ","@before to_sass ","quote != "," _to_sass "," after ","opts merge "," before "," quote_for ","opts [] "," type == "," type ","c to_sass ","Sass Script Value String  quote slice ","Sass Script Value String  quote ","c is_a? "," contents each "," contents "," detected_quote ","before_quote_Sass Script Value String  quote slice har != ","before_quote_Sass Script Value String  quote slice har ! ","after_quote_Sass Script Value String  quote slice har ! ","opts merge  merge ","opts merge  [] ","Sass Script Value String  quote slice  to_sass ","Sass SSass Script Value String  quote slice ript Value String  quote sliSass Script Value String  quote slice e ","Sass SSass Script Value String  quote slice ript Value String  quote ","Sass Script Value String  quote slice  is_a? "," Sass Script Value String  quote slice ontents eaSass Script Value String  quote slice h "," Sass Script Value String  quote slice ontents "," deteSass Script Value String  quote slice ted_quote "]}," Tree StringInterpolation inspect":{"type":"method","name":"inspect","children":[],"call":["@after inspect ","@mid inspect ","@before inspect ","(send\n  (send nil :contents) :map) join ","c inspect "," contents map "," contents ","@type inspect "]}," Tree StringInterpolation initialize":{"type":"method","name":"initialize","children":[],"call":["Sass Util  merge_adjacent_strings "]}," Tree Operation operand_to_sass":{"type":"method","name":"operand_to_sass","children":[],"call":["op to_sass ","assoc ! ","sub_pred == ","side == ","sub_pred < ","Sass Script Parser  associative? ","Sass Script Parser  precedence_of ","op operator ","op is_a? ","Sass Script Parser  associative?  ! ","Sass Script Parser  precedence_of  == ","sub_Sass Script Parser  precedence_of  == ","Sass Script Parser  precedence_of  < ","sub_Sass Script Parser  precedence_of  < ","Sass Script Parser  Sass Script Parser  associative? iative? "]}," Tree Operation _perform":{"type":"method","name":"_perform","children":[],"call":[" raise ","Sass SyntaxError  new ","e name to_s == ","@operator to_s ","e name to_s ","e name "," opts ","value1 send ","value2 inspect ","value1 inspect ","@operator != ","value2 is_a? ","value1 is_a? ","@operand2 perform ","value1 to_bool ","@operator == ","@operand1 perform ","Sass Util  sass_warn "," filename "," line ","value1 unitless? != ","value2 unitless? ","value1 unitless? ","result == ","value2 to_sass ","value1 to_sass "," css_variable_warning warn! "," css_variable_warning ","(and\n  (send\n    (lvar :value1) :is_a?\n    (const\n      (const\n        (const\n          (const nil :Sass) :Script) :Value) :String))\n  (send\n    (lvar :value2) :is_a?\n    (const\n      (const\n        (const\n          (const nil :Sass) :Script) :Value) :String))) ! ","(and\n  (and\n    (and\n      (send\n        (lvar :value1) :is_a?\n        (const\n          (const\n            (const\n              (const nil :Sass) :Script) :Value) :Number))\n      (send\n        (lvar :value1) :original))\n    (send\n      (lvar :value2) :is_a?\n      (const\n        (const\n          (const\n            (const nil :Sass) :Script) :Value) :Number)))\n  (send\n    (lvar :value2) :original)) ! ","value2 original ","value1 original "," warn_for_unitless_equals "," warn_for_color_arithmetic ","@operand1 perform  send ","@operand2 perform  inspect ","@operand1 perform  inspect ","@operand2 perform  is_a? ","@operand1 perform  is_a? ","@operand1 perform  to_bool ","@operand1 perform  unitless? != ","@operand2 perform  unitless? ","@operand1 perform  unitless? "," opts  == ","@operand2 perform  to_sass ","@operand1 perform  to_sass ","(and\n  (send\n    (lvar :value1) :is_a?\n    (const\n      (const\n        (const\n          (const nil :Sass) :Script) :Value) :String))\n  (send\n    (lvar :@operand2 perform ) :is_a?\n    (const\n      (const\n        (const\n          (const nil :Sass) :Script) :Value) :String))) ! ","(and\n  (send\n    (lvar :@operand1 perform ) :is_a?\n    (const\n      (const\n        (const\n          (const nil :Sass) :Script) :Value) :String))\n  (send\n    (lvar :value2) :is_a?\n    (const\n      (const\n        (const\n          (const nil :Sass) :Script) :Value) :String))) ! ","(and\n  (and\n    (and\n      (send\n        (lvar :value1) :is_a?\n        (const\n          (const\n            (const\n              (const nil :Sass) :Script) :Value) :Number))\n      (send\n        (lvar :value1) :original))\n    (send\n      (lvar :@operand2 perform ) :is_a?\n      (const\n        (const\n          (const\n            (const nil :Sass) :Script) :Value) :Number)))\n  (send\n    (lvar :@operand2 perform ) :original)) ! ","(and\n  (and\n    (and\n      (send\n        (lvar :@operand1 perform ) :is_a?\n        (const\n          (const\n            (const\n              (const nil :Sass) :Script) :Value) :Number))\n      (send\n        (lvar :@operand1 perform ) :original))\n    (send\n      (lvar :value2) :is_a?\n      (const\n        (const\n          (const\n            (const nil :Sass) :Script) :Value) :Number)))\n  (send\n    (lvar :value2) :original)) ! ","@operand2 perform  original ","@operand1 perform  original "]}," Tree Operation deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","@operand2 deep_copy ","@operand1 deep_copy "," dup "," dup  instance_variable_set "]}," Tree Operation children":{"type":"method","name":"children","children":[],"call":[]}," Tree Operation to_sass":{"type":"method","name":"to_sass","children":[],"call":["Sass Script Lexer OPERATORS_REVERSE  [] "," operand_to_sass "]}," Tree Operation inspect":{"type":"method","name":"inspect","children":[],"call":["@operand2 inspect ","@operand1 inspect ","@operator inspect "]}," Tree Operation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree Node opts":{"type":"method","name":"opts","children":[],"call":["value options= "," options "]}," Tree Node _perform":{"type":"method","name":"_perform","children":[],"call":["Sass Util  abstract "]}," Tree Node dasherize":{"type":"method","name":"dasherize","children":[],"call":["s gsub ","opts [] ","s tr "]}," Tree Node deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["Sass Util  abstract "]}," Tree Node to_sass":{"type":"method","name":"to_sass","children":[],"call":["Sass Util  abstract "]}," Tree Node children":{"type":"method","name":"children","children":[],"call":["Sass Util  abstract "]}," Tree Node perform":{"type":"method","name":"perform","children":[],"call":[" raise ","e modify_backtrace "," line "," _perform "]}," Tree Node options=":{"type":"method","name":"options=","children":[],"call":["c options= ","v options= ","c values each ","c values ","c is_a? "," children each "," children "]}," Tree MapLiteral _perform":{"type":"method","name":"_perform","children":[],"call":["map options= "," options ","Sass Script Value Map  new ","Sass Util  to_hash ","keys << "," raise ","Sass SyntaxError  new "," to_sass ","k inspect ","keys include? ","v perform ","k perform "," pairs map "," pairs ","Set  new ","Hash  [] ","Sass Script Value Map  new  options= ","Set  new  << ","Set  new  include? "," pairs Sass Script Value Map  new  "]}," Tree MapLiteral deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","v deep_copy ","k deep_copy "," pairs map "," pairs "," dup "," dup  instance_variable_set "]}," Tree MapLiteral to_sass":{"type":"method","name":"to_sass","children":[],"call":["( + + ","( + ","(send\n  (send nil :pairs) :map) join ","to_sass [] "," pairs map "," pairs ","value to_sass ","value separator == ","value separator ","value is_a? "," lambda "," pairs empty? "]}," Tree MapLiteral children":{"type":"method","name":"children","children":[],"call":["@pairs flatten "]}," Tree MapLiteral initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree Literal _perform":{"type":"method","name":"_perform","children":[],"call":[" value "," value source_range= "," source_range "," value filename= "," filename "," value line= "," line "]}," Tree Literal inspect":{"type":"method","name":"inspect","children":[],"call":[" value inspect "," value "]}," Tree Literal options=":{"type":"method","name":"options=","children":[],"call":[" value options= "," value "]}," Tree Literal deep_copy":{"type":"method","name":"deep_copy","children":[],"call":[" dup "]}," Tree Literal to_sass":{"type":"method","name":"to_sass","children":[],"call":[" value to_sass "," value "]}," Tree Literal children":{"type":"method","name":"children","children":[],"call":[]}," Tree Literal initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree ListLiteral sep_str":{"type":"method","name":"sep_str","children":[],"call":["opts [] == ","opts [] "," separator == "," separator "]}," Tree ListLiteral _perform":{"type":"method","name":"_perform","children":[],"call":["list options= "," options ","list source_range= "," source_range ","Sass Script Value List  new "," separator ","e perform "," elements map "," elements ","list filename= "," filename ","list line= "," line "," bracketed ","Sass Script Value List  new  options= ","Sass Script Value List  new  source_range= ","Sass Script Value List  new  filename= ","Sass Script Value List  new  line= "]}," Tree ListLiteral inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :elements) :map) join "," separator == "," separator ","e inspect "," elements map "," elements ","(if\n  (send nil :bracketed)\n  (str \"[\")\n  (str \"(\")) + + "," bracketed ","(if\n  (send nil :bracketed)\n  (str \"[\")\n  (str \"(\")) + "]}," Tree ListLiteral deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","e deep_copy "," elements map "," elements "," dup "," dup  instance_variable_set "]}," Tree ListLiteral to_sass":{"type":"method","name":"to_sass","children":[],"call":["members join "," sep_str ","members first ","members length == ","members length "," separator == "," separator ","v to_sass ","v operator == ","v operator ","v is_a? ","Sass Script Parser  precedence_of <= ","Sass Script Parser  precedence_of ","v separator "," elements map "," elements "," elements empty? ","(send\n  (send nil :elements) :map) join ","(send\n  (block\n    (send\n      (send nil :elements) :reject)\n    (args\n      (arg :e))\n    (send\n      (lvar :e) :is_a?\n      (const\n        (const\n          (const\n            (const nil :Sass) :Script) :Value) :Null))) :map) join ","(send\n  (send nil :elements) :reject) map ","e is_a? "," elements reject "," element_needs_parens? "," bracketed ","Sass Script Parser  Sass Script Parser  precedence_of _of <= ","Sass Script Parser  Sass Script Parser  precedence_of _of "]}," Tree ListLiteral children":{"type":"method","name":"children","children":[],"call":[" elements "]}," Tree ListLiteral initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree Interpolation _perform":{"type":"method","name":"_perform","children":[],"call":[" opts ","Sass Script Value String  new ","res << ","@after perform to_s ","@after perform ","val to_s ","val value ","val is_a? ","@mid perform ","@before perform to_s ","@before perform ","Sass Util  sass_warn ","alternative to_sass ","val inspect "," filename "," source_range start_pos offset "," source_range start_pos "," source_range "," line ","Operation  new ","val name ","str source_range= "," to_quoted_equivalent to_sass "," to_quoted_equivalent "," deprecation == "," deprecation ","result to_s ","result inspect ","result name ","result is_a? ","@value perform ","@mid perform  to_s ","@mid perform  @mid perform ue ","@mid perform  is_a? ","Operation  new  to_sass ","@mid perform  inspect ","@mid perform  name ","Sass Script Value String  new  source_range= "," to_quoted_equi@mid perform ent to_sass "," to_quoted_equi@mid perform ent ","@value perform  to_s ","@value perform  inspect ","@value perform  name ","@value perform  is_a? ","@@mid perform ue perform "]}," Tree Interpolation deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","@after deep_copy ","@mid deep_copy ","@before deep_copy "," dup ","@value deep_copy "," dup  instance_variable_set "]}," Tree Interpolation children":{"type":"method","name":"children","children":[],"call":["(ivar :@before) compact "]}," Tree Interpolation to_sass":{"type":"method","name":"to_sass","children":[],"call":["res << ","@after to_sass ","@mid to_sass ","@before to_sass "," to_quoted_equivalent to_sass "," to_quoted_equivalent "," deprecation == "," deprecation ","@value to_sass "]}," Tree Interpolation inspect":{"type":"method","name":"inspect","children":[],"call":["@after inspect ","@mid inspect ","@before inspect ","@value inspect "]}," Tree Interpolation initialize":{"type":"method","name":"initialize","children":[],"call":["opts [] "]}," Tree Funcall reformat_argument_error":{"type":"method","name":"reformat_argument_error","children":[],"call":[" raise ","Sass SyntaxError  new "," name ","e backtrace [] !~ "," ruby_name ","e backtrace [] ","e backtrace ","e message =~ ","e message ","Sass Util  jruby1_6? ! ","Sass Util  jruby1_6? ","(and\n  (send\n    (send\n      (lvar :trace) :[]\n      (int 0)) :=~\n    (regexp\n      (str \":in `send'$\")\n      (regopt)))\n  (send\n    (send\n      (lvar :trace) :[]\n      (int 1)) :=~\n    (regexp\n      (str \":in `_perform'$\")\n      (regopt)))) ! ","trace [] =~ ","trace [] ","trace shift !~ ","trace shift ","e backtrace dup ","Sass Util  jruby? ","error_name != ","Sass Util  rbx? ","md [] ","e backtrace [] =~ ","(str \"^wrong number of arguments \\\\(given (\\\\d+), expected (\\\\d+)\\\\)\") match ","e backe backtrace dup  [] !~ ","e backe backtrace dup  [] ","e backe backtrace dup  ","e e message  =~ ","e e message  ","(and\n  (send\n    (send\n      (lvar :e backtrace dup ) :[]\n      (int 0)) :=~\n    (regexp\n      (str \":in `send'$\")\n      (regopt)))\n  (send\n    (send\n      (lvar :e backtrace dup ) :[]\n      (int 1)) :=~\n    (regexp\n      (str \":in `_perform'$\")\n      (regopt)))) ! ","e backtrace dup  [] =~ ","e backtrace dup  [] ","e backtrace dup  shift !~ ","e backtrace dup  shift ","e backe backtrace dup  dup ","(str \"^wrong number of arguments \\(given (\\d+), expected (\\d+)\\)\") match  [] ","e backe backtrace dup  [] =~ "]}," Tree Funcall perform_sass_fn":{"type":"method","name":"perform_sass_fn","children":[],"call":[" raise ","Sass SyntaxError  new ","Sass Tree Visitors Perform  visit ","function tree each ","function tree "," catch ","env caller= ","Sass Environment  new ","Sass Tree Visitors Perform  perform_arguments "]}," Tree Funcall construct_ruby_args":{"type":"method","name":"construct_ruby_args","children":[],"call":[" raise ","Sass SyntaxError  new ","signature args include? ","signature args ","keywords keys sort first ","keywords keys sort ","keywords keys ","args << ","keywords to_hash ","signature var_kwargs ","keywords size > ","keywords size ","args + ","keywords delete ","Sass Util  sass_warn ","(str \"DEPRECATION WARNING: The `$\") + ","keywords denormalize ","keywords has_key? ","argnames zip map ","argnames zip ","signature deprecated [] ","args size ","signature deprecated ","signature args [] ","keywords empty? ","args [] inspect ","args [] ","signature args size ","args size > ","signature var_args ! ","signature var_args ","Sass Script Functions  signature ","name to_sym ","splat keywords_accessed= ","splat keywords ","splat keywords_accessed ","splat to_a ","signature args [] map ","v perform ","Sass Util  map_hash ","splat is_a? ","@keywords empty? ","@keywords size ","splat keywords size ","(or\n  (send\n    (send\n      (lvar :signature) :args) :[]\n    (irange\n      (send\n        (lvar :args) :size)\n      (int -1)))\n  (array)) map ","splat keywords empty? ! ","splat keywords empty? ","signature args +  include? ","Sass Script Functions  signature  args include? ","signature args +  ","Sass Script Functions  signature  args ","splat keywords  keys sort first ","splat keywords  keys sort ","splat keywords  keys ","args +  << ","splat keywords  to_hash ","signature var_kwargs +  ","Sass Script Functions  signature  var_kwargs ","splat keywords  size > ","splat keywords  size ","args +  + ","splat keywords  delete ","splat keywords  denormalize ","splat keywords  has_key? ","keywords keys sort first s zip map ","keywords keys sort first s zip ","Sass Script Functions  signature  deprecated [] ","args +  size ","Sass Script Functions  signature  deprecated ","signature args +  [] ","Sass Script Functions  signature  args [] ","splat keywords  empty? ","args +  [] inspect ","args +  [] ","signature args +  size ","Sass Script Functions  signature  args size ","args +  size > ","signature var_args +  ! ","Sass Script Functions  signature  var_args ! ","signature var_args +  ","Sass Script Functions  signature  var_args ","Sass Script Functions  Sass Script Functions  signature  ","splat splat keywords _accessed= ","splat splat keywords  ","splat splat keywords _accessed ","signature args +  [] map ","Sass Script Functions  signature  args [] map ","@splat keywords  empty? ","@splat keywords  size ","splat splat keywords  size ","(or\n  (send\n    (send\n      (lvar :signature) :args + ) :[]\n    (irange\n      (send\n        (lvar :args + ) :size)\n      (int -1)))\n  (array)) map ","(or\n  (send\n    (send\n      (lvar :Sass Script Functions  signature ) :args) :[]\n    (irange\n      (send\n        (lvar :args) :size)\n      (int -1)))\n  (array)) map ","splat splat keywords  empty? ! ","splat splat keywords  empty? "]}," Tree Funcall without_original":{"type":"method","name":"without_original","children":[],"call":["value original= ","value dup ","value is_a? ","value dup  original= ","value dup  dup ","value dup  is_a? "]}," Tree Funcall signature":{"type":"method","name":"signature","children":[],"call":["Sass Script Functions  signature ","@keywords size ","@args size "," name to_sym "," name "]}," Tree Funcall perform_arg":{"type":"method","name":"perform_arg","children":[],"call":["argument perform "," signature delayed_args include? "," signature delayed_args "," signature "]}," Tree Funcall ruby_name":{"type":"method","name":"ruby_name","children":[],"call":["@name tr "]}," Tree Funcall to_value":{"type":"method","name":"to_value","children":[],"call":["Sass Script Value String  new ","args join "," name "]}," Tree Funcall to_literal":{"type":"method","name":"to_literal","children":[],"call":[" to_value "]}," Tree Funcall _perform":{"type":"method","name":"_perform","children":[],"call":[" reformat_argument_error "," opts "," to_literal "," without_original ","Sass Script Functions EvaluationContext  new send "," ruby_name ","Sass Script Functions EvaluationContext  new ","local_environment caller= ","Sass ReadOnlyEnvironment  new ","environment options ","Sass Environment  new ","environment global_env ","Sass Script Functions  callable? "," construct_ruby_args "," perform_sass_fn ","environment function ","Sass Tree Visitors Perform  perform_splat "," perform_arg ","k tr ","Sass Util  map_hash "," signature args [] "," signature args "," signature ","Sass Util  enum_with_index map ","Sass Util  enum_with_index "," raise ","Sass SyntaxError  new "," name ","e backtrace [] !~ ","e backtrace [] ","e backtrace ","e message =~ ","e message ","Sass Util  jruby1_6? ! ","Sass Util  jruby1_6? ","(and\n  (send\n    (send\n      (lvar :trace) :[]\n      (int 0)) :=~\n    (regexp\n      (str \":in `send'$\")\n      (regopt)))\n  (send\n    (send\n      (lvar :trace) :[]\n      (int 1)) :=~\n    (regexp\n      (str \":in `_perform'$\")\n      (regopt)))) ! ","trace [] =~ ","trace [] ","trace shift !~ ","trace shift ","e backtrace dup ","Sass Util  jruby? ","error_name != ","Sass Util  rbx? ","@name tr ","v perform ","@splat perform ","a perform ","@args map "," css_variable_warning warn! "," css_variable_warning ","local_environment stack with_function "," line "," filename ","local_environment stack ","fn origin == ","fn origin ","fn ! ","environment stack with_function ","environment stack ","@args each_with_index map ","@args each_with_index "," @name tr  ","Sass Environment  new  caller= "," construct_ruby_ construct_ruby_args  "," perform_sass_environment function  ","Sass Tree Visitors Perform  perform_Sass Tree Visitors Perform  perform_splat  ","Sass Tree Visitors Perform  perform_@splat perform  "," signature  construct_ruby_args  [] "," signature  construct_ruby_args  ","e backe backtrace dup  [] !~ ","e backe backtrace dup  [] ","e backe backtrace dup  ","e e message  =~ ","e e message  ","(and\n  (send\n    (send\n      (lvar :e backtrace dup ) :[]\n      (int 0)) :=~\n    (regexp\n      (str \":in `send'$\")\n      (regopt)))\n  (send\n    (send\n      (lvar :e backtrace dup ) :[]\n      (int 1)) :=~\n    (regexp\n      (str \":in `_perform'$\")\n      (regopt)))) ! ","e backtrace dup  [] =~ ","e backtrace dup  [] ","e backtrace dup  shift !~ ","e backtrace dup  shift ","e backe backtrace dup  dup ","@Sass Tree Visitors Perform  perform_splat  perform ","@@splat perform  perform ","@ construct_ruby_args  map ","Sass Environment  new  stack with_function ","Sass Environment  new  stack ","environment function  origin == ","environment function  origin ","environment function  ! ","@ construct_ruby_args  each_with_index map ","@ construct_ruby_args  each_with_index "]}," Tree Funcall deep_copy":{"type":"method","name":"deep_copy","children":[],"call":["node instance_variable_set ","copied_keywords []= ","v deep_copy ","@keywords as_stored each ","@keywords as_stored ","Sass Util NormalizedMap  new ","a deep_copy "," args map "," args "," dup ","Hash  [] "," keywords map "," keywords "," dup  instance_variable_set ","Sass Util NormalizedMap  new  []= "]}," Tree Funcall children":{"type":"method","name":"children","children":[],"call":["res << ","@args + ","@keywords values ","@args +  << "]}," Tree Funcall to_sass":{"type":"method","name":"to_sass","children":[],"call":[" dasherize "," name ","(lvar :args) flatten compact join ","(lvar :args) flatten compact ","(lvar :args) flatten ","arg_to_sass [] "," kwarg_splat "," splat ","Sass Util  hash_to_a map ","Sass Util  hash_to_a ","@keywords as_stored ","@args map ","arg separator == ","arg separator ","arg is_a? ","arg to_sass "," lambda ","keywords empty? ","args empty? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join ","@args map join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join ","@keywords as_stored to_a map ","@keywords as_stored to_a ","(lvar :@args map ) flatten compact join ","(lvar :@args map join ) flatten compact join ","(lvar :@args map ) flatten compact ","(lvar :@args map join ) flatten compact ","(lvar :@args map ) flatten ","(lvar :@args map join ) flatten ","arg_to_arg to_sass  [] ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  as_stored ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join  as_stored ","@@args map  map ","@@args map join  map ","arg to_arg to_sass  ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  empty? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join  empty? ","@args map  empty? ","@args map join  empty? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join )) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join )) :map) join ","@@args map  map join ","@@args map join  map join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join ) :as_stored)) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join ) :as_stored)) :map) join ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  as_stored to_a map ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join  as_stored to_a map ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  as_stored to_a ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join  as_stored to_a "]}," Tree Funcall inspect":{"type":"method","name":"inspect","children":[],"call":["keywords empty? ","args empty? "," name "," kwarg_splat inspect "," kwarg_splat "," splat inspect "," splat ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join ","v inspect ","Sass Util  hash_to_a map ","Sass Util  hash_to_a ","@keywords as_stored ","(send\n  (ivar :@args) :map) join ","a inspect ","@args map ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join ","(send\n  (send\n    (send\n      (ivar :@keywords) :as_stored) :to_a) :map) join ","@keywords as_stored to_a map ","@keywords as_stored to_a ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join  empty? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  empty? ","(send\n  (send\n    (send\n      (ivar :@keywords) :as_stored) :to_a) :map) join  empty? ","(send\n  (ivar :@args) :map) join  empty? ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join ) :as_stored)) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join ) :as_stored)) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@(send\n  (send\n    (send\n      (ivar :@keywords) :as_stored) :to_a) :map) join ) :as_stored)) :map) join ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join  as_stored ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  as_stored ","@(send\n  (send\n    (send\n      (ivar :@keywords) :as_stored) :to_a) :map) join  as_stored ","(send\n  (ivar :@(send\n  (ivar :@args) :map) join ) :map) join ","@(send\n  (ivar :@args) :map) join  map ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join )) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join )) :map) join ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@(send\n  (send\n    (send\n      (ivar :@keywords) :as_stored) :to_a) :map) join )) :map) join ","(send\n  (send\n    (send\n      (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join ) :as_stored) :to_a) :map) join ","(send\n  (send\n    (send\n      (ivar :@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join ) :as_stored) :to_a) :map) join ","(send\n  (send\n    (send\n      (ivar :@(send\n  (send\n    (send\n      (ivar :@keywords) :as_stored) :to_a) :map) join ) :as_stored) :to_a) :map) join ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join  as_stored to_a map ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  as_stored to_a map ","@(send\n  (send\n    (send\n      (ivar :@keywords) :as_stored) :to_a) :map) join  as_stored to_a map ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (send\n      (ivar :@keywords) :as_stored)) :map) join  as_stored to_a ","@(send\n  (send\n    (const\n      (const nil :Sass) :Util) :hash_to_a\n    (ivar :@keywords)) :map) join  as_stored to_a ","@(send\n  (send\n    (send\n      (ivar :@keywords) :as_stored) :to_a) :map) join  as_stored to_a "]}," Tree Funcall initialize":{"type":"method","name":"initialize","children":[],"call":["name_or_callable name ","name_or_callable is_a? "]}," Sass Script Parser literal_node":{"type":"method","name":"literal_node","children":[],"call":[" node ","Sass Script Tree Literal  new "]}," Sass Script Parser try_toks":{"type":"method","name":"try_toks","children":[],"call":["@lexer next ","names include? ","peeked type ","@lexer peek "," peek_toks ","@lexer peek  type "]}," Sass Script Parser assert_toks":{"type":"method","name":"assert_toks","children":[],"call":["@lexer expected! ","(send\n  (lvar :names) :map) join ","Lexer TOKEN_NAMES  [] ","names map "," try_toks ","@lexer expec try_toks ed! ","  try_toks ry_ try_toks oks "]}," Sass Script Parser selector":{"type":"method","name":"selector","children":[],"call":[" node ","tok source_range start_pos ","tok source_range ","tok value "," literal "," try_tok ","@css_variable_warning warn! "," try_tok  source_range start_pos "," try_tok  source_range "," try_tok  value "," try_ try_tok  "]}," Sass Script Parser list":{"type":"method","name":"list","children":[],"call":["list elements << ","list elements "," interpolation "," try_ops_after_interp "," try_op_before_interp ","list elements first ","list elements length == ","list elements length "," try_tok "," node ","Sass Script Tree ListLiteral  new ","@lexer peek type == ","@lexer peek type ","@lexer peek ","list elements size == ","list elements size "," assert_expr ","list source_range end_pos= ","list elements last source_range end_pos ","list elements last source_range ","list elements last ","list source_range "," space ","list  interpolation l interpolation m interpolation nts << ","list  space l space m space nts << "," node  elements << ","list  interpolation l interpolation m interpolation nts ","list  space l space m space nts "," node  elements "," int interpolation rpolation "," int space rpolation ","  try_op_before_interp olation "," try_ops_aft interpolation r_int interpolation rp "," try_ops_aft space r_int space rp "," try_ops_after_ try_op_before_interp  "," try_op_b interpolation for interpolation _int interpolation rp "," try_op_b space for space _int space rp "," try_op_before_ try_op_before_interp  ","list  interpolation l interpolation m interpolation nts first ","list  space l space m space nts first "," node  elements first ","list  interpolation l interpolation m interpolation nts l interpolation ngth == ","list  space l space m space nts l space ngth == "," node  elements length == ","list  interpolation l interpolation m interpolation nts l interpolation ngth ","list  space l space m space nts l space ngth "," node  elements length "," try_ try_tok  "," nod interpolation  "," nod space  ","Sass Script Tr interpolation  interpolation  ListLit interpolation ral  n interpolation w ","Sass Script Tr space  space  ListLit space ral  n space w ","@l interpolation x interpolation r p interpolation  interpolation k typ interpolation  == ","@l space x space r p space  space k typ space  == ","@l interpolation x interpolation r p interpolation  interpolation k typ interpolation  ","@l space x space r p space  space k typ space  ","@l interpolation x interpolation r p interpolation  interpolation k ","@l space x space r p space  space k ","list  interpolation l interpolation m interpolation nts siz interpolation  == ","list  space l space m space nts siz space  == "," node  elements size == ","list  interpolation l interpolation m interpolation nts siz interpolation  ","list  space l space m space nts siz space  "," node  elements size "," ass interpolation rt_ interpolation xpr "," ass space rt_ space xpr ","list sourc interpolation _rang interpolation   interpolation nd_pos= ","list sourc space _rang space   space nd_pos= "," node  source_range end_pos= ","list  interpolation l interpolation m interpolation nts last sourc interpolation _rang interpolation   interpolation nd_pos ","list  space l space m space nts last sourc space _rang space   space nd_pos "," node  elements last source_range end_pos ","list  interpolation l interpolation m interpolation nts last sourc interpolation _rang interpolation  ","list  space l space m space nts last sourc space _rang space  "," node  elements last source_range ","list  interpolation l interpolation m interpolation nts last ","list  space l space m space nts last "," node  elements last ","list sourc interpolation _rang interpolation  ","list sourc space _rang space  "," node  source_range "," spac interpolation  "," spac space  "]}," Sass Script Parser map_pair":{"type":"method","name":"map_pair","children":[],"call":[" assert_expr "," assert_tok "," interpolation "," space "]}," Sass Script Parser map":{"type":"method","name":"map","children":[],"call":["map pairs << ","map pairs "," map_pair "," try_tok "," node ","Sass Script Tree MapLiteral  new "," list ","@lexer peek type == ","@lexer peek type ","@lexer peek "," interpolation "," source_position "," assert_expr ","@css_variable_warning warn! ","map source_range end_pos= ","map pairs last last source_range end_pos ","map pairs last last source_range ","map pairs last last ","map pairs last ","map source_range "," space ","map  map_pair s << "," node  pairs << ","map  map_pair s "," node  pairs "," map_ map_pair  ","  node _pair "," try_ try_tok  "," nod interpolation  "," nod space  ","Sass Script Tr interpolation  interpolation  MapLit interpolation ral  n interpolation w ","Sass Script Tr space  space  MapLit space ral  n space w ","@l interpolation x interpolation r p interpolation  interpolation k typ interpolation  == ","@l space x space r p space  space k typ space  == ","@l interpolation x interpolation r p interpolation  interpolation k typ interpolation  ","@l space x space r p space  space k typ space  ","@l interpolation x interpolation r p interpolation  interpolation k ","@l space x space r p space  space k "," int interpolation rpolation "," int space rpolation "," sourc interpolation _position "," sourc space _position "," ass interpolation rt_ interpolation xpr "," ass space rt_ space xpr ","@css_variabl interpolation _warning warn! ","@css_variabl space _warning warn! "," node  source_range end_pos= ","map sourc interpolation _rang interpolation   interpolation nd_pos= ","map sourc space _rang space   space nd_pos= ","map  map_pair s last last source_range end_pos "," node  pairs last last source_range end_pos ","map pairs last last sourc interpolation _rang interpolation   interpolation nd_pos ","map pairs last last sourc space _rang space   space nd_pos ","map  map_pair s last last source_range "," node  pairs last last source_range ","map pairs last last sourc interpolation _rang interpolation  ","map pairs last last sourc space _rang space  ","map  map_pair s last last "," node  pairs last last ","map  map_pair s last "," node  pairs last "," node  source_range ","map sourc interpolation _rang interpolation  ","map sourc space _rang space  "," spac interpolation  "," spac space  "]}," Sass Script Parser range":{"type":"method","name":"range","children":[],"call":["Sass Source Range  new ","@options [] "]}," Sass Script Parser source_position":{"type":"method","name":"source_position","children":[],"call":["Sass Source Position  new "," offset "," line "]}," Sass Script Parser offset":{"type":"method","name":"offset","children":[],"call":["@lexer offset "]}," Sass Script Lexer source_position":{"type":"method","name":"source_position","children":[],"call":["Sass Source Position  new "]}," Sass Script Lexer range":{"type":"method","name":"range","children":[],"call":["Sass Source Range  new ","@options [] "]}," Sass Script Lexer offset":{"type":"method","name":"offset","children":[],"call":["@tok source_range start_pos offset ","@tok source_range start_pos ","@tok source_range "]}," Sass Script Lexer line":{"type":"method","name":"line","children":[],"call":["@tok source_range start_pos line ","@tok source_range start_pos ","@tok source_range "]}," Script Functions to_h":{"type":"method","name":"to_h","children":[],"call":["obj to_h ","Sass Util  sass_warn ","(str \"DEPRECATION WARNING: Passing lists of pairs to \") + "," environment stack to_s gsub "," environment stack to_s "," environment stack "," environment ","Sass Util  caller_info last gsub ","Sass Util  caller_info last ","Sass Util  caller_info ","obj needs_map_warning? ","obj is_a? "]}," Script Functions random":{"type":"method","name":"random","children":[],"call":[" number ","generator rand ","1 + ","limit value "," raise ","ArgumentError  new ","limit value < "," assert_integer ","Sass Script Functions  random_number_generator ","limit to_i ","limit to_i < ","Sass Script Functions  random_number_generator  rand ","Sass Script Functions  random_number_Sass Script Functions  random_number_generator  "]}," Script Functions inspect":{"type":"method","name":"inspect","children":[],"call":[" unquoted_string ","value to_sass ","value check_deprecated_interp ","value is_a? "]}," Script Functions mixin_exists":{"type":"method","name":"mixin_exists","children":[],"call":[" bool "," environment mixin ","name value "," environment "," assert_type ","Sass Script Value Bool  new "]}," Script Functions function_exists":{"type":"method","name":"function_exists","children":[],"call":[" bool "," environment function ","name value "," environment ","Sass Script Functions  callable? ","name value tr "," assert_type ","Sass Script Value Bool  new "," environment caller function "," environment caller "]}," Script Functions global_variable_exists":{"type":"method","name":"global_variable_exists","children":[],"call":[" bool "," environment global_env var ","name value "," environment global_env "," environment "," assert_type ","Sass Script Value Bool  new "]}," Script Functions variable_exists":{"type":"method","name":"variable_exists","children":[],"call":[" bool "," environment caller var ","name value "," environment caller "," environment "," assert_type ","Sass Script Value Bool  new "]}," Script Functions call":{"type":"method","name":"call","children":[],"call":[" perform ","funcall options= "," options ","Sass Script Tree Funcall  new ","Sass Script Tree Literal  new ","Sass Util  map_vals ","args map ","name value ","args pop ","args last is_a? ","args last "," assert_type ","funcall perform "," environment ","funcall filename= "," environment stack frames last filename "," environment stack frames last "," environment stack frames "," environment stack ","funcall line= "," environment stack frames last line ","Sass Util  sass_warn ","name to_sass "," get_function "," bool "," function_exists to_bool "," function_exists ","name is_a? ","Sass Script Tree Funcall  new  options= "," get_function  value ","Sass Script Tree Funcall  new  perform ","Sass Script Tree Funcall  new  filename= ","funcall file get_function = "," environment stack frames last file get_function  ","Sass Script Tree Funcall  new  line= "," get_function  to_sass "," get_function  is_a? "]}," Script Functions unique_id":{"type":"method","name":"unique_id","children":[],"call":[" identifier ","u + ","value to_s rjust ","value to_s ","generator rand + ","generator rand ","Thread  current [] ","Thread  current ","36 ** ","Sass Script Functions  random_number_generator ","Sass Script String  new "," rand "," rand + ","max - ","Sass Script Functions  random_number_generator  rand + ","Sass Script Functions  random_number_generator  rand ","Sass Script Functions  random_number_Sass Script Functions  random_number_generator  "]}," Script Functions keywords":{"type":"method","name":"keywords","children":[],"call":[" map ","Sass Script String  new ","Sass Util  map_keys ","args keywords as_stored ","args keywords "," assert_type ","Sass Script Value Map  new ","Sass Script Value String  new "]}," Script Functions map_has_key":{"type":"method","name":"map_has_key","children":[],"call":[" bool "," to_h has_key? "," to_h "," assert_type ","Sass Script Value Bool  new ","map to_h has_key? ","map to_h "]}," Script Functions map_values":{"type":"method","name":"map_values","children":[],"call":[" list "," to_h values "," to_h "," assert_type ","Sass Script Value List  new ","map to_h values ","map to_h "]}," Script Functions map_keys":{"type":"method","name":"map_keys","children":[],"call":[" list "," to_h keys "," to_h "," assert_type ","Sass Script Value List  new ","map to_h keys ","map to_h "]}," Script Functions map_remove":{"type":"method","name":"map_remove","children":[],"call":[" map ","hash delete "," to_h dup "," to_h "," assert_type ","keys include? ","hash delete_if ","map to_h dup ","map to_h "," to_h dup  delete ","map to_h dup  delete "," to_h dup  delete_if ","map to_h dup  delete_if "]}," Script Functions map_merge":{"type":"method","name":"map_merge","children":[],"call":[" map "," to_h merge "," to_h "," assert_type ","Sass Script Value Map  new ","map1 to_h merge ","map2 to_h ","map1 to_h "]}," Script Functions map_get":{"type":"method","name":"map_get","children":[],"call":[" null "," to_h [] "," to_h "," assert_type ","Sass Script Value Null  new ","map to_h [] ","map to_h "]}," Script Functions list_separator":{"type":"method","name":"list_separator","children":[],"call":[" identifier ","(or\n  (send\n    (lvar :list) :separator)\n  (sym :space)) to_s ","list separator ","String  new ","list separator to_s ","list class == ","list class ","list is_a? ","Sass Script Value String  new "]}," Script Functions set_nth":{"type":"method","name":"set_nth","children":[],"call":["Sass Script Value List  new ","list separator ","new_list []= ","list to_a dup ","list to_a ","n to_i ","n to_i - ","n to_i > ","Sass Script Value List  assert_valid_index "," assert_type "," list ","list with_contents ","list to_a dup  []= ","Sass Script Value List  assert_valid_n to_i  ","Sass Script Value List  assert_valid_n to_i -  "]}," Script Functions feature_exists":{"type":"method","name":"feature_exists","children":[],"call":[" bool ","Sass  has_feature? ","feature value "," assert_type ","Sass Script Value Bool  new "]}," Script Functions to_lower_case":{"type":"method","name":"to_lower_case","children":[],"call":["Sass Script Value String  new ","string type ","string value downcase ","string value "," assert_type ","Sass Script String  new ","Sass Util  downcase "]}," Script Functions to_upper_case":{"type":"method","name":"to_upper_case","children":[],"call":["Sass Script Value String  new ","string type ","string value upcase ","string value "," assert_type ","Sass Script String  new ","Sass Util  upcase "]}," Script Functions str_slice":{"type":"method","name":"str_slice","children":[],"call":["Sass Script Value String  new ","string type ","string value slice ","string value ","s < ","string value length + ","string value length ","e < ","end_at value ","end_at value - ","end_at value > ","start_at value ","start_at value - ","start_at value > "," assert_unit "," number ","end_at nil? "," assert_type ","Sass Script String  new ","Sass Script Number  new ","Sass Script Value Number  new ","end_at value == ","Sass Script Valustring value length +  String  nstring value length + w ","Sass Script Valuend_at value  String  nend_at value w ","Sass Script Valuend_at value -  String  nend_at value - w ","Sastring value length + string value length +  Script Value String  new ","Sastart_at value start_at value  Script Value String  new ","Sastart_at value - start_at value -  Script Value String  new ","string typstring value length +  ","string typend_at value  ","string typend_at value -  ","string value length + tring type ","start_at value tring type ","start_at value - tring type ","string valustring value length +  slicstring value length +  ","string valuend_at value  slicend_at value  ","string valuend_at value -  slicend_at value -  ","string value length + tring value string value length + lice ","start_at value tring value start_at value lice ","start_at value - tring value start_at value - lice ","string valustring value length +  ","string valuend_at value  ","string valuend_at value -  ","string value length + tring value ","start_at value tring value ","start_at value - tring value ","string value length +  < ","start_at value  < ","start_at value -  < ","string valustring value length +  lstring value length + ngth + ","string valuend_at value  lend_at value ngth + ","string valuend_at value -  lend_at value - ngth + ","string value length + tring value length + ","start_at value tring value length + ","start_at value - tring value length + ","string valustring value length +  lstring value length + ngth ","string valuend_at value  lend_at value ngth ","string valuend_at value -  lend_at value - ngth ","string value length + tring value length ","start_at value tring value length ","start_at value - tring value length ","end_at value  < ","end_at value -  < ","string value length + nd_at valustring value length +  ","end_at value nd_at valuend_at value  ","end_at value - nd_at valuend_at value -  "," number  value ","Sass Script Number  new  value ","Sass Script Value Number  new  value ","string value length + nd_at valustring value length +  - ","end_at value nd_at valuend_at value  - ","end_at value - nd_at valuend_at value -  - "," number  value - ","Sass Script Number  new  value - ","Sass Script Value Number  new  value - ","string value length + nd_at valustring value length +  > ","end_at value nd_at valuend_at value  > ","end_at value - nd_at valuend_at value -  > "," number  value > ","Sass Script Number  new  value > ","Sass Script Value Number  new  value > ","start_at valustring value length +  ","start_at valuend_at value  ","start_at valuend_at value -  ","string value length + tart_at value ","start_at value tart_at value ","start_at value - tart_at value ","start_at valustring value length +  - ","start_at valuend_at value  - ","start_at valuend_at value -  - ","string value length + tart_at value - ","start_at value tart_at value - ","start_at value - tart_at value - ","start_at valustring value length +  > ","start_at valuend_at value  > ","start_at valuend_at value -  > ","string value length + tart_at value > ","start_at value tart_at value > ","start_at value - tart_at value > "," assstring value length + rt_unit "," assend_at value rt_unit "," assend_at value - rt_unit "," astring value length + string value length + ert_unit "," astart_at value start_at value ert_unit "," astart_at value - start_at value - ert_unit "," numbstring value length + r "," numbend_at value r "," numbend_at value - r ","string value length + nd_at nil? ","end_at value nd_at nil? ","end_at value - nd_at nil? "," number  nil? ","Sass Script Number  new  nil? ","Sass Script Value Number  new  nil? "," assstring value length + rt_typstring value length +  "," assend_at value rt_typend_at value  "," assend_at value - rt_typend_at value -  "," astring value length + string value length + ert_type "," astart_at value start_at value ert_type "," astart_at value - start_at value - ert_type ","Sass Script String  nstring value length + w ","Sass Script String  nend_at value w ","Sass Script String  nend_at value - w ","Sastring value length + string value length +  Script String  new ","Sastart_at value start_at value  Script String  new ","Sastart_at value - start_at value -  Script String  new ","Sass Script Numbstring value length + r  nstring value length + w ","Sass Script Numbend_at value r  nend_at value w ","Sass Script Numbend_at value - r  nend_at value - w ","Sastring value length + string value length +  Script Number  new ","Sastart_at value start_at value  Script Number  new ","Sastart_at value - start_at value -  Script Number  new ","Sass Script Valustring value length +  Numbstring value length + r  nstring value length + w ","Sass Script Valuend_at value  Numbend_at value r  nend_at value w ","Sass Script Valuend_at value -  Numbend_at value - r  nend_at value - w ","Sastring value length + string value length +  Script Value Number  new ","Sastart_at value start_at value  Script Value Number  new ","Sastart_at value - start_at value -  Script Value Number  new ","string value length + nd_at valustring value length +  == ","end_at value nd_at valuend_at value  == ","end_at value - nd_at valuend_at value -  == "," number  value == ","Sass Script Number  new  value == ","Sass Script Value Number  new  value == "]}," Script Functions str_index":{"type":"method","name":"str_index","children":[],"call":[" null "," number ","index + ","string value index ","substring value ","string value "," assert_type ","Sass Script Number  new ","Sass Script Value Number  new ","string value index  + ","string value string value index  "]}," Script Functions str_insert":{"type":"method","name":"str_insert","children":[],"call":["Sass Script Value String  new ","original type ","original value dup insert ","insert value ","original value dup ","original value ","(send\n  (lvar :index) :value) max ","original value size -@ - ","original value size -@ ","original value size ","index value ","(send\n  (send\n    (lvar :index) :value) :-\n  (int 1)) min ","index value - ","index value > "," assert_unit "," assert_integer "," assert_type ","Sass Script String  new ","(send\n  (lvar :index) :to_i) max ","index to_i ","(send\n  (send\n    (lvar :index) :to_i) :-\n  (int 1)) min ","index to_i - ","index to_i > "]}," Script Functions str_length":{"type":"method","name":"str_length","children":[],"call":[" number ","string value size ","string value "," assert_type ","Sass Script Number  new ","Sass Script Value Number  new "]}," Script Functions EvaluationContext perform":{"type":"method","name":"perform","children":[],"call":["node perform ","node is_a? "]}," Script Functions EvaluationContext assert_integer":{"type":"method","name":"assert_integer","children":[],"call":[" raise ","ArgumentError  new ","number int? "," assert_type "]}," Script Functions EvaluationContext assert_unit":{"type":"method","name":"assert_unit","children":[],"call":[" raise ","ArgumentError  new ","number is_unit? "," assert_type "]}," Script Functions random_number_generator":{"type":"method","name":"random_number_generator","children":[],"call":[]}," Script Functions random_seed=":{"type":"method","name":"random_seed=","children":[],"call":[]}," Plugin Compiler child_of_directory?":{"type":"method","name":"child_of_directory?","children":[],"call":["parent == ","child start_with? ","parent + ","parent end_with? "]}," Plugin Compiler relative_to_pwd":{"type":"method","name":"relative_to_pwd","children":[],"call":["Sass Util  pathname relative_path_from to_s ","Sass Util  pathname relative_path_from ","Sass Util  pathname ","Dir  pwd ","Pathname  new relative_path_from to_s ","Pathname  new relative_path_from ","Pathname  new ","Sass Util  relative_path_from to_s ","Sass Util  relative_path_from "]}," Plugin Compiler normalized_load_paths":{"type":"method","name":"normalized_load_paths","children":[],"call":["Sass Engine  normalize_options [] ","Sass Engine  normalize_options "," load_paths "]}," Plugin Compiler watched_paths":{"type":"method","name":"watched_paths","children":[],"call":["(send\n  (send nil :normalized_load_paths) :map) compact flatten ","(send\n  (send nil :normalized_load_paths) :map) compact ","lp directories_to_watch "," normalized_load_paths map "," normalized_load_paths "]}," Plugin Compiler watched_file?":{"type":"method","name":"watched_file?","children":[],"call":["lp watched_file? "," normalized_load_paths find "," normalized_load_paths "," normalized_load_paths any? ","@watched_files include? "," sass_file_in_directory? ","@inferred_directories any? "]}," Plugin Compiler remove_redundant_directories":{"type":"method","name":"remove_redundant_directories","children":[],"call":["dedupped << "," child_of_directory? ","dedupped reject! ","dedupped any? ","directories each "]}," Plugin Compiler listen_to":{"type":"method","name":"listen_to","children":[],"call":["listener start! ","listener stop ","listener thread join ","listener thread ","listener start ","Sass Util  listen_geq_2? ","listener start join ","thread join ","(send\n  (lvar :listener) :map) each ","l start ","listener map "," sleep "]}," Plugin Compiler create_listener":{"type":"method","name":"create_listener","children":[],"call":["Listen Listener  new ","Listen  to ","Sass Util  listen_geq_2? "," require "," load_listen! ","Sass Util  load_listen! ","args map ","args pop ","args last is_a? ","args last ","SassListen  to "]}," Sass Importers Filesystem warn_about_public_url":{"type":"method","name":"warn_about_public_url","children":[],"call":["@warnings_issued << ","Sass Util  sass_warn ","@warnings_issued include? ","Set  new "]}," Sass Importers Filesystem public_url":{"type":"method","name":"public_url","children":[],"call":[" warn_about_public_url ","file_pathname relative_path_from to_s ","file_pathname relative_path_from ","Sass Util  pathname cleanpath ","Sass Util  pathname ","Sass Util  absolute_path ","sourcemap_directory nil? ","Pathname  new cleanpath ","Pathname  new ","Sass Util  cleanpath ","Sass Util  file_uri_from_path ","Sass Util  relative_path_from ","File  absolute_path ","Sass Util  pathname cleanpath  relative_path_from to_s ","Pathname  new cleanpath  relative_path_from to_s ","Sass Util  cleanpath  relative_path_from to_s ","Sass Util  pathname cleanpath  relative_path_from ","Pathname  new cleanpath  relative_path_from ","Sass Util  cleanpath  relative_path_from "]}," Sass Importers Filesystem watched_file?":{"type":"method","name":"watched_file?","children":[],"call":["filename start_with? "," root + "," root ","filename =~ ","@real_root + "]}," Sass Importers Filesystem directories_to_watch":{"type":"method","name":"directories_to_watch","children":[],"call":[" root "]}," Sass Importers DeprecatedPath deprecation_warning":{"type":"method","name":"deprecation_warning","children":[],"call":["@specified_root == "]}," Sass Importers DeprecatedPath to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Sass Importers DeprecatedPath directories_to_watch":{"type":"method","name":"directories_to_watch","children":[],"call":[]}," Sass Importers DeprecatedPath find":{"type":"method","name":"find","children":[],"call":["Sass Util  sass_warn "," deprecation_warning ","@warning_given ! "]}," Sass Importers DeprecatedPath initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Importers Base watched_file?":{"type":"method","name":"watched_file?","children":[],"call":[]}," Sass Importers Base directories_to_watch":{"type":"method","name":"directories_to_watch","children":[],"call":[]}," Sass Importers Base public_url":{"type":"method","name":"public_url","children":[],"call":["Sass Util  sass_warn "," class name "," class "]}," Sass Features add_feature":{"type":"method","name":"add_feature","children":[],"call":["KNOWN_FEATURES  << "," raise ","ArgumentError  new ","feature_name [] == ","feature_name [] "]}," Sass Features has_feature?":{"type":"method","name":"has_feature?","children":[],"call":["KNOWN_FEATURES  include? "]}," Sass Exec Sass default_sass_path":{"type":"method","name":"default_sass_path","children":[],"call":[" Sass Importers DeprecatedPath  new ","File  directory? ","ENV  [] split select ","ENV  [] split ","ENV  [] "]}," Sass ReadOnlyEnvironment content":{"type":"method","name":"content","children":[],"call":["ReadOnlyEnvironment  new ","env options ","env is_a? ","env is_a? ! ","ReadOnlyEnvironment  new  options ","ReadOnlyEnvironment  new  is_a? ","ReadOnlyEnvironment  new  is_a? ! "]}," Sass ReadOnlyEnvironment caller":{"type":"method","name":"caller","children":[],"call":["ReadOnlyEnvironment  new ","env options ","env is_a? "]}," Sass BaseEnvironment stack":{"type":"method","name":"stack","children":[],"call":[" global_env stack "," global_env "]}," Sass BaseEnvironment global_env":{"type":"method","name":"global_env","children":[],"call":["@parent global_env ","@parent nil? "," parent global_env "," parent "," parent nil? "," global? "]}," Sass BaseEnvironment selector":{"type":"method","name":"selector","children":[],"call":["@parent selector ","@caller selector ","@selector resolve_parent_refs "," caller selector "," caller "]}," Sass BaseEnvironment content":{"type":"method","name":"content","children":[],"call":["@parent content "]}," Sass BaseEnvironment caller":{"type":"method","name":"caller","children":[],"call":["@parent caller "]}," Sass BaseEnvironment initialize":{"type":"method","name":"initialize","children":[],"call":["Set  new ","Sass Stack  new ","@parent nil? ","parent options "]}," Sass BaseEnvironment inherited_hash_writer":{"type":"method","name":"inherited_hash_writer","children":[],"call":[" class_eval ","33 + ","29 + ","28 + "]}," Sass BaseEnvironment inherited_hash_reader":{"type":"method","name":"inherited_hash_reader","children":[],"call":[" class_eval ","15 + ","16 + "]}," Sass BaseEnvironment inherited_hash_accessor":{"type":"method","name":"inherited_hash_accessor","children":[],"call":[" inherited_hash_writer "," inherited_hash_reader "]}," Sass Engine full_line_range":{"type":"method","name":"full_line_range","children":[],"call":["Sass Source Range  new ","@options [] ","Sass Source Position  new "," to_parser_offset + ","line text length ","line text "," to_parser_offset ","line offset "]}," Sass Engine to_parser_offset":{"type":"method","name":"to_parser_offset","children":[],"call":["offset + "]}," Sass Engine parse_function_directive":{"type":"method","name":"parse_function_directive","children":[],"call":["Tree FunctionNode  new ","Script Parser  new parse_function_definition_arglist ","Script Parser  new "," to_parser_offset ","arg_string strip ","line offset + - ","arg_string size ","line offset + ","line text size ","line text ","line offset "," raise ","SyntaxError  new ","name nil? ","line text scan first ","line text scan "," to_parser_line offset + -  ","line line offset + -  + - ","line line offset + -  + ","line line offset + -  "]}," Sass Engine parse_include_directive":{"type":"method","name":"parse_include_directive","children":[],"call":[" parse_mixin_include "]}," Sass Engine parse_mixin_directive":{"type":"method","name":"parse_mixin_directive","children":[],"call":[" parse_mixin_definition "]}," Sass Engine parse_import_directive":{"type":"method","name":"parse_import_directive","children":[],"call":[" raise ","SyntaxError  new ","scanner scan ","values << ","scanner rest inspect ","scanner rest "," parse_import_arg ","offset + ","scanner pos "," loop ","Sass Util MultibyteStringScanner  new ","@line + ","line children empty? ","line children ","Sass Util MultibyteStringScanner  new  scan ","Sass Util MultibyteStringScanner  new  rest inspect ","Sass Util MultibyteStringScanner  new  rest ","Sass Util MultibyteStringScanner  new  pos "]}," Sass Engine parse_else_directive":{"type":"method","name":"parse_else_directive","children":[],"call":["previous add_else "," append_children ","line children ","Tree IfNode  new "," parse_script ","line offset + ","line text index ","line text ","line offset "," raise ","SyntaxError  new ","value !~ ","previous is_a? ","parent children last ","parent children ","parent children last  add_else ","parent children last  is_a? "]}," Sass Engine parse_each_directive":{"type":"method","name":"parse_each_directive","children":[],"call":["Tree EachNode  new "," parse_script ","line offset + ","line text index ","line text ","line offset ","var [] "," raise ","SyntaxError  new ","var =~ ","var strip! ","vars split map ","vars split ","value !~ ","vars nil? ","value scan first ","value scan "]}," Sass Engine parse_for_directive":{"type":"method","name":"parse_for_directive","children":[],"call":["Tree ForNode  new ","to_name == "," parse_script ","line offset + ","line text index ","line text ","line offset ","var [] "," raise ","SyntaxError  new ","var =~ ","value !~ ","var nil? ","value scan first ","value scan ","var []  [] ","var []  =~ ","var []  nil? "]}," Sass Engine parse_at_root_directive":{"type":"method","name":"parse_at_root_directive","children":[],"call":["parent << ","at_root_node << "," append_children ","line children ","Tree RuleNode  new "," full_line_range "," parse_interp ","Tree AtRootNode  new ","parser parse_at_root_query ","line offset + - ","line offset + ","line text index to_i ","line text index ","line text ","line offset ","Sass SCSS Parser  new "," to_parser_offset ","@options [] ","value start_with? ","Sass Tree AtRootNode  new ","Sass Source Range  new ","Sass Source Position  new "," to_parser_offset + ","line text length ","Tree AtRootNode  new  << ","Sass Tree AtRootNode  new  << ","Sass SCSS Parser  new  parse_at_root_query ","line line offset + -  + - ","line line offset + -  + ","line line offset + -  "," to_parser_line offset + -  "," to_Sass SCSS Parser  new _offset "," to_parser_line offset + -  + "," to_Sass SCSS Parser  new _offset + "]}," Sass Engine parse_media_directive":{"type":"method","name":"parse_media_directive","children":[],"call":["node source_range= ","Sass Source Range  new ","@options [] ","Sass Source Position  new "," to_parser_offset + ","line text length ","line text "," to_parser_offset ","line offset ","Tree MediaNode  new ","parser parse_media_query_list to_a ","parser parse_media_query_list ","line offset + - ","line offset + ","line text index to_i ","line text index ","Sass SCSS Parser  new ","Tree MediaNode  new  source_range= "," to_parser_line offset + -  + "," to_Sass SCSS Parser  new _offset + "," to_parser_line offset + -  "," to_Sass SCSS Parser  new _offset ","line line offset + -  ","Sass SCSS Parser  new  parse_media_query_list to_a ","Sass SCSS Parser  new  parse_media_query_list ","line line offset + -  + - ","line line offset + -  + "]}," Sass Engine parse_charset_directive":{"type":"method","name":"parse_charset_directive","children":[],"call":["Tree CharsetNode  new "," raise ","SyntaxError  new ","@line + ","line children empty? ","line children ","value [] "]}," Sass Engine parse_return_directive":{"type":"method","name":"parse_return_directive","children":[],"call":["Tree ReturnNode  new "," parse_script ","line offset + ","line text index to_i ","line text index ","line text ","line offset "," raise ","SyntaxError  new ","@line + ","line children empty? ","line children ","line line offset +  + ","line line offset +  "]}," Sass Engine parse_warn_directive":{"type":"method","name":"parse_warn_directive","children":[],"call":["Tree WarnNode  new "," parse_script ","line offset + ","line text index to_i ","line text index ","line text ","line offset "," raise ","SyntaxError  new ","@line + ","line children empty? ","line children ","line line offset +  + ","line line offset +  "]}," Sass Engine parse_extend_directive":{"type":"method","name":"parse_extend_directive","children":[],"call":["Tree ExtendNode  new ","Sass Source Range  new ","@options [] ","Sass Source Position  new "," to_parser_offset + ","line text length ","line text "," to_parser_offset ","line offset "," parse_interp ","line offset + ","line text index to_i ","line text index ","value gsub! ! ! ","value gsub! ! ","value gsub! "," raise ","SyntaxError  new ","@line + ","line children empty? ","line children "," to_parser_line offset +  + "," to_parser_line offset +  ","line line offset +  ","line line offset +  + "]}," Sass Engine parse_debug_directive":{"type":"method","name":"parse_debug_directive","children":[],"call":["Tree DebugNode  new "," parse_script ","line offset + ","line text index to_i ","line text index ","line text ","line offset "," raise ","SyntaxError  new ","@line + ","line children empty? ","line children ","line line offset +  + ","line line offset +  "]}," Sass Engine parse_if_directive":{"type":"method","name":"parse_if_directive","children":[],"call":["Tree IfNode  new "," parse_script "," raise ","SyntaxError  new "]}," Sass Engine parse_while_directive":{"type":"method","name":"parse_while_directive","children":[],"call":["Tree WhileNode  new "," parse_script "," raise ","SyntaxError  new "]}," Sass Engine encode_and_set_charset":{"type":"method","name":"encode_and_set_charset","children":[],"call":["rendered gsub ","(str \"@charset \\\"\") encode "," source_encoding "," source_encoding name ","Regexp  new ","\\A@charset \"(.*?)\" encode ","rendered encode ","Sass Util  ruby1_8? "," ruby1_8? ","rendered encode  gsub ","rendered encode  encode "]}," Sass Engine _render_with_sourcemap":{"type":"method","name":"_render_with_sourcemap","children":[],"call":[" encode_and_set_charset ","rendered << ","Sass Util  escape_uri ","rendered [] != ","rendered [] ","@options [] == ","@options [] "," _to_tree render_with_sourcemap "," _to_tree "," raise ","Sass SyntaxError  new ","importer public_url nil? ","importer public_url ","Sass Util  silence_warnings ","importer nil? ","filename nil? ","File  dirname ","File  expand_path ","URI  encode ","(or\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :importer)) :public_url\n    (send\n      (ivar :@options) :[]\n      (sym :filename)))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :importer)) :is_a?\n    (const\n      (const\n        (const nil :Sass) :Importers) :Filesystem))) ! ","@options [] is_a? ","@options [] public_url ","@options [] nil? ","URI DEFAULT_PARSER  escape ","Sass Util  silence_sass_warnings "," encode_and_set_charset  << "," encode_and_set_charset  [] != "," encode_and_set_charset  [] ","@options []  public_url nil? ","@options []  public_url ","@options []  nil? ","(or\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :@options [] )) :public_url\n    (send\n      (ivar :@options) :[]\n      (sym :filename)))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :@options [] )) :is_a?\n    (const\n      (const\n        (const nil :Sass) :Importers) :Filesystem))) ! ","(or\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :importer)) :public_url\n    (send\n      (ivar :@options) :[]\n      (sym :@options [] )))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :importer)) :is_a?\n    (const\n      (const\n        (const nil :Sass) :Importers) :Filesystem))) ! "]}," Sass Engine render_with_sourcemap":{"type":"method","name":"render_with_sourcemap","children":[],"call":[" _render_with_sourcemap ","Sass Util  silence_sass_warnings ","@options [] "]}," Sass Script Parser token_start_position":{"type":"method","name":"token_start_position","children":[],"call":["Sass Source Position  new ","token offset ","token line "]}," Script Number is_unit?":{"type":"method","name":"is_unit?","children":[],"call":[" unitless? "," numerator_units first == "," numerator_units first "," numerator_units "," numerator_units size == "," numerator_units size "," denominator_units size == "," denominator_units size "," denominator_units "]}," Sass Environment global_env":{"type":"method","name":"global_env","children":[],"call":[" parent global_env "," parent "," parent nil? "]}," Script Color hsla":{"type":"method","name":"hsla","children":[],"call":["(send nil :hue) freeze "," lightness "," saturation "," hue "]}," Script Color rgba":{"type":"method","name":"rgba","children":[],"call":["(send nil :red) freeze "," alpha "," blue "," green "," red "]}," Value Null initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Value Base options=":{"type":"method","name":"options=","children":[],"call":[]}," Value ArgList children":{"type":"method","name":"children","children":[],"call":[" + ","@keywords values "]}," Sass Util NormalizedMap initialize_dup":{"type":"method","name":"initialize_dup","children":[],"call":[" __setobj__ ","other instance_variable_get dup ","other instance_variable_get "]}," Tree Selector _perform":{"type":"method","name":"_perform","children":[],"call":[" opts ","Sass Script Value List  new ","Sass Script Value String  new ","component to_s ","seq members map ","seq members ","selector members map ","selector members ","Sass Script Value Null  new ","environment selector ","selector to_sass_script ","environment selector  members map ","environment selector  members ","environment environment selector  ","environment selector  to_sass_script "]}," Tree Selector deep_copy":{"type":"method","name":"deep_copy","children":[],"call":[" dup "]}," Tree Selector to_sass":{"type":"method","name":"to_sass","children":[],"call":[]}," Tree Selector children":{"type":"method","name":"children","children":[],"call":[]}," Tree Selector initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Script Lexer selector":{"type":"method","name":"selector","children":[],"call":["script_selector source_range= "," range ","Script Tree Selector  new "," scan ","REGULAR_EXPRESSIONS  [] "," source_position ","Sass Util  sass_warn "," offset "," line ","@options [] ","@scanner peek == ","@scanner peek ","Script Tree Selector  new  source_range= "]}," Sass Environment selector":{"type":"method","name":"selector","children":[],"call":["@selector resolve_parent_refs ","@parent selector "," caller selector "," caller "]}," Sass BaseEnvironment no_selector!":{"type":"method","name":"no_selector!","children":[],"call":[]}," Sass BaseEnvironment selector=":{"type":"method","name":"selector=","children":[],"call":[]}," Sass Util cleanpath":{"type":"method","name":"cleanpath","children":[],"call":[" pathname ","path cleanpath to_s ","path cleanpath ","Pathname  new ","path is_a? "," Pathname  new name ","Pathname  new  cleanPathname  new  to_s ","Pathname  new  cleanPathname  new  ","Pathname  new  is_a? "]}," Plugin Compiler on_file_changed":{"type":"method","name":"on_file_changed","children":[],"call":[" update_stylesheets ","File  exists? ","individual_files select "," run_template_deleted "," relative_to_pwd "," try_delete_css "," css_filename ","f [] ","sass_dir size + ","sass_dir size "," child_of_directory? ","File  expand_path "," template_location_array each "," template_location_array "," watched_file? ","files [] ","File  expand_path == ","individual_files find ","removed uniq each ","removed uniq "," run_template_created ","added uniq each ","added uniq "," run_template_modified ","modified uniq each ","modified uniq ","File  exist? ","File  expand_path  size + ","File  expand_path  size "]}," Sass Util load_listen!":{"type":"method","name":"load_listen!","children":[],"call":["$LOAD_PATH unshift ","e message << << ","e message << ","e message "," raise ","File  exist? "," scope ","$LOAD_PATH include? "," require "," version_geq "," gem ","File  exists? "]}," Sass Util file_uri_from_path":{"type":"method","name":"file_uri_from_path","children":[],"call":["path tr ","file:// + ","path =~ ","file:/// + ","path start_with? "," windows? ","Sass Util  escape_uri ","path to_s ","path is_a? ","file: + ","URI DEFAULT_PARSER  escape ","Sass Util  escape_uri  tr ","path to_s  tr ","path tr  tr ","URI DEFAULT_PARSER  escape  tr ","Sass Util  escape_uri  =~ ","path to_s  =~ ","path tr  =~ ","URI DEFAULT_PARSER  escape  =~ ","Sass Util  escape_uri  start_with? ","path to_s  start_with? ","path tr  start_with? ","URI DEFAULT_PARSER  escape  start_with? ","Sass Util  escape_uri  to_s ","path to_s  to_s ","path tr  to_s ","URI DEFAULT_PARSER  escape  to_s ","Sass Util  escape_uri  is_a? ","path to_s  is_a? ","path tr  is_a? ","URI DEFAULT_PARSER  escape  is_a? "]}," Sass Util replace_subseq":{"type":"method","name":"replace_subseq","children":[],"call":["new push ","matched << ","i == ","subseq length - ","subseq length ","new << ","elem != ","subseq [] ","arr each "]}," SetOptions visit_comment":{"type":"method","name":"visit_comment","children":[],"call":["c options= ","c is_a? ","node value each ","node value "]}," CheckNesting transparent_parent?":{"type":"method","name":"transparent_parent?","children":[],"call":["grandparent is_a? ! ","grandparent is_a? ","parent bubbles? "," is_any_of? "]}," Plugin Compiler clean":{"type":"method","name":"clean","children":[],"call":["File  delete "," run_deleting_sourcemap ","File  exist? "," run_deleting_css "," file_list each "," file_list "]}," Plugin Compiler file_list":{"type":"method","name":"file_list","children":[],"call":["files << ","Sass Util  sourcemap_name "," engine_options [] "," engine_options "," css_filename ","file sub ","template_location to_s sub ","template_location to_s ","Sass Util  glob sort each ","Sass Util  glob sort ","Sass Util  glob ","File  join "," template_location_array each "," template_location_array ","tuple [] ","tuple size < ","tuple size ","individual_files map ","Sass Util  pathname relative_path_from to_s ","Sass Util  pathname relative_path_from ","Sass Util  pathname "," engine_options [] == ","tuple dup ","Sass Util  relative_path_from to_s ","Sass Util  relative_path_from ","Sass Util  Sass Util  sourcemap_name _name ","Sass Util  sourcemap_file sub  ","Sass Util  sourcemap_Sass Util  pathname relative_path_from to_s  ","Sass Util  sourcemap_Sass Util  relative_path_from to_s  ","  css_filename _filename "," css_filefile sub  "," css_fileSass Util  pathname relative_path_from to_s  "," css_fileSass Util  relative_path_from to_s  ","Sass Util  pathfile sub  relative_path_from to_s ","Sass Util  pathSass Util  pathname relative_path_from to_s  relative_path_from to_s ","Sass Util  pathSass Util  relative_path_from to_s  relative_path_from to_s ","Sass Util  pathfile sub  relative_path_from ","Sass Util  pathSass Util  pathname relative_path_from to_s  relative_path_from ","Sass Util  pathSass Util  relative_path_from to_s  relative_path_from ","Sass Util  pathfile sub  ","Sass Util  pathSass Util  pathname relative_path_from to_s  ","Sass Util  pathSass Util  relative_path_from to_s  "]}," Sass Script Lexer special_fun_body":{"type":"method","name":"special_fun_body","children":[],"call":[" expected! "," scan ","Sass Script Value String  new ","@interpolation_stack << ","@scanner pos ","str slice! "," raise ","@scanner [] == ","@scanner [] ","parens == ","scanned [] == ","scanned [] ","str << ","Token  new ","@scanner pos - "," range ","Sass Source Position  new ","@offset - "," scan  [] == "," scan  [] "]}," ToCss visit_keyframerule":{"type":"method","name":"visit_keyframerule","children":[],"call":[" visit_directive "]}," SetOptions visit_error":{"type":"method","name":"visit_error","children":[],"call":["node expr options= ","node expr "]}," Perform visit_error":{"type":"method","name":"visit_error","children":[],"call":[" raise ","Sass SyntaxError  new ","res to_sass ","res value ","res is_a? ","node expr perform ","node expr ","res to_sass  to_sass ","res value  to_sass ","node expr perform  to_sass ","res to_sass  value ","res value  value ","node expr perform  value ","res to_sass  is_a? ","res value  is_a? ","node expr perform  is_a? "]}," DeepCopy visit_error":{"type":"method","name":"visit_error","children":[],"call":["node expr= ","node expr deep_copy ","node expr "]}," Cssize visit_keyframerule":{"type":"method","name":"visit_keyframerule","children":[],"call":[" debubble ","node children ","node has_children "]}," Convert visit_error":{"type":"method","name":"visit_error","children":[],"call":[" semi ","node expr to_sass ","node expr "," tab_str "]}," Tree KeyframeRuleNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree ErrorNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree DirectiveNode normalized_name":{"type":"method","name":"normalized_name","children":[],"call":[" name gsub downcase "," name gsub "," name "]}," Sass Selector Attribute to_s":{"type":"method","name":"to_s","children":[],"call":["res << ","res << << "]}," Sass Selector Element to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Sass Selector Universal to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Sass Selector Placeholder to_s":{"type":"method","name":"to_s","children":[],"call":["% + "]}," Sass Selector Id to_s":{"type":"method","name":"to_s","children":[],"call":["# + "]}," Sass Selector Class to_s":{"type":"method","name":"to_s","children":[],"call":[". + "]}," Sass Selector Parent to_s":{"type":"method","name":"to_s","children":[],"call":["& + "]}," Sass Selector SimpleSequence to_s":{"type":"method","name":"to_s","children":[],"call":["res << "," subject? ","@members join ","(send\n  (ivar :@members) :map) join ","m to_s ","@members map ","res empty? ","@members join  << ","(send\n  (ivar :@members) :map) join  << ","@members join  empty? ","(send\n  (ivar :@members) :map) join  empty? "]}," Sass Selector SimpleSequence selector_pseudo_classes":{"type":"method","name":"selector_pseudo_classes","children":[],"call":["sel normalized_name ","(send\n  (send nil :members) :select) group_by ","sel selector ","sel type == ","sel type ","sel is_a? "," members select "," members "]}," Sass Selector Sequence subjectless":{"type":"method","name":"subjectless","children":[],"call":["Sequence  new ","pre_subject + ","subject members << ","Pseudo  new ","CommaSequence  new ","subject members ","has empty? ","subject subject= ","subject members= ","sseq_or_op members dup ","sseq_or_op members ","sseq_or_op dup ","pre_subject << ","sseq_or_op subject? ! ","sseq_or_op subject? ","sseq_or_op is_a? ","has << "," members each "," members ","pre_sseq_or_op dup  + ","sseq_or_op dup  members << ","sseq_or_op dup  members ","sseq_or_op dup  sseq_or_op dup = ","sseq_or_op dup  members= ","pre_sseq_or_op dup  << ","sseq_or_op sseq_or_op dup ? ! ","sseq_or_op sseq_or_op dup ? "]}," Sass Selector Sequence to_s":{"type":"method","name":"to_s","children":[],"call":["@members join gsub ","@members join ","(send\n  (ivar :@members) :map) join gsub ","(send\n  (ivar :@members) :map) join ","m to_s ","m is_a? ","@members map "]}," Sass Selector Sequence unify":{"type":"method","name":"unify","children":[],"call":["CommaSequence  new ","Sequence  new ","woven map "," weave ","other members [] + ","other members [] ","other members "," members [] "," members ","other_base unify ","other_base is_a? ","base is_a? ","other members last "," members last "," weave  map ","other members last  unify ","other_ members last  unify ","other members last  is_a? ","other_ members last  is_a? "," members last  is_a? "]}," Sass Selector Pseudo superselector?":{"type":"method","name":"superselector?","children":[],"call":[" throw "," name "," selector superselector? ","their_sel selector "," selector ","their_sel arg == "," arg ","their_sel arg ","their_sel name == ","their_sel name ","their_sel is_a? ","their_sseq members any? ","their_sseq members "," selector == ","their_current selector ","their_current name != ","their_current name ","(or\n  (send\n    (send\n      (lvar :their_sseq) :selector_pseudo_classes) :[]\n    (str \"current\"))\n  (array)) any? ","their_sseq selector_pseudo_classes [] ","their_sseq selector_pseudo_classes ","their_sel selector superselector? ","CommaSequence  new ","our_sel != ","our_sel class == ","their_sel class ","our_sel class ","our_sseq members any? ","our_sseq members ","our_sseq is_a? ","our_seq members last ","our_seq members "," selector members all? "," selector members ","(or\n  (send\n    (send\n      (lvar :their_sseq) :selector_pseudo_classes) :[]\n    (send nil :normalized_name))\n  (array)) any? "," normalized_name ","our_seq superselector? ","Sequence  new ","parents + "," selector members any? ","our_seq members last  members any? ","our_seq members last  members ","our_seq members last  is_a? "]}," Sass Selector Pseudo to_s":{"type":"method","name":"to_s","children":[],"call":["res << ","@selector to_s ","@arg strip ","(if\n  (send\n    (send nil :syntactic_type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) + "," syntactic_type == "," syntactic_type ","m invisible? ","@selector members all? ","@selector members "," name == "," name ","Sass Util  strip_except_escapes ","(if\n  (send\n    (send nil :syntactic_type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) +  << "]}," Sass Selector Pseudo normalized_name":{"type":"method","name":"normalized_name","children":[],"call":[" name gsub "," name "]}," Sass Selector Pseudo with_selector":{"type":"method","name":"with_selector","children":[],"call":["Pseudo  new ","CommaSequence  new ","(send\n  (send\n    (lvar :new_selector) :members) :map) flatten ","sel selector members ","sel selector ","sel arg == "," arg ","sel arg ","sel name == "," name ","sel name ","sel normalized_name == ","sel normalized_name "," normalized_name ","sel is_a? ","sseq members first ","sseq members ","sseq members length == ","sseq members length ","sseq is_a? ","seq members first ","seq members ","seq members length == ","seq members length ","new_selector members map ","new_selector members "," syntactic_type ","result selector members map ","result selector members ","result selector "," selector members length > "," selector members length "," selector members "," selector "," normalized_name == ","(send\n  (send\n    (lvar :new_sseq members first ector) :members) :map) flatten ","sseq members first  sseq members first ector members ","sseq members first  sseq members first ector ","sseq members first  arg == ","sseq members first  arg ","sseq members first  name == ","sseq members first  name ","sseq members first  normalized_name == ","sseq members first  normalized_name ","sseq members first  is_a? ","seq members first  members first ","seq members first  members ","seq members first  members length == ","seq members first  members length ","seq members first  is_a? ","new_sseq members first ector members map ","new_sseq members first ector members ","result sseq members first ector members map ","Pseudo  new  selector members map ","result sseq members first ector members ","Pseudo  new  selector members ","result sseq members first ector ","Pseudo  new  selector "," sseq members first ector members length > "," sseq members first ector members length "," sseq members first ector members "," sseq members first ector "]}," Sass Selector CommaSequence to_s":{"type":"method","name":"to_s","children":[],"call":["@members join gsub ","@members join ","(send\n  (ivar :@members) :map) join gsub ","(send\n  (ivar :@members) :map) join ","opts [] == ","opts [] ","m to_s ","@members map ","(send\n  (ivar :@members) :map) compact join gsub ","(send\n  (ivar :@members) :map) compact join ","(send\n  (ivar :@members) :map) compact ","m invisible? "]}," Sass Selector CommaSequence to_sass_script":{"type":"method","name":"to_sass_script","children":[],"call":["Sass Script Value List  new ","(send\n  (send\n    (lvar :seq) :members) :map) compact ","Sass Script Value String  new ","component to_s ","component == ","seq members map ","seq members "," members map "," members "]}," Sass Selector CommaSequence unify":{"type":"method","name":"unify","children":[],"call":["CommaSequence  new ","(send\n  (lvar :results) :map) flatten ","cseq members ","results map ","results empty? ","(send\n  (send nil :members) :map) flatten compact ","(send\n  (send nil :members) :map) flatten ","seq1 unify ","other members map ","other members "," members map "," members ","(send\n  (lvar :(send\n  (send nil :members) :map) flatten compact ) :map) flatten ","(send\n  (send nil :members) :map) flatten compact  map ","(send\n  (send nil :members) :map) flatten compact  empty? "]}," Sass Selector CommaSequence populate_extends":{"type":"method","name":"populate_extends","children":[],"call":["extends []= ","Sass Tree Visitors Cssize Extend  new "," raise ","Sass SyntaxError  new ","member members last is_a? ","member members last ","member members "," members each "," members ","sseq members ","ss is_a? ","sseq members any? ","sseq is_a? ! ","sseq is_a? ","seq members first ","seq members ","seq members size > ","seq members size ","extendee members each ","extendee members ","@@compound_extend_deprecation warn ","sseq line ","sseq filename ","sel length > ","sel length ","allow_compound_target ! ","sseq members join ","seq members first  members ","seq members first  members any? ","seq members first  is_a? ! ","seq members first  is_a? ","seq members first  line ","seq members first  filename ","sseq members  length > ","sseq members  length ","seq members first  members join "]}," Sass Selector CommaSequence superselector?":{"type":"method","name":"superselector?","children":[],"call":["seq2 superselector? "," members any? "," members ","cseq members all? ","cseq members "]}," Sass SCSS StaticParser keyframes_selector_component":{"type":"method","name":"keyframes_selector_component","children":[],"call":[" tok "," ident "]}," Sass SCSS StaticParser keyframes_selector":{"type":"method","name":"keyframes_selector","children":[],"call":[" ss "," expr! "," tok "," keyframes_selector_component "," str "]}," Sass SCSS StaticParser a_n_plus_b":{"type":"method","name":"a_n_plus_b","children":[],"call":[" tok! "," ss "," tok "]}," Sass SCSS StaticParser prefixed_selector_pseudo":{"type":"method","name":"prefixed_selector_pseudo","children":[],"call":[" expr! "," ss "," tok "," str "]}," Sass SCSS StaticParser pseudo_expr_token":{"type":"method","name":"pseudo_expr_token","children":[],"call":[" tok "]}," Sass SCSS StaticParser pseudo_expr":{"type":"method","name":"pseudo_expr","children":[],"call":["res << << "," ss "," str ","res << "," pseudo_expr_token ","r pseudo_expr_token s << << "," pseudo_expr_token  << << ","r pseudo_expr_token s << "," pseudo_expr_token  << "," ps pseudo_expr_token udo_ pseudo_expr_token xpr_tok pseudo_expr_token n "]}," Sass SCSS StaticParser pseudo_args":{"type":"method","name":"pseudo_args","children":[],"call":["arg concat "," expr! ","arg << << "," ss "," str ","arg << "," tok "," expr!  concat "," expr!  << << "," expr!  << "]}," Sass SCSS StaticParser pseudo":{"type":"method","name":"pseudo","children":[],"call":["Selector Pseudo  new ","s == "," tok! "," expr! "," prefixed_selector_pseudo ","PREFIXED_SELECTOR_PSEUDO_CLASSES  include? "," selector_comma_sequence ","SELECTOR_PSEUDO_CLASSES  include? "," deprefix "," ss "," tok "," expr! join ","SELECTOR_PSEUDO_ELEMENTS  include? "," ident! ","Selector P tok eudo  new "," tok  == "," prefixed_ selector_comma_sequence ector_pseudo "," prefixed_ tok elector_p tok eudo ","  selector_comma_sequence ector_comma_sequence ","  tok elector_comma_ tok equence ","  tok  tok  "]}," Sass SCSS StaticParser attrib_name!":{"type":"method","name":"attrib_name!","children":[],"call":[" tok! "," tok "," ident! "," ident "]}," Sass SCSS StaticParser attrib":{"type":"method","name":"attrib","children":[],"call":["Selector Attribute  new "," tok! "," tok "," ss "," attrib_name! "," ident "]}," Sass SCSS StaticParser qualified_name":{"type":"method","name":"qualified_name","children":[],"call":[" tok! "," tok "," tok? "," ident "," ident! "]}," Sass SCSS StaticParser element_name":{"type":"method","name":"element_name","children":[],"call":["Selector Element  new ","Selector Universal  new ","name == ","Sass Util  destructure "," qualified_name "]}," Sass SCSS StaticParser placeholder_selector":{"type":"method","name":"placeholder_selector","children":[],"call":["Selector Placeholder  new "," tok! "," tok "," ident! "]}," Sass SCSS StaticParser id_selector":{"type":"method","name":"id_selector","children":[],"call":["Selector Id  new "," tok! "," tok "," name! "]}," Sass SCSS StaticParser class_selector":{"type":"method","name":"class_selector","children":[],"call":["Selector Class  new "," tok! "," tok "," ident! "]}," Sass SCSS StaticParser parent_selector":{"type":"method","name":"parent_selector","children":[],"call":["Selector Parent  new "," tok "," name "]}," Sass SCSS StaticParser simple_selector_sequence":{"type":"method","name":"simple_selector_sequence","children":[],"call":["Selector SimpleSequence  new "," range "," tok "," raise ","e message << ","e message "," expected "," throw_error ","res [] is_a? ","res [] ","res length == ","res length ","@scanner pos= "," simple_selector_sequence "," str? ","@scanner pos ","res << ","Selector Universal  new "," pseudo "," attrib "," placeholder_selector "," class_selector "," id_selector "," parent_selector "," element_name "," source_position ","@scanner @scanner pos = ","@scanner @scanner pos  "," source_@scanner pos ition "]}," Sass SCSS StaticParser reference_combinator":{"type":"method","name":"reference_combinator","children":[],"call":["res << << "," tok! ","res << "," expr! "," tok ","Sass Util  sass_warn "]}," Sass SCSS StaticParser combinator":{"type":"method","name":"combinator","children":[],"call":[" reference_combinator "," tok "]}," Sass SCSS StaticParser selector":{"type":"method","name":"selector","children":[],"call":["Sass Util  sass_warn ","seq subjectless ","start_pos offset ","start_pos line ","sseq subject? ","sseq is_a? ","seq members any? ","seq members ","Selector Sequence  new ","res compact ","res << ","(send nil :str) include? "," ss "," str "," simple_selector_sequence "," combinator "," source_position ","Selector Sequence  new  subjectless "," source_position  offset "," source_position  line ","sSelector Sequence  new  subject? ","sSelector Sequence  new  is_a? ","Selector Sequence  new  members any? ","Selector Sequence  new  members "," simple_selector_Selector Sequence  new uence "]}," Sass SCSS StaticParser selector_string":{"type":"method","name":"selector_string","children":[],"call":["sel to_s "," selector "," selector  to_s ","  selector ector "]}," Sass SCSS StaticParser selector_comma_sequence":{"type":"method","name":"selector_comma_sequence","children":[],"call":["Selector CommaSequence  new ","selectors []= ","Selector Sequence  new ","(str \"\\n\") + ","selectors last members ","selectors last ","ws include? ","selectors << "," selector ","ws << "," ss "," str "," tok "," selector ectors []= "," selector ectors last members "," selector ectors last "," selector ectors << ","  selector ector "]}," Sass SCSS StaticParser initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass SCSS StaticParser parse_keyframes_selector":{"type":"method","name":"parse_keyframes_selector","children":[],"call":[" expected ","@scanner eos? "," expr! "," init_scanner! "]}," Sass SCSS Parser deprefix":{"type":"method","name":"deprefix","children":[],"call":["str gsub "]}," Sass SCSS Parser string":{"type":"method","name":"string","children":[],"call":["Sass Script Value String  value ","@scanner [] "," tok "]}," Sass SCSS Parser almost_any_value_token":{"type":"method","name":"almost_any_value_token","children":[],"call":[" interpolation "," interp_uri "," interp_string "," tok "]}," Sass SCSS Parser almost_any_value":{"type":"method","name":"almost_any_value","children":[],"call":[" merge ","sel << "," almost_any_value_token "," almost_any_value_ almost_any_value_token en "]}," Sass SCSS Parser try_declaration":{"type":"method","name":"try_declaration","children":[],"call":[" nested_properties! ","node value_source_range= "," range ","node name_source_range= "," node ","Sass Tree PropNode  new ","name flatten compact ","name flatten "," tok? "," ss "," source_position ","name + + ","name + "," rethrow "," almost_any_value "," tok! "," tok? ! "," value! "," catch_error ","post_colon_whitespace ! ","mid last empty? ! ","mid last empty? ","mid last ","mid << "," str "," tok ","name << "," Array "," interp_ident ","name first start_with? ","name first ","name first is_a? "," css_variable_declaration "," ne tok ted_propertie tok ! "," node  value_source_range= ","node  value! _source_range= ","node value_ tok ource_range= "," node  name_source_range= ","node  Array _source_range= ","node  interp_ident _source_range= ","node name_ tok ource_range= ","  node  ","Sa tok  tok  Tree PropNode  new "," Array  flatten compact "," interp_ident  flatten compact "," Array  flatten "," interp_ident  flatten ","  tok  tok  ","  tok ource_po tok ition "," Array  + + "," interp_ident  + + "," Array  + "," interp_ident  + "," almost_any_ value!  "," almo tok t_any_value ","  value! ! ","mid last empty? !  ! ","po tok t_colon_white tok pace ! ","mid la tok t empty? ! ","mid la tok t empty? ","mid la tok t ","  tok tr "," Array  << "," interp_ident  << "," interp_ interp_ident  "," Array  first start_with? "," interp_ident  first start_with? ","name fir tok t  tok tart_with? "," Array  first "," interp_ident  first ","name fir tok t "," Array  first is_a? "," interp_ident  first is_a? ","name fir tok t i tok _a? "," c tok  tok _variable_declaration "]}," Sass SCSS Parser error_directive":{"type":"method","name":"error_directive","children":[],"call":[" node ","Sass Tree ErrorNode  new "," sass_script "]}," Sass SCSS CssParser ruleset":{"type":"method","name":"ruleset","children":[],"call":[" block "," node ","Sass Tree RuleNode  new "," range "," selector_comma_sequence "," source_position ","  selector_comma_sequence _comma_sequence "]}," Value String inspect":{"type":"method","name":"inspect","children":[],"call":["String  quote "," value "]}," Value String quote":{"type":"method","name":"quote","children":[],"call":[]}," Value String value":{"type":"method","name":"value","children":[],"call":[]}," Value Helpers selector_to_str":{"type":"method","name":"selector_to_str","children":[],"call":["(send\n  (send\n    (lvar :value) :to_a) :map) join ","compound value ","compound is_a? ","value to_a map ","value to_a "," selector_to_str ","complex separator == ","complex separator ","complex is_a? ","complex value ","value separator == ","value separator ","value is_a? ","value value "," selector_to_ selector_to_str  "]}," Value Helpers normalize_selector":{"type":"method","name":"normalize_selector","children":[],"call":[" raise ","ArgumentError  new ","name to_s gsub ","name to_s ","(begin\n  (send\n    (lvar :value) :inspect)) + ","value inspect "," selector_to_str ","name to_s tr "," selector_to_ selector_to_str  "]}," Value Helpers parse_compound_selector":{"type":"method","name":"parse_compound_selector","children":[],"call":[" raise ","ArgumentError  new ","name to_s gsub ","name to_s ","value inspect ","sseq is_a? ","seq members length == ","seq members length ","seq members ","selector members length == ","selector members length ","selector members ","seq members first ","selector members first "," parse_selector "," assert_type ","name to_s tr ","seq members first  is_a? ","sselector members first  is_a? ","selector members first  members length == ","selector members first  members length ","selector members first  members "," parse_selector  members length == "," parse_selector  members length "," parse_selector  members ","selector members first  members first "," parse_selector  members first "," parse_ parse_selector  "]}," Value Helpers parse_complex_selector":{"type":"method","name":"parse_complex_selector","children":[],"call":[" raise ","ArgumentError  new ","name to_s gsub ","name to_s ","value inspect "," seq ","selector members length == ","selector members length ","selector members "," parse_selector ","name to_s tr "," parse_selector  members length == "," parse_selector  members length "," parse_selector  members "," parse_ parse_selector  "]}," Value Helpers parse_selector":{"type":"method","name":"parse_selector","children":[],"call":[" raise ","ArgumentError  new ","name to_s gsub ","name to_s ","value inspect ","Sass SCSS StaticParser  new parse_selector ","Sass SCSS StaticParser  new "," normalize_selector ","name to_s tr "]}," Value Color name":{"type":"method","name":"name","children":[],"call":["COLOR_NAMES_REVERSE  [] "," rgba "]}," Sass Script Lexer id":{"type":"method","name":"id","children":[],"call":["@scanner [] ","Script Value Color  from_hex ","@scanner [] length == ","@scanner [] length ","@scanner [] =~ "," scan ","REGULAR_EXPRESSIONS  [] ","Sass Util  sass_warn "," offset "," line ","@options [] ","Sass Util  normalize_ident_escapes "]}," Script Functions is_superselector":{"type":"method","name":"is_superselector","children":[],"call":[" bool ","sup superselector? "," parse_selector "," parse_selector   parse_selector erselector? "]}," Script Functions simple_selectors":{"type":"method","name":"simple_selectors","children":[],"call":[" list "," unquoted_string ","simple to_s ","selector members map ","selector members "," parse_compound_selector "," parse_compound_selector  members map "," parse_compound_selector  members "," parse_compound_ parse_compound_selector  "]}," Script Functions selector_unify":{"type":"method","name":"selector_unify","children":[],"call":["unified to_sass_script "," null ","selector1 unify "," parse_selector ","selector1 unify  to_sass_script "," parse_selector  unify "]}," Script Functions selector_replace":{"type":"method","name":"selector_replace","children":[],"call":[" raise ","ArgumentError  new ","e to_s ","selector do_extend to_sass_script ","selector do_extend ","replace ! ! ","replace ! ","replacement populate_extends ","Sass Util SubsetMap  new "," parse_selector "," parse_selector  do_extend to_sass_script "," parse_selector  do_extend ","replacement populate_Sass Util SubsetMap  new  "," parse_selector  populate_extends "," parse_ parse_selector  "]}," Script Functions selector_extend":{"type":"method","name":"selector_extend","children":[],"call":[" raise ","ArgumentError  new ","e to_s ","selector do_extend to_sass_script ","selector do_extend ","extender populate_extends ","Sass Util SubsetMap  new "," parse_selector "," parse_selector  do_extend to_sass_script "," parse_selector  do_extend ","extender populate_Sass Util SubsetMap  new  "," parse_selector  populate_extends "," parse_ parse_selector  "]}," Script Functions selector_append":{"type":"method","name":"selector_append","children":[],"call":["(send\n  (block\n    (send\n      (lvar :selectors) :map)\n    (args\n      (arg :sel))\n    (send nil :parse_selector\n      (lvar :sel)\n      (sym :selectors))) :inject) to_sass_script ","child resolve_parent_refs ","sseq members unshift ","Sass Selector Parent  new ","sseq members ","sseq members []= ","base name "," raise ","ArgumentError  new ","base namespace nil? ","base namespace ","sseq base ","sseq is_a? ","seq members first ","seq members ","child members each ","child members ","(send\n  (lvar :selectors) :map) inject "," parse_selector ","selectors map ","selectors empty? ","seq members first  members unshift ","seq members first  members ","seq members first  members []= ","sseq base  name ","sseq base  namespace nil? ","sseq base  namespace ","sseq sseq base  ","seq members first  base ","seq members first  is_a? "]}," Script Functions selector_nest":{"type":"method","name":"selector_nest","children":[],"call":["(send\n  (lvar :parsed) :inject) to_sass_script ","child resolve_parent_refs ","parsed inject "," parse_selector ","parse_parent_ref ! ! ","parse_parent_ref ! ","selectors [] map ","selectors [] ","selectors first "," raise ","ArgumentError  new ","selectors empty? "]}," Script Functions selector_parse":{"type":"method","name":"selector_parse","children":[],"call":[" parse_selector to_sass_script "," parse_selector "]}," Exec SassScss default_sass_path":{"type":"method","name":"default_sass_path","children":[],"call":["File  directory? ","ENV  [] split select ","ENV  [] split ","ENV  [] "]}," Exec SassScss probably_dest_dir?":{"type":"method","name":"probably_dest_dir?","children":[],"call":["Sass Util  glob empty? ","Sass Util  glob ","File  join "," colon_path? "]}," Exec SassScss split_colon_path":{"type":"method","name":"split_colon_path","children":[],"call":["one + + ","one + ","two split ","two =~ ","one =~ ","Sass Util  windows? ","path split ","one + +  + + ","one + +  + ","one + +  =~ "]}," Exec SassScss colon_path?":{"type":"method","name":"colon_path?","children":[],"call":[" split_colon_path [] nil? ! "," split_colon_path [] nil? "," split_colon_path [] "," split_colon_path "]}," Exec SassScss run":{"type":"method","name":"run","children":[],"call":["output close ","output is_a? "," raise ","e sass_backtrace_str ","@options [] "," write_output ","Sass SyntaxError  exception_to_css ","engine render ","mapping to_json + ","mapping to_json ","engine render_with_sourcemap ","relative_sourcemap_path to_s ","Sass Util  pathname relative_path_from ","Sass Util  pathname dirname ","Sass Util  pathname ","@options [] != ","input close ","input is_a? ","Sass Engine  new ","input read ","Sass Engine  for_file ","input path ","@options [] ! ","@options [] [] ","input path =~ ","Sass Util  relative_path_from ","(or-asgn\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :for_engine)) :[]\n    (sym :load_paths))\n  (array)) << "," Sass Importers DeprecatedPath  new ","input == ","@options []  close ","@options []  is_a? "," write_@options []  ","Sass Engine  new  render ","Sass Engine  for_file  render ","Sass Engine  new  render_with_sourcemap ","Sass Engine  for_file  render_with_sourcemap ","Sass Util  pathname relative_path_from  to_s ","Sass Util  relative_path_from  to_s ","@options []  read ","@options []  path ","@options []  path =~ ","(or-asgn\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :for_Sass Engine  new )) :[]\n    (sym :load_paths))\n  (array)) << ","(or-asgn\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :for_Sass Engine  for_file )) :[]\n    (sym :load_paths))\n  (array)) << ","@options []  == "]}," Exec SassScss watch_or_update":{"type":"method","name":"watch_or_update","children":[],"call":["Sass Plugin  watch ","STDOUT  flush "," puts ","Sass Plugin  on_template_deleted ","Sass Plugin  on_template_created ","Sass Plugin  on_template_modified "," exit ","Sass Plugin  update_stylesheets ","@options [] "," puts_action ","error message ","error sass_line ","error sass_filename "," raise ","@options [] ! ","error is_a? ","Sass Plugin  on_compilation_error ","Sass Plugin  on_deleting_sourcemap ","Sass Plugin  on_deleting_css ","Sass Plugin  on_creating_directory ","(lvar :css) each ","Sass Plugin  on_updated_stylesheet ","Sass Plugin  options []= ","Sass Plugin  options ","dirs map! ","Sass Util  sourcemap_name ","from gsub ","files map! ","File  directory? ","(send\n  (ivar :@args) :map) partition "," split_colon_path ","@args map ","@args [] ","@args [] =~ ","File  exist? ! ","File  exist? "," probably_dest_dir? "," colon_path? ! "," colon_path? ","@args empty? ","Sass Plugin  options merge! "," require "," + ","file start_with? ","@@working_directory + ","file =~ ","Sass Util  realpath to_s ","Sass Util  realpath ","Sass Plugin  compiler ","Sass Util  sass_warn ","(str \"DEPRECATION WARNING: Compiling directories without --update or --watch is\\n\") strip ","dirs empty? ! ","dirs empty? ","Sass Plugin  on_deleting_Sass Util  sourcemap_name  ","Sass Util  Sass Util  sourcemap_name _name ","Sass Util  realpath to_s  + "]}," Exec SassScss interactive":{"type":"method","name":"interactive","children":[],"call":["Sass Repl  new run ","Sass Repl  new "," require "]}," Exec SassScss load_compass":{"type":"method","name":"load_compass","children":[],"call":["Compass  configuration sass_load_paths ","Compass  configuration ","@options [] [] ","@options [] ","Dir  pwd ","Compass  configuration project_path ","Compass  add_project_configuration "," exit "," puts "," require "]}," Exec SassScss miscellaneous":{"type":"method","name":"miscellaneous","children":[],"call":["@options [] []= ","@options [] ","opts on ","@options []= ","Sass Script Value Number  precision= ","Sass Script Value Number  precision ","StringIO  new "," require ","opts separator "]}," Exec SassScss input_and_output":{"type":"method","name":"input_and_output","children":[],"call":["@options [] []= ","@options [] ","opts on ","@options []= ","Sass Util  windows? "," encoding_option ","(or\n  (lvar :type)\n  (sym :auto)) to_sym ","Sass Util  sass_warn ","(str \"DEPRECATION WARNING: Passing --sourcemap without a value is deprecated.\\n\") rstrip ","type nil? "," exit ","$stderr puts ","(str \"auto\") include? ! ","(str \"auto\") include? ","@default_syntax == ","opts separator ","(or-asgn\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :for_engine)) :[]\n    (sym :load_paths))\n  (array)) << "," Sass Importers DeprecatedPath  new ","@options [] [] "]}," Exec SassScss watching_and_updating":{"type":"method","name":"watching_and_updating","children":[],"call":["@options []= ","opts on ","Sass Util  windows? ","opts separator "]}," Exec SassScss common_options":{"type":"method","name":"common_options","children":[],"call":[" exit "," puts ","Sass  version [] ","Sass  version ","opts on ","@options [] []= ","name to_sym ","@options [] ","@options []= "," require ","(or-asgn\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :for_engine)) :[]\n    (sym :load_paths))\n  (array)) << ","@options [] [] ","opts separator ","@options [] [] << "]}," Exec SassScss process_result":{"type":"method","name":"process_result","children":[],"call":[" run ","@options [] []= ","@options [] ","@options [] is_a? ","@options []= ","Sass Util  sourcemap_name ","@options [] != "," watch_or_update "," interactive "," load_compass "," split_colon_path ","@args first ","@args size == ","@args size "," colon_path? ","@options [] ! "," require "," split_colon_path  first "," split_colon_path  size == "," split_colon_path  size "]}," Exec SassScss set_opts":{"type":"method","name":"set_opts","children":[],"call":[" miscellaneous "," input_and_output "," watching_and_updating "," common_options ","opts banner= "," default_syntax "]}," Exec SassScss initialize":{"type":"method","name":"initialize","children":[],"call":["@options []= "," default_sass_path "]}," Exec SassConvert process_file":{"type":"method","name":"process_file","children":[],"call":[" handle_load_error "," raise ","e message ","e sass_line ","e sass_filename ","@options [] "," write_output ","input path ","(send\n  (lvar :input) :is_a?\n  (const nil :File)) to_tree send ","(send\n  (lvar :input) :is_a?\n  (const nil :File)) to_tree ","Sass Engine  new ","input read ","Sass Engine  for_file ","input is_a? ","Sass CSS  new render ","Sass CSS  new "," require ","@options [] == ","Sass Util  silence_sass_warnings ","@options [] []= ","output path ","output is_a? ","(lvar :input_path) to_tree send ","(lvar :input_path) to_tree "," path_for "," read "," write_input path  ","input path  path ","input path  is_a? "]}," Exec SassConvert process_directory":{"type":"method","name":"process_directory","children":[],"call":[" process_file "," open_file "," puts_action ","File  exist? ","FileUtils  mkdir_p ","File  dirname ","File  directory? ","f gsub ","@options [] ","output_name []= ","@options [] size ","Sass Util  glob "," raise ","@options [] ! ","@options [] == ","File  directory? ! ","@options []= ","@args shift ","f gsub  []= ","@options []= _name []= "]}," Exec SassConvert miscellaneous":{"type":"method","name":"miscellaneous","children":[],"call":["@options []= ","opts on ","@options [] []= ","@options [] ","opts separator "]}," Exec SassConvert input_and_output":{"type":"method","name":"input_and_output","children":[],"call":["@options []= ","Sass Util  windows? ","opts on "," encoding_option ","opts separator "]}," Exec SassConvert style":{"type":"method","name":"style","children":[],"call":["@options [] []= ","@options [] ","opts on ","  * ","indent to_i ","indent == ","opts separator "]}," Exec SassConvert common_options":{"type":"method","name":"common_options","children":[],"call":[" exit "," puts ","Sass  version [] ","Sass  version ","opts on ","@options []= "," raise ","(sym :scss) include? ","@options [] ","name downcase to_sym ","name downcase ","(sym :css) include? ","@options [] == ","opts separator "]}," Exec SassConvert process_result":{"type":"method","name":"process_result","children":[],"call":[" process_file ","@options [] "," raise ","input path ","File  directory? "," process_directory "," require ","@options []  path "]}," Exec SassConvert set_opts":{"type":"method","name":"set_opts","children":[],"call":[" miscellaneous "," input_and_output "," style "," common_options ","opts banner= "]}," Exec SassConvert initialize":{"type":"method","name":"initialize","children":[],"call":["@options []= "," require "]}," Exec Base handle_load_error":{"type":"method","name":"handle_load_error","children":[],"call":[" exit ","$stderr puts "," raise ","dep empty? ","dep nil? ","@options [] ","err message [] ","err message ","err message []  empty? ","err message []  nil? "]}," Exec Base open_file":{"type":"method","name":"open_file","children":[],"call":["file close "," block_given? ","File  open ","flag == ","@options [] ","filename nil? ","File  open  close ","File  open name nil? "]}," Exec Base write_output":{"type":"method","name":"write_output","children":[],"call":["destination write ","file write "," open_file ","destination is_a? "]}," Exec Base color":{"type":"method","name":"color","children":[],"call":["COLORS  [] ","STDOUT  tty? ! ","STDOUT  tty? ","ENV  [] empty? ","ENV  [] ","ENV  [] nil? "," raise "]}," Exec Base puts":{"type":"method","name":"puts","children":[],"call":["Kernel  puts ","@options [] [] ","@options [] "]}," Exec Base puts_action":{"type":"method","name":"puts_action","children":[],"call":["STDOUT  flush "," printf "," color ","@options [] [] ","@options [] "]}," Exec Base process_result":{"type":"method","name":"process_result","children":[],"call":["@options []= ","@options [] ","args shift "," open_file ","@args dup ","@args dup  shift ","@@args dup  dup "]}," Exec Base encoding_option":{"type":"method","name":"encoding_option","children":[],"call":["Encoding  default_external= "," exit ","$stderr puts ","Sass Util  ruby1_8? ","opts on "]}," Exec Base set_opts":{"type":"method","name":"set_opts","children":[],"call":["Sass Util  abstract "," this "]}," Exec Base get_line":{"type":"method","name":"get_line","children":[],"call":["(or\n  (send\n    (send\n      (send\n        (send\n          (lvar :exception) :backtrace) :[]\n        (int 0)) :scan\n      (regexp\n        (str \":(\\\\d+)\")\n        (regopt))) :first)\n  (array\n    (str \"??\"))) first ","exception backtrace [] scan first ","exception backtrace [] scan ","exception backtrace [] ","exception backtrace ","(or\n  (send\n    (send\n      (send\n        (lvar :exception) :message) :scan\n      (regexp\n        (str \":(\\\\d+)\")\n        (regopt))) :first)\n  (array\n    (str \"??\"))) first ","exception message scan first ","exception message scan ","exception message ","exception is_a? "]}," Exec Base to_s":{"type":"method","name":"to_s","children":[],"call":["@opts to_s "]}," Exec Base parse":{"type":"method","name":"parse","children":[],"call":[" process_result ","@opts parse! ","OptionParser  new "," method ","OptionParser  new  parse! "]}," Exec Base parse!":{"type":"method","name":"parse!","children":[],"call":[" exit ","$stderr puts ","e message ","$stderr print ","e class ","e class == "," raise ","e is_a? ","@options [] "," parse ","e message to_s ","e sass_backtrace_str "," at_exit ","Sass Util  windows? "]}," Exec Base initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass BaseEnvironment global?":{"type":"method","name":"global?","children":[],"call":["@parent nil? "]}," Sass Engine parse_error_directive":{"type":"method","name":"parse_error_directive","children":[],"call":["Tree ErrorNode  new "," parse_script ","line offset + ","line text index to_i ","line text index ","line text ","line offset "," raise ","SyntaxError  new ","@line + ","line children empty? ","line children ","line line offset +  + ","line line offset +  "]}," Sass SemiGlobalEnvironment try_set_var":{"type":"method","name":"try_set_var","children":[],"call":["@parent try_set_var ","@vars []= ","@vars include? "]}," Sass Tree FunctionNode normalized_name":{"type":"method","name":"normalized_name","children":[],"call":[" name gsub "," name "]}," Sass Selector Sequence contains_parent_ref?":{"type":"method","name":"contains_parent_ref?","children":[],"call":["sel selector contains_parent_ref? ","sel selector ","sel is_a? ","sseq_or_op members any? ","sseq_or_op members ","sseq_or_op members first is_a? ","sseq_or_op members first ","sseq_or_op is_a? "," members any? "," members "]}," Sass Selector CommaSequence contains_parent_ref?":{"type":"method","name":"contains_parent_ref?","children":[],"call":["sel contains_parent_ref? ","@members any? "]}," Script Functions check_alpha_unit":{"type":"method","name":"check_alpha_unit","children":[],"call":["Sass Util  sass_warn ","alpha value ","alpha is_unit? ","alpha unitless? "]}," Exec SassConvert path_for":{"type":"method","name":"path_for","children":[],"call":["file is_a? ","file path "]}," Convert visit_keyframerule":{"type":"method","name":"visit_keyframerule","children":[],"call":["node resolved_value "," tab_str "]}," Sass Selector Sequence has_root?":{"type":"method","name":"has_root?","children":[],"call":["sel normalized_name == ","sel normalized_name ","sel is_a? ","sseq members any? ","sseq members ","sseq is_a? "]}," Sass SCSS CssParser keyframes_ruleset":{"type":"method","name":"keyframes_ruleset","children":[],"call":[" block "," node ","Sass Tree KeyframeRuleNode  new ","selector strip "," keyframes_selector "," source_position ","Sass Util  strip_except_escapes "," keyframes_selector  strip "," keyframes_ keyframes_selector  "]}," Sass SCSS CssParser block_contents":{"type":"method","name":"block_contents","children":[],"call":["node normalized_name == ","node normalized_name ","node is_a? "]}," Supports Operator parens":{"type":"method","name":"parens","children":[],"call":["condition op != "," op ","condition op ","condition is_a? "]}," Convert visit_rule_level":{"type":"method","name":"visit_rule_level","children":[],"call":["(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (send\n      (lvar :nodes) :+\n      (array\n        (nil)))\n    (int 2)) :map) join rstrip + ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (send\n      (lvar :nodes) :+\n      (array\n        (nil)))\n    (int 2)) :map) join rstrip ","(send\n  (send\n    (const\n      (const nil :Sass) :Util) :enum_cons\n    (send\n      (lvar :nodes) :+\n      (array\n        (nil)))\n    (int 2)) :map) join "," visit + ","nxt is_a? ","child is_a? ","child line + == ","nxt line ","child line + ","child line ","child line + + == ","child line + + ","child lines "," visit ","Sass Util  enum_cons map ","Sass Util  enum_cons ","nodes + ","(send\n  (send\n    (begin\n      (send\n        (lvar :nodes) :+\n        (array\n          (nil)))) :each_cons\n    (int 2)) :map) join rstrip + ","(send\n  (send\n    (begin\n      (send\n        (lvar :nodes) :+\n        (array\n          (nil)))) :each_cons\n    (int 2)) :map) join rstrip ","(send\n  (send\n    (begin\n      (send\n        (lvar :nodes) :+\n        (array\n          (nil)))) :each_cons\n    (int 2)) :map) join ","(send\n  (lvar :nodes) :+\n  (array\n    (nil))) each_cons map ","(send\n  (lvar :nodes) :+\n  (array\n    (nil))) each_cons "]}," Value Helpers calc?":{"type":"method","name":"calc?","children":[],"call":["literal value =~ ","literal value ","literal is_a? "]}," Value Color operation_name":{"type":"method","name":"operation_name","children":[],"call":[]}," Tree Node force_division!":{"type":"method","name":"force_division!","children":[],"call":["c force_division! "," children each "," children "]}," Tree Literal force_division!":{"type":"method","name":"force_division!","children":[],"call":[" value original= "," value "," value is_a? "]}," Tree ListLiteral is_literal_number?":{"type":"method","name":"is_literal_number?","children":[],"call":["value value original nil? ! ","value value original nil? ","value value original ","value value ","value value is_a? ","value is_a? "]}," Tree ListLiteral element_needs_parens?":{"type":"method","name":"element_needs_parens?","children":[],"call":["(and\n  (send nil :is_literal_number?\n    (send\n      (lvar :element) :operand1))\n  (send nil :is_literal_number?\n    (send\n      (lvar :element) :operand2))) ! "," is_literal_number? ","element operand2 ","element operand1 ","element operator == ","element operator ","element is_a? "," separator == "," separator ","Sass Script Parser  precedence_of <= ","Sass Script Parser  precedence_of ","element separator ","element bracketed ","element elements length < ","element elements length ","element elements "]}," Tree ListLiteral force_division!":{"type":"method","name":"force_division!","children":[],"call":[]}," ToCss ends_with?":{"type":"method","name":"ends_with?","children":[],"call":["@result end_with? "]}," Value Number basically_equal?":{"type":"method","name":"basically_equal?","children":[],"call":[" class basically_equal? "," class "]}," Value Number epsilon":{"type":"method","name":"epsilon","children":[],"call":[]}," Tree StringInterpolation quote_for":{"type":"method","name":"quote_for","children":[],"call":["after_quote == "," quote_for ","string_or_interp after ","before_quote == ","string_or_interp before ","string_or_interp value value include? ","string_or_interp value value ","string_or_interp value ","string_or_interp value value empty? ","string_or_interp is_a? "," quote_for  == "]}," Tree StringInterpolation _to_sass":{"type":"method","name":"_to_sass","children":[],"call":["result slice ","opts [] == ","opts [] ","string_or_interp to_sass ","string_or_interp to_sass  slice "]}," Tree StringInterpolation type":{"type":"method","name":"type","children":[],"call":["@before value type ","@before value "]}," Sass SCSS Parser supports_clause":{"type":"method","name":"supports_clause","children":[],"call":[" tok! "," ss "," supports_condition "," tok "," import_supports_condition ","  supports_condition _condition ","  import_supports_condition _condition "," import_ supports_condition _condition "," import_ import_supports_condition _condition "]}," Sass SCSS Parser parse_supports_clause":{"type":"method","name":"parse_supports_clause","children":[],"call":[" ss "," supports_clause "," init_scanner! "," supports_ supports_clause  "]}," Value String check_deprecated_interp":{"type":"method","name":"check_deprecated_interp","children":[],"call":["Sass Util  sass_warn ","location << "," source_range file "," source_range "," source_range start_pos line "," source_range start_pos ","$_sass_deprecated_interp_warnings << ","$_sass_deprecated_interp_warnings include? ","Set  new ","@@interpolation_deprecation warn "]}," Value String to_a":{"type":"method","name":"to_a","children":[],"call":[" check_deprecated_interp "]}," Value String separator":{"type":"method","name":"separator","children":[],"call":[" check_deprecated_interp "]}," Tree StringInterpolation quote":{"type":"method","name":"quote","children":[],"call":[" quote_for "]}," Tree Interpolation string_literal":{"type":"method","name":"string_literal","children":[],"call":["Literal  new ","Sass Script Value String  new "]}," Tree Interpolation concat":{"type":"method","name":"concat","children":[],"call":["StringInterpolation  new "," concat ","string_or_interp1 after ","string_or_interp1 mid ","string_or_interp1 before ","interp after ","interp mid "," string_literal ","string value value + ","interp before value value ","interp before value ","interp before ","string value value ","string value ","string_or_interp1 is_a? ","string_or_interp1 value value + ","string_or_interp2 value value ","string_or_interp2 value ","string_or_interp1 value value ","string_or_interp1 value ","string_or_interp2 is_a? ","string_or_interp1  string_literal  ","interp  string_literal  value value ","interp  string_literal  value ","interp  string_literal  "]}," Tree Interpolation to_string_interpolation":{"type":"method","name":"to_string_interpolation","children":[],"call":[" concat "," string_literal ","interp whitespace_before ","interp before "," to_string_interpolation ","interp mid ","interp whitespace_after ","interp after ","StringInterpolation  new ","node quote ","node is_a? ","node value to_s ","node value ","node_or_interp is_a? "]}," Tree Interpolation to_quoted_equivalent":{"type":"method","name":"to_quoted_equivalent","children":[],"call":["Funcall  new ","Sass Util NormalizedMap  new "," to_string_interpolation "]}," Sass Script Parser interpolation_deprecation":{"type":"method","name":"interpolation_deprecation","children":[],"call":["Sass Util  sass_warn ","interpolation to_quoted_equivalent to_sass ","interpolation to_quoted_equivalent ","location << ","interpolation filename ","interpolation line ","@options [] "]}," Sass Script Parser check_for_interpolation":{"type":"method","name":"check_for_interpolation","children":[],"call":[" interpolation_deprecation ","nodes concat ","node children ","node deprecation == ","node deprecation ","node is_a? ","nodes pop ","nodes empty? ","nodes pop s concat ","nodes pop  children ","nodes pop  deprecation == ","nodes pop  deprecation ","nodes pop  is_a? ","nodes pop s pop ","nodes pop s empty? "]}," Sass Script Parser is_unsafe_before?":{"type":"method","name":"is_unsafe_before?","children":[],"call":["expr is_a? ! ","expr is_a? ","char_before == ","expr value type == ","expr value type ","expr value ","expr value is_a? "," is_safe_value? "]}," Sass Script Lexer char":{"type":"method","name":"char","children":[],"call":["@scanner string [] ","@scanner string "]}," Sass Plugin Configuration convert_template_location":{"type":"method","name":"convert_template_location","children":[],"call":["template_location to_a ","File  join ","template_location is_a? "]}," ToCss trailing_semicolon?":{"type":"method","name":"trailing_semicolon?","children":[],"call":["@result end_with? ! ","@result end_with? "]}," Sass Util find_encoding_error":{"type":"method","name":"find_encoding_error","children":[],"call":["str encoding "," raise ","Sass SyntaxError  new ","i + "," undefined_conversion_error_char ","encoding name ","line encode ","str force_encoding split each_with_index ","str force_encoding split ","str force_encoding ","Regexp  quote ","\f encode force_encoding ","\f encode ","\n encode force_encoding ","\n encode ","\r encode force_encoding ","\r encode ","str str encoding  ","str encoding  name ","str force_str encoding  split each_with_index ","str force_str encoding  split ","str force_str encoding  ","\f encode force_str encoding  ","\n encode force_str encoding  ","\r encode force_str encoding  "]}," Sass Util ruby1_9_2?":{"type":"method","name":"ruby1_9_2?","children":[],"call":["RUBY_VERSION_COMPONENTS  == "]}," Sass Util retry_on_windows":{"type":"method","name":"retry_on_windows","children":[],"call":[" sleep "," windows? "]}," Sass Util relative_path_from":{"type":"method","name":"relative_path_from","children":[],"call":[" raise "," ArgumentError ","(str \"Incompatible path encodings: \") + ","from encoding ","from inspect ","path encoding ","path inspect ","from to_s ","path to_s ","e name == ","e name "," pathname relative_path_from "," pathname ","(str \"Incompatible path to_s  encodings: \") + ","from to_s  encoding ","from to_s  inspect ","path to_s  encoding ","path to_s  inspect ","from to_s  to_s ","path to_s  to_s "," pathname relative_path_from to_s  "," path to_s name relative_path to_s _from "," path to_s name "]}," Sass Util realpath":{"type":"method","name":"realpath","children":[],"call":["path realpath ","Pathname  new ","path is_a? ","Pathname  new  realPathname  new  ","Pathname  new  is_a? "]}," Sass Util min":{"type":"method","name":"min","children":[],"call":["val1 <= "]}," Sass Util max":{"type":"method","name":"max","children":[],"call":["val1 > "]}," Sass Util round":{"type":"method","name":"round","children":[],"call":["value floor ","value ceil ","value > ","value round ","(send\n  (lvar :value) :%\n  (int 1)) - <= ","-1 * ","Script Value Number  epsilon ","(send\n  (lvar :value) :%\n  (int 1)) - ","value % ","mod < ","mod_is_half ! ","(send\n  (lvar :mod) :-\n  (float 0.5)) abs < ","(send\n  (lvar :mod) :-\n  (float 0.5)) abs ","mod - ","value %  < ","(send\n  (lvar :mod) :-\n  (float 0.5)) abs <  ! ","value % _is_half ! ","(send\n  (lvar :value % ) :-\n  (float 0.5)) abs < ","(send\n  (lvar :value % ) :-\n  (float 0.5)) abs ","value %  - "]}," Sass Script Parser without_css_variable_warning":{"type":"method","name":"without_css_variable_warning","children":[],"call":[]}," Sass Script CssVariableWarning print_warning":{"type":"method","name":"print_warning","children":[],"call":["Sass Util  sass_warn ","(str \"DEPRECATION WARNING on line \") + + + + + ","@value to_sass ","(str \"DEPRECATION WARNING on line \") + + + + ","(str \"DEPRECATION WARNING on line \") + + + ","(str \"DEPRECATION WARNING on line \") + + ","(str \"DEPRECATION WARNING on line \") + ","@value line ","@value filename "]}," Sass Script CssVariableWarning warn!":{"type":"method","name":"warn!","children":[],"call":[" print_warning "]}," Sass Script CssVariableWarning value=":{"type":"method","name":"value=","children":[],"call":[" print_warning ","@value ! "]}," Sass Script CssVariableWarning initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Plugin Compiler sass_file_in_directory?":{"type":"method","name":"sass_file_in_directory?","children":[],"call":["filename start_with? ","directory + ","filename =~ "]}," Exec SassConvert read":{"type":"method","name":"read","children":[],"call":["f read "," open ","file read ","file respond_to? "]}," Sass SCSS Parser supports_declaration":{"type":"method","name":"supports_declaration","children":[],"call":["Sass Supports Declaration  new "," sass_script "," ss "," tok! "]}," Sass SCSS Parser import_supports_condition":{"type":"method","name":"import_supports_condition","children":[],"call":[" supports_declaration "," supports_condition "]}," Sass Script Parser is_safe_value?":{"type":"method","name":"is_safe_value?","children":[],"call":["expr value type == ","expr value type ","expr value ","expr value is_a? ","expr is_a? "," is_safe_value? ","expr elements last ","expr elements "]}," Sass logger":{"type":"method","name":"logger","children":[],"call":["Sass Logger Base  new ","Thread  current [] ","Thread  current "]}," Sass logger=":{"type":"method","name":"logger=","children":[],"call":["Thread  current []= ","Thread  current "]}," Delayed _log":{"type":"method","name":"_log","children":[],"call":["@messages << "]}," Delayed uninstall!":{"type":"method","name":"uninstall!","children":[],"call":["Sass  logger= ","@inner log_level= "," log_level "," throw ","Exception  new ","Sass  logger != ","Sass  logger "]}," Delayed flush":{"type":"method","name":"flush","children":[],"call":["@inner log ","@messages each "]}," Delayed initialize":{"type":"method","name":"initialize","children":[],"call":[" log_level= ","inner log_level "]}," Delayed install!":{"type":"method","name":"install!","children":[],"call":[]}," Sass Util ruby2_4?":{"type":"method","name":"ruby2_4?","children":[],"call":["RUBY_VERSION_COMPONENTS  [] > ","RUBY_VERSION_COMPONENTS  [] ","RUBY_VERSION_COMPONENTS  [] >= ","RUBY_VERSION_COMPONENTS  [] == "]}," Sass Util downcase":{"type":"method","name":"downcase","children":[],"call":["string downcase "," ruby2_4? "]}," Sass Util upcase":{"type":"method","name":"upcase","children":[],"call":["string upcase "," ruby2_4? "]}," Tree Operation warn_for_unitless_equals":{"type":"method","name":"warn_for_unitless_equals","children":[],"call":["@@unitless_equals_deprecation warn "," line "," filename ","@operator == ","value2 to_sass ","value1 to_sass ","result == ","value1 unitless? != ","value2 unitless? ","value1 unitless? ","value2 is_a? ","value1 is_a? "]}," Tree Operation warn_for_color_arithmetic":{"type":"method","name":"warn_for_color_arithmetic","children":[],"call":["@@color_arithmetic_deprecation warn "," line "," filename ","value2 is_a? ","value1 is_a? ","@operator == "]}," Sass Deprecation warn":{"type":"method","name":"warn","children":[],"call":["Sass Util  sass_warn ","location << ","@seen add? nil? ","@seen add? ","@@allow_double_warnings ! "]}," Sass Deprecation initialize":{"type":"method","name":"initialize","children":[],"call":["Set  new "]}," Sass Deprecation allow_double_warnings":{"type":"method","name":"allow_double_warnings","children":[],"call":[]}," ToCss format_custom_property_value":{"type":"method","name":"format_custom_property_value","children":[],"call":["lines first + + ","indented_lines join gsub ","   * ","indented_lines join ","lines first + ","lines first ","min_indentation [] ","node name_source_range start_pos offset - ","node name_source_range start_pos offset ","node name_source_range start_pos ","node name_source_range ","line length ","(send\n  (block\n    (send\n      (lvar :indented_lines) :map)\n    (args\n      (arg :line))\n    (send\n      (lvar :line) :[]\n      (regexp\n        (str \"^[ \\\\t]*\")\n        (regopt)))) :reject) min_by ","line empty? ","(send\n  (lvar :indented_lines) :map) reject ","line [] ","indented_lines map ","lines [] ","node resolved_value split ","node resolved_value ","node resolved_value gsub ","node resolved_value include? ! ","node resolved_value include? ","node style == ","node style ","value split ","value include? ! ","value include? ","node resolved_value sub ","node resolved_value split  first + + ","value split  first + + ","lines []  join gsub ","indented_node resolved_value split  join gsub ","indented_value split  join gsub ","lines []  join ","indented_node resolved_value split  join ","indented_value split  join ","node resolved_value split  first + ","value split  first + ","node resolved_value split  first ","value split  first ","(send\n  (block\n    (send\n      (lvar :lines [] ) :map)\n    (args\n      (arg :line))\n    (send\n      (lvar :line) :[]\n      (regexp\n        (str \"^[ \\\\t]*\")\n        (regopt)))) :reject) min_by ","(send\n  (block\n    (send\n      (lvar :indented_node resolved_value split ) :map)\n    (args\n      (arg :line))\n    (send\n      (lvar :line) :[]\n      (regexp\n        (str \"^[ \\\\t]*\")\n        (regopt)))) :reject) min_by ","(send\n  (block\n    (send\n      (lvar :indented_value split ) :map)\n    (args\n      (arg :line))\n    (send\n      (lvar :line) :[]\n      (regexp\n        (str \"^[ \\\\t]*\")\n        (regopt)))) :reject) min_by ","(send\n  (lvar :lines [] ) :map) reject ","(send\n  (lvar :indented_node resolved_value split ) :map) reject ","(send\n  (lvar :indented_value split ) :map) reject ","lines []  map ","indented_node resolved_value split  map ","indented_value split  map ","node resolved_value split  [] ","value split  [] ","node resolved_node resolved_value sub  split ","node resolved_node resolved_value sub  ","node resolved_node resolved_value sub  gsub ","node resolved_node resolved_value sub  include? ! ","node resolved_node resolved_value sub  include? ","node resolved_value sub  split ","node resolved_value sub  include? ! ","node resolved_value sub  include? ","node resolved_node resolved_value sub  sub "]}," Tree PropNode value_needs_parens?":{"type":"method","name":"value_needs_parens?","children":[],"call":["root operand2 value original nil? ","root operand2 value original ","root operand2 value ","root operand2 ","root operand2 value is_a? ","root operand2 is_a? ","root operand1 value original nil? ","root operand1 value original ","root operand1 value ","root operand1 ","root operand1 value is_a? ","root operand1 is_a? ","root operator == ","root operator ","root is_a? "," value first "," value "," custom_property? "," value first  operand2 value original nil? "," value first  operand2 value original "," value first  operand2 value "," value first  operand2 "," value first  operand2 value is_a? "," value first  operand2 is_a? "," value first  operand1 value original nil? "," value first  operand1 value original "," value first  operand1 value "," value first  operand1 "," value first  operand1 value is_a? "," value first  operand1 is_a? "," value first  operator == "," value first  operator "," value first  is_a? "]}," Tree PropNode custom_property?":{"type":"method","name":"custom_property?","children":[],"call":[" name first start_with? "," name first "," name "," name first is_a? "]}," Sass Stack with_directive":{"type":"method","name":"with_directive","children":[],"call":[" with_frame "]}," Sass Stack with_function":{"type":"method","name":"with_function","children":[],"call":[" with_frame "]}," Sass Selector Id unique?":{"type":"method","name":"unique?","children":[],"call":[]}," Sass Selector Simple unique?":{"type":"method","name":"unique?","children":[],"call":[]}," Sass Selector Sequence must_unify?":{"type":"method","name":"must_unify?","children":[],"call":["unique_selectors include? ","sel unique? ","sseq members any? ","sseq members ","sseq is_a? ","seq2 any? ","unique_selectors empty? ","(send\n  (lvar :seq1) :map) flatten to_set ","(send\n  (lvar :seq1) :map) flatten ","sseq members select ","seq1 map ","(send\n  (lvar :seq1) :map) flatten to_set  include? ","(send\n  (lvar :seq1) :map) flatten to_set  empty? "]}," Sass Selector Pseudo invisible?":{"type":"method","name":"invisible?","children":[],"call":["s invisible? ","@selector members all? ","@selector members "," name != "," name "]}," Sass Selector Pseudo unique?":{"type":"method","name":"unique?","children":[],"call":[" normalized_name == "," normalized_name "," type == "," type "]}," Sass Selector AbstractSequence invisible?":{"type":"method","name":"invisible?","children":[],"call":["m is_a? ","m invisible? "," members any? "," members "]}," Sass SCSS Parser declaration_value_token":{"type":"method","name":"declaration_value_token","children":[],"call":[" tok! "," declaration_value "," tok ","ws gsub ","ws include? "," interpolation "," interp_uri "," interp_string "," declaration_ declaration_value  "," tok  gsub "," tok  include? "]}," Sass SCSS Parser declaration_value":{"type":"method","name":"declaration_value","children":[],"call":[" merge ","value << "," declaration_value_token "," declaration_value_ declaration_value_token en "]}," Sass SCSS Parser css_variable_declaration":{"type":"method","name":"css_variable_declaration","children":[],"call":["node value_source_range= "," range ","node name_source_range= "," node ","Sass Tree PropNode  new ","name flatten compact ","name flatten "," source_position "," declaration_value "," node  value_source_range= ","node  declaration_value _source_range= "," node  name_source_range= ","  node  "," declaration_ declaration_value  "]}," Sass SCSS Parser parse_declaration_value":{"type":"method","name":"parse_declaration_value","children":[],"call":[" expected ","@scanner eos? "," declaration_value "," init_scanner! "," declaration_ declaration_value  "]}," Value Helpers special_number?":{"type":"method","name":"special_number?","children":[],"call":["literal value =~ ","literal value ","literal is_a? "]}," Value Function to_sass":{"type":"method","name":"to_sass","children":[],"call":[" value name "," value "]}," Value Function initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","ArgumentError  new ","function type == ","function type "]}," Value Callable to_sass":{"type":"method","name":"to_sass","children":[],"call":["Sass Util  abstract "]}," Value Callable inspect":{"type":"method","name":"inspect","children":[],"call":[" to_sass "]}," Value Callable to_s":{"type":"method","name":"to_s","children":[],"call":[" raise ","Sass SyntaxError  new "," to_sass "]}," Value Callable initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Value Base with_contents":{"type":"method","name":"with_contents","children":[],"call":["Sass Script Value List  new "]}," Value Base bracketed":{"type":"method","name":"bracketed","children":[],"call":[]}," Sass Script Parser peek_tok":{"type":"method","name":"peek_tok","children":[],"call":["name == ","peeked type ","@lexer peek ","@lexer peek  type "]}," Sass Script Parser square_list":{"type":"method","name":"square_list","children":[],"call":[" node ","Sass Script Tree ListLiteral  new "," source_position "," assert_tok ","elements length > ","elements length "," try_tok ","elements << "," space ","elements first ","elements length == "," interpolation "," paren "," without_stop_at "," nod space  "," nod node  "," nodelements first  "," nod interpolation  ","Sass Script Tr space  space  ListLit space ral  n space w ","Sass Script Tr node  node  ListLit node ral  n node w ","Sass Script Trelements first elements first  ListLitelements first ral  nelements first w ","Sass Script Tr interpolation  interpolation  ListLit interpolation ral  n interpolation w "," sourc space _position "," sourc node _position "," sourcelements first _position "," sourc interpolation _position "," ass space rt_tok "," ass node rt_tok "," asselements first rt_tok "," ass interpolation rt_tok "," space l space m space nts l space ngth > "," node l node m node nts l node ngth > ","elements first lelements first melements first nts lelements first ngth > "," interpolation l interpolation m interpolation nts l interpolation ngth > "," space l space m space nts l space ngth "," node l node m node nts l node ngth ","elements first lelements first melements first nts lelements first ngth "," interpolation l interpolation m interpolation nts l interpolation ngth "," space l space m space nts << "," node l node m node nts << ","elements first lelements first melements first nts << "," interpolation l interpolation m interpolation nts << "," spac space  "," spac node  "," spacelements first  "," spac interpolation  "," space l space m space nts first "," node l node m node nts first ","elements first lelements first melements first nts first "," interpolation l interpolation m interpolation nts first "," space l space m space nts l space ngth == "," node l node m node nts l node ngth == ","elements first lelements first melements first nts lelements first ngth == "," interpolation l interpolation m interpolation nts l interpolation ngth == "," int space rpolation "," int node rpolation "," intelements first rpolation "," int interpolation rpolation "," par space n "," par node n "," parelements first n "," par interpolation n "]}," Script Functions content_exists":{"type":"method","name":"content_exists","children":[],"call":[" bool "," environment caller content nil? ! "," environment caller content nil? "," environment caller content "," environment caller "," environment "," raise ","Sass SyntaxError  new ","mixin_frame type == ","mixin_frame type "," environment stack frames [] "," environment stack frames "," environment stack "," environment stack frames []  type == "," environment stack frames []  type "]}," Script Functions is_bracketed":{"type":"method","name":"is_bracketed","children":[],"call":[" bool ","list bracketed "]}," Script Functions get_function":{"type":"method","name":"get_function","children":[],"call":[" raise ","Sass SyntaxError  new ","Sass Script Value Function  new ","Sass Callable  new ","name value ","Sass Script Functions  callable? ","name value tr "," environment caller function "," environment caller "," environment ","ArgumentError  new ","kwargs keys first ","kwargs keys ","kwargs any? ","v value "," assert_type ","kwargs delete ","kwargs has_key? ","name kwargs delete alue ","name kwargs delete alue tr "," enkwargs delete ironment caller function "," enkwargs delete ironment caller "," enkwargs delete ironment ","kwargs delete  kwargs delete alue "]}," Sass ReadOnlyEnvironment initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Base capture":{"type":"method","name":"capture","children":[],"call":[" io= "," io to_s "," io ","StringIO  new "," io string "]}," Value Helpers var?":{"type":"method","name":"var?","children":[],"call":["literal value =~ ","literal value ","literal is_a? "]}," Sass Util escaped_char":{"type":"method","name":"escaped_char","children":[],"call":["escape [] ","1 to_i chr ","1 to_i ","escape =~ "]}," Sass Util normalize_ident_escapes":{"type":"method","name":"normalize_ident_escapes","children":[],"call":["char ord to_s ","char ord ","char =~ "," escaped_char ","ident gsub "," escaped_char  ord to_s "," escaped_char  ord "," escaped_char  =~ "," escaped_ escaped_char  "]}," Sass SCSS Parser name!":{"type":"method","name":"name!","children":[],"call":["Sass Util  normalize_ident_escapes "," tok! "]}," Sass SCSS Parser name":{"type":"method","name":"name","children":[],"call":["Sass Util  normalize_ident_escapes "," tok "]}," Sass SCSS Parser ident!":{"type":"method","name":"ident!","children":[],"call":["Sass Util  normalize_ident_escapes "," tok! "]}," Sass SCSS Parser ident":{"type":"method","name":"ident","children":[],"call":["Sass Util  normalize_ident_escapes "," tok ","Sass Util  normalize_ tok _escapes "]}," Sass Script Parser array_to_interpolation":{"type":"method","name":"array_to_interpolation","children":[],"call":["Sass Script Tree StringInterpolation  new ","Sass Script Tree Literal  new ","Sass Script Value String  new ","after after ","after mid ","value is_a? ","Sass Util  merge_adjacent_strings reverse inject ","Sass Util  merge_adjacent_strings reverse ","Sass Util  merge_adjacent_strings "]}," Sass Script Parser without_stop_at":{"type":"method","name":"without_stop_at","children":[],"call":[]}," Sass Script Parser peek_toks":{"type":"method","name":"peek_toks","children":[],"call":["names include? ","peeked type ","@lexer peek ","@lexer peek  type "]}," Sass Script Parser declaration_value":{"type":"method","name":"declaration_value","children":[],"call":["result << ","Lexer OPERATORS_REVERSE  [] "," assert_tok ","brackets pop ","brackets empty? ","tok type ","brackets << "," try_toks "," assert_expr "," try_tok ","@lexer next_char ","@lexer next "," peek_toks ","@lexer done? ","@lexer str "," loop "," assert_ try_toks  ","brackets pop s pop ","brackets pop s empty? "," try_toks  type ","brackets pop s << "," try_ try_toks s "," try_ try_toks  "," peek_ try_toks s "]}," Sass Script Parser nested_min_max":{"type":"method","name":"nested_min_max","children":[],"call":["tok value "," min_max_contents ","@lexer next ","(str \"min\") include? ","tok value downcase "," peek_tok "," peek_tok  value "," min_max_ min_max_contents  "," peek_tok  value downcase "," peek_ peek_tok  "]}," Sass Script Parser min_max_parens":{"type":"method","name":"min_max_parens","children":[],"call":[" min_max_contents "," try_tok "," min_max_ min_max_contents  "]}," Sass Script Parser min_max_calc":{"type":"method","name":"min_max_calc","children":[],"call":["@lexer next value ","@lexer next ","tok value value downcase start_with? ","tok value value downcase ","tok value value ","tok value "," peek_tok "," peek_tok  value value downcase start_with? "," peek_tok  value value downcase "," peek_tok  value value "," peek_tok  value "," peek_ peek_tok  "]}," Sass Script Parser min_max_function":{"type":"method","name":"min_max_function","children":[],"call":[" assert_tok "," declaration_value ","tok value ","@lexer next ","(str \"calc\") include? ","tok value downcase "," peek_tok "," assert_ peek_tok  "," peek_tok  value "," peek_tok  value downcase "," peek_ peek_tok  "]}," Sass Script Parser min_max_interpolation":{"type":"method","name":"min_max_interpolation","children":[],"call":[" assert_tok "," assert_expr "," without_stop_at "," try_tok "," assert_ try_tok  "," try_ try_tok  "]}," Sass Script Parser min_max_contents":{"type":"method","name":"min_max_contents","children":[],"call":["result << "," try_tok ","Lexer OPERATORS_REVERSE  [] ","tok type ","result concat "," nested_min_max "," min_max_parens "," min_max_function ","value value "," min_max_calc "," min_max_interpolation ","tok value to_s ","tok value "," loop "," try_ try_tok  "," try_tok  type "," min_max_calc   min_max_calc  "," min_max_interpolation   min_max_interpolation  ","tok  min_max_calc  to_s ","tok  min_max_interpolation  to_s "," try_tok  value to_s ","tok  min_max_calc  ","tok  min_max_interpolation  "," try_tok  value "]}," Sass Script Parser css_min_max":{"type":"method","name":"css_min_max","children":[],"call":[" funcall "," node "," source_position ","tok source_range start_pos ","tok source_range "," array_to_interpolation ","tok value "," min_max_contents ","(str \"min\") include? ","tok value downcase "," try_tok ","@lexer try "," try_tok  source_range start_pos "," try_tok  source_range "," try_tok  value "," min_max_ min_max_contents  "," try_tok  value downcase "," try_ try_tok  "]}," Sass Script Lexer try":{"type":"method","name":"try","children":[],"call":["@scanner pos= ","@interpolation_stack dup ","@scanner pos "]}," Sass Script Lexer next_char":{"type":"method","name":"next_char","children":[],"call":[" scan "," unpeek! "]}," Script Functions percentage_or_unitless":{"type":"method","name":"percentage_or_unitless","children":[],"call":[" raise ","ArgumentError  new ","max * / ","max * ","number value ","number is_unit? ","number unitless? ","number max * /  ","number number value  "]}," Sass Script CssParser interpolation":{"type":"method","name":"interpolation","children":[],"call":[" send "]}," Sass Util rstrip_except_escapes":{"type":"method","name":"rstrip_except_escapes","children":[],"call":["string sub "]}," Sass Util strip_except_escapes":{"type":"method","name":"strip_except_escapes","children":[],"call":[" rstrip_except_escapes ","string lstrip "]}," Tree StringInterpolation detected_quote":{"type":"method","name":"detected_quote","children":[],"call":["c include? ","c is_a? "," contents each "," contents "]}," Sass Script Lexer whitespace_before?":{"type":"method","name":"whitespace_before?","children":[],"call":["@scanner string [] =~ ","@scanner string [] ","tok pos ","@scanner string "]}," Sass Script CssParser ident":{"type":"method","name":"ident","children":[],"call":[" literal_node ","name source_range ","Sass Script Value String  new ","name value ","Sass Script Value Color  new ","Sass Script Value Color COLOR_NAMES  [] ","name value downcase ","@lexer next ","@stop_at include? ","@lexer peek value ","@lexer peek "," funcall ","@lexer peek type == ","@lexer peek type ","@lexer next  source_range ","@lexer next  value ","@lexer next  value downcase "]}}