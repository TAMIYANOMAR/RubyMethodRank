{" MultiXml parse":{"type":"method","name":"parse","children":[],"call":[" engine parse "," engine ","hash nil? "," symbolize_keys ","options [] "," typecast_xml_value "," undasherize_keys "," parser parse "," parser ","xml strip! "," raise ","exception inspect ","error backtrace ","error to_s "," parser parse_error ","xml ungetc ","char nil? ","xml getc ","StringIO  new ","xml respond_to? "," parser string_parser? "," parser respond_to? ","error message ","DEFAULT_OPTIONS  merge ","xml strip "," symbolize_keys  nil? "," typecast_xml_value  nil? "," undasherize_keys  nil? ","DEFAULT_OPTIONS  merge  [] "," typecast_StringIO  new _value "," typecast_xml strip _value ","StringIO  new  strip! ","xml strip  strip! ","StringIO  new  ungetc ","xml strip  ungetc ","xml getc  nil? ","StringIO  new  getc ","xml strip  getc ","StringIO  new  respond_to? ","xml strip  respond_to? ","StringIO  new  strip ","xml strip  strip "]}," MultiXml engine=":{"type":"method","name":"engine=","children":[],"call":[" raise ","MultiXml Engines  const_get ","(send\n  (send\n    (send\n      (lvar :new_engine) :to_s) :split\n    (str \"_\")) :map) join ","s capitalize ","new_engine to_s split map ","new_engine to_s split ","new_engine to_s "," require "]}," MultiXml default_engine":{"type":"method","name":"default_engine","children":[],"call":[" require ","REQUIREMENT_MAP  each "]}," MultiXml engine":{"type":"method","name":"engine","children":[],"call":[" engine= "," default_engine "]}," MultiXml Engines RexmlUtilityNode unnormalize_xml_entities":{"type":"method","name":"unnormalize_xml_entities","children":[],"call":[" REXML Text  unnormalize "]}," MultiXml Engines RexmlUtilityNode to_html":{"type":"method","name":"to_html","children":[],"call":[" name "," inner_html "," attributes to_xml_attributes "," attributes "," attributes merge! "]}," MultiXml Engines RexmlUtilityNode inner_html":{"type":"method","name":"inner_html","children":[],"call":["@children join "]}," MultiXml Engines RexmlUtilityNode undasherize_keys":{"type":"method","name":"undasherize_keys","children":[],"call":["params []= ","params delete ","key tr ","params keys each ","params keys "]}," MultiXml Engines RexmlUtilityNode typecast_value":{"type":"method","name":"typecast_value","children":[],"call":["proc call ","proc nil? "," class typecasts [] "," class typecasts "," class "," class typecasts []  call "," class typecasts []  nil? "]}," MultiXml Engines RexmlUtilityNode to_hash":{"type":"method","name":"to_hash","children":[],"call":[" name "," typecast_value ","out nil? ","out empty? ","out merge! "," attributes "," attributes empty? ","e to_hash [] ","e to_hash ","v map ","v first ","v size == ","v size ","groups each ","out flatten ","out << ","v first to_hash entries first last ","v first to_hash entries first ","v first to_hash entries ","v first to_hash ","@type == ","(or-asgn\n  (send\n    (lvar :s) :[]\n    (send\n      (lvar :e) :name))\n  (array)) << ","s [] ","e name ","@children inject ","t attributes= ","t class send ","t class "," unnormalize_xml_entities "," inner_html ","f content_type= "," attributes [] ","f original_filename= "," attr_accessor ","StringIO  new ","(or\n  (send\n    (ivar :@children) :first)\n  (str \"\")) unpack first ","(or\n  (send\n    (ivar :@children) :first)\n  (str \"\")) unpack ","@children first ","  typecast_value ypecas typecast_value _value ","out flatten  nil? ","ou typecast_value  nil? ","out flatten  empty? ","ou typecast_value  emp typecast_value y? ","out flatten  merge! ","ou typecast_value  merge! "," a typecast_value  typecast_value ribu typecast_value es "," a typecast_value  typecast_value ribu typecast_value es emp typecast_value y? ","e  typecast_value o_hash [] ","e  typecast_value o_hash ","v firs typecast_value  ","v StringIO  new irst ","out flatten  flatten ","ou typecast_value  fla typecast_value  typecast_value en ","out StringIO  new latten ","out flatten  << ","ou typecast_value  << ","v firs typecast_value   typecast_value o_hash en typecast_value ries firs typecast_value  las typecast_value  ","v StringIO  new irst to_hash entries StringIO  new irst last ","v firs typecast_value   typecast_value o_hash en typecast_value ries firs typecast_value  ","v StringIO  new irst to_hash entries StringIO  new irst ","v firs typecast_value   typecast_value o_hash en typecast_value ries ","v StringIO  new irst to_hash entries ","v firs typecast_value   typecast_value o_hash ","v StringIO  new irst to_hash ","@ typecast_value ype == ","@children injec typecast_value  "," typecast_value  a typecast_value  typecast_value ribu typecast_value es= "," typecast_value  class send "," typecast_value  class "," unnormalize_xml_en typecast_value i typecast_value ies "," inner_h typecast_value ml ","f con typecast_value en typecast_value _ typecast_value ype= ","StringIO  new  content_type= "," a typecast_value  typecast_value ribu typecast_value es [] ","StringIO  new  original_StringIO  new ilename= "," a typecast_value  typecast_value r_accessor ","S typecast_value ringIO  new ","(or\n  (send\n    (ivar :@children) :firs typecast_value )\n  (s typecast_value r \"\")) unpack firs typecast_value  ","(or\n  (send\n    (ivar :@children) :StringIO  new irst)\n  (str \"\")) unpack StringIO  new irst ","(or\n  (send\n    (ivar :@children) :firs typecast_value )\n  (s typecast_value r \"\")) unpack ","(or\n  (send\n    (ivar :@children) :StringIO  new irst)\n  (str \"\")) unpack ","@children firs typecast_value  ","@children StringIO  new irst "]}," MultiXml Engines RexmlUtilityNode add_node":{"type":"method","name":"add_node","children":[],"call":["@children << ","node is_a? "]}," MultiXml Engines RexmlUtilityNode initialize":{"type":"method","name":"initialize","children":[],"call":[" undasherize_keys ","attributes delete == ","attributes delete ","attributes [] "," class available_typecasts include? "," class available_typecasts "," class ","name tr ","Hash  [] ","(send\n  (lvar :normalized_attributes) :map) flatten "," unnormalize_xml_entities ","normalized_attributes map ","Hash  []  delete == ","Hash  []  delete ","Hash  []  [] ","(send\n  (lvar :normalized_Hash  [] ) :map) flatten ","normalized_Hash  []  map "]}," MultiXml Engines RexmlUtilityNode available_typecasts=":{"type":"method","name":"available_typecasts=","children":[],"call":[]}," MultiXml Engines RexmlUtilityNode available_typecasts":{"type":"method","name":"available_typecasts","children":[],"call":[]}," MultiXml Engines RexmlUtilityNode typecasts=":{"type":"method","name":"typecasts=","children":[],"call":[]}," MultiXml Engines RexmlUtilityNode typecasts":{"type":"method","name":"typecasts","children":[],"call":[]}," MultiXml Engines Rexml symbolize_keys":{"type":"method","name":"symbolize_keys","children":[],"call":[]}," MultiXml Engines Rexml parse":{"type":"method","name":"parse","children":[],"call":[]}," MultiXml typecast_xml_value":{"type":"method","name":"typecast_xml_value","children":[],"call":[" raise ","value inspect ","value class name ","value class ","value first ","value length > ","value length "," typecast_xml_value ","value map! ","xml_value [] ","xml_value [] is_a? ","hash []= ","value inject ","value [] is_a? ! ","value [] is_a? ","value [] ","value size == ","value size ","value [] == ","value empty? ","value nil? ","value [] != ","block call ","block arity == ","block arity ","PARSING  [] ","value has_key? ","entries inspect ","entries class name ","entries class ","entries map ","c nil? ","entries strip == ","entries strip ","entries nil? "," wrap ","key != ","value detect ","value blank? ","c blank? ","entries blank? ","value is_a? ","Array  wrap ","entries strip empty? ","entries is_a? ","v is_a? ","k != ","value keys size > ","value keys size ","value keys ","value []= ","value delete ","disallowed_types include? ","value include? ","value key? ","entries collect ","DisallowedTypeError  new ","PARSING  []  call ","PARSING  []  arity == ","PARSING  []  arity "]}," MultiXml wrap":{"type":"method","name":"wrap","children":[],"call":["object to_ary ","object respond_to? ","object nil? "]}," MultiXml undasherize_keys":{"type":"method","name":"undasherize_keys","children":[],"call":[" undasherize_keys ","params map ","hash []= ","key to_s tr ","key to_s ","params inject ","params collect ","_ freeze ","- freeze "]}," MultiXml symbolize_keys":{"type":"method","name":"symbolize_keys","children":[],"call":["result []= "," symbolize_keys ","key to_sym ","hash inject ","params map ","result merge ","params inject ","params collect "]}," MultiXml parse_file":{"type":"method","name":"parse_file","children":[],"call":["f content_type= ","entity [] ","f original_filename= ","f extend ","StringIO  new ","Base64  decode64 ","StringIO  new  content_type= ","StringIO  new  original_StringIO  new ilename= ","StringIO  new  extend "]}," MultiXml parse_binary":{"type":"method","name":"parse_binary","children":[],"call":["Base64  decode64 ","entity [] "]}," MultiXml FileLike content_type":{"type":"method","name":"content_type","children":[],"call":[]}," MultiXml FileLike original_filename":{"type":"method","name":"original_filename","children":[],"call":[]}," MultiXml parser=":{"type":"method","name":"parser=","children":[],"call":[" raise ","MultiXml Parsers  const_get ","(send\n  (send\n    (send\n      (lvar :new_parser) :to_s) :split\n    (str \"_\")) :map) join ","s capitalize ","new_parser to_s split map ","new_parser to_s split ","new_parser to_s "," require ","new_parser to_s downcase ","new_parser to_s split collect join to_s ","new_parser to_s split collect join ","new_parser to_s split collect "]}," MultiXml default_parser":{"type":"method","name":"default_parser","children":[],"call":[" require ","REQUIREMENT_MAP  each "," raise ","NoParserError  new "]}," MultiXml parser":{"type":"method","name":"parser","children":[],"call":[" parser= "," default_parser ","@@parser nil? "]}," MultiXml Parsers Rexml empty_content?":{"type":"method","name":"empty_content?","children":[],"call":["element texts join empty? ","element texts join ","element texts ","element texts join nil? ","element texts join blank? ","element texts join strip empty? ","element texts join strip "]}," MultiXml Parsers Rexml get_attributes":{"type":"method","name":"get_attributes","children":[],"call":["attributes []= ","element attributes each ","element attributes "]}," MultiXml Parsers Rexml merge!":{"type":"method","name":"merge!","children":[],"call":["hash []= ","value instance_of? ","hash [] ","hash [] << ","hash [] instance_of? ","hash has_key? ","hash key? "]}," MultiXml Parsers Rexml merge_texts!":{"type":"method","name":"merge_texts!","children":[],"call":[" merge! ","texts << ","t value ","element texts each ","element texts ","element has_text? "]}," MultiXml Parsers Rexml collapse":{"type":"method","name":"collapse","children":[],"call":[" merge_texts! "," empty_content? "," merge_element! ","element each_element ","element has_elements? "," get_attributes "]}," MultiXml Parsers Rexml merge_element!":{"type":"method","name":"merge_element!","children":[],"call":[" merge! "," collapse ","element name "]}," MultiXml Parsers Rexml parse":{"type":"method","name":"parse","children":[],"call":[" raise ","doc to_s inspect ","doc to_s "," merge_element! ","doc root ","REXML Document  new ","data ungetc ","char nil? ","data getc ","StringIO  new ","data respond_to? ! ","data respond_to? ","xml ungetc ","xml getc ","xml respond_to? ! ","xml respond_to? ","REXML ParseException  new ","REXML Document  new  to_s inspect ","REXML Document  new  to_s ","REXML Document  new  root ","StringIO  new  ungetc ","data getc  nil? ","xml getc  nil? ","StringIO  new  getc ","StringIO  new  respond_to? ! ","StringIO  new  respond_to? "]}," MultiXml Parsers Nokogiri Conversions Node to_hash":{"type":"method","name":"to_hash","children":[],"call":["node_hash []= ","a value ","a node_name "," attribute_nodes each "," attribute_nodes ","node_hash delete ","node_hash [] empty? ","node_hash [] ","node_hash [] nil? ","node_hash length > ","node_hash length ","node_hash [] << ","c content ","c cdata? ","c text? ","c to_hash ","c element? "," children each "," children ","hash []= "," name ","hash [] ","hash [] << ","node_hash [] blank? "]}," MultiXml Parsers Nokogiri Conversions Document to_hash":{"type":"method","name":"to_hash","children":[],"call":[" root to_hash "," root "]}," MultiXml Parsers Nokogiri parse":{"type":"method","name":"parse","children":[],"call":["doc to_hash "," raise ","doc errors first ","doc errors ","doc errors length > ","doc errors length "," Nokogiri  XML ","data ungetc ","char nil? ","data getc ","StringIO  new ","data respond_to? ! ","data respond_to? ","xml ungetc ","xml getc ","xml respond_to? ! ","xml respond_to? "," node_to_hash ","doc root ","doc errors empty? "," Nokogiri  XML  to_hash "," Nokogiri  XML  errors first "," Nokogiri  XML  errors "," Nokogiri  XML  errors length > "," Nokogiri  XML  errors length ","StringIO  new  ungetc ","data getc  nil? ","xml getc  nil? ","StringIO  new  getc ","StringIO  new  respond_to? ! ","StringIO  new  respond_to? "," Nokogiri  XML  root "," Nokogiri  XML  errors empty? "]}," LibXML Conversions Node to_hash":{"type":"method","name":"to_hash","children":[],"call":["node_hash []= ","a value ","a name "," each_attr ","node_hash delete ","node_hash [] empty? ","node_hash [] ","node_hash [] nil? ","node_hash length > ","node_hash length ","node_hash [] << ","c content ","c cdata? ","c text? ","c to_hash ","c element? "," each_child ","hash []= "," name ","hash [] ","hash [] << ","node_hash [] blank? "]}," LibXML Conversions Document to_hash":{"type":"method","name":"to_hash","children":[],"call":[" root to_hash "," root "]}," MultiXml Parsers Libxml parse":{"type":"method","name":"parse","children":[],"call":["LibXML XML Parser  io parse to_hash ","LibXML XML Parser  io parse ","LibXML XML Parser  io ","data ungetc ","char nil? ","data getc ","StringIO  new ","data respond_to? ! ","data respond_to? ","xml ungetc ","xml getc ","xml respond_to? ! ","xml respond_to? "," node_to_hash ","LibXML XML Parser  io parse root ","StringIO  new  ungetc ","data getc  nil? ","xml getc  nil? ","StringIO  new  getc ","StringIO  new  respond_to? ! ","StringIO  new  respond_to? "]}," String blank?":{"type":"method","name":"blank?","children":[],"call":[" strip empty? "," strip "]}," FalseClass blank?":{"type":"method","name":"blank?","children":[],"call":[]}," TrueClass blank?":{"type":"method","name":"blank?","children":[],"call":[]}," NilClass blank?":{"type":"method","name":"blank?","children":[],"call":[]}," Numeric blank?":{"type":"method","name":"blank?","children":[],"call":[]}," Object blank?":{"type":"method","name":"blank?","children":[],"call":[" empty? "," respond_to? "," nil? "]}," Array wrap":{"type":"method","name":"wrap","children":[],"call":[]}," MultiXml Parsers Rexml parse_error":{"type":"method","name":"parse_error","children":[],"call":[]}," MultiXml Parsers Nokogiri parse_error":{"type":"method","name":"parse_error","children":[],"call":[]}," MultiXml Parsers Libxml parse_error":{"type":"method","name":"parse_error","children":[],"call":[]}," MultiXml Parsers Nokogiri node_name":{"type":"method","name":"node_name","children":[],"call":["node node_name "]}," MultiXml Parsers Nokogiri each_attr":{"type":"method","name":"each_attr","children":[],"call":["node attribute_nodes each ","node attribute_nodes "]}," MultiXml Parsers Nokogiri each_child":{"type":"method","name":"each_child","children":[],"call":["node children each ","node children "]}," MultiXml Parsers Libxml2Parser node_name":{"type":"method","name":"node_name","children":[],"call":[" raise "," __method__ ","NotImplementedError  new "]}," MultiXml Parsers Libxml2Parser each_attr":{"type":"method","name":"each_attr","children":[],"call":[" raise "," __method__ ","NotImplementedError  new "]}," MultiXml Parsers Libxml2Parser each_child":{"type":"method","name":"each_child","children":[],"call":[" raise "," __method__ ","NotImplementedError  new "]}," MultiXml Parsers Libxml2Parser parse":{"type":"method","name":"parse","children":[],"call":[" raise "," __method__ ","NotImplementedError  new "]}," MultiXml Parsers Libxml2Parser node_to_hash":{"type":"method","name":"node_to_hash","children":[],"call":["node_hash []= ","a value "," node_name "," each_attr ","node_hash delete ","node_hash [] strip empty? ","node_hash [] strip ","node_hash [] ","node_hash [] << ","c content ","c cdata? ","c text? "," node_to_hash ","c element? "," each_child ","hash []= ","hash [] ","hash [] << ","a node_hash [] alue "," node_ node_name  "]}," MultiXml Parsers Libxml node_name":{"type":"method","name":"node_name","children":[],"call":["node name "]}," MultiXml Parsers Libxml each_attr":{"type":"method","name":"each_attr","children":[],"call":["node each_attr "]}," MultiXml Parsers Libxml each_child":{"type":"method","name":"each_child","children":[],"call":["node each_child "]}," MultiXml Parsers Ox string_parser?":{"type":"method","name":"string_parser?","children":[],"call":[]}," MultiXml Parsers Ox element_to_hash":{"type":"method","name":"element_to_hash","children":[],"call":["h []= ","e name ","ex << ","ex is_a? ","(lvasgn :ex\n  (send\n    (lvar :h) :[]\n    (send\n      (lvar :e) :name))) nil? ","h [] ","content []= ","n value ","n is_a? "," element_to_hash ","e nodes each ","e nodes ","k to_s ","e attributes each ","e attributes ","h []  << ","h []  is_a? ","(lvasgn :h [] \n  (send\n    (lvar :h) :[]\n    (send\n      (lvar :e) :name))) nil? "]}," MultiXml Parsers Ox parse":{"type":"method","name":"parse","children":[],"call":[" element_to_hash ","doc nil? "," Ox  parse ","handler doc "," Ox  sax_parse ","Handler  new "," Ox  parse  nil? ","handler  Ox  parse  ","Handler  new  doc "]}," MultiXml Parsers Ox parse_error":{"type":"method","name":"parse_error","children":[],"call":[]}," MultiXml Parsers Ox Handler append":{"type":"method","name":"append","children":[],"call":["h []= ","v << ","v is_a? ","h [] ","h has_key? ","@stack last ","key to_s ","h key? ","@stack last  []= ","h []  << ","h []  is_a? ","@stack last  [] ","@stack last  @stack last as_key? ","h has_key to_s ? ","key to_s  to_s ","@stack last  key? ","h key to_s ? "]}," MultiXml Parsers Ox Handler error":{"type":"method","name":"error","children":[],"call":[" raise ","Exception  new "]}," MultiXml Parsers Ox Handler end_element":{"type":"method","name":"end_element","children":[],"call":["@stack pop "]}," MultiXml Parsers Ox Handler start_element":{"type":"method","name":"start_element","children":[],"call":["@stack push "," append ","Hash  new ","@stack empty? ","@stack pusHash  new  ","HasHash  new   new "]}," MultiXml Parsers Ox Handler cdata":{"type":"method","name":"cdata","children":[],"call":[" append "]}," MultiXml Parsers Ox Handler text":{"type":"method","name":"text","children":[],"call":[" append "]}," MultiXml Parsers Ox Handler attr":{"type":"method","name":"attr","children":[],"call":[" append ","@stack empty? "]}," MultiXml Parsers Ox Handler doc":{"type":"method","name":"doc","children":[],"call":["@stack [] "]}," MultiXml Parsers Ox Handler initialize":{"type":"method","name":"initialize","children":[],"call":[]}," MultiXml DisallowedTypeError initialize":{"type":"method","name":"initialize","children":[],"call":["type inspect "]}," MultiXml Version to_s":{"type":"method","name":"to_s","children":[],"call":[" to_a join "," to_a "]}," MultiXml Version to_a":{"type":"method","name":"to_a","children":[],"call":["(send nil :major) compact "," pre "," patch "," minor "," major "]}," MultiXml Version to_h":{"type":"method","name":"to_h","children":[],"call":[" pre "," patch "," minor "," major "]}," MultiXml Version pre":{"type":"method","name":"pre","children":[],"call":[]}," MultiXml Version patch":{"type":"method","name":"patch","children":[],"call":[]}," MultiXml Version minor":{"type":"method","name":"minor","children":[],"call":[]}," MultiXml Version major":{"type":"method","name":"major","children":[],"call":[]}," MultiXml Parsers Oga node_name":{"type":"method","name":"node_name","children":[],"call":["node name "]}," MultiXml Parsers Oga each_attr":{"type":"method","name":"each_attr","children":[],"call":["node attributes each ","node attributes "]}," MultiXml Parsers Oga each_child":{"type":"method","name":"each_child","children":[],"call":["node children each ","node children "]}," MultiXml Parsers Oga node_to_hash":{"type":"method","name":"node_to_hash","children":[],"call":["node_hash []= ","a value ","node_hash [] "," node_name "," each_attr ","node_hash delete ","node_hash [] strip empty? ","node_hash [] strip ","node_hash [] << ","c text ","c is_a? "," node_to_hash "," each_child ","hash []= ","hash [] ","hash [] << ","a node_hash [] alue "," node_ node_name  "]}," MultiXml Parsers Oga parse":{"type":"method","name":"parse","children":[],"call":[" node_to_hash ","document children [] ","document children "," Oga  parse_xml "," Oga  parse_xml  children [] "," Oga  parse_xml  children "]}," MultiXml Parsers Oga parse_error":{"type":"method","name":"parse_error","children":[],"call":[]}}