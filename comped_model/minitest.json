{" MiniTest Unit TestCase passed?":{"type":"method","name":"passed?","children":[],"call":[]}," MiniTest Unit TestCase teardown":{"type":"method","name":"teardown","children":[],"call":[]}," MiniTest Unit TestCase setup":{"type":"method","name":"setup","children":[],"call":[]}," MiniTest Unit TestCase test_methods":{"type":"method","name":"test_methods","children":[],"call":[]}," MiniTest Unit TestCase test_suites":{"type":"method","name":"test_suites","children":[],"call":[]}," MiniTest Unit TestCase test_order":{"type":"method","name":"test_order","children":[],"call":[]}," MiniTest Unit TestCase inherited":{"type":"method","name":"inherited","children":[],"call":[]}," MiniTest Unit TestCase reset":{"type":"method","name":"reset","children":[],"call":[]}," MiniTest Unit TestCase initialize":{"type":"method","name":"initialize","children":[],"call":[]}," MiniTest Unit TestCase run":{"type":"method","name":"run","children":[],"call":["runner puke "," name "," class "," teardown "," __send__ "," setup "," __name__ "," trap "," raise ","runner status "," warn ","%s#%s %.2fs % ","Time  now - ","runner start_time ","Time  now "," io? "," run_teardown_hooks "," run_test "," run_setup_hooks "," send ","(str \"before_teardown\") each "," after_setup "," before_setup ","Current Test: %s#%s %.2fs % ","\n%3d) %s % ","i + ","runner report each_with_index ","runner report ","runner record "," _assertions ","Skip  === ","runner info_signal ","runner start_Time  now -  ","runner Time  now  "]}," MiniTest Unit run_test_suites":{"type":"method","name":"run_test_suites","children":[],"call":["@@out sync= ","@@out respond_to? ","inst _assertions ","@@out puts ","@@out print ","%.2f s:  % ","Time  now - ","Time  now ","inst run ","inst _assertions= ","suite new ","suite test_methods grep each ","suite test_methods grep ","suite test_methods ","TestCase  test_suites each ","TestCase  test_suites ","@@out sync ","@@ouTime  now  sync= ","@@ouTime  now  respond_Time  now o? ","insTime  now  _asserTime  now ions ","suite new  _assertions ","@@ouTime  now  puTime  now s ","@@ouTime  now  prinTime  now  ","insTime  now  run ","suite new  run ","insTime  now  _asserTime  now ions= ","suite new  _assertions= ","suiTime  now e new ","suiTime  now e Time  now esTime  now _meTime  now hods grep each ","suiTime  now e Time  now esTime  now _meTime  now hods grep ","suiTime  now e Time  now esTime  now _meTime  now hods ","TesTime  now Case  Time  now esTime  now _suiTime  now es each ","TesTime  now Case  Time  now esTime  now _suiTime  now es ","@@ouTime  now  sync "]}," MiniTest Unit run":{"type":"method","name":"run","children":[],"call":[" failures + "," errors "," failures ","@test_count > ","@@out puts ","format % "," skips "," assertion_count "," test_count ","\n%3d) %s % ","i + ","@report each_with_index ","%.6f % ","Time  now - ","Time  now "," run_test_suites ","$0 sub ","Regexp  new ","arg =~ ","args shift ","args first =~ ","args first ","args delete "," abort "," status ","help join ","help push ","options [] inspect ","options [] "," srand "," srand % ","filter =~ "," process_args "," report empty? "," report "," send "," class plugins each "," class plugins "," class "," puts "," help "," options= "," class runner _run "," class runner ","args shift  =~ ","args shift s shift ","args shift s first =~ ","args shift s first ","args shift s delete "," process_args  [] inspect "," process_args  [] ","Regexp  new  =~ "," process_args shift s ","  process_args = "]}," MiniTest Unit initialize":{"type":"method","name":"initialize","children":[],"call":[" last_error= ","Mutex  new ","Signal  list [] ","Signal  list "]}," MiniTest Unit puke":{"type":"method","name":"puke","children":[],"call":["e [] ","@report << ","e message ","e class ","MiniTest  filter_backtrace join ","MiniTest  filter_backtrace ","e backtrace "," location "," last_error= "]}," MiniTest Unit location":{"type":"method","name":"location","children":[],"call":["(send\n  (send\n    (lvar :e) :backtrace) :find) sub ","s !~ ","e backtrace find ","e backtrace ","last_before_assertion sub ","s =~ ","e backtrace reverse_each "]}," MiniTest Unit output=":{"type":"method","name":"output=","children":[],"call":[]}," MiniTest Unit autorun":{"type":"method","name":"autorun","children":[],"call":[]}," MiniTest Assertions skip":{"type":"method","name":"skip","children":[],"call":[" raise "]}," MiniTest Assertions refute_same":{"type":"method","name":"refute_same","children":[],"call":[" refute ","exp equal? "," mu_pp "," message ","Expected %s (oid=%d) to not be the same as %s (oid=%d) % ","exp object_id ","act object_id "]}," MiniTest Assertions refute_respond_to":{"type":"method","name":"refute_respond_to","children":[],"call":[" refute ","obj respond_to? ","(send\n  (const nil :Symbol) :===\n  (lvar :meth)) ! ","Symbol  === "," mu_pp "," message "]}," MiniTest Assertions refute_operator":{"type":"method","name":"refute_operator","children":[],"call":[" refute ","o1 __send__ "," mu_pp "," message "," refute_predicate ","UNDEFINED  == ","o2 == "]}," MiniTest Assertions refute_nil":{"type":"method","name":"refute_nil","children":[],"call":[" refute ","obj nil? "," mu_pp "," message "]}," MiniTest Assertions refute_match":{"type":"method","name":"refute_match","children":[],"call":[" refute ","act =~ "," mu_pp "," message ","exp =~ ","Regexp  escape ","String  === "," assert_respond_to ","matcher =~ ","Regexp  new ","Regexp  new  =~ "]}," MiniTest Assertions refute_kind_of":{"type":"method","name":"refute_kind_of","children":[],"call":[" refute ","obj kind_of? ","(send\n  (const nil :Module) :===\n  (lvar :cls)) ! ","Module  === "," mu_pp "," message "]}," MiniTest Assertions refute_instance_of":{"type":"method","name":"refute_instance_of","children":[],"call":[" refute ","cls === ","(send\n  (const nil :Module) :===\n  (lvar :cls)) ! ","Module  === "," mu_pp "," message ","obj instance_of? "]}," MiniTest Assertions refute_includes":{"type":"method","name":"refute_includes","children":[],"call":[" refute ","collection include? "," assert_respond_to "," mu_pp "," message ","(send\n  (lvar :collection) :respond_to?\n  (sym :include?)) ! ","collection respond_to? ","obj respond_to? "]}," MiniTest Assertions refute_in_epsilon":{"type":"method","name":"refute_in_epsilon","children":[],"call":[" refute_in_delta ","a * "]}," MiniTest Assertions refute_in_delta":{"type":"method","name":"refute_in_delta","children":[],"call":[" refute ","delta > "," message ","(send\n  (lvar :exp) :-\n  (lvar :act)) abs ","exp - ","delta >= ","(se(send\n  (lvar :exp) :-\n  (lvar :act)) abs d\n  (lvar :exp) :-\n  (lvar :act)) abs "]}," MiniTest Assertions refute_equal":{"type":"method","name":"refute_equal","children":[],"call":[" refute ","exp == "," mu_pp "," message "]}," MiniTest Assertions refute_empty":{"type":"method","name":"refute_empty","children":[],"call":[" refute ","obj empty? "," assert_respond_to ","obj inspect "," message "," mu_pp "]}," MiniTest Assertions refute":{"type":"method","name":"refute","children":[],"call":[" assert ! "," assert ","test ! "]}," MiniTest Assertions pass":{"type":"method","name":"pass","children":[],"call":[" assert "]}," MiniTest Assertions message":{"type":"method","name":"message","children":[],"call":["default call ","msg strip ","msg empty? ","msg to_s ","String  === "," proc ","msg to_s empty? ","msg nil? ","msg call chomp ","msg call ","Proc  === ","msg to_s  strip ","msg call chomp  strip ","msg to_s  empty? ","msg call chomp  empty? ","msg to_s  to_s ","msg call chomp  to_s ","msg to_s  to_s empty? ","msg call chomp  to_s empty? ","msg to_s  nil? ","msg call chomp  nil? ","msg to_s  call chomp ","msg call chomp  call chomp ","msg to_s  call ","msg call chomp  call "]}," MiniTest Assertions flunk":{"type":"method","name":"flunk","children":[],"call":[" assert "]}," MiniTest Assertions exception_details":{"type":"method","name":"exception_details","children":[],"call":["MiniTest  filter_backtrace join ","MiniTest  filter_backtrace ","e backtrace ","e message inspect ","e message ","e class ","(dstr\n  (begin\n    (lvar :msg))) join "]}," MiniTest Assertions capture_io":{"type":"method","name":"capture_io","children":[],"call":["captured_stderr string ","captured_stdout string ","StringIO  new ","$stderr dup ","$stdout dup "," require "," synchronize "]}," MiniTest Assertions assert_throws":{"type":"method","name":"assert_throws","children":[],"call":[" assert "," message ","e name inspect ","e name ","e message split last ","e message split ","e message "," catch "," mu_pp ","e message [] "]}," MiniTest Assertions assert_send":{"type":"method","name":"assert_send","children":[],"call":[" assert ","recv __send__ "," mu_pp "," message "]}," MiniTest Assertions assert_same":{"type":"method","name":"assert_same","children":[],"call":[" assert ","exp equal? ","Expected %s (0x%x) to be the same as %s (0x%x) % ","exp object_id "," mu_pp ","act object_id "," message ","Expected %s (oid=%d) to be the same as %s (oid=%d) % "]}," MiniTest Assertions assert_respond_to":{"type":"method","name":"assert_respond_to","children":[],"call":[" assert ","obj respond_to? ","(send\n  (const nil :Symbol) :===\n  (lvar :meth)) ! ","Symbol  === ","obj class "," mu_pp "," message "]}," MiniTest Assertions assert_raises":{"type":"method","name":"assert_raises","children":[],"call":[" flunk "," mu_pp ","exp first ","exp size == ","exp size "," assert_includes "," exception_details ","e class ","exp pop ","String  === ","exp last "," assert ","ex == ","e kind_of? ","ex instance_of? ","exp any? ","msg to_s + ","msg to_s "," raise ","exp include? "," proc ","e instance_of? ","exp first  first ","exp first  size == ","exp first  size ","exp first  pop ","exp first  last ","exp first  any? ","exp pop  to_s + ","msg to_s +  to_s + ","exp pop  to_s ","msg to_s +  to_s ","exp first  include? "]}," MiniTest Assertions assert_operator":{"type":"method","name":"assert_operator","children":[],"call":[" assert ","o1 __send__ "," mu_pp "," message "," assert_predicate ","UNDEFINED  == ","o2 == "]}," MiniTest Assertions assert_nil":{"type":"method","name":"assert_nil","children":[],"call":[" assert ","obj nil? "," mu_pp "," message "]}," MiniTest Assertions assert_match":{"type":"method","name":"assert_match","children":[],"call":[" assert ","act =~ ","String  === "," assert_respond_to "," mu_pp "," message ","exp =~ ","Regexp  escape ","Regexp  new ","matcher =~ ","Regexp  new  =~ ","RegRegexp  new   escape ","RegRegexp  new   new "]}," MiniTest Assertions assert_kind_of":{"type":"method","name":"assert_kind_of","children":[],"call":[" assert ","obj kind_of? ","(send\n  (const nil :Module) :===\n  (lvar :cls)) ! ","Module  === ","obj class "," mu_pp "," message "]}," MiniTest Assertions assert_instance_of":{"type":"method","name":"assert_instance_of","children":[],"call":[" assert ","cls === ","(send\n  (const nil :Module) :===\n  (lvar :cls)) ! ","Module  === ","obj class "," mu_pp "," message ","obj instance_of? "]}," MiniTest Assertions assert_includes":{"type":"method","name":"assert_includes","children":[],"call":[" assert ","collection include? "," assert_respond_to "," mu_pp "," message ","(send\n  (lvar :collection) :respond_to?\n  (sym :include?)) ! ","collection respond_to? ","obj respond_to? "]}," MiniTest Assertions assert_in_epsilon":{"type":"method","name":"assert_in_epsilon","children":[],"call":[" assert_in_delta ","(lvar :a) min * ","(lvar :a) min ","(send\n  (lvar :a) :abs) min * ","(send\n  (lvar :a) :abs) min ","b abs ","a abs "]}," MiniTest Assertions assert_in_delta":{"type":"method","name":"assert_in_delta","children":[],"call":[" assert ","delta > "," message ","(send\n  (lvar :exp) :-\n  (lvar :act)) abs ","exp - ","delta >= ","(se(send\n  (lvar :exp) :-\n  (lvar :act)) abs d\n  (lvar :exp) :-\n  (lvar :act)) abs "]}," MiniTest Assertions assert_equal":{"type":"method","name":"assert_equal","children":[],"call":[" assert ","exp == "," mu_pp "," message "," diff "]}," MiniTest Assertions assert_empty":{"type":"method","name":"assert_empty","children":[],"call":[" assert ","obj empty? "," assert_respond_to ","obj inspect "," message "," mu_pp "]}," MiniTest Assertions assert_block":{"type":"method","name":"assert_block","children":[],"call":[" assert "," message "," warn "," caller first "," caller "]}," MiniTest Assertions assert":{"type":"method","name":"assert","children":[],"call":[" raise ","msg call ","Proc  === "," _assertions ","msg call  call "]}," MiniTest Assertions _assertions":{"type":"method","name":"_assertions","children":[],"call":[]}," MiniTest Assertions _assertions=":{"type":"method","name":"_assertions=","children":[],"call":[]}," MiniTest Assertions mu_pp":{"type":"method","name":"mu_pp","children":[],"call":["s force_encoding ","Encoding  default_external ","obj inspect ","s encode ","s force_encoding  force_encoding ","obj inspect  force_encoding ","s encode  force_encoding ","obj ins force_encoding pect ","obj inobj inspect pect ","obj ins encode pect ","s force_encoding  encode ","obj inspect  encode ","s encode  encode "]}," MiniTest filter_backtrace":{"type":"method","name":"filter_backtrace","children":[],"call":[]}," Spec it":{"type":"method","name":"it","children":[],"call":[]}," Spec after":{"type":"method","name":"after","children":[],"call":[]}," Spec before":{"type":"method","name":"before","children":[],"call":[]}," Spec initialize":{"type":"method","name":"initialize","children":[],"call":["Thread  current []= ","Thread  current "]}," Spec current":{"type":"method","name":"current","children":[],"call":[]}," Kernel describe":{"type":"method","name":"describe","children":[],"call":["cls class_eval ","Object  const_set ","(send\n  (send\n    (send\n      (lvar :desc) :to_s) :split\n    (regexp\n      (str \"\\\\W+\")\n      (regopt))) :map) join ","s capitalize ","desc to_s split map ","desc to_s split ","desc to_s ","Class  new ","stack pop ","stack push ","cls nuke_test_methods! ","Object  class_eval ","stack last ","(send\n  (send\n    (send\n      (lvar :desc) :to_s) :split\n    (regexp\n      (str \"\\\\W+\")\n      (regopt))) :map) join + ","MiniTest Spec  describe_stack ","prev == ","(sclass\n  (lvar :cls)\n  (self)) send ","(send\n  (lvar :stack) :last) compact join ","(send\n  (lvar :stack) :last) compact ","sclas children << ","sclas children ","cls == ","MiniTest Spec  spec_type "," < ","Class  === ","sclas create "," is_a? ","Minitest Spec  spec_type ","Minitest Spec  describe_stack "," kind_of? ","Class  new  class_eval ","Object  class_eval  class_eval ","sclas create  class_eval ","MiniTest Spec  describe_stack  pop ","Minitest Spec  describe_stack  pop ","MiniTest Spec  describe_stack  push ","Minitest Spec  describe_stack  push ","Class  new  nuke_test_methods! ","Object  class_eval  nuke_test_methods! ","sclas create  nuke_test_methods! ","MiniTest Spec  describe_stack  last ","Minitest Spec  describe_stack  last ","MiniTest Spec  describe_MiniTest Spec  describe_stack  ","MiniTest Spec  describe_Minitest Spec  describe_stack  ","stack last  == ","(sclass\n  (lvar :Class  new )\n  (self)) send ","(sclass\n  (lvar :Object  class_eval )\n  (self)) send ","(sclass\n  (lvar :sclas create )\n  (self)) send ","(send\n  (lvar :MiniTest Spec  describe_stack ) :last) compact join ","(send\n  (lvar :Minitest Spec  describe_stack ) :last) compact join ","(send\n  (lvar :MiniTest Spec  describe_stack ) :last) compact ","(send\n  (lvar :Minitest Spec  describe_stack ) :last) compact ","Class  new  == ","Object  class_eval  == ","sclas create  == ","Minitest Spec  describe_MiniTest Spec  describe_stack  ","Minitest Spec  describe_Minitest Spec  describe_stack  "]}," Module infect_with_assertions":{"type":"method","name":"infect_with_assertions","children":[],"call":[" class_eval ","new_name sub! ","new_name =~ ","map find ","meth sub ","neg_prefix to_s ","pos_prefix to_s ","meth to_s ","MiniTest Assertions  public_instance_methods each ","MiniTest Assertions  public_instance_methods "," infect_an_assertion "," puts ","$0 == ","MiniTest Assertions  public_instance_methods sort each ","MiniTest Assertions  public_instance_methods sort "," abort ","meth to_s  sub ","meth to_s  to_s ","MiniTest Assertions  public_instance_meth to_s ods each ","MiniTest Assertions  public_instance_meth to_s ods ","MiniTest Assertions  public_instance_meth to_s ods sort each ","MiniTest Assertions  public_instance_meth to_s ods sort "]}," MiniTest Mock verify":{"type":"method","name":"verify","children":[],"call":[" raise ","@actual_calls [] include? ","@actual_calls [] ","@actual_calls has_key? ","expected inspect ","@expected_calls [] ","@expected_calls each_key ","@actual_calls [] include? ! ","@actual_calls [] inspect ","calls each ","@expected_calls each "," call "," __call ","@expected_calls []  inspect ","@@expected_calls [] _calls [] ","@@expected_calls [] _calls each_key ","@@expected_calls [] _calls each "]}," MiniTest Mock expect":{"type":"method","name":"expect","children":[],"call":["@actual_calls [] << ","@actual_calls [] "," raise ","@expected_calls [] [] size == ","x size ","@expected_calls [] [] size ","@expected_calls [] [] ","@expected_calls [] "," class __send__ "," class ","@expected_calls []= "," respond_to? ","@expected_calls [] << ","Array  === ","args empty? "," block_given? "]}," MiniTest Mock initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","Hash  new ","calls []= "]}," Spec define_inheritable_method":{"type":"method","name":"define_inheritable_method","children":[],"call":[]}," Spec nuke_test_methods!":{"type":"method","name":"nuke_test_methods!","children":[],"call":[]}," Spec describe_stack":{"type":"method","name":"describe_stack","children":[],"call":[]}," TestCase inherited":{"type":"method","name":"inherited","children":[],"call":[]}," MiniTest Unit status":{"type":"method","name":"status","children":[],"call":["io puts ","format % "," skips "," errors "," failures "," assertion_count "," test_count "]}," Module infect_an_assertion":{"type":"method","name":"infect_an_assertion","children":[],"call":[" class_eval ","dont_flip ! ! ","dont_flip ! ","Minitest Expectation  class_eval ","15 + ","9 + ","dont_flip == ","18 + ","19 + ","10 + ","24 + ","14 + ","ruby2_keywords %p % "," respond_to? ","12 + "]}," Test Unit TestCase inherited":{"type":"method","name":"inherited","children":[],"call":[]}," MiniTest Unit process_args":{"type":"method","name":"process_args","children":[],"call":["opts parse ","options []= ","opts on ","m to_i "," exit "," puts ","opts version= ","opts banner= ","OptionParser  new ","(send\n  (lvar :orig_args) :map) join ","s inspect ","s =~ ","orig_args map "," verbose= ","options [] "," srand ","orig_args << << ","options [] to_s ","orig_args << "," srand % ","opts parse! ","args dup ","(send\n  (lvar :args dup ) :map) join ","args dup  map ","args dup  << << ","args dup  << "]}," Module classes":{"type":"method","name":"classes","children":[],"call":["(send\n  (block\n    (send\n      (send nil :constants) :map)\n    (args\n      (arg :n))\n    (send nil :const_get\n      (lvar :n))) :find_all) - ","type > ","c class == ","c class ","(send\n  (send nil :constants) :map) find_all "," const_get "," constants map "," constants "]}," MiniTest Assertions assert_silent":{"type":"method","name":"assert_silent","children":[],"call":[" assert_output "]}," MiniTest Assertions assert_output":{"type":"method","name":"assert_output","children":[],"call":["stderr ! ","stdout ! "," assert_equal "," capture_io "," send ","Regexp  === ","Rege assert_equal p  === ","Rege send p  === "]}," MiniTest Unit TestCase io?":{"type":"method","name":"io?","children":[],"call":[]}," MiniTest Unit TestCase io":{"type":"method","name":"io","children":[],"call":["MiniTest Unit  output "]}," MiniTest Unit run_tests":{"type":"method","name":"run_tests","children":[],"call":[" _run_anything "]}," MiniTest Unit _run_suite":{"type":"method","name":"_run_suite","children":[],"call":["sum + ","assertions inject ","assertions size ","inst _assertions "," puts "," print ","(begin\n  (lvar :suite)) % ","Time  now - ","Time  now ","inst run ","inst _assertions= ","suite new ","suite send grep map ","suite send grep ","suite send ","Regexp  new ","filter =~ "," options [] "," options "," send "," respond_to? ","%.2f s =  % "," record "," last_error "," last_error= ","filtered_test_methods map ","filter === ","all_test_methods find_all ","suite new  _assertions ","suite new  run ","suite new  _assertions= ","Regexp  new  =~ ","Regexp  new ed_test_methods map ","Regexp  new  === ","suite send  find_all "]}," MiniTest Unit _run_suites":{"type":"method","name":"_run_suites","children":[],"call":[" _run_suite ","suites map ","(send\n  (send\n    (const nil :ParallelEach) :new\n    (lvar :parallel)) :map) + ","serial map ","ParallelEach  new map ","ParallelEach  new ","s test_order == ","s test_order ","suites partition "]}," MiniTest Unit _run_anything":{"type":"method","name":"_run_anything","children":[],"call":[" status "," puts ","\n%3d) %s % ","i + "," report each_with_index "," report ","(str \"Finished \") % "," assertion_count / "," assertion_count "," test_count / "," test_count ","Time  now - ","Time  now "," output sync= "," output ","sum + ","results inject "," _run_suites "," output sync "," output respond_to? ","suites empty? ","TestCase  send "," sTime  now - aTime  now - us "," puTime  now - s "," reporTime  now -  each_wiTime  now - h_index "," reporTime  now -  ","(sTime  now - r \"Finished \") % "," asserTime  now - ion_counTime  now -  / "," asserTime  now - ion_counTime  now -  "," Time  now - esTime  now - _counTime  now -  / "," Time  now - esTime  now - _counTime  now -  "," ouTime  now - puTime  now -  sync= "," output  output respond_to? = "," ouTime  now - puTime  now -  ","resulTime  now - s injecTime  now -  "," _run_suites  inject "," _run_suiTime  now - es "," _run_TestCase  send  "," ouTime  now - puTime  now -  sync "," output  output respond_to?  "," ouTime  now - puTime  now -  respond_Time  now - o? ","suiTime  now - es empTime  now - y? ","TestCase  send  empty? ","TesTime  now - Case  send "]}," MiniTest Unit print":{"type":"method","name":"print","children":[],"call":[" output print "," output "]}," MiniTest Unit puts":{"type":"method","name":"puts","children":[],"call":[" output puts "," output "]}," MiniTest Unit output":{"type":"method","name":"output","children":[],"call":[" class output "," class "]}," MiniTest Unit plugins":{"type":"method","name":"plugins","children":[],"call":[]}," MiniTest Unit out":{"type":"method","name":"out","children":[],"call":[]}," MiniTest Unit after_tests":{"type":"method","name":"after_tests","children":[],"call":[]}," PrideIO method_missing":{"type":"method","name":"method_missing","children":[],"call":[" io send "," io "]}," PrideIO print":{"type":"method","name":"print","children":[],"call":[" io print "," io ","@chars next ","@colors next "," pride ","@colors [] ","@index % "]}," PrideIO initialize":{"type":"method","name":"initialize","children":[],"call":["CHARS  cycle ","COLORS  cycle ","@colors size ","(irange\n  (int 31)\n  (int 36)) to_a ","COLORS  cycle  size ","(irange\n  (int 31)\n  (int 36)) to_a  size "]}," MiniTest Mock respond_to?":{"type":"method","name":"respond_to?","children":[],"call":[" original_respond_to? ","@expected_calls has_key? "," __respond_to? ","sym to_sym "]}," MiniTest Mock method_missing":{"type":"method","name":"method_missing","children":[],"call":["@actual_calls [] << ","@actual_calls [] ","@expected_calls [] [] ","@expected_calls [] "," raise ","@expected_calls [] [] size == ","args size ","@expected_calls [] [] size ","@expected_calls has_key? ","mod === ","expected_args zip map ","expected_args zip ","mocked method %p expects %d arguments, got %d % ","expected [] size ","expected [] ","expected_args size == ","expected_args size ","unmocked method %p, expected one of %p % ","@expected_calls keys sort_by ","@expected_calls keys ","expected_call [] ","mocked method %p called with unexpected arguments %p % ","mod == ","call [] zip all? ","call [] zip ","call [] ","expected_calls find ","mocked method %p expects %s arguments, got %d % ","arg_sizes join ","(send\n  (send\n    (ivar :@expected_calls) :[]\n    (lvar :sym)) :map) uniq sort ","(send\n  (send\n    (ivar :@expected_calls) :[]\n    (lvar :sym)) :map) uniq ","call [] size ","@expected_calls [] map ","expected_calls empty? ","call [] size == ","@expected_calls [] select ","a === ","args [] ","@expected_calls [] [] each_with_index map ","@expected_calls [] [] each_with_index ","mocked method '%s' expects %d arguments, got %d % ","unmocked method '%s', expected one of %s % ","(send\n  (send\n    (ivar :@expected_calls) :keys) :map) sort join ","(send\n  (send\n    (ivar :@expected_calls) :keys) :map) sort ","@expected_calls keys map ","expected_args zip all? ","expected_args size != ","No more expects available for %p: %p % ","@actual_calls [] length ","mocked method %p failed block w/ %p % ","val_block call ","expected_call values_at ","@@expected_calls [] _calls [] [] ","@@expected_calls [] [] s [] [] ","@@expected_calls [] _calls [] ","@@expected_calls [] [] s [] ","@@expected_calls [] _calls [] [] size == ","@@expected_calls [] [] s [] [] size == ","@@expected_calls [] _calls [] [] size ","@@expected_calls [] [] s [] [] size ","@@expected_calls [] _calls has_key? ","@@expected_calls [] [] s has_key? ","@expected_calls [] _args zip map ","@expected_calls [] _args zip ","@expected_calls []  [] size ","@expected_calls []  [] ","@expected_calls [] _args size == ","@expected_calls [] _args size ","unmocked method %p, @expected_calls []  one of %p % ","@@expected_calls [] _calls keys sort_by ","@@expected_calls [] [] s keys sort_by ","@@expected_calls [] _calls keys ","@@expected_calls [] [] s keys ","@expected_calls [] _call [] ","@expected_calls [] []  [] ","mocked method %p called with un@expected_calls []  arguments %p % ","@expected_calls [] _calls find ","@expected_calls [] [] s find ","(send\n  (send\n    (ivar :@expected_calls) :[]\n    (lvar :sym)) :map) uniq sort  join ","(send\n  (send\n    (ivar :@@expected_calls [] _calls) :[]\n    (lvar :sym)) :map) uniq sort ","(send\n  (send\n    (ivar :@@expected_calls [] [] s) :[]\n    (lvar :sym)) :map) uniq sort ","(send\n  (send\n    (ivar :@@expected_calls [] _calls) :[]\n    (lvar :sym)) :map) uniq ","(send\n  (send\n    (ivar :@@expected_calls [] [] s) :[]\n    (lvar :sym)) :map) uniq ","@@expected_calls [] _calls [] map ","@@expected_calls [] [] s [] map ","@expected_calls [] _calls empty? ","@expected_calls [] [] s empty? ","@@expected_calls [] _calls [] select ","@@expected_calls [] [] s [] select ","@@expected_calls [] _calls [] [] each_with_index map ","@@expected_calls [] [] s [] [] each_with_index map ","@expected_calls [] [] each_with_@actual_calls [] length  map ","@@expected_calls [] _calls [] [] each_with_index ","@@expected_calls [] [] s [] [] each_with_index ","@expected_calls [] [] each_with_@actual_calls [] length  ","unmocked method '%s', @expected_calls []  one of %s % ","(send\n  (send\n    (ivar :@@expected_calls [] _calls) :keys) :map) sort join ","(send\n  (send\n    (ivar :@@expected_calls [] [] s) :keys) :map) sort join ","(send\n  (send\n    (ivar :@@expected_calls [] _calls) :keys) :map) sort ","(send\n  (send\n    (ivar :@@expected_calls [] [] s) :keys) :map) sort ","@@expected_calls [] _calls keys map ","@@expected_calls [] [] s keys map ","@expected_calls [] _args zip all? ","@expected_calls [] _args size != ","@expected_calls [] _call values_at ","@expected_calls [] []  values_at "]}," Spec bench_performance_exponential":{"type":"method","name":"bench_performance_exponential","children":[],"call":[]}," Spec bench_performance_constant":{"type":"method","name":"bench_performance_constant","children":[],"call":[]}," Spec bench_performance_linear":{"type":"method","name":"bench_performance_linear","children":[],"call":[]}," Spec bench_range":{"type":"method","name":"bench_range","children":[],"call":[]}," Spec bench":{"type":"method","name":"bench","children":[],"call":[]}," Unit TestCase validation_for_fit":{"type":"method","name":"validation_for_fit","children":[],"call":[" assert_operator "," send "," proc "]}," Unit TestCase sigma":{"type":"method","name":"sigma","children":[],"call":["sum + ","enum inject ","enum map ","enum map  inject ","enum map  map "]}," Unit TestCase fit_power":{"type":"method","name":"fit_power","children":[],"call":["Math  exp * ","x ** ","Math  exp "," fit_error ","(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / ","slny - ","b * ","(send\n  (send\n    (lvar :n) :*\n    (lvar :slnxlny)) :-\n  (send\n    (lvar :slnx) :*\n    (lvar :slny))) / ","n * - ","slnx ** ","n * ","slnx * ","Math  log ** ","Math  log "," sigma ","Math  log * ","xs zip ","xs size ","M(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  exp * ","M(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  exp ","(send\n  (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slny) :-\n  (send\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :b) :*\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slnx))) / ","(send\n  (lvar :slny) :-\n  (send\n    (lvar :(send\n  (send\n    (lvar :n) :*\n    (lvar :slnxlny)) :-\n  (send\n    (lvar :slnx) :*\n    (lvar :slny))) / ) :*\n    (lvar :slnx))) / ","(sexs size d\n  (lvar :slxs size y) :-\n  (sexs size d\n    (lvar :b) :*\n    (lvar :slxs size x))) / ","slxs size y - ","(send\n  (send\n    (lvar :n) :*\n    (lvar :slnxlny)) :-\n  (send\n    (lvar :slnx) :*\n    (lvar :slny))) /  * ","(send\n  (send\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :n) :*\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slnxlny)) :-\n  (send\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slnx) :*\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slny))) / ","(sexs size d\n  (sexs size d\n    (lvar :xs size ) :*\n    (lvar :slxs size xlxs size y)) :-\n  (sexs size d\n    (lvar :slxs size x) :*\n    (lvar :slxs size y))) / ","xs size  * - ","slxs size x ** ","xs size  * ","slxs size x * ","M(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  log ** ","M(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  log "," sigm(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) /  ","M(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  log * "]}," Unit TestCase fit_linear":{"type":"method","name":"fit_linear","children":[],"call":["a + ","b * "," fit_error ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sxy)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sy))) / ","n * - ","sx * ","n * ","(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / ","sy * - ","sy * ","sx ** ","x * "," sigma ","x ** ","xs zip ","xs size ","(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) /  + ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sxy)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sy))) /  * ","(send\n  (send\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :n) :*\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sxy)) :-\n  (send\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sx) :*\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sy))) / ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sxy)) :-\n  (send\n    (lvar :sx) :*\n    (lvar : sigma ))) / ","(send\n  (send\n    (lvar :n) :*\n    (lvar : sigma y)) :-\n  (send\n    (lvar : sigma ) :*\n    (lvar :sy))) / ","(sexs size d\n  (sexs size d\n    (lvar :xs size ) :*\n    (lvar :sxy)) :-\n  (sexs size d\n    (lvar :sx) :*\n    (lvar :sy))) / ","xs size  * - "," sigma  * ","xs size  * ","(send\n  (send\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sy) :*\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sx2)) :-\n  (send\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sx) :*\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sxy))) / ","(send\n  (send\n    (lvar : sigma ) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / ","(send\n  (send\n    (lvar :sy) :*\n    (lvar : sigma 2)) :-\n  (send\n    (lvar : sigma ) :*\n    (lvar : sigma y))) / ","(sexs size d\n  (sexs size d\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (sexs size d\n    (lvar :sx) :*\n    (lvar :sxy))) / "," sigma  * - "," sigma  ** "," sigm(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) /  "]}," Unit TestCase fit_exponential":{"type":"method","name":"fit_exponential","children":[],"call":["Math  exp ","a + ","b * "," fit_error ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sxlny)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :slny))) / ","n * - ","sx * ","n * ","(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / ","slny * - ","slny * ","sx ** "," sigma ","x * ","Math  log ","xs zip ","xs size ","M(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / th  exp ","(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) /  + ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sxlny)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :slny))) /  * ","(send\n  (send\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :n) :*\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :sxlny)) :-\n  (send\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :sx) :*\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :slny))) / ","(send\n  (send\n    (lvar :n) :*\n    (lvar : sigma lny)) :-\n  (send\n    (lvar : sigma ) :*\n    (lvar :slny))) / ","(sexs size d\n  (sexs size d\n    (lvar :xs size ) :*\n    (lvar :sxlxs size y)) :-\n  (sexs size d\n    (lvar :sx) :*\n    (lvar :slxs size y))) / ","xs size  * - "," sigma  * ","xs size  * ","(send\n  (send\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :slny) :*\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :sx2)) :-\n  (send\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :sx) :*\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :sxlny))) / ","(send\n  (send\n    (lvar :slny) :*\n    (lvar : sigma 2)) :-\n  (send\n    (lvar : sigma ) :*\n    (lvar : sigma lny))) / ","(sexs size d\n  (sexs size d\n    (lvar :slxs size y) :*\n    (lvar :sx2)) :-\n  (sexs size d\n    (lvar :sx) :*\n    (lvar :sxlxs size y))) / ","slxs size y * - ","slxs size y * "," sigma  ** "," sigm(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) /  ","M(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / th  log "]}," Unit TestCase fit_error":{"type":"method","name":"fit_error","children":[],"call":["1 - ","ss_err / ","(send\n  (yield\n    (lvar :x)) :-\n  (lvar :y)) ** ","(lvar :x) - "," sigma ","(send\n  (lvar :y) :-\n  (lvar :y_bar)) ** ","y - ","(send nil :sigma\n  (lvar :xys)) / ","xys size to_f ","xys size ","(send\n  (lvar :y) :-\n  (lvar :(send nil :sigma\n  (lvar :xys)) / )) ** "]}," Unit TestCase assert_performance_power":{"type":"method","name":"assert_performance_power","children":[],"call":[" assert_performance "," validation_for_fit "]}," Unit TestCase assert_performance_linear":{"type":"method","name":"assert_performance_linear","children":[],"call":[" assert_performance "," validation_for_fit "]}," Unit TestCase assert_performance_exponential":{"type":"method","name":"assert_performance_exponential","children":[],"call":[" assert_performance "," validation_for_fit "]}," Unit TestCase assert_performance_constant":{"type":"method","name":"assert_performance_constant","children":[],"call":[" assert_performance "," assert_in_delta ","1 - "," fit_linear "," proc "]}," Unit TestCase assert_performance":{"type":"method","name":"assert_performance","children":[],"call":["validation [] "," io puts "," io ","times << "," io print ","\t%9.6f % ","Time  now - ","Time  now "," instance_exec ","GC  start ","range each "," __name__ "," class bench_range "," class ","validaTime  now - ion [] "," io puTime  now - s ","Time  now - imes << "," io prinTime  now -  "," insTime  now - ance_exec ","GC  sTime  now - arTime  now -  "," class bench_range  each "," class bench_ class bench_range  "]}," Unit TestCase bench_range":{"type":"method","name":"bench_range","children":[],"call":[]}," Unit TestCase benchmark_suites":{"type":"method","name":"benchmark_suites","children":[],"call":[]}," Unit TestCase benchmark_methods":{"type":"method","name":"benchmark_methods","children":[],"call":[]}," Unit TestCase bench_linear":{"type":"method","name":"bench_linear","children":[],"call":[]}," Unit TestCase bench_exp":{"type":"method","name":"bench_exp","children":[],"call":[]}," Unit benchmark_suite_header":{"type":"method","name":"benchmark_suite_header","children":[],"call":["suite bench_range join ","suite bench_range "]}," Unit run_benchmarks":{"type":"method","name":"run_benchmarks","children":[],"call":[" _run_anything "]}," MiniTest Unit options":{"type":"method","name":"options","children":[],"call":[]}," MiniTest Unit _run":{"type":"method","name":"_run","children":[],"call":[" abort "," failures + "," errors "," failures ","@test_count > "," report empty? "," report "," send "," class plugins each "," class plugins "," class "," puts "," help "," options= "," process_args "," options merge! "," options "," test_count > "," test_count "," process_ process_args  "]}," MiniTest Unit runner":{"type":"method","name":"runner","children":[],"call":[]}," MiniTest Unit runner=":{"type":"method","name":"runner=","children":[],"call":[]}," Spec children":{"type":"method","name":"children","children":[],"call":[]}," Spec spec_type":{"type":"method","name":"spec_type","children":[],"call":[]}," Spec register_spec_type":{"type":"method","name":"register_spec_type","children":[],"call":[]}," MiniTest Unit TestCase run_teardown_hooks":{"type":"method","name":"run_teardown_hooks","children":[],"call":["hook call ","hook arity == ","hook arity ","hook respond_to? "," class teardown_hooks reverse each "," class teardown_hooks reverse "," class teardown_hooks "," class "]}," MiniTest Unit TestCase teardown_hooks":{"type":"method","name":"teardown_hooks","children":[],"call":[]}," MiniTest Unit TestCase add_teardown_hook":{"type":"method","name":"add_teardown_hook","children":[],"call":[]}," MiniTest Unit TestCase run_setup_hooks":{"type":"method","name":"run_setup_hooks","children":[],"call":["hook call ","hook arity == ","hook arity ","hook respond_to? "," class setup_hooks each "," class setup_hooks "," class "]}," MiniTest Unit TestCase setup_hooks":{"type":"method","name":"setup_hooks","children":[],"call":[]}," MiniTest Unit TestCase add_setup_hook":{"type":"method","name":"add_setup_hook","children":[],"call":[]}," MiniTest Unit TestCase reset_setup_teardown_hooks":{"type":"method","name":"reset_setup_teardown_hooks","children":[],"call":[]}," MiniTest Unit TestCase i_suck_and_my_tests_are_order_dependent!":{"type":"method","name":"i_suck_and_my_tests_are_order_dependent!","children":[],"call":[]}," MiniTest Unit TestCase current":{"type":"method","name":"current","children":[],"call":[]}," MiniTest Unit Guard windows?":{"type":"method","name":"windows?","children":[],"call":[]}," MiniTest Unit Guard rubinius?":{"type":"method","name":"rubinius?","children":[],"call":["rbx == "]}," MiniTest Unit Guard mri?":{"type":"method","name":"mri?","children":[],"call":[]}," MiniTest Unit Guard jruby?":{"type":"method","name":"jruby?","children":[],"call":["java == "]}," MiniTest Assertions refute_predicate":{"type":"method","name":"refute_predicate","children":[],"call":[" refute ","o1 __send__ "," mu_pp "," message "]}," MiniTest Assertions assert_predicate":{"type":"method","name":"assert_predicate","children":[],"call":[" assert ","o1 __send__ "," mu_pp "," message "]}," MiniTest Assertions mu_pp_for_diff":{"type":"method","name":"mu_pp_for_diff","children":[],"call":[" mu_pp gsub gsub "," mu_pp gsub "," mu_pp "]}," MiniTest Assertions diff":{"type":"method","name":"diff","children":[],"call":["(str \"No visible difference.\") join ","exp class ","result empty? ","result sub! ","b path ","a path ","MiniTest Assertions  diff ","b flush ","b puts ","Tempfile  open ","a flush ","a puts "," mu_pp ","expect == ","butwas size > ","butwas size ","expect size > ","expect size ","butwas include? ","expect include? "," mu_pp_for_diff "," require ","b rewind ","a rewind ","(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :klass))\n  (str \"#inspect output.\")) join ","(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :klass))\n  (str \"#inspect output.\\n\")) join ","(str \"No visible difference.\") join  empty? ","(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :klass))\n  (str \"#inspect output.\")) join  empty? ","(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :klass))\n  (str \"#inspect output.\\n\")) join  empty? ","(str \"No visible difference.\") join  sub! ","(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :klass))\n  (str \"#inspect output.\")) join  sub! ","(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :klass))\n  (str \"#inspect output.\\n\")) join  sub! "," mu_pp_for_diff  == "," mu_pp_for_diff  size > "," mu_pp_for_diff  size "," mu_pp_for_diff  include? ","(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :exp class ))\n  (str \"#inspect output.\")) join ","(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :exp class ))\n  (str \"#inspect output.\\n\")) join "]}," MiniTest Assertions diff=":{"type":"method","name":"diff=","children":[],"call":[]}," MiniTest Assertions inspect":{"type":"method","name":"inspect","children":[],"call":[]}," MiniTest const_missing":{"type":"method","name":"const_missing","children":[],"call":[]}," Spec to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Spec create":{"type":"method","name":"create","children":[],"call":[]}," Spec subject":{"type":"method","name":"subject","children":[],"call":[]}," Spec let":{"type":"method","name":"let","children":[],"call":[]}," PrideLOL pride":{"type":"method","name":"pride","children":[],"call":["@colors [] ","@index % ","@@colors [] olors [] "]}," PrideLOL initialize":{"type":"method","name":"initialize","children":[],"call":["36 * + + + ","36 * + + ","36 * + ","6 * ","36 * ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lvar :n) :+\n        (send\n          (int 4) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i ","3 * + ","3 * ","Math  sin ","n + ","4 * ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lvar :n) :+\n        (send\n          (int 2) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i ","2 * ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lvar :n))) :+\n  (int 3)) to_i ","1.0 / ","(erange\n  (int 0)\n  (begin\n    (send\n      (int 6) :*\n      (int 7)))) map ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lva(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lvar :n))) :+\n  (int 3)) to_i  :n) :+\n        (send\n          (int 4) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lva(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lvar :n))) :+\n  (int 3)) to_i  :n) :+\n        (send\n          (int 2) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lva(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lvar :n))) :+\n  (int 3)) to_i  :n))) :+\n  (int 3)) to_i ","(erange\n  (int 0)\n  ((send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lvar :n) :+\n        (send\n          (int 4) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i egin\n    (send\n      (int 6) :*\n      (int 7)))) map ","(eran(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lvar :n) :+\n        (send\n          (int 2) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i e\n  (int 0)\n  (be(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lvar :n) :+\n        (send\n          (int 2) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i in\n    (send\n      (int 6) :*\n      (int 7)))) map ","(e(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lvar :n))) :+\n  (int 3)) to_i ange\n  (int 0)\n  (begin\n    (send\n      (int 6) :*\n      (int 7)))) map "]}," PrideIO pride":{"type":"method","name":"pride","children":[],"call":["@colors [] ","@index % ","string == ","@@colors [] olors [] "]}," PrideIO puts":{"type":"method","name":"puts","children":[],"call":["(send\n  (send\n    (str \"Fabulous tests\") :split\n    (regexp\n      (regopt))) :map) join "," pride ","Fabulous tests split map ","Fabulous tests split ","s sub ","o map! ","s to_s sub ","s to_s "]}," Minitest define_minitest_tasks":{"type":"method","name":"define_minitest_tasks","children":[],"call":[" test_prelude= "," testlib= ","ENV  [] "," name == "," name "," minitest? "]}," Minitest initialize_minitest":{"type":"method","name":"initialize_minitest","children":[],"call":[" dependency "," name == "," name ","MiniTest Unit VERSION  split first join ","MiniTest Unit VERSION  split first ","MiniTest Unit VERSION  split "," require "," gem "," extra_dev_deps << "," extra_dev_deps ","ENV  [] ","Minitest VERSION  split first join ","Minitest VERSION  split first ","Minitest VERSION  split ","Hoe  add_include_dirs ","File  directory? "," minitest? "]}," MiniTest Unit TestCase after_teardown":{"type":"method","name":"after_teardown","children":[],"call":[]}," MiniTest Unit TestCase before_teardown":{"type":"method","name":"before_teardown","children":[],"call":[]}," MiniTest Unit TestCase before_setup":{"type":"method","name":"before_setup","children":[],"call":[]}," MiniTest Unit TestCase after_setup":{"type":"method","name":"after_setup","children":[],"call":[]}," Spec before_teardown":{"type":"method","name":"before_teardown","children":[],"call":[" run_teardown_hooks "]}," Spec after_setup":{"type":"method","name":"after_setup","children":[],"call":[" run_setup_hooks "]}," MiniTest Unit record":{"type":"method","name":"record","children":[],"call":[]}," TestCase test_methods":{"type":"method","name":"test_methods","children":[],"call":[" old_test_methods "," load_excludes "]}," TestCase load_excludes":{"type":"method","name":"load_excludes","children":[],"call":[]}," TestCase exclude":{"type":"method","name":"exclude","children":[],"call":[]}," Object stub":{"type":"method","name":"stub","children":[],"call":["metaclass send ","val_or_callable call ","val_or_callable respond_to? "," methods map include? ! "," methods map include? ","name to_s "," methods map "," methods "," respond_to? "," class == "," class ","blk call ","metaclass respond_to? ","block_kwargs empty? ","kwargs empty? ","block [] ","ENV  [] "]}," MiniTest Mock call":{"type":"method","name":"call","children":[],"call":["(send\n  (lvar :data) :map) join "," call ","data map ","data [] inspect ","data [] ","data [] inspect [] "]}," MiniTest Mock __call":{"type":"method","name":"__call","children":[],"call":["(send\n  (lvar :data) :map) join "," __call ","data map ","data [] inspect ","data [] ","data [] inspect [] "]}," MiniTest Unit Deprecated Hooks run_teardown_hooks":{"type":"method","name":"run_teardown_hooks","children":[],"call":[" _run_hooks "," class teardown_hooks reverse "," class teardown_hooks "," class "]}," MiniTest Unit Deprecated Hooks teardown_hooks":{"type":"method","name":"teardown_hooks","children":[],"call":[]}," MiniTest Unit Deprecated Hooks add_teardown_hook":{"type":"method","name":"add_teardown_hook","children":[],"call":[]}," MiniTest Unit Deprecated Hooks _run_hooks":{"type":"method","name":"_run_hooks","children":[],"call":["hook call ","hook arity == ","hook arity ","hook respond_to? ","hooks each "]}," MiniTest Unit Deprecated Hooks run_setup_hooks":{"type":"method","name":"run_setup_hooks","children":[],"call":[" _run_hooks "," class setup_hooks "," class "]}," MiniTest Unit Deprecated Hooks setup_hooks":{"type":"method","name":"setup_hooks","children":[],"call":[]}," MiniTest Unit Deprecated Hooks add_setup_hook":{"type":"method","name":"add_setup_hook","children":[],"call":[]}," MiniTest Unit LifecycleHooks after_teardown":{"type":"method","name":"after_teardown","children":[],"call":[]}," MiniTest Unit LifecycleHooks before_teardown":{"type":"method","name":"before_teardown","children":[],"call":[]}," MiniTest Unit LifecycleHooks before_setup":{"type":"method","name":"before_setup","children":[],"call":[]}," MiniTest Unit LifecycleHooks after_setup":{"type":"method","name":"after_setup","children":[],"call":[]}," MiniTest Assertions capture_subprocess_io":{"type":"method","name":"capture_subprocess_io","children":[],"call":["$stderr reopen ","$stdout reopen ","captured_stderr unlink ","captured_stdout unlink ","captured_stderr read ","captured_stdout read ","$stderr rewind ","$stdout rewind ","$stderr dup ","$stdout dup ","Tempfile  new "," require "," synchronize "]}," MiniTest Unit Deprecated HooksCM teardown_hooks":{"type":"method","name":"teardown_hooks","children":[],"call":["(send\n  (send nil :superclass) :respond_to?\n  (sym :teardown_hooks)) + "," superclass teardown_hooks "," superclass "," superclass respond_to? "]}," MiniTest Unit Deprecated HooksCM add_teardown_hook":{"type":"method","name":"add_teardown_hook","children":[],"call":["@teardown_hooks << "," warn "," caller first "," caller "]}," MiniTest Unit Deprecated HooksCM setup_hooks":{"type":"method","name":"setup_hooks","children":[],"call":["(send\n  (send nil :superclass) :respond_to?\n  (sym :setup_hooks)) + "," superclass setup_hooks "," superclass "," superclass respond_to? "]}," MiniTest Unit Deprecated HooksCM add_setup_hook":{"type":"method","name":"add_setup_hook","children":[],"call":["@setup_hooks << "," warn "," caller first "," caller "]}," MiniTest BacktraceFilter filter":{"type":"method","name":"filter","children":[],"call":["bt dup ","new_bt empty? ","line =~ ","bt reject ","new_bt << ","bt each ","bt dup  empty? ","bt dup  << "]}," MiniTest Unit TestCase parallelize_me!":{"type":"method","name":"parallelize_me!","children":[],"call":[]}," MiniTest Unit TestCase make_my_diffs_pretty!":{"type":"method","name":"make_my_diffs_pretty!","children":[],"call":[]}," MiniTest Unit synchronize":{"type":"method","name":"synchronize","children":[],"call":["@mutex synchronize "]}," MiniTest Assertions synchronize":{"type":"method","name":"synchronize","children":[],"call":["Minitest Unit  runner synchronize ","Minitest Unit  runner "]}," ParallelEach each":{"type":"method","name":"each","children":[],"call":["threads map ","@queue pop ","Thread  current abort_on_exception= ","Thread  current ","Thread  new ","N  times map ","N  times "]}," ParallelEach grep":{"type":"method","name":"grep","children":[],"call":[" class new "," class "]}," ParallelEach initialize":{"type":"method","name":"initialize","children":[],"call":["@queue << ","N  times ","list each ","Queue  new ","Queue  new  << "]}," TestCase test_order":{"type":"method","name":"test_order","children":[],"call":[]}," Unit TestCase fit_logarithmic":{"type":"method","name":"fit_logarithmic","children":[],"call":["a + ","b * ","Math  log "," fit_error ","(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / ","sy - ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sylnx)) :-\n  (send\n    (lvar :sy) :*\n    (lvar :slnx))) / ","n * - ","sy * ","n * ","slnx ** "," sigma ","y * ","Math  log ** ","xs zip ","xs size ","(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) /  + ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sylnx)) :-\n  (send\n    (lvar :sy) :*\n    (lvar :slnx))) /  * ","M(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  log ","(send\n  (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :sy) :-\n  (send\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :b) :*\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slnx))) / ","(send\n  (lvar :sy) :-\n  (send\n    (lvar :(send\n  (send\n    (lvar :n) :*\n    (lvar :sylnx)) :-\n  (send\n    (lvar :sy) :*\n    (lvar :slnx))) / ) :*\n    (lvar :slnx))) / ","(sexs size d\n  (lvar :sy) :-\n  (sexs size d\n    (lvar :b) :*\n    (lvar :slxs size x))) / ","(send\n  (send\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :n) :*\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :sylnx)) :-\n  (send\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :sy) :*\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slnx))) / ","(sexs size d\n  (sexs size d\n    (lvar :xs size ) :*\n    (lvar :sylxs size x)) :-\n  (sexs size d\n    (lvar :sy) :*\n    (lvar :slxs size x))) / ","xs size  * - ","xs size  * ","slxs size x ** "," sigm(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) /  ","M(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  log ** "]}," Unit TestCase assert_performance_logarithmic":{"type":"method","name":"assert_performance_logarithmic","children":[],"call":[" assert_performance "," validation_for_fit "]}," MiniTest Unit Guard maglev?":{"type":"method","name":"maglev?","children":[],"call":["maglev == "]}," MiniTest Assertions skipped?":{"type":"method","name":"skipped?","children":[],"call":[]}," Unit _run_suites":{"type":"method","name":"_run_suites","children":[],"call":["(send\n  (send\n    (const nil :ParallelEach) :new\n    (lvar :parallel)) :map) + "," _run_suite ","serial map ","ParallelEach  new map ","ParallelEach  new ","s test_order == ","s test_order ","suites partition "]}," ParallelEach select":{"type":"method","name":"select","children":[],"call":[" class new "," class "]}," Spec DSL to_s":{"type":"method","name":"to_s","children":[],"call":[" name "]}," Spec DSL name":{"type":"method","name":"name","children":[],"call":[]}," Spec DSL create":{"type":"method","name":"create","children":[],"call":[" children << "," children "," nuke_test_methods! ","Class  new "]}," Spec DSL subject":{"type":"method","name":"subject","children":[],"call":[" let "]}," Spec DSL let":{"type":"method","name":"let","children":[],"call":["@_memoized []= "," instance_eval ","@_memoized fetch "," define_method "," raise ","name to_s =~ ","name to_s ","methods include? ","name =~ ","Minitest Spec  instance_methods map - ","Minitest Spec  instance_methods map ","Minitest Spec  instance_methods ","(send\n  (send\n    (send nil :instance_methods) :map\n    (block-pass\n      (sym :to_s))) :-\n  (array\n    (str \"subject\"))) include? "," instance_methods map - "," instance_methods map "," instance_methods ","(send\n  (send\n    (send\n      (const\n        (const nil :Minitest) :Spec) :instance_methods) :map\n    (block-pass\n      (sym :to_s))) :-\n  (array\n    (str \"subject\"))) include? ","name to_s  to_s =~ ","name to_s  to_s ","Minitest Spec  instance_methods map -  include? ","name to_s  =~ ","Minitest Spec  instance_Minitest Spec  instance_methods map -  map - ","Minitest Spec  instance_Minitest Spec  instance_methods map -  map ","Minitest Spec  instance_Minitest Spec  instance_methods map -  ","(send\n  (send\n    (send nil :instance_Minitest Spec  instance_methods map - ) :map\n    (block-pass\n      (sym :to_s))) :-\n  (array\n    (str \"subject\"))) include? "," instance_Minitest Spec  instance_methods map -  map - "," instance_Minitest Spec  instance_methods map -  map "," instance_Minitest Spec  instance_methods map -  ","(send\n  (send\n    (send\n      (const\n        (const nil :Minitest) :Spec) :instance_Minitest Spec  instance_methods map - ) :map\n    (block-pass\n      (sym :to_s))) :-\n  (array\n    (str \"subject\"))) include? "]}," Spec DSL it":{"type":"method","name":"it","children":[],"call":["mod send ","mod public_method_defined? "," children each "," children "," define_method ","test_%04d_%s % "," skip "," proc ","undef_klass send ","undef_klasses each ","c public_method_defined? "," children reject "]}," Spec DSL after":{"type":"method","name":"after","children":[],"call":[" instance_eval "," define_method "]}," Spec DSL before":{"type":"method","name":"before","children":[],"call":[" instance_eval "," define_method "]}," Spec DSL nuke_test_methods!":{"type":"method","name":"nuke_test_methods!","children":[],"call":[" send "," public_instance_methods grep each "," public_instance_methods grep "," public_instance_methods "]}," Spec DSL children":{"type":"method","name":"children","children":[],"call":[]}," Spec DSL describe_stack":{"type":"method","name":"describe_stack","children":[],"call":["Thread  current [] ","Thread  current "]}," Spec DSL spec_type":{"type":"method","name":"spec_type","children":[],"call":["(send\n  (const nil :TYPES) :find) last ","matcher === ","desc to_s ","matcher call ","matcher respond_to? ","TYPES  find "]}," Spec DSL register_spec_type":{"type":"method","name":"register_spec_type","children":[],"call":["TYPES  unshift ","args first "]}," MiniTest Unit test_count":{"type":"method","name":"test_count","children":[],"call":[]}," ParallelEach count":{"type":"method","name":"count","children":[],"call":["(send\n  (send\n    (ivar :@queue) :size) :-\n  (const nil :N)) max ","@queue size - ","@queue size "]}," Minitest BacktraceFilter filter":{"type":"method","name":"filter","children":[],"call":["bt dup ","new_bt empty? ","line !~ ","bt select ","bt take_while ","ENV  [] ","bt dup  empty? "]}," Minitest Guard windows?":{"type":"method","name":"windows?","children":[],"call":[]}," Minitest Guard rubinius?":{"type":"method","name":"rubinius?","children":[],"call":["rbx == "," warn ","where split first ","where split ","Minitest  filter_backtrace first ","Minitest  filter_backtrace "," caller ","where split first  split first ","Minitest  filter_backtrace first  split first ","where split first  split ","Minitest  filter_backtrace first  split "]}," Minitest Guard mri?":{"type":"method","name":"mri?","children":[],"call":[]}," Minitest Guard maglev?":{"type":"method","name":"maglev?","children":[],"call":["maglev == "," warn ","where split first ","where split ","Minitest  filter_backtrace first ","Minitest  filter_backtrace "," caller ","where split first  split first ","Minitest  filter_backtrace first  split first ","where split first  split ","Minitest  filter_backtrace first  split "]}," Minitest Guard jruby?":{"type":"method","name":"jruby?","children":[],"call":["java == "]}," Minitest UnexpectedError result_label":{"type":"method","name":"result_label","children":[],"call":[]}," Minitest UnexpectedError message":{"type":"method","name":"message","children":[],"call":[" exception message "," exception "," exception class ","Minitest  filter_backtrace join ","Minitest  filter_backtrace "," backtrace "," error message "," error "," error class "]}," Minitest UnexpectedError error":{"type":"method","name":"error","children":[],"call":[" exception "]}," Minitest UnexpectedError backtrace":{"type":"method","name":"backtrace","children":[],"call":[" exception backtrace "," exception "," error backtrace "," error "]}," Minitest UnexpectedError initialize":{"type":"method","name":"initialize","children":[],"call":[" exception= "," error= "]}," Minitest Skip result_label":{"type":"method","name":"result_label","children":[],"call":[]}," Minitest Assertion result_label":{"type":"method","name":"result_label","children":[],"call":[]}," Minitest Assertion result_code":{"type":"method","name":"result_code","children":[],"call":[" result_label [] "," result_label "]}," Minitest Assertion location":{"type":"method","name":"location","children":[],"call":["last_before_assertion sub ","s =~ "," backtrace reverse_each "," backtrace "]}," Minitest Assertion error":{"type":"method","name":"error","children":[],"call":[]}," Minitest CompositeReporter report":{"type":"method","name":"report","children":[],"call":[" reporters each "," reporters "]}," Minitest CompositeReporter record":{"type":"method","name":"record","children":[],"call":["reporter record "," reporters each "," reporters "]}," Minitest CompositeReporter start":{"type":"method","name":"start","children":[],"call":[" reporters each "," reporters "]}," Minitest CompositeReporter passed?":{"type":"method","name":"passed?","children":[],"call":[" reporters all? "," reporters "]}," Minitest CompositeReporter <<":{"type":"method","name":"<<","children":[],"call":[" reporters << "," reporters "]}," Minitest CompositeReporter initialize":{"type":"method","name":"initialize","children":[],"call":[" reporters= "]}," Minitest Reporter report":{"type":"method","name":"report","children":[],"call":[" io sync= "," old_sync "," io "," sync "," io puts ","\n%3d) %s % ","i + ","filtered_results each_with_index ","filtered_results reject! "," options [] "," options "," results dup "," results ","format % "," assertions "," count ","Finished in %.6fs, %.4f runs/s, %.4f assertions/s. % "," assertions / "," count / ","Time  now - "," start_time ","Time  now ","aggregate [] size ","aggregate [] ","aggregate default= ","r failure class ","r failure "," results group_by "," io print "," io aggregate [] size ync= "," old_aggregate [] size ync "," aggregate [] size ync "," io puTime  now - s "," io putaggregate [] size  ","\n%3d) %aggregate [] size  % "," results dup  each_with_index ","filTime  now - ered_resulTime  now - s each_wiTime  now - h_index ","filtered_reaggregate [] size ultaggregate [] size  each_with_index ","filtaggregate [] size raggregate [] size d_raggregate [] size sults aggregate [] size ach_with_indaggregate [] size x ","aggregate [] size iltered_results each_with_index "," results dup  reject! ","filTime  now - ered_resulTime  now - s rejecTime  now - ! ","filtered_reaggregate [] size ultaggregate [] size  reject! ","filtaggregate [] size raggregate [] size d_raggregate [] size sults raggregate [] size jaggregate [] size ct! ","aggregate [] size iltered_results reject! "," opTime  now - ions [] "," optionaggregate [] size  [] "," opTime  now - ions "," optionaggregate [] size  "," resulTime  now - s dup "," reaggregate [] size ultaggregate [] size  dup "," raggregate [] size sults dup "," resulTime  now - s "," reaggregate [] size ultaggregate [] size  "," raggregate [] size sults ","formaTime  now -  % ","aggregate [] size ormat % "," asserTime  now - ions "," aaggregate [] size aggregate [] size ertionaggregate [] size  "," assaggregate [] size rtions "," counTime  now -  ","Finished in %.6fs, %.4f runs/s, %.4f asserTime  now - ions/s. % ","Finiaggregate [] size hed in %.6faggregate [] size , %.4f runaggregate [] size /aggregate [] size , %.4f aaggregate [] size aggregate [] size ertionaggregate [] size /aggregate [] size . % ","Finishaggregate [] size d in %.6fs, %.4f runs/s, %.4f assaggregate [] size rtions/s. % ","Finished in %.6aggregate [] size s, %.4aggregate [] size  runs/s, %.4aggregate [] size  assertions/s. % "," asserTime  now - ions / "," aaggregate [] size aggregate [] size ertionaggregate [] size  / "," assaggregate [] size rtions / "," counTime  now -  / ","Timaggregate [] size   now - "," sTime  now - arTime  now - _Time  now - ime "," aggregate [] size tart_time "," start_timaggregate [] size  ","Timaggregate [] size   now ","aggregaTime  now - e [] size ","aggregate [] aggregate [] size ize ","aggraggregate [] size gataggregate [] size  [] sizaggregate [] size  ","aggregaTime  now - e [] ","aggraggregate [] size gataggregate [] size  [] ","aggregaTime  now - e defaulTime  now - = ","aggraggregate [] size gataggregate [] size  daggregate [] size fault= ","aggregate deaggregate [] size ault= ","r failure claaggregate [] size aggregate [] size  ","r failuraggregate [] size  class ","r aggregate [] size ailure class ","r failuraggregate [] size  ","r aggregate [] size ailure "," resulTime  now - s group_by "," reaggregate [] size ultaggregate [] size  group_by "," raggregate [] size sults group_by "," io prinTime  now -  "]}," Minitest Reporter record":{"type":"method","name":"record","children":[],"call":[" results << "," results ","result skipped? ","result passed? ! ","result passed? "," io puts "," io "," options [] "," options "," io print ","result result_code ","%s#%s = %.2f s =  % ","result time ","result name ","result class ","result assertions "," assertions "," count "," simple_record ","Reporter  synchronize "]}," Minitest Reporter start":{"type":"method","name":"start","children":[],"call":[" io puts "," io "," options [] "," options "," start_time= ","Time  now "," io sync "," io sync= "," old_sync= "," sync "," sync= "," io respond_to? "]}," Minitest Reporter run_and_report":{"type":"method","name":"run_and_report","children":[],"call":[" report "," start "," io sync= "," old_sync "," io "," sync "]}," Minitest Reporter passed?":{"type":"method","name":"passed?","children":[],"call":[" results all? "," results "]}," Minitest Reporter initialize":{"type":"method","name":"initialize","children":[],"call":[" start_time= "," results= "," count= "," assertions= "," options= "," io= "]}," Minitest Runnable skipped?":{"type":"method","name":"skipped?","children":[],"call":[" raise "]}," Minitest Runnable result_code":{"type":"method","name":"result_code","children":[],"call":[" raise "]}," Minitest Runnable passed?":{"type":"method","name":"passed?","children":[],"call":[" raise "]}," Minitest Runnable run":{"type":"method","name":"run","children":[],"call":[" raise "]}," Minitest Runnable initialize":{"type":"method","name":"initialize","children":[],"call":[" assertions= "," failures= "," name= "]}," Minitest Runnable failure":{"type":"method","name":"failure","children":[],"call":[" failures first "," failures "]}," Minitest Runnable dup":{"type":"method","name":"dup","children":[],"call":["obj assertions= "," assertions ","obj failures= "," failures dup "," failures ","obj name= "," name "," class new "," class "," class new  assertions= "," class new  failures= "," class new  name= "]}," Minitest Runnable runnables":{"type":"method","name":"runnables","children":[],"call":[]}," Minitest Runnable runnable_methods":{"type":"method","name":"runnable_methods","children":[],"call":[]}," Minitest Runnable reset":{"type":"method","name":"reset","children":[],"call":[]}," Minitest Runnable methods_matching":{"type":"method","name":"methods_matching","children":[],"call":[]}," Minitest Runnable inherited":{"type":"method","name":"inherited","children":[],"call":[]}," Minitest Runnable name=":{"type":"method","name":"name=","children":[],"call":[]}," Minitest Runnable name":{"type":"method","name":"name","children":[],"call":[]}," Minitest filter_backtrace":{"type":"method","name":"filter_backtrace","children":[],"call":[]}," Minitest process_args":{"type":"method","name":"process_args","children":[],"call":[]}," Minitest __run":{"type":"method","name":"__run","children":[],"call":[]}," Minitest run":{"type":"method","name":"run","children":[],"call":[]}," Minitest load_plugins":{"type":"method","name":"load_plugins","children":[],"call":[]}," Minitest init_plugins":{"type":"method","name":"init_plugins","children":[],"call":[]}," Minitest after_run":{"type":"method","name":"after_run","children":[],"call":[]}," Minitest autorun":{"type":"method","name":"autorun","children":[],"call":[]}," Minitest Unit after_tests":{"type":"method","name":"after_tests","children":[],"call":[]}," Minitest Unit autorun":{"type":"method","name":"autorun","children":[],"call":[]}," Minitest Unit TestCase inherited":{"type":"method","name":"inherited","children":[],"call":[]}," Minitest Test with_info_handler":{"type":"method","name":"with_info_handler","children":[],"call":[" trap "," warn ","Current: %s#%s %.2fs % ","Time  now - ","Time  now "," name "," class ","Signal  list [] ","Signal  list "," class on_signal ","\nCurrent: %s#%s %.2fs % "," lambda "," Minitest  info_signal ","Minitest  clock_time - ","Minitest  clock_time "]}," Minitest Test to_s":{"type":"method","name":"to_s","children":[],"call":["(send\n  (send nil :failures) :map) join ","failure message "," location ","failure result_label "," failures map "," failures "," skipped? ! "," skipped? "," passed? "]}," Minitest Test time_it":{"type":"method","name":"time_it","children":[],"call":[" time= ","Time  now - ","Time  now ","Minitest  clock_time - ","Minitest  clock_time "]}," Minitest Test skipped?":{"type":"method","name":"skipped?","children":[],"call":["Skip  === "," failure "]}," Minitest Test result_code":{"type":"method","name":"result_code","children":[],"call":[" failure result_code "," failure "]}," Minitest Test passed?":{"type":"method","name":"passed?","children":[],"call":[" failure ! "," failure "]}," Minitest Test location":{"type":"method","name":"location","children":[],"call":[" name "," class "," failure location "," failure "," error? "," passed? "]}," Minitest Test error?":{"type":"method","name":"error?","children":[],"call":["UnexpectedError  === "," failures any? "," failures "]}," Minitest Test capture_exceptions":{"type":"method","name":"capture_exceptions","children":[],"call":[" failures << ","UnexpectedError  new "," failures "," raise "," sanitize_exception "]}," Minitest Test LifecycleHooks after_teardown":{"type":"method","name":"after_teardown","children":[],"call":[]}," Minitest Test LifecycleHooks teardown":{"type":"method","name":"teardown","children":[],"call":[]}," Minitest Test LifecycleHooks before_teardown":{"type":"method","name":"before_teardown","children":[],"call":[]}," Minitest Test LifecycleHooks after_setup":{"type":"method","name":"after_setup","children":[],"call":[]}," Minitest Test LifecycleHooks setup":{"type":"method","name":"setup","children":[],"call":[]}," Minitest Test LifecycleHooks before_setup":{"type":"method","name":"before_setup","children":[],"call":[]}," Minitest Test run":{"type":"method","name":"run","children":[],"call":[" send "," capture_exceptions ","(str \"before_teardown\") each "," name "," after_setup "," setup "," before_setup "," time_it "," with_info_handler ","TEARDOWN_METHODS  each ","Result  from ","SETUP_METHODS  each "]}," Minitest Test dup":{"type":"method","name":"dup","children":[],"call":["obj time= "," time "]}," Minitest Test test_order":{"type":"method","name":"test_order","children":[],"call":[]}," Minitest Test runnable_methods":{"type":"method","name":"runnable_methods","children":[],"call":[]}," Minitest Test parallelize_me!":{"type":"method","name":"parallelize_me!","children":[],"call":[]}," Minitest Test make_my_diffs_pretty!":{"type":"method","name":"make_my_diffs_pretty!","children":[],"call":[]}," Minitest Test i_suck_and_my_tests_are_order_dependent!":{"type":"method","name":"i_suck_and_my_tests_are_order_dependent!","children":[],"call":[]}," Minitest PrideLOL pride":{"type":"method","name":"pride","children":[],"call":["@colors [] ","@index % ","@@colors [] olors [] "]}," Minitest PrideLOL initialize":{"type":"method","name":"initialize","children":[],"call":["36 * + + + ","36 * + + ","36 * + ","6 * ","36 * ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lvar :n) :+\n        (send\n          (int 4) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i ","3 * + ","3 * ","Math  sin ","n + ","4 * ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lvar :n) :+\n        (send\n          (int 2) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i ","2 * ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lvar :n))) :+\n  (int 3)) to_i ","1.0 / ","(erange\n  (int 0)\n  (begin\n    (send\n      (int 6) :*\n      (int 7)))) map ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lva(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lvar :n))) :+\n  (int 3)) to_i  :n) :+\n        (send\n          (int 4) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lva(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lvar :n))) :+\n  (int 3)) to_i  :n) :+\n        (send\n          (int 2) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i ","(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lva(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lvar :n))) :+\n  (int 3)) to_i  :n))) :+\n  (int 3)) to_i ","(erange\n  (int 0)\n  ((send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lvar :n) :+\n        (send\n          (int 4) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i egin\n    (send\n      (int 6) :*\n      (int 7)))) map ","(eran(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lvar :n) :+\n        (send\n          (int 2) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i e\n  (int 0)\n  (be(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (send\n        (lvar :n) :+\n        (send\n          (int 2) :*\n          (const nil :PI_3))))) :+\n  (int 3)) to_i in\n    (send\n      (int 6) :*\n      (int 7)))) map ","(e(send\n  (send\n    (int 3) :*\n    (send\n      (const nil :Math) :sin\n      (lvar :n))) :+\n  (int 3)) to_i ange\n  (int 0)\n  (begin\n    (send\n      (int 6) :*\n      (int 7)))) map "]}," Minitest PrideIO method_missing":{"type":"method","name":"method_missing","children":[],"call":[" io send "," io "]}," Minitest PrideIO pride":{"type":"method","name":"pride","children":[],"call":["@colors [] ","@index % ","string == ","@@colors [] olors [] "]}," Minitest PrideIO puts":{"type":"method","name":"puts","children":[],"call":["(send\n  (send\n    (str \"Fabulous run\") :split\n    (regexp\n      (regopt))) :map) join "," pride ","Fabulous run split map ","Fabulous run split ","s to_s sub ","s to_s ","o map! "," io puts "," io "]}," Minitest PrideIO print":{"type":"method","name":"print","children":[],"call":[" io print "," io "," pride "]}," Minitest PrideIO initialize":{"type":"method","name":"initialize","children":[],"call":["@colors size ","(irange\n  (int 31)\n  (int 36)) to_a "]}," Minitest PrideIO pride?":{"type":"method","name":"pride?","children":[],"call":[]}," Minitest PrideIO pride!":{"type":"method","name":"pride!","children":[],"call":[]}," Minitest plugin_pride_init":{"type":"method","name":"plugin_pride_init","children":[],"call":[]}," Minitest plugin_pride_options":{"type":"method","name":"plugin_pride_options","children":[],"call":[]}," Minitest Reporter synchronize":{"type":"method","name":"synchronize","children":[],"call":[]}," Minitest Test capture_subprocess_io":{"type":"method","name":"capture_subprocess_io","children":[],"call":[" simple_capture_subprocess_io ","Test  synchronize "]}," Minitest Test capture_io":{"type":"method","name":"capture_io","children":[],"call":[" simple_capture_io ","Test  synchronize "]}," Minitest Test synchronize":{"type":"method","name":"synchronize","children":[],"call":[]}," Minitest Mock respond_to?":{"type":"method","name":"respond_to?","children":[],"call":[" __respond_to? ","@expected_calls has_key? ","sym to_sym ","@delegator respond_to? ","@expected_calls key? "]}," Minitest Mock method_missing":{"type":"method","name":"method_missing","children":[],"call":["@actual_calls [] << ","mod === ","expected_args zip map ","expected_args zip ","@actual_calls [] "," raise ","mocked method %p called with unexpected arguments %p % ","mod == ","expected_args zip all? ","mocked method %p expects %d arguments, got %d % ","args size ","expected_args size ","expected_args size != ","mocked method %p failed block w/ %p % ","val_block call ","expected_call values_at ","No more expects available for %p: %p % ","@expected_calls [] [] ","@expected_calls [] ","@actual_calls [] length ","unmocked method %p, expected one of %p % ","@expected_calls keys sort_by ","@expected_calls keys ","@expected_calls has_key? ","zipped_args map! ","zipped_args all? ","@delegator public_send ","@delegator respond_to? ","@expected_calls key? ","(send\n  (lvar :zipped_kwargs) :map) to_h ","e === ","zipped_kwargs map ","zipped_args map ","fmt % ","ev == ","ev === ","zipped_kwargs all? ","(send\n  (lvar :expected_kwargs) :map) to_h ","kwargs [] ","expected_kwargs map ","kwargs keys ","expected_kwargs keys ","expected_kwargs keys sort == ","kwargs keys sort ","expected_kwargs keys sort ","mocked method %p expects %d keyword arguments, got %p % ","expected_kwargs size ","expected_kwargs size != ","kwargs size ","mocked method %p expects %d arguments, got %p % ","mocked method %p failed block w/ %p %p % ","No more expects available for %p: %p %p % ","(send\n  (lvar :kwargs) :map) to_h ","kwargs map ","Hash  == ","kwargs empty? ","@expected_calls [] []  values_at ","No more expects kwargs [] ailable for %p: %p % ","@@expected_calls [] [] s [] [] ","@@expected_calls [] [] s [] ","@@expected_calls [] [] s keys sort_by ","@@expected_calls [] [] s keys ","@@expected_calls [] [] s has_key? ","expected_args zip  map! ","expected_args zip  all? ","@@expected_calls [] [] s key? ","(send\n  (lvar :(send\n  (lvar :expected_kwargs) :map) to_h ) :map) to_h ","(send\n  (lvar :expected_kwargs) :map) to_h  map ","expected_args zip  map ","(send\n  (lvar :expected_kwargs) :map) to_h  all? ","(send\n  (lvar :(send\n  (lvar :kwargs) :map) to_h ) :map) to_h ","(send\n  (lvar :kwargs) :map) to_h  map ","(send\n  (lvar :kwargs) :map) to_h  keys ","(send\n  (lvar :kwargs) :map) to_h  keys sort == ","(send\n  (lvar :kwargs) :map) to_h  keys sort ","(send\n  (lvar :kwargs) :map) to_h  size ","(send\n  (lvar :kwargs) :map) to_h  size != ","No more expects kwargs [] ailable for %p: %p %p % "]}," Minitest Mock verify":{"type":"method","name":"verify","children":[],"call":[" raise ","@actual_calls [] include? ","@actual_calls [] ","@actual_calls has_key? ","@actual_calls [] include? ! "," __call ","calls each ","@expected_calls each ","expected [] ","actual size ","actual size < ","expected size ","@actual_calls fetch ","@actual_calls key? ","@@actual_calls fetch _calls [] include? ","@@actual_calls fetch _calls [] ","@@actual_calls fetch _calls has_key? ","@@actual_calls fetch _calls [] include? ! ","@actual_calls fetch  size ","@actual_calls fetch  size < ","@@actual_calls fetch _calls fetch ","@@actual_calls fetch _calls key? "]}," Minitest Mock __call":{"type":"method","name":"__call","children":[],"call":["(send\n  (lvar :data) :map) join "," __call ","data map ","data [] inspect ","data [] ","data [] inspect [] ","args << ","kwargs inspect [] ","kwargs inspect ","args empty? ","kwargs empty? ! ","kwargs empty? ","data [] inspect []  << ","data []  inspect [] ","kwdata [] inspect []  inspect [] ","data []  inspect ","kwdata [] inspect []  inspect ","data [] inspect []  empty? ","data []  empty? ! ","kwdata [] inspect []  empty? ! ","data []  empty? ","kwdata [] inspect []  empty? "]}," Minitest Mock expect":{"type":"method","name":"expect","children":[],"call":["@expected_calls [] << ","@expected_calls [] "," raise ","Array  === ","args empty? "," block_given? ","name to_sym "," warn "," caller first "," caller ","args pop ","kwargs empty? ","Hash  === ","args last ","ENV  [] ","Hash  == ","name to_sym  to_sym ","args pop  empty? "]}," Minitest Mock initialize":{"type":"method","name":"initialize","children":[],"call":["calls []= ","Hash  new "]}," Test test_order":{"type":"method","name":"test_order","children":[],"call":[]}," Minitest BenchSpec bench_performance_exponential":{"type":"method","name":"bench_performance_exponential","children":[],"call":[]}," Minitest BenchSpec bench_performance_constant":{"type":"method","name":"bench_performance_constant","children":[],"call":[]}," Minitest BenchSpec bench_performance_linear":{"type":"method","name":"bench_performance_linear","children":[],"call":[]}," Minitest BenchSpec bench_range":{"type":"method","name":"bench_range","children":[],"call":[]}," Minitest BenchSpec bench":{"type":"method","name":"bench","children":[],"call":[]}," Minitest Benchmark validation_for_fit":{"type":"method","name":"validation_for_fit","children":[],"call":[" assert_operator "," send "," proc "]}," Minitest Benchmark sigma":{"type":"method","name":"sigma","children":[],"call":["sum + ","enum inject ","enum map ","enum map  inject ","enum map  map "]}," Minitest Benchmark fit_power":{"type":"method","name":"fit_power","children":[],"call":["Math  exp * ","x ** ","Math  exp "," fit_error ","(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / ","slny - ","b * ","(send\n  (send\n    (lvar :n) :*\n    (lvar :slnxlny)) :-\n  (send\n    (lvar :slnx) :*\n    (lvar :slny))) / ","n * - ","slnx ** ","n * ","slnx * ","Math  log ** ","Math  log "," sigma ","Math  log * ","xs zip ","xs size ","M(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  exp * ","M(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  exp ","(send\n  (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slny) :-\n  (send\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :b) :*\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slnx))) / ","(send\n  (lvar :slny) :-\n  (send\n    (lvar :(send\n  (send\n    (lvar :n) :*\n    (lvar :slnxlny)) :-\n  (send\n    (lvar :slnx) :*\n    (lvar :slny))) / ) :*\n    (lvar :slnx))) / ","(sexs size d\n  (lvar :slxs size y) :-\n  (sexs size d\n    (lvar :b) :*\n    (lvar :slxs size x))) / ","slxs size y - ","(send\n  (send\n    (lvar :n) :*\n    (lvar :slnxlny)) :-\n  (send\n    (lvar :slnx) :*\n    (lvar :slny))) /  * ","(send\n  (send\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :n) :*\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slnxlny)) :-\n  (send\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slnx) :*\n    (lv(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slny))) / ","(sexs size d\n  (sexs size d\n    (lvar :xs size ) :*\n    (lvar :slxs size xlxs size y)) :-\n  (sexs size d\n    (lvar :slxs size x) :*\n    (lvar :slxs size y))) / ","xs size  * - ","slxs size x ** ","xs size  * ","slxs size x * ","M(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  log ** ","M(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  log "," sigm(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) /  ","M(send\n  (lvar :slny) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  log * "]}," Minitest Benchmark fit_linear":{"type":"method","name":"fit_linear","children":[],"call":["a + ","b * "," fit_error ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sxy)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sy))) / ","n * - ","sx * ","n * ","(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / ","sy * - ","sy * ","sx ** ","x * "," sigma ","x ** ","xs zip ","xs size ","(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) /  + ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sxy)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sy))) /  * ","(send\n  (send\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :n) :*\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sxy)) :-\n  (send\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sx) :*\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sy))) / ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sxy)) :-\n  (send\n    (lvar :sx) :*\n    (lvar : sigma ))) / ","(send\n  (send\n    (lvar :n) :*\n    (lvar : sigma y)) :-\n  (send\n    (lvar : sigma ) :*\n    (lvar :sy))) / ","(sexs size d\n  (sexs size d\n    (lvar :xs size ) :*\n    (lvar :sxy)) :-\n  (sexs size d\n    (lvar :sx) :*\n    (lvar :sy))) / ","xs size  * - "," sigma  * ","xs size  * ","(send\n  (send\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sy) :*\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sx2)) :-\n  (send\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sx) :*\n    (lv(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / r :sxy))) / ","(send\n  (send\n    (lvar : sigma ) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) / ","(send\n  (send\n    (lvar :sy) :*\n    (lvar : sigma 2)) :-\n  (send\n    (lvar : sigma ) :*\n    (lvar : sigma y))) / ","(sexs size d\n  (sexs size d\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (sexs size d\n    (lvar :sx) :*\n    (lvar :sxy))) / "," sigma  * - "," sigma  ** "," sigm(send\n  (send\n    (lvar :sy) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxy))) /  "]}," Minitest Benchmark fit_logarithmic":{"type":"method","name":"fit_logarithmic","children":[],"call":["a + ","b * ","Math  log "," fit_error ","(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / ","sy - ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sylnx)) :-\n  (send\n    (lvar :sy) :*\n    (lvar :slnx))) / ","n * - ","sy * ","n * ","slnx ** "," sigma ","y * ","Math  log ** ","xs zip ","xs size ","(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) /  + ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sylnx)) :-\n  (send\n    (lvar :sy) :*\n    (lvar :slnx))) /  * ","M(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  log ","(send\n  (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :sy) :-\n  (send\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :b) :*\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slnx))) / ","(send\n  (lvar :sy) :-\n  (send\n    (lvar :(send\n  (send\n    (lvar :n) :*\n    (lvar :sylnx)) :-\n  (send\n    (lvar :sy) :*\n    (lvar :slnx))) / ) :*\n    (lvar :slnx))) / ","(sexs size d\n  (lvar :sy) :-\n  (sexs size d\n    (lvar :b) :*\n    (lvar :slxs size x))) / ","(send\n  (send\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :n) :*\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :sylnx)) :-\n  (send\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :sy) :*\n    (lv(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / r :slnx))) / ","(sexs size d\n  (sexs size d\n    (lvar :xs size ) :*\n    (lvar :sylxs size x)) :-\n  (sexs size d\n    (lvar :sy) :*\n    (lvar :slxs size x))) / ","xs size  * - ","xs size  * ","slxs size x ** "," sigm(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) /  ","M(send\n  (lvar :sy) :-\n  (send\n    (lvar :b) :*\n    (lvar :slnx))) / th  log ** "]}," Minitest Benchmark fit_exponential":{"type":"method","name":"fit_exponential","children":[],"call":["Math  exp ","a + ","b * "," fit_error ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sxlny)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :slny))) / ","n * - ","sx * ","n * ","(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / ","slny * - ","slny * ","sx ** "," sigma ","x * ","Math  log ","xs zip ","xs size ","M(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / th  exp ","(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) /  + ","(send\n  (send\n    (lvar :n) :*\n    (lvar :sxlny)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :slny))) /  * ","(send\n  (send\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :n) :*\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :sxlny)) :-\n  (send\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :sx) :*\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :slny))) / ","(send\n  (send\n    (lvar :n) :*\n    (lvar : sigma lny)) :-\n  (send\n    (lvar : sigma ) :*\n    (lvar :slny))) / ","(sexs size d\n  (sexs size d\n    (lvar :xs size ) :*\n    (lvar :sxlxs size y)) :-\n  (sexs size d\n    (lvar :sx) :*\n    (lvar :slxs size y))) / ","xs size  * - "," sigma  * ","xs size  * ","(send\n  (send\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :slny) :*\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :sx2)) :-\n  (send\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :sx) :*\n    (lv(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / r :sxlny))) / ","(send\n  (send\n    (lvar :slny) :*\n    (lvar : sigma 2)) :-\n  (send\n    (lvar : sigma ) :*\n    (lvar : sigma lny))) / ","(sexs size d\n  (sexs size d\n    (lvar :slxs size y) :*\n    (lvar :sx2)) :-\n  (sexs size d\n    (lvar :sx) :*\n    (lvar :sxlxs size y))) / ","slxs size y * - ","slxs size y * "," sigma  ** "," sigm(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) /  ","M(send\n  (send\n    (lvar :slny) :*\n    (lvar :sx2)) :-\n  (send\n    (lvar :sx) :*\n    (lvar :sxlny))) / th  log "]}," Minitest Benchmark fit_error":{"type":"method","name":"fit_error","children":[],"call":["1 - ","ss_err / ","(send\n  (yield\n    (lvar :x)) :-\n  (lvar :y)) ** ","(lvar :x) - "," sigma ","(send\n  (lvar :y) :-\n  (lvar :y_bar)) ** ","y - ","(send nil :sigma\n  (lvar :xys)) / ","xys size to_f ","xys size ","(send\n  (lvar :y) :-\n  (lvar :(send nil :sigma\n  (lvar :xys)) / )) ** "]}," Minitest Benchmark assert_performance_power":{"type":"method","name":"assert_performance_power","children":[],"call":[" assert_performance "," validation_for_fit "]}," Minitest Benchmark assert_performance_linear":{"type":"method","name":"assert_performance_linear","children":[],"call":[" assert_performance "," validation_for_fit "]}," Minitest Benchmark assert_performance_logarithmic":{"type":"method","name":"assert_performance_logarithmic","children":[],"call":[" assert_performance "," validation_for_fit "]}," Minitest Benchmark assert_performance_exponential":{"type":"method","name":"assert_performance_exponential","children":[],"call":[" assert_performance "," validation_for_fit "]}," Minitest Benchmark assert_performance_constant":{"type":"method","name":"assert_performance_constant","children":[],"call":[" assert_performance "," assert_in_delta ","1 - "," fit_linear "," proc "]}," Minitest Benchmark assert_performance":{"type":"method","name":"assert_performance","children":[],"call":["validation [] "," io puts "," io ","times << "," io print ","\t%9.6f % ","Time  now - ","Time  now "," instance_exec ","GC  start ","range each "," name "," class bench_range "," class ","Minitest  clock_time - ","Minitest  clock_time ","validaTime  now - ion [] ","validaMinitest  clock_time - ion [] "," io puTime  now - s "," io puMinitest  clock_time - s ","Time  now - imes << ","Minitest  clock_time - imes << "," io prinTime  now -  "," io prinMinitest  clock_time -  "," insTime  now - ance_exec "," insMinitest  clock_time - ance_exec ","GC  sTime  now - arTime  now -  ","GC  sMinitest  clock_time - arMinitest  clock_time -  "," class bench_range  each "," class bench_ class bench_range  ","MiniTime  now - esTime  now -   clock_Time  now - ime - ","MiniMinitest  clock_time - esMinitest  clock_time -   clock_Minitest  clock_time - ime - ","MiniTime  now - esTime  now -   clock_Time  now - ime ","MiniMinitest  clock_time - esMinitest  clock_time -   clock_Minitest  clock_time - ime "]}," Minitest Benchmark bench_range":{"type":"method","name":"bench_range","children":[],"call":[]}," Minitest Benchmark bench_linear":{"type":"method","name":"bench_linear","children":[],"call":[]}," Minitest Benchmark bench_exp":{"type":"method","name":"bench_exp","children":[],"call":[]}," Minitest Benchmark runnable_methods":{"type":"method","name":"runnable_methods","children":[],"call":[]}," Minitest Benchmark run":{"type":"method","name":"run","children":[],"call":[]}," Minitest Benchmark io":{"type":"method","name":"io","children":[],"call":[" class io "," class "]}," Minitest Assertions skipped?":{"type":"method","name":"skipped?","children":[],"call":[]}," Minitest Assertions skip":{"type":"method","name":"skip","children":[],"call":[" raise "]}," Minitest Assertions refute_same":{"type":"method","name":"refute_same","children":[],"call":[" refute ","exp equal? ","Expected %s (oid=%d) to not be the same as %s (oid=%d) % ","exp object_id "," mu_pp ","act object_id "," message "]}," Minitest Assertions refute_respond_to":{"type":"method","name":"refute_respond_to","children":[],"call":[" refute ","obj respond_to? "," mu_pp "," message "]}," Minitest Assertions refute_predicate":{"type":"method","name":"refute_predicate","children":[],"call":[" refute ","o1 __send__ "," mu_pp "," message "]}," Minitest Assertions refute_operator":{"type":"method","name":"refute_operator","children":[],"call":[" refute ","o1 __send__ "," mu_pp "," message "," refute_predicate ","UNDEFINED  == "]}," Minitest Assertions refute_nil":{"type":"method","name":"refute_nil","children":[],"call":[" refute ","obj nil? "," mu_pp "," message "]}," Minitest Assertions refute_match":{"type":"method","name":"refute_match","children":[],"call":[" refute ","matcher =~ ","Regexp  new ","Regexp  escape ","String  === "," assert_respond_to "," mu_pp "," message ","Regexp  new  =~ "]}," Minitest Assertions refute_kind_of":{"type":"method","name":"refute_kind_of","children":[],"call":[" refute ","obj kind_of? "," mu_pp "," message "]}," Minitest Assertions refute_instance_of":{"type":"method","name":"refute_instance_of","children":[],"call":[" refute ","obj instance_of? "," mu_pp "," message "]}," Minitest Assertions refute_includes":{"type":"method","name":"refute_includes","children":[],"call":[" refute ","collection include? "," assert_respond_to "," mu_pp "," message "]}," Minitest Assertions refute_in_epsilon":{"type":"method","name":"refute_in_epsilon","children":[],"call":[" refute_in_delta ","a * "]}," Minitest Assertions refute_in_delta":{"type":"method","name":"refute_in_delta","children":[],"call":[" refute ","delta >= "," message ","(send\n  (lvar :exp) :-\n  (lvar :act)) abs ","exp - ","(se(send\n  (lvar :exp) :-\n  (lvar :act)) abs d\n  (lvar :exp) :-\n  (lvar :act)) abs "]}," Minitest Assertions refute_equal":{"type":"method","name":"refute_equal","children":[],"call":[" refute ","exp == "," mu_pp "," message "]}," Minitest Assertions refute_empty":{"type":"method","name":"refute_empty","children":[],"call":[" refute ","obj empty? "," assert_respond_to "," mu_pp "," message "]}," Minitest Assertions refute":{"type":"method","name":"refute","children":[],"call":[" assert ! "," assert ","test ! "," mu_pp "," message "]}," Minitest Assertions pass":{"type":"method","name":"pass","children":[],"call":[" assert "]}," Minitest Assertions message":{"type":"method","name":"message","children":[],"call":["default call ","msg to_s empty? ","msg to_s ","msg nil? ","msg call chomp ","msg call ","Proc  === "," proc ","msg call chomp  to_s empty? ","msg call chomp  to_s ","msg call chomp  nil? ","msg call chomp  call chomp ","msg call chomp  call "]}," Minitest Assertions flunk":{"type":"method","name":"flunk","children":[],"call":[" assert "]}," Minitest Assertions exception_details":{"type":"method","name":"exception_details","children":[],"call":["(dstr\n  (begin\n    (lvar :msg))) join ","Minitest  filter_backtrace join ","Minitest  filter_backtrace ","e backtrace ","e message inspect ","e message ","e class "]}," Minitest Assertions capture_subprocess_io":{"type":"method","name":"capture_subprocess_io","children":[],"call":["$stderr reopen ","$stdout reopen ","captured_stderr unlink ","captured_stdout unlink ","captured_stderr read ","captured_stdout read ","$stderr rewind ","$stdout rewind ","$stderr dup ","$stdout dup ","Tempfile  new "," require "," _synchronize ","captured_stderr close ","captured_stdout close ","orig_stderr close ","orig_stdout close ","captured_stderr close! ","captured_stdout close! "]}," Minitest Assertions capture_io":{"type":"method","name":"capture_io","children":[],"call":["captured_stderr string ","captured_stdout string ","StringIO  new "," require "," _synchronize "]}," Minitest Assertions assert_throws":{"type":"method","name":"assert_throws","children":[],"call":[" assert "," message ","e name inspect ","e name ","e message split last ","e message split ","e message ","e message [] "," catch "," mu_pp "," raise ","e name == ","e message include? "]}," Minitest Assertions assert_silent":{"type":"method","name":"assert_silent","children":[],"call":[" assert_output "]}," Minitest Assertions assert_send":{"type":"method","name":"assert_send","children":[],"call":[" assert ","recv __send__ "," mu_pp "," message "," warn "," caller first "," caller ","where split first ","where split ","Minitest  filter_backtrace first ","Minitest  filter_backtrace ","where split first  split first ","Minitest  filter_backtrace first  split first ","where split first  split ","Minitest  filter_backtrace first  split "]}," Minitest Assertions assert_same":{"type":"method","name":"assert_same","children":[],"call":[" assert ","exp equal? ","Expected %s (oid=%d) to be the same as %s (oid=%d) % ","exp object_id "," mu_pp ","act object_id "," message "]}," Minitest Assertions assert_respond_to":{"type":"method","name":"assert_respond_to","children":[],"call":[" assert ","obj respond_to? ","obj class "," mu_pp "," message "]}," Minitest Assertions assert_raises":{"type":"method","name":"assert_raises","children":[],"call":[" flunk "," mu_pp ","exp first ","exp size == ","exp size "," assert "," exception_details "," proc ","e instance_of? ","e kind_of? ","ex instance_of? ","exp any? "," raise ","exp include? ","exp pop ","String  === ","exp last "," pass ","exp << ","exp empty? "," block_given? ","exp first  first ","exp first  size == ","exp first  size ","exp first  any? ","exp first  include? ","exp first  pop ","exp first  last ","exp first  << ","exp first  empty? "]}," Minitest Assertions assert_predicate":{"type":"method","name":"assert_predicate","children":[],"call":[" assert ","o1 __send__ "," mu_pp "," message "]}," Minitest Assertions assert_output":{"type":"method","name":"assert_output","children":[],"call":["stderr ! ","stdout ! "," send ","Regexp  === "," capture_io "," flunk "," block_given? "," raise ","Rege send p  === "]}," Minitest Assertions assert_operator":{"type":"method","name":"assert_operator","children":[],"call":[" assert ","o1 __send__ "," mu_pp "," message "," assert_predicate ","UNDEFINED  == "]}," Minitest Assertions assert_nil":{"type":"method","name":"assert_nil","children":[],"call":[" assert ","obj nil? "," mu_pp "," message "]}," Minitest Assertions assert_match":{"type":"method","name":"assert_match","children":[],"call":[" assert ","matcher =~ ","Regexp  new ","Regexp  escape ","String  === "," assert_respond_to "," mu_pp "," message ","Regexp  last_match ","Regexp  new  =~ "]}," Minitest Assertions assert_kind_of":{"type":"method","name":"assert_kind_of","children":[],"call":[" assert ","obj kind_of? ","obj class "," mu_pp "," message "]}," Minitest Assertions assert_instance_of":{"type":"method","name":"assert_instance_of","children":[],"call":[" assert ","obj instance_of? ","obj class "," mu_pp "," message "]}," Minitest Assertions assert_includes":{"type":"method","name":"assert_includes","children":[],"call":[" assert ","collection include? "," assert_respond_to "," mu_pp "," message "]}," Minitest Assertions assert_in_epsilon":{"type":"method","name":"assert_in_epsilon","children":[],"call":[" assert_in_delta ","(send\n  (lvar :a) :abs) min * ","(send\n  (lvar :a) :abs) min ","b abs ","a abs ","(send\n  (lvar :exp) :abs) min * ","(send\n  (lvar :exp) :abs) min ","act abs ","exp abs "]}," Minitest Assertions assert_in_delta":{"type":"method","name":"assert_in_delta","children":[],"call":[" assert ","delta >= "," message ","(send\n  (lvar :exp) :-\n  (lvar :act)) abs ","exp - ","(se(send\n  (lvar :exp) :-\n  (lvar :act)) abs d\n  (lvar :exp) :-\n  (lvar :act)) abs "]}," Minitest Assertions assert_equal":{"type":"method","name":"assert_equal","children":[],"call":[" assert ","exp == "," diff "," message ","$stderr puts "," caller first "," caller "," refute_nil ","Minitest VERSION  =~ ","exp nil? "," warn ","where split first ","where split ","Minitest  filter_backtrace first ","Minitest  filter_backtrace "," == ","where split first  split first ","Minitest  filter_backtrace first  split first ","where split first  split ","Minitest  filter_backtrace first  split "]}," Minitest Assertions assert_empty":{"type":"method","name":"assert_empty","children":[],"call":[" assert ","obj empty? "," assert_respond_to "," mu_pp "," message "]}," Minitest Assertions assert":{"type":"method","name":"assert","children":[],"call":[" raise ","msg call ","Proc  === "," assertions "," mu_pp ","msg call  call "]}," Minitest Assertions mu_pp_for_diff":{"type":"method","name":"mu_pp_for_diff","children":[],"call":[" mu_pp gsub gsub "," mu_pp gsub "," mu_pp ","str gsub gsub ","str gsub ","s == "," lambda ","single ^ ","str match? ","str match ! ! ","str match ! ","str match "," mu_pp  gsub gsub "," mu_pp  gsub ","str match?  ^ ","str match ! !  ^ "," mu_pp  match? "," mu_pp  match ! ! "," mu_pp  match ! "," mu_pp  match "]}," Minitest Assertions mu_pp":{"type":"method","name":"mu_pp","children":[],"call":["s encode ","Encoding  default_external ","obj inspect ","obj encoding ","obj encoding != ","String  === ","obj valid_encoding? ","obj valid_encoding? ! ","s encode  encode ","obj inspect  encode ","obj ins encode pect ","obj inobj inspect pect "]}," Minitest Assertions diff":{"type":"method","name":"diff","children":[],"call":["(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :klass))\n  (str \"#inspect output.\\n\")) join ","exp class ","result empty? ","result sub! ","b path ","a path ","Minitest Assertions  diff ","b flush ","b puts ","Tempfile  open ","a flush ","a puts "," mu_pp ","expect == ","butwas size > ","butwas size ","expect size > ","expect size ","butwas include? ","expect include? "," mu_pp_for_diff "," require ","b1 ^ ","e1 ^ "," things_to_diff ","(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :exp class ))\n  (str \"#inspect output.\\n\")) join ","(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :klass))\n  (str \"#inspect output.\\n\")) join  empty? ","(dstr\n  (str \"No visible difference in the \")\n  (begin\n    (lvar :klass))\n  (str \"#inspect output.\\n\")) join  sub! "," mu_pp_for_diff  == "," mu_pp_for_diff  size > "," mu_pp_for_diff  size "," mu_pp_for_diff  include? "]}," Minitest Assertions diff=":{"type":"method","name":"diff=","children":[],"call":[]}," Minitest Assertions inspect":{"type":"method","name":"inspect","children":[],"call":[]}," Minitest Runnable marshal_load":{"type":"method","name":"marshal_load","children":[],"call":[" assertions= "," failures= "," name= "," time= "]}," Minitest Runnable marshal_dump":{"type":"method","name":"marshal_dump","children":[],"call":[" assertions "," failures "," name "," time "," warn ","(str \"Minitest::Test#marshal_dump is deprecated.\") join "," caller first "," caller ","(str \"Minitest::Runnable#marshal_dump is deprecated.\") join "]}," Minitest Test marshal_load":{"type":"method","name":"marshal_load","children":[],"call":[" time= ","ary pop "]}," Minitest Test marshal_dump":{"type":"method","name":"marshal_dump","children":[],"call":[" << "," time "]}," Minitest Reporter to_s":{"type":"method","name":"to_s","children":[],"call":["(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join ","\n%3d) %s % ","i + ","filtered_results each_with_index map ","filtered_results each_with_index ","filtered_results reject! "," options [] "," options "," results dup "," results ","(send\n  (send\n    (lvar : results dup ) :each_with_index) :map) join "," results dup  each_with_index map "," results dup  each_with_index "," results dup  reject! "]}," Minitest Runnable on_signal":{"type":"method","name":"on_signal","children":[],"call":[]}," Minitest Runnable with_info_handler":{"type":"method","name":"with_info_handler","children":[],"call":[]}," Minitest SummaryReporter summary":{"type":"method","name":"summary","children":[],"call":["%d runs, %d assertions, %d failures, %d errors, %d skips % "," skips "," errors "," failures "," assertions "," count ","%d runs, %d assertions, %d failures, %d errors, %d skips%s % "," results any? "," results ","ENV  [] "," options [] "," options "]}," Minitest SummaryReporter aggregated_results":{"type":"method","name":"aggregated_results","children":[],"call":["(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ","(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join ","\n%3d) %s % ","i + ","filtered_results each_with_index map ","filtered_results each_with_index ","filtered_results reject! "," options [] "," options "," results dup "," results ","s force_encoding "," io external_encoding "," io ","s encoding != ","s encoding ","io puts ","skip include? ","result result_code ","(send\n  (send\n    (lvar : results dup ) :each_with_index) :map) join + ","((send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + end\n  ((send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + end\n    (lvar :filtered_re(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ult(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ) :each_with_index) :map) join + ","(send\n  (send\n    (lvar : results dup ) :each_with_index) :map) join ","((send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + end\n  ((send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + end\n    (lvar :filtered_re(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ult(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ) :each_with_index) :map) join ","\n%3d) %(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  % "," results dup  each_with_index map ","filtered_re(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ult(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  each_with_index map "," results dup  each_with_index ","filtered_re(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ult(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  each_with_index "," results dup  reject! ","filtered_re(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ult(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  reject! "," option(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  [] "," option(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  "," re(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ult(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  dup "," re(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ult(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  ","(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  force_encoding ","(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  encoding != ","(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  encoding ","io put(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join +  ","(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + kip include? ","re(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ult re(send\n  (send\n    (lvar :filtered_results) :each_with_index) :map) join + ult_code "]}," Minitest SummaryReporter statistics":{"type":"method","name":"statistics","children":[],"call":["Finished in %.6fs, %.4f runs/s, %.4f assertions/s. % "," assertions / "," total_time "," assertions "," count / "," count "]}," Minitest SummaryReporter report":{"type":"method","name":"report","children":[],"call":[" io puts "," summary "," io "," aggregated_results "," statistics "," io sync= "," old_sync "," options [] "," options "]}," Minitest SummaryReporter start":{"type":"method","name":"start","children":[],"call":[" io sync "," io "," io sync= "," old_sync= "," sync "," sync= "," io respond_to? "," io puts "," options [] "," options "]}," Minitest StatisticsReporter report":{"type":"method","name":"report","children":[],"call":[" skips= ","aggregate [] size ","aggregate [] "," errors= "," failures= "," total_time= ","Time  now - "," start_time ","Time  now ","aggregate default= ","r failure class ","r failure "," results group_by "," results ","Minitest  clock_time - ","Minitest  clock_time "]}," Minitest StatisticsReporter record":{"type":"method","name":"record","children":[],"call":[" results << "," results ","result skipped? ","result passed? ! ","result passed? ","result assertions "," assertions "," count "]}," Minitest StatisticsReporter start":{"type":"method","name":"start","children":[],"call":[" start_time= ","Time  now ","Minitest  clock_time "]}," Minitest StatisticsReporter passed?":{"type":"method","name":"passed?","children":[],"call":[" results all? "," results "]}," Minitest StatisticsReporter initialize":{"type":"method","name":"initialize","children":[],"call":[" skips= "," errors= "," failures= "," total_time= "," start_time= "," results= "," count= "," assertions= "]}," Minitest ProgressReporter record":{"type":"method","name":"record","children":[],"call":[" io puts "," io "," options [] "," options "," io print ","result result_code ","%s#%s = %.2f s =  % ","result time ","result name ","result class ","%.2f s =  % "]}," Minitest AbstractReporter passed?":{"type":"method","name":"passed?","children":[],"call":[]}," Minitest AbstractReporter report":{"type":"method","name":"report","children":[],"call":[]}," Minitest AbstractReporter record":{"type":"method","name":"record","children":[],"call":[]}," Minitest AbstractReporter start":{"type":"method","name":"start","children":[],"call":[]}," Minitest run_one_method":{"type":"method","name":"run_one_method","children":[],"call":[]}," Minitest Runnable run_one_method":{"type":"method","name":"run_one_method","children":[],"call":[]}," Minitest Parallel Test ClassMethods test_order":{"type":"method","name":"test_order","children":[],"call":[]}," Minitest Parallel Test ClassMethods run_one_method":{"type":"method","name":"run_one_method","children":[],"call":["MiniTest  parallel_executor << ","MiniTest  parallel_executor ","Minitest  parallel_executor << ","Minitest  parallel_executor "]}," Minitest Parallel Test _synchronize":{"type":"method","name":"_synchronize","children":[],"call":["Test  io_lock synchronize ","Test  io_lock ","Minitest Test  io_lock synchronize ","Minitest Test  io_lock "]}," Minitest Parallel Executor shutdown":{"type":"method","name":"shutdown","children":[],"call":["@pool each ","@queue << "," size times "," size "]}," Minitest Parallel Executor <<":{"type":"method","name":"<<","children":[],"call":["@queue << "]}," Minitest Parallel Executor initialize":{"type":"method","name":"initialize","children":[],"call":["reporter record ","reporter synchronize ","Minitest  run_one_method ","queue pop ","Thread  current abort_on_exception= ","Thread  current ","Thread  new ","size times map ","size times ","Queue  new "]}," Minitest Assertions _synchronize":{"type":"method","name":"_synchronize","children":[],"call":[]}," Minitest clock_time":{"type":"method","name":"clock_time","children":[],"call":[]}," Minitest CompositeReporter prerecord":{"type":"method","name":"prerecord","children":[],"call":["reporter prerecord "," reporters each "," reporters ","reporter respond_to? "]}," Minitest CompositeReporter io":{"type":"method","name":"io","children":[],"call":[" reporters first io "," reporters first "," reporters "]}," Minitest ProgressReporter prerecord":{"type":"method","name":"prerecord","children":[],"call":[" io flush "," io "," io print ","%s#%s =  % "," options [] "," options ","klass name "]}," Minitest AbstractReporter prerecord":{"type":"method","name":"prerecord","children":[],"call":[]}," Spec DSL extended":{"type":"method","name":"extended","children":[],"call":[]}," Spec DSL InstanceMethods before_setup":{"type":"method","name":"before_setup","children":[],"call":["Thread  current []= ","Thread  current "]}," Spec DSL InstanceMethods _":{"type":"method","name":"_","children":[],"call":["Minitest Expectation  new "]}," Minitest Parallel Executor start":{"type":"method","name":"start","children":[],"call":["reporter record ","reporter synchronize ","Minitest  run_one_method ","queue pop ","Thread  current abort_on_exception= ","Thread  current ","Thread  new "," size times map "," size times "," size ","reporter prerecord "]}," Assertions assert_mock":{"type":"method","name":"assert_mock","children":[],"call":[" assert ","mock verify "]}," Minitest minitest?":{"type":"method","name":"minitest?","children":[],"call":[" name == "," name "]}," Minitest SummaryReporter binary_string":{"type":"method","name":"binary_string","children":[],"call":[" force_encoding "," b "]}," Minitest SummaryReporter to_s":{"type":"method","name":"to_s","children":[],"call":[" aggregated_results string "," aggregated_results ","StringIO  new "," binary_string "," b "]}," Minitest Result to_s":{"type":"method","name":"to_s","children":[],"call":["(send\n  (send nil :failures) :map) join ","failure message "," location ","failure result_label "," failures map "," failures "," skipped? ! "," skipped? "," passed? "]}," Minitest Result skipped?":{"type":"method","name":"skipped?","children":[],"call":["Skip  === "," failure "]}," Minitest Result result_code":{"type":"method","name":"result_code","children":[],"call":[" failure result_code "," failure "]}," Minitest Result passed?":{"type":"method","name":"passed?","children":[],"call":[" failure ! "," failure "]}," Minitest Result location":{"type":"method","name":"location","children":[],"call":[" name "," klass "," failure location "," failure "," error? "," passed? "]}," Minitest Result error?":{"type":"method","name":"error?","children":[],"call":["UnexpectedError  === "," failures any? "," failures "]}," Minitest Result from":{"type":"method","name":"from","children":[],"call":[]}," Minitest Runnable time_it":{"type":"method","name":"time_it","children":[],"call":[" time= ","Minitest  clock_time - ","Minitest  clock_time "]}," Minitest BenchSpec bench_performance_power":{"type":"method","name":"bench_performance_power","children":[],"call":[]}," Minitest BenchSpec bench_performance_logarithmic":{"type":"method","name":"bench_performance_logarithmic","children":[],"call":[]}," Minitest Result class_name":{"type":"method","name":"class_name","children":[],"call":[" klass "]}," Minitest Reportable skipped?":{"type":"method","name":"skipped?","children":[],"call":["Skip  === "," failure "]}," Minitest Reportable result_code":{"type":"method","name":"result_code","children":[],"call":[" failure result_code "," failure "]}," Minitest Reportable class_name":{"type":"method","name":"class_name","children":[],"call":[" raise "]}," Minitest Reportable location":{"type":"method","name":"location","children":[],"call":[" name "," class_name "," failure location "," failure "," error? "," passed? "]}," Minitest Reportable passed?":{"type":"method","name":"passed?","children":[],"call":[" failure ! "," failure "]}," Minitest Test class_name":{"type":"method","name":"class_name","children":[],"call":[" class name "," class "]}," Minitest Reportable error?":{"type":"method","name":"error?","children":[],"call":["UnexpectedError  === "," failures any? "," failures "]}," Minitest Guard osx?":{"type":"method","name":"osx?","children":[],"call":[]}," Minitest Assertions skip_until":{"type":"method","name":"skip_until","children":[],"call":[" warn ","Stale skip_until %p at %s % "," caller first split first join "," caller first split first "," caller first split "," caller first "," caller "," skip ","Time  now < ","Time  local ","Time  now "," caller first rpartition reject first "," caller first rpartition reject "," caller first rpartition "]}," Minitest Assertions refute_path_exists":{"type":"method","name":"refute_path_exists","children":[],"call":[" refute ","File  exist? "," message "]}," Minitest Assertions fail_after":{"type":"method","name":"fail_after","children":[],"call":[" flunk ","Time  now > ","Time  local ","Time  now "]}," Minitest Assertions assert_path_exists":{"type":"method","name":"assert_path_exists","children":[],"call":[" assert ","File  exist? "," message "]}," Minitest Assertions things_to_diff":{"type":"method","name":"things_to_diff","children":[],"call":["Minitest Assertions  diff ","expect == ","butwas size > ","butwas size ","expect size > ","expect size ","b1 ^ ","e1 ^ ","butwas include? ","expect include? "," mu_pp_for_diff "," mu_pp_for_diff  == "," mu_pp_for_diff  size > "," mu_pp_for_diff  size "," mu_pp_for_diff  include? "]}," Minitest Test sanitize_exception":{"type":"method","name":"sanitize_exception","children":[],"call":["e set_backtrace ","RuntimeError  new ","e message ","e class ","e backtrace ","Marshal  dump "," neuter_exception ","RuntimeError  new  sRuntimeError  new t_backtracRuntimeError  new  ","RuntimRuntimeError  new Error  nRuntimeError  new w ","RuntimeError  new  mRuntimeError  new ssagRuntimeError  new  ","RuntimeError  new  class ","RuntimeError  new  backtracRuntimeError  new  "," nRuntimeError  new utRuntimeError  new r_RuntimeError  new xcRuntimeError  new ption "]}," Minitest cattr_accessor":{"type":"method","name":"cattr_accessor","children":[],"call":[]}," Integer threads_do":{"type":"method","name":"threads_do","children":[],"call":["(send\n  (send\n    (self) :times) :map) each ","q pop ","Thread  new "," times map "," times ","Work  new "," require ","Work  new  pop "," reWork  new uire "]}," Work initialize":{"type":"method","name":"initialize","children":[],"call":[" close "," << ","jobs each "]}," Minitest TestTask make_test_cmd":{"type":"method","name":"make_test_cmd","children":[],"call":["args join ","args << "," extra_args map "," extra_args "," warning "," libs join "," libs "," libs empty? ","runner join ","runner concat ","runner << "," framework "," test_prelude ","tests map! ","tests concat ","Dir  [] sort shuffle ","Dir  [] sort ","Dir  [] ","runner join  join ","runner join  concat ","runner join  << "]}," Minitest TestTask define":{"type":"method","name":"define","children":[],"call":[" task "," desc ","default_tasks << "," name "," sh ","(dstr\n  (str \"rake \")\n  (begin\n    (send nil :name))\n  (str \" TESTOPTS=-v\")) join "," exit "," puts ","bad sort each ","bad sort ","%.2fs: %s % ","times [] ","bad keys sort each ","bad keys sort ","bad keys ","bad empty? ","good sort each ","good sort ","good empty? ","io puts ","JSON  pretty_generate ","File  open "," require ","Ran in %.2f seconds % ","Time  now - ","Time  now ","bad []= ","$stderr print ","good << ","$? success? ","times []= "," make_test_cmd ","Gem  ruby ","n threads_do ","tests sort ","ENV  delete ","(or\n  (send\n    (const nil :ENV) :delete\n    (str \"K\"))\n  (int 3)) to_i ","Dir  [] uniq ","Dir  [] "," test_globs "," ruby "," verbose ","(dstr\n  (str \"rake \")\n  (begin\n    (send nil :name))\n  (str \" A=-v\")) join ","Dir  [] uniq  sort "]}," Minitest TestTask process_env":{"type":"method","name":"process_env","children":[],"call":[" extra_args compact! "," extra_args ","ENV  delete ","ENV  [] "," extra_args concat ","Shellwords  split "," extra_args << << "," extra_args << "," libs []= "," libs ","(or\n  (send\n    (const nil :ENV) :[]\n    (str \"MT_LIB_EXTRAS\"))\n  (str \"\")) split "," warn ","ENV  [] to_i > ","ENV  [] to_i "]}," Minitest TestTask initialize":{"type":"method","name":"initialize","children":[],"call":[" warning= "," verbose= ","Rake  application options trace ","Rake  application options ","Rake  application "," test_prelude= "," test_globs= "," name= "," libs= "," framework= "," extra_args= "]}," Minitest TestTask create":{"type":"method","name":"create","children":[],"call":[]}," Minitest Test new_exception":{"type":"method","name":"new_exception","children":[],"call":["Marshal  dump ","ne set_backtrace ","klass new ","ne remove_instance_variable ","ne instance_variables each ","ne instance_variables ","klass new  set_backtrace ","klass klass new w ","klass new  remove_instance_variable ","klass new  instance_variables each ","klass new  instance_variables "]}," Minitest Test neuter_exception":{"type":"method","name":"neuter_exception","children":[],"call":[" new_exception ","msg prepend ","e class ","e message dup ","e message ","e backtrace ","e message dup  prepend "]}," Minitest Assertions refute_pattern":{"type":"method","name":"refute_pattern","children":[],"call":[" pass "," flunk "," block_given? "," raise ","RUBY_VERSION  >= "]}," Minitest Assertions assert_pattern":{"type":"method","name":"assert_pattern","children":[],"call":[" flunk ","e message "," pass "," block_given? "," raise ","RUBY_VERSION  >= "]}," Minitest Runnable test_order":{"type":"method","name":"test_order","children":[],"call":[]}," Minitest Runnable metadata?":{"type":"method","name":"metadata?","children":[],"call":[]}," Minitest Runnable metadata":{"type":"method","name":"metadata","children":[],"call":[]}," Expectations _":{"type":"method","name":"_","children":[],"call":["Minitest Expectation  new "]}}