{" Faker numerify":{"type":"method","name":"numerify","children":[],"call":[]}," Faker PhoneNumber phone_number":{"type":"method","name":"phone_number","children":[],"call":["Faker  numerify ","Formats  at_rand ","Formats  rand ","I18n  translate rand ","I18n  translate "," numerify "," fetch "," parse "," parse == "]}," Faker Name suffix":{"type":"method","name":"suffix","children":[],"call":["(str \"Jr.\") at_rand ","(str \"Jr.\") rand "," fetch "]}," Faker Name prefix":{"type":"method","name":"prefix","children":[],"call":["(str \"Mr.\") at_rand ","(str \"Mr.\") rand "," fetch "]}," Faker Name last_name":{"type":"method","name":"last_name","children":[],"call":["(str \"Abbott\") at_rand ","(str \"Abbott\") rand "," fetch "," parse "]}," Faker Name first_name":{"type":"method","name":"first_name","children":[],"call":["(str \"Aaliyah\") at_rand ","(str \"Aaliyah\") rand "," fetch "," parse "," parse empty? "]}," Faker Name name":{"type":"method","name":"name","children":[],"call":["Formats  at_rand call join ","Formats  at_rand call ","Formats  at_rand ","Formats  rand call join ","Formats  rand call ","Formats  rand ","(send\n  (send\n    (send\n      (const nil :I18n) :translate\n      (str \"name.formats\")) :rand) :collect) join "," send ","I18n  translate rand collect ","I18n  translate rand ","I18n  translate ","(send\n  (send\n    (send\n      (const nil :I18n) :translate\n      (str \"faker.name.formats\")) :rand) :collect) join ","(send\n  (send nil :fetch\n    (str \"name.formats\")) :collect) join "," fetch collect "," fetch "," parse "]}," Faker Internet domain_suffix":{"type":"method","name":"domain_suffix","children":[],"call":["(str \"co.uk\") at_rand ","(str \"co.uk\") rand ","I18n  translate rand ","I18n  translate "," fetch "]}," Faker Internet domain_word":{"type":"method","name":"domain_word","children":[],"call":["Company  name split first gsub downcase ","Company  name split first gsub ","Company  name split first ","Company  name split ","Company  name ","Char  prepare ","Company  name split [] ","(str \"uk\") include? ","Config  locale ","Config  locale == "," with_locale "]}," Faker Internet domain_name":{"type":"method","name":"domain_name","children":[],"call":["(send nil :domain_word) join "," domain_suffix "," domain_word ","(send nil :fix_umlauts\n  (send nil :domain_word)) join "," fix_umlauts ","(send\n  (const nil :Char) :prepare\n  (send nil :domain_word)) join ","Char  prepare ","I18n  with_locale "," with_locale ","domain_elements join ","domain_elements unshift ","(send\n  (array\n    (send nil :domain_word)\n    (send nil :domain_suffix)) :tap) join ","(send nil :domain_word) tap ","(send\n  (block\n    (send\n      (send\n        (lvar :domain) :split\n        (str \".\")) :map)\n    (args\n      (arg :domain_part))\n    (send\n      (const nil :Char) :prepare\n      (lvar :domain_part))) :tap) join ","domain_elements length < ","domain_elements length ","domain_elements << ","(send\n  (send\n    (lvar :domain) :split\n    (str \".\")) :map) tap ","domain split map ","domain split ","keywords << ","legacy_subdomain != "," warn_for_deprecated_arguments "," warn_with_uplevel ","(send\n  (array\n    (send nil :domain_word)\n    (send nil :domain_suffix\n      (hash\n        (pair\n          (sym :safe)\n          (true))))) :tap) join "]}," Faker Internet user_name":{"type":"method","name":"user_name","children":[],"call":["(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (send\n      (send\n        (const nil :Name) :first_name) :gsub\n      (regexp\n        (str \"\\\\W\")\n        (regopt))\n      (str \"\")) :downcase)) at_rand call ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (send\n      (send\n        (const nil :Name) :first_name) :gsub\n      (regexp\n        (str \"\\\\W\")\n        (regopt))\n      (str \"\")) :downcase)) at_rand ","(send\n  (array\n    (send\n      (const nil :Name) :first_name)\n    (send\n      (const nil :Name) :last_name)) :map) join downcase ","(send\n  (array\n    (send\n      (const nil :Name) :first_name)\n    (send\n      (const nil :Name) :last_name)) :map) join ","n gsub ","(send\n  (const nil :Name) :first_name) map ","Name  last_name ","Name  first_name ","Proc  new ","Name  first_name gsub downcase ","Name  first_name gsub ","name scan shuffle join ","name scan shuffle ","name scan ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (send\n      (send\n        (const nil :Name) :first_name) :gsub\n      (regexp\n        (str \"\\\\W\")\n        (regopt))\n      (str \"\")) :downcase)) rand call ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (send\n      (send\n        (const nil :Name) :first_name) :gsub\n      (regexp\n        (str \"\\\\W\")\n        (regopt))\n      (str \"\")) :downcase)) rand ","(str \".\") rand ","name scan shuffle join downcase "," fix_umlauts ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (send\n      (send\n        (const nil :Name) :first_name) :gsub\n      (regexp\n        (str \"\\\\W\")\n        (regopt))\n      (str \"\")) :downcase)) sample call ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (send\n      (send\n        (const nil :Name) :first_name) :gsub\n      (regexp\n        (str \"\\\\W\")\n        (regopt))\n      (str \"\")) :downcase)) sample ","(str \".\") sample ","separators sample ","result [] ","specifier max "," user_name ","specifier min ","tries < ","specifier include? ! ","specifier include? ","result length ","specifier kind_of? ","result * ","result length >= ","result length < ","specifier scan shuffle join downcase ","specifier scan shuffle join ","specifier scan shuffle ","specifier scan ","(send\n  (const nil :Char) :prepare\n  (send\n    (const nil :Name) :first_name)) sample ","Char  prepare ","I18n  with_locale "," with_locale ","specifier / + ","specifier / ","specifier > "," raise ","10 ** ","specifier respond_to? "," sample "," user_name  [] ","result *  [] "," user_name  length ","result *  length "," user_name  * ","result *  * "," user_name  length >= ","result *  length >= "," user_name  length < ","result *  length < "]}," Faker Internet free_email":{"type":"method","name":"free_email","children":[],"call":["(send nil :user_name\n  (lvar :name)) join ","(str \"gmail.com\") at_rand "," user_name ","(str \"gmail.com\") rand ","I18n  translate rand ","I18n  translate "," fetch ","(send nil :username\n  (lvar :name)) join "," username ","(send nil :username\n  (hash\n    (pair\n      (sym :specifier)\n      (lvar :name)))) join ","keywords << ","legacy_name != "," warn_for_deprecated_arguments "," construct_email "," sanitize_email_local_part "," warn_with_uplevel "]}," Faker Internet email":{"type":"method","name":"email","children":[],"call":["(send nil :user_name\n  (lvar :name)) join "," domain_name "," user_name ","(send nil :username\n  (lvar :name)) join "," username ","(send nil :username\n  (lvar :name)\n  (lvar :separators)) join ","(send nil :username\n  (hash\n    (pair\n      (sym :specifier)\n      (lvar :name)))) join ","(send nil :username\n  (hash\n    (pair\n      (sym :specifier)\n      (lvar :name))\n    (pair\n      (sym :separators)\n      (lvar :separators)))) join ","keywords << ","legacy_separators != ","legacy_name != "," warn_for_deprecated_arguments "," construct_email "," sanitize_email_local_part "," warn_with_uplevel ","domain nil? "," sanitize_email_ username  "]}," Faker Company suffix":{"type":"method","name":"suffix","children":[],"call":["(str \"Inc\") at_rand ","(str \"Inc\") rand ","I18n  translate rand ","I18n  translate "," fetch "]}," Faker Company name":{"type":"method","name":"name","children":[],"call":["Formats  at_rand call ","Formats  at_rand ","Formats  rand call ","Formats  rand "," parse "]}," Faker Address street_address":{"type":"method","name":"street_address","children":[],"call":["Faker  numerify ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (str \"##### %s\") :%\n    (send nil :street_name))) at_rand call ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (str \"##### %s\") :%\n    (send nil :street_name))) at_rand ","##### %s Suite ### % "," street_name ","Proc  new ","##### %s Apt. ### % ","##### %s % ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (str \"##### %s\") :%\n    (send nil :street_name))) rand call ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (str \"##### %s\") :%\n    (send nil :street_name))) rand ","(send\n  (str \"##### %s\") :%\n  (send nil :street_name)) rand + ","  + "," secondary_address ","(send\n  (str \"##### %s\") :%\n  (send nil :street_name)) rand ","### %s % ","#### %s % ","I18n  translate rand ","I18n  translate "," numerify "," fetch "," parse + "," parse ","keywords << ","legacy_include_secondary != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Address street_name":{"type":"method","name":"street_name","children":[],"call":["(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (array\n      (send\n        (const nil :Name) :last_name)\n      (send nil :street_suffix)) :join\n    (str \" \"))) at_rand call ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (array\n      (send\n        (const nil :Name) :last_name)\n      (send nil :street_suffix)) :join\n    (str \" \"))) at_rand ","(send\n  (const nil :Name) :first_name) join "," street_suffix ","Name  first_name ","Proc  new ","(send\n  (const nil :Name) :last_name) join ","Name  last_name ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (array\n      (send\n        (const nil :Name) :last_name)\n      (send nil :street_suffix)) :join\n    (str \" \"))) rand call ","(block\n  (send\n    (const nil :Proc) :new)\n  (args)\n  (send\n    (array\n      (send\n        (const nil :Name) :last_name)\n      (send nil :street_suffix)) :join\n    (str \" \"))) rand "," parse "]}," Faker Address street_suffix":{"type":"method","name":"street_suffix","children":[],"call":["(str \"Alley\") at_rand ","(str \"Alley\") rand "," fetch "]}," Faker Address us_state_abbr":{"type":"method","name":"us_state_abbr","children":[],"call":["(str \"AL\") at_rand ","(str \"AL\") rand "]}," Faker Address us_state":{"type":"method","name":"us_state","children":[],"call":["(str \"Alabama\") at_rand ","(str \"Alabama\") rand "]}," Faker Address zip_code":{"type":"method","name":"zip_code","children":[],"call":["Faker  numerify ","(str \"#####\") at_rand ","(str \"#####\") rand ","Faker  bothify upcase ","Faker  bothify ","I18n  translate rand ","I18n  translate "," bothify upcase "," bothify "," fetch ","address.postcode_by_state. + ","state_abbreviation === "," numerify "," letterify ","state_abbreviation empty? ","keywords << ","legacy_state_abbreviation != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Array shuffle!":{"type":"method","name":"shuffle!","children":[],"call":[" []= ","j + "," [] ","Kernel  rand ","s - "," each_index "," size "," size  - "," each_Kernel  rand ndex "," sKernel  rand ze ","  size ize "]}," Array shuffle":{"type":"method","name":"shuffle","children":[],"call":[" dup shuffle! "," dup ","Kernel  rand "," sort_by "]}," Array rand_subset":{"type":"method","name":"rand_subset","children":[],"call":[" values_at ","ri << "," rand "," size ","number times ","(send nil :sort_by) slice "," sort_by ","number to_int ","number to_int  times "," rand  times ","number to_int  to_int "," rand  to_int "]}," Array rand_index":{"type":"method","name":"rand_index","children":[],"call":[" rand "," size "]}," Array pick!":{"type":"method","name":"pick!","children":[],"call":[" delete_at ","Kernel  rand "," size ","r << ","n times "," replace "," dup ","n > ","Ke dup nel   dup and "," dup  << ","  dup eplace "]}," Array pick":{"type":"method","name":"pick","children":[],"call":[" at ","Kernel  rand "," size ","a pick! "," dup ","  dup t ","Kernel  r dup nd "," dup  pick! "]}," Array at_rand!":{"type":"method","name":"at_rand!","children":[],"call":[" delete_at ","Kernel  rand "," size "]}," Array at_rand":{"type":"method","name":"at_rand","children":[],"call":[" at "," rand "," size "]}," Faker Company bs":{"type":"method","name":"bs","children":[],"call":["(send\n  (array\n    (str \"implement\")\n    (str \"utilize\")\n    (str \"integrate\")\n    (str \"streamline\")\n    (str \"optimize\")\n    (str \"evolve\")\n    (str \"transform\")\n    (str \"embrace\")\n    (str \"enable\")\n    (str \"orchestrate\")\n    (str \"leverage\")\n    (str \"reinvent\")\n    (str \"aggregate\")\n    (str \"architect\")\n    (str \"enhance\")\n    (str \"incentivize\")\n    (str \"morph\")\n    (str \"empower\")\n    (str \"envisioneer\")\n    (str \"monetize\")\n    (str \"harness\")\n    (str \"facilitate\")\n    (str \"seize\")\n    (str \"disintermediate\")\n    (str \"synergize\")\n    (str \"strategize\")\n    (str \"deploy\")\n    (str \"brand\")\n    (str \"grow\")\n    (str \"target\")\n    (str \"syndicate\")\n    (str \"synthesize\")\n    (str \"deliver\")\n    (str \"mesh\")\n    (str \"incubate\")\n    (str \"engage\")\n    (str \"maximize\")\n    (str \"benchmark\")\n    (str \"expedite\")\n    (str \"reintermediate\")\n    (str \"whiteboard\")\n    (str \"visualize\")\n    (str \"repurpose\")\n    (str \"innovate\")\n    (str \"scale\")\n    (str \"unleash\")\n    (str \"drive\")\n    (str \"extend\")\n    (str \"engineer\")\n    (str \"revolutionize\")\n    (str \"generate\")\n    (str \"exploit\")\n    (str \"transition\")\n    (str \"e-enable\")\n    (str \"iterate\")\n    (str \"cultivate\")\n    (str \"matrix\")\n    (str \"productize\")\n    (str \"redefine\")\n    (str \"recontextualize\")) :at_rand) join ","(str \"synergies\") at_rand ","(str \"clicks-and-mortar\") at_rand ","(str \"implement\") at_rand ","(send\n  (array\n    (str \"implement\")\n    (str \"utilize\")\n    (str \"integrate\")\n    (str \"streamline\")\n    (str \"optimize\")\n    (str \"evolve\")\n    (str \"transform\")\n    (str \"embrace\")\n    (str \"enable\")\n    (str \"orchestrate\")\n    (str \"leverage\")\n    (str \"reinvent\")\n    (str \"aggregate\")\n    (str \"architect\")\n    (str \"enhance\")\n    (str \"incentivize\")\n    (str \"morph\")\n    (str \"empower\")\n    (str \"envisioneer\")\n    (str \"monetize\")\n    (str \"harness\")\n    (str \"facilitate\")\n    (str \"seize\")\n    (str \"disintermediate\")\n    (str \"synergize\")\n    (str \"strategize\")\n    (str \"deploy\")\n    (str \"brand\")\n    (str \"grow\")\n    (str \"target\")\n    (str \"syndicate\")\n    (str \"synthesize\")\n    (str \"deliver\")\n    (str \"mesh\")\n    (str \"incubate\")\n    (str \"engage\")\n    (str \"maximize\")\n    (str \"benchmark\")\n    (str \"expedite\")\n    (str \"reintermediate\")\n    (str \"whiteboard\")\n    (str \"visualize\")\n    (str \"repurpose\")\n    (str \"innovate\")\n    (str \"scale\")\n    (str \"unleash\")\n    (str \"drive\")\n    (str \"extend\")\n    (str \"engineer\")\n    (str \"revolutionize\")\n    (str \"generate\")\n    (str \"exploit\")\n    (str \"transition\")\n    (str \"e-enable\")\n    (str \"iterate\")\n    (str \"cultivate\")\n    (str \"matrix\")\n    (str \"productize\")\n    (str \"redefine\")\n    (str \"recontextualize\")) :rand) join ","(str \"synergies\") rand ","(str \"clicks-and-mortar\") rand ","(str \"implement\") rand ","(send\n  (send nil :translate\n    (str \"faker.company.bs\")) :collect) join ","list sample "," translate collect "," translate "," sample "]}," Faker Company catch_phrase":{"type":"method","name":"catch_phrase","children":[],"call":["(send\n  (array\n    (str \"Adaptive\")\n    (str \"Advanced\")\n    (str \"Ameliorated\")\n    (str \"Assimilated\")\n    (str \"Automated\")\n    (str \"Balanced\")\n    (str \"Business-focused\")\n    (str \"Centralized\")\n    (str \"Cloned\")\n    (str \"Compatible\")\n    (str \"Configurable\")\n    (str \"Cross-group\")\n    (str \"Cross-platform\")\n    (str \"Customer-focused\")\n    (str \"Customizable\")\n    (str \"Decentralized\")\n    (str \"De-engineered\")\n    (str \"Devolved\")\n    (str \"Digitized\")\n    (str \"Distributed\")\n    (str \"Diverse\")\n    (str \"Down-sized\")\n    (str \"Enhanced\")\n    (str \"Enterprise-wide\")\n    (str \"Ergonomic\")\n    (str \"Exclusive\")\n    (str \"Expanded\")\n    (str \"Extended\")\n    (str \"Face to face\")\n    (str \"Focused\")\n    (str \"Front-line\")\n    (str \"Fully-configurable\")\n    (str \"Function-based\")\n    (str \"Fundamental\")\n    (str \"Future-proofed\")\n    (str \"Grass-roots\")\n    (str \"Horizontal\")\n    (str \"Implemented\")\n    (str \"Innovative\")\n    (str \"Integrated\")\n    (str \"Intuitive\")\n    (str \"Inverse\")\n    (str \"Managed\")\n    (str \"Mandatory\")\n    (str \"Monitored\")\n    (str \"Multi-channelled\")\n    (str \"Multi-lateral\")\n    (str \"Multi-layered\")\n    (str \"Multi-tiered\")\n    (str \"Networked\")\n    (str \"Object-based\")\n    (str \"Open-architected\")\n    (str \"Open-source\")\n    (str \"Operative\")\n    (str \"Optimized\")\n    (str \"Optional\")\n    (str \"Organic\")\n    (str \"Organized\")\n    (str \"Persevering\")\n    (str \"Persistent\")\n    (str \"Phased\")\n    (str \"Polarised\")\n    (str \"Pre-emptive\")\n    (str \"Proactive\")\n    (str \"Profit-focused\")\n    (str \"Profound\")\n    (str \"Programmable\")\n    (str \"Progressive\")\n    (str \"Public-key\")\n    (str \"Quality-focused\")\n    (str \"Reactive\")\n    (str \"Realigned\")\n    (str \"Re-contextualized\")\n    (str \"Re-engineered\")\n    (str \"Reduced\")\n    (str \"Reverse-engineered\")\n    (str \"Right-sized\")\n    (str \"Robust\")\n    (str \"Seamless\")\n    (str \"Secured\")\n    (str \"Self-enabling\")\n    (str \"Sharable\")\n    (str \"Stand-alone\")\n    (str \"Streamlined\")\n    (str \"Switchable\")\n    (str \"Synchronised\")\n    (str \"Synergistic\")\n    (str \"Synergized\")\n    (str \"Team-oriented\")\n    (str \"Total\")\n    (str \"Triple-buffered\")\n    (str \"Universal\")\n    (str \"Up-sized\")\n    (str \"Upgradable\")\n    (str \"User-centric\")\n    (str \"User-friendly\")\n    (str \"Versatile\")\n    (str \"Virtual\")\n    (str \"Visionary\")\n    (str \"Vision-oriented\")) :at_rand) join ","(str \"ability\") at_rand ","(str \"24 hour\") at_rand ","(str \"Adaptive\") at_rand ","(send\n  (array\n    (str \"Adaptive\")\n    (str \"Advanced\")\n    (str \"Ameliorated\")\n    (str \"Assimilated\")\n    (str \"Automated\")\n    (str \"Balanced\")\n    (str \"Business-focused\")\n    (str \"Centralized\")\n    (str \"Cloned\")\n    (str \"Compatible\")\n    (str \"Configurable\")\n    (str \"Cross-group\")\n    (str \"Cross-platform\")\n    (str \"Customer-focused\")\n    (str \"Customizable\")\n    (str \"Decentralized\")\n    (str \"De-engineered\")\n    (str \"Devolved\")\n    (str \"Digitized\")\n    (str \"Distributed\")\n    (str \"Diverse\")\n    (str \"Down-sized\")\n    (str \"Enhanced\")\n    (str \"Enterprise-wide\")\n    (str \"Ergonomic\")\n    (str \"Exclusive\")\n    (str \"Expanded\")\n    (str \"Extended\")\n    (str \"Face to face\")\n    (str \"Focused\")\n    (str \"Front-line\")\n    (str \"Fully-configurable\")\n    (str \"Function-based\")\n    (str \"Fundamental\")\n    (str \"Future-proofed\")\n    (str \"Grass-roots\")\n    (str \"Horizontal\")\n    (str \"Implemented\")\n    (str \"Innovative\")\n    (str \"Integrated\")\n    (str \"Intuitive\")\n    (str \"Inverse\")\n    (str \"Managed\")\n    (str \"Mandatory\")\n    (str \"Monitored\")\n    (str \"Multi-channelled\")\n    (str \"Multi-lateral\")\n    (str \"Multi-layered\")\n    (str \"Multi-tiered\")\n    (str \"Networked\")\n    (str \"Object-based\")\n    (str \"Open-architected\")\n    (str \"Open-source\")\n    (str \"Operative\")\n    (str \"Optimized\")\n    (str \"Optional\")\n    (str \"Organic\")\n    (str \"Organized\")\n    (str \"Persevering\")\n    (str \"Persistent\")\n    (str \"Phased\")\n    (str \"Polarised\")\n    (str \"Pre-emptive\")\n    (str \"Proactive\")\n    (str \"Profit-focused\")\n    (str \"Profound\")\n    (str \"Programmable\")\n    (str \"Progressive\")\n    (str \"Public-key\")\n    (str \"Quality-focused\")\n    (str \"Reactive\")\n    (str \"Realigned\")\n    (str \"Re-contextualized\")\n    (str \"Re-engineered\")\n    (str \"Reduced\")\n    (str \"Reverse-engineered\")\n    (str \"Right-sized\")\n    (str \"Robust\")\n    (str \"Seamless\")\n    (str \"Secured\")\n    (str \"Self-enabling\")\n    (str \"Sharable\")\n    (str \"Stand-alone\")\n    (str \"Streamlined\")\n    (str \"Switchable\")\n    (str \"Synchronised\")\n    (str \"Synergistic\")\n    (str \"Synergized\")\n    (str \"Team-oriented\")\n    (str \"Total\")\n    (str \"Triple-buffered\")\n    (str \"Universal\")\n    (str \"Up-sized\")\n    (str \"Upgradable\")\n    (str \"User-centric\")\n    (str \"User-friendly\")\n    (str \"Versatile\")\n    (str \"Virtual\")\n    (str \"Visionary\")\n    (str \"Vision-oriented\")) :rand) join ","(str \"ability\") rand ","(str \"24 hour\") rand ","(str \"Adaptive\") rand ","(send\n  (send nil :translate\n    (str \"faker.company.buzzwords\")) :collect) join ","list sample "," translate collect "," translate "," sample "]}," Array rand":{"type":"method","name":"rand","children":[],"call":[" [] ","Kernel  rand "," length "]}," Faker bothify":{"type":"method","name":"bothify","children":[],"call":[]}," Faker letterify":{"type":"method","name":"letterify","children":[],"call":[]}," Faker Lorem paragraphs":{"type":"method","name":"paragraphs","children":[],"call":["paragraphs << "," paragraph ","1 upto "," resolve "," tap ","1 upto collect ","keywords << ","legacy_supplemental != "," warn_for_deprecated_arguments ","legacy_number != "," warn_with_uplevel "]}," Faker Lorem paragraph":{"type":"method","name":"paragraph","children":[],"call":[" sentences join "," sentences "," resolve + "," rand "," resolve "," rand to_i ","random_sentences_to_add to_i "," locale_space ","keywords << ","legacy_random_sentences_to_add != ","legacy_supplemental != ","legacy_sentence_count != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Lorem sentences":{"type":"method","name":"sentences","children":[],"call":["sentences << "," sentence ","1 upto "," resolve "," tap ","1 upto collect ","keywords << ","legacy_supplemental != ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Lorem sentence":{"type":"method","name":"sentence","children":[],"call":[" words join capitalize + "," words join capitalize "," words join "," words ","word_count + "," rand "," rand to_i ","random_words_to_add to_i "," locale_period ","keywords << ","legacy_random_words_to_add != ","legacy_supplemental != ","legacy_word_count != "," warn_for_deprecated_arguments "," locale_space "," warn_with_uplevel "]}," Faker Lorem words":{"type":"method","name":"words","children":[],"call":["(send\n  (send nil :translate\n    (str \"faker.lorem.words\")) :+\n  (begin\n    (if\n      (lvar :supplemental)\n      (send nil :translate\n        (str \"faker.lorem.supplemental\"))\n      (array)))) shuffle [] "," resolve ","(send\n  (send nil :translate\n    (str \"faker.lorem.words\")) :+\n  (begin\n    (if\n      (lvar :supplemental)\n      (send nil :translate\n        (str \"faker.lorem.supplemental\"))\n      (array)))) shuffle "," translate + "," translate ","word_list shuffle [] ","word_list shuffle ","word_list * ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar :word_list) :length)) + ","resolved_num / ","word_list length "," shuffle [] "," shuffle ","keywords << ","legacy_supplemental != ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel ","exclude_words split ","exclude_words instance_of? ","word_list *  shuffle [] ","word_list *  shuffle ","word_list *  * ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar :word_list * ) :length)) + ","(send\n  (lvar : resolve ) :/\n  (send\n    (lvar :word_list) :length)) + "," resolve  / ","word_list *  length ","exclude_words split  split ","exclude_words split  instance_of? "]}," Faker Address uk_postcode":{"type":"method","name":"uk_postcode","children":[],"call":["Faker  bothify upcase ","Faker  bothify ","(str \"??# #??\") rand "]}," Faker Address uk_country":{"type":"method","name":"uk_country","children":[],"call":["(str \"England\") rand "]}," Faker Address uk_county":{"type":"method","name":"uk_county","children":[],"call":["(str \"Avon\") rand "," county "]}," Faker Address secondary_address":{"type":"method","name":"secondary_address","children":[],"call":["Faker  numerify ","(str \"Apt. ###\") rand ","I18n  translate rand ","I18n  translate "," numerify "," fetch "," bothify "]}," Object returning":{"type":"method","name":"returning","children":[],"call":[]}," Faker Address city":{"type":"method","name":"city","children":[],"call":["(send\n  (str \"%s %s%s\") :%\n  (array\n    (send nil :city_prefix)\n    (send\n      (const nil :Name) :first_name)\n    (send nil :city_suffix))) rand ","%s%s % "," city_suffix ","Name  last_name ","Name  first_name ","%s %s % "," city_prefix ","%s %s%s % "," parse ","options [] ","keywords << ","legacy_options != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Address city_suffix":{"type":"method","name":"city_suffix","children":[],"call":["(str \"town\") rand "," fetch "]}," Faker Address city_prefix":{"type":"method","name":"city_prefix","children":[],"call":["(str \"North\") rand "," fetch "]}," Faker Config locale=":{"type":"method","name":"locale=","children":[],"call":["Thread  current []= ","Thread  current "]}," Faker Internet ip_v4_address":{"type":"method","name":"ip_v4_address","children":[],"call":["(send\n  (send\n    (begin\n      (irange\n        (int 0)\n        (int 255))) :to_a) :rand) join ","(irange\n  (int 0)\n  (int 255)) to_a rand ","(irange\n  (int 0)\n  (int 255)) to_a ","(send\n  (lvar :ary) :sample) join ","ary sample ","(irange\n  (int 2)\n  (int 254)) to_a ","(send\n  (begin\n    (irange\n      (int 1)\n      (int 4))) :map) join "," rand ","(irange\n  (int 1)\n  (int 4)) map ","(send nil :sample\n  (lvar :ary)) join "," sample ","(send nil :rand_in_range\n  (int 0)\n  (int 255)) join "," rand_in_range ","(send\n  (lvar :(irange\n  (int 2)\n  (int 254)) to_a ) :sample) join ","(irange\n  (int 2)\n  (int 254)) to_a  sample ","(send nil :sample\n  (lvar :(irange\n  (int 2)\n  (int 254)) to_a )) join "]}," Faker Address method_missing":{"type":"method","name":"method_missing","children":[],"call":["translation rand ","translation respond_to? ","I18n  translate [] ","I18n  translate ","I18n  translate [] [] ","I18n  translate []  rand ","I18n  translate [] []  rand ","I18n  translate []  respond_to? ","I18n  translate [] []  respond_to? "]}," Faker Base bothify":{"type":"method","name":"bothify","children":[],"call":[" letterify "," numerify "]}," Faker Base letterify":{"type":"method","name":"letterify","children":[],"call":["(irange\n  (str \"a\")\n  (str \"z\")) to_a rand ","(irange\n  (str \"a\")\n  (str \"z\")) to_a ","letter_string gsub ","(irange\n  (str \"A\")\n  (str \"Z\")) to_a sample ","(irange\n  (str \"A\")\n  (str \"Z\")) to_a ","ULetters  sample "," sample "]}," Faker Base numerify":{"type":"method","name":"numerify","children":[],"call":[" rand to_s "," rand ","number_string gsub ","(send\n  (lvar :number_string) :sub\n  (regexp\n    (str \"#\")\n    (regopt))) gsub ","(send\n  (send nil :rand\n    (int 9)) :+\n  (int 1)) to_s "," rand + ","number_string sub ","(send\n  (lvar :number_string) :sub\n  (str \"#\")) gsub "]}," Faker Base fetch":{"type":"method","name":"fetch","children":[],"call":["I18n  translate rand ","I18n  translate "," translate sample "," translate "," regexify ","fetched match ","fetched sample ","fetched respond_to? "," sample ","fetched sample  match "," translate  match "," sample  match ","fetched sample  sample "," translate  sample "," sample  sample ","fetched sample  respond_to? "," translate  respond_to? "," sample  respond_to? "]}," Faker Address country":{"type":"method","name":"country","children":[],"call":[" fetch "]}," Faker Address state":{"type":"method","name":"state","children":[],"call":[" fetch "]}," Faker Address state_abbr":{"type":"method","name":"state_abbr","children":[],"call":[" fetch "]}," Faker Base method_missing":{"type":"method","name":"method_missing","children":[],"call":["translation sample ","translation respond_to? "," translate [] [] "," translate [] "," translate "," sample "," flexible_key "," translate [] []  sample "," translate  sample "," translate [] []  respond_to? "," translate  respond_to? "]}," Faker Base flexible":{"type":"method","name":"flexible","children":[],"call":[]}," Faker Base translate":{"type":"method","name":"translate","children":[],"call":["I18n  translate ","args push ","opts merge ","opts []= ","Faker Config  locale ","opts [] ","args pop ","args last is_a? ","args last "," disable_enforce_available_locales ","Faker  load_i18n ","args pop  merge ","args pop  []= ","args pop  [] "]}," Faker Base parse":{"type":"method","name":"parse","children":[],"call":["(send\n  (send\n    (send nil :fetch\n      (lvar :key)) :scan\n    (regexp\n      (str \"#\\\\{([A-Za-z]+\\\\.)?([^\\\\}]+)\\\\}([^#]+)?\")\n      (regopt))) :map) join ","(if\n  (lvar :kls)\n  (send\n    (const nil :Faker) :const_get\n    (send\n      (lvar :kls) :chop))\n  (self)) send + ","etc to_s ","(if\n  (lvar :kls)\n  (send\n    (const nil :Faker) :const_get\n    (send\n      (lvar :kls) :chop))\n  (self)) send ","Faker  const_get ","kls chop "," fetch scan map "," fetch scan "," fetch ","meth downcase ","(or\n  (lvar :kls)\n  (self)) to_s split last downcase ","(or\n  (lvar :kls)\n  (self)) to_s split last ","(or\n  (lvar :kls)\n  (self)) to_s split ","(or\n  (lvar :kls)\n  (self)) to_s ","cls send ","cls respond_to? ","(send\n  (send\n    (send nil :fetch\n      (lvar :key)) :scan\n    (regexp\n      (str \"(\\\\(?)#\\\\{([A-Za-z]+\\\\.)?([^\\\\}]+)\\\\}([^#]+)?\")\n      (regopt))) :map) join "," numerify ","parts join ","parts any? ","fetched scan map ","fetched scan ","text + ","cls to_s split last gsub downcase ","cls to_s split last gsub ","cls to_s split last ","cls to_s split ","cls to_s ","Faker  const_get  send ","Faker  const_get  respond_to? "," fetch  scan map "," fetch  scan "," fetch  + ","cls send  + ","Faker  const_get  to_s split last gsub downcase ","Faker  const_get  to_s split last gsub ","Faker  const_get  to_s split last ","Faker  const_get  to_s split ","Faker  const_get  to_s "]}," Faker Config locale":{"type":"method","name":"locale","children":[],"call":["I18n  locale ","I18n  locale downcase ","I18n  available_locales first ","I18n  available_locales ","I18n  available_locales include? ","Faker  load_i18n ","Thread  current [] ","Thread  current "]}," Faker PhoneNumber cell_phone":{"type":"method","name":"cell_phone","children":[],"call":[" numerify "," fetch ","translation [] sample ","translation [] ","(lvasgn :translation\n  (send\n    (send nil :translate\n      (sym :faker)) :[]\n    (sym :cell_phone))) is_a? "," translate [] "," translate "," parse "," parse == "," translate []  [] sample "," translate []  [] ","(lvasgn : translate [] \n  (send\n    (send nil :translate\n      (sym :faker)) :[]\n    (sym :cell_phone))) is_a? "]}," Faker Name title":{"type":"method","name":"title","children":[],"call":[" fetch + + + + "," fetch "," fetch + + + "," fetch + + "," fetch + ","Faker Job  title "]}," Faker Lorem characters":{"type":"method","name":"characters","children":[],"call":[" rand to_s rjust chars to_a shuffle join "," rand to_s rjust chars to_a shuffle "," rand to_s rjust chars to_a "," rand to_s rjust chars "," rand to_s rjust "," rand to_s "," rand ","36 ** "," resolve ","char_count to_i < ","char_count to_i ","char_count respond_to? ","(send\n  (const nil :Array) :new\n  (lvar :char_count)) join ","CHARACTERS  sample ","Array  new "," sample ","Alphanumeric  alphanumeric ","keywords << ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel "," resolve  to_i < "," resolve  to_i "," resolve  respond_to? ","(send\n  (const nil :Array) :new\n  (lvar : resolve )) join "]}," Faker Internet url":{"type":"method","name":"url","children":[],"call":[" user_name "," domain_name ","keywords << ","legacy_scheme != ","legacy_path != ","legacy_host != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Internet ip_v6_address":{"type":"method","name":"ip_v6_address","children":[],"call":["(send\n  (lvar :container) :map) join ","n to_s ","container map ","@@ip_v6_space sample ","(irange\n  (int 1)\n  (int 8)) map ","(irange\n  (int 0)\n  (int 65535)) to_a ","(send\n  (begin\n    (irange\n      (int 1)\n      (int 8))) :map) join "," rand to_s "," rand "]}," Faker Internet fix_umlauts":{"type":"method","name":"fix_umlauts","children":[],"call":["match downcase ","string gsub ","Char  fix_umlauts ","keywords << ","legacy_string != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Address longitude":{"type":"method","name":"longitude","children":[],"call":["(send\n  (begin\n    (send\n      (send nil :rand) :*\n      (int 360))) :-\n  (int 180)) to_s ","(send\n  (send nil :rand) :*\n  (int 360)) - "," rand * "," rand ","(send\n  (begin\n    (send\n      (send nil :rand) :*\n      (int 360))) :-\n  (int 180)) to_f "]}," Faker Address latitude":{"type":"method","name":"latitude","children":[],"call":["(send\n  (begin\n    (send\n      (send nil :rand) :*\n      (int 180))) :-\n  (int 90)) to_s ","(send\n  (send nil :rand) :*\n  (int 180)) - "," rand * "," rand ","(send\n  (begin\n    (send\n      (send nil :rand) :*\n      (int 180))) :-\n  (int 90)) to_f "]}," Array sample":{"type":"method","name":"sample","children":[],"call":[" choice ","result []= ","result [] ","i + ","Kernel  rand ","size - ","n times ","Array  new ","n > "," raise ","n < ","n to_int "," [] ","n nil? "," length ","arr times ","arr > ","arr < ","arr to_int ","arr nil? ","i + esult []= ","Array  new  []= ","i + esult [] ","Array  new  [] ","Kei + nel  i + and ","Kern to_int el  ran to_int d "," length  - ","n to_int  times ","Ai + i + ay  new ","Array  n to_int ew ","n to_int  > "," i + aise ","n to_int  < ","n to_int  to_in to_int t ","n to_int  n to_int il? "," len to_int gth ","ai + i +  times ","arr to_int  times ","ai + i +  > ","arr to_int  > ","ai + i +  < ","arr to_int  < ","ai + i +  to_int ","arr to_in to_int t ","arr to_int  to_int ","ai + i +  nil? ","arr n to_int il? ","arr to_int  nil? "]}," Faker Internet safe_email":{"type":"method","name":"safe_email","children":[],"call":["(send nil :user_name\n  (lvar :name)) join ","example. + ","(str \"org\") shuffle first ","(str \"org\") shuffle "," user_name ","(str \"org\") sample "," sample ","(send nil :username\n  (lvar :name)) join "," username ","(send nil :username\n  (hash\n    (pair\n      (sym :specifier)\n      (lvar :name)))) join ","keywords << ","legacy_name != "," warn_for_deprecated_arguments "," construct_email "," sanitize_email_local_part "," warn_with_uplevel "]}," Faker Base regexify":{"type":"method","name":"regexify","children":[],"call":["Letters  sample ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :re) :gsub\n                                  (regexp\n                                    (str \"^/?\\\\^?\")\n                                    (regopt))\n                                  (str \"\")) :gsub\n                                (regexp\n                                  (str \"\\\\$?/?$\")\n                                  (regopt))\n                                (str \"\")) :gsub\n                              (regexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (regopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (regexp\n                              (str \"\\\\?\")\n                              (regopt))\n                            (str \"{0,1}\")) :gsub\n                          (regexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (regopt)))\n                        (args\n                          (arg :match))\n                        (send\n                          (nth-ref 1) :*\n                          (send\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (nth-ref 2) :to_i)\n                                (send\n                                  (nth-ref 3) :to_i))) :sample))) :gsub\n                      (regexp\n                        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (regopt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-ref 1) :*\n                      (send\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-ref 2) :to_i)\n                            (send\n                              (nth-ref 3) :to_i))) :sample))) :gsub\n                  (regexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i))) :sample))) :gsub\n              (regexp\n                (str \"\\\\((.*?)\\\\)\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (regexp\n                    (str \"[\\\\(\\\\)]\")\n                    (regopt))\n                  (str \"\")) :split\n                (str \"|\")) :sample)) :gsub\n          (regexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (regopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (regexp\n              (str \"(\\\\w\\\\-\\\\w)\")\n              (regopt)))\n          (args\n            (arg :range))\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\"))))) :sample))) :gsub\n      (regexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send\n      (send\n        (nth-ref 1) :split\n        (str \"\")) :sample)) :gsub\n  (str \"\\\\d\")) gsub ","Numbers  sample ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :re) :gsub\n                              (regexp\n                                (str \"^/?\\\\^?\")\n                                (regopt))\n                              (str \"\")) :gsub\n                            (regexp\n                              (str \"\\\\$?/?$\")\n                              (regopt))\n                            (str \"\")) :gsub\n                          (regexp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (regopt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (regexp\n                          (str \"\\\\?\")\n                          (regopt))\n                        (str \"{0,1}\")) :gsub\n                      (regexp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (regopt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-ref 1) :*\n                      (send\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-ref 2) :to_i)\n                            (send\n                              (nth-ref 3) :to_i))) :sample))) :gsub\n                  (regexp\n                    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i))) :sample))) :gsub\n              (regexp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i))) :sample))) :gsub\n          (regexp\n            (str \"\\\\((.*?)\\\\)\")\n            (regopt)))\n        (args\n          (arg :match))\n        (send\n          (send\n            (send\n              (lvar :match) :gsub\n              (regexp\n                (str \"[\\\\(\\\\)]\")\n                (regopt))\n              (str \"\")) :split\n            (str \"|\")) :sample)) :gsub\n      (regexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (regopt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (regexp\n          (str \"(\\\\w\\\\-\\\\w)\")\n          (regopt)))\n      (args\n        (arg :range))\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\"))))) :sample))) :gsub\n  (regexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (regopt))) gsub ","1 split sample ","1 split ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :re) :gsub\n                          (regexp\n                            (str \"^/?\\\\^?\")\n                            (regopt))\n                          (str \"\")) :gsub\n                        (regexp\n                          (str \"\\\\$?/?$\")\n                          (regopt))\n                        (str \"\")) :gsub\n                      (regexp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (regopt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (regexp\n                      (str \"\\\\?\")\n                      (regopt))\n                    (str \"{0,1}\")) :gsub\n                  (regexp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i))) :sample))) :gsub\n              (regexp\n                (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i))) :sample))) :gsub\n          (regexp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i))) :sample))) :gsub\n      (regexp\n        (str \"\\\\((.*?)\\\\)\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send\n      (send\n        (send\n          (lvar :match) :gsub\n          (regexp\n            (str \"[\\\\(\\\\)]\")\n            (regopt))\n          (str \"\")) :split\n        (str \"|\")) :sample)) :gsub\n  (regexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (regopt))) gsub "," Array sample "," Array ","Range  new ","range split ","match gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :re) :gsub\n                      (regexp\n                        (str \"^/?\\\\^?\")\n                        (regopt))\n                      (str \"\")) :gsub\n                    (regexp\n                      (str \"\\\\$?/?$\")\n                      (regopt))\n                    (str \"\")) :gsub\n                  (regexp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (regopt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (regexp\n                  (str \"\\\\?\")\n                  (regopt))\n                (str \"{0,1}\")) :gsub\n              (regexp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i))) :sample))) :gsub\n          (regexp\n            (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i))) :sample))) :gsub\n      (regexp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i))) :sample))) :gsub\n  (regexp\n    (str \"\\\\((.*?)\\\\)\")\n    (regopt))) gsub ","match gsub split sample ","match gsub split ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :re) :gsub\n                  (regexp\n                    (str \"^/?\\\\^?\")\n                    (regopt))\n                  (str \"\")) :gsub\n                (regexp\n                  (str \"\\\\$?/?$\")\n                  (regopt))\n                (str \"\")) :gsub\n              (regexp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (regopt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (regexp\n              (str \"\\\\?\")\n              (regopt))\n            (str \"{0,1}\")) :gsub\n          (regexp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i))) :sample))) :gsub\n      (regexp\n        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i))) :sample))) :gsub\n  (regexp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","1 * ","3 to_i ","2 to_i ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :re) :gsub\n              (regexp\n                (str \"^/?\\\\^?\")\n                (regopt))\n              (str \"\")) :gsub\n            (regexp\n              (str \"\\\\$?/?$\")\n              (regopt))\n            (str \"\")) :gsub\n          (regexp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (regopt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (regexp\n          (str \"\\\\?\")\n          (regopt))\n        (str \"{0,1}\")) :gsub\n      (regexp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i))) :sample))) :gsub\n  (regexp\n    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :re) :gsub\n          (regexp\n            (str \"^/?\\\\^?\")\n            (regopt))\n          (str \"\")) :gsub\n        (regexp\n          (str \"\\\\$?/?$\")\n          (regopt))\n        (str \"\")) :gsub\n      (regexp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (regopt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (regexp\n      (str \"\\\\?\")\n      (regopt))\n    (str \"{0,1}\")) :gsub\n  (regexp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","re gsub gsub gsub gsub gsub ","re gsub gsub gsub gsub ","re gsub gsub gsub ","re gsub gsub ","re gsub ","re source ","re respond_to? "," sample ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :re) :gsub\n                                  (regexp\n                                    (str \"^/?\\\\^?\")\n                                    (regopt))\n                                  (str \"\")) :gsub\n                                (regexp\n                                  (str \"\\\\$?/?$\")\n                                  (regopt))\n                                (str \"\")) :gsub\n                              (regexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (regopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (regexp\n                              (str \"\\\\?\")\n                              (regopt))\n                            (str \"{0,1}\")) :gsub\n                          (regexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (regopt)))\n                        (args\n                          (arg :match))\n                        (send\n                          (nth-ref 1) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (nth-ref 2) :to_i)\n                                (send\n                                  (nth-ref 3) :to_i)))))) :gsub\n                      (regexp\n                        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (regopt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-ref 1) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-ref 2) :to_i)\n                            (send\n                              (nth-ref 3) :to_i)))))) :gsub\n                  (regexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i)))))) :gsub\n              (regexp\n                (str \"\\\\((.*?)\\\\)\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (regexp\n                    (str \"[\\\\(\\\\)]\")\n                    (regopt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (regexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (regopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (regexp\n              (str \"(\\\\w\\\\-\\\\w)\")\n              (regopt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (regexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (nth-ref 1) :split\n        (str \"\")))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :re) :gsub\n                              (regexp\n                                (str \"^/?\\\\^?\")\n                                (regopt))\n                              (str \"\")) :gsub\n                            (regexp\n                              (str \"\\\\$?/?$\")\n                              (regopt))\n                            (str \"\")) :gsub\n                          (regexp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (regopt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (regexp\n                          (str \"\\\\?\")\n                          (regopt))\n                        (str \"{0,1}\")) :gsub\n                      (regexp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (regopt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-ref 1) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-ref 2) :to_i)\n                            (send\n                              (nth-ref 3) :to_i)))))) :gsub\n                  (regexp\n                    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i)))))) :gsub\n              (regexp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i)))))) :gsub\n          (regexp\n            (str \"\\\\((.*?)\\\\)\")\n            (regopt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (regexp\n                (str \"[\\\\(\\\\)]\")\n                (regopt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (regexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (regopt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (regexp\n          (str \"(\\\\w\\\\-\\\\w)\")\n          (regopt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (regexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :re) :gsub\n                          (regexp\n                            (str \"^/?\\\\^?\")\n                            (regopt))\n                          (str \"\")) :gsub\n                        (regexp\n                          (str \"\\\\$?/?$\")\n                          (regopt))\n                        (str \"\")) :gsub\n                      (regexp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (regopt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (regexp\n                      (str \"\\\\?\")\n                      (regopt))\n                    (str \"{0,1}\")) :gsub\n                  (regexp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i)))))) :gsub\n              (regexp\n                (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i)))))) :gsub\n          (regexp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i)))))) :gsub\n      (regexp\n        (str \"\\\\((.*?)\\\\)\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (regexp\n            (str \"[\\\\(\\\\)]\")\n            (regopt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (regexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :re) :gsub\n                      (regexp\n                        (str \"^/?\\\\^?\")\n                        (regopt))\n                      (str \"\")) :gsub\n                    (regexp\n                      (str \"\\\\$?/?$\")\n                      (regopt))\n                    (str \"\")) :gsub\n                  (regexp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (regopt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (regexp\n                  (str \"\\\\?\")\n                  (regopt))\n                (str \"{0,1}\")) :gsub\n              (regexp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i)))))) :gsub\n          (regexp\n            (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i)))))) :gsub\n      (regexp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i)))))) :gsub\n  (regexp\n    (str \"\\\\((.*?)\\\\)\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :re) :gsub\n                  (regexp\n                    (str \"^/?\\\\^?\")\n                    (regopt))\n                  (str \"\")) :gsub\n                (regexp\n                  (str \"\\\\$?/?$\")\n                  (regopt))\n                (str \"\")) :gsub\n              (regexp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (regopt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (regexp\n              (str \"\\\\?\")\n              (regopt))\n            (str \"{0,1}\")) :gsub\n          (regexp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i)))))) :gsub\n      (regexp\n        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i)))))) :gsub\n  (regexp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :re) :gsub\n              (regexp\n                (str \"^/?\\\\^?\")\n                (regopt))\n              (str \"\")) :gsub\n            (regexp\n              (str \"\\\\$?/?$\")\n              (regopt))\n            (str \"\")) :gsub\n          (regexp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (regopt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (regexp\n          (str \"\\\\?\")\n          (regopt))\n        (str \"{0,1}\")) :gsub\n      (regexp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i)))))) :gsub\n  (regexp\n    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :reg) :gsub\n                                  (regexp\n                                    (str \"^\\\\/?\\\\^?\")\n                                    (regopt))\n                                  (str \"\")) :gsub\n                                (regexp\n                                  (str \"\\\\$?\\\\/?$\")\n                                  (regopt))\n                                (str \"\")) :gsub\n                              (regexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (regopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (regexp\n                              (str \"\\\\?\")\n                              (regopt))\n                            (str \"{0,1}\")) :gsub\n                          (regexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (regopt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (regexp\n                        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (regopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (regexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (regexp\n                (str \"\\\\((.*?)\\\\)\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (regexp\n                    (str \"[\\\\(\\\\)]\")\n                    (regopt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (regexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (regopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (regexp\n              (str \"(\\\\w\\\\-\\\\w)\")\n              (regopt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (regexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :split\n        (str \"\")))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :reg) :gsub\n                              (regexp\n                                (str \"^\\\\/?\\\\^?\")\n                                (regopt))\n                              (str \"\")) :gsub\n                            (regexp\n                              (str \"\\\\$?\\\\/?$\")\n                              (regopt))\n                            (str \"\")) :gsub\n                          (regexp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (regopt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (regexp\n                          (str \"\\\\?\")\n                          (regopt))\n                        (str \"{0,1}\")) :gsub\n                      (regexp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (regopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (regexp\n                    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (regexp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (regexp\n            (str \"\\\\((.*?)\\\\)\")\n            (regopt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (regexp\n                (str \"[\\\\(\\\\)]\")\n                (regopt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (regexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (regopt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (regexp\n          (str \"(\\\\w\\\\-\\\\w)\")\n          (regopt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (regexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (regopt))) gsub ","Regexp  last_match split ","Regexp  last_match ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :reg) :gsub\n                          (regexp\n                            (str \"^\\\\/?\\\\^?\")\n                            (regopt))\n                          (str \"\")) :gsub\n                        (regexp\n                          (str \"\\\\$?\\\\/?$\")\n                          (regopt))\n                        (str \"\")) :gsub\n                      (regexp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (regopt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (regexp\n                      (str \"\\\\?\")\n                      (regopt))\n                    (str \"{0,1}\")) :gsub\n                  (regexp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (regexp\n                (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (regexp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (regexp\n        (str \"\\\\((.*?)\\\\)\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (regexp\n            (str \"[\\\\(\\\\)]\")\n            (regopt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (regexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :reg) :gsub\n                      (regexp\n                        (str \"^\\\\/?\\\\^?\")\n                        (regopt))\n                      (str \"\")) :gsub\n                    (regexp\n                      (str \"\\\\$?\\\\/?$\")\n                      (regopt))\n                    (str \"\")) :gsub\n                  (regexp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (regopt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (regexp\n                  (str \"\\\\?\")\n                  (regopt))\n                (str \"{0,1}\")) :gsub\n              (regexp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (regexp\n            (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (regexp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (regexp\n    (str \"\\\\((.*?)\\\\)\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :reg) :gsub\n                  (regexp\n                    (str \"^\\\\/?\\\\^?\")\n                    (regopt))\n                  (str \"\")) :gsub\n                (regexp\n                  (str \"\\\\$?\\\\/?$\")\n                  (regopt))\n                (str \"\")) :gsub\n              (regexp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (regopt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (regexp\n              (str \"\\\\?\")\n              (regopt))\n            (str \"{0,1}\")) :gsub\n          (regexp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (regexp\n        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (regexp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","Regexp  last_match * ","Regexp  last_match to_i ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :reg) :gsub\n              (regexp\n                (str \"^\\\\/?\\\\^?\")\n                (regopt))\n              (str \"\")) :gsub\n            (regexp\n              (str \"\\\\$?\\\\/?$\")\n              (regopt))\n            (str \"\")) :gsub\n          (regexp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (regopt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (regexp\n          (str \"\\\\?\")\n          (regopt))\n        (str \"{0,1}\")) :gsub\n      (regexp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (regexp\n    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :reg) :gsub\n          (regexp\n            (str \"^\\\\/?\\\\^?\")\n            (regopt))\n          (str \"\")) :gsub\n        (regexp\n          (str \"\\\\$?\\\\/?$\")\n          (regopt))\n        (str \"\")) :gsub\n      (regexp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (regopt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (regexp\n      (str \"\\\\?\")\n      (regopt))\n    (str \"{0,1}\")) :gsub\n  (regexp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","reg gsub gsub gsub gsub gsub ","reg gsub gsub gsub gsub ","reg gsub gsub gsub ","reg gsub gsub ","reg gsub ","reg source ","reg respond_to? ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :reg) :gsub\n                                  (regexp\n                                    (str \"^/?\\\\^?\")\n                                    (regopt))\n                                  (str \"\")) :gsub\n                                (regexp\n                                  (str \"\\\\$?/?$\")\n                                  (regopt))\n                                (str \"\")) :gsub\n                              (regexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (regopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (regexp\n                              (str \"\\\\?\")\n                              (regopt))\n                            (str \"{0,1}\")) :gsub\n                          (regexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (regopt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (regexp\n                        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (regopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (regexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (regexp\n                (str \"\\\\((.*?)\\\\)\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (regexp\n                    (str \"[()]\")\n                    (regopt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (regexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (regopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (regexp\n              (str \"(\\\\w-\\\\w)\")\n              (regopt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (regexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :split\n        (str \"\")))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :reg) :gsub\n                              (regexp\n                                (str \"^/?\\\\^?\")\n                                (regopt))\n                              (str \"\")) :gsub\n                            (regexp\n                              (str \"\\\\$?/?$\")\n                              (regopt))\n                            (str \"\")) :gsub\n                          (regexp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (regopt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (regexp\n                          (str \"\\\\?\")\n                          (regopt))\n                        (str \"{0,1}\")) :gsub\n                      (regexp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (regopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (regexp\n                    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (regexp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (regexp\n            (str \"\\\\((.*?)\\\\)\")\n            (regopt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (regexp\n                (str \"[()]\")\n                (regopt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (regexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (regopt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (regexp\n          (str \"(\\\\w-\\\\w)\")\n          (regopt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (regexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :reg) :gsub\n                          (regexp\n                            (str \"^/?\\\\^?\")\n                            (regopt))\n                          (str \"\")) :gsub\n                        (regexp\n                          (str \"\\\\$?/?$\")\n                          (regopt))\n                        (str \"\")) :gsub\n                      (regexp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (regopt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (regexp\n                      (str \"\\\\?\")\n                      (regopt))\n                    (str \"{0,1}\")) :gsub\n                  (regexp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (regexp\n                (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (regexp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (regexp\n        (str \"\\\\((.*?)\\\\)\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (regexp\n            (str \"[()]\")\n            (regopt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (regexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :reg) :gsub\n                      (regexp\n                        (str \"^/?\\\\^?\")\n                        (regopt))\n                      (str \"\")) :gsub\n                    (regexp\n                      (str \"\\\\$?/?$\")\n                      (regopt))\n                    (str \"\")) :gsub\n                  (regexp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (regopt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (regexp\n                  (str \"\\\\?\")\n                  (regopt))\n                (str \"{0,1}\")) :gsub\n              (regexp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (regexp\n            (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (regexp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (regexp\n    (str \"\\\\((.*?)\\\\)\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :reg) :gsub\n                  (regexp\n                    (str \"^/?\\\\^?\")\n                    (regopt))\n                  (str \"\")) :gsub\n                (regexp\n                  (str \"\\\\$?/?$\")\n                  (regopt))\n                (str \"\")) :gsub\n              (regexp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (regopt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (regexp\n              (str \"\\\\?\")\n              (regopt))\n            (str \"{0,1}\")) :gsub\n          (regexp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (regexp\n        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (regexp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :reg) :gsub\n              (regexp\n                (str \"^/?\\\\^?\")\n                (regopt))\n              (str \"\")) :gsub\n            (regexp\n              (str \"\\\\$?/?$\")\n              (regopt))\n            (str \"\")) :gsub\n          (regexp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (regopt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (regexp\n          (str \"\\\\?\")\n          (regopt))\n        (str \"{0,1}\")) :gsub\n      (regexp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (regexp\n    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :reg) :gsub\n          (regexp\n            (str \"^/?\\\\^?\")\n            (regopt))\n          (str \"\")) :gsub\n        (regexp\n          (str \"\\\\$?/?$\")\n          (regopt))\n        (str \"\")) :gsub\n      (regexp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (regopt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (regexp\n      (str \"\\\\?\")\n      (regopt))\n    (str \"{0,1}\")) :gsub\n  (regexp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :reg) :gsub\n                                  (regexp\n                                    (str \"^/?\\\\^?\")\n                                    (regopt))\n                                  (str \"\")) :gsub\n                                (regexp\n                                  (str \"\\\\$?/?$\")\n                                  (regopt))\n                                (str \"\")) :gsub\n                              (regexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (regopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (regexp\n                              (str \"\\\\?\")\n                              (regopt))\n                            (str \"{0,1}\")) :gsub\n                          (regexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (regopt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (regexp\n                        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (regopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (regexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (regexp\n                (str \"\\\\((.*?)\\\\)\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (regexp\n                    (str \"[()]\")\n                    (regopt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (regexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (regopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (regexp\n              (str \"(\\\\w-\\\\w)\")\n              (regopt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (regexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :chars))) :gsub\n  (str \"\\\\d\")) gsub ","Regexp  last_match chars ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :reg) :gsub\n                                  (regexp\n                                    (str \"^/?\\\\^?\")\n                                    (regopt))\n                                  (str \"\")) :gsub\n                                (regexp\n                                  (str \"\\\\$?/?$\")\n                                  (regopt))\n                                (str \"\")) :gsub\n                              (regexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (regopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (str \"?\")\n                            (str \"{0,1}\")) :gsub\n                          (regexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (regopt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (regexp\n                        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (regopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (regexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (regexp\n                (str \"\\\\((.*?)\\\\)\")\n                (regopt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (regexp\n                    (str \"[()]\")\n                    (regopt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (regexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (regopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (regexp\n              (str \"(\\\\w-\\\\w)\")\n              (regopt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (regexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :chars))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :reg) :gsub\n                              (regexp\n                                (str \"^/?\\\\^?\")\n                                (regopt))\n                              (str \"\")) :gsub\n                            (regexp\n                              (str \"\\\\$?/?$\")\n                              (regopt))\n                            (str \"\")) :gsub\n                          (regexp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (regopt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (str \"?\")\n                        (str \"{0,1}\")) :gsub\n                      (regexp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (regopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (regexp\n                    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (regexp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (regexp\n            (str \"\\\\((.*?)\\\\)\")\n            (regopt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (regexp\n                (str \"[()]\")\n                (regopt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (regexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (regopt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (regexp\n          (str \"(\\\\w-\\\\w)\")\n          (regopt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (regexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :reg) :gsub\n                          (regexp\n                            (str \"^/?\\\\^?\")\n                            (regopt))\n                          (str \"\")) :gsub\n                        (regexp\n                          (str \"\\\\$?/?$\")\n                          (regopt))\n                        (str \"\")) :gsub\n                      (regexp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (regopt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (str \"?\")\n                    (str \"{0,1}\")) :gsub\n                  (regexp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (regopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (regexp\n                (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (regexp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (regexp\n        (str \"\\\\((.*?)\\\\)\")\n        (regopt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (regexp\n            (str \"[()]\")\n            (regopt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (regexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :reg) :gsub\n                      (regexp\n                        (str \"^/?\\\\^?\")\n                        (regopt))\n                      (str \"\")) :gsub\n                    (regexp\n                      (str \"\\\\$?/?$\")\n                      (regopt))\n                    (str \"\")) :gsub\n                  (regexp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (regopt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (str \"?\")\n                (str \"{0,1}\")) :gsub\n              (regexp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (regopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (regexp\n            (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (regexp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (regexp\n    (str \"\\\\((.*?)\\\\)\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :reg) :gsub\n                  (regexp\n                    (str \"^/?\\\\^?\")\n                    (regopt))\n                  (str \"\")) :gsub\n                (regexp\n                  (str \"\\\\$?/?$\")\n                  (regopt))\n                (str \"\")) :gsub\n              (regexp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (regopt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (str \"?\")\n            (str \"{0,1}\")) :gsub\n          (regexp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (regopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (regexp\n        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (regexp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :reg) :gsub\n              (regexp\n                (str \"^/?\\\\^?\")\n                (regopt))\n              (str \"\")) :gsub\n            (regexp\n              (str \"\\\\$?/?$\")\n              (regopt))\n            (str \"\")) :gsub\n          (regexp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (regopt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (str \"?\")\n        (str \"{0,1}\")) :gsub\n      (regexp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (regopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (regexp\n    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :reg) :gsub\n          (regexp\n            (str \"^/?\\\\^?\")\n            (regopt))\n          (str \"\")) :gsub\n        (regexp\n          (str \"\\\\$?/?$\")\n          (regopt))\n        (str \"\")) :gsub\n      (regexp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (regopt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (str \"?\")\n    (str \"{0,1}\")) :gsub\n  (regexp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (regopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :re source ) :gsub\n                                  (re source gexp\n                                    (str \"^/?\\\\^?\")\n                                    (re source gopt))\n                                  (str \"\")) :gsub\n                                (re source gexp\n                                  (str \"\\\\$?/?$\")\n                                  (re source gopt))\n                                (str \"\")) :gsub\n                              (re source gexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (re source gopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (re source gexp\n                              (str \"\\\\?\")\n                              (re source gopt))\n                            (str \"{0,1}\")) :gsub\n                          (re source gexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (re source gopt)))\n                        (args\n                          (arg :match))\n                        (send\n                          (nth-re source f 1) :*\n                          (send\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (nth-re source f 2) :to_i)\n                                (send\n                                  (nth-re source f 3) :to_i))) :sample))) :gsub\n                      (re source gexp\n                        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (re source gopt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-re source f 1) :*\n                      (send\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-re source f 2) :to_i)\n                            (send\n                              (nth-re source f 3) :to_i))) :sample))) :gsub\n                  (re source gexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-re source f 1) :*\n                  (send\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-re source f 2) :to_i)\n                        (send\n                          (nth-re source f 3) :to_i))) :sample))) :gsub\n              (re source gexp\n                (str \"\\\\((.*?)\\\\)\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (re source gexp\n                    (str \"[\\\\(\\\\)]\")\n                    (re source gopt))\n                  (str \"\")) :split\n                (str \"|\")) :sample)) :gsub\n          (re source gexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (re source gexp\n              (str \"(\\\\w\\\\-\\\\w)\")\n              (re source gopt)))\n          (args\n            (arg :range))\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\"))))) :sample))) :gsub\n      (re source gexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send\n      (send\n        (nth-re source f 1) :split\n        (str \"\")) :sample)) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :re) :gsub\n                                  (reg source exp\n                                    (str \"^/?\\\\^?\")\n                                    (reg source opt))\n                                  (str \"\")) :gsub\n                                (reg source exp\n                                  (str \"\\\\$?/?$\")\n                                  (reg source opt))\n                                (str \"\")) :gsub\n                              (reg source exp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (reg source opt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (reg source exp\n                              (str \"\\\\?\")\n                              (reg source opt))\n                            (str \"{0,1}\")) :gsub\n                          (reg source exp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (reg source opt)))\n                        (args\n                          (arg :match))\n                        (send\n                          (nth-ref 1) :*\n                          (send\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (nth-ref 2) :to_i)\n                                (send\n                                  (nth-ref 3) :to_i))) :sample))) :gsub\n                      (reg source exp\n                        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (reg source opt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-ref 1) :*\n                      (send\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-ref 2) :to_i)\n                            (send\n                              (nth-ref 3) :to_i))) :sample))) :gsub\n                  (reg source exp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i))) :sample))) :gsub\n              (reg source exp\n                (str \"\\\\((.*?)\\\\)\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (reg source exp\n                    (str \"[\\\\(\\\\)]\")\n                    (reg source opt))\n                  (str \"\")) :split\n                (str \"|\")) :sample)) :gsub\n          (reg source exp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (reg source exp\n              (str \"(\\\\w\\\\-\\\\w)\")\n              (reg source opt)))\n          (args\n            (arg :range))\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\"))))) :sample))) :gsub\n      (reg source exp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send\n      (send\n        (nth-ref 1) :split\n        (str \"\")) :sample)) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :re source ) :gsub\n                              (re source gexp\n                                (str \"^/?\\\\^?\")\n                                (re source gopt))\n                              (str \"\")) :gsub\n                            (re source gexp\n                              (str \"\\\\$?/?$\")\n                              (re source gopt))\n                            (str \"\")) :gsub\n                          (re source gexp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (re source gopt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (re source gexp\n                          (str \"\\\\?\")\n                          (re source gopt))\n                        (str \"{0,1}\")) :gsub\n                      (re source gexp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (re source gopt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-re source f 1) :*\n                      (send\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-re source f 2) :to_i)\n                            (send\n                              (nth-re source f 3) :to_i))) :sample))) :gsub\n                  (re source gexp\n                    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-re source f 1) :*\n                  (send\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-re source f 2) :to_i)\n                        (send\n                          (nth-re source f 3) :to_i))) :sample))) :gsub\n              (re source gexp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-re source f 1) :*\n              (send\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-re source f 2) :to_i)\n                    (send\n                      (nth-re source f 3) :to_i))) :sample))) :gsub\n          (re source gexp\n            (str \"\\\\((.*?)\\\\)\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (send\n          (send\n            (send\n              (lvar :match) :gsub\n              (re source gexp\n                (str \"[\\\\(\\\\)]\")\n                (re source gopt))\n              (str \"\")) :split\n            (str \"|\")) :sample)) :gsub\n      (re source gexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (re source gexp\n          (str \"(\\\\w\\\\-\\\\w)\")\n          (re source gopt)))\n      (args\n        (arg :range))\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\"))))) :sample))) :gsub\n  (re source gexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :re) :gsub\n                              (reg source exp\n                                (str \"^/?\\\\^?\")\n                                (reg source opt))\n                              (str \"\")) :gsub\n                            (reg source exp\n                              (str \"\\\\$?/?$\")\n                              (reg source opt))\n                            (str \"\")) :gsub\n                          (reg source exp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (reg source opt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (reg source exp\n                          (str \"\\\\?\")\n                          (reg source opt))\n                        (str \"{0,1}\")) :gsub\n                      (reg source exp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (reg source opt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-ref 1) :*\n                      (send\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-ref 2) :to_i)\n                            (send\n                              (nth-ref 3) :to_i))) :sample))) :gsub\n                  (reg source exp\n                    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i))) :sample))) :gsub\n              (reg source exp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i))) :sample))) :gsub\n          (reg source exp\n            (str \"\\\\((.*?)\\\\)\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (send\n          (send\n            (send\n              (lvar :match) :gsub\n              (reg source exp\n                (str \"[\\\\(\\\\)]\")\n                (reg source opt))\n              (str \"\")) :split\n            (str \"|\")) :sample)) :gsub\n      (reg source exp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (reg source exp\n          (str \"(\\\\w\\\\-\\\\w)\")\n          (reg source opt)))\n      (args\n        (arg :range))\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\"))))) :sample))) :gsub\n  (reg source exp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :re source ) :gsub\n                          (re source gexp\n                            (str \"^/?\\\\^?\")\n                            (re source gopt))\n                          (str \"\")) :gsub\n                        (re source gexp\n                          (str \"\\\\$?/?$\")\n                          (re source gopt))\n                        (str \"\")) :gsub\n                      (re source gexp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (re source gopt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (re source gexp\n                      (str \"\\\\?\")\n                      (re source gopt))\n                    (str \"{0,1}\")) :gsub\n                  (re source gexp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-re source f 1) :*\n                  (send\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-re source f 2) :to_i)\n                        (send\n                          (nth-re source f 3) :to_i))) :sample))) :gsub\n              (re source gexp\n                (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-re source f 1) :*\n              (send\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-re source f 2) :to_i)\n                    (send\n                      (nth-re source f 3) :to_i))) :sample))) :gsub\n          (re source gexp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-re source f 1) :*\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-re source f 2) :to_i)\n                (send\n                  (nth-re source f 3) :to_i))) :sample))) :gsub\n      (re source gexp\n        (str \"\\\\((.*?)\\\\)\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send\n      (send\n        (send\n          (lvar :match) :gsub\n          (re source gexp\n            (str \"[\\\\(\\\\)]\")\n            (re source gopt))\n          (str \"\")) :split\n        (str \"|\")) :sample)) :gsub\n  (re source gexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :re) :gsub\n                          (reg source exp\n                            (str \"^/?\\\\^?\")\n                            (reg source opt))\n                          (str \"\")) :gsub\n                        (reg source exp\n                          (str \"\\\\$?/?$\")\n                          (reg source opt))\n                        (str \"\")) :gsub\n                      (reg source exp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (reg source opt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (reg source exp\n                      (str \"\\\\?\")\n                      (reg source opt))\n                    (str \"{0,1}\")) :gsub\n                  (reg source exp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i))) :sample))) :gsub\n              (reg source exp\n                (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i))) :sample))) :gsub\n          (reg source exp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i))) :sample))) :gsub\n      (reg source exp\n        (str \"\\\\((.*?)\\\\)\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send\n      (send\n        (send\n          (lvar :match) :gsub\n          (reg source exp\n            (str \"[\\\\(\\\\)]\")\n            (reg source opt))\n          (str \"\")) :split\n        (str \"|\")) :sample)) :gsub\n  (reg source exp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :re source ) :gsub\n                      (re source gexp\n                        (str \"^/?\\\\^?\")\n                        (re source gopt))\n                      (str \"\")) :gsub\n                    (re source gexp\n                      (str \"\\\\$?/?$\")\n                      (re source gopt))\n                    (str \"\")) :gsub\n                  (re source gexp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (re source gopt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (re source gexp\n                  (str \"\\\\?\")\n                  (re source gopt))\n                (str \"{0,1}\")) :gsub\n              (re source gexp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-re source f 1) :*\n              (send\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-re source f 2) :to_i)\n                    (send\n                      (nth-re source f 3) :to_i))) :sample))) :gsub\n          (re source gexp\n            (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-re source f 1) :*\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-re source f 2) :to_i)\n                (send\n                  (nth-re source f 3) :to_i))) :sample))) :gsub\n      (re source gexp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-re source f 1) :*\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-re source f 2) :to_i)\n            (send\n              (nth-re source f 3) :to_i))) :sample))) :gsub\n  (re source gexp\n    (str \"\\\\((.*?)\\\\)\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :re) :gsub\n                      (reg source exp\n                        (str \"^/?\\\\^?\")\n                        (reg source opt))\n                      (str \"\")) :gsub\n                    (reg source exp\n                      (str \"\\\\$?/?$\")\n                      (reg source opt))\n                    (str \"\")) :gsub\n                  (reg source exp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (reg source opt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (reg source exp\n                  (str \"\\\\?\")\n                  (reg source opt))\n                (str \"{0,1}\")) :gsub\n              (reg source exp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i))) :sample))) :gsub\n          (reg source exp\n            (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i))) :sample))) :gsub\n      (reg source exp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i))) :sample))) :gsub\n  (reg source exp\n    (str \"\\\\((.*?)\\\\)\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :re source ) :gsub\n                  (re source gexp\n                    (str \"^/?\\\\^?\")\n                    (re source gopt))\n                  (str \"\")) :gsub\n                (re source gexp\n                  (str \"\\\\$?/?$\")\n                  (re source gopt))\n                (str \"\")) :gsub\n              (re source gexp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (re source gopt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (re source gexp\n              (str \"\\\\?\")\n              (re source gopt))\n            (str \"{0,1}\")) :gsub\n          (re source gexp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-re source f 1) :*\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-re source f 2) :to_i)\n                (send\n                  (nth-re source f 3) :to_i))) :sample))) :gsub\n      (re source gexp\n        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-re source f 1) :*\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-re source f 2) :to_i)\n            (send\n              (nth-re source f 3) :to_i))) :sample))) :gsub\n  (re source gexp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :re) :gsub\n                  (reg source exp\n                    (str \"^/?\\\\^?\")\n                    (reg source opt))\n                  (str \"\")) :gsub\n                (reg source exp\n                  (str \"\\\\$?/?$\")\n                  (reg source opt))\n                (str \"\")) :gsub\n              (reg source exp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (reg source opt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (reg source exp\n              (str \"\\\\?\")\n              (reg source opt))\n            (str \"{0,1}\")) :gsub\n          (reg source exp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i))) :sample))) :gsub\n      (reg source exp\n        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i))) :sample))) :gsub\n  (reg source exp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :re source ) :gsub\n              (re source gexp\n                (str \"^/?\\\\^?\")\n                (re source gopt))\n              (str \"\")) :gsub\n            (re source gexp\n              (str \"\\\\$?/?$\")\n              (re source gopt))\n            (str \"\")) :gsub\n          (re source gexp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (re source gopt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (re source gexp\n          (str \"\\\\?\")\n          (re source gopt))\n        (str \"{0,1}\")) :gsub\n      (re source gexp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-re source f 1) :*\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-re source f 2) :to_i)\n            (send\n              (nth-re source f 3) :to_i))) :sample))) :gsub\n  (re source gexp\n    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :re) :gsub\n              (reg source exp\n                (str \"^/?\\\\^?\")\n                (reg source opt))\n              (str \"\")) :gsub\n            (reg source exp\n              (str \"\\\\$?/?$\")\n              (reg source opt))\n            (str \"\")) :gsub\n          (reg source exp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (reg source opt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (reg source exp\n          (str \"\\\\?\")\n          (reg source opt))\n        (str \"{0,1}\")) :gsub\n      (reg source exp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i))) :sample))) :gsub\n  (reg source exp\n    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :re source ) :gsub\n          (re source gexp\n            (str \"^/?\\\\^?\")\n            (re source gopt))\n          (str \"\")) :gsub\n        (re source gexp\n          (str \"\\\\$?/?$\")\n          (re source gopt))\n        (str \"\")) :gsub\n      (re source gexp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (re source gopt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (re source gexp\n      (str \"\\\\?\")\n      (re source gopt))\n    (str \"{0,1}\")) :gsub\n  (re source gexp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :re) :gsub\n          (reg source exp\n            (str \"^/?\\\\^?\")\n            (reg source opt))\n          (str \"\")) :gsub\n        (reg source exp\n          (str \"\\\\$?/?$\")\n          (reg source opt))\n        (str \"\")) :gsub\n      (reg source exp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (reg source opt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (reg source exp\n      (str \"\\\\?\")\n      (reg source opt))\n    (str \"{0,1}\")) :gsub\n  (reg source exp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","re source  gsub gsub gsub gsub gsub ","re source  gsub gsub gsub gsub ","re source  gsub gsub gsub ","re source  gsub gsub ","re source  gsub ","re source  source ","re source  re source spond_to? ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :re source ) :gsub\n                                  (re source gexp\n                                    (str \"^/?\\\\^?\")\n                                    (re source gopt))\n                                  (str \"\")) :gsub\n                                (re source gexp\n                                  (str \"\\\\$?/?$\")\n                                  (re source gopt))\n                                (str \"\")) :gsub\n                              (re source gexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (re source gopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (re source gexp\n                              (str \"\\\\?\")\n                              (re source gopt))\n                            (str \"{0,1}\")) :gsub\n                          (re source gexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (re source gopt)))\n                        (args\n                          (arg :match))\n                        (send\n                          (nth-re source f 1) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (nth-re source f 2) :to_i)\n                                (send\n                                  (nth-re source f 3) :to_i)))))) :gsub\n                      (re source gexp\n                        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (re source gopt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-re source f 1) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-re source f 2) :to_i)\n                            (send\n                              (nth-re source f 3) :to_i)))))) :gsub\n                  (re source gexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-re source f 1) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-re source f 2) :to_i)\n                        (send\n                          (nth-re source f 3) :to_i)))))) :gsub\n              (re source gexp\n                (str \"\\\\((.*?)\\\\)\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (re source gexp\n                    (str \"[\\\\(\\\\)]\")\n                    (re source gopt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (re source gexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (re source gexp\n              (str \"(\\\\w\\\\-\\\\w)\")\n              (re source gopt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (re source gexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (nth-re source f 1) :split\n        (str \"\")))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :re) :gsub\n                                  (reg source exp\n                                    (str \"^/?\\\\^?\")\n                                    (reg source opt))\n                                  (str \"\")) :gsub\n                                (reg source exp\n                                  (str \"\\\\$?/?$\")\n                                  (reg source opt))\n                                (str \"\")) :gsub\n                              (reg source exp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (reg source opt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (reg source exp\n                              (str \"\\\\?\")\n                              (reg source opt))\n                            (str \"{0,1}\")) :gsub\n                          (reg source exp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (reg source opt)))\n                        (args\n                          (arg :match))\n                        (send\n                          (nth-ref 1) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (nth-ref 2) :to_i)\n                                (send\n                                  (nth-ref 3) :to_i)))))) :gsub\n                      (reg source exp\n                        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (reg source opt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-ref 1) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-ref 2) :to_i)\n                            (send\n                              (nth-ref 3) :to_i)))))) :gsub\n                  (reg source exp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i)))))) :gsub\n              (reg source exp\n                (str \"\\\\((.*?)\\\\)\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (reg source exp\n                    (str \"[\\\\(\\\\)]\")\n                    (reg source opt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (reg source exp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (reg source exp\n              (str \"(\\\\w\\\\-\\\\w)\")\n              (reg source opt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (reg source exp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (nth-ref 1) :split\n        (str \"\")))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :re source ) :gsub\n                              (re source gexp\n                                (str \"^/?\\\\^?\")\n                                (re source gopt))\n                              (str \"\")) :gsub\n                            (re source gexp\n                              (str \"\\\\$?/?$\")\n                              (re source gopt))\n                            (str \"\")) :gsub\n                          (re source gexp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (re source gopt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (re source gexp\n                          (str \"\\\\?\")\n                          (re source gopt))\n                        (str \"{0,1}\")) :gsub\n                      (re source gexp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (re source gopt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-re source f 1) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-re source f 2) :to_i)\n                            (send\n                              (nth-re source f 3) :to_i)))))) :gsub\n                  (re source gexp\n                    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-re source f 1) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-re source f 2) :to_i)\n                        (send\n                          (nth-re source f 3) :to_i)))))) :gsub\n              (re source gexp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-re source f 1) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-re source f 2) :to_i)\n                    (send\n                      (nth-re source f 3) :to_i)))))) :gsub\n          (re source gexp\n            (str \"\\\\((.*?)\\\\)\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (re source gexp\n                (str \"[\\\\(\\\\)]\")\n                (re source gopt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (re source gexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (re source gexp\n          (str \"(\\\\w\\\\-\\\\w)\")\n          (re source gopt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (re source gexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :re) :gsub\n                              (reg source exp\n                                (str \"^/?\\\\^?\")\n                                (reg source opt))\n                              (str \"\")) :gsub\n                            (reg source exp\n                              (str \"\\\\$?/?$\")\n                              (reg source opt))\n                            (str \"\")) :gsub\n                          (reg source exp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (reg source opt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (reg source exp\n                          (str \"\\\\?\")\n                          (reg source opt))\n                        (str \"{0,1}\")) :gsub\n                      (reg source exp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (reg source opt)))\n                    (args\n                      (arg :match))\n                    (send\n                      (nth-ref 1) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (nth-ref 2) :to_i)\n                            (send\n                              (nth-ref 3) :to_i)))))) :gsub\n                  (reg source exp\n                    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i)))))) :gsub\n              (reg source exp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i)))))) :gsub\n          (reg source exp\n            (str \"\\\\((.*?)\\\\)\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (reg source exp\n                (str \"[\\\\(\\\\)]\")\n                (reg source opt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (reg source exp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (reg source exp\n          (str \"(\\\\w\\\\-\\\\w)\")\n          (reg source opt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (reg source exp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :re source ) :gsub\n                          (re source gexp\n                            (str \"^/?\\\\^?\")\n                            (re source gopt))\n                          (str \"\")) :gsub\n                        (re source gexp\n                          (str \"\\\\$?/?$\")\n                          (re source gopt))\n                        (str \"\")) :gsub\n                      (re source gexp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (re source gopt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (re source gexp\n                      (str \"\\\\?\")\n                      (re source gopt))\n                    (str \"{0,1}\")) :gsub\n                  (re source gexp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-re source f 1) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-re source f 2) :to_i)\n                        (send\n                          (nth-re source f 3) :to_i)))))) :gsub\n              (re source gexp\n                (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-re source f 1) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-re source f 2) :to_i)\n                    (send\n                      (nth-re source f 3) :to_i)))))) :gsub\n          (re source gexp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-re source f 1) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-re source f 2) :to_i)\n                (send\n                  (nth-re source f 3) :to_i)))))) :gsub\n      (re source gexp\n        (str \"\\\\((.*?)\\\\)\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (re source gexp\n            (str \"[\\\\(\\\\)]\")\n            (re source gopt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (re source gexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :re) :gsub\n                          (reg source exp\n                            (str \"^/?\\\\^?\")\n                            (reg source opt))\n                          (str \"\")) :gsub\n                        (reg source exp\n                          (str \"\\\\$?/?$\")\n                          (reg source opt))\n                        (str \"\")) :gsub\n                      (reg source exp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (reg source opt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (reg source exp\n                      (str \"\\\\?\")\n                      (reg source opt))\n                    (str \"{0,1}\")) :gsub\n                  (reg source exp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :match))\n                (send\n                  (nth-ref 1) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (nth-ref 2) :to_i)\n                        (send\n                          (nth-ref 3) :to_i)))))) :gsub\n              (reg source exp\n                (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i)))))) :gsub\n          (reg source exp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i)))))) :gsub\n      (reg source exp\n        (str \"\\\\((.*?)\\\\)\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (reg source exp\n            (str \"[\\\\(\\\\)]\")\n            (reg source opt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (reg source exp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :re source ) :gsub\n                      (re source gexp\n                        (str \"^/?\\\\^?\")\n                        (re source gopt))\n                      (str \"\")) :gsub\n                    (re source gexp\n                      (str \"\\\\$?/?$\")\n                      (re source gopt))\n                    (str \"\")) :gsub\n                  (re source gexp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (re source gopt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (re source gexp\n                  (str \"\\\\?\")\n                  (re source gopt))\n                (str \"{0,1}\")) :gsub\n              (re source gexp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send\n              (nth-re source f 1) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-re source f 2) :to_i)\n                    (send\n                      (nth-re source f 3) :to_i)))))) :gsub\n          (re source gexp\n            (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-re source f 1) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-re source f 2) :to_i)\n                (send\n                  (nth-re source f 3) :to_i)))))) :gsub\n      (re source gexp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-re source f 1) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-re source f 2) :to_i)\n            (send\n              (nth-re source f 3) :to_i)))))) :gsub\n  (re source gexp\n    (str \"\\\\((.*?)\\\\)\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :re) :gsub\n                      (reg source exp\n                        (str \"^/?\\\\^?\")\n                        (reg source opt))\n                      (str \"\")) :gsub\n                    (reg source exp\n                      (str \"\\\\$?/?$\")\n                      (reg source opt))\n                    (str \"\")) :gsub\n                  (reg source exp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (reg source opt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (reg source exp\n                  (str \"\\\\?\")\n                  (reg source opt))\n                (str \"{0,1}\")) :gsub\n              (reg source exp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send\n              (nth-ref 1) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (nth-ref 2) :to_i)\n                    (send\n                      (nth-ref 3) :to_i)))))) :gsub\n          (reg source exp\n            (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i)))))) :gsub\n      (reg source exp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i)))))) :gsub\n  (reg source exp\n    (str \"\\\\((.*?)\\\\)\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :re source ) :gsub\n                  (re source gexp\n                    (str \"^/?\\\\^?\")\n                    (re source gopt))\n                  (str \"\")) :gsub\n                (re source gexp\n                  (str \"\\\\$?/?$\")\n                  (re source gopt))\n                (str \"\")) :gsub\n              (re source gexp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (re source gopt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (re source gexp\n              (str \"\\\\?\")\n              (re source gopt))\n            (str \"{0,1}\")) :gsub\n          (re source gexp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (send\n          (nth-re source f 1) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-re source f 2) :to_i)\n                (send\n                  (nth-re source f 3) :to_i)))))) :gsub\n      (re source gexp\n        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-re source f 1) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-re source f 2) :to_i)\n            (send\n              (nth-re source f 3) :to_i)))))) :gsub\n  (re source gexp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :re) :gsub\n                  (reg source exp\n                    (str \"^/?\\\\^?\")\n                    (reg source opt))\n                  (str \"\")) :gsub\n                (reg source exp\n                  (str \"\\\\$?/?$\")\n                  (reg source opt))\n                (str \"\")) :gsub\n              (reg source exp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (reg source opt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (reg source exp\n              (str \"\\\\?\")\n              (reg source opt))\n            (str \"{0,1}\")) :gsub\n          (reg source exp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (send\n          (nth-ref 1) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (nth-ref 2) :to_i)\n                (send\n                  (nth-ref 3) :to_i)))))) :gsub\n      (reg source exp\n        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i)))))) :gsub\n  (reg source exp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :re source ) :gsub\n              (re source gexp\n                (str \"^/?\\\\^?\")\n                (re source gopt))\n              (str \"\")) :gsub\n            (re source gexp\n              (str \"\\\\$?/?$\")\n              (re source gopt))\n            (str \"\")) :gsub\n          (re source gexp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (re source gopt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (re source gexp\n          (str \"\\\\?\")\n          (re source gopt))\n        (str \"{0,1}\")) :gsub\n      (re source gexp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send\n      (nth-re source f 1) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-re source f 2) :to_i)\n            (send\n              (nth-re source f 3) :to_i)))))) :gsub\n  (re source gexp\n    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :re) :gsub\n              (reg source exp\n                (str \"^/?\\\\^?\")\n                (reg source opt))\n              (str \"\")) :gsub\n            (reg source exp\n              (str \"\\\\$?/?$\")\n              (reg source opt))\n            (str \"\")) :gsub\n          (reg source exp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (reg source opt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (reg source exp\n          (str \"\\\\?\")\n          (reg source opt))\n        (str \"{0,1}\")) :gsub\n      (reg source exp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send\n      (nth-ref 1) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (nth-ref 2) :to_i)\n            (send\n              (nth-ref 3) :to_i)))))) :gsub\n  (reg source exp\n    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :re source g) :gsub\n                                  (re source gexp\n                                    (str \"^\\\\/?\\\\^?\")\n                                    (re source gopt))\n                                  (str \"\")) :gsub\n                                (re source gexp\n                                  (str \"\\\\$?\\\\/?$\")\n                                  (re source gopt))\n                                (str \"\")) :gsub\n                              (re source gexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (re source gopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (re source gexp\n                              (str \"\\\\?\")\n                              (re source gopt))\n                            (str \"{0,1}\")) :gsub\n                          (re source gexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (re source gopt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (re source gexp\n                        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (re source gopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (re source gexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (re source gexp\n                (str \"\\\\((.*?)\\\\)\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (re source gexp\n                    (str \"[\\\\(\\\\)]\")\n                    (re source gopt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (re source gexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (re source gexp\n              (str \"(\\\\w\\\\-\\\\w)\")\n              (re source gopt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (re source gexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :split\n        (str \"\")))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :reg source ) :gsub\n                                  (reg source exp\n                                    (str \"^\\\\/?\\\\^?\")\n                                    (reg source opt))\n                                  (str \"\")) :gsub\n                                (reg source exp\n                                  (str \"\\\\$?\\\\/?$\")\n                                  (reg source opt))\n                                (str \"\")) :gsub\n                              (reg source exp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (reg source opt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (reg source exp\n                              (str \"\\\\?\")\n                              (reg source opt))\n                            (str \"{0,1}\")) :gsub\n                          (reg source exp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (reg source opt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (reg source exp\n                        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (reg source opt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (reg source exp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (reg source exp\n                (str \"\\\\((.*?)\\\\)\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (reg source exp\n                    (str \"[\\\\(\\\\)]\")\n                    (reg source opt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (reg source exp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (reg source exp\n              (str \"(\\\\w\\\\-\\\\w)\")\n              (reg source opt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (reg source exp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :split\n        (str \"\")))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :re source g) :gsub\n                              (re source gexp\n                                (str \"^\\\\/?\\\\^?\")\n                                (re source gopt))\n                              (str \"\")) :gsub\n                            (re source gexp\n                              (str \"\\\\$?\\\\/?$\")\n                              (re source gopt))\n                            (str \"\")) :gsub\n                          (re source gexp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (re source gopt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (re source gexp\n                          (str \"\\\\?\")\n                          (re source gopt))\n                        (str \"{0,1}\")) :gsub\n                      (re source gexp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (re source gopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (re source gexp\n                    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (re source gexp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (re source gexp\n            (str \"\\\\((.*?)\\\\)\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (re source gexp\n                (str \"[\\\\(\\\\)]\")\n                (re source gopt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (re source gexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (re source gexp\n          (str \"(\\\\w\\\\-\\\\w)\")\n          (re source gopt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (re source gexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :reg source ) :gsub\n                              (reg source exp\n                                (str \"^\\\\/?\\\\^?\")\n                                (reg source opt))\n                              (str \"\")) :gsub\n                            (reg source exp\n                              (str \"\\\\$?\\\\/?$\")\n                              (reg source opt))\n                            (str \"\")) :gsub\n                          (reg source exp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (reg source opt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (reg source exp\n                          (str \"\\\\?\")\n                          (reg source opt))\n                        (str \"{0,1}\")) :gsub\n                      (reg source exp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (reg source opt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (reg source exp\n                    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (reg source exp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (reg source exp\n            (str \"\\\\((.*?)\\\\)\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (reg source exp\n                (str \"[\\\\(\\\\)]\")\n                (reg source opt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (reg source exp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (reg source exp\n          (str \"(\\\\w\\\\-\\\\w)\")\n          (reg source opt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (reg source exp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :re source g) :gsub\n                          (re source gexp\n                            (str \"^\\\\/?\\\\^?\")\n                            (re source gopt))\n                          (str \"\")) :gsub\n                        (re source gexp\n                          (str \"\\\\$?\\\\/?$\")\n                          (re source gopt))\n                        (str \"\")) :gsub\n                      (re source gexp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (re source gopt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (re source gexp\n                      (str \"\\\\?\")\n                      (re source gopt))\n                    (str \"{0,1}\")) :gsub\n                  (re source gexp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (re source gexp\n                (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (re source gexp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (re source gexp\n        (str \"\\\\((.*?)\\\\)\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (re source gexp\n            (str \"[\\\\(\\\\)]\")\n            (re source gopt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (re source gexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :reg source ) :gsub\n                          (reg source exp\n                            (str \"^\\\\/?\\\\^?\")\n                            (reg source opt))\n                          (str \"\")) :gsub\n                        (reg source exp\n                          (str \"\\\\$?\\\\/?$\")\n                          (reg source opt))\n                        (str \"\")) :gsub\n                      (reg source exp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (reg source opt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (reg source exp\n                      (str \"\\\\?\")\n                      (reg source opt))\n                    (str \"{0,1}\")) :gsub\n                  (reg source exp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (reg source exp\n                (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (reg source exp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (reg source exp\n        (str \"\\\\((.*?)\\\\)\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (reg source exp\n            (str \"[\\\\(\\\\)]\")\n            (reg source opt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (reg source exp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :re source g) :gsub\n                      (re source gexp\n                        (str \"^\\\\/?\\\\^?\")\n                        (re source gopt))\n                      (str \"\")) :gsub\n                    (re source gexp\n                      (str \"\\\\$?\\\\/?$\")\n                      (re source gopt))\n                    (str \"\")) :gsub\n                  (re source gexp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (re source gopt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (re source gexp\n                  (str \"\\\\?\")\n                  (re source gopt))\n                (str \"{0,1}\")) :gsub\n              (re source gexp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (re source gexp\n            (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (re source gexp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (re source gexp\n    (str \"\\\\((.*?)\\\\)\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :reg source ) :gsub\n                      (reg source exp\n                        (str \"^\\\\/?\\\\^?\")\n                        (reg source opt))\n                      (str \"\")) :gsub\n                    (reg source exp\n                      (str \"\\\\$?\\\\/?$\")\n                      (reg source opt))\n                    (str \"\")) :gsub\n                  (reg source exp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (reg source opt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (reg source exp\n                  (str \"\\\\?\")\n                  (reg source opt))\n                (str \"{0,1}\")) :gsub\n              (reg source exp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (reg source exp\n            (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (reg source exp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (reg source exp\n    (str \"\\\\((.*?)\\\\)\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :re source g) :gsub\n                  (re source gexp\n                    (str \"^\\\\/?\\\\^?\")\n                    (re source gopt))\n                  (str \"\")) :gsub\n                (re source gexp\n                  (str \"\\\\$?\\\\/?$\")\n                  (re source gopt))\n                (str \"\")) :gsub\n              (re source gexp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (re source gopt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (re source gexp\n              (str \"\\\\?\")\n              (re source gopt))\n            (str \"{0,1}\")) :gsub\n          (re source gexp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (re source gexp\n        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (re source gexp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :reg source ) :gsub\n                  (reg source exp\n                    (str \"^\\\\/?\\\\^?\")\n                    (reg source opt))\n                  (str \"\")) :gsub\n                (reg source exp\n                  (str \"\\\\$?\\\\/?$\")\n                  (reg source opt))\n                (str \"\")) :gsub\n              (reg source exp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (reg source opt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (reg source exp\n              (str \"\\\\?\")\n              (reg source opt))\n            (str \"{0,1}\")) :gsub\n          (reg source exp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (reg source exp\n        (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (reg source exp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :re source g) :gsub\n              (re source gexp\n                (str \"^\\\\/?\\\\^?\")\n                (re source gopt))\n              (str \"\")) :gsub\n            (re source gexp\n              (str \"\\\\$?\\\\/?$\")\n              (re source gopt))\n            (str \"\")) :gsub\n          (re source gexp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (re source gopt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (re source gexp\n          (str \"\\\\?\")\n          (re source gopt))\n        (str \"{0,1}\")) :gsub\n      (re source gexp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (re source gexp\n    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :reg source ) :gsub\n              (reg source exp\n                (str \"^\\\\/?\\\\^?\")\n                (reg source opt))\n              (str \"\")) :gsub\n            (reg source exp\n              (str \"\\\\$?\\\\/?$\")\n              (reg source opt))\n            (str \"\")) :gsub\n          (reg source exp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (reg source opt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (reg source exp\n          (str \"\\\\?\")\n          (reg source opt))\n        (str \"{0,1}\")) :gsub\n      (reg source exp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (reg source exp\n    (str \"(\\\\([^\\\\)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :re source g) :gsub\n          (re source gexp\n            (str \"^\\\\/?\\\\^?\")\n            (re source gopt))\n          (str \"\")) :gsub\n        (re source gexp\n          (str \"\\\\$?\\\\/?$\")\n          (re source gopt))\n        (str \"\")) :gsub\n      (re source gexp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (re source gopt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (re source gexp\n      (str \"\\\\?\")\n      (re source gopt))\n    (str \"{0,1}\")) :gsub\n  (re source gexp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :reg source ) :gsub\n          (reg source exp\n            (str \"^\\\\/?\\\\^?\")\n            (reg source opt))\n          (str \"\")) :gsub\n        (reg source exp\n          (str \"\\\\$?\\\\/?$\")\n          (reg source opt))\n        (str \"\")) :gsub\n      (reg source exp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (reg source opt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (reg source exp\n      (str \"\\\\?\")\n      (reg source opt))\n    (str \"{0,1}\")) :gsub\n  (reg source exp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","re source g gsub gsub gsub gsub gsub ","reg source  gsub gsub gsub gsub gsub ","re source g gsub gsub gsub gsub ","reg source  gsub gsub gsub gsub ","re source g gsub gsub gsub ","reg source  gsub gsub gsub ","re source g gsub gsub ","reg source  gsub gsub ","re source g gsub ","reg source  gsub ","re source g source ","reg source  source ","re source g re source spond_to? ","reg source  respond_to? ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :re source g) :gsub\n                                  (re source gexp\n                                    (str \"^/?\\\\^?\")\n                                    (re source gopt))\n                                  (str \"\")) :gsub\n                                (re source gexp\n                                  (str \"\\\\$?/?$\")\n                                  (re source gopt))\n                                (str \"\")) :gsub\n                              (re source gexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (re source gopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (re source gexp\n                              (str \"\\\\?\")\n                              (re source gopt))\n                            (str \"{0,1}\")) :gsub\n                          (re source gexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (re source gopt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (re source gexp\n                        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (re source gopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (re source gexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (re source gexp\n                (str \"\\\\((.*?)\\\\)\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (re source gexp\n                    (str \"[()]\")\n                    (re source gopt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (re source gexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (re source gexp\n              (str \"(\\\\w-\\\\w)\")\n              (re source gopt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (re source gexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :split\n        (str \"\")))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :reg source ) :gsub\n                                  (reg source exp\n                                    (str \"^/?\\\\^?\")\n                                    (reg source opt))\n                                  (str \"\")) :gsub\n                                (reg source exp\n                                  (str \"\\\\$?/?$\")\n                                  (reg source opt))\n                                (str \"\")) :gsub\n                              (reg source exp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (reg source opt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (reg source exp\n                              (str \"\\\\?\")\n                              (reg source opt))\n                            (str \"{0,1}\")) :gsub\n                          (reg source exp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (reg source opt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (reg source exp\n                        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (reg source opt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (reg source exp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (reg source exp\n                (str \"\\\\((.*?)\\\\)\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (reg source exp\n                    (str \"[()]\")\n                    (reg source opt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (reg source exp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (reg source exp\n              (str \"(\\\\w-\\\\w)\")\n              (reg source opt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (reg source exp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :split\n        (str \"\")))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :re source g) :gsub\n                              (re source gexp\n                                (str \"^/?\\\\^?\")\n                                (re source gopt))\n                              (str \"\")) :gsub\n                            (re source gexp\n                              (str \"\\\\$?/?$\")\n                              (re source gopt))\n                            (str \"\")) :gsub\n                          (re source gexp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (re source gopt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (re source gexp\n                          (str \"\\\\?\")\n                          (re source gopt))\n                        (str \"{0,1}\")) :gsub\n                      (re source gexp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (re source gopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (re source gexp\n                    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (re source gexp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (re source gexp\n            (str \"\\\\((.*?)\\\\)\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (re source gexp\n                (str \"[()]\")\n                (re source gopt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (re source gexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (re source gexp\n          (str \"(\\\\w-\\\\w)\")\n          (re source gopt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (re source gexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :reg source ) :gsub\n                              (reg source exp\n                                (str \"^/?\\\\^?\")\n                                (reg source opt))\n                              (str \"\")) :gsub\n                            (reg source exp\n                              (str \"\\\\$?/?$\")\n                              (reg source opt))\n                            (str \"\")) :gsub\n                          (reg source exp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (reg source opt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (reg source exp\n                          (str \"\\\\?\")\n                          (reg source opt))\n                        (str \"{0,1}\")) :gsub\n                      (reg source exp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (reg source opt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (reg source exp\n                    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (reg source exp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (reg source exp\n            (str \"\\\\((.*?)\\\\)\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (reg source exp\n                (str \"[()]\")\n                (reg source opt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (reg source exp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (reg source exp\n          (str \"(\\\\w-\\\\w)\")\n          (reg source opt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (reg source exp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :re source g) :gsub\n                          (re source gexp\n                            (str \"^/?\\\\^?\")\n                            (re source gopt))\n                          (str \"\")) :gsub\n                        (re source gexp\n                          (str \"\\\\$?/?$\")\n                          (re source gopt))\n                        (str \"\")) :gsub\n                      (re source gexp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (re source gopt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (re source gexp\n                      (str \"\\\\?\")\n                      (re source gopt))\n                    (str \"{0,1}\")) :gsub\n                  (re source gexp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (re source gexp\n                (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (re source gexp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (re source gexp\n        (str \"\\\\((.*?)\\\\)\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (re source gexp\n            (str \"[()]\")\n            (re source gopt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (re source gexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :reg source ) :gsub\n                          (reg source exp\n                            (str \"^/?\\\\^?\")\n                            (reg source opt))\n                          (str \"\")) :gsub\n                        (reg source exp\n                          (str \"\\\\$?/?$\")\n                          (reg source opt))\n                        (str \"\")) :gsub\n                      (reg source exp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (reg source opt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (reg source exp\n                      (str \"\\\\?\")\n                      (reg source opt))\n                    (str \"{0,1}\")) :gsub\n                  (reg source exp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (reg source exp\n                (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (reg source exp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (reg source exp\n        (str \"\\\\((.*?)\\\\)\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (reg source exp\n            (str \"[()]\")\n            (reg source opt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (reg source exp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :re source g) :gsub\n                      (re source gexp\n                        (str \"^/?\\\\^?\")\n                        (re source gopt))\n                      (str \"\")) :gsub\n                    (re source gexp\n                      (str \"\\\\$?/?$\")\n                      (re source gopt))\n                    (str \"\")) :gsub\n                  (re source gexp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (re source gopt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (re source gexp\n                  (str \"\\\\?\")\n                  (re source gopt))\n                (str \"{0,1}\")) :gsub\n              (re source gexp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (re source gexp\n            (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (re source gexp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (re source gexp\n    (str \"\\\\((.*?)\\\\)\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :reg source ) :gsub\n                      (reg source exp\n                        (str \"^/?\\\\^?\")\n                        (reg source opt))\n                      (str \"\")) :gsub\n                    (reg source exp\n                      (str \"\\\\$?/?$\")\n                      (reg source opt))\n                    (str \"\")) :gsub\n                  (reg source exp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (reg source opt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (reg source exp\n                  (str \"\\\\?\")\n                  (reg source opt))\n                (str \"{0,1}\")) :gsub\n              (reg source exp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (reg source exp\n            (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (reg source exp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (reg source exp\n    (str \"\\\\((.*?)\\\\)\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :re source g) :gsub\n                  (re source gexp\n                    (str \"^/?\\\\^?\")\n                    (re source gopt))\n                  (str \"\")) :gsub\n                (re source gexp\n                  (str \"\\\\$?/?$\")\n                  (re source gopt))\n                (str \"\")) :gsub\n              (re source gexp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (re source gopt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (re source gexp\n              (str \"\\\\?\")\n              (re source gopt))\n            (str \"{0,1}\")) :gsub\n          (re source gexp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (re source gexp\n        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (re source gexp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :reg source ) :gsub\n                  (reg source exp\n                    (str \"^/?\\\\^?\")\n                    (reg source opt))\n                  (str \"\")) :gsub\n                (reg source exp\n                  (str \"\\\\$?/?$\")\n                  (reg source opt))\n                (str \"\")) :gsub\n              (reg source exp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (reg source opt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (reg source exp\n              (str \"\\\\?\")\n              (reg source opt))\n            (str \"{0,1}\")) :gsub\n          (reg source exp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (reg source exp\n        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (reg source exp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :re source g) :gsub\n              (re source gexp\n                (str \"^/?\\\\^?\")\n                (re source gopt))\n              (str \"\")) :gsub\n            (re source gexp\n              (str \"\\\\$?/?$\")\n              (re source gopt))\n            (str \"\")) :gsub\n          (re source gexp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (re source gopt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (re source gexp\n          (str \"\\\\?\")\n          (re source gopt))\n        (str \"{0,1}\")) :gsub\n      (re source gexp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (re source gexp\n    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :reg source ) :gsub\n              (reg source exp\n                (str \"^/?\\\\^?\")\n                (reg source opt))\n              (str \"\")) :gsub\n            (reg source exp\n              (str \"\\\\$?/?$\")\n              (reg source opt))\n            (str \"\")) :gsub\n          (reg source exp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (reg source opt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (reg source exp\n          (str \"\\\\?\")\n          (reg source opt))\n        (str \"{0,1}\")) :gsub\n      (reg source exp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (reg source exp\n    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :re source g) :gsub\n          (re source gexp\n            (str \"^/?\\\\^?\")\n            (re source gopt))\n          (str \"\")) :gsub\n        (re source gexp\n          (str \"\\\\$?/?$\")\n          (re source gopt))\n        (str \"\")) :gsub\n      (re source gexp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (re source gopt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (re source gexp\n      (str \"\\\\?\")\n      (re source gopt))\n    (str \"{0,1}\")) :gsub\n  (re source gexp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :reg source ) :gsub\n          (reg source exp\n            (str \"^/?\\\\^?\")\n            (reg source opt))\n          (str \"\")) :gsub\n        (reg source exp\n          (str \"\\\\$?/?$\")\n          (reg source opt))\n        (str \"\")) :gsub\n      (reg source exp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (reg source opt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (reg source exp\n      (str \"\\\\?\")\n      (reg source opt))\n    (str \"{0,1}\")) :gsub\n  (reg source exp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :re source g) :gsub\n                                  (re source gexp\n                                    (str \"^/?\\\\^?\")\n                                    (re source gopt))\n                                  (str \"\")) :gsub\n                                (re source gexp\n                                  (str \"\\\\$?/?$\")\n                                  (re source gopt))\n                                (str \"\")) :gsub\n                              (re source gexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (re source gopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (re source gexp\n                              (str \"\\\\?\")\n                              (re source gopt))\n                            (str \"{0,1}\")) :gsub\n                          (re source gexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (re source gopt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (re source gexp\n                        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (re source gopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (re source gexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (re source gexp\n                (str \"\\\\((.*?)\\\\)\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (re source gexp\n                    (str \"[()]\")\n                    (re source gopt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (re source gexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (re source gexp\n              (str \"(\\\\w-\\\\w)\")\n              (re source gopt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (re source gexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :chars))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :reg source ) :gsub\n                                  (reg source exp\n                                    (str \"^/?\\\\^?\")\n                                    (reg source opt))\n                                  (str \"\")) :gsub\n                                (reg source exp\n                                  (str \"\\\\$?/?$\")\n                                  (reg source opt))\n                                (str \"\")) :gsub\n                              (reg source exp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (reg source opt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (reg source exp\n                              (str \"\\\\?\")\n                              (reg source opt))\n                            (str \"{0,1}\")) :gsub\n                          (reg source exp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (reg source opt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (reg source exp\n                        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (reg source opt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (reg source exp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (reg source exp\n                (str \"\\\\((.*?)\\\\)\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (reg source exp\n                    (str \"[()]\")\n                    (reg source opt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (reg source exp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (reg source exp\n              (str \"(\\\\w-\\\\w)\")\n              (reg source opt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (reg source exp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :chars))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :re source g) :gsub\n                                  (re source gexp\n                                    (str \"^/?\\\\^?\")\n                                    (re source gopt))\n                                  (str \"\")) :gsub\n                                (re source gexp\n                                  (str \"\\\\$?/?$\")\n                                  (re source gopt))\n                                (str \"\")) :gsub\n                              (re source gexp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (re source gopt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (str \"?\")\n                            (str \"{0,1}\")) :gsub\n                          (re source gexp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (re source gopt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (re source gexp\n                        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (re source gopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (re source gexp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (re source gexp\n                (str \"\\\\((.*?)\\\\)\")\n                (re source gopt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (re source gexp\n                    (str \"[()]\")\n                    (re source gopt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (re source gexp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (re source gexp\n              (str \"(\\\\w-\\\\w)\")\n              (re source gopt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (re source gexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :chars))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (block\n                        (send\n                          (send\n                            (send\n                              (send\n                                (send\n                                  (lvar :reg source ) :gsub\n                                  (reg source exp\n                                    (str \"^/?\\\\^?\")\n                                    (reg source opt))\n                                  (str \"\")) :gsub\n                                (reg source exp\n                                  (str \"\\\\$?/?$\")\n                                  (reg source opt))\n                                (str \"\")) :gsub\n                              (reg source exp\n                                (str \"\\\\{(\\\\d+)\\\\}\")\n                                (reg source opt))\n                              (str \"{\\\\1,\\\\1}\")) :gsub\n                            (str \"?\")\n                            (str \"{0,1}\")) :gsub\n                          (reg source exp\n                            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                            (reg source opt)))\n                        (args\n                          (arg :_match))\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 1)) :*\n                          (send nil :sample\n                            (send nil :Array\n                              (send\n                                (const nil :Range) :new\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 2)) :to_i)\n                                (send\n                                  (send\n                                    (const nil :Regexp) :last_match\n                                    (int 3)) :to_i)))))) :gsub\n                      (reg source exp\n                        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (reg source opt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (reg source exp\n                    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (reg source exp\n                (str \"\\\\((.*?)\\\\)\")\n                (reg source opt)))\n            (args\n              (arg :match))\n            (send nil :sample\n              (send\n                (send\n                  (lvar :match) :gsub\n                  (reg source exp\n                    (str \"[()]\")\n                    (reg source opt))\n                  (str \"\")) :split\n                (str \"|\")))) :gsub\n          (reg source exp\n            (str \"\\\\[([^\\\\]]+)\\\\]\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (block\n          (send\n            (lvar :match) :gsub\n            (reg source exp\n              (str \"(\\\\w-\\\\w)\")\n              (reg source opt)))\n          (args\n            (arg :range))\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (splat\n                  (send\n                    (lvar :range) :split\n                    (str \"-\")))))))) :gsub\n      (reg source exp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send nil :sample\n      (send\n        (send\n          (const nil :Regexp) :last_match\n          (int 1)) :chars))) :gsub\n  (str \"\\\\d\")) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :re source g) :gsub\n                              (re source gexp\n                                (str \"^/?\\\\^?\")\n                                (re source gopt))\n                              (str \"\")) :gsub\n                            (re source gexp\n                              (str \"\\\\$?/?$\")\n                              (re source gopt))\n                            (str \"\")) :gsub\n                          (re source gexp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (re source gopt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (str \"?\")\n                        (str \"{0,1}\")) :gsub\n                      (re source gexp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (re source gopt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (re source gexp\n                    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (re source gexp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (re source gexp\n            (str \"\\\\((.*?)\\\\)\")\n            (re source gopt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (re source gexp\n                (str \"[()]\")\n                (re source gopt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (re source gexp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (re source gexp\n          (str \"(\\\\w-\\\\w)\")\n          (re source gopt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (re source gexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (block\n                    (send\n                      (send\n                        (send\n                          (send\n                            (send\n                              (lvar :reg source ) :gsub\n                              (reg source exp\n                                (str \"^/?\\\\^?\")\n                                (reg source opt))\n                              (str \"\")) :gsub\n                            (reg source exp\n                              (str \"\\\\$?/?$\")\n                              (reg source opt))\n                            (str \"\")) :gsub\n                          (reg source exp\n                            (str \"\\\\{(\\\\d+)\\\\}\")\n                            (reg source opt))\n                          (str \"{\\\\1,\\\\1}\")) :gsub\n                        (str \"?\")\n                        (str \"{0,1}\")) :gsub\n                      (reg source exp\n                        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                        (reg source opt)))\n                    (args\n                      (arg :_match))\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 1)) :*\n                      (send nil :sample\n                        (send nil :Array\n                          (send\n                            (const nil :Range) :new\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 2)) :to_i)\n                            (send\n                              (send\n                                (const nil :Regexp) :last_match\n                                (int 3)) :to_i)))))) :gsub\n                  (reg source exp\n                    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (reg source exp\n                (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (reg source exp\n            (str \"\\\\((.*?)\\\\)\")\n            (reg source opt)))\n        (args\n          (arg :match))\n        (send nil :sample\n          (send\n            (send\n              (lvar :match) :gsub\n              (reg source exp\n                (str \"[()]\")\n                (reg source opt))\n              (str \"\")) :split\n            (str \"|\")))) :gsub\n      (reg source exp\n        (str \"\\\\[([^\\\\]]+)\\\\]\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (block\n      (send\n        (lvar :match) :gsub\n        (reg source exp\n          (str \"(\\\\w-\\\\w)\")\n          (reg source opt)))\n      (args\n        (arg :range))\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (splat\n              (send\n                (lvar :range) :split\n                (str \"-\")))))))) :gsub\n  (reg source exp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :re source g) :gsub\n                          (re source gexp\n                            (str \"^/?\\\\^?\")\n                            (re source gopt))\n                          (str \"\")) :gsub\n                        (re source gexp\n                          (str \"\\\\$?/?$\")\n                          (re source gopt))\n                        (str \"\")) :gsub\n                      (re source gexp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (re source gopt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (str \"?\")\n                    (str \"{0,1}\")) :gsub\n                  (re source gexp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (re source gopt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (re source gexp\n                (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (re source gexp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (re source gexp\n        (str \"\\\\((.*?)\\\\)\")\n        (re source gopt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (re source gexp\n            (str \"[()]\")\n            (re source gopt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (re source gexp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (block\n                (send\n                  (send\n                    (send\n                      (send\n                        (send\n                          (lvar :reg source ) :gsub\n                          (reg source exp\n                            (str \"^/?\\\\^?\")\n                            (reg source opt))\n                          (str \"\")) :gsub\n                        (reg source exp\n                          (str \"\\\\$?/?$\")\n                          (reg source opt))\n                        (str \"\")) :gsub\n                      (reg source exp\n                        (str \"\\\\{(\\\\d+)\\\\}\")\n                        (reg source opt))\n                      (str \"{\\\\1,\\\\1}\")) :gsub\n                    (str \"?\")\n                    (str \"{0,1}\")) :gsub\n                  (reg source exp\n                    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                    (reg source opt)))\n                (args\n                  (arg :_match))\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 1)) :*\n                  (send nil :sample\n                    (send nil :Array\n                      (send\n                        (const nil :Range) :new\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 2)) :to_i)\n                        (send\n                          (send\n                            (const nil :Regexp) :last_match\n                            (int 3)) :to_i)))))) :gsub\n              (reg source exp\n                (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (reg source exp\n            (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (reg source exp\n        (str \"\\\\((.*?)\\\\)\")\n        (reg source opt)))\n    (args\n      (arg :match))\n    (send nil :sample\n      (send\n        (send\n          (lvar :match) :gsub\n          (reg source exp\n            (str \"[()]\")\n            (reg source opt))\n          (str \"\")) :split\n        (str \"|\")))) :gsub\n  (reg source exp\n    (str \"\\\\[([^\\\\]]+)\\\\]\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :re source g) :gsub\n                      (re source gexp\n                        (str \"^/?\\\\^?\")\n                        (re source gopt))\n                      (str \"\")) :gsub\n                    (re source gexp\n                      (str \"\\\\$?/?$\")\n                      (re source gopt))\n                    (str \"\")) :gsub\n                  (re source gexp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (re source gopt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (str \"?\")\n                (str \"{0,1}\")) :gsub\n              (re source gexp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (re source gopt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (re source gexp\n            (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (re source gexp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (re source gexp\n    (str \"\\\\((.*?)\\\\)\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (block\n            (send\n              (send\n                (send\n                  (send\n                    (send\n                      (lvar :reg source ) :gsub\n                      (reg source exp\n                        (str \"^/?\\\\^?\")\n                        (reg source opt))\n                      (str \"\")) :gsub\n                    (reg source exp\n                      (str \"\\\\$?/?$\")\n                      (reg source opt))\n                    (str \"\")) :gsub\n                  (reg source exp\n                    (str \"\\\\{(\\\\d+)\\\\}\")\n                    (reg source opt))\n                  (str \"{\\\\1,\\\\1}\")) :gsub\n                (str \"?\")\n                (str \"{0,1}\")) :gsub\n              (reg source exp\n                (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n                (reg source opt)))\n            (args\n              (arg :_match))\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 1)) :*\n              (send nil :sample\n                (send nil :Array\n                  (send\n                    (const nil :Range) :new\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 2)) :to_i)\n                    (send\n                      (send\n                        (const nil :Regexp) :last_match\n                        (int 3)) :to_i)))))) :gsub\n          (reg source exp\n            (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (reg source exp\n        (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (reg source exp\n    (str \"\\\\((.*?)\\\\)\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :re source g) :gsub\n                  (re source gexp\n                    (str \"^/?\\\\^?\")\n                    (re source gopt))\n                  (str \"\")) :gsub\n                (re source gexp\n                  (str \"\\\\$?/?$\")\n                  (re source gopt))\n                (str \"\")) :gsub\n              (re source gexp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (re source gopt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (str \"?\")\n            (str \"{0,1}\")) :gsub\n          (re source gexp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (re source gopt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (re source gexp\n        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (re source gexp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (block\n        (send\n          (send\n            (send\n              (send\n                (send\n                  (lvar :reg source ) :gsub\n                  (reg source exp\n                    (str \"^/?\\\\^?\")\n                    (reg source opt))\n                  (str \"\")) :gsub\n                (reg source exp\n                  (str \"\\\\$?/?$\")\n                  (reg source opt))\n                (str \"\")) :gsub\n              (reg source exp\n                (str \"\\\\{(\\\\d+)\\\\}\")\n                (reg source opt))\n              (str \"{\\\\1,\\\\1}\")) :gsub\n            (str \"?\")\n            (str \"{0,1}\")) :gsub\n          (reg source exp\n            (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n            (reg source opt)))\n        (args\n          (arg :_match))\n        (send\n          (send\n            (const nil :Regexp) :last_match\n            (int 1)) :*\n          (send nil :sample\n            (send nil :Array\n              (send\n                (const nil :Range) :new\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 2)) :to_i)\n                (send\n                  (send\n                    (const nil :Regexp) :last_match\n                    (int 3)) :to_i)))))) :gsub\n      (reg source exp\n        (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (reg source exp\n    (str \"(\\\\\\\\?.)\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :re source g) :gsub\n              (re source gexp\n                (str \"^/?\\\\^?\")\n                (re source gopt))\n              (str \"\")) :gsub\n            (re source gexp\n              (str \"\\\\$?/?$\")\n              (re source gopt))\n            (str \"\")) :gsub\n          (re source gexp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (re source gopt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (str \"?\")\n        (str \"{0,1}\")) :gsub\n      (re source gexp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (re source gopt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (re source gexp\n    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (block\n    (send\n      (send\n        (send\n          (send\n            (send\n              (lvar :reg source ) :gsub\n              (reg source exp\n                (str \"^/?\\\\^?\")\n                (reg source opt))\n              (str \"\")) :gsub\n            (reg source exp\n              (str \"\\\\$?/?$\")\n              (reg source opt))\n            (str \"\")) :gsub\n          (reg source exp\n            (str \"\\\\{(\\\\d+)\\\\}\")\n            (reg source opt))\n          (str \"{\\\\1,\\\\1}\")) :gsub\n        (str \"?\")\n        (str \"{0,1}\")) :gsub\n      (reg source exp\n        (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n        (reg source opt)))\n    (args\n      (arg :_match))\n    (send\n      (send\n        (const nil :Regexp) :last_match\n        (int 1)) :*\n      (send nil :sample\n        (send nil :Array\n          (send\n            (const nil :Range) :new\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 2)) :to_i)\n            (send\n              (send\n                (const nil :Regexp) :last_match\n                (int 3)) :to_i)))))) :gsub\n  (reg source exp\n    (str \"(\\\\([^)]+\\\\))\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :re source g) :gsub\n          (re source gexp\n            (str \"^/?\\\\^?\")\n            (re source gopt))\n          (str \"\")) :gsub\n        (re source gexp\n          (str \"\\\\$?/?$\")\n          (re source gopt))\n        (str \"\")) :gsub\n      (re source gexp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (re source gopt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (str \"?\")\n    (str \"{0,1}\")) :gsub\n  (re source gexp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (re source gopt))) gsub ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :reg source ) :gsub\n          (reg source exp\n            (str \"^/?\\\\^?\")\n            (reg source opt))\n          (str \"\")) :gsub\n        (reg source exp\n          (str \"\\\\$?/?$\")\n          (reg source opt))\n        (str \"\")) :gsub\n      (reg source exp\n        (str \"\\\\{(\\\\d+)\\\\}\")\n        (reg source opt))\n      (str \"{\\\\1,\\\\1}\")) :gsub\n    (str \"?\")\n    (str \"{0,1}\")) :gsub\n  (reg source exp\n    (str \"(\\\\[[^\\\\]]+\\\\])\\\\{(\\\\d+),(\\\\d+)\\\\}\")\n    (reg source opt))) gsub "]}," Faker Lorem resolve":{"type":"method","name":"resolve","children":[],"call":[" rand + ","value first "," rand ","(send\n  (send\n    (lvar :value) :last) :+\n  (int 1)) - ","value last + ","value last ","value [] ","value size ","value sample "," sample "]}," Faker Lorem word":{"type":"method","name":"word","children":[],"call":[" translate sample "," translate "," sample "," words first "," words "]}," Faker Address building_number":{"type":"method","name":"building_number","children":[],"call":[" bothify "," fetch "]}," downcase":{"type":"method","name":"downcase","children":[],"call":[" to_s downcase intern "," to_s downcase "," to_s "]}," Faker Number digit":{"type":"method","name":"digit","children":[],"call":[" rand to_s "," rand ","(send\n  (send nil :rand) :*\n  (int 9)) round to_s ","(send\n  (send nil :rand) :*\n  (int 9)) round "," rand * "]}," Faker Number number":{"type":"method","name":"number","children":[],"call":[" rand to_s center "," rand to_s "," rand ","digits ** - ","digits ** "," rand to_s rjust ","10 ** ","(send\n  (begin\n    (irange\n      (int 1)\n      (lvar :digits))) :collect) join "," digit ","(irange\n  (int 1)\n  (lvar :digits)) collect ","num + "," leading_zero_number "," non_zero_digit ","digits > ","(send\n  (array\n    (send nil :non_zero_digit)) :+\n  (send nil :generate\n    (send\n      (lvar :digits) :-\n      (int 1)))) join to_i ","(send\n  (array\n    (send nil :non_zero_digit)) :+\n  (send nil :generate\n    (send\n      (lvar :digits) :-\n      (int 1)))) join ","(send nil :non_zero_digit) + "," generate ","digits - ","digits == ","digits < "," rand round ","keywords << ","legacy_digits != "," warn_for_deprecated_arguments "," warn_with_uplevel "," non_zero_digit  + "," leading_zero_ non_zero_digit ber "]}," Faker Internet slug":{"type":"method","name":"slug","children":[],"call":["(or\n  (lvar :words)\n  (send\n    (send\n      (const\n        (const nil :Faker) :Lorem) :words\n      (int 2)) :join\n    (str \" \"))) gsub downcase ","(or\n  (lvar :words)\n  (send\n    (send\n      (const\n        (const nil :Faker) :Lorem) :words\n      (int 2)) :join\n    (str \" \"))) gsub ","Faker Lorem  words join ","Faker Lorem  words ","(str \"-\") sample "," sample ","(or\n  (lvar :words)\n  (send\n    (send\n      (const\n        (const nil :Faker) :Lorem) :words\n      (int 2)) :join\n    (str \" \"))) delete gsub downcase ","(or\n  (lvar :words)\n  (send\n    (send\n      (const\n        (const nil :Faker) :Lorem) :words\n      (int 2)) :join\n    (str \" \"))) delete gsub ","(or\n  (lvar :words)\n  (send\n    (send\n      (const\n        (const nil :Faker) :Lorem) :words\n      (int 2)) :join\n    (str \" \"))) delete ","(or\n  (lvar :words)\n  (send\n    (send\n      (const\n        (const nil :Faker) :Lorem) :words\n      (hash\n        (pair\n          (sym :number)\n          (int 2)))) :join\n    (str \" \"))) delete gsub downcase ","(or\n  (lvar :words)\n  (send\n    (send\n      (const\n        (const nil :Faker) :Lorem) :words\n      (hash\n        (pair\n          (sym :number)\n          (int 2)))) :join\n    (str \" \"))) delete gsub ","(or\n  (lvar :words)\n  (send\n    (send\n      (const\n        (const nil :Faker) :Lorem) :words\n      (hash\n        (pair\n          (sym :number)\n          (int 2)))) :join\n    (str \" \"))) delete ","keywords << ","legacy_glue != ","legacy_words != "," warn_for_deprecated_arguments "," warn_with_uplevel "," sample join "," translate ","words delete gsub downcase ","words delete gsub ","words delete ","words nil? "]}," Faker Internet password":{"type":"method","name":"password","children":[],"call":["Lorem  words join ","Lorem  words ","Lorem  word ","temp length < ","temp length ","temp [] ","min_length > ","Lorem  characters "," rand ","diff_length + ","diff_length > ","max_length - ","temp []= ","chars [] ","Random  rand ","chars length ","Random  rand times ","char upcase ","index % == ","index % ","temp chars each_with_index ","temp chars ","index even? "," rand times ","diff_length positive? ","alpha_count even? ","char =~ ","keywords << ","legacy_special_characters != ","legacy_mix_case != ","legacy_max_length != ","legacy_min_length != "," warn_for_deprecated_arguments "," warn_with_uplevel ","Lorem  characters upcase ","temp size - ","temp size ","temp match ! ","temp match "," raise ","min_length <= "," shuffle join "," shuffle ","password << ","character_bag [] ","character_bag count - ","character_bag count ","password length < ","password length ","special_chars [] ","special_chars count - ","special_chars count ","character_types include? ","upper_chars [] ","upper_chars count - ","upper_chars count ","(irange\n  (str \"A\")\n  (str \"Z\")) to_a ","lower_chars [] ","lower_chars count - ","lower_chars count ","(irange\n  (str \"a\")\n  (str \"z\")) to_a ","character_types join ","min_length < ","character_types << ","max_length < ","digits [] ","digits count - ","digits count ","(irange\n  (str \"1\")\n  (str \"9\")) to_a "," sample ","(irange\n  (str \"0\")\n  (str \"9\")) to_a ","Lorem  words join  length < ","temp []  length < ","Lorem  characters  length < ","Lorem  words join  length ","temp []  length ","Lorem  characters  length ","Lorem  words join  [] ","temp []  [] ","Lorem  characters  [] ","max_length -  + ","max_length -  > ","Lorem  words join  []= ","temp []  []= ","Lorem  characters  []= ","Lorem  words join  chars each_with_index ","temp []  chars each_with_index ","Lorem  characters  chars each_with_index ","Lorem  words join  chars ","temp []  chars ","Lorem  characters  chars ","max_length -  positive? ","Lorem  words join  size - ","temp []  size - ","Lorem  characters  size - ","Lorem  words join  size ","temp []  size ","Lorem  characters  size ","Lorem  words join  match ! ","temp []  match ! ","Lorem  characters  match ! ","Lorem  words join  match ","temp []  match ","Lorem  characters  match ","(irange\n  (str \"A\")\n  (str \"Z\")) to_a  [] ","(irange\n  (str \"A\")\n  (str \"Z\")) to_a  count - ","(irange\n  (str \"A\")\n  (str \"Z\")) to_a  count ","(irange\n  (str \"a\")\n  (str \"z\")) to_a  [] ","(irange\n  (str \"a\")\n  (str \"z\")) to_a  count - ","(irange\n  (str \"a\")\n  (str \"z\")) to_a  count ","(irange\n  (str \"1\")\n  (str \"9\")) to_a  [] ","(irange\n  (str \"0\")\n  (str \"9\")) to_a  [] ","(irange\n  (str \"1\")\n  (str \"9\")) to_a  count - ","(irange\n  (str \"0\")\n  (str \"9\")) to_a  count - ","(irange\n  (str \"1\")\n  (str \"9\")) to_a  count ","(irange\n  (str \"0\")\n  (str \"9\")) to_a  count "]}," Faker Company duns_number":{"type":"method","name":"duns_number","children":[],"call":["(send\n  (str \"%09d\") :%\n  (send nil :rand\n    (send\n      (int 10) :**\n      (int 9)))) gsub ","%09d % "," rand ","10 ** "," format gsub "," format "]}," Faker Commerce product_name":{"type":"method","name":"product_name","children":[],"call":[" fetch + + + + "," fetch "," fetch + + + "," fetch + + "," fetch + "]}," Faker Commerce department":{"type":"method","name":"department","children":[],"call":[" fetch ","categories [] "," merge_categories ","num > "," categories ","1 + "," rand ","keywords << ","legacy_fixed_amount != ","legacy_max != "," warn_for_deprecated_arguments ","categories length > ","categories length ","categories is_a? "," warn_with_uplevel "," categories  [] "," merge_ categories  ","  categories  "," categories  length > "," categories  length "," categories  is_a? "]}," Faker Commerce color":{"type":"method","name":"color","children":[],"call":[" fetch "]}," Faker Code sum":{"type":"method","name":"sum","children":[],"call":["sum + ","block call ","values split each_with_index inject ","values split each_with_index ","values split ","values chars each_with_index inject ","values chars each_with_index ","values chars "]}," Faker Code generate_base13_isbn":{"type":"method","name":"generate_base13_isbn","children":[],"call":["values << ","(send\n  (int 10) :-\n  (lvar :remainder)) % ","10 - ","(send nil :sum\n  (lvar :values)) % ","value to_i * ","value to_i ","index even? "," sum "," regexify ","(send nil :sum\n  (send\n    (lvar :values) :to_s)) % ","offset even? ","values to_s ","g computed ","g lit ","g int "," generate "," regexify  << ","(send\n  (int 10) :-\n  (lvar :(send nil :sum\n  (lvar :values)) % )) % ","(send\n  (int 10) :-\n  (lvar :(send nil :sum\n  (send\n    (lvar :values) :to_s)) % )) % ","(send nil :sum\n  (lvar : regexify )) % ","(send nil :sum\n  (send\n    (lvar : regexify ) :to_s)) % "," regexify  to_s "]}," Faker Code generate_base10_isbn":{"type":"method","name":"generate_base10_isbn","children":[],"call":["values << ","remainder == ","(send nil :sum\n  (lvar :values)) % ","(send\n  (lvar :index) :+\n  (int 1)) * ","value to_i ","index + "," sum "," regexify ","remainder to_s ","(send nil :sum\n  (send\n    (lvar :values) :to_s)) % ","(send\n  (lvar :offset) :+\n  (int 1)) * ","offset + ","values to_s ","g computed ","g lit ","g int "," generate "," regexify  << ","(send nil :sum\n  (lvar :values)) %  == ","(send nil :sum\n  (send\n    (lvar :values) :to_s)) %  == ","(send nil :sum\n  (lvar : regexify )) % ","(send nil :sum\n  (lvar :values)) %  to_s ","(send nil :sum\n  (send\n    (lvar :values) :to_s)) %  to_s ","(send nil :sum\n  (send\n    (lvar : regexify ) :to_s)) % "," regexify  to_s "]}," Faker Code isbn":{"type":"method","name":"isbn","children":[],"call":[" generate_base10_isbn "," generate_base13_isbn ","base == ","keywords << ","legacy_base != "," warn_for_deprecated_arguments "," raise "," warn_with_uplevel "]}," Faker Business credit_card_type":{"type":"method","name":"credit_card_type","children":[],"call":[" fetch "]}," Faker Business credit_card_expiry_date":{"type":"method","name":"credit_card_expiry_date","children":[],"call":["Date  parse "," fetch "," Date  parse "," Date  today + ","365 * "," rand + "," rand "," Date  today "]}," Faker Business credit_card_number":{"type":"method","name":"credit_card_number","children":[],"call":[" fetch "]}," Faker Address time_zone":{"type":"method","name":"time_zone","children":[],"call":[" bothify "," fetch "]}," Faker Team state":{"type":"method","name":"state","children":[],"call":[" fetch titleize "," fetch "]}," Faker Team creature":{"type":"method","name":"creature","children":[],"call":[" fetch "]}," Faker Team name":{"type":"method","name":"name","children":[],"call":[" parse "]}," Faker PhoneNumber subscriber_number":{"type":"method","name":"subscriber_number","children":[],"call":[" rand to_s [] ","1 + "," rand to_s "," rand ","keywords << ","legacy_length != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker PhoneNumber exchange_code":{"type":"method","name":"exchange_code","children":[],"call":[" fetch "]}," Faker PhoneNumber area_code":{"type":"method","name":"area_code","children":[],"call":[" fetch "]}," Faker Number decimal":{"type":"method","name":"decimal","children":[],"call":[" number "," decimal_part ","(begin\n  (lvar :l_d)) to_f "," generate join + "," non_zero_digit to_s "," non_zero_digit "," generate join "," generate ","r_digits - ","r_digits == ","keywords << ","legacy_r_digits != ","legacy_l_digits != "," warn_for_deprecated_arguments "," warn_with_uplevel ","(begin\n  (lvar : number )) to_f "," number igits - "," decimal_part igits - "," generate join + igits - "," generate igits - "," number igits == "," decimal_part igits == "," generate join + igits == "," generate igits == ","legacy_ number igits != ","legacy_ decimal_part igits != ","legacy_ generate join + igits != ","legacy_ generate igits != "," warn_fo number eprecated_arguments "," warn_fo decimal_part eprecated_arguments "," warn_fo generate join + eprecated_arguments "," warn_fo generate eprecated_arguments "]}," Faker Internet mac_address":{"type":"method","name":"mac_address","children":[],"call":["(send\n  (begin\n    (send\n      (lvar :prefix_digits) :+\n      (lvar :address_digits))) :map) join ","%02x % ","(send\n  (lvar :prefix_digits) :+\n  (lvar :address_digits)) map ","prefix_digits + "," rand ","(send\n  (int 6) :-\n  (send\n    (lvar :prefix_digits) :size)) times map ","(send\n  (int 6) :-\n  (send\n    (lvar :prefix_digits) :size)) times ","6 - ","prefix_digits size ","d to_i ","prefix split map ","prefix split "," format ","Array  new ","keywords << ","legacy_prefix != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Finance credit_card":{"type":"method","name":"credit_card","children":[],"call":["template gsub! ","luhn_digit to_s ","(send\n  (int 10) :-\n  (begin\n    (send\n      (lvar :luhn_sum) :%\n      (int 10)))) % ","10 - ","luhn_sum % ","sum + ","digit_sum + ","(send\n  (lvar :digit) :*\n  (lvar :multiplier)) to_s split map inject ","(send\n  (lvar :digit) :*\n  (lvar :multiplier)) to_s split map ","(send\n  (lvar :digit) :*\n  (lvar :multiplier)) to_s split ","(send\n  (lvar :digit) :*\n  (lvar :multiplier)) to_s ","digit * ","multiplier == ","template gsub split reverse map inject ","template gsub split reverse map ","template gsub split reverse ","template gsub split ","template gsub "," numerify "," fetch ","types sample ","types empty? "," sample ","(send\n  (lvar :digit) :*\n  (lvar :multiplier)) to_s chars map inject ","(send\n  (lvar :digit) :*\n  (lvar :multiplier)) to_s chars map ","(send\n  (lvar :digit) :*\n  (lvar :multiplier)) to_s chars ","template gsub chars reverse map inject ","template gsub chars reverse map ","template gsub chars reverse ","template gsub chars "," numerify  gsub! ","(send\n  (int 10) :-\n  (begin\n    (send\n      (lvar :luhn_sum) :%\n      (int 10)))) %  to_s "," numerify  gsub split reverse map inject "," numerify  gsub split reverse map "," numerify  gsub split reverse "," numerify  gsub split "," numerify  gsub ","types sample s sample "," sample s sample ","types sample s empty? "," sample s empty? "," numerify  gsub chars reverse map inject "," numerify  gsub chars reverse map "," numerify  gsub chars reverse "," numerify  gsub chars "]}," Faker Commerce price":{"type":"method","name":"price","children":[],"call":["(send\n  (send\n    (lvar :random) :rand\n    (irange\n      (int 0)\n      (float 100.0))) :*\n  (int 100)) floor / ","(send\n  (send\n    (lvar :random) :rand\n    (irange\n      (int 0)\n      (float 100.0))) :*\n  (int 100)) floor ","random rand * ","random rand ","Random  new ","(send\n  (send\n    (lvar :random) :rand\n    (lvar :range)) :*\n  (int 100)) floor / ","(send\n  (send\n    (lvar :random) :rand\n    (lvar :range)) :*\n  (int 100)) floor ","price_parts [] + ","price_parts [] ljust ","price_parts [] ","price to_s split ","price to_s ","(send\n  (send nil :rand\n    (lvar :range)) :*\n  (int 100)) floor / ","(send\n  (send nil :rand\n    (lvar :range)) :*\n  (int 100)) floor "," rand * "," rand ","price_parts [] + + ","keywords << ","legacy_as_string != ","legacy_range != "," warn_for_deprecated_arguments "," warn_with_uplevel ","(send\n  (send\n    (lvar :Random  new ) :rand\n    (irange\n      (int 0)\n      (float 100.0))) :*\n  (int 100)) floor / ","(send\n  (send\n    (lvar :Random  new ) :rand\n    (irange\n      (int 0)\n      (float 100.0))) :*\n  (int 100)) floor ","Random  new  rand * ","Random  new  rand ","(send\n  (send\n    (lvar :Random  new ) :rand\n    (lvar :range)) :*\n  (int 100)) floor / ","(send\n  (send\n    (lvar :Random  new ) :rand\n    (lvar :range)) :*\n  (int 100)) floor ","price_parts [] + _parts [] + ","(send\n  (send\n    (lvar :random) :rand\n    (lvar :range)) :*\n  (int 100)) floor / _parts [] + ","(send\n  (send nil :rand\n    (lvar :range)) :*\n  (int 100)) floor / _parts [] + ","price_parts [] + + _parts [] + ","price to_s split  [] + ","price_parts [] + _parts [] ljust ","(send\n  (send\n    (lvar :random) :rand\n    (lvar :range)) :*\n  (int 100)) floor / _parts [] ljust ","(send\n  (send nil :rand\n    (lvar :range)) :*\n  (int 100)) floor / _parts [] ljust ","price_parts [] + + _parts [] ljust ","price to_s split  [] ljust ","price_parts [] + _parts [] ","(send\n  (send\n    (lvar :random) :rand\n    (lvar :range)) :*\n  (int 100)) floor / _parts [] ","(send\n  (send nil :rand\n    (lvar :range)) :*\n  (int 100)) floor / _parts [] ","price_parts [] + + _parts [] ","price to_s split  [] ","price_parts [] +  to_s split ","(send\n  (send\n    (lvar :random) :rand\n    (lvar :range)) :*\n  (int 100)) floor /  to_s split ","(send\n  (send nil :rand\n    (lvar :range)) :*\n  (int 100)) floor /  to_s split ","price_parts [] + +  to_s split ","price_parts [] +  to_s ","(send\n  (send\n    (lvar :random) :rand\n    (lvar :range)) :*\n  (int 100)) floor /  to_s ","(send\n  (send nil :rand\n    (lvar :range)) :*\n  (int 100)) floor /  to_s ","price_parts [] + +  to_s ","price_parts [] + _parts [] + + ","(send\n  (send\n    (lvar :random) :rand\n    (lvar :range)) :*\n  (int 100)) floor / _parts [] + + ","(send\n  (send nil :rand\n    (lvar :range)) :*\n  (int 100)) floor / _parts [] + + ","price_parts [] + + _parts [] + + ","price to_s split  [] + + "]}," Faker Bitcoin base58":{"type":"method","name":"base58","children":[],"call":["1 * + ","ret reverse ","1 * ","str match [] to_s size ","str match [] to_s ","str match [] ","str match ","0 chr ","ret << ","alphabet [] ","lv divmod ","lv > ","v unpack [] * ","256 ** ","v unpack [] ","v unpack ","str split reverse each_with_index ","str split reverse ","str split ","alphabet size "]}," Faker Bitcoin address":{"type":"method","name":"address","children":[],"call":[" base58 ","packed + ","Digest SHA2  digest [] ","Digest SHA2  digest ","version chr + ","(lvar :hash) pack ","version chr "," rand to_s "," rand ","2 ** ","SecureRandom  hex "," address_for ","Faker Blockchain Bitcoin  address ","version chr +  + ","(lvar : rand to_s ) pack ","(lvar :SecureRandom  hex ) pack "]}," Faker Avatar image":{"type":"method","name":"image","children":[],"call":["Faker Lorem  words ","Faker Lorem  words join "," raise ","SUPPORTED_FORMATS  join ","SUPPORTED_FORMATS  include? ","size match ","size =~ ","keywords << ","legacy_bgset != ","legacy_set != ","legacy_format != ","legacy_size != ","legacy_slug != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Base rand_in_range":{"type":"method","name":"rand_in_range","children":[],"call":["Random  new rand ","Random  new ","to < "," rand "]}," Faker Time seconds":{"type":"method","name":"seconds","children":[],"call":["(irange\n  (int 0)\n  (int 59)) to_a sample ","(irange\n  (int 0)\n  (int 59)) to_a "," sample "]}," Faker Time minutes":{"type":"method","name":"minutes","children":[],"call":["60 * "," seconds "]}," Faker Time hours":{"type":"method","name":"hours","children":[],"call":["60 * * ","60 * ","TIME_RANGES  [] to_a sample ","TIME_RANGES  [] to_a ","TIME_RANGES  [] "," raise ","TIME_RANGES  has_key? "," sample ","TIME_RANGES  key? "]}," Faker Time random_time":{"type":"method","name":"random_time","children":[],"call":[" hours + + "," seconds "," hours + "," minutes "," hours "]}," Faker Time backward":{"type":"method","name":"backward","children":[],"call":["(lvar :days) to_time + "," random_time ","(lvar :days) to_time "," date_with_random_time "," time_with_format ","Faker Date  backward ","keywords << ","legacy_format != ","legacy_period != ","legacy_days != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Time forward":{"type":"method","name":"forward","children":[],"call":["(lvar :days) to_time + "," random_time ","(lvar :days) to_time "," date_with_random_time "," time_with_format ","Faker Date  forward ","keywords << ","legacy_format != ","legacy_period != ","legacy_days != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Time between":{"type":"method","name":"between","children":[],"call":["(lvar :from) to_time + "," random_time ","(lvar :from) to_time "," Time  at ","Faker Base  rand_in_range ","to to_f ","from to_f ","to is_a? ","from is_a? "," date_with_random_time "," time_with_format "," rand ","period == "," get_time_object ","keywords << ","legacy_format != ","legacy_to != ","legacy_from != "," warn_for_deprecated_arguments "," warn_with_uplevel ","(lvar :from) to_ date_with_random_time  + ","(lvar :from) to_ rand  + ","(lvar :from) to_Faker Base  rand_in_range  + ","(lvar :from)  get_time_object _time + ","(lvar : get_time_object ) to_time + "," (lvar :from) to_time +  ","  Time  at  "," Faker Base  rand_in_range  "," random_ date_with_random_time  "," random_ rand  "," random_Faker Base  rand_in_range  ","(lvar :from) to_ date_with_random_time  ","(lvar :from) to_ rand  ","(lvar :from) to_Faker Base  rand_in_range  ","(lvar :from)  get_time_object _time ","(lvar : get_time_object ) to_time "," get_time_object   get_time_object _f ","from  get_time_object _f "," get_time_object  to_f "," get_time_object  is_a? "," date_with_(lvar :from) to_time +  "," date_with_ Time  at  "," date_with_Faker Base  rand_in_range  "," date_with_random_ date_with_random_time  "," date_with_random_ rand  "," date_with_random_Faker Base  rand_in_range  ","  date_with_random_time _with_format ","  rand _with_format "," Faker Base  rand_in_range _with_format "," get_ date_with_random_time _object "," get_ rand _object "," get_Faker Base  rand_in_range _object ","legacy_ get_time_object  != "]}," Faker Number should_be":{"type":"method","name":"should_be","children":[],"call":["number * ","number send "]}," Faker Number less_than_zero":{"type":"method","name":"less_than_zero","children":[],"call":[" should_be "]}," Faker Number greater_than_zero":{"type":"method","name":"greater_than_zero","children":[],"call":[" should_be "]}," Faker Number negative":{"type":"method","name":"negative","children":[],"call":[" less_than_zero "," between ","keywords << ","legacy_to != ","legacy_from != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Number positive":{"type":"method","name":"positive","children":[],"call":[" greater_than_zero "," between ","keywords << ","legacy_to != ","legacy_from != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Number between":{"type":"method","name":"between","children":[],"call":["Faker Base  rand_in_range ","keywords << ","legacy_to != ","legacy_from != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Number hexadecimal":{"type":"method","name":"hexadecimal","children":[],"call":[" rand to_s "," rand ","digits times ","keywords << ","legacy_digits != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Hacker phrases":{"type":"method","name":"phrases","children":[],"call":[" noun "," abbreviation "," adjective "," verb "," ingverb ","(begin\n  (send nil :ingverb)) capitalize "]}," Faker Hacker ingverb":{"type":"method","name":"ingverb","children":[],"call":[" fetch "]}," Faker Hacker verb":{"type":"method","name":"verb","children":[],"call":[" fetch "]}," Faker Hacker noun":{"type":"method","name":"noun","children":[],"call":[" fetch "]}," Faker Hacker adjective":{"type":"method","name":"adjective","children":[],"call":[" fetch "]}," Faker Hacker abbreviation":{"type":"method","name":"abbreviation","children":[],"call":[" fetch "]}," Faker Hacker say_something_smart":{"type":"method","name":"say_something_smart","children":[],"call":[" phrases sample "," phrases "," sample "]}," Faker Date get_date_object":{"type":"method","name":"get_date_object","children":[],"call":["date to_date ","date respond_to? "," Date  parse ","date is_a? ","date to_date  to_date to_date  "," Date  parse  to_ Date  parse  ","date to_date  respond_to? "," Date  parse  respond_to? ","date to_date  is_a? "," Date  parse  is_a? "]}," Faker Date backward":{"type":"method","name":"backward","children":[],"call":[" between to_date "," between "," Date  today - "," Date  today ","keywords << ","legacy_days != "," warn_for_deprecated_arguments "," warn_with_uplevel "," between  Date  today - _date "," Date   Date  today - day - "," Date   Date  today - day "]}," Faker Date forward":{"type":"method","name":"forward","children":[],"call":[" between to_date "," between "," Date  today + "," Date  today ","keywords << ","legacy_days != "," warn_for_deprecated_arguments "," warn_with_uplevel ","start_date + "," get_date_object "," between  Date  today + _date "," between start_date + _date "," Date   Date  today + day + "," Date  start_date + day + "," Date   Date  today + day "," Date  start_date + day "," get_date_object  + "]}," Faker Date between":{"type":"method","name":"between","children":[],"call":["Faker Base  rand_in_range "," get_date_object ","keywords << ","legacy_to != ","legacy_from != "," warn_for_deprecated_arguments "," warn_with_uplevel ","legacy_ get_date_object  != "]}," Faker Company logo":{"type":"method","name":"logo","children":[],"call":["rand_num < ","Random  rand + ","Random  rand "," rand + "," rand ","Random  rand +  < "," rand +  < "," rand  < "]}," Faker Code rut_verificator_digit":{"type":"method","name":"rut_verificator_digit","children":[],"call":["(send\n  (int 11) :-\n  (send\n    (lvar :total) :%\n    (int 11))) to_s gsub gsub ","(send\n  (int 11) :-\n  (send\n    (lvar :total) :%\n    (int 11))) to_s gsub ","(send\n  (int 11) :-\n  (send\n    (lvar :total) :%\n    (int 11))) to_s ","11 - ","total % ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :rut) :to_s) :rjust\n        (int 8)\n        (str \"0\")) :split\n      (regexp\n        (regopt))) :zip\n    (array\n      (str \"3\")\n      (str \"2\")\n      (str \"7\")\n      (str \"6\")\n      (str \"5\")\n      (str \"4\")\n      (str \"3\")\n      (str \"2\"))) :collect) inject ","a to_i * ","b to_i ","a to_i ","rut to_s rjust split zip collect ","rut to_s rjust split zip ","rut to_s rjust split ","rut to_s rjust ","rut to_s ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :rut) :to_s) :rjust\n        (int 8)\n        (str \"0\")) :chars) :zip\n    (array\n      (str \"3\")\n      (str \"2\")\n      (str \"7\")\n      (str \"6\")\n      (str \"5\")\n      (str \"4\")\n      (str \"3\")\n      (str \"2\"))) :collect) inject ","rut to_s rjust chars zip collect ","rut to_s rjust chars zip ","rut to_s rjust chars ","(send\n  (int 11) :-\n  (send\n    (lvar :(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :rut) :to_s) :rjust\n        (int 8)\n        (str \"0\")) :split\n      (regexp\n        (regopt))) :zip\n    (array\n      (str \"3\")\n      (str \"2\")\n      (str \"7\")\n      (str \"6\")\n      (str \"5\")\n      (str \"4\")\n      (str \"3\")\n      (str \"2\"))) :collect) inject ) :%\n    (int 11))) to_s gsub gsub ","(send\n  (int 11) :-\n  (send\n    (lvar :(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :rut) :to_s) :rjust\n        (int 8)\n        (str \"0\")) :chars) :zip\n    (array\n      (str \"3\")\n      (str \"2\")\n      (str \"7\")\n      (str \"6\")\n      (str \"5\")\n      (str \"4\")\n      (str \"3\")\n      (str \"2\"))) :collect) inject ) :%\n    (int 11))) to_s gsub gsub ","(send\n  (int 11) :-\n  (send\n    (lvar :(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :rut) :to_s) :rjust\n        (int 8)\n        (str \"0\")) :split\n      (regexp\n        (regopt))) :zip\n    (array\n      (str \"3\")\n      (str \"2\")\n      (str \"7\")\n      (str \"6\")\n      (str \"5\")\n      (str \"4\")\n      (str \"3\")\n      (str \"2\"))) :collect) inject ) :%\n    (int 11))) to_s gsub ","(send\n  (int 11) :-\n  (send\n    (lvar :(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :rut) :to_s) :rjust\n        (int 8)\n        (str \"0\")) :chars) :zip\n    (array\n      (str \"3\")\n      (str \"2\")\n      (str \"7\")\n      (str \"6\")\n      (str \"5\")\n      (str \"4\")\n      (str \"3\")\n      (str \"2\"))) :collect) inject ) :%\n    (int 11))) to_s gsub ","(send\n  (int 11) :-\n  (send\n    (lvar :(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :rut) :to_s) :rjust\n        (int 8)\n        (str \"0\")) :split\n      (regexp\n        (regopt))) :zip\n    (array\n      (str \"3\")\n      (str \"2\")\n      (str \"7\")\n      (str \"6\")\n      (str \"5\")\n      (str \"4\")\n      (str \"3\")\n      (str \"2\"))) :collect) inject ) :%\n    (int 11))) to_s ","(send\n  (int 11) :-\n  (send\n    (lvar :(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :rut) :to_s) :rjust\n        (int 8)\n        (str \"0\")) :chars) :zip\n    (array\n      (str \"3\")\n      (str \"2\")\n      (str \"7\")\n      (str \"6\")\n      (str \"5\")\n      (str \"4\")\n      (str \"3\")\n      (str \"2\"))) :collect) inject ) :%\n    (int 11))) to_s ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :rut) :to_s) :rjust\n        (int 8)\n        (str \"0\")) :split\n      (regexp\n        (regopt))) :zip\n    (array\n      (str \"3\")\n      (str \"2\")\n      (str \"7\")\n      (str \"6\")\n      (str \"5\")\n      (str \"4\")\n      (str \"3\")\n      (str \"2\"))) :collect) inject  % ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :rut) :to_s) :rjust\n        (int 8)\n        (str \"0\")) :chars) :zip\n    (array\n      (str \"3\")\n      (str \"2\")\n      (str \"7\")\n      (str \"6\")\n      (str \"5\")\n      (str \"4\")\n      (str \"3\")\n      (str \"2\"))) :collect) inject  % "]}," Faker Code generate_base13_ean":{"type":"method","name":"generate_base13_ean","children":[],"call":["values << ","(send\n  (int 10) :-\n  (lvar :check_digit)) to_s ","10 - ","(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) % ","s + ","v to_i * ","EAN_CHECK_DIGIT13  [] ","v to_i ","values split each_with_index inject ","values split each_with_index ","values split "," regexify ","(if\n  (send\n    (lvar :check_digit) :==\n    (int 10))\n  (int 0)\n  (lvar :check_digit)) to_s ","check_digit == ","(send\n  (send\n    (send\n      (lvar :values) :chars) :each_with_index) :inject\n  (int 0)) % ","values chars each_with_index inject ","values chars each_with_index ","values chars ","(send\n  (send\n    (send\n      (send\n        (lvar :values) :to_s) :chars) :each_with_index) :inject\n  (int 0)) % ","values to_s chars each_with_index inject ","values to_s chars each_with_index ","values to_s chars ","values to_s ","g computed ","g int "," generate "," regexify  << ","(send\n  (int 10) :-\n  (lvar :(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) % )) to_s ","(send\n  (int 10) :-\n  (lvar :10 - )) to_s ","(send\n  (send\n    (send\n      (lvar : regexify ) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) % "," regexify  split each_with_index inject "," regexify  split each_with_index "," regexify  split ","(if\n  (send\n    (lvar :(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) % ) :==\n    (int 10))\n  (int 0)\n  (lvar :(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) % )) to_s ","(if\n  (send\n    (lvar :10 - ) :==\n    (int 10))\n  (int 0)\n  (lvar :10 - )) to_s ","(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) %  == ","10 -  == ","(send\n  (send\n    (send\n      (lvar : regexify ) :chars) :each_with_index) :inject\n  (int 0)) % "," regexify  chars each_with_index inject "," regexify  chars each_with_index "," regexify  chars ","(send\n  (send\n    (send\n      (send\n        (lvar : regexify ) :to_s) :chars) :each_with_index) :inject\n  (int 0)) % "," regexify  to_s chars each_with_index inject "," regexify  to_s chars each_with_index "," regexify  to_s chars "," regexify  to_s "]}," Faker Code generate_base8_ean":{"type":"method","name":"generate_base8_ean","children":[],"call":["values << ","(send\n  (int 10) :-\n  (lvar :check_digit)) to_s ","10 - ","(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) % ","s + ","v to_i * ","EAN_CHECK_DIGIT8  [] ","v to_i ","values split each_with_index inject ","values split each_with_index ","values split "," regexify ","(if\n  (send\n    (lvar :check_digit) :==\n    (int 10))\n  (int 0)\n  (lvar :check_digit)) to_s ","check_digit == ","(send\n  (send\n    (send\n      (lvar :values) :chars) :each_with_index) :inject\n  (int 0)) % ","values chars each_with_index inject ","values chars each_with_index ","values chars ","(send\n  (send\n    (send\n      (send\n        (lvar :values) :to_s) :chars) :each_with_index) :inject\n  (int 0)) % ","values to_s chars each_with_index inject ","values to_s chars each_with_index ","values to_s chars ","values to_s ","g computed ","g int "," generate "," regexify  << ","(send\n  (int 10) :-\n  (lvar :(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) % )) to_s ","(send\n  (int 10) :-\n  (lvar :10 - )) to_s ","(send\n  (send\n    (send\n      (lvar : regexify ) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) % "," regexify  split each_with_index inject "," regexify  split each_with_index "," regexify  split ","(if\n  (send\n    (lvar :(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) % ) :==\n    (int 10))\n  (int 0)\n  (lvar :(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) % )) to_s ","(if\n  (send\n    (lvar :10 - ) :==\n    (int 10))\n  (int 0)\n  (lvar :10 - )) to_s ","(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :each_with_index) :inject\n  (int 0)) %  == ","10 -  == ","(send\n  (send\n    (send\n      (lvar : regexify ) :chars) :each_with_index) :inject\n  (int 0)) % "," regexify  chars each_with_index inject "," regexify  chars each_with_index "," regexify  chars ","(send\n  (send\n    (send\n      (send\n        (lvar : regexify ) :to_s) :chars) :each_with_index) :inject\n  (int 0)) % "," regexify  to_s chars each_with_index inject "," regexify  to_s chars each_with_index "," regexify  to_s chars "," regexify  to_s "]}," Faker Code rut":{"type":"method","name":"rut","children":[],"call":["value << "," rut_verificator_digit ","Number  number ","Number  number to_s ","Number  number  << ","Number  number to_s  << "]}," Faker Code ean":{"type":"method","name":"ean","children":[],"call":[" generate_base13_ean "," generate_base8_ean ","base == ","keywords << ","legacy_base != "," warn_for_deprecated_arguments "," raise "," warn_with_uplevel "]}," Faker Address country_code":{"type":"method","name":"country_code","children":[],"call":[" fetch "]}," Faker Lorem character":{"type":"method","name":"character","children":[],"call":[" characters ","CHARACTERS  sample "," sample "]}," Faker Date birthday":{"type":"method","name":"birthday","children":[],"call":[" between to_date "," between "," Date  new ","t day ","t month ","t year - ","t year "," Date  today ","years [] "," handled_leap_years "," prepare_bounds "," birthday_date ","keywords << ","legacy_max_age != "," warn_for_deprecated_arguments ","legacy_min_age != "," warn_with_uplevel "," between  Date  new _date "," between  birthday_date _date "," be Date  today ween  Date  today o_da Date  today e "," be Date  today ween "," Da Date  today e  new "," Date  today  day "," Date  today  mon Date  today h "," Date  today  year - "," Date  today  year "," Date   Date  new day "," Date   birthday_date day "," Da Date  today e   Date  today oday "," handled_leap_years  [] "," handled_leap_ handled_leap_years  "," bir Date  today hday_da Date  today e "," warn_for_depreca Date  today ed_argumen Date  today s "," warn_wi Date  today h_uplevel "]}," Faker Company ein":{"type":"method","name":"ein","children":[],"call":["(send\n  (str \"%09d\") :%\n  (send nil :rand\n    (send\n      (int 10) :**\n      (int 9)))) gsub ","%09d % "," rand ","10 ** "," format gsub "," format "]}," Faker Commerce merge_categories":{"type":"method","name":"merge_categories","children":[],"call":["(lvar :comma_separated) join ","categories [] ","categories slice! join ","categories slice! "," fetch ","(lvar :categories slice! join ) join "]}," Faker Commerce categories":{"type":"method","name":"categories","children":[],"call":["categories << ","categories include? "," fetch ","categories length < ","categories length "," sample "," fetch_all "]}," Faker App author":{"type":"method","name":"author","children":[],"call":[" parse "]}," Faker App version":{"type":"method","name":"version","children":[],"call":[" parse "," numerify "," fetch "," parse == "]}," Faker App name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Char romanize_cyrillic":{"type":"method","name":"romanize_cyrillic","children":[],"call":[]}," Faker Char fix_umlauts":{"type":"method","name":"fix_umlauts","children":[],"call":[]}," Faker Char prepare":{"type":"method","name":"prepare","children":[],"call":[]}," Faker University suffix":{"type":"method","name":"suffix","children":[],"call":[" fetch "]}," Faker University prefix":{"type":"method","name":"prefix","children":[],"call":[" fetch "]}," Faker University name":{"type":"method","name":"name","children":[],"call":[" parse "]}," Faker SlackEmoji emoji":{"type":"method","name":"emoji","children":[],"call":[" parse "]}," Faker SlackEmoji custom":{"type":"method","name":"custom","children":[],"call":[" fetch "]}," Faker SlackEmoji objects_and_symbols":{"type":"method","name":"objects_and_symbols","children":[],"call":[" fetch "]}," Faker SlackEmoji travel_and_places":{"type":"method","name":"travel_and_places","children":[],"call":[" fetch "]}," Faker SlackEmoji activity":{"type":"method","name":"activity","children":[],"call":[" fetch "]}," Faker SlackEmoji celebration":{"type":"method","name":"celebration","children":[],"call":[" fetch "]}," Faker SlackEmoji food_and_drink":{"type":"method","name":"food_and_drink","children":[],"call":[" fetch "]}," Faker SlackEmoji nature":{"type":"method","name":"nature","children":[],"call":[" fetch "]}," Faker SlackEmoji people":{"type":"method","name":"people","children":[],"call":[" fetch "]}," Faker Internet device_token":{"type":"method","name":"device_token","children":[],"call":[" rand to_s rjust chars to_a shuffle join "," rand to_s rjust chars to_a shuffle "," rand to_s rjust chars to_a "," rand to_s rjust chars "," rand to_s rjust "," rand to_s "," rand ","16 ** "," shuffle join "," shuffle "]}," Faker Company luhn_algorithm":{"type":"method","name":"luhn_algorithm","children":[],"call":["(send\n  (send\n    (lvar :sum) :/\n    (int 10)) :+\n  (int 1)) * - ","(send\n  (send\n    (lvar :sum) :/\n    (int 10)) :+\n  (int 1)) * ","sum / + ","sum / ","sum % == ","sum % ","character chr to_i ","character chr ","num to_s each_byte ","num to_s ","multiplications each ","multiplications << ","digit to_i ","digit to_i * ","i % == ","i % ","number split each_with_index ","number split ","i even? ","(send\n  (lvar :sum) :%\n  (int 10)) zero? ","number reverse split each_with_index ","number reverse split ","number reverse ","number to_s reverse split each_with_index ","number to_s reverse split ","number to_s reverse ","number to_s ","number to_s reverse chars each_with_index ","number to_s reverse chars "]}," Faker Company swedish_organisation_number":{"type":"method","name":"swedish_organisation_number","children":[],"call":["base + "," luhn_algorithm to_s "," luhn_algorithm ","%09d % "," rand ","10 ** ","(send\n  (array\n    (int 1)\n    (int 2)\n    (int 3)\n    (int 5)\n    (int 6)\n    (int 7)\n    (int 8)\n    (int 9)) :sample) join ","%06d % ","(irange\n  (int 2)\n  (int 9)) to_a sample ","(irange\n  (int 2)\n  (int 9)) to_a ","(irange\n  (int 0)\n  (int 9)) to_a sample ","(irange\n  (int 0)\n  (int 9)) to_a ","(int 1) sample ","(send nil :sample\n  (array\n    (int 1)\n    (int 2)\n    (int 3)\n    (int 5)\n    (int 6)\n    (int 7)\n    (int 8)\n    (int 9))) join "," sample "," format ","(send\n  (array\n    (int 1)\n    (int 2)\n    (int 3)\n    (int 5)\n    (int 6)\n    (int 7)\n    (int 8)\n    (int 9)) :sample) join  + ","(send nil :sample\n  (array\n    (int 1)\n    (int 2)\n    (int 3)\n    (int 5)\n    (int 6)\n    (int 7)\n    (int 8)\n    (int 9))) join  + "]}," Faker Company buzzword":{"type":"method","name":"buzzword","children":[],"call":[" translate flatten sample "," translate flatten "," translate "," sample "]}," Faker Commerce material":{"type":"method","name":"material","children":[],"call":[" fetch "]}," Faker Color hsla_color":{"type":"method","name":"hsla_color","children":[],"call":["@hsla_colors push "," alpha_channel "," single_hsl_color ","3 times "," hsl_color << "," rand round "," rand "," hsl_color "]}," Faker Color hsl_color":{"type":"method","name":"hsl_color","children":[],"call":["@hsl_colors push "," single_hsl_color ","3 times "," rand round "," rand ","(irange\n  (int 0)\n  (int 360)) to_a sample ","(irange\n  (int 0)\n  (int 360)) to_a "," sample "]}," Faker Color alpha_channel":{"type":"method","name":"alpha_channel","children":[],"call":[" rand "]}," Faker Color single_hsl_color":{"type":"method","name":"single_hsl_color","children":[],"call":["Faker Base  rand_in_range round ","Faker Base  rand_in_range "]}," Faker Color rgb_color":{"type":"method","name":"rgb_color","children":[],"call":["@rgb_colors push "," single_rgb_color ","3 times ","3 times collect ","Array  new "]}," Faker Color single_rgb_color":{"type":"method","name":"single_rgb_color","children":[],"call":["(irange\n  (int 0)\n  (int 255)) to_a sample ","(irange\n  (int 0)\n  (int 255)) to_a "," sample "]}," Faker Color hex_color":{"type":"method","name":"hex_color","children":[],"call":["#%06x % "," rand * "," rand "," format "," hsl_to_hex "," hsl_color ","args is_a? ","LIGHTNESS_LOOKUP  [] ","(sym :dark) include? "]}," Faker Code npi":{"type":"method","name":"npi","children":[],"call":["Random  new rand to_s rjust ","Random  new rand to_s ","Random  new rand ","10 ** ","Random  new "," rand to_s rjust "," rand to_s "," rand "]}," Faker Book publisher":{"type":"method","name":"publisher","children":[],"call":[" fetch "]}," Faker Book author":{"type":"method","name":"author","children":[],"call":[" fetch "," parse "]}," Faker Book title":{"type":"method","name":"title","children":[],"call":[" fetch "]}," Faker Bitcoin address_for":{"type":"method","name":"address_for","children":[],"call":[" base58 ","packed + ","Digest SHA2  digest [] ","Digest SHA2  digest ","version chr + ","(lvar :hash) pack ","version chr ","SecureRandom  hex ","PROTOCOL_VERSIONS  fetch ","Random DEFAULT  bytes ","Faker Config  random bytes ","Faker Config  random ","version chr +  + ","PROTOCOL_VERSIONS  fetch  chr + ","(lvar :SecureRandom  hex ) pack ","PROTOCOL_VERSIONS  fetch  chr "]}," Faker Bitcoin testnet_address":{"type":"method","name":"testnet_address","children":[],"call":[" address_for ","Faker Blockchain Bitcoin  testnet_address "]}," Faker Shakespeare romeo_and_juliet":{"type":"method","name":"romeo_and_juliet","children":[],"call":[" fetch ","Faker Quotes Shakespeare  romeo_and_juliet "]}," Faker Shakespeare king_richard_iii":{"type":"method","name":"king_richard_iii","children":[],"call":[" fetch ","Faker Quotes Shakespeare  king_richard_iii "]}," Faker Shakespeare as_you_like_it":{"type":"method","name":"as_you_like_it","children":[],"call":[" fetch ","Faker Quotes Shakespeare  as_you_like_it "]}," Faker Shakespeare hamlet":{"type":"method","name":"hamlet","children":[],"call":[" fetch ","Faker Quotes Shakespeare  hamlet "]}," Faker Shakespeare romeo_and_juliet_quote":{"type":"method","name":"romeo_and_juliet_quote","children":[],"call":[" romeo_and_juliet sample "," romeo_and_juliet "," sample ","Faker Quotes Shakespeare  romeo_and_juliet_quote "]}," Faker Shakespeare king_richard_iii_quote":{"type":"method","name":"king_richard_iii_quote","children":[],"call":[" king_richard_iii sample "," king_richard_iii "," sample ","Faker Quotes Shakespeare  king_richard_iii_quote "]}," Faker Shakespeare as_you_like_it_quote":{"type":"method","name":"as_you_like_it_quote","children":[],"call":[" as_you_like_it sample "," as_you_like_it "," sample ","Faker Quotes Shakespeare  as_you_like_it_quote "]}," Faker Shakespeare hamlet_quote":{"type":"method","name":"hamlet_quote","children":[],"call":[" hamlet sample "," hamlet "," sample ","Faker Quotes Shakespeare  hamlet_quote "]}," Faker Placeholdit image":{"type":"method","name":"image","children":[],"call":[" raise ","text_color match ","text_color nil? ","background_color match ","SUPPORTED_FORMATS  join ","SUPPORTED_FORMATS  include? ","size match ","background_color nil? ","size =~ "," generate_color ","text_color == ","background_color == ","text_color =~ ","background_color =~ ","keywords << ","legacy_text != ","legacy_text_color != ","legacy_background_color != ","legacy_format != ","legacy_size != "," warn_for_deprecated_arguments "," warn_with_uplevel "," generate_color  match "," generate_color  nil? "," generate_color  == "," generate_color  =~ ","legacy_ generate_color  != "]}," Faker Number non_zero_digit":{"type":"method","name":"non_zero_digit","children":[],"call":["(send\n  (send nil :rand\n    (int 9)) :+\n  (int 1)) to_s "," rand + "," rand "," rand to_s "]}," Faker Number decimal_part":{"type":"method","name":"decimal_part","children":[],"call":[" leading_zero_number + "," leading_zero_number "," non_zero_digit ","digits > ","num to_s ","keywords << ","legacy_digits != "," warn_for_deprecated_arguments "," warn_with_uplevel "," leading_zero_ non_zero_digit ber + "," leading_zero_ non_zero_digit ber "," non_zero_digit  to_s "]}," Faker Number leading_zero_number":{"type":"method","name":"leading_zero_number","children":[],"call":["(send\n  (begin\n    (irange\n      (int 1)\n      (lvar :digits))) :collect) join "," digit ","(irange\n  (int 1)\n  (lvar :digits)) collect ","0 + ","(send\n  (begin\n    (irange\n      (int 2)\n      (lvar :digits))) :collect) join ","(irange\n  (int 2)\n  (lvar :digits)) collect ","keywords << ","legacy_digits != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Internet ip_v6_cidr":{"type":"method","name":"ip_v6_cidr","children":[],"call":["(irange\n  (int 1)\n  (int 128)) sample "," ip_v6_address ","1 + "," rand "]}," Faker Internet ip_v4_cidr":{"type":"method","name":"ip_v4_cidr","children":[],"call":["(irange\n  (int 1)\n  (int 32)) sample "," ip_v4_address ","1 + "," rand "]}," Faker Internet public_ip_v4_address":{"type":"method","name":"public_ip_v4_address","children":[],"call":[" ip_v4_address ","is_private [] ","net =~ ","private_nets any? "," lambda "," private_net_checker ","is_reserved [] "," reserved_net_checker "," reserved_net_checker [] "," loop "," ip_v4_ ip_v4_address ess "," private_net_checker  [] "," reserved_net_checker  [] "]}," Faker IDNumber _translate":{"type":"method","name":"_translate","children":[],"call":[" parse "," numerify "," fetch "," parse == "]}," Faker IDNumber ssn_valid":{"type":"method","name":"ssn_valid","children":[],"call":[" ssn_valid ","regex =~ ","INVALID_SSN  any? "," regexify "," format ","Faker Base  rand ","g computed ","g lit ","(irange\n  (int 1)\n  (int 665)) sample ","Faker Config  random "," generate ","  regexify _valid "," ssFaker Base  rand _valid ","INVALID_SSN  aFaker Base  rand y? ","Faker Base  raFaker Base  rand d ","(iraFaker Base  rand ge\n  (iFaker Base  rand t 1)\n  (iFaker Base  rand t 665)) sample ","(i(irange\n  (int 1)\n  (int 665)) sample \n  (int 1)\n  (int 665)) sample ","Faker CoFaker Base  rand fig  raFaker Base  rand dom "," geFaker Base  rand erate "]}," Faker IDNumber invalid":{"type":"method","name":"invalid","children":[],"call":[" _translate "]}," Faker IDNumber valid":{"type":"method","name":"valid","children":[],"call":[" _translate "]}," Faker Hipster resolve":{"type":"method","name":"resolve","children":[],"call":[" rand + ","value first "," rand ","(send\n  (send\n    (lvar :value) :last) :+\n  (int 1)) - ","value last + ","value last ","value [] ","value size ","value to_a [] ","value to_a "]}," Faker Hipster paragraphs":{"type":"method","name":"paragraphs","children":[],"call":["paragraphs << "," paragraph ","1 upto "," resolve "," tap ","keywords << ","legacy_supplemental != ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Hipster paragraph":{"type":"method","name":"paragraph","children":[],"call":[" sentences join "," sentences "," resolve + "," rand to_i "," rand ","random_sentences_to_add to_i "," resolve ","keywords << ","legacy_random_sentences_to_add != ","legacy_supplemental != ","legacy_sentence_count != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Hipster sentences":{"type":"method","name":"sentences","children":[],"call":["sentences << "," sentence ","1 upto "," resolve "," tap ","keywords << ","legacy_supplemental != ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Hipster sentence":{"type":"method","name":"sentence","children":[],"call":[" words join capitalize + "," words join capitalize "," words join "," words ","word_count + "," rand to_i "," rand ","random_words_to_add to_i ","keywords << ","legacy_random_words_to_add != ","legacy_supplemental != ","legacy_word_count != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Hipster words":{"type":"method","name":"words","children":[],"call":["words []= "," word ","w match ","words each_with_index ","word_list shuffle [] ","word_list shuffle ","word_list * ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar :word_list) :length)) + ","resolved_num / ","word_list length "," translate + "," translate "," resolve "," shuffle [] "," shuffle ","w =~ ","keywords << ","legacy_spaces_allowed != ","legacy_supplemental != ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel ","word_list shuffle []  []= "," shuffle []  []= ","word_list shuffle []  each_with_index "," shuffle []  each_with_index ","word_list *  shuffle [] ","word_list *  shuffle ","word_list *  * ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar :word_list * ) :length)) + ","(send\n  (lvar : resolve ) :/\n  (send\n    (lvar :word_list) :length)) + "," resolve  / ","word_list *  length ","keyword_list shuffle []  << ","key shuffle []  << "]}," Faker Hipster word":{"type":"method","name":"word","children":[],"call":[" word ","random_word match "," translate sample "," translate "," sample ","random_word =~ "," translate sample  match "," sample  match "," translate sample  =~ "," sample  =~ "]}," Faker Company profession":{"type":"method","name":"profession","children":[],"call":[" fetch "]}," Faker Company industry":{"type":"method","name":"industry","children":[],"call":[" fetch "]}," Faker Code generate_nric_check_alphabet":{"type":"method","name":"generate_nric_check_alphabet","children":[],"call":["(str \"A\") [] ","10 - ","total % ","total + ","prefix == ","(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :zip\n    (lvar :weight)) :collect) inject ","a to_i * ","b to_i ","a to_i ","values split zip collect ","values split zip ","values split ","(send\n  (send\n    (send\n      (lvar :values) :chars) :zip\n    (lvar :weight)) :collect) inject ","values chars zip collect ","values chars zip ","values chars ","total +  % ","(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :zip\n    (lvar :weight)) :collect) inject  % ","(send\n  (send\n    (send\n      (lvar :values) :chars) :zip\n    (lvar :weight)) :collect) inject  % ","total +  + ","(send\n  (send\n    (send\n      (lvar :values) :split\n      (regexp\n        (regopt))) :zip\n    (lvar :weight)) :collect) inject  + ","(send\n  (send\n    (send\n      (lvar :values) :chars) :zip\n    (lvar :weight)) :collect) inject  + "]}," Faker Code nric":{"type":"method","name":"nric","children":[],"call":[" generate_nric_check_alphabet ","values << "," regexify ","birthyear to_s [] ","birthyear to_s ","birthyear < ","Date  birthday year ","Date  birthday ","keywords << ","legacy_max_age != ","legacy_min_age != "," warn_for_deprecated_arguments "," warn_with_uplevel ","g computed ","g int "," generate "," generate_nric_ generate_nric_check_alphabet bet ","birthyear to_s []  << ","Date  birthday year  to_s [] ","Date  birthday year  to_s ","Date  birthday year  < "]}," Faker Book genre":{"type":"method","name":"genre","children":[],"call":[" fetch "]}," Faker Base with_locale":{"type":"method","name":"with_locale","children":[],"call":["Faker Config  locale= ","I18n  with_locale ","Faker Config  own_locale "," disable_enforce_available_locales ","Faker  load_i18n "]}," Faker Config own_locale":{"type":"method","name":"own_locale","children":[],"call":["Thread  current [] ","Thread  current "]}," Faker Superhero name":{"type":"method","name":"name","children":[],"call":[" parse "]}," Faker Superhero descriptor":{"type":"method","name":"descriptor","children":[],"call":[" fetch "]}," Faker Superhero suffix":{"type":"method","name":"suffix","children":[],"call":[" fetch "]}," Faker Superhero prefix":{"type":"method","name":"prefix","children":[],"call":[" fetch "]}," Faker Superhero power":{"type":"method","name":"power","children":[],"call":[" fetch "]}," Faker StarWars vehicles":{"type":"method","name":"vehicles","children":[],"call":[" fetch "," fetch_all ","Faker Movies StarWars  vehicles "]}," Faker StarWars species":{"type":"method","name":"species","children":[],"call":[" fetch "," fetch_all ","Faker Movies StarWars  species "]}," Faker StarWars quotes":{"type":"method","name":"quotes","children":[],"call":[]}," Faker StarWars planets":{"type":"method","name":"planets","children":[],"call":[" fetch "," fetch_all ","Faker Movies StarWars  planets "]}," Faker StarWars droids":{"type":"method","name":"droids","children":[],"call":[" fetch "," fetch_all ","Faker Movies StarWars  droids "]}," Faker StarWars characters":{"type":"method","name":"characters","children":[],"call":[" fetch "," fetch_all ","Faker Movies StarWars  characters "]}," Faker StarWars vehicle":{"type":"method","name":"vehicle","children":[],"call":[" vehicles sample "," vehicles "," sample ","Faker Movies StarWars  vehicle "]}," Faker StarWars specie":{"type":"method","name":"specie","children":[],"call":[" species sample "," species "," sample ","Faker Movies StarWars  specie "]}," Faker StarWars quote":{"type":"method","name":"quote","children":[],"call":[" quotes sample "," quotes "," sample "," fetch ","star_wars.quotes. + "," raise ","quoted_characters keys join ","quoted_characters keys ","quoted_characters keys include? ","character to_sym ","k to_s ","v include? "," translate each "," translate ","character to_s downcase! ","character to_s "," sample to_s ","character nil? ","quoted_characters key? ","Faker Movies StarWars  quote ","quoted_k to_s s keys join ","quoted_ sample to_s s keys join "," translate  keys join ","quoted_k to_s s keys ","quoted_ sample to_s s keys "," translate  keys ","quoted_k to_s s keys include? ","quoted_ sample to_s s keys include? "," translate  keys include? ","k to_s  to_sym "," sample to_s  to_sym ","k to_s  to_s downcase! "," sample to_s  to_s downcase! ","k to_s  to_s "," sample to_s  to_s ","k to_s  nil? "," sample to_s  nil? ","quoted_k to_s s key? ","quoted_ sample to_s s key? "," translate  key? "]}," Faker StarWars planet":{"type":"method","name":"planet","children":[],"call":[" planets sample "," planets "," sample ","Faker Movies StarWars  planet "]}," Faker StarWars droid":{"type":"method","name":"droid","children":[],"call":[" droids sample "," droids "," sample ","Faker Movies StarWars  droid "]}," Faker StarWars character":{"type":"method","name":"character","children":[],"call":[" planets sample "," planets "," characters sample "," characters "," sample ","Faker Movies StarWars  character "]}," Faker Date between_except":{"type":"method","name":"between_except","children":[],"call":[" between ","date == ","date to_date ","date != "," loop "," get_date_object "," raise ","to == ","from == ","keywords << ","legacy_excepted != "," warn_for_deprecated_arguments ","legacy_to != ","legacy_from != "," warn_with_uplevel "," between  == "," between  to_ between  "," between  != "," get_ between _object ","legacy_ get_date_object  != "]}," Faker Color color_name":{"type":"method","name":"color_name","children":[],"call":[" fetch "]}," Faker Cat registry":{"type":"method","name":"registry","children":[],"call":[" fetch ","Faker Creature Cat  registry "]}," Faker Cat breed":{"type":"method","name":"breed","children":[],"call":[" fetch ","Faker Creature Cat  breed "]}," Faker Cat name":{"type":"method","name":"name","children":[],"call":[" fetch ","Faker Creature Cat  name "]}," Faker Boolean boolean":{"type":"method","name":"boolean","children":[],"call":[" rand < "," rand ","keywords << ","legacy_true_ratio != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Beer blg":{"type":"method","name":"blg","children":[],"call":[" rand round to_s + "," rand round to_s "," rand round "," rand "]}," Faker Beer alcohol":{"type":"method","name":"alcohol","children":[],"call":[" rand round to_s + "," rand round to_s "," rand round "," rand "]}," Faker Beer ibu":{"type":"method","name":"ibu","children":[],"call":[" rand to_s + "," rand to_s "," rand "]}," Faker Beer malts":{"type":"method","name":"malts","children":[],"call":[" fetch "]}," Faker Beer yeast":{"type":"method","name":"yeast","children":[],"call":[" fetch "]}," Faker Beer hop":{"type":"method","name":"hop","children":[],"call":[" fetch "]}," Faker Beer style":{"type":"method","name":"style","children":[],"call":[" fetch "]}," Faker Beer name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Base fetch_all":{"type":"method","name":"fetch_all","children":[],"call":[" regexify ","fetched match ","fetched respond_to? ! ","fetched respond_to? ","fetched last ","fetched size <= ","fetched size "," translate ","fetched last  match "," translate  match ","fetched last  respond_to? ! "," translate  respond_to? ! ","fetched last  respond_to? "," translate  respond_to? ","fetched last  last "," translate  last ","fetched last  size <= "," translate  size <= ","fetched last  size "," translate  size "]}," Faker Yoda quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Quote  yoda "]}," Faker Vehicle vin_checksum":{"type":"method","name":"vin_checksum","children":[],"call":["@vin_map [] ","vehicle_identification_number each_with_index map inject % ","vehicle_identification_number each_with_index map inject ","vehicle_identification_number each_with_index map "," method ","vehicle_identification_number each_with_index ","VIN_MAP  [] "]}," Faker Vehicle calculate_vin_weight":{"type":"method","name":"calculate_vin_weight","children":[],"call":["(send\n  (send\n    (ivar :@vin_chars) :index\n    (lvar :character)) :%\n  (int 10)) * ","@vin_map index ","@vin_weights [] ","@vin_chars index % ","@vin_chars index ","(send\n  (send\n    (const nil :VIN_CHARS) :index\n    (lvar :character)) :%\n  (int 10)) * ","VIN_MAP  index ","VIN_WEIGHTS  [] ","VIN_CHARS  index % ","VIN_CHARS  index "]}," Faker Vehicle manufacture":{"type":"method","name":"manufacture","children":[],"call":[" fetch_all sample [] "," fetch_all sample "," fetch_all "," fetch_all sample first "," sample first "," sample "," fetch "]}," Faker Vehicle vin":{"type":"method","name":"vin","children":[],"call":["vehicle_identification_number join upcase ","vehicle_identification_number join ","vehicle_identification_number []= "," vin_checksum "," fetch ","manufacture [] [] ","manufacture [] ","(irange\n  (int 12)\n  (int 14)) to_a each_with_index ","(irange\n  (int 12)\n  (int 14)) to_a ","manufacture [] nil? ","manufacture [] split concat ","c sample ","Array  new ","manufacture [] split ","n == ","@vin_chars split reject ","@vin_chars split "," fetch_all sample "," fetch_all ","wmi_ext [] ","wmi_ext nil? ","wmi split concat ","wmi split ","VIN_CHARS  split reject ","VIN_CHARS  split "," sample "," regexify ","checksum == ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :front))\n        (str \"A\")\n        (begin\n          (lvar :back))) :chars) :each_with_index) :map) inject % ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :front))\n        (str \"A\")\n        (begin\n          (lvar :back))) :chars) :each_with_index) :map) inject ","value * ","VIN_WEIGHT  [] ","VIN_TRANSLITERATION  [] ","char to_sym ","char to_i ","char =~ ","(begin\n  (lvar :front)) chars each_with_index map ","(begin\n  (lvar :front)) chars each_with_index ","(begin\n  (lvar :front)) chars ","(send\n  (send\n    (int 8) :times) :map) join ","VIN_KEYSPACE  sample ","Faker Config  random ","8 times map ","8 times ","g int ","g letter ","VIN_KEYSPACE  - ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :wmi))\n        (begin\n          (lvar :vds))\n        (str \"0\")\n        (begin\n          (lvar :model_year))\n        (begin\n          (lvar :plant_code))\n        (begin\n          (lvar :vis))) :chars) :each_with_index) :map) inject % ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :wmi))\n        (begin\n          (lvar :vds))\n        (str \"0\")\n        (begin\n          (lvar :model_year))\n        (begin\n          (lvar :plant_code))\n        (begin\n          (lvar :vis))) :chars) :each_with_index) :map) inject ","(begin\n  (lvar :wmi)) chars each_with_index map ","(begin\n  (lvar :wmi)) chars each_with_index ","(begin\n  (lvar :wmi)) chars ","g computed "," generate ","manufacture [] split concat  join upcase ","wmi split concat  join upcase ","manufacture [] split concat  join ","wmi split concat  join ","manufacture [] split concat  []= ","wmi split concat  []= "," vin_(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :front))\n        (str \"A\")\n        (begin\n          (lvar :back))) :chars) :each_with_index) :map) inject %  "," vin_(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :wmi))\n        (begin\n          (lvar :vds))\n        (str \"0\")\n        (begin\n          (lvar :model_year))\n        (begin\n          (lvar :plant_code))\n        (begin\n          (lvar :vis))) :chars) :each_with_index) :map) inject %  "," fetch_all sample  [] [] "," fetch_all sample  [] "," fetch_all sample  [] nil? "," fetch_all sample  [] split concat "," fetch_all sample  [] split ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :front))\n        (str \"A\")\n        (begin\n          (lvar :back))) :chars) :each_with_index) :map) inject %  == ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :wmi))\n        (begin\n          (lvar :vds))\n        (str \"0\")\n        (begin\n          (lvar :model_year))\n        (begin\n          (lvar :plant_code))\n        (begin\n          (lvar :vis))) :chars) :each_with_index) :map) inject %  == ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :front))\n        (str \"A\")\n        (begin\n          (lvar :(send\n  (send\n    (int 8) :times) :map) join ))) :chars) :each_with_index) :map) inject % ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :(send\n  (send\n    (int 8) :times) :map) join ))\n        (str \"A\")\n        (begin\n          (lvar :back))) :chars) :each_with_index) :map) inject % ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :front))\n        (str \"A\")\n        (begin\n          (lvar :(send\n  (send\n    (int 8) :times) :map) join ))) :chars) :each_with_index) :map) inject ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :(send\n  (send\n    (int 8) :times) :map) join ))\n        (str \"A\")\n        (begin\n          (lvar :back))) :chars) :each_with_index) :map) inject ","(begin\n  (lvar :(send\n  (send\n    (int 8) :times) :map) join )) chars each_with_index map ","(begin\n  (lvar :(send\n  (send\n    (int 8) :times) :map) join )) chars each_with_index ","(begin\n  (lvar :(send\n  (send\n    (int 8) :times) :map) join )) chars "]}," Faker Time date_with_random_time":{"type":"method","name":"date_with_random_time","children":[],"call":[" Time  local "," seconds "," minutes "," hours ","date day ","date month ","date year "]}," Faker Space distance_measurement":{"type":"method","name":"distance_measurement","children":[],"call":[" rand to_s + + "," fetch "," rand to_s + "," rand to_s "," rand "]}," Faker Space company":{"type":"method","name":"company","children":[],"call":[" fetch "]}," Faker Space nasa_space_craft":{"type":"method","name":"nasa_space_craft","children":[],"call":[" fetch "]}," Faker Space agency_abv":{"type":"method","name":"agency_abv","children":[],"call":[" fetch "]}," Faker Space agency":{"type":"method","name":"agency","children":[],"call":[" fetch "]}," Faker Space star":{"type":"method","name":"star","children":[],"call":[" fetch "]}," Faker Space constellation":{"type":"method","name":"constellation","children":[],"call":[" fetch "]}," Faker Space star_cluster":{"type":"method","name":"star_cluster","children":[],"call":[" fetch "]}," Faker Space nebula":{"type":"method","name":"nebula","children":[],"call":[" fetch "]}," Faker Space galaxy":{"type":"method","name":"galaxy","children":[],"call":[" fetch "]}," Faker Space moon":{"type":"method","name":"moon","children":[],"call":[" fetch "]}," Faker Space planet":{"type":"method","name":"planet","children":[],"call":[" fetch "]}," Faker Name job_titles":{"type":"method","name":"job_titles","children":[],"call":[" fetch_all "]}," Faker Name name_with_middle":{"type":"method","name":"name_with_middle","children":[],"call":[" parse "]}," Faker Music key_variants":{"type":"method","name":"key_variants","children":[],"call":[]}," Faker Music keys":{"type":"method","name":"keys","children":[],"call":[]}," Faker Music instrument":{"type":"method","name":"instrument","children":[],"call":[" fetch "]}," Faker Music key":{"type":"method","name":"key","children":[],"call":[" keys sample + "," key_variants sample "," key_variants "," keys sample "," keys "," sample + "," sample "]}," Faker Lorem questions":{"type":"method","name":"questions","children":[],"call":["questions << "," question ","1 upto "," resolve "," tap ","1 upto collect ","keywords << ","legacy_supplemental != ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Lorem question":{"type":"method","name":"question","children":[],"call":[" words join capitalize + "," words join capitalize "," words join "," words ","word_count + "," rand to_i "," rand ","random_words_to_add to_i "," locale_question_mark ","keywords << ","legacy_random_words_to_add != ","legacy_supplemental != ","legacy_word_count != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Internet private_net_checker":{"type":"method","name":"private_net_checker","children":[],"call":["net =~ "," private_nets_regex any? "," private_nets_regex "," lambda "]}," Faker Internet private_nets_regex":{"type":"method","name":"private_nets_regex","children":[],"call":[]}," Faker Internet private_ip_v4_address":{"type":"method","name":"private_ip_v4_address","children":[],"call":[" ip_v4_address ","is_private [] ! ","is_private [] "," private_net_checker "," private_net_checker [] ! "," private_net_checker [] "," loop ","(send\n  (send nil :sample\n    (const nil :PRIVATE_IPV4_ADDRESS_RANGES)) :map) join "," rand "," sample map "," sample "," ip_v4_ ip_v4_address ess "," private_net_checker  [] ! "," private_net_checker  [] "]}," Faker File file_name":{"type":"method","name":"file_name","children":[],"call":["(lvar :dir) join + ","(lvar :dir) join "," extension ","Faker Lorem  word downcase ","Faker Lorem  word ","Faker Internet  slug "," dir ","keywords << ","legacy_directory_separator != ","legacy_ext != ","legacy_name != ","legacy_dir != "," warn_for_deprecated_arguments "," warn_with_uplevel ","(lvar :Faker Internet  slug ) join + ","(lvar :Faker Internet  slug ) join ","  extension ension "," Faker Internet  slug  ","legacy_Faker Internet  slug ectory_separator != ","legacy_ extension  != ","legacy_Faker Lorem  word downcase  != ","legacy_Faker Internet  slug  != "]}," Faker File mime_type":{"type":"method","name":"mime_type","children":[],"call":[" fetch "," sample "," translate values "," translate "]}," Faker File extension":{"type":"method","name":"extension","children":[],"call":[" fetch "]}," Faker Educator campus":{"type":"method","name":"campus","children":[],"call":[" fetch "," parse "]}," Faker Educator secondary_school":{"type":"method","name":"secondary_school","children":[],"call":[" fetch "," parse "]}," Faker Educator course":{"type":"method","name":"course","children":[],"call":[" fetch "]}," Faker Educator university":{"type":"method","name":"university","children":[],"call":[" fetch "," parse "]}," Faker Date customized_bound":{"type":"method","name":"customized_bound","children":[],"call":[" customized_bound ","bound - ","bound + ","(send\n  (lvar :bound) :%\n  (int 4)) != ","bound % "," customized_bound -  "," customized_bound +  ","bound -  - ","bound +  - ","bound -  + ","bound +  + ","(send\n  (lvar :bound - ) :%\n  (int 4)) != ","(send\n  (lvar :bound + ) :%\n  (int 4)) != ","bound -  % ","bound +  % "]}," Faker Date handled_leap_years":{"type":"method","name":"handled_leap_years","children":[],"call":[" customized_bound ","(send\n  (lvar :bottom_bound) :%\n  (int 4)) != ","bottom_bound % ","(send\n  (lvar :top_bound) :%\n  (int 4)) != ","top_bound % "]}," Faker Date prepare_bounds":{"type":"method","name":"prepare_bounds","children":[],"call":["t year - ","t year "]}," Faker Crypto sha256":{"type":"method","name":"sha256","children":[],"call":["Digest SHA256  hexdigest ","Lorem  characters ","OpenSSL Digest SHA256  hexdigest "]}," Faker Crypto sha1":{"type":"method","name":"sha1","children":[],"call":["Digest SHA1  hexdigest ","Lorem  characters ","OpenSSL Digest SHA1  hexdigest "]}," Faker Crypto md5":{"type":"method","name":"md5","children":[],"call":["Digest MD5  hexdigest ","Lorem  characters ","OpenSSL Digest MD5  hexdigest "]}," Faker Company abn_checksum":{"type":"method","name":"abn_checksum","children":[],"call":["weight * ","abn [] to_i ","abn [] ","abn_weights each_with_index "]}," Faker Company australian_business_number":{"type":"method","name":"australian_business_number","children":[],"call":["(send\n  (int 99) :-\n  (begin\n    (send\n      (send nil :abn_checksum\n        (lvar :abn)) :%\n      (int 89)))) to_s + ","(send\n  (int 99) :-\n  (begin\n    (send\n      (send nil :abn_checksum\n        (lvar :abn)) :%\n      (int 89)))) to_s ","99 - "," abn_checksum % "," abn_checksum ","00 + ","%09d % "," rand ","10 ** "," format ","(send\n  (int 99) :-\n  (begin\n    (send\n      (send nil :00 + _checksum\n        (lvar :00 + )) :%\n      (int 89)))) to_s + ","(send\n  (int 99) :-\n  (begin\n    (send\n      (send nil :00 + _checksum\n        (lvar :00 + )) :%\n      (int 89)))) to_s "," 00 + _checksum % "," 00 + _checksum "]}," Faker Code generate_imei":{"type":"method","name":"generate_imei","children":[],"call":["str join ","str []= ","(send\n  (int 10) :-\n  (begin\n    (send\n      (lvar :sum) :%\n      (int 10)))) % ","10 - ","sum % ","len - ","str [] ","t > ","str [] * ","(send\n  (lvar :pos) :+\n  (lvar :len_offset)) % != ","(send\n  (lvar :pos) :+\n  (lvar :len_offset)) % ","pos + ","(send\n  (lvar :len) :+\n  (int 1)) % ","len + "," rand ","pos < ","arr [] to_i ","arr [] ","RBI  sample ","Array  new ","(send\n  (lvar :position) :+\n  (lvar :len_offset)) % != ","(send\n  (lvar :position) :+\n  (lvar :len_offset)) % ","position + ","(irange\n  (int 0)\n  (begin\n    (send\n      (lvar :len) :-\n      (int 1)))) each "," sample ","(send\n  (lvar :position) :+\n  (lvar :len_offset)) odd? ","sstr [] * r join ","Array  new  join ","sstr [] * r []= ","Array  new  []= ","(send\n  (instr [] *  10) :-\n  (begin\n    (send\n      (lvar :sum) :%\n      (instr [] *  10)))) % ","sstr [] * r [] ","Array  new  [] ","str [] *  > ","sstr [] * r [] * ","Array  new  [] * ","(send\n  (lvar :pos) :+\n  (lvar :len_offsestr [] * )) % != ","(send\n  (lvar :pos) :+\n  (lvar :(send\n  (lvar :len) :+\n  (int 1)) % )) % != ","(send\n  (lvar :pos) :+\n  (lvar :len_offsestr [] * )) % ","(send\n  (lvar :pos) :+\n  (lvar :(send\n  (lvar :len) :+\n  (int 1)) % )) % ","(send\n  (lvar :len) :+\n  (instr [] *  1)) % ","arr [] str [] * o_i ","RBI  sample  [] to_i "," sample  [] to_i ","RBI  sample  [] "," sample  [] ","(send\n  (lvar :posistr [] * ion) :+\n  (lvar :len_offsestr [] * )) % != ","(send\n  (lvar :position) :+\n  (lvar :(send\n  (lvar :len) :+\n  (int 1)) % )) % != ","(send\n  (lvar :posistr [] * ion) :+\n  (lvar :len_offsestr [] * )) % ","(send\n  (lvar :position) :+\n  (lvar :(send\n  (lvar :len) :+\n  (int 1)) % )) % ","posistr [] * ion + ","(irange\n  (instr [] *  0)\n  (begin\n    (send\n      (lvar :len) :-\n      (instr [] *  1)))) each ","(send\n  (lvar :posistr [] * ion) :+\n  (lvar :len_offsestr [] * )) odd? ","(send\n  (lvar :position) :+\n  (lvar :(send\n  (lvar :len) :+\n  (int 1)) % )) odd? "]}," Faker Code asin":{"type":"method","name":"asin","children":[],"call":[" fetch "]}," Faker Code imei":{"type":"method","name":"imei","children":[],"call":[" generate_imei "]}," Faker ChuckNorris fact":{"type":"method","name":"fact","children":[],"call":[" fetch "]}," Faker ChuckNorris name":{"type":"method","name":"name","children":[],"call":[" parse "]}," Faker Pokemon location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker Games Pokemon  location "]}," Faker Pokemon name":{"type":"method","name":"name","children":[],"call":[" fetch ","Faker Games Pokemon  name "]}," Faker GameOfThrones city":{"type":"method","name":"city","children":[],"call":[" fetch ","Faker TvShows GameOfThrones  city "]}," Faker GameOfThrones house":{"type":"method","name":"house","children":[],"call":[" fetch ","Faker TvShows GameOfThrones  house "]}," Faker GameOfThrones character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows GameOfThrones  character "]}," Faker UniqueGenerator method_missing":{"type":"method","name":"method_missing","children":[],"call":[" raise ","@previous_results [] << ","@previous_results [] ","@previous_results [] include? ","@generator public_send ","@max_retries times "," class marked_unique add "," class marked_unique "," class "," previous_results [] << "," previous_results [] "," previous_results "," previous_results [] include? ","@previous_@generator public_send s [] << ","@previous_@generator public_send s [] ","@previous_@generator public_send s [] include? "," previous_@generator public_send s [] << "," previous_@generator public_send s [] "," previous_@generator public_send s "," previous_@generator public_send s [] include? "]}," Faker UniqueGenerator initialize":{"type":"method","name":"initialize","children":[],"call":["hash []= ","Set  new ","Hash  new "]}," Faker Base unique":{"type":"method","name":"unique","children":[],"call":["UniqueGenerator  new "]}," Faker TwinPeaks quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows TwinPeaks  quote "]}," Faker TwinPeaks location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker TvShows TwinPeaks  location "]}," Faker TwinPeaks character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows TwinPeaks  character "]}," Faker Time time_with_format":{"type":"method","name":"time_with_format","children":[],"call":["I18n  l ","DateTime  parse ","time to_s ","format nil? ","I18n  localize "]}," Faker StarWars wookie_words":{"type":"method","name":"wookie_words","children":[],"call":[]}," Faker StarWars wookie_sentence":{"type":"method","name":"wookie_sentence","children":[],"call":["sentence + ","(str \".\") sample ","  + "," wookie_words sample "," wookie_words "," rand times "," rand "," wookie_words sample capitalize "," sample "," sample capitalize "," wookie_words sample capitalize  + "," sample capitalize  + "]}," Faker Space meteorite":{"type":"method","name":"meteorite","children":[],"call":[" fetch "]}," Faker RockBand name":{"type":"method","name":"name","children":[],"call":[" fetch ","Faker Music RockBand  name "]}," Faker Number normal":{"type":"method","name":"normal","children":[],"call":["mean + ","scale * ","Math  cos ","standard_deviation * ","Math  sqrt ","-2 * ","Math  log ","1 - "," rand ","2 * * ","2 * ","keywords << ","legacy_standard_deviation != ","legacy_mean != "," warn_for_deprecated_arguments "," warn_with_uplevel ","standard_deviation *  * "]}," Faker Music chord_types":{"type":"method","name":"chord_types","children":[],"call":[]}," Faker Music key_types":{"type":"method","name":"key_types","children":[],"call":[]}," Faker Music chord":{"type":"method","name":"chord","children":[],"call":[" key + "," chord_types sample "," chord_types "," key "," sample "]}," Faker LoremPixel image":{"type":"method","name":"image","children":[],"call":["url_parts join ","(lvar :category) compact ","size split ","url_parts << "," raise ","category nil? ","number nil? ","text nil? ! ","text nil? ","(irange\n  (int 1)\n  (int 10)) include? ","number nil? ! ","SUPPORTED_CATEGORIES  join ","SUPPORTED_CATEGORIES  include? ","size match ","(irange\n  (int 1)\n  (int 10)) cover? ","size =~ ","keywords << ","legacy_secure != ","legacy_text != ","legacy_number != ","legacy_category != ","legacy_is_gray != ","legacy_size != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker LordOfTheRings location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker Movies LordOfTheRings  location "]}," Faker LordOfTheRings character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Movies LordOfTheRings  character "]}," Faker Job key_skill":{"type":"method","name":"key_skill","children":[],"call":[" fetch "]}," Faker Job field":{"type":"method","name":"field","children":[],"call":[" fetch "]}," Faker Job title":{"type":"method","name":"title","children":[],"call":[" parse "]}," Faker GameOfThrones dragon":{"type":"method","name":"dragon","children":[],"call":[" fetch ","Faker TvShows GameOfThrones  dragon "]}," Faker GameOfThrones quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows GameOfThrones  quote "]}," Faker Food measurement":{"type":"method","name":"measurement","children":[],"call":[" fetch + + "," fetch "," fetch + "]}," Faker Food spice":{"type":"method","name":"spice","children":[],"call":[" fetch "]}," Faker Food ingredient":{"type":"method","name":"ingredient","children":[],"call":[" fetch "]}," Faker Fillmurray image":{"type":"method","name":"image","children":[],"call":["grayscale == "," raise ","(true) include? ","height match ","width match ","height to_s match ","height to_s ","width to_s match ","width to_s ","height to_s =~ ","width to_s =~ ","keywords << ","legacy_height != ","legacy_width != ","legacy_grayscale != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Esport game":{"type":"method","name":"game","children":[],"call":[" fetch "]}," Faker Esport event":{"type":"method","name":"event","children":[],"call":[" fetch "]}," Faker Esport league":{"type":"method","name":"league","children":[],"call":[" fetch "]}," Faker Esport team":{"type":"method","name":"team","children":[],"call":[" fetch "]}," Faker Esport player":{"type":"method","name":"player","children":[],"call":[" fetch "]}," Faker Commerce promotion_code":{"type":"method","name":"promotion_code","children":[],"call":["(send nil :fetch\n  (str \"commerce.promotion_code.adjective\")) join ","Faker Number  number "," fetch ","keywords << ","legacy_digits != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Bank iban_details":{"type":"method","name":"iban_details","children":[],"call":[" fetch_all "]}," Faker Bank iban":{"type":"method","name":"iban","children":[],"call":["bcc + + ","bcc + ","(send\n  (send\n    (send\n      (send\n        (lvar :details) :[]\n        (str \"iban_digits\")) :to_i) :times) :map) join "," rand ","details [] to_i times map ","details [] to_i times ","details [] to_i ","details [] ","(send\n  (begin\n    (erange\n      (int 0)\n      (send\n        (send\n          (lvar :details) :[]\n          (str \"iban_letter_code\")) :to_i))) :map) join ","(send\n  (int 65) :+\n  (send nil :rand\n    (int 26))) chr ","65 + ","(erange\n  (int 0)\n  (send\n    (send\n      (lvar :details) :[]\n      (str \"iban_letter_code\")) :to_i)) map ","details [] + ","(send\n  (send\n    (int 2) :times) :map) join ","2 times map ","2 times ","country [] == ","bank_country_code upcase ","country [] "," iban_details find "," iban_details "," raise ","(send\n  (lvar :country_code) :upcase) join "," iban_range ","Array  new ","country_code upcase ","country_code upcase + + ","country_code upcase + "," iban_checksum ","Base  regexify "," fetch ","country_code downcase ","keywords << ","legacy_country_code != "," warn_for_deprecated_arguments "," iban_country_code "," warn_with_uplevel ","details [] +  + + ","details [] +  + ","(send\n  (send\n    (send\n      (send\n        (lvar :details) :[]\n        (str \"(send\n  (send\n    (send\n      (send\n        (lvar :details) :[]\n        (str \"iban_digits\")) :to_i) :times) :map) join an_digits\")) :to_i) :times) :map) join ","(send\n  (begin\n    (erange\n      (int 0)\n      (send\n        (send\n          (lvar :details) :[]\n          (str \"(send\n  (send\n    (send\n      (send\n        (lvar :details) :[]\n        (str \"iban_digits\")) :to_i) :times) :map) join an_letter_code\")) :to_i))) :map) join ","(erange\n  (int 0)\n  (send\n    (send\n      (lvar :details) :[]\n      (str \"(send\n  (send\n    (send\n      (send\n        (lvar :details) :[]\n        (str \"iban_digits\")) :to_i) :times) :map) join an_letter_code\")) :to_i)) map "," (send\n  (send\n    (send\n      (send\n        (lvar :details) :[]\n        (str \"iban_digits\")) :to_i) :times) :map) join an_details find "," (send\n  (send\n    (send\n      (send\n        (lvar :details) :[]\n        (str \"iban_digits\")) :to_i) :times) :map) join an_details "," (send\n  (send\n    (send\n      (send\n        (lvar :details) :[]\n        (str \"iban_digits\")) :to_i) :times) :map) join an_range "," (send\n  (send\n    (send\n      (send\n        (lvar :details) :[]\n        (str \"iban_digits\")) :to_i) :times) :map) join an_checksum "," (send\n  (send\n    (send\n      (send\n        (lvar :details) :[]\n        (str \"iban_digits\")) :to_i) :times) :map) join an_country_code "]}," Faker Bank swift_bic":{"type":"method","name":"swift_bic","children":[],"call":[" fetch "]}," Faker Bank name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Artist name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Ancient hero":{"type":"method","name":"hero","children":[],"call":[" fetch "]}," Faker Ancient titan":{"type":"method","name":"titan","children":[],"call":[" fetch "]}," Faker Ancient primordial":{"type":"method","name":"primordial","children":[],"call":[" fetch "]}," Faker Ancient god":{"type":"method","name":"god","children":[],"call":[" fetch "]}," Faker Address full_address":{"type":"method","name":"full_address","children":[],"call":[" parse "]}," Faker Internet reserved_net_checker":{"type":"method","name":"reserved_net_checker","children":[],"call":["net =~ ","(send\n  (send nil :private_nets_regex) :+\n  (send nil :reserved_nets_regex)) any? "," private_nets_regex + "," reserved_nets_regex "," private_nets_regex "," lambda "]}," Faker Internet reserved_nets_regex":{"type":"method","name":"reserved_nets_regex","children":[],"call":[]}," Faker UniqueGenerator clear":{"type":"method","name":"clear","children":[],"call":["@previous_results clear "," previous_results clear "," previous_results "]}," Faker Zelda character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Games Zelda  character "]}," Faker Zelda game":{"type":"method","name":"game","children":[],"call":[" fetch ","Faker Games Zelda  game "]}," Faker Twitter utc_offset":{"type":"method","name":"utc_offset","children":[],"call":["Faker Number  between "]}," Faker Twitter created_at":{"type":"method","name":"created_at","children":[],"call":["Faker Date  between strftime ","Faker Date  between "," Date  today "]}," Faker Twitter id":{"type":"method","name":"id","children":[],"call":["Faker Number  between "]}," Faker Twitter status":{"type":"method","name":"status","children":[],"call":["status []= ","Faker Twitter  user ","Faker Address  country_code ","Faker Boolean  boolean ","Faker Number  between ","Faker Company  name ","Faker Internet  url ","Faker Lorem  sentence ","status_id to_s "," created_at "," id ","status [] [] first [] ","status [] [] first ","status [] [] ","status [] "," status_entities ","keywords << ","legacy_include_photo != ","legacy_include_user != "," warn_for_deprecated_arguments "," warn_with_uplevel "," id  to_s "]}," Faker Twitter user":{"type":"method","name":"user","children":[],"call":["user []= ","Faker Twitter  status ","Faker Boolean  boolean ","Faker Color  hex_color ","Faker LoremPixel  image ","profile_image_url sub ","background_image_url sub ","Faker Address  country_code ","Faker Number  between ","Faker Address  time_zone "," utc_offset "," created_at ","Faker Internet  url ","Faker Lorem  sentence ","Faker Address  state_abbr ","Faker Address  city ","Faker Internet  user_name ","Faker Name  name ","user_id to_s ","Faker Avatar  image "," id ","Faker Internet  safe_email "," screen_name "," user_entities ","keywords << ","legacy_include_email != ","legacy_include_status != "," warn_for_deprecated_arguments "," warn_with_uplevel ","Faker LoremFlickr  image ","Faker Internet  email ","Faker Avatar  image  sub ","Faker LoremPixel  image  sub ","Faker LoremFlickr  image  sub "," id  to_s "]}," Faker Omniauth random_boolean":{"type":"method","name":"random_boolean","children":[],"call":["(true) shuffle pop ","(true) shuffle "," shuffle pop "," shuffle "]}," Faker Omniauth random_number_from_range":{"type":"method","name":"random_number_from_range","children":[],"call":["range to_a shuffle pop ","range to_a shuffle ","range to_a "," shuffle pop "," shuffle "]}," Faker Omniauth city_state":{"type":"method","name":"city_state","children":[],"call":["Address  state ","Address  city "]}," Faker Omniauth image":{"type":"method","name":"image","children":[],"call":["Placeholdit  image "]}," Faker Omniauth created_at":{"type":"method","name":"created_at","children":[],"call":["Date  backward strftime "," time_now [] join "," time_now [] "," time_now ","Date  backward "]}," Faker Omniauth updated_time":{"type":"method","name":"updated_time","children":[],"call":[" time_now [] join "," time_now [] "," time_now ","Date  backward to_s ","Date  backward "]}," Faker Omniauth time_now":{"type":"method","name":"time_now","children":[],"call":["Object Time  now to_s split ","Object Time  now to_s ","Object Time  now "]}," Faker Omniauth timezone":{"type":"method","name":"timezone","children":[],"call":["(irange\n  (int -12)\n  (int 12)) to_a shuffle pop ","(irange\n  (int -12)\n  (int 12)) to_a shuffle ","(irange\n  (int -12)\n  (int 12)) to_a "," shuffle pop "," shuffle "]}," Faker Omniauth gender":{"type":"method","name":"gender","children":[],"call":["(str \"male\") shuffle pop ","(str \"male\") shuffle "," shuffle pop "," shuffle "]}," Faker Omniauth one_hour_from_now":{"type":"method","name":"one_hour_from_now","children":[],"call":["Object Time  now + ","60 * ","Object Time  now "]}," Faker Omniauth linkedin":{"type":"method","name":"linkedin","children":[],"call":[" image "," city_state split first "," city_state split "," city_state ","Address  country_code downcase ","Address  country_code ","auth last_name ","auth first_name "," one_hour_from_now to_i "," one_hour_from_now ","PhoneNumber  phone_number ","auth name ","Commerce  department ","Crypto  md5 ","Lorem  sentence ","auth last_name downcase ","auth first_name downcase ","Omniauth  new ","Number  number ","Time  forward to_i ","Time  forward ","auth email ","keywords << ","legacy_uid != ","legacy_email != ","legacy_name != "," warn_for_deprecated_arguments "," warn_with_uplevel ","auth auth last_name downcase  ","Omniauth  new  last_name ","auth auth first_name downcase  ","Omniauth  new  first_name ","Omniauth  new  name ","auth auth last_name downcase  downcase ","Omniauth  new  last_name downcase ","auth auth first_name downcase  downcase ","Omniauth  new  first_name downcase ","OmniOmniauth  new   new ","Omniauth  new  email ","legacy_Number  number  != "]}," Faker Omniauth twitter":{"type":"method","name":"twitter","children":[],"call":[" random_boolean ","Color  hex_color "," image "," created_at "," random_number_from_range "," timezone ","Address  city ","auth name ","Crypto  md5 ","auth name downcase gsub ","auth name downcase ","Lorem  sentence "," city_state ","Omniauth  new ","Number  number ","Time  backward strftime ","Time  backward ","auth name downcase delete ","keywords << ","legacy_uid != ","legacy_nickname != ","legacy_name != "," warn_for_deprecated_arguments "," warn_with_uplevel ","Omniauth  new  name ","Omniauth  new  name downcase gsub ","Omniauth  new  name downcase ","OmniOmniauth  new   new ","Omniauth  new  name downcase delete ","legacy_Number  number  != "]}," Faker Omniauth facebook":{"type":"method","name":"facebook","children":[],"call":[" updated_time "," random_boolean "," timezone "," gender "," city_state ","Number  number ","auth last_name ","auth first_name ","auth name "," one_hour_from_now to_i "," one_hour_from_now ","Crypto  md5 "," image ","auth last_name downcase ","auth first_name downcase ","auth first_name downcase [] ","Omniauth  new ","Time  backward iso8601 ","Time  backward ","Time  forward to_i ","Time  forward ","auth email ","Number  number to_s ","keywords << ","legacy_uid != ","legacy_username != ","legacy_email != ","legacy_name != "," warn_for_deprecated_arguments "," warn_with_uplevel ","Omniauth  new  last_name ","Omniauth  new  first_name ","Omniauth  new  name ","Omniauth  new  last_name downcase ","Omniauth  new  first_name downcase ","Omniauth  new  first_name downcase [] ","OmniOmniauth  new   new ","Omniauth  new  email ","legacy_Number  number  != "]}," Faker Omniauth google":{"type":"method","name":"google","children":[],"call":[" one_hour_from_now to_i to_s "," one_hour_from_now to_i "," one_hour_from_now ","Number  number ","Number  number to_s ","Crypto  md5 ","Company  name downcase ","Company  name ","Date  backward strftime ","Date  backward ","(str \"male\") shuffle pop ","(str \"male\") shuffle "," image ","auth last_name ","auth first_name ","auth name "," random_boolean ","auth first_name downcase ","Omniauth  new ","Time  forward to_i to_s ","Time  forward to_i ","Time  forward "," gender ","auth email "," random_boolean to_s ","keywords << ","legacy_uid != ","legacy_email != ","legacy_name != "," warn_for_deprecated_arguments "," warn_with_uplevel ","Omniauth  new  last_name ","Omniauth  new  first_name ","Omniauth  new  name ","Omniauth  new  first_name downcase ","OmniOmniauth  new   new ","Omniauth  new  email ","legacy_Number  number  != "]}," Faker Omniauth initialize":{"type":"method","name":"initialize","children":[],"call":[" name split last "," name split "," name "," name split first ","Name  last_name ","Name  first_name ","Internet  safe_email ","Internet  email "]}," Faker HarryPotter book":{"type":"method","name":"book","children":[],"call":[" fetch ","Faker Movies HarryPotter  book "]}," Faker HarryPotter quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Movies HarryPotter  quote "]}," Faker HarryPotter location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker Movies HarryPotter  location "]}," Faker HarryPotter character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Movies HarryPotter  character "]}," Faker Friends quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows Friends  quote "]}," Faker Friends location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker TvShows Friends  location "]}," Faker Friends character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows Friends  character "]}," Faker Demographic height":{"type":"method","name":"height","children":[],"call":[" rand_in_range round to_s "," rand_in_range round "," rand_in_range ","inches % ","inches / ","keywords << ","legacy_unit != "," warn_for_deprecated_arguments "," warn_with_uplevel "," rand_in_range  % "," rand_in_range  / "]}," Faker Demographic sex":{"type":"method","name":"sex","children":[],"call":[" fetch "]}," Faker Demographic marital_status":{"type":"method","name":"marital_status","children":[],"call":[" fetch "]}," Faker Demographic demonym":{"type":"method","name":"demonym","children":[],"call":[" fetch "]}," Faker Demographic educational_attainment":{"type":"method","name":"educational_attainment","children":[],"call":[" fetch "]}," Faker Demographic race":{"type":"method","name":"race","children":[],"call":[" fetch "]}," Faker Base rand":{"type":"method","name":"rand","children":[],"call":["Faker Config  random rand ","Faker Config  random ","max to_i > ","max to_i ","max is_a? ","max nil? ","max to_i positive? "]}," Faker Base shuffle":{"type":"method","name":"shuffle","children":[],"call":["list shuffle ","Faker Config  random "]}," Faker Base sample":{"type":"method","name":"sample","children":[],"call":["list sample ","Faker Config  random ","list respond_to? "]}," Faker Config random":{"type":"method","name":"random","children":[],"call":["Random  new ","Thread  current [] ","Thread  current "]}," Faker Zelda location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker Games Zelda  location "]}," Faker Twitter photo_entity":{"type":"method","name":"photo_entity","children":[],"call":["Faker Internet  url ","media_url sub ","media_id to_s "," id ","Faker LoremPixel  image ","Faker LoremFlickr  image ","Faker LoremPixel  image  sub ","Faker LoremFlickr  image  sub "," id  to_s "]}," Faker Twitter status_entities":{"type":"method","name":"status_entities","children":[],"call":["entities []= "," photo_entity ","keywords << ","legacy_include_photo != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Twitter user_entities":{"type":"method","name":"user_entities","children":[],"call":[]}," Faker Twitter screen_name":{"type":"method","name":"screen_name","children":[],"call":["Faker Internet  user_name [] ","Faker Internet  user_name ","Faker Internet  username [] ","Faker Internet  username "]}," Faker StarTrek villain":{"type":"method","name":"villain","children":[],"call":[" fetch ","Faker TvShows StarTrek  villain "]}," Faker StarTrek specie":{"type":"method","name":"specie","children":[],"call":[" fetch ","Faker TvShows StarTrek  specie "]}," Faker StarTrek location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker TvShows StarTrek  location "]}," Faker StarTrek character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows StarTrek  character "]}," Faker Simpsons quote":{"type":"method","name":"quote","children":[],"call":["Faker TvShows Simpsons  quote "]}," Faker Simpsons location":{"type":"method","name":"location","children":[],"call":["Faker TvShows Simpsons  location "]}," Faker Simpsons character":{"type":"method","name":"character","children":[],"call":["Faker TvShows Simpsons  character "]}," Faker RuPaul quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows RuPaul  quote "]}," Faker Robin quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Quote  robin "]}," Faker RickAndMorty quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows RickAndMorty  quote "]}," Faker RickAndMorty location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker TvShows RickAndMorty  location "]}," Faker RickAndMorty character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows RickAndMorty  character "]}," Faker Pokemon move":{"type":"method","name":"move","children":[],"call":[" fetch ","Faker Games Pokemon  move "]}," Faker Overwatch quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Games Overwatch  quote "]}," Faker Overwatch location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker Games Overwatch  location "]}," Faker Overwatch hero":{"type":"method","name":"hero","children":[],"call":[" fetch ","Faker Games Overwatch  hero "]}," Faker Omniauth github":{"type":"method","name":"github","children":[],"call":["Time  backward iso8601 ","Time  backward "," random_number_from_range "," city_state ","auth name "," random_boolean "," image ","Crypto  md5 ","auth last_name downcase ","auth last_name ","auth first_name downcase ","auth first_name ","Omniauth  new ","Number  number ","auth email ","auth name downcase tr ","auth name downcase ","keywords << ","legacy_uid != ","legacy_email != ","legacy_name != "," warn_for_deprecated_arguments "," warn_with_uplevel ","Omniauth  new  name ","auth auth last_name downcase  downcase ","Omniauth  new  last_name downcase ","auth auth last_name downcase  ","Omniauth  new  last_name ","auth auth first_name downcase  downcase ","Omniauth  new  first_name downcase ","auth auth first_name downcase  ","Omniauth  new  first_name ","OmniOmniauth  new   new ","Omniauth  new  email ","Omniauth  new  name downcase tr ","Omniauth  new  name downcase ","legacy_Number  number  != "]}," Faker Matz quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Quote  matz "]}," Faker Markdown available_methods":{"type":"method","name":"available_methods","children":[],"call":["Markdown  public_methods - ","Base  methods ","Markdown  public_methods ","(send\n  (send\n    (const nil :Markdown) :public_methods\n    (false)) :-\n  (send\n    (const nil :Base) :methods)) sort "]}," Faker Markdown random":{"type":"method","name":"random","children":[],"call":[" send "," available_methods [] "," rand "," available_methods length - "," available_methods length "," available_methods ","method_list [] ","method_list length - ","method_list length ","meth == ","ex to_sym ","method_list delete_if ","Faker Config  random rand ","Faker Config  random "," available_methods  [] "," available_methods  length - "," available_methods  length "," available_methods  delete_if "]}," Faker Markdown table":{"type":"method","name":"table","children":[],"call":["table join ","table << ","Lorem  word ","3 times ","table insert "]}," Faker Markdown block_code":{"type":"method","name":"block_code","children":[],"call":["Lorem  sentence "]}," Faker Markdown inline_code":{"type":"method","name":"inline_code","children":[],"call":["Faker Lorem  sentence "]}," Faker Markdown unordered_list":{"type":"method","name":"unordered_list","children":[],"call":["result join ","result << ","Faker Lorem  sentence ","number times "," rand "," rand  times "]}," Faker Markdown ordered_list":{"type":"method","name":"ordered_list","children":[],"call":["result join ","result << ","Faker Lorem  sentence ","i to_s ","number times "," rand "," rand  times "]}," Faker Markdown emphasis":{"type":"method","name":"emphasis","children":[],"call":["words join ","words []= ","words [] "," fetch "," rand ","words length - ","words length ","paragraph split ","Faker Lorem  paragraph ","paragraph split  join ","paragraph split  []= ","paragraph split  [] ","paragraph split  length - ","paragraph split  length ","Faker Lorem  paragraph  split ","Faker Lorem  Faker Lorem  paragraph  "]}," Faker Markdown headers":{"type":"method","name":"headers","children":[],"call":["Lorem  word capitalize ","Lorem  word "," fetch "]}," Faker Lovecraft resolve":{"type":"method","name":"resolve","children":[],"call":[" rand "," sample "]}," Faker Lovecraft paragraphs":{"type":"method","name":"paragraphs","children":[],"call":["paragraphs << "," paragraph ","1 upto "," resolve "," tap ","Faker Books Lovecraft  paragraphs "]}," Faker Lovecraft paragraph":{"type":"method","name":"paragraph","children":[],"call":[" sentences join "," sentences "," resolve + "," rand to_i "," rand ","random_sentences_to_add to_i "," resolve ","Faker Books Lovecraft  paragraph "]}," Faker Lovecraft sentences":{"type":"method","name":"sentences","children":[],"call":["sentences << "," sentence ","1 upto "," resolve "," tap ","Faker Books Lovecraft  sentences "]}," Faker Lovecraft words":{"type":"method","name":"words","children":[],"call":["words []= "," word ","w match ","words each_with_index "," shuffle [] "," shuffle ","word_list * ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar :word_list) :length)) + ","resolved_num / ","word_list length "," translate "," resolve ","w =~ ","Faker Books Lovecraft  words "," shuffle []  []= "," shuffle []  each_with_index ","word_list *  * "," translate  * ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar :word_list * ) :length)) + ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar : translate ) :length)) + ","(send\n  (lvar : resolve ) :/\n  (send\n    (lvar :word_list) :length)) + "," resolve  / ","word_list *  length "," translate  length ","Faker Books Lovecraft   shuffle []  "]}," Faker Lovecraft word":{"type":"method","name":"word","children":[],"call":[" word ","random_word match "," sample "," translate ","random_word =~ ","Faker Books Lovecraft  word "," sample  match "," sample  =~ "]}," Faker Lovecraft sentence":{"type":"method","name":"sentence","children":[],"call":[" words join capitalize + "," words join capitalize "," words join "," words ","word_count + "," rand to_i "," rand ","random_words_to_add to_i ","Faker Books Lovecraft  sentence "]}," Faker Lovecraft tome":{"type":"method","name":"tome","children":[],"call":[" fetch ","Faker Books Lovecraft  tome "]}," Faker Lovecraft deity":{"type":"method","name":"deity","children":[],"call":[" fetch ","Faker Books Lovecraft  deity "]}," Faker Lovecraft fhtagn":{"type":"method","name":"fhtagn","children":[],"call":["(send\n  (send\n    (lvar :number_of) :times) :collect) join "," fetch ","number_of times collect ","number_of times ","(send\n  (const nil :Array) :new\n  (lvar :number_of)) join ","Array  new ","Faker Books Lovecraft  fhtagn "]}," Faker Lovecraft location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker Books Lovecraft  location "]}," Faker LeagueOfLegends rank":{"type":"method","name":"rank","children":[],"call":[" fetch ","Faker Games LeagueOfLegends  rank "]}," Faker LeagueOfLegends masteries":{"type":"method","name":"masteries","children":[],"call":[" fetch ","Faker Games LeagueOfLegends  masteries "]}," Faker LeagueOfLegends summoner_spell":{"type":"method","name":"summoner_spell","children":[],"call":[" fetch ","Faker Games LeagueOfLegends  summoner_spell "]}," Faker LeagueOfLegends quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Games LeagueOfLegends  quote "]}," Faker LeagueOfLegends location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker Games LeagueOfLegends  location "]}," Faker LeagueOfLegends champion":{"type":"method","name":"champion","children":[],"call":[" fetch ","Faker Games LeagueOfLegends  champion "]}," Faker Internet user_agent":{"type":"method","name":"user_agent","children":[],"call":[" sample ","agent_hash [] ","agent_hash keys ","vendor to_sym ","vendor respond_to? "," translate ","keywords << ","legacy_vendor != "," warn_for_deprecated_arguments "," warn_with_uplevel "," translate  [] "," translate  keys "]}," Faker HowIMetYourMother quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows HowIMetYourMother  quote "]}," Faker HowIMetYourMother high_five":{"type":"method","name":"high_five","children":[],"call":[" fetch ","Faker TvShows HowIMetYourMother  high_five "]}," Faker HowIMetYourMother catch_phrase":{"type":"method","name":"catch_phrase","children":[],"call":[" fetch ","Faker TvShows HowIMetYourMother  catch_phrase "]}," Faker HowIMetYourMother character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows HowIMetYourMother  character "]}," Faker Hobbit location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker Movies Hobbit  location "]}," Faker Hobbit quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Movies Hobbit  quote "]}," Faker Hobbit thorins_company":{"type":"method","name":"thorins_company","children":[],"call":[" fetch ","Faker Movies Hobbit  thorins_company "]}," Faker Hobbit character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Movies Hobbit  character "]}," Faker HitchhikersGuideToTheGalaxy starship":{"type":"method","name":"starship","children":[],"call":[" fetch ","Faker Movies HitchhikersGuideToTheGalaxy  starship "]}," Faker HitchhikersGuideToTheGalaxy specie":{"type":"method","name":"specie","children":[],"call":[" fetch ","Faker Movies HitchhikersGuideToTheGalaxy  specie "]}," Faker HitchhikersGuideToTheGalaxy quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Movies HitchhikersGuideToTheGalaxy  quote "]}," Faker HitchhikersGuideToTheGalaxy planet":{"type":"method","name":"planet","children":[],"call":[" fetch ","Faker Movies HitchhikersGuideToTheGalaxy  planet "]}," Faker HitchhikersGuideToTheGalaxy marvin_quote":{"type":"method","name":"marvin_quote","children":[],"call":[" fetch ","Faker Movies HitchhikersGuideToTheGalaxy  marvin_quote "]}," Faker HitchhikersGuideToTheGalaxy location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker Movies HitchhikersGuideToTheGalaxy  location "]}," Faker HitchhikersGuideToTheGalaxy character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Movies HitchhikersGuideToTheGalaxy  character "]}," Faker HeyArnold quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows HeyArnold  quote "]}," Faker HeyArnold location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker TvShows HeyArnold  location "]}," Faker HeyArnold character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows HeyArnold  character "]}," Faker FunnyName name_with_initial":{"type":"method","name":"name_with_initial","children":[],"call":[" sample ","name count > ","name count "," fetch_all select "," fetch_all ","name count positive? "]}," Faker FunnyName four_word_name":{"type":"method","name":"four_word_name","children":[],"call":[" sample ","name count == ","name count "," fetch_all select "," fetch_all "]}," Faker FunnyName three_word_name":{"type":"method","name":"three_word_name","children":[],"call":[" sample ","name count == ","name count "," fetch_all select "," fetch_all "]}," Faker FunnyName two_word_name":{"type":"method","name":"two_word_name","children":[],"call":[" sample ","name count == ","name count "," fetch_all select "," fetch_all "]}," Faker FunnyName name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Food dish":{"type":"method","name":"dish","children":[],"call":[" fetch "]}," Faker FamilyGuy quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows FamilyGuy  quote "]}," Faker FamilyGuy location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker TvShows FamilyGuy  location "]}," Faker FamilyGuy character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows FamilyGuy  character "]}," Faker DragonBall character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker JapaneseMedia DragonBall  character "]}," Faker DrWho specie":{"type":"method","name":"specie","children":[],"call":["Faker TvShows DrWho  specie "]}," Faker DrWho villian":{"type":"method","name":"villian","children":[],"call":["Faker TvShows DrWho  villian "]}," Faker DrWho quote":{"type":"method","name":"quote","children":[],"call":["Faker TvShows DrWho  quote "]}," Faker DrWho catch_phrase":{"type":"method","name":"catch_phrase","children":[],"call":["Faker TvShows DrWho  catch_phrase "]}," Faker DrWho the_doctor":{"type":"method","name":"the_doctor","children":[],"call":["Faker TvShows DrWho  the_doctor "]}," Faker DrWho character":{"type":"method","name":"character","children":[],"call":["Faker TvShows DrWho  character "]}," Faker Dessert flavor":{"type":"method","name":"flavor","children":[],"call":[" fetch "]}," Faker Dessert topping":{"type":"method","name":"topping","children":[],"call":[" fetch "]}," Faker Dessert variety":{"type":"method","name":"variety","children":[],"call":[" fetch "]}," Faker Compass quarter_wind_azimuth":{"type":"method","name":"quarter_wind_azimuth","children":[],"call":[" fetch "]}," Faker Compass half_wind_azimuth":{"type":"method","name":"half_wind_azimuth","children":[],"call":[" fetch "]}," Faker Compass ordinal_azimuth":{"type":"method","name":"ordinal_azimuth","children":[],"call":[" fetch "]}," Faker Compass cardinal_azimuth":{"type":"method","name":"cardinal_azimuth","children":[],"call":[" fetch "]}," Faker Compass quarter_wind_abbreviation":{"type":"method","name":"quarter_wind_abbreviation","children":[],"call":[" fetch "]}," Faker Compass half_wind_abbreviation":{"type":"method","name":"half_wind_abbreviation","children":[],"call":[" fetch "]}," Faker Compass ordinal_abbreviation":{"type":"method","name":"ordinal_abbreviation","children":[],"call":[" fetch "]}," Faker Compass cardinal_abbreviation":{"type":"method","name":"cardinal_abbreviation","children":[],"call":[" fetch "]}," Faker Compass azimuth":{"type":"method","name":"azimuth","children":[],"call":[" parse "]}," Faker Compass abbreviation":{"type":"method","name":"abbreviation","children":[],"call":[" parse "]}," Faker Compass direction":{"type":"method","name":"direction","children":[],"call":[" parse "]}," Faker Compass quarter_wind":{"type":"method","name":"quarter_wind","children":[],"call":[" fetch "]}," Faker Compass half_wind":{"type":"method","name":"half_wind","children":[],"call":[" fetch "]}," Faker Compass ordinal":{"type":"method","name":"ordinal","children":[],"call":[" fetch "]}," Faker Compass cardinal":{"type":"method","name":"cardinal","children":[],"call":[" fetch "]}," Faker Company mod11":{"type":"method","name":"mod11","children":[],"call":["11 - ","sum % ","char to_i * ","weight [] ","char to_i ","number to_s reverse chars each_with_index ","number to_s reverse chars ","number to_s reverse ","number to_s "]}," Faker Company norwegian_organisation_number":{"type":"method","name":"norwegian_organisation_number","children":[],"call":["base + ","mod11_check to_s "," mod11 ","(send nil :sample\n  (array\n    (int 8)\n    (int 9))) join ","%07d % "," rand ","10 ** "," sample ","mod11_check nil? "," format ","(send nil :sample\n  (array\n    (int 8)\n    (int 9))) join  + "," mod11  to_s "," mod11  nil? "]}," Faker Coffee search_format":{"type":"method","name":"search_format","children":[],"call":["key downcase ","key split join downcase ","key split join ","key split ","key split length > ","key split length "]}," Faker Coffee notes":{"type":"method","name":"notes","children":[],"call":[" parse "]}," Faker Coffee variety":{"type":"method","name":"variety","children":[],"call":[" fetch "]}," Faker Coffee origin":{"type":"method","name":"origin","children":[],"call":[" fetch "," search_format "]}," Faker Coffee blend_name":{"type":"method","name":"blend_name","children":[],"call":[" parse "]}," Faker Address country_code_long":{"type":"method","name":"country_code_long","children":[],"call":[" fetch "]}," Faker Address community":{"type":"method","name":"community","children":[],"call":[" parse "]}," Faker Team mascot":{"type":"method","name":"mascot","children":[],"call":[" fetch "]}," Faker Movie quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker WorldOfWarcraft quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Games WorldOfWarcraft  quote "]}," Faker WorldOfWarcraft hero":{"type":"method","name":"hero","children":[],"call":[" fetch ","Faker Games WorldOfWarcraft  hero "]}," Faker Witcher monster":{"type":"method","name":"monster","children":[],"call":[" fetch ","Faker Games Witcher  monster "]}," Faker Witcher quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Games Witcher  quote "]}," Faker Witcher location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker Games Witcher  location "]}," Faker Witcher school":{"type":"method","name":"school","children":[],"call":[" fetch ","Faker Games Witcher  school "]}," Faker Witcher witcher":{"type":"method","name":"witcher","children":[],"call":[" fetch ","Faker Games Witcher  witcher "]}," Faker Witcher character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Games Witcher  character "]}," Faker VentureBros quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows VentureBros  quote "]}," Faker VentureBros vehicle":{"type":"method","name":"vehicle","children":[],"call":[" fetch ","Faker TvShows VentureBros  vehicle "]}," Faker VentureBros organization":{"type":"method","name":"organization","children":[],"call":[" fetch ","Faker TvShows VentureBros  organization "]}," Faker VentureBros character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows VentureBros  character "]}," Faker University greek_alphabet":{"type":"method","name":"greek_alphabet","children":[],"call":[]}," Faker University greek_organization":{"type":"method","name":"greek_organization","children":[],"call":["organization + "," sample "," greek_alphabet ","3 times ","(send\n  (send\n    (int 3) :times) :map) join ","3 times map ","(send\n  (const nil :Array) :new\n  (int 3)) join ","Array  new ","organization +  + "]}," Faker UmphreysMcgee song":{"type":"method","name":"song","children":[],"call":[" fetch ","Faker Music UmphreysMcgee  song "]}," Faker TheFreshPrinceOfBelAir quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows TheFreshPrinceOfBelAir  quote "]}," Faker TheFreshPrinceOfBelAir celebrity":{"type":"method","name":"celebrity","children":[],"call":[" fetch ","Faker TvShows TheFreshPrinceOfBelAir  celebrity "]}," Faker TheFreshPrinceOfBelAir character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows TheFreshPrinceOfBelAir  character "]}," Faker StarWars wookiee_words":{"type":"method","name":"wookiee_words","children":[],"call":[" fetch "," fetch_all ","Faker Movies StarWars  wookiee_words "]}," Faker StarWars wookiee_sentence":{"type":"method","name":"wookiee_sentence","children":[],"call":["sentence + "," sample ","  + "," wookiee_words "," rand times "," rand "," sample capitalize ","Faker Movies StarWars  wookiee_sentence "," sample capitalize  + ","Faker Movies StarWars  wookiee_ sample capitalize  "]}," Faker Seinfeld quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows Seinfeld  quote "]}," Faker Seinfeld character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows Seinfeld  character "]}," Faker MostInterestingManInTheWorld quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Quote  most_interesting_man_in_the_world "]}," Faker Measurement make_plural":{"type":"method","name":"make_plural","children":[],"call":[]}," Faker Measurement check_for_plural":{"type":"method","name":"check_for_plural","children":[],"call":[" make_plural ","number != "]}," Faker Measurement ensure_valid_amount":{"type":"method","name":"ensure_valid_amount","children":[],"call":[" raise ","amount is_a? ","amount == "]}," Faker Measurement metric_weight":{"type":"method","name":"metric_weight","children":[],"call":[" check_for_plural "," fetch ","amount to_s ","amount == "," make_plural "," ensure_valid_amount "," define_measurement_locale ","keywords << ","legacy_amount != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Measurement metric_volume":{"type":"method","name":"metric_volume","children":[],"call":[" check_for_plural "," fetch ","amount to_s ","amount == "," make_plural "," ensure_valid_amount "," define_measurement_locale ","keywords << ","legacy_amount != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Measurement metric_length":{"type":"method","name":"metric_length","children":[],"call":[" check_for_plural "," fetch ","amount to_s ","amount == "," make_plural "," ensure_valid_amount "," define_measurement_locale ","keywords << ","legacy_amount != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Measurement metric_height":{"type":"method","name":"metric_height","children":[],"call":[" check_for_plural "," fetch ","amount to_s ","amount == "," make_plural "," ensure_valid_amount "," define_measurement_locale ","keywords << ","legacy_amount != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Measurement weight":{"type":"method","name":"weight","children":[],"call":[" check_for_plural "," fetch ","amount to_s ","amount == "," make_plural "," ensure_valid_amount "," define_measurement_locale ","keywords << ","legacy_amount != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Measurement volume":{"type":"method","name":"volume","children":[],"call":[" check_for_plural "," fetch ","amount to_s ","amount == "," make_plural "," ensure_valid_amount "," define_measurement_locale ","keywords << ","legacy_amount != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Measurement length":{"type":"method","name":"length","children":[],"call":[" check_for_plural "," fetch ","amount to_s ","amount == "," make_plural "," ensure_valid_amount "," define_measurement_locale ","keywords << ","legacy_amount != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Measurement height":{"type":"method","name":"height","children":[],"call":[" check_for_plural "," fetch ","amount to_s ","amount == "," make_plural "," ensure_valid_amount "," define_measurement_locale ","keywords << ","legacy_amount != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker HarryPotter house":{"type":"method","name":"house","children":[],"call":[" fetch ","Faker Movies HarryPotter  house "]}," Faker Food metric_measurement":{"type":"method","name":"metric_measurement","children":[],"call":[" fetch "]}," Faker ElderScrolls dragon":{"type":"method","name":"dragon","children":[],"call":[" fetch ","Faker Games ElderScrolls  dragon "]}," Faker ElderScrolls region":{"type":"method","name":"region","children":[],"call":[" fetch ","Faker Games ElderScrolls  region "]}," Faker ElderScrolls creature":{"type":"method","name":"creature","children":[],"call":[" fetch ","Faker Games ElderScrolls  creature "]}," Faker ElderScrolls race":{"type":"method","name":"race","children":[],"call":[" fetch ","Faker Games ElderScrolls  race "]}," Faker BossaNova song":{"type":"method","name":"song","children":[],"call":[" fetch "]}," Faker BossaNova artist":{"type":"method","name":"artist","children":[],"call":[" fetch "]}," Faker Zelda item":{"type":"method","name":"item","children":[],"call":[" fetch ","Faker Games Zelda  item "]}," Faker VForVendetta quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Movies VForVendetta  quote "]}," Faker VForVendetta speech":{"type":"method","name":"speech","children":[],"call":[" fetch ","Faker Movies VForVendetta  speech "]}," Faker VForVendetta character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Movies VForVendetta  character "]}," Faker TheThickOfIt position":{"type":"method","name":"position","children":[],"call":[" fetch ","Faker TvShows TheThickOfIt  position "]}," Faker TheThickOfIt department":{"type":"method","name":"department","children":[],"call":[" fetch ","Faker TvShows TheThickOfIt  department "]}," Faker TheThickOfIt character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows TheThickOfIt  character "]}," Faker Stargate quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows Stargate  quote "]}," Faker Stargate planet":{"type":"method","name":"planet","children":[],"call":[" fetch ","Faker TvShows Stargate  planet "]}," Faker Stargate character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows Stargate  character "]}," Faker SiliconValley url":{"type":"method","name":"url","children":[],"call":[" fetch ","Faker TvShows SiliconValley  url "]}," Faker SiliconValley motto":{"type":"method","name":"motto","children":[],"call":[" fetch ","Faker TvShows SiliconValley  motto "]}," Faker SiliconValley invention":{"type":"method","name":"invention","children":[],"call":[" fetch ","Faker TvShows SiliconValley  invention "]}," Faker SiliconValley app":{"type":"method","name":"app","children":[],"call":[" fetch ","Faker TvShows SiliconValley  app "]}," Faker SiliconValley quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows SiliconValley  quote "]}," Faker SiliconValley company":{"type":"method","name":"company","children":[],"call":[" fetch ","Faker TvShows SiliconValley  company "]}," Faker SiliconValley character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows SiliconValley  character "]}," Faker Science scientist":{"type":"method","name":"scientist","children":[],"call":[" fetch "]}," Faker Science element":{"type":"method","name":"element","children":[],"call":[" fetch "]}," Faker RuPaul queen":{"type":"method","name":"queen","children":[],"call":[" fetch ","Faker TvShows RuPaul  queen "]}," Faker ProgrammingLanguage creator":{"type":"method","name":"creator","children":[],"call":[" fetch "]}," Faker ProgrammingLanguage name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker OnePiece akuma_no_mi":{"type":"method","name":"akuma_no_mi","children":[],"call":[" fetch ","Faker JapaneseMedia OnePiece  akuma_no_mi "]}," Faker OnePiece quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker JapaneseMedia OnePiece  quote "]}," Faker OnePiece location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker JapaneseMedia OnePiece  location "]}," Faker OnePiece island":{"type":"method","name":"island","children":[],"call":[" fetch ","Faker JapaneseMedia OnePiece  island "]}," Faker OnePiece sea":{"type":"method","name":"sea","children":[],"call":[" fetch ","Faker JapaneseMedia OnePiece  sea "]}," Faker OnePiece character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker JapaneseMedia OnePiece  character "]}," Faker Name initials":{"type":"method","name":"initials","children":[],"call":["(send\n  (begin\n    (erange\n      (int 0)\n      (lvar :character_count))) :map) join ","(send\n  (int 65) :+\n  (send nil :rand\n    (int 26))) chr ","65 + "," rand ","(erange\n  (int 0)\n  (lvar :character_count)) map "," rand chr ","(send\n  (begin\n    (erange\n      (int 0)\n      (lvar :number))) :map) join ","(erange\n  (int 0)\n  (lvar :number)) map ","keywords << ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Lebowski quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Movies Lebowski  quote "]}," Faker Lebowski character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Movies Lebowski  character "]}," Faker Lebowski actor":{"type":"method","name":"actor","children":[],"call":[" fetch ","Faker Movies Lebowski  actor "]}," Faker Kpop solo":{"type":"method","name":"solo","children":[],"call":[" fetch "]}," Faker Kpop boy_bands":{"type":"method","name":"boy_bands","children":[],"call":[" fetch "]}," Faker Kpop girl_groups":{"type":"method","name":"girl_groups","children":[],"call":[" fetch "]}," Faker Kpop iii_groups":{"type":"method","name":"iii_groups","children":[],"call":[" fetch "]}," Faker Kpop ii_groups":{"type":"method","name":"ii_groups","children":[],"call":[" fetch "]}," Faker Kpop i_groups":{"type":"method","name":"i_groups","children":[],"call":[" fetch "]}," Faker Fallout quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Games Fallout  quote "]}," Faker Fallout location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker Games Fallout  location "]}," Faker Fallout faction":{"type":"method","name":"faction","children":[],"call":[" fetch ","Faker Games Fallout  faction "]}," Faker Fallout character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Games Fallout  character "]}," Faker Dune saying":{"type":"method","name":"saying","children":[],"call":[" fetch ","dune.sayings. + "," raise ","sourced_sayings join ","sourced_sayings include? ","source to_sym ","source to_s downcase! ","source to_s "," sample to_s "," sample ","source nil? "," translate keys "," translate ","Faker Books Dune  saying "," sample to_s d_sayings join "," translate keys  join "," sample to_s d_sayings include? "," translate keys  include? "," sample to_s  to_sym "," sample to_s  to_s downcase! "," sample to_s  to_s "," sample to_s  nil? "]}," Faker Dune quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","dune.quotes. + "," raise ","quoted_characters join ","quoted_characters include? ","character to_sym ","character to_s downcase! ","character to_s "," sample to_s "," sample ","character nil? "," translate keys "," translate ","Faker Books Dune  quote ","quoted_ sample to_s s join "," translate keys  join ","quoted_ sample to_s s include? "," translate keys  include? "," sample to_s  to_sym "," sample to_s  to_s downcase! "," sample to_s  to_s "," sample to_s  nil? "]}," Faker Dune planet":{"type":"method","name":"planet","children":[],"call":[" fetch ","Faker Books Dune  planet "]}," Faker Dune title":{"type":"method","name":"title","children":[],"call":[" fetch ","Faker Books Dune  title "]}," Faker Dune character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Books Dune  character "]}," Faker DumbAndDumber quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows DumbAndDumber  quote "]}," Faker DumbAndDumber character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows DumbAndDumber  character "]}," Faker DumbAndDumber actor":{"type":"method","name":"actor","children":[],"call":[" fetch ","Faker TvShows DumbAndDumber  actor "]}," Faker Dog size":{"type":"method","name":"size","children":[],"call":[" fetch ","Faker Creature Dog  size "]}," Faker Dog coat_length":{"type":"method","name":"coat_length","children":[],"call":[" fetch ","Faker Creature Dog  coat_length "]}," Faker Dog gender":{"type":"method","name":"gender","children":[],"call":[" fetch ","Faker Creature Dog  gender "]}," Faker Dog age":{"type":"method","name":"age","children":[],"call":[" fetch ","Faker Creature Dog  age "]}," Faker Dog meme_phrase":{"type":"method","name":"meme_phrase","children":[],"call":[" fetch ","Faker Creature Dog  meme_phrase "]}," Faker Dog sound":{"type":"method","name":"sound","children":[],"call":[" fetch ","Faker Creature Dog  sound "]}," Faker Dog breed":{"type":"method","name":"breed","children":[],"call":[" fetch ","Faker Creature Dog  breed "]}," Faker Dog name":{"type":"method","name":"name","children":[],"call":[" fetch ","Faker Creature Dog  name "]}," Faker Company french_siret_number":{"type":"method","name":"french_siret_number","children":[],"call":["org_no + "," luhn_algorithm to_s "," luhn_algorithm "," french_siren_number + "," french_siren_number "," rand to_s rjust "," rand to_s "," rand "," french_siren_number +  + "]}," Faker Company french_siren_number":{"type":"method","name":"french_siren_number","children":[],"call":["base + "," luhn_algorithm to_s "," luhn_algorithm ","(send\n  (begin\n    (irange\n      (int 1)\n      (int 8))) :map) join "," rand ","(irange\n  (int 1)\n  (int 8)) map ","(send\n  (begin\n    (irange\n      (int 1)\n      (int 8))) :map) join  + "]}," Faker Company spanish_organisation_number":{"type":"method","name":"spanish_organisation_number","children":[],"call":["(send nil :sample\n  (lvar :letters)) join ","%07d % "," rand ","10 ** "," sample "," format ","(send nil :sample\n  (const\n    (self) :ULetters)) join ","(lvar :organization_type) join "," spanish_cif_control_digit ","letters include? ","(lvar : sample ) join "," spanish_cif_ spanish_cif_control_digit _digit "]}," Faker BreakingBad episode":{"type":"method","name":"episode","children":[],"call":["Faker TvShows BreakingBad  episode "]}," Faker BreakingBad character":{"type":"method","name":"character","children":[],"call":["Faker TvShows BreakingBad  character "]}," Faker Bank iban_length":{"type":"method","name":"iban_length","children":[],"call":[" raise "," fetch to_i "," fetch ","country_code downcase "]}," Faker Bank iban_range":{"type":"method","name":"iban_range","children":[],"call":["Array  new "," iban_length "]}," Faker BackToTheFuture quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Movies BackToTheFuture  quote "]}," Faker BackToTheFuture date":{"type":"method","name":"date","children":[],"call":[" fetch ","Faker Movies BackToTheFuture  date "]}," Faker BackToTheFuture character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Movies BackToTheFuture  character "]}," Faker AquaTeenHungerForce character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows AquaTeenHungerForce  character "]}," Faker Types resolve":{"type":"method","name":"resolve","children":[],"call":[" rand "," sample "]}," Faker Types titleize":{"type":"method","name":"titleize","children":[],"call":["word split map join ","word split map ","word split "]}," Faker Types random_complex_type":{"type":"method","name":"random_complex_type","children":[],"call":[" integer "," array "," hash "," string ","types [] "," rand ","types length - ","types length ","SIMPLE_TYPES  + "," rb_array "," rb_hash "," rb_integer "," rb_string ","SIMPLE_TYPES  +  [] ","SIMPLE_TYPES  +  length - ","SIMPLE_TYPES  +  length "]}," Faker Types random_type":{"type":"method","name":"random_type","children":[],"call":[" integer "," string ","SIMPLE_TYPES  [] "," rand ","SIMPLE_TYPES  length - ","SIMPLE_TYPES  length "," rb_integer "," rb_string "]}," Faker Types array":{"type":"method","name":"array","children":[],"call":["ar push "," random_type ","len times ","Array  new tap ","Array  new "]}," Faker Types complex_hash":{"type":"method","name":"complex_hash","children":[],"call":["hsh merge! "," random_complex_type "," string to_sym "," string ","key_count times ","Hash  new tap ","Hash  new "]}," Faker Types hash":{"type":"method","name":"hash","children":[],"call":["hsh merge! "," random_type "," string to_sym "," string ","key_count times ","Hash  new tap ","Hash  new "]}," Faker Types integer":{"type":"method","name":"integer","children":[],"call":[" rand to_i "," rand "]}," Faker Types character":{"type":"method","name":"character","children":[],"call":[" sample "]}," Faker Types string":{"type":"method","name":"string","children":[],"call":[" shuffle [] join "," shuffle [] "," shuffle ","word_list * ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar :word_list) :length)) + ","resolved_num / ","word_list length "," translate "," resolve ","word_list *  * ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar :word_list * ) :length)) + ","(send\n  (lvar : resolve ) :/\n  (send\n    (lvar :word_list) :length)) + "," resolve  / ","word_list *  length "]}," Faker StarWars call_squadrons":{"type":"method","name":"call_squadrons","children":[],"call":[" fetch "," fetch_all ","Faker Movies StarWars  call_squadrons "]}," Faker StarWars call_numbers":{"type":"method","name":"call_numbers","children":[],"call":[" fetch "," fetch_all ","Faker Movies StarWars  call_numbers "]}," Faker StarWars call_number":{"type":"method","name":"call_number","children":[],"call":[" sample "," call_numbers ","Faker Movies StarWars  call_number "]}," Faker StarWars call_sign":{"type":"method","name":"call_sign","children":[],"call":[" numerify "," parse ","Faker Movies StarWars  call_sign "]}," Faker StarWars call_squadron":{"type":"method","name":"call_squadron","children":[],"call":[" sample "," call_squadrons ","Faker Movies StarWars  call_squadron "]}," Faker App semantic_version":{"type":"method","name":"semantic_version","children":[],"call":["(send\n  (array\n    (lvar :major)\n    (lvar :minor)\n    (lvar :patch)) :map) join "," sample "," Array ","(lvar :major) map ","keywords << ","legacy_patch != ","legacy_minor != ","legacy_major != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker UniqueGenerator respond_to_missing?":{"type":"method","name":"respond_to_missing?","children":[],"call":["method_name to_s start_with? ","method_name to_s "]}," Faker Base respond_to_missing?":{"type":"method","name":"respond_to_missing?","children":[],"call":[]}," Faker WorldCup roster":{"type":"method","name":"roster","children":[],"call":[" fetch ","keywords << ","legacy_type != ","legacy_country != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker WorldCup group":{"type":"method","name":"group","children":[],"call":[" fetch ","keywords << ","legacy_group != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker WorldCup stadium":{"type":"method","name":"stadium","children":[],"call":[" fetch "]}," Faker WorldCup city":{"type":"method","name":"city","children":[],"call":[" fetch "]}," Faker WorldCup team":{"type":"method","name":"team","children":[],"call":[" fetch "]}," Faker Verb ing_form":{"type":"method","name":"ing_form","children":[],"call":[" fetch "]}," Faker Verb simple_present":{"type":"method","name":"simple_present","children":[],"call":[" fetch "]}," Faker Verb past_participle":{"type":"method","name":"past_participle","children":[],"call":[" fetch "]}," Faker Verb past":{"type":"method","name":"past","children":[],"call":[" fetch "]}," Faker Verb base":{"type":"method","name":"base","children":[],"call":[" fetch "]}," Faker Vehicle standard_specs":{"type":"method","name":"standard_specs","children":[],"call":[" fetch ","Array  new "," rand "]}," Faker Vehicle car_options":{"type":"method","name":"car_options","children":[],"call":[" fetch ","Array  new "," rand "]}," Faker Vehicle engine":{"type":"method","name":"engine","children":[],"call":[" fetch "," sample "," fetch_all "]}," Faker Vehicle car_type":{"type":"method","name":"car_type","children":[],"call":[" fetch "]}," Faker Vehicle door_count":{"type":"method","name":"door_count","children":[],"call":[" fetch "]}," Faker Vehicle fuel_type":{"type":"method","name":"fuel_type","children":[],"call":[" fetch "]}," Faker Vehicle drive_type":{"type":"method","name":"drive_type","children":[],"call":[" fetch "]}," Faker Vehicle transmission":{"type":"method","name":"transmission","children":[],"call":[" fetch "]}," Faker Vehicle color":{"type":"method","name":"color","children":[],"call":[" fetch "]}," Faker Vehicle style":{"type":"method","name":"style","children":[],"call":[" fetch "]}," Faker Vehicle make_and_model":{"type":"method","name":"make_and_model","children":[],"call":[" model "," make ","  make odel ","  make ake "]}," Faker Vehicle model":{"type":"method","name":"model","children":[],"call":[" fetch "," make ","make_of_model empty? ","keywords << ","legacy_make_of_model != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Vehicle make":{"type":"method","name":"make","children":[],"call":[" fetch "]}," Faker Vehicle year":{"type":"method","name":"year","children":[],"call":[" rand_in_range "," Time  now year "," Time  now ","Faker Time  backward to_i ","Faker Time  backward "]}," Faker Vehicle mileage":{"type":"method","name":"mileage","children":[],"call":[" rand_in_range ","keywords << ","legacy_max != ","legacy_min != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Types rb_array":{"type":"method","name":"rb_array","children":[],"call":["ar push "," random_type ","len times "," tap ","keywords << ","legacy_len != "," warn_for_deprecated_arguments "," warn_with_uplevel ","type call ","type is_a? "]}," Faker Types complex_rb_hash":{"type":"method","name":"complex_rb_hash","children":[],"call":["hsh merge! "," random_complex_type ","s to_sym ","Lorem  words uniq first each ","Lorem  words uniq first ","Lorem  words uniq ","Lorem  words ","key_count * "," tap "," rb_hash ","keywords << ","legacy_number != "," warn_for_deprecated_arguments "," lambda "," warn_with_uplevel "]}," Faker Types rb_hash":{"type":"method","name":"rb_hash","children":[],"call":["hsh merge! "," random_type ","s to_sym ","Lorem  words uniq first each ","Lorem  words uniq first ","Lorem  words uniq ","Lorem  words ","key_count * "," tap ","number * ","keywords << ","legacy_type != ","legacy_number != "," warn_for_deprecated_arguments ","type call ","type is_a? "," warn_with_uplevel "]}," Faker Types rb_integer":{"type":"method","name":"rb_integer","children":[],"call":[" rand to_i "," rand ","keywords << ","legacy_to != ","legacy_from != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Types rb_string":{"type":"method","name":"rb_string","children":[],"call":[" shuffle [] join "," shuffle [] "," shuffle ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar :word_list) :length)) + ","resolved_num / ","word_list length "," translate "," resolve ","keywords << ","legacy_words != "," warn_for_deprecated_arguments "," warn_with_uplevel ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar : translate ) :length)) + ","(send\n  (lvar : resolve ) :/\n  (send\n    (lvar :word_list) :length)) + "," resolve  / "," translate  length "]}," Faker TheITCrowd quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows TheITCrowd  quote "]}," Faker TheITCrowd email":{"type":"method","name":"email","children":[],"call":[" fetch ","Faker TvShows TheITCrowd  email "]}," Faker TheITCrowd character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows TheITCrowd  character "]}," Faker TheITCrowd actor":{"type":"method","name":"actor","children":[],"call":[" fetch ","Faker TvShows TheITCrowd  actor "]}," Faker Team sport":{"type":"method","name":"sport","children":[],"call":[" fetch "]}," Faker SwordArtOnline item":{"type":"method","name":"item","children":[],"call":[" fetch ","Faker JapaneseMedia SwordArtOnline  item "]}," Faker SwordArtOnline location":{"type":"method","name":"location","children":[],"call":[" fetch ","Faker JapaneseMedia SwordArtOnline  location "]}," Faker SwordArtOnline game_name":{"type":"method","name":"game_name","children":[],"call":[" fetch ","Faker JapaneseMedia SwordArtOnline  game_name "]}," Faker SwordArtOnline real_name":{"type":"method","name":"real_name","children":[],"call":[" fetch ","Faker JapaneseMedia SwordArtOnline  real_name "]}," Faker Stripe ccv":{"type":"method","name":"ccv","children":[],"call":["(if\n  (send\n    (send\n      (lvar :card_type) :to_s) :==\n    (str \"amex\"))\n  (send nil :rand_in_range\n    (int 1000)\n    (int 9999))\n  (send nil :rand_in_range\n    (int 100)\n    (int 999))) to_s "," rand_in_range ","card_type to_s == ","card_type to_s ","keywords << ","legacy_card_type != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Stripe year":{"type":"method","name":"year","children":[],"call":[" rand_in_range to_s "," rand_in_range ","start_year + "," Time  new year + "," Time  new year "," Time  new "," Time  new year +  + "]}," Faker Stripe month":{"type":"method","name":"month","children":[],"call":[" format "," rand_in_range "]}," Faker Stripe invalid_card":{"type":"method","name":"invalid_card","children":[],"call":[" fetch ","stripe.invalid_cards. + "," raise ","invalid_cards join ","invalid_cards include? ","card_error to_sym "," sample to_s "," sample ","card_error nil? "," translate keys "," translate ","keywords << ","legacy_card_error != "," warn_for_deprecated_arguments "," warn_with_uplevel ","stripe. translate keys . + "," translate keys  join "," translate keys  include? "," sample to_s  to_sym "," sample to_s  nil? ","legacy_ sample to_s  != "]}," Faker Stripe valid_token":{"type":"method","name":"valid_token","children":[],"call":[" fetch ","stripe.valid_tokens. + "," raise ","valid_tokens join ","valid_tokens include? ","card_type to_sym "," sample to_s "," sample ","card_type nil? "," translate keys "," translate ","keywords << ","legacy_card_type != "," warn_for_deprecated_arguments "," warn_with_uplevel ","stripe. translate keys . + "," translate keys  join "," translate keys  include? "," sample to_s  to_sym "," sample to_s  nil? ","legacy_ sample to_s  != "]}," Faker Stripe valid_card":{"type":"method","name":"valid_card","children":[],"call":[" fetch ","stripe.valid_cards. + "," raise ","valid_cards join ","valid_cards include? ","card_type to_sym "," sample to_s "," sample ","card_type nil? "," translate keys "," translate ","keywords << ","legacy_card_type != "," warn_for_deprecated_arguments "," warn_with_uplevel ","stripe. translate keys . + "," translate keys  join "," translate keys  include? "," sample to_s  to_sym "," sample to_s  nil? ","legacy_ sample to_s  != "]}," Faker String utf8character":{"type":"method","name":"utf8character","children":[],"call":[" sample chr "," sample "," rand "]}," Faker String char_space_ratio":{"type":"method","name":"char_space_ratio","children":[],"call":[" sample ","(int 2) flatten ","(int 7) * ","(int 5) * ","(int 3) * "]}," Faker String space_or_utf8_char":{"type":"method","name":"space_or_utf8_char","children":[],"call":[" sample ","(send\n  (int 32) :chr\n  (const\n    (const nil :Encoding) :UTF_8)) flatten ","(send nil :utf8character) * "," utf8character ","32 chr "]}," Faker String utf8string":{"type":"method","name":"utf8string","children":[],"call":["(send\n  (begin\n    (irange\n      (int 1)\n      (send\n        (lvar :length) :to_i))) :map) join "," space_or_utf8_char ","(irange\n  (int 1)\n  (send\n    (lvar :length) :to_i)) map ","length to_i "," char_space_ratio "," char_space_ char_space_ratio  "]}," Faker String select_a":{"type":"method","name":"select_a","children":[],"call":[" select_a "," sample ","length to_enum to_a ","length to_enum ","length class included_modules include? ","length class included_modules ","length class "]}," Faker String random":{"type":"method","name":"random","children":[],"call":[" utf8string "," select_a ","keywords << ","legacy_length != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker StrangerThings character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows StrangerThings  character "]}," Faker StrangerThings quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows StrangerThings  quote "]}," Faker Space launch_vehicule":{"type":"method","name":"launch_vehicule","children":[],"call":[" fetch "]}," Faker Source print_1_to_10":{"type":"method","name":"print_1_to_10","children":[],"call":[" fetch ","keywords << ","legacy_lang != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Source print":{"type":"method","name":"print","children":[],"call":["code gsub "," fetch ","keywords << ","legacy_lang != "," warn_for_deprecated_arguments ","legacy_str != "," warn_with_uplevel "," fetch  gsub "]}," Faker Source hello_world":{"type":"method","name":"hello_world","children":[],"call":[" fetch ","keywords << ","legacy_lang != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker SingularSiegler quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Quote  singular_siegler "]}," Faker SiliconValley email":{"type":"method","name":"email","children":[],"call":[" fetch ","Faker TvShows SiliconValley  email "]}," Faker Science element_symbol":{"type":"method","name":"element_symbol","children":[],"call":[" fetch "]}," Faker PrincessBride quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Movies PrincessBride  quote "]}," Faker PrincessBride character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Movies PrincessBride  character "]}," Faker Placeholdit generate_color":{"type":"method","name":"generate_color","children":[],"call":[" format "," rand * "," rand "]}," Faker ParksAndRec city":{"type":"method","name":"city","children":[],"call":[" fetch ","Faker TvShows ParksAndRec  city "]}," Faker ParksAndRec character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows ParksAndRec  character "]}," Faker NewGirl quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows NewGirl  quote "]}," Faker NewGirl character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows NewGirl  character "]}," Faker NatoPhoneticAlphabet code_word":{"type":"method","name":"code_word","children":[],"call":[" fetch "]}," Faker Nation national_sport":{"type":"method","name":"national_sport","children":[],"call":[" fetch "]}," Faker Nation capital_city":{"type":"method","name":"capital_city","children":[],"call":[" fetch "]}," Faker Nation language":{"type":"method","name":"language","children":[],"call":[" fetch "]}," Faker Nation nationality":{"type":"method","name":"nationality","children":[],"call":[" fetch "]}," Faker Name female_first_name":{"type":"method","name":"female_first_name","children":[],"call":[" fetch "]}," Faker Name male_first_name":{"type":"method","name":"male_first_name","children":[],"call":[" fetch "]}," Faker Myst quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Games Myst  quote "]}," Faker Myst character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker Games Myst  character "]}," Faker Myst age":{"type":"method","name":"age","children":[],"call":[" fetch ","Faker Games Myst  age "]}," Faker Myst creature":{"type":"method","name":"creature","children":[],"call":[" fetch ","Faker Games Myst  creature "]}," Faker Myst game":{"type":"method","name":"game","children":[],"call":[" fetch ","Faker Games Myst  game "]}," Faker Music genre":{"type":"method","name":"genre","children":[],"call":[" fetch "]}," Faker Music album":{"type":"method","name":"album","children":[],"call":[" fetch "]}," Faker Music band":{"type":"method","name":"band","children":[],"call":[" fetch "]}," Faker Military dod_paygrade":{"type":"method","name":"dod_paygrade","children":[],"call":[" fetch "]}," Faker Military air_force_rank":{"type":"method","name":"air_force_rank","children":[],"call":[" fetch "]}," Faker Military navy_rank":{"type":"method","name":"navy_rank","children":[],"call":[" fetch "]}," Faker Military marines_rank":{"type":"method","name":"marines_rank","children":[],"call":[" fetch "]}," Faker Military army_rank":{"type":"method","name":"army_rank","children":[],"call":[" fetch "]}," Faker MichaelScott quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows MichaelScott  quote "]}," Faker Measurement define_measurement_locale":{"type":"method","name":"define_measurement_locale","children":[],"call":[" check_for_plural "," fetch ","amount == "," make_plural "," ensure_valid_amount "]}," Faker Markdown sandwich":{"type":"method","name":"sandwich","children":[],"call":["text_block join ","text_block << "," random ","Faker Lorem  paragraph ","repeat times "," headers ","keywords << ","legacy_repeat != ","legacy_sentences != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Lovecraft paragraph_by_chars":{"type":"method","name":"paragraph_by_chars","children":[],"call":["paragraph [] + ","paragraph [] ","chars - ","  + "," paragraph ","paragraph length < ","paragraph length ","Faker Books Lovecraft  paragraph_by_chars "," paragraph  [] + "," paragraph  [] ","  paragraph  "," paragraph  length < "," paragraph  length ","Faker Books Lovecraft   paragraph _by_chars "]}," Faker LoremFlickr build_url":{"type":"method","name":"build_url","children":[],"call":["url_parts compact join ","url_parts compact ","url_parts << ","search_terms compact join ","search_terms compact ","search_terms any? ","size split "," raise ","size =~ "]}," Faker LoremFlickr colorized_image":{"type":"method","name":"colorized_image","children":[],"call":[" build_url "," raise ","SUPPORTED_COLORIZATIONS  join ","SUPPORTED_COLORIZATIONS  include? ","search_terms any? ","keywords << ","legacy_match_all != ","legacy_search_terms != ","legacy_color != ","legacy_size != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker LoremFlickr pixelated_image":{"type":"method","name":"pixelated_image","children":[],"call":[" build_url "," raise ","search_terms any? ","keywords << ","legacy_match_all != ","legacy_search_terms != ","legacy_size != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker LoremFlickr grayscale_image":{"type":"method","name":"grayscale_image","children":[],"call":[" build_url "," raise ","search_terms any? ","keywords << ","legacy_match_all != ","legacy_search_terms != ","legacy_size != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker LoremFlickr image":{"type":"method","name":"image","children":[],"call":[" build_url ","keywords << ","legacy_match_all != ","legacy_search_terms != ","legacy_size != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Lorem locale_question_mark":{"type":"method","name":"locale_question_mark","children":[],"call":[" translate "]}," Faker Lorem locale_space":{"type":"method","name":"locale_space","children":[],"call":[" translate "]}," Faker Lorem locale_period":{"type":"method","name":"locale_period","children":[],"call":[" translate "]}," Faker Lorem paragraph_by_chars":{"type":"method","name":"paragraph_by_chars","children":[],"call":["paragraph [] + ","paragraph [] ","chars - ","  + "," paragraph ","paragraph length < ","paragraph length ","number - ","keywords << ","legacy_supplemental != ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel "," paragraph  [] + "," paragraph  [] ","  paragraph  "," paragraph  length < "," paragraph  length "]}," Faker Lorem multibyte":{"type":"method","name":"multibyte","children":[],"call":[" sample "," sample pack force_encoding "," sample pack "," translate "]}," Faker LordOfTheRings quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Movies LordOfTheRings  quote "]}," Faker Job position":{"type":"method","name":"position","children":[],"call":[" fetch "]}," Faker Invoice mod10_remainder":{"type":"method","name":"mod10_remainder","children":[],"call":["number -@ % ","number -@ "]}," Faker Invoice calculate_weighted_sum":{"type":"method","name":"calculate_weighted_sum","children":[],"call":["(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :base) :to_s) :reverse) :each_char) :with_index) :map) reduce ","digit to_i * ","weight_factors at ","index % ","weight_factors length ","digit to_i ","base to_s reverse each_char with_index map ","base to_s reverse each_char with_index ","base to_s reverse each_char ","base to_s reverse ","base to_s "]}," Faker Invoice kidmod10":{"type":"method","name":"kidmod10","children":[],"call":[" mod10_remainder "," calculate_weighted_sum "," calculate_ calculate_weighted_sum  "]}," Faker Invoice method_731":{"type":"method","name":"method_731","children":[],"call":[" mod10_remainder "," calculate_weighted_sum "," calculate_ calculate_weighted_sum  "]}," Faker Invoice iban_checksum":{"type":"method","name":"iban_checksum","children":[],"call":["checksum to_s rjust ","checksum to_s ","(send\n  (int 1) :-\n  (lvar :account_to_number)) % ","1 - ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :account))\n        (begin\n          (lvar :country_code))\n        (str \"00\")) :upcase) :chars) :map) join to_i ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :account))\n        (begin\n          (lvar :country_code))\n        (str \"00\")) :upcase) :chars) :map) join ","(send\n  (send\n    (lvar :d) :ord) :-\n  (int 55)) to_s ","d ord - ","d ord ","d =~ ","(begin\n  (lvar :account)) upcase chars map ","(begin\n  (lvar :account)) upcase chars ","(begin\n  (lvar :account)) upcase ","(send\n  (int 1) :-\n  (lvar :account_to_number)) %  to_s rjust ","(send\n  (int 1) :-\n  (lvar :account_to_number)) %  to_s ","(send\n  (int 1) :-\n  (lvar :(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :account))\n        (begin\n          (lvar :country_code))\n        (str \"00\")) :upcase) :chars) :map) join to_i )) % "]}," Faker Invoice reference":{"type":"method","name":"reference","children":[],"call":["ref sub! ","check_digit_match [] ","check_digit to_s rjust ","check_digit_match [] length ","check_digit to_s "," send ","ref tr "," fetch ","ref match ","Base  regexify ","ref empty? ","ref sub ","keywords << ","legacy_ref != "," warn_for_deprecated_arguments "," warn_with_uplevel ","Base  regexify  sub! ","ref sub  sub! ","check_digit to_s rjust _match [] "," send _match [] ","ref match  [] ","check_digit to_s rjust  to_s rjust "," send  to_s rjust ","check_digit to_s rjust _match [] length "," send _match [] length ","ref match  [] length ","check_digit to_s rjust  to_s "," send  to_s ","Base  regexify  tr ","ref sub  tr ","Base  regexify  match ","ref sub  match ","Base  regexify  empty? ","ref sub  empty? ","Base  regexify  sub ","ref sub  sub ","legacy_Base  regexify  != ","legacy_ref sub  != "]}," Faker Invoice creditor_reference":{"type":"method","name":"creditor_reference","children":[],"call":["RF + + ","RF + "," iban_checksum "," reference ","ref empty? ","keywords << ","legacy_ref != "," warn_for_deprecated_arguments "," warn_with_uplevel ","  reference erence "," reference  empty? ","legacy_ reference  != "]}," Faker Invoice amount_between":{"type":"method","name":"amount_between","children":[],"call":["Faker Base  rand_in_range round ","Faker Base  rand_in_range ","keywords << ","legacy_to != ","legacy_from != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Internet username":{"type":"method","name":"username","children":[],"call":[" sample ","(send\n  (array\n    (send\n      (const nil :Name) :first_name)\n    (send\n      (const nil :Name) :last_name)) :map) join ","Char  prepare ","(send\n  (const nil :Name) :first_name) map ","Name  last_name ","Name  first_name ","result [] ","specifier max ","tries < ","specifier include? ! ","specifier include? ","result length "," username ","specifier min "," loop ","specifier is_a? ","result * ","specifier / + ","specifier / ","specifier > ","result length < "," raise ","10 ** "," shuffle join downcase "," shuffle join "," shuffle ","specifier scan ","specifier respond_to? "," with_locale ","specifier positive? ","keywords << ","legacy_separators != ","legacy_specifier != "," warn_for_deprecated_arguments "," warn_with_uplevel "," username  [] "," username  length "," username  * "," username  length < "]}," Faker IDNumber spanish_foreign_citizen_number":{"type":"method","name":"spanish_foreign_citizen_number","children":[],"call":["CHECKS  [] ","(begin\n  (lvar :prefix_val)) to_i % ","(begin\n  (lvar :prefix_val)) to_i ","XYZ index to_s ","XYZ index ","code [] "," rand ","code length ","Faker Number  number ","(begin\n  (lvar :XYZ index to_s )) to_i % ","(begin\n  (lvar :code [] _val)) to_i % ","(begin\n  (lvar :XYZ index to_s )) to_i ","(begin\n  (lvar :code [] _val)) to_i "]}," Faker IDNumber spanish_citizen_number":{"type":"method","name":"spanish_citizen_number","children":[],"call":["CHECKS  [] ","num to_i % ","num to_i ","Faker Number  number ","Faker Number  number  to_i % ","Faker Number  number  to_i ","Faker Number  Faker Number  number ber "]}," Faker Hipster paragraph_by_chars":{"type":"method","name":"paragraph_by_chars","children":[],"call":["paragraph [] + ","paragraph [] ","chars - ","  + "," paragraph ","paragraph length < ","paragraph length ","characters - ","keywords << ","legacy_supplemental != ","legacy_characters != "," warn_for_deprecated_arguments "," warn_with_uplevel "," paragraph  [] + "," paragraph  [] ","  paragraph  "," paragraph  length < "," paragraph  length "]}," Faker HarryPotter spell":{"type":"method","name":"spell","children":[],"call":[" fetch ","Faker Movies HarryPotter  spell "]}," Faker GreekPhilosophers quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker GreekPhilosophers name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Gender binary_type":{"type":"method","name":"binary_type","children":[],"call":[" fetch "]}," Faker Gender type":{"type":"method","name":"type","children":[],"call":[" fetch "]}," Faker Football competition":{"type":"method","name":"competition","children":[],"call":[" fetch ","Faker Sports Football  competition "]}," Faker Football coach":{"type":"method","name":"coach","children":[],"call":[" fetch ","Faker Sports Football  coach "]}," Faker Football player":{"type":"method","name":"player","children":[],"call":[" fetch ","Faker Sports Football  player "]}," Faker Football team":{"type":"method","name":"team","children":[],"call":[" fetch ","Faker Sports Football  team "]}," Faker Food vegetables":{"type":"method","name":"vegetables","children":[],"call":[" fetch "]}," Faker Food fruits":{"type":"method","name":"fruits","children":[],"call":[" fetch "]}," Faker Food description":{"type":"method","name":"description","children":[],"call":[" fetch "]}," Faker FamousLastWords last_words":{"type":"method","name":"last_words","children":[],"call":[" fetch ","Faker Quote  famous_last_words "]}," Faker Ethereum address":{"type":"method","name":"address","children":[],"call":["var << "," sample "," shuffle ","hex_alphabet split ","40 times ","Faker Blockchain Ethereum  address "]}," Faker ElectricalComponents electromechanical":{"type":"method","name":"electromechanical","children":[],"call":[" fetch "]}," Faker ElectricalComponents passive":{"type":"method","name":"passive","children":[],"call":[" fetch "]}," Faker ElectricalComponents active":{"type":"method","name":"active","children":[],"call":[" fetch "]}," Faker ElderScrolls last_name":{"type":"method","name":"last_name","children":[],"call":[" fetch ","Faker Games ElderScrolls  last_name "]}," Faker ElderScrolls first_name":{"type":"method","name":"first_name","children":[],"call":[" fetch ","Faker Games ElderScrolls  first_name "]}," Faker ElderScrolls name":{"type":"method","name":"name","children":[],"call":[" fetch ","Faker Games ElderScrolls  name "]}," Faker ElderScrolls city":{"type":"method","name":"city","children":[],"call":[" fetch ","Faker Games ElderScrolls  city "]}," Faker DrWho actor":{"type":"method","name":"actor","children":[],"call":["Faker TvShows DrWho  actor "]}," Faker Dota quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker Games Dota  quote "]}," Faker Dota player":{"type":"method","name":"player","children":[],"call":[" fetch ","Faker Games Dota  player "]}," Faker Dota team":{"type":"method","name":"team","children":[],"call":[" fetch ","Faker Games Dota  team "]}," Faker Dota item":{"type":"method","name":"item","children":[],"call":[" fetch ","Faker Games Dota  item "]}," Faker Dota hero":{"type":"method","name":"hero","children":[],"call":[" fetch ","Faker Games Dota  hero "]}," Faker Device version":{"type":"method","name":"version","children":[],"call":["Faker Number  between "]}," Faker Device serial":{"type":"method","name":"serial","children":[],"call":[" fetch "]}," Faker Device platform":{"type":"method","name":"platform","children":[],"call":[" fetch "]}," Faker Device model_name":{"type":"method","name":"model_name","children":[],"call":[" fetch "]}," Faker Device manufacturer":{"type":"method","name":"manufacturer","children":[],"call":[" fetch "]}," Faker Device build_number":{"type":"method","name":"build_number","children":[],"call":["Faker Number  between "]}," Faker Date birthday_date":{"type":"method","name":"birthday_date","children":[],"call":[" Date  new ","date month ","date day "," Date  leap? ! "," Date  leap? ","date month == ","date day == ","date year - ","date year ","date date day  ","date date day  == ","date date year -  - ","date date year -  "]}," Faker Currency symbol":{"type":"method","name":"symbol","children":[],"call":[" fetch "]}," Faker Currency code":{"type":"method","name":"code","children":[],"call":[" fetch "]}," Faker Currency name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Company weight_sum":{"type":"method","name":"weight_sum","children":[],"call":["array [] * ","weights [] ","array [] ","(irange\n  (int 0)\n  (send\n    (send\n      (lvar :weights) :size) :-\n    (int 1))) each ","weights size - ","weights size "]}," Faker Company collect_regon_sum":{"type":"method","name":"collect_regon_sum","children":[],"call":["sum == "," weight_sum % "," weight_sum ","array size == ","array size "," weight_sum %  == "," weight_ weight_sum %  % "," weight_ weight_sum %  "]}," Faker Company polish_register_of_national_economy":{"type":"method","name":"polish_register_of_national_economy","children":[],"call":["random_digits join "," collect_regon_sum == ","random_digits last "," collect_regon_sum "," rand ","Array  new "," loop "," raise ","(int 9) include? ","keywords << ","legacy_length != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Company polish_taxpayer_identification_number":{"type":"method","name":"polish_taxpayer_identification_number","children":[],"call":["result join ","(send\n  (send nil :weight_sum\n    (lvar :result)\n    (lvar :weights)) :%\n  (int 11)) == ","result [] "," weight_sum % "," weight_sum ","(send\n  (const nil :Array) :new\n  (int 3)) + "," rand ","Array  new "," loop ","(send\n  (const nil :Array) :new\n  (int 3)) +  join ","(send\n  (send nil :weight_sum\n    (lvar :(send\n  (const nil :Array) :new\n  (int 3)) + )\n    (lvar :weights)) :%\n  (int 11)) == ","(send\n  (const nil :Array) :new\n  (int 3)) +  [] "]}," Faker Company czech_organisation_number":{"type":"method","name":"czech_organisation_number","children":[],"call":["base join ","base << ","(send\n  (int 11) :-\n  (begin\n    (send\n      (lvar :sum) :%\n      (int 11)))) % ","11 - ","sum % ","weight * ","base last "," sample ","(irange\n  (int 0)\n  (int 9)) to_a ","(int 8) each "]}," Faker Company type":{"type":"method","name":"type","children":[],"call":[" fetch "]}," Faker Community quotes":{"type":"method","name":"quotes","children":[],"call":[" fetch ","Faker TvShows Community  quotes "]}," Faker Community characters":{"type":"method","name":"characters","children":[],"call":[" fetch ","Faker TvShows Community  characters "]}," Faker Coffee intensifier":{"type":"method","name":"intensifier","children":[],"call":[" fetch "]}," Faker Code generate_sin_check_digit":{"type":"method","name":"generate_sin_check_digit","children":[],"call":["10 - ","checksum zero? ","sum % ","luhn_arr [] [] ","luhn_arr [] ","digits [] to_i ","digits [] ","len > ","len positive? ","sum %  zero? "]}," Faker Code sin":{"type":"method","name":"sin","children":[],"call":["registry + + ","registry + "," generate_sin_check_digit to_s "," generate_sin_check_digit ","(send\n  (const nil :Array) :new\n  (int 7)) join ","Faker Config  random rand ","Faker Config  random ","Array  new ","Faker Base  sample to_s ","Faker Base  sample ","Faker Base  sample to_s  + + ","Faker Base  sample to_s  + "," generate_sin_ generate_sin_check_digit to_s  to_s "," generate_sin_ generate_sin_check_digit to_s  "]}," Faker Cannabis buzzword":{"type":"method","name":"buzzword","children":[],"call":[]}," Faker Cannabis type":{"type":"method","name":"type","children":[],"call":[]}," Faker Cannabis category":{"type":"method","name":"category","children":[],"call":[]}," Faker Cannabis health_benefit":{"type":"method","name":"health_benefit","children":[],"call":[]}," Faker Cannabis medical_use":{"type":"method","name":"medical_use","children":[],"call":[]}," Faker Cannabis terpene":{"type":"method","name":"terpene","children":[],"call":[]}," Faker Cannabis cannabinoid":{"type":"method","name":"cannabinoid","children":[],"call":[]}," Faker Cannabis cannabinoid_abbreviation":{"type":"method","name":"cannabinoid_abbreviation","children":[],"call":[]}," Faker Cannabis strain":{"type":"method","name":"strain","children":[],"call":[]}," Faker BojackHorseman quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","Faker TvShows BojackHorseman  quote "]}," Faker BojackHorseman tongue_twister":{"type":"method","name":"tongue_twister","children":[],"call":[" fetch ","Faker TvShows BojackHorseman  tongue_twister "]}," Faker BojackHorseman character":{"type":"method","name":"character","children":[],"call":[" fetch ","Faker TvShows BojackHorseman  character "]}," Faker Bank rand_numstring":{"type":"method","name":"rand_numstring","children":[],"call":["(irange\n  (int 0)\n  (int 9)) to_a map sample ","(irange\n  (int 0)\n  (int 9)) to_a map ","(irange\n  (int 0)\n  (int 9)) to_a "]}," Faker Bank compile_fraction":{"type":"method","name":"compile_fraction","children":[],"call":["prefix + + + + ","prefix + + + ","prefix + + ","prefix + ","routing_num split [] join to_i to_s ","routing_num split [] join to_i ","routing_num split [] join ","routing_num split [] ","routing_num split ","(irange\n  (int 1)\n  (int 50)) to_a map sample ","(irange\n  (int 1)\n  (int 50)) to_a map ","(irange\n  (int 1)\n  (int 50)) to_a ","routing_num chars [] join to_i to_s ","routing_num chars [] join to_i ","routing_num chars [] join ","routing_num chars [] ","routing_num chars ","(irange\n  (int 1)\n  (int 50)) to_a map sample  + + + + ","(irange\n  (int 1)\n  (int 50)) to_a map sample  + + + ","(irange\n  (int 1)\n  (int 50)) to_a map sample  + + ","(irange\n  (int 1)\n  (int 50)) to_a map sample  + "]}," Faker Bank valid_routing_number":{"type":"method","name":"valid_routing_number","children":[],"call":[" checksum "," compile_routing_number ","routing_number [] + ","checksum to_s ","routing_number [] "," valid_checksum? ","  checksum  "," compile_ compile_routing_number  "," compile_routing_number  [] + "," checksum  to_s "," compile_routing_number  [] "," valid_ checksum ? "]}," Faker Bank iban_checksum":{"type":"method","name":"iban_checksum","children":[],"call":["checksum to_s rjust ","checksum to_s ","(send\n  (int 1) :-\n  (lvar :account_to_number)) % ","1 - ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :account))\n        (begin\n          (lvar :country_code))\n        (str \"00\")) :upcase) :chars) :map) join to_i ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :account))\n        (begin\n          (lvar :country_code))\n        (str \"00\")) :upcase) :chars) :map) join ","(send\n  (send\n    (lvar :d) :ord) :-\n  (int 55)) to_s ","d ord - ","d ord ","d =~ ","(begin\n  (lvar :account)) upcase chars map ","(begin\n  (lvar :account)) upcase chars ","(begin\n  (lvar :account)) upcase ","98 - ","account_to_number % ","(send\n  (int 1) :-\n  (lvar :account_to_number)) %  to_s rjust ","98 -  to_s rjust ","(send\n  (int 1) :-\n  (lvar :account_to_number)) %  to_s ","98 -  to_s ","(send\n  (int 1) :-\n  (lvar :(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :account))\n        (begin\n          (lvar :country_code))\n        (str \"00\")) :upcase) :chars) :map) join to_i )) % ","(send\n  (send\n    (send\n      (dstr\n        (begin\n          (lvar :account))\n        (begin\n          (lvar :country_code))\n        (str \"00\")) :upcase) :chars) :map) join to_i  % "]}," Faker Bank compile_routing_number":{"type":"method","name":"compile_routing_number","children":[],"call":["digit_one_two sample + + + + + + + "," rand_numstring ","digit_one_two sample + + + + + + ","digit_one_two sample + + + + + ","digit_one_two sample + + + + ","digit_one_two sample + + + ","digit_one_two sample + + ","digit_one_two sample + ","digit_one_two sample ","digit_one_two << ","x to_s ","(send\n  (send\n    (send\n      (begin\n        (irange\n          (int 21)\n          (int 32))) :to_a) :+\n    (send\n      (begin\n        (irange\n          (int 61)\n          (int 72))) :to_a)) :+\n  (array\n    (int 80))) each ","(irange\n  (int 21)\n  (int 32)) to_a + + ","(irange\n  (int 21)\n  (int 32)) to_a + ","(irange\n  (int 61)\n  (int 72)) to_a ","(irange\n  (int 21)\n  (int 32)) to_a "]}," Faker Bank checksum":{"type":"method","name":"checksum","children":[],"call":["digit == ","num_array [] ","(send\n  (send\n    (send\n      (int 7) :*\n      (begin\n        (send\n          (send\n            (send\n              (lvar :num_array) :[]\n              (int 0)) :+\n            (send\n              (lvar :num_array) :[]\n              (int 3))) :+\n          (send\n            (lvar :num_array) :[]\n            (int 6))))) :+\n    (send\n      (int 3) :*\n      (begin\n        (send\n          (send\n            (send\n              (lvar :num_array) :[]\n              (int 1)) :+\n            (send\n              (lvar :num_array) :[]\n              (int 4))) :+\n          (send\n            (lvar :num_array) :[]\n            (int 7)))))) :+\n  (send\n    (int 9) :*\n    (begin\n      (send\n        (send\n          (lvar :num_array) :[]\n          (int 2)) :+\n        (send\n          (lvar :num_array) :[]\n          (int 5)))))) % ","7 * + + ","9 * ","num_array [] + ","7 * + ","3 * ","num_array [] + + ","7 * ","num_string split map ","num_string split ","num_string chars map ","num_string chars ","(send\n  (send\n    (send\n      (int 7) :*\n      (begin\n        (send\n          (send\n            (send\n              (lvar :num_array) :[]\n              (int 0)) :+\n            (send\n              (lvar :num_array) :[]\n              (int 3))) :+\n          (send\n            (lvar :num_array) :[]\n            (int 6))))) :+\n    (send\n      (int 3) :*\n      (begin\n        (send\n          (send\n            (send\n              (lvar :num_array) :[]\n              (int 1)) :+\n            (send\n              (lvar :num_array) :[]\n              (int 4))) :+\n          (send\n            (lvar :num_array) :[]\n            (int 7)))))) :+\n  (send\n    (int 9) :*\n    (begin\n      (send\n        (send\n          (lvar :num_array) :[]\n          (int 2)) :+\n        (send\n          (lvar :num_array) :[]\n          (int 5)))))) %  == ","num_string split map  [] ","num_string chars map  [] ","(send\n  (send\n    (send\n      (int 7) :*\n      (begin\n        (send\n          (send\n            (send\n              (lvar :num_string split map ) :[]\n              (int 0)) :+\n            (send\n              (lvar :num_string split map ) :[]\n              (int 3))) :+\n          (send\n            (lvar :num_string split map ) :[]\n            (int 6))))) :+\n    (send\n      (int 3) :*\n      (begin\n        (send\n          (send\n            (send\n              (lvar :num_string split map ) :[]\n              (int 1)) :+\n            (send\n              (lvar :num_string split map ) :[]\n              (int 4))) :+\n          (send\n            (lvar :num_string split map ) :[]\n            (int 7)))))) :+\n  (send\n    (int 9) :*\n    (begin\n      (send\n        (send\n          (lvar :num_string split map ) :[]\n          (int 2)) :+\n        (send\n          (lvar :num_string split map ) :[]\n          (int 5)))))) % ","(send\n  (send\n    (send\n      (int 7) :*\n      (begin\n        (send\n          (send\n            (send\n              (lvar :num_string chars map ) :[]\n              (int 0)) :+\n            (send\n              (lvar :num_string chars map ) :[]\n              (int 3))) :+\n          (send\n            (lvar :num_string chars map ) :[]\n            (int 6))))) :+\n    (send\n      (int 3) :*\n      (begin\n        (send\n          (send\n            (send\n              (lvar :num_string chars map ) :[]\n              (int 1)) :+\n            (send\n              (lvar :num_string chars map ) :[]\n              (int 4))) :+\n          (send\n            (lvar :num_string chars map ) :[]\n            (int 7)))))) :+\n  (send\n    (int 9) :*\n    (begin\n      (send\n        (send\n          (lvar :num_string chars map ) :[]\n          (int 2)) :+\n        (send\n          (lvar :num_string chars map ) :[]\n          (int 5)))))) % ","num_string split map  [] + ","num_string chars map  [] + ","num_string split map  [] + + ","num_string chars map  [] + + "]}," Faker Bank routing_number_with_format":{"type":"method","name":"routing_number_with_format","children":[],"call":[" compile_fraction "," valid_routing_number "]}," Faker Bank routing_number":{"type":"method","name":"routing_number","children":[],"call":[" valid_routing_number "]}," Faker Bank account_number":{"type":"method","name":"account_number","children":[],"call":[" rand to_s [] "," rand to_s "," rand ","output [] ","output length < ","output length ","keywords << ","legacy_digits != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Appliance equipment":{"type":"method","name":"equipment","children":[],"call":[" fetch "]}," Faker Appliance brand":{"type":"method","name":"brand","children":[],"call":[" fetch "]}," Faker UniqueGenerator exclude":{"type":"method","name":"exclude","children":[],"call":["@previous_results [] << ","@previous_results [] ","values each "," previous_results [] << "," previous_results [] "," previous_results "]}," Faker I18nBackend init_translations":{"type":"method","name":"init_translations","children":[],"call":[" load_translations ","Dir  [] "," File  join "," __dir__ "]}," Faker Base58 encode":{"type":"method","name":"encode","children":[],"call":[]}," Faker Base disable_enforce_available_locales":{"type":"method","name":"disable_enforce_available_locales","children":[],"call":["I18n  enforce_available_locales= ","I18n  enforce_available_locales "]}," Faker Base resolve":{"type":"method","name":"resolve","children":[],"call":[" rand "," sample "]}," Faker TvShows VentureBros quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows VentureBros vehicle":{"type":"method","name":"vehicle","children":[],"call":[" fetch "]}," Faker TvShows VentureBros organization":{"type":"method","name":"organization","children":[],"call":[" fetch "]}," Faker TvShows VentureBros character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows TwinPeaks quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows TwinPeaks location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker TvShows TwinPeaks character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows TheThickOfIt position":{"type":"method","name":"position","children":[],"call":[" fetch "]}," Faker TvShows TheThickOfIt department":{"type":"method","name":"department","children":[],"call":[" fetch "]}," Faker TvShows TheThickOfIt character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows TheITCrowd quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows TheITCrowd email":{"type":"method","name":"email","children":[],"call":[" fetch "]}," Faker TvShows TheITCrowd character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows TheITCrowd actor":{"type":"method","name":"actor","children":[],"call":[" fetch "]}," Faker TvShows TheFreshPrinceOfBelAir quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows TheFreshPrinceOfBelAir celebrity":{"type":"method","name":"celebrity","children":[],"call":[" fetch "]}," Faker TvShows TheFreshPrinceOfBelAir character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows TheExpanse ship":{"type":"method","name":"ship","children":[],"call":[" fetch "]}," Faker TvShows TheExpanse location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker TvShows TheExpanse quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows TheExpanse character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows StrangerThings character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows StrangerThings quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows Stargate quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows Stargate planet":{"type":"method","name":"planet","children":[],"call":[" fetch "]}," Faker TvShows Stargate character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows StarTrek villain":{"type":"method","name":"villain","children":[],"call":[" fetch "]}," Faker TvShows StarTrek specie":{"type":"method","name":"specie","children":[],"call":[" fetch "]}," Faker TvShows StarTrek location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker TvShows StarTrek character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows SouthPark quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows SouthPark character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows Simpsons quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows Simpsons location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker TvShows Simpsons character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows SiliconValley email":{"type":"method","name":"email","children":[],"call":[" fetch "]}," Faker TvShows SiliconValley url":{"type":"method","name":"url","children":[],"call":[" fetch "]}," Faker TvShows SiliconValley motto":{"type":"method","name":"motto","children":[],"call":[" fetch "]}," Faker TvShows SiliconValley invention":{"type":"method","name":"invention","children":[],"call":[" fetch "]}," Faker TvShows SiliconValley app":{"type":"method","name":"app","children":[],"call":[" fetch "]}," Faker TvShows SiliconValley quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows SiliconValley company":{"type":"method","name":"company","children":[],"call":[" fetch "]}," Faker TvShows SiliconValley character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows Seinfeld quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows Seinfeld character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows Seinfeld business":{"type":"method","name":"business","children":[],"call":[" fetch "]}," Faker TvShows RuPaul queen":{"type":"method","name":"queen","children":[],"call":[" fetch "]}," Faker TvShows RuPaul quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows RickAndMorty quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows RickAndMorty location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker TvShows RickAndMorty character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows ParksAndRec city":{"type":"method","name":"city","children":[],"call":[" fetch "]}," Faker TvShows ParksAndRec character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows NewGirl quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows NewGirl character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows MichaelScott quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows HowIMetYourMother quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows HowIMetYourMother high_five":{"type":"method","name":"high_five","children":[],"call":[" fetch "]}," Faker TvShows HowIMetYourMother catch_phrase":{"type":"method","name":"catch_phrase","children":[],"call":[" fetch "]}," Faker TvShows HowIMetYourMother character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows HeyArnold quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows HeyArnold location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker TvShows HeyArnold character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows GameOfThrones dragon":{"type":"method","name":"dragon","children":[],"call":[" fetch "]}," Faker TvShows GameOfThrones quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows GameOfThrones city":{"type":"method","name":"city","children":[],"call":[" fetch "]}," Faker TvShows GameOfThrones house":{"type":"method","name":"house","children":[],"call":[" fetch "]}," Faker TvShows GameOfThrones character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows Friends quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows Friends location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker TvShows Friends character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows FamilyGuy quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows FamilyGuy location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker TvShows FamilyGuy character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows DumbAndDumber quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows DumbAndDumber character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows DumbAndDumber actor":{"type":"method","name":"actor","children":[],"call":[" fetch "]}," Faker TvShows DrWho specie":{"type":"method","name":"specie","children":[],"call":[" fetch "]}," Faker TvShows DrWho villian":{"type":"method","name":"villian","children":[],"call":[" fetch "]}," Faker TvShows DrWho quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows DrWho catch_phrase":{"type":"method","name":"catch_phrase","children":[],"call":[" fetch "]}," Faker TvShows DrWho actor":{"type":"method","name":"actor","children":[],"call":[" fetch "]}," Faker TvShows DrWho the_doctor":{"type":"method","name":"the_doctor","children":[],"call":[" fetch "]}," Faker TvShows DrWho character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows Community quotes":{"type":"method","name":"quotes","children":[],"call":[" fetch "]}," Faker TvShows Community characters":{"type":"method","name":"characters","children":[],"call":[" fetch "]}," Faker TvShows Buffy episode":{"type":"method","name":"episode","children":[],"call":[" fetch "]}," Faker TvShows Buffy big_bad":{"type":"method","name":"big_bad","children":[],"call":[" fetch "]}," Faker TvShows Buffy celebrity":{"type":"method","name":"celebrity","children":[],"call":[" fetch "]}," Faker TvShows Buffy quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows Buffy character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows BreakingBad episode":{"type":"method","name":"episode","children":[],"call":[" fetch "]}," Faker TvShows BreakingBad character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows BojackHorseman quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows BojackHorseman tongue_twister":{"type":"method","name":"tongue_twister","children":[],"call":[" fetch "]}," Faker TvShows BojackHorseman character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows AquaTeenHungerForce character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Quotes Shakespeare romeo_and_juliet":{"type":"method","name":"romeo_and_juliet","children":[],"call":[" fetch "]}," Faker Quotes Shakespeare king_richard_iii":{"type":"method","name":"king_richard_iii","children":[],"call":[" fetch "]}," Faker Quotes Shakespeare as_you_like_it":{"type":"method","name":"as_you_like_it","children":[],"call":[" fetch "]}," Faker Quotes Shakespeare hamlet":{"type":"method","name":"hamlet","children":[],"call":[" fetch "]}," Faker Quotes Shakespeare romeo_and_juliet_quote":{"type":"method","name":"romeo_and_juliet_quote","children":[],"call":[" sample "," romeo_and_juliet "]}," Faker Quotes Shakespeare king_richard_iii_quote":{"type":"method","name":"king_richard_iii_quote","children":[],"call":[" sample "," king_richard_iii "]}," Faker Quotes Shakespeare as_you_like_it_quote":{"type":"method","name":"as_you_like_it_quote","children":[],"call":[" sample "," as_you_like_it "]}," Faker Quotes Shakespeare hamlet_quote":{"type":"method","name":"hamlet_quote","children":[],"call":[" sample "," hamlet "]}," Faker Quote yoda":{"type":"method","name":"yoda","children":[],"call":[" fetch "]}," Faker Quote singular_siegler":{"type":"method","name":"singular_siegler","children":[],"call":[" fetch "]}," Faker Quote robin":{"type":"method","name":"robin","children":[],"call":[" fetch "]}," Faker Quote most_interesting_man_in_the_world":{"type":"method","name":"most_interesting_man_in_the_world","children":[],"call":[" fetch "]}," Faker Quote matz":{"type":"method","name":"matz","children":[],"call":[" fetch "]}," Faker Quote famous_last_words":{"type":"method","name":"famous_last_words","children":[],"call":[" fetch "]}," Faker Music UmphreysMcgee song":{"type":"method","name":"song","children":[],"call":[" fetch "]}," Faker Music RockBand name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Music Phish song":{"type":"method","name":"song","children":[],"call":[" fetch "]}," Faker Movies VForVendetta quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies VForVendetta speech":{"type":"method","name":"speech","children":[],"call":[" fetch "]}," Faker Movies VForVendetta character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Movies StarWars wookiee_words":{"type":"method","name":"wookiee_words","children":[],"call":[" fetch_all "]}," Faker Movies StarWars vehicles":{"type":"method","name":"vehicles","children":[],"call":[" fetch_all "]}," Faker Movies StarWars species":{"type":"method","name":"species","children":[],"call":[" fetch_all "]}," Faker Movies StarWars planets":{"type":"method","name":"planets","children":[],"call":[" fetch_all "]}," Faker Movies StarWars droids":{"type":"method","name":"droids","children":[],"call":[" fetch_all "]}," Faker Movies StarWars characters":{"type":"method","name":"characters","children":[],"call":[" fetch_all "]}," Faker Movies StarWars call_squadrons":{"type":"method","name":"call_squadrons","children":[],"call":[" fetch_all "]}," Faker Movies StarWars call_numbers":{"type":"method","name":"call_numbers","children":[],"call":[" fetch_all "]}," Faker Movies StarWars quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","star_wars.quotes. + "," raise ","quoted_characters keys join ","quoted_characters keys ","quoted_characters key? ","character to_sym ","k to_s ","v include? "," translate each "," translate ","character to_s downcase ","character to_s "," sample to_s "," sample ","character nil? ","keywords << ","legacy_character != "," warn_for_deprecated_arguments "," warn_with_uplevel ","quoted_k to_s s keys join ","quoted_character to_s downcase s keys join ","quoted_ sample to_s s keys join "," translate  keys join ","quoted_k to_s s keys ","quoted_character to_s downcase s keys ","quoted_ sample to_s s keys "," translate  keys ","quoted_k to_s s key? ","quoted_character to_s downcase s key? ","quoted_ sample to_s s key? "," translate  key? ","k to_s  to_sym ","character to_s downcase  to_sym "," sample to_s  to_sym ","k to_s  to_s downcase ","character to_s downcase  to_s downcase "," sample to_s  to_s downcase ","k to_s  to_s ","character to_s downcase  to_s "," sample to_s  to_s ","k to_s  nil? ","character to_s downcase  nil? "," sample to_s  nil? ","legacy_k to_s  != ","legacy_character to_s downcase  != ","legacy_ sample to_s  != "]}," Faker Movies StarWars wookiee_sentence":{"type":"method","name":"wookiee_sentence","children":[],"call":["sentence + "," sample ","  + "," wookiee_words "," rand times "," rand "," sample capitalize "," sample capitalize  + "]}," Faker Movies StarWars vehicle":{"type":"method","name":"vehicle","children":[],"call":[" sample "," vehicles "]}," Faker Movies StarWars specie":{"type":"method","name":"specie","children":[],"call":[" sample "," species "]}," Faker Movies StarWars planet":{"type":"method","name":"planet","children":[],"call":[" sample "," planets "]}," Faker Movies StarWars droid":{"type":"method","name":"droid","children":[],"call":[" sample "," droids "]}," Faker Movies StarWars character":{"type":"method","name":"character","children":[],"call":[" sample "," characters "]}," Faker Movies StarWars call_number":{"type":"method","name":"call_number","children":[],"call":[" sample "," call_numbers "]}," Faker Movies StarWars call_sign":{"type":"method","name":"call_sign","children":[],"call":[" numerify "," parse "]}," Faker Movies StarWars call_squadron":{"type":"method","name":"call_squadron","children":[],"call":[" sample "," call_squadrons "]}," Faker Movies PrincessBride quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies PrincessBride character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Movies LordOfTheRings quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies LordOfTheRings location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Movies LordOfTheRings character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Movies Lebowski quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies Lebowski character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Movies Lebowski actor":{"type":"method","name":"actor","children":[],"call":[" fetch "]}," Faker Movies Hobbit location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Movies Hobbit quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies Hobbit thorins_company":{"type":"method","name":"thorins_company","children":[],"call":[" fetch "]}," Faker Movies Hobbit character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Movies HitchhikersGuideToTheGalaxy starship":{"type":"method","name":"starship","children":[],"call":[" fetch "]}," Faker Movies HitchhikersGuideToTheGalaxy specie":{"type":"method","name":"specie","children":[],"call":[" fetch "]}," Faker Movies HitchhikersGuideToTheGalaxy quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies HitchhikersGuideToTheGalaxy planet":{"type":"method","name":"planet","children":[],"call":[" fetch "]}," Faker Movies HitchhikersGuideToTheGalaxy marvin_quote":{"type":"method","name":"marvin_quote","children":[],"call":[" fetch "]}," Faker Movies HitchhikersGuideToTheGalaxy location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Movies HitchhikersGuideToTheGalaxy character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Movies HarryPotter spell":{"type":"method","name":"spell","children":[],"call":[" fetch "]}," Faker Movies HarryPotter house":{"type":"method","name":"house","children":[],"call":[" fetch "]}," Faker Movies HarryPotter book":{"type":"method","name":"book","children":[],"call":[" fetch "]}," Faker Movies HarryPotter quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies HarryPotter location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Movies HarryPotter character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Movies GratefulDead song":{"type":"method","name":"song","children":[],"call":[" fetch ","Faker Music GratefulDead  song "]}," Faker Movies GratefulDead player":{"type":"method","name":"player","children":[],"call":[" fetch ","Faker Music GratefulDead  player "]}," Faker Movies Ghostbusters quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies Ghostbusters character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Movies Ghostbusters actor":{"type":"method","name":"actor","children":[],"call":[" fetch "]}," Faker Movies BackToTheFuture quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies BackToTheFuture date":{"type":"method","name":"date","children":[],"call":[" fetch "]}," Faker Movies BackToTheFuture character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker JapaneseMedia SwordArtOnline item":{"type":"method","name":"item","children":[],"call":[" fetch "]}," Faker JapaneseMedia SwordArtOnline location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker JapaneseMedia SwordArtOnline game_name":{"type":"method","name":"game_name","children":[],"call":[" fetch "]}," Faker JapaneseMedia SwordArtOnline real_name":{"type":"method","name":"real_name","children":[],"call":[" fetch "]}," Faker JapaneseMedia OnePiece akuma_no_mi":{"type":"method","name":"akuma_no_mi","children":[],"call":[" fetch "]}," Faker JapaneseMedia OnePiece quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker JapaneseMedia OnePiece location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker JapaneseMedia OnePiece island":{"type":"method","name":"island","children":[],"call":[" fetch "]}," Faker JapaneseMedia OnePiece sea":{"type":"method","name":"sea","children":[],"call":[" fetch "]}," Faker JapaneseMedia OnePiece character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker JapaneseMedia DragonBall character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games Zelda item":{"type":"method","name":"item","children":[],"call":[" fetch "]}," Faker Games Zelda location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games Zelda character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games Zelda game":{"type":"method","name":"game","children":[],"call":[" fetch "]}," Faker Games WorldOfWarcraft quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Games WorldOfWarcraft hero":{"type":"method","name":"hero","children":[],"call":[" fetch "]}," Faker Games Witcher monster":{"type":"method","name":"monster","children":[],"call":[" fetch "]}," Faker Games Witcher quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Games Witcher location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games Witcher school":{"type":"method","name":"school","children":[],"call":[" fetch "]}," Faker Games Witcher witcher":{"type":"method","name":"witcher","children":[],"call":[" fetch "]}," Faker Games Witcher character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games SuperSmashBros stage":{"type":"method","name":"stage","children":[],"call":[" fetch "]}," Faker Games SuperSmashBros fighter":{"type":"method","name":"fighter","children":[],"call":[" fetch "]}," Faker Games SonicTheHedgehog game":{"type":"method","name":"game","children":[],"call":[" fetch "]}," Faker Games SonicTheHedgehog zone":{"type":"method","name":"zone","children":[],"call":[" fetch "]}," Faker Games SonicTheHedgehog character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games Pokemon move":{"type":"method","name":"move","children":[],"call":[" fetch "]}," Faker Games Pokemon location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games Pokemon name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Games Overwatch quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Games Overwatch location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games Overwatch hero":{"type":"method","name":"hero","children":[],"call":[" fetch "]}," Faker Games Myst quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Games Myst character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games Myst age":{"type":"method","name":"age","children":[],"call":[" fetch "]}," Faker Games Myst creature":{"type":"method","name":"creature","children":[],"call":[" fetch "]}," Faker Games Myst game":{"type":"method","name":"game","children":[],"call":[" fetch "]}," Faker Games LeagueOfLegends rank":{"type":"method","name":"rank","children":[],"call":[" fetch "]}," Faker Games LeagueOfLegends masteries":{"type":"method","name":"masteries","children":[],"call":[" fetch "]}," Faker Games LeagueOfLegends summoner_spell":{"type":"method","name":"summoner_spell","children":[],"call":[" fetch "]}," Faker Games LeagueOfLegends quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Games LeagueOfLegends location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games LeagueOfLegends champion":{"type":"method","name":"champion","children":[],"call":[" fetch "]}," Faker Games HeroesOfTheStorm quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Games HeroesOfTheStorm hero":{"type":"method","name":"hero","children":[],"call":[" fetch "]}," Faker Games HeroesOfTheStorm class":{"type":"method","name":"class","children":[],"call":[" fetch "," warn "]}," Faker Games HeroesOfTheStorm battleground":{"type":"method","name":"battleground","children":[],"call":[" fetch "]}," Faker Games Heroes klass":{"type":"method","name":"klass","children":[],"call":[" fetch "]}," Faker Games Heroes specialty":{"type":"method","name":"specialty","children":[],"call":[" fetch "]}," Faker Games Heroes name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Games HalfLife location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games HalfLife enemy":{"type":"method","name":"enemy","children":[],"call":[" fetch "]}," Faker Games HalfLife character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games Fallout quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Games Fallout location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games Fallout faction":{"type":"method","name":"faction","children":[],"call":[" fetch "]}," Faker Games Fallout character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games ElderScrolls last_name":{"type":"method","name":"last_name","children":[],"call":[" fetch "]}," Faker Games ElderScrolls first_name":{"type":"method","name":"first_name","children":[],"call":[" fetch "]}," Faker Games ElderScrolls name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Games ElderScrolls dragon":{"type":"method","name":"dragon","children":[],"call":[" fetch "]}," Faker Games ElderScrolls region":{"type":"method","name":"region","children":[],"call":[" fetch "]}," Faker Games ElderScrolls creature":{"type":"method","name":"creature","children":[],"call":[" fetch "]}," Faker Games ElderScrolls city":{"type":"method","name":"city","children":[],"call":[" fetch "]}," Faker Games ElderScrolls race":{"type":"method","name":"race","children":[],"call":[" fetch "]}," Faker Games Dota quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","keywords << ","legacy_hero != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Games Dota player":{"type":"method","name":"player","children":[],"call":[" fetch "]}," Faker Games Dota team":{"type":"method","name":"team","children":[],"call":[" fetch "]}," Faker Games Dota item":{"type":"method","name":"item","children":[],"call":[" fetch "]}," Faker Games Dota hero":{"type":"method","name":"hero","children":[],"call":[" fetch "]}," Faker Tezos signature":{"type":"method","name":"signature","children":[],"call":["Faker Blockchain Tezos  signature "]}," Faker Tezos operation":{"type":"method","name":"operation","children":[],"call":["Faker Blockchain Tezos  operation "]}," Faker Tezos contract":{"type":"method","name":"contract","children":[],"call":["Faker Blockchain Tezos  contract "]}," Faker Tezos account":{"type":"method","name":"account","children":[],"call":["Faker Blockchain Tezos  account "]}," Faker SouthPark quote":{"type":"method","name":"quote","children":[],"call":["Faker TvShows SouthPark  quote "]}," Faker SouthPark character":{"type":"method","name":"character","children":[],"call":["Faker TvShows SouthPark  character "]}," Faker Seinfeld business":{"type":"method","name":"business","children":[],"call":["Faker TvShows Seinfeld  business "]}," Faker HeroesOfTheStorm quote":{"type":"method","name":"quote","children":[],"call":["Faker Games HeroesOfTheStorm  quote "]}," Faker HeroesOfTheStorm hero":{"type":"method","name":"hero","children":[],"call":["Faker Games HeroesOfTheStorm  hero "]}," Faker HeroesOfTheStorm class":{"type":"method","name":"class","children":[],"call":["Faker Games HeroesOfTheStorm  class "]}," Faker HeroesOfTheStorm battleground":{"type":"method","name":"battleground","children":[],"call":["Faker Games HeroesOfTheStorm  battleground "]}," Faker Buffy episode":{"type":"method","name":"episode","children":[],"call":["Faker TvShows Buffy  episode "]}," Faker Buffy big_bad":{"type":"method","name":"big_bad","children":[],"call":["Faker TvShows Buffy  big_bad "]}," Faker Buffy celebrity":{"type":"method","name":"celebrity","children":[],"call":["Faker TvShows Buffy  celebrity "]}," Faker Buffy quote":{"type":"method","name":"quote","children":[],"call":["Faker TvShows Buffy  quote "]}," Faker Buffy character":{"type":"method","name":"character","children":[],"call":["Faker TvShows Buffy  character "]}," Faker Vehicle singapore_checksum":{"type":"method","name":"singapore_checksum","children":[],"call":["SG_CHECKSUM_CHARS  split [] ","sum % ","SG_CHECKSUM_CHARS  split ","memo + ","SG_CHECKSUM_WEIGHTS  [] * ","SG_CHECKSUM_WEIGHTS  [] ","char ord - ","char ord ","char is_a? ","(splat\n  (lvar :padded_alphabets)) each_with_index reduce ","(splat\n  (lvar :padded_alphabets)) each_with_index "," format split map "," format split "," format ","plate_number [] "," format tr split "," format tr ","SG_CHECKSUM_CHARS  chars [] ","SG_CHECKSUM_CHARS  chars "," format chars map "," format chars "," format tr chars ","(splat\n  (lvar : format tr split )) each_with_index reduce ","(splat\n  (lvar : format tr chars )) each_with_index reduce ","(splat\n  (lvar : format tr split )) each_with_index ","(splat\n  (lvar : format tr chars )) each_with_index "]}," Faker Vehicle vin_char_to_number":{"type":"method","name":"vin_char_to_number","children":[],"call":["VIN_MAP  [] ","char to_i ","index nil? ","VIN_LETTERS  split index ","VIN_LETTERS  split ","VIN_LETTERS  chars index ","VIN_LETTERS  chars ","VIN_LETTERS  split index  nil? ","VIN_LETTERS  chars index  nil? ","VIN_LETTERS  split VIN_LETTERS  split index  ","VIN_LETTERS  split VIN_LETTERS  chars index  ","VIN_LETTERS  chars VIN_LETTERS  split index  ","VIN_LETTERS  chars VIN_LETTERS  chars index  "]}," Faker Vehicle calculate_vin_check_digit":{"type":"method","name":"calculate_vin_check_digit","children":[],"call":["mod == ","sum % ","weight * ","VIN_WEIGHTS  [] to_i ","VIN_WEIGHTS  [] "," vin_char_to_number to_i "," vin_char_to_number ","vin each_char with_index ","vin each_char ","sum %  == ","VIN_WEIGHTS  [] to_i  * "," vi vin_char_to_number to_i _char_to_ vin_char_to_number to_i umber to_i "," vi vin_char_to_number to_i _char_to_ vin_char_to_number to_i umber ","vi vin_char_to_number to_i  each_char with_i vin_char_to_number to_i dex ","vi vin_char_to_number to_i  each_char "]}," Faker Vehicle first_eight":{"type":"method","name":"first_eight","children":[],"call":[" regexify ","number [] ","number nil? "]}," Faker Vehicle singapore_license_plate":{"type":"method","name":"singapore_license_plate","children":[],"call":[" singapore_checksum "," regexify "," bothify "," fetch "]}," Faker Vehicle license_plate":{"type":"method","name":"license_plate","children":[],"call":[" regexify "," bothify "," fetch ","vehicle.license_plate_by_state. + ","state_abreviation empty? ","keywords << ","legacy_state_abreviation != "," warn_for_deprecated_arguments ","state_abbreviation empty? "," warn_with_uplevel ","vehicle.license_plate_by_state. + words << "]}," Faker Vehicle doors":{"type":"method","name":"doors","children":[],"call":[" sample "," fetch_all "]}," Faker Subscription payment_term":{"type":"method","name":"payment_term","children":[],"call":[]}," Faker Subscription subscription_term":{"type":"method","name":"subscription_term","children":[],"call":[]}," Faker Subscription payment_method":{"type":"method","name":"payment_method","children":[],"call":[]}," Faker Subscription status":{"type":"method","name":"status","children":[],"call":[]}," Faker Subscription plan":{"type":"method","name":"plan","children":[],"call":[]}," Faker SouthAfrica vat_number":{"type":"method","name":"vat_number","children":[],"call":["Faker Finance  vat_number "]}," Faker SouthAfrica trust_registration_number":{"type":"method","name":"trust_registration_number","children":[],"call":["Faker Company  south_african_trust_registration_number "]}," Faker SouthAfrica listed_company_registration_number":{"type":"method","name":"listed_company_registration_number","children":[],"call":["Faker Company  south_african_listed_company_registration_number "]}," Faker SouthAfrica close_corporation_registration_number":{"type":"method","name":"close_corporation_registration_number","children":[],"call":["Faker Company  south_african_close_corporation_registration_number "]}," Faker SouthAfrica pty_ltd_registration_number":{"type":"method","name":"pty_ltd_registration_number","children":[],"call":["Faker Company  south_african_pty_ltd_registration_number "]}," Faker SouthAfrica cell_phone":{"type":"method","name":"cell_phone","children":[],"call":["Faker PhoneNumber  cell_phone "," with_locale "]}," Faker SouthAfrica phone_number":{"type":"method","name":"phone_number","children":[],"call":["Faker PhoneNumber  phone_number "," with_locale "]}," Faker SouthAfrica invalid_id_number":{"type":"method","name":"invalid_id_number","children":[],"call":["Faker IDNumber  invalid_south_african_id_number "]}," Faker SouthAfrica valid_id_number":{"type":"method","name":"valid_id_number","children":[],"call":["Faker IDNumber  valid_south_african_id_number "]}," Faker SouthAfrica id_number":{"type":"method","name":"id_number","children":[],"call":["Faker IDNumber  south_african_id_number "]}," Faker Restaurant name":{"type":"method","name":"name","children":[],"call":[" bothify "," parse "]}," Faker Relationship sibling":{"type":"method","name":"sibling","children":[],"call":[" fetch "]}," Faker Relationship parent":{"type":"method","name":"parent","children":[],"call":[" fetch "]}," Faker Relationship spouse":{"type":"method","name":"spouse","children":[],"call":[" fetch "]}," Faker Relationship in_law":{"type":"method","name":"in_law","children":[],"call":[" fetch "]}," Faker Relationship familial":{"type":"method","name":"familial","children":[],"call":[" fetch ","relationship.familial. + "," raise ","familial_connections join ","familial_connections include? ","connection to_sym ","connection to_s downcase ","connection to_s "," sample to_s "," sample ","connection nil? "," translate keys "," translate ","keywords << ","legacy_connection != "," warn_for_deprecated_arguments "," warn_with_uplevel ","familial_connection to_s downcase s join ","familial_ sample to_s s join "," translate keys  join ","familial_connection to_s downcase s include? ","familial_ sample to_s s include? "," translate keys  include? ","connection to_s downcase  to_sym "," sample to_s  to_sym ","connection to_s downcase  to_s downcase "," sample to_s  to_s downcase ","connection to_s downcase  to_s "," sample to_s  to_s ","connection to_s downcase  nil? "," sample to_s  nil? ","legacy_connection to_s downcase  != ","legacy_ sample to_s  != "]}," Faker PhoneNumber cell_phone_with_country_code":{"type":"method","name":"cell_phone_with_country_code","children":[],"call":[" cell_phone "," country_code "]}," Faker PhoneNumber phone_number_with_country_code":{"type":"method","name":"phone_number_with_country_code","children":[],"call":[" phone_number "," country_code "]}," Faker PhoneNumber country_code":{"type":"method","name":"country_code","children":[],"call":[" fetch "]}," Faker Number within":{"type":"method","name":"within","children":[],"call":[" between ","range max ","range min ","keywords << ","legacy_range != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker NationalHealthService check_digit":{"type":"method","name":"check_digit","children":[],"call":["result == ","11 - ","sum % ","digit to_i * ","digit to_i ","idx + ","number to_s chars each_with_index ","number to_s chars ","number to_s ","keywords << ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel ","11 -  == "]}," Faker NationalHealthService british_number":{"type":"method","name":"british_number","children":[],"call":["(begin\n  (lvar :base_number)) to_s chars insert insert join ","(begin\n  (lvar :base_number)) to_s chars insert insert ","(begin\n  (lvar :base_number)) to_s chars insert ","(begin\n  (lvar :base_number)) to_s chars ","(begin\n  (lvar :base_number)) to_s "," check_digit "," check_digit == "," rand ","(begin\n  (lvar : rand )) to_s chars insert insert join ","(begin\n  (lvar : rand )) to_s chars insert insert ","(begin\n  (lvar : rand )) to_s chars insert ","(begin\n  (lvar : rand )) to_s chars ","(begin\n  (lvar : rand )) to_s "]}," Faker Nation flag":{"type":"method","name":"flag","children":[],"call":[" sample pack force_encoding "," sample pack "," sample "," translate "]}," Faker Marketing buzzwords":{"type":"method","name":"buzzwords","children":[],"call":[" fetch "]}," Faker Json build_keys_from_array":{"type":"method","name":"build_keys_from_array","children":[],"call":["key_string << ","key_array each "]}," Faker Json add_hash":{"type":"method","name":"add_hash","children":[],"call":[" eval ","string_to_eval << "," build_shallow_hash ","key_array [] ","key_array length times ","key_array length "]}," Faker Json add_hash_to_bottom":{"type":"method","name":"add_hash_to_bottom","children":[],"call":["key_array pop "," add_hash "," add_hash_to_bottom ","key_array << "," eval each "," eval "," eval is_a? "," build_keys_from_array "]}," Faker Json build_shallow_hash":{"type":"method","name":"build_shallow_hash","children":[],"call":["hash []= "," eval ","width times ","options [] "]}," Faker Json add_depth_to_json":{"type":"method","name":"add_depth_to_json","children":[],"call":["JSON  generate "," add_hash_to_bottom ","hash each ","JSON  parse ","options []= ","options [] prepend ","options [] ","Faker:: + ","keywords << ","legacy_options != "," warn_for_deprecated_arguments ","legacy_width != ","legacy_json != "," warn_with_uplevel "," add_JSON  parse _to_bottom ","JSON  parse  each "]}," Faker Json shallow_json":{"type":"method","name":"shallow_json","children":[],"call":["JSON  generate "," build_shallow_hash ","options []= ","options [] prepend ","options [] ","Faker:: + ","keywords << ","legacy_options != ","legacy_width != "," warn_for_deprecated_arguments "," warn_with_uplevel "," build_shallow_ build_shallow_hash  "]}," Faker IndustrySegments sub_sector":{"type":"method","name":"sub_sector","children":[],"call":[" fetch "]}," Faker IndustrySegments sector":{"type":"method","name":"sector","children":[],"call":[" fetch "]}," Faker IndustrySegments super_sector":{"type":"method","name":"super_sector","children":[],"call":[" fetch "]}," Faker IndustrySegments industry":{"type":"method","name":"industry","children":[],"call":[" fetch "]}," Faker IDNumber brazilian_citizen_number_checksum_digit":{"type":"method","name":"brazilian_citizen_number_checksum_digit","children":[],"call":["remainder to_s ","remainder == ","digit_sum % ","(send\n  (send\n    (send\n      (lvar :digits) :chars) :each_with_index) :inject\n  (int 0)) * ","acc + ","digit to_i * ","digits size + - ","digits size + ","digits size ","digit to_i ","digits chars each_with_index inject ","digits chars each_with_index ","digits chars "," brazilian_document_digit "," brazilian_document_checksum ","digit_sum %  to_s ","digit_sum %  == ","(send\n  (send\n    (send\n      (lvar :digits) :chars) :each_with_index) :inject\n  (int 0)) *  % "," brazilian_document_ brazilian_document_checksum  "]}," Faker IDNumber south_african_id_checksum_digit":{"type":"method","name":"south_african_id_checksum_digit","children":[],"call":["(send\n  (begin\n    (send\n      (int 10) :-\n      (begin\n        (send\n          (lvar :total_sum) :%\n          (int 10))))) :%\n  (int 10)) to_s ","(send\n  (int 10) :-\n  (begin\n    (send\n      (lvar :total_sum) :%\n      (int 10)))) % ","10 - ","total_sum % ","sum_of_odd_digits + ","even_digits_times_two chars map reduce ","even_digits_times_two chars map ","even_digits_times_two chars ","(send\n  (send\n    (send\n      (lvar :even_digits) :join\n      (str \"\")) :to_i) :*\n  (int 2)) to_s ","even_digits join to_i * ","even_digits join to_i ","even_digits join ","odd_digits_without_last_character map reduce ","odd_digits_without_last_character map ","(send\n  (lvar :i) :+\n  (int 1)) odd? ","i + ","value_parts [] select with_index ","value_parts [] select ","value_parts [] ","(send\n  (lvar :i) :+\n  (int 1)) even? ","value_parts select with_index ","value_parts select ","id_number chars ","(send\n  (send\n    (send\n      (lvar :even_digits) :join) :to_i) :*\n  (int 2)) to_s ","(send\n  (begin\n    (send\n      (int 10) :-\n      (begin\n        (send\n          (lvar :sum_of_odd_digits + ) :%\n          (int 10))))) :%\n  (int 10)) to_s ","(send\n  (int 10) :-\n  (begin\n    (send\n      (lvar :sum_of_odd_digits + ) :%\n      (int 10)))) % ","sum_of_odd_digits +  % ","odd_digits_without_last_character map reduce  + ","(send\n  (send\n    (send\n      (lvar :even_digits) :join\n      (str \"\")) :to_i) :*\n  (int 2)) to_s  chars map reduce ","(send\n  (send\n    (send\n      (lvar :even_digits) :join) :to_i) :*\n  (int 2)) to_s  chars map reduce ","(send\n  (send\n    (send\n      (lvar :even_digits) :join\n      (str \"\")) :to_i) :*\n  (int 2)) to_s  chars map ","(send\n  (send\n    (send\n      (lvar :even_digits) :join) :to_i) :*\n  (int 2)) to_s  chars map ","(send\n  (send\n    (send\n      (lvar :even_digits) :join\n      (str \"\")) :to_i) :*\n  (int 2)) to_s  chars ","(send\n  (send\n    (send\n      (lvar :even_digits) :join) :to_i) :*\n  (int 2)) to_s  chars ","id_number chars  [] select with_index ","id_number chars  [] select ","id_number chars  [] ","id_number chars  select with_index ","id_number chars  select "]}," Faker IDNumber brazilian_citizen_number":{"type":"method","name":"brazilian_citizen_number","children":[],"call":[" format ","number scan flatten ","number scan ","(lvar :digits) join "," brazilian_citizen_number_checksum_digit ","digits + ","Faker Number  leading_zero_number ","keywords << ","legacy_formatted != "," warn_for_deprecated_arguments "," warn_with_uplevel ","(lvar :digits) join  scan flatten ","(lvar :digits) join  scan ","(lvar :Faker Number  leading_zero_number ) join "," brazilian_citizen_(lvar :digits) join _checksum_digit ","Faker Number  leading_zero_number  + ","Faker Number  leading_zero_(lvar :digits) join  "]}," Faker IDNumber invalid_south_african_id_number":{"type":"method","name":"invalid_south_african_id_number","children":[],"call":["(lvar :id_number) join "," south_african_id_checksum_digit ","(lvar :invalid_date_of_birth) join ","ZA_CITIZENSHIP_DIGITS  sample ","Faker Config  random ","Faker Number  number ","(send\n  (const\n    (const nil :Faker) :Number) :number\n  (int 2)) map join ","(send\n  (const\n    (const nil :Faker) :Number) :number\n  (int 2)) map ","Faker Number  between ","(send\n  (const\n    (const nil :Faker) :Number) :number\n  (hash\n    (pair\n      (sym :digits)\n      (int 2)))) map join ","(send\n  (const\n    (const nil :Faker) :Number) :number\n  (hash\n    (pair\n      (sym :digits)\n      (int 2)))) map ","(lvar :(lvar :invalid_date_of_birth) join ) join ","(lvar :(send\n  (const\n    (const nil :Faker) :Number) :number\n  (int 2)) map join ) join ","(lvar :(send\n  (const\n    (const nil :Faker) :Number) :number\n  (hash\n    (pair\n      (sym :digits)\n      (int 2)))) map join ) join "]}," Faker IDNumber valid_south_african_id_number":{"type":"method","name":"valid_south_african_id_number","children":[],"call":["(lvar :id_number) join "," south_african_id_checksum_digit ","(send\n  (send\n    (const\n      (const nil :Faker) :Date) :birthday) :strftime\n  (str \"%y%m%d\")) join ","ZA_CITIZENSHIP_DIGITS  sample ","Faker Config  random ","Faker Number  number ","Faker Date  birthday strftime ","Faker Date  birthday ","(lvar :(send\n  (send\n    (const\n      (const nil :Faker) :Date) :birthday) :strftime\n  (str \"%y%m%d\")) join ) join "]}," Faker House room":{"type":"method","name":"room","children":[],"call":[" fetch "]}," Faker House furniture":{"type":"method","name":"furniture","children":[],"call":[" fetch "]}," Faker Football position":{"type":"method","name":"position","children":[],"call":[" fetch ","Faker Sports Football  position "]}," Faker Finance vat_number_keys":{"type":"method","name":"vat_number_keys","children":[],"call":[" translate keys "," translate "]}," Faker Finance vat_number":{"type":"method","name":"vat_number","children":[],"call":[" raise "," numerify "," fetch ","keywords << ","legacy_country != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Educator course_name":{"type":"method","name":"course_name","children":[],"call":[" numerify "," fetch "," parse "]}," Faker Educator subject":{"type":"method","name":"subject","children":[],"call":[" fetch "]}," Faker Educator degree":{"type":"method","name":"degree","children":[],"call":[" fetch "," parse "]}," Faker DrivingLicence gb_licence_checksum":{"type":"method","name":"gb_licence_checksum","children":[],"call":[" regexify ","g letter ","g int "," generate "]}," Faker DrivingLicence gb_licence_year":{"type":"method","name":"gb_licence_year","children":[],"call":["%02d % ","dob day ","dob month ","dob month + ","gender == ","dob year % ","dob year ","(send\n  (send\n    (lvar :dob) :year) :/\n  (int 10)) % ","dob year / ","g computed "," format "," generate ","dob dob month  ","dob dob month +  ","dob dob month  + ","dob dob month +  + ","dob dob year %  % ","dob dob year %  ","(send\n  (send\n    (lvar :dob) :dob year % ) :/\n  (int 10)) % ","dob dob year %  / "]}," Faker DrivingLicence gb_licence_padding":{"type":"method","name":"gb_licence_padding","children":[],"call":["prepped [] ","num_chars - ","str upcase gsub + ","str upcase gsub ","str upcase ","str upcase gsub +  [] "]}," Faker DrivingLicence random_gender":{"type":"method","name":"random_gender","children":[],"call":["(sym :male) sample ","Faker Config  random "]}," Faker DrivingLicence uk_driving_licence":{"type":"method","name":"uk_driving_licence","children":[],"call":[" british_driving_licence "," northern_irish_driving_licence ","Faker Config  random rand < ","Faker Config  random rand ","Faker Config  random "]}," Faker DrivingLicence northern_irish_driving_licence":{"type":"method","name":"northern_irish_driving_licence","children":[],"call":["Faker Number  number ","Faker Number  number to_s "]}," Faker DrivingLicence british_driving_licence":{"type":"method","name":"british_driving_licence","children":[],"call":["(send nil :gb_licence_padding\n  (lvar :last_name)\n  (int 5)) join "," gb_licence_checksum "," gb_licence_padding "," gb_licence_year ","keywords << ","legacy_date_of_birth != ","legacy_gender != ","legacy_initials != ","legacy_last_name != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker DcComics title":{"type":"method","name":"title","children":[],"call":[]}," Faker DcComics name":{"type":"method","name":"name","children":[],"call":[]}," Faker DcComics villain":{"type":"method","name":"villain","children":[],"call":[]}," Faker DcComics heroine":{"type":"method","name":"heroine","children":[],"call":[]}," Faker DcComics hero":{"type":"method","name":"hero","children":[],"call":[]}," Faker CryptoCoin coin_hash":{"type":"method","name":"coin_hash","children":[],"call":[" url_logo "," acronym "," coin_name "," coin_array ","  coin_array _name ","  coin_array _array "]}," Faker CryptoCoin coin_array":{"type":"method","name":"coin_array","children":[],"call":[" fetch split map "," fetch split "," fetch "]}," Faker CryptoCoin url_logo":{"type":"method","name":"url_logo","children":[],"call":["coin [] ","keywords << ","legacy_coin != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker CryptoCoin acronym":{"type":"method","name":"acronym","children":[],"call":["coin [] ","keywords << ","legacy_coin != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker CryptoCoin coin_name":{"type":"method","name":"coin_name","children":[],"call":["coin [] ","keywords << ","legacy_coin != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Cosmere spren":{"type":"method","name":"spren","children":[],"call":[" sample "," sprens "]}," Faker Cosmere herald":{"type":"method","name":"herald","children":[],"call":[" sample "," heralds "]}," Faker Cosmere feruchemist":{"type":"method","name":"feruchemist","children":[],"call":[" sample "," feruchemists "]}," Faker Cosmere allomancer":{"type":"method","name":"allomancer","children":[],"call":[" sample "," allomancers "]}," Faker Cosmere metal":{"type":"method","name":"metal","children":[],"call":[" sample "," metals "]}," Faker Cosmere knight_radiant":{"type":"method","name":"knight_radiant","children":[],"call":[" sample "," knights_radiant "]}," Faker Cosmere surge":{"type":"method","name":"surge","children":[],"call":[" sample "," surges "]}," Faker Cosmere shard":{"type":"method","name":"shard","children":[],"call":[" sample "," shards "]}," Faker Cosmere shard_world":{"type":"method","name":"shard_world","children":[],"call":[" sample "," shard_worlds "]}," Faker Cosmere aon":{"type":"method","name":"aon","children":[],"call":[" sample "," aons "]}," Faker Construction role":{"type":"method","name":"role","children":[],"call":[]}," Faker Construction standard_cost_code":{"type":"method","name":"standard_cost_code","children":[],"call":[]}," Faker Construction subcontract_category":{"type":"method","name":"subcontract_category","children":[],"call":[]}," Faker Construction trade":{"type":"method","name":"trade","children":[],"call":[]}," Faker Construction heavy_equipment":{"type":"method","name":"heavy_equipment","children":[],"call":[]}," Faker Construction material":{"type":"method","name":"material","children":[],"call":[]}," Faker Company brazilian_company_number":{"type":"method","name":"brazilian_company_number","children":[],"call":[" format ","number scan flatten ","number scan ","digits join ","digits << ","11 - ","checksum < ","(send\n  (lvar :digits) :inject\n  (int 0)) % ","acc + ","digit * ","factors next ","digits inject ","2 times ","(int 5) cycle ","(send\n  (const nil :Array) :new\n  (int 8)) + ","Faker Number  non_zero_digit to_i ","Faker Number  non_zero_digit ","Faker Number  digit to_i ","Faker Number  digit ","Array  new ","keywords << ","legacy_formatted != "," warn_for_deprecated_arguments "," warn_with_uplevel ","digits join  scan flatten ","digits join  scan ","(send\n  (const nil :Array) :new\n  (int 8)) +  join ","(send\n  (const nil :Array) :new\n  (int 8)) +  << ","(send\n  (lvar :digits) :inject\n  (int 0)) %  < ","(send\n  (lvar :(send\n  (const nil :Array) :new\n  (int 8)) + ) :inject\n  (int 0)) % ","(int 5) cycle  next ","(send\n  (const nil :Array) :new\n  (int 8)) +  inject "]}," Faker Company south_african_trust_registration_number":{"type":"method","name":"south_african_trust_registration_number","children":[],"call":[" regexify ","g int ","g lit "," generate "]}," Faker Company south_african_listed_company_registration_number":{"type":"method","name":"south_african_listed_company_registration_number","children":[],"call":[" regexify ","g lit ","g int "," generate "]}," Faker Company south_african_close_corporation_registration_number":{"type":"method","name":"south_african_close_corporation_registration_number","children":[],"call":[" regexify ","g lit ","g int ","one int ","g_ int ","g_ lit ","one group ","g oneof "," generate "]}," Faker Company south_african_pty_ltd_registration_number":{"type":"method","name":"south_african_pty_ltd_registration_number","children":[],"call":[" regexify ","g lit ","g int "," generate "]}," Faker Coin flip":{"type":"method","name":"flip","children":[],"call":[" fetch "]}," Faker Coin name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker ChileRut full_rut":{"type":"method","name":"full_rut","children":[],"call":[" dv "," rut ","keywords << ","legacy_fixed != ","legacy_min_rut != "," warn_for_deprecated_arguments "," warn_with_uplevel "," rut to_s reverse gsub reverse "," rut to_s reverse gsub "," rut to_s reverse "," rut to_s "," format_rut "]}," Faker ChileRut check_digit":{"type":"method","name":"check_digit","children":[],"call":[" dv "]}," Faker ChileRut dv":{"type":"method","name":"dv","children":[],"call":["partial_check_digit to_s ","partial_check_digit == ","11 - ","digit_sum % ","i + ","i == ","sum to_i + ","n to_i * ","seq [] ","n to_i ","sum to_i ","split_reversed_rut reduce ","@last_rut to_s reverse split ","@last_rut to_s reverse ","@last_rut to_s ","@last_rut to_s reverse chars ","11 -  to_s ","parti + al_check_di + gi + t to_s ","11 -  == ","parti + al_check_di + gi + t == ","di + gi + t_sum % ","i +  + ","i +  == ","sum to_i +  + ","n to_i +  * ","n to_i +  ","sum to_i +  ","spli + t_reversed_rut reduce ","@last_rut to_s reverse split  reduce ","@last_rut to_s reverse chars  reduce ","@last_rut to_s reverse spli + t "]}," Faker ChileRut rut":{"type":"method","name":"rut","children":[],"call":[" rand_in_range ","keywords << ","legacy_fixed != ","legacy_min_rut != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Alphanumeric alphanumeric":{"type":"method","name":"alphanumeric","children":[],"call":["(send\n  (const nil :Array) :new\n  (lvar :char_count)) join "," sample ","Array  new ","char_count to_i < ","char_count to_i "," resolve ","combined shuffle join ","combined shuffle ","alphas + + ","alphas + ","char_count - - ","char_count - "," raise ","min_alpha + > ","min_alpha + ","min_numeric zero? ","min_alpha zero? ","keywords << ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel ","(send\n  (const nil :Array) :new\n  (lvar : resolve )) join "," resolve  to_i < "," resolve  to_i ","alphas + +  shuffle join ","alphas + +  shuffle "," resolve  - - "," resolve  - "]}," Faker Alphanumeric alpha":{"type":"method","name":"alpha","children":[],"call":["(send\n  (const nil :Array) :new\n  (lvar :char_count)) join "," sample ","Array  new ","char_count to_i < ","char_count to_i "," resolve ","keywords << ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel ","(send\n  (const nil :Array) :new\n  (lvar : resolve )) join "," resolve  to_i < "," resolve  to_i "]}," Faker Address country_name_to_code":{"type":"method","name":"country_name_to_code","children":[],"call":[" fetch ","address.country_by_name. + ","keywords << ","legacy_name != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Address country_by_code":{"type":"method","name":"country_by_code","children":[],"call":[" fetch ","address.country_by_code. + ","keywords << ","legacy_code != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Creature Dog size":{"type":"method","name":"size","children":[],"call":[" fetch "]}," Faker Creature Dog coat_length":{"type":"method","name":"coat_length","children":[],"call":[" fetch "]}," Faker Creature Dog gender":{"type":"method","name":"gender","children":[],"call":["Faker Gender  binary_type "]}," Faker Creature Dog age":{"type":"method","name":"age","children":[],"call":[" fetch "]}," Faker Creature Dog meme_phrase":{"type":"method","name":"meme_phrase","children":[],"call":[" fetch "]}," Faker Creature Dog sound":{"type":"method","name":"sound","children":[],"call":[" fetch "]}," Faker Creature Dog breed":{"type":"method","name":"breed","children":[],"call":[" fetch "]}," Faker Creature Dog name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Creature Cat registry":{"type":"method","name":"registry","children":[],"call":[" fetch "]}," Faker Creature Cat breed":{"type":"method","name":"breed","children":[],"call":[" fetch "]}," Faker Creature Cat name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Creature Animal name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Books Lovecraft paragraph_by_chars":{"type":"method","name":"paragraph_by_chars","children":[],"call":["paragraph [] + ","paragraph [] ","chars - ","  + "," paragraph ","paragraph length < ","paragraph length ","characters - ","keywords << ","legacy_characters != "," warn_for_deprecated_arguments "," warn_with_uplevel "," paragraph  [] + "," paragraph  [] ","  paragraph  "," paragraph  length < "," paragraph  length "]}," Faker Books Lovecraft paragraphs":{"type":"method","name":"paragraphs","children":[],"call":["paragraphs << "," paragraph ","1 upto "," resolve "," tap ","keywords << ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Books Lovecraft paragraph":{"type":"method","name":"paragraph","children":[],"call":[" sentences join "," sentences "," resolve + "," rand to_i "," rand ","random_sentences_to_add to_i "," resolve ","keywords << ","legacy_random_sentences_to_add != ","legacy_sentence_count != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Books Lovecraft sentences":{"type":"method","name":"sentences","children":[],"call":["sentences << "," sentence ","1 upto "," resolve "," tap ","keywords << ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Books Lovecraft words":{"type":"method","name":"words","children":[],"call":["words []= "," word ","w =~ ","words each_with_index "," shuffle [] "," shuffle ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar :word_list) :length)) + ","resolved_num / ","word_list length "," translate "," resolve ","keywords << ","legacy_spaces_allowed != ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel "," shuffle []  []= "," shuffle []  each_with_index ","(send\n  (lvar :resolved_num) :/\n  (send\n    (lvar : translate ) :length)) + ","(send\n  (lvar : resolve ) :/\n  (send\n    (lvar :word_list) :length)) + "," resolve  / "," translate  length ","key shuffle []  << "]}," Faker Books Lovecraft word":{"type":"method","name":"word","children":[],"call":[" word ","random_word =~ "," sample "," translate "," sample  =~ "]}," Faker Books Lovecraft sentence":{"type":"method","name":"sentence","children":[],"call":[" words join capitalize + "," words join capitalize "," words join "," words ","word_count + "," rand to_i "," rand ","random_words_to_add to_i ","keywords << ","legacy_random_words_to_add != ","legacy_word_count != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Books Lovecraft tome":{"type":"method","name":"tome","children":[],"call":[" fetch "]}," Faker Books Lovecraft deity":{"type":"method","name":"deity","children":[],"call":[" fetch "]}," Faker Books Lovecraft fhtagn":{"type":"method","name":"fhtagn","children":[],"call":["(send\n  (const nil :Array) :new\n  (lvar :number_of)) join "," fetch ","Array  new ","(send\n  (const nil :Array) :new\n  (lvar :number)) join ","keywords << ","legacy_number != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Books Lovecraft location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Books Dune saying":{"type":"method","name":"saying","children":[],"call":[" fetch ","dune.sayings. + "," raise ","sourced_sayings join ","sourced_sayings include? ","source to_sym ","source to_s downcase ","source to_s "," sample to_s "," sample ","source nil? "," translate keys "," translate ","keywords << ","legacy_source != "," warn_for_deprecated_arguments "," warn_with_uplevel ","source to_s downcase d_sayings join "," sample to_s d_sayings join "," translate keys  join ","source to_s downcase d_sayings include? "," sample to_s d_sayings include? "," translate keys  include? ","source to_s downcase  to_sym "," sample to_s  to_sym ","source to_s downcase  to_s downcase "," sample to_s  to_s downcase ","source to_s downcase  to_s "," sample to_s  to_s ","source to_s downcase  nil? "," sample to_s  nil? ","legacy_source to_s downcase  != ","legacy_ sample to_s  != "]}," Faker Books Dune quote":{"type":"method","name":"quote","children":[],"call":[" fetch ","dune.quotes. + "," raise ","quoted_characters join ","quoted_characters include? ","character to_sym ","character to_s downcase ","character to_s "," sample to_s "," sample ","character nil? "," translate keys "," translate ","keywords << ","legacy_character != "," warn_for_deprecated_arguments "," warn_with_uplevel ","quoted_character to_s downcase s join ","quoted_ sample to_s s join "," translate keys  join ","quoted_character to_s downcase s include? ","quoted_ sample to_s s include? "," translate keys  include? ","character to_s downcase  to_sym "," sample to_s  to_sym ","character to_s downcase  to_s downcase "," sample to_s  to_s downcase ","character to_s downcase  to_s "," sample to_s  to_s ","character to_s downcase  nil? "," sample to_s  nil? ","legacy_character to_s downcase  != ","legacy_ sample to_s  != "]}," Faker Books Dune planet":{"type":"method","name":"planet","children":[],"call":[" fetch "]}," Faker Books Dune title":{"type":"method","name":"title","children":[],"call":[" fetch "]}," Faker Books Dune character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Books CultureSeries planet":{"type":"method","name":"planet","children":[],"call":[" fetch "]}," Faker Books CultureSeries civ":{"type":"method","name":"civ","children":[],"call":[" fetch "]}," Faker Books CultureSeries culture_ship_class_abv":{"type":"method","name":"culture_ship_class_abv","children":[],"call":[" fetch "]}," Faker Books CultureSeries culture_ship_class":{"type":"method","name":"culture_ship_class","children":[],"call":[" fetch "]}," Faker Books CultureSeries culture_ship":{"type":"method","name":"culture_ship","children":[],"call":[" fetch "]}," Faker Books CultureSeries book":{"type":"method","name":"book","children":[],"call":[" fetch "]}," Faker Blockchain Tezos encode_tz":{"type":"method","name":"encode_tz","children":[],"call":["Faker Base58  encode ","packed + ","Digest SHA2  digest [] ","Digest SHA2  digest ","prefix map join + ","Faker Config  random bytes ","Faker Config  random ","prefix map join ","prefix map ","PREFIXES  fetch ","OpenSSL Digest SHA256  digest [] ","OpenSSL Digest SHA256  digest ","prefix map join +  + ","PREFIXES  fetch  map join + ","PREFIXES  fetch  map join ","PREFIXES  fetch  map "]}," Faker Blockchain Tezos signature":{"type":"method","name":"signature","children":[],"call":[" encode_tz "]}," Faker Blockchain Tezos operation":{"type":"method","name":"operation","children":[],"call":[" encode_tz "]}," Faker Blockchain Tezos contract":{"type":"method","name":"contract","children":[],"call":[" encode_tz "]}," Faker Blockchain Tezos account":{"type":"method","name":"account","children":[],"call":[" encode_tz "]}," Faker Blockchain Ethereum address":{"type":"method","name":"address","children":[],"call":["var << "," sample "," shuffle ","hex_alphabet split ","40 times ","0x +@ ","hex_alphabet chars ","0x +@  << "]}," Faker Blockchain Bitcoin address_for":{"type":"method","name":"address_for","children":[],"call":["Faker Base58  encode ","packed + ","Digest SHA2  digest [] ","Digest SHA2  digest ","version chr + ","Faker Config  random bytes ","Faker Config  random ","version chr ","PROTOCOL_VERSIONS  fetch ","OpenSSL Digest SHA256  digest [] ","OpenSSL Digest SHA256  digest ","version chr +  + ","PROTOCOL_VERSIONS  fetch  chr + ","PROTOCOL_VERSIONS  fetch  chr "]}," Faker Blockchain Bitcoin testnet_address":{"type":"method","name":"testnet_address","children":[],"call":[" address_for "]}," Faker Blockchain Bitcoin address":{"type":"method","name":"address","children":[],"call":[" address_for "]}," Faker Sports Football position":{"type":"method","name":"position","children":[],"call":[" fetch "]}," Faker Sports Football competition":{"type":"method","name":"competition","children":[],"call":[" fetch "]}," Faker Sports Football coach":{"type":"method","name":"coach","children":[],"call":[" fetch "]}," Faker Sports Football player":{"type":"method","name":"player","children":[],"call":[" fetch "]}," Faker Sports Football team":{"type":"method","name":"team","children":[],"call":[" fetch "]}," Faker Sports Basketball position":{"type":"method","name":"position","children":[],"call":[" fetch "]}," Faker Sports Basketball coach":{"type":"method","name":"coach","children":[],"call":[" fetch "]}," Faker Sports Basketball player":{"type":"method","name":"player","children":[],"call":[" fetch "]}," Faker Sports Basketball team":{"type":"method","name":"team","children":[],"call":[" fetch "]}," Faker Music Opera bellini":{"type":"method","name":"bellini","children":[],"call":[" fetch "]}," Faker Music Opera donizetti":{"type":"method","name":"donizetti","children":[],"call":[" fetch "]}," Faker Music Opera rossini":{"type":"method","name":"rossini","children":[],"call":[" fetch "]}," Faker Music Opera verdi":{"type":"method","name":"verdi","children":[],"call":[" fetch "]}," Faker Music GratefulDead song":{"type":"method","name":"song","children":[],"call":[" fetch "]}," Faker Music GratefulDead player":{"type":"method","name":"player","children":[],"call":[" fetch "]}," Faker Game platform":{"type":"method","name":"platform","children":[],"call":[" fetch "]}," Faker Game genre":{"type":"method","name":"genre","children":[],"call":[" fetch "]}," Faker Game title":{"type":"method","name":"title","children":[],"call":[" fetch "]}," Faker Internet uuid":{"type":"method","name":"uuid","children":[],"call":["%08x-%04x-%04x-%04x-%04x%08x % ","ary []= ","(send\n  (send\n    (lvar :ary) :[]\n    (int 3)) :&\n  (int 16383)) | ","ary [] & ","ary [] ","(send\n  (send\n    (lvar :ary) :[]\n    (int 2)) :&\n  (int 4095)) | ","Faker Config  random bytes unpack ","Faker Config  random bytes ","Faker Config  random ","Faker Config  random bytes unpack  []= ","(send\n  (send\n    (lvar :Faker Config  random bytes unpack ) :[]\n    (int 3)) :&\n  (int 16383)) | ","Faker Config  random bytes unpack  [] & ","Faker Config  random bytes unpack  [] ","(send\n  (send\n    (lvar :Faker Config  random bytes unpack ) :[]\n    (int 2)) :&\n  (int 4095)) | "]}," Faker Company sic_code":{"type":"method","name":"sic_code","children":[],"call":[" fetch "]}," Faker Creature Horse breed":{"type":"method","name":"breed","children":[],"call":[" fetch "]}," Faker Creature Horse name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Blockchain Tezos block":{"type":"method","name":"block","children":[],"call":[" encode_tz "]}," Faker CLI Base search":{"type":"method","name":"search","children":[],"call":["Faker CLI Commands Search  new execute ","Faker CLI Commands Search  new "," options "," invoke "," options [] "]}," Faker CLI Base list":{"type":"method","name":"list","children":[],"call":["Faker CLI Commands List  new execute ","Faker CLI Commands List  new "," options "," invoke "," options [] "]}," Faker CLI Base version":{"type":"method","name":"version","children":[],"call":[" puts "]}," Faker CLI Renderer ensure_method_is_supported":{"type":"method","name":"ensure_method_is_supported","children":[],"call":["const respond_to? "]}," Faker CLI Renderer faker_method":{"type":"method","name":"faker_method","children":[],"call":[" ensure_method_is_supported ","const public_send "]}," Faker CLI Renderer verbose_output":{"type":"method","name":"verbose_output","children":[],"call":["arr << << "," crayon dim magenta bold ","message to_s "," crayon dim magenta "," crayon dim "," crayon ","arr << "," crayon dim white "," faker_method "]}," Faker CLI Renderer verbose?":{"type":"method","name":"verbose?","children":[],"call":[" options [] "," options "]}," Faker CLI Renderer leaf_args":{"type":"method","name":"leaf_args","children":[],"call":[" verbose_output "," verbose? ","(send\n  (lvar :method) :to_s) tap ","method to_s "]}," Faker CLI Renderer leaf":{"type":"method","name":"leaf","children":[],"call":[" crayon cyan "," leaf_args "," crayon ","(or\n  (lvar :methods)\n  (array)) map "]}," Faker CLI Renderer node":{"type":"method","name":"node","children":[],"call":[" leaf "," crayon green ","const to_s "," crayon "]}," Faker CLI Renderer build_tree":{"type":"method","name":"build_tree","children":[],"call":["results sort_by to_h ","results sort_by ","h merge! "," node "," hash reduce "," hash "]}," Faker CLI Renderer gt_screen_height?":{"type":"method","name":"gt_screen_height?","children":[],"call":[" tree nodes size > ","TTY Screen  height "," tree nodes size "," tree nodes "," tree "]}," Faker CLI Renderer paginable?":{"type":"method","name":"paginable?","children":[],"call":[" output tty? "," output "," gt_screen_height? "]}," Faker CLI Renderer tree":{"type":"method","name":"tree","children":[],"call":["TTY Tree  new "," build_tree "]}," Faker CLI Renderer render":{"type":"method","name":"render","children":[],"call":[" tree render "," tree "]}," Faker CLI Renderer call":{"type":"method","name":"call","children":[],"call":[" output puts "," render "," output "," pager page "," pager "," paginable? "]}," Faker CLI Renderer initialize":{"type":"method","name":"initialize","children":[],"call":["TTY Pager  new ","Pastel  new ","output tty? "]}," Faker CLI Reflectors Search query_matches?":{"type":"method","name":"query_matches?","children":[],"call":[" query match ","method_name_parts join "," query ","method_name split reject ","method_name split ","method_name split reject  join "]}," Faker CLI Reflectors Search search_descendants_matching_query":{"type":"method","name":"search_descendants_matching_query","children":[],"call":[" store "," query_matches? ","method to_s ","methods select ","descendant my_singleton_methods "," faker_descendants each "," faker_descendants ","descendant my_singleton_methods  select ","descendant my_singleton_descendant my_singleton_methods  "]}," Faker CLI Reflectors Search call":{"type":"method","name":"call","children":[],"call":[" descendants_with_methods "," search_descendants_matching_query "]}," Faker CLI Reflectors Search initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Faker CLI Reflectors List all_descendants_with_methods":{"type":"method","name":"all_descendants_with_methods","children":[],"call":[" descendants_with_methods "," store ","descendant my_singleton_methods "," faker_descendants each "," faker_descendants "]}," Faker CLI Reflectors List call":{"type":"method","name":"call","children":[],"call":[" faker_descendants "," all_descendants_with_methods "," show_methods "]}," Faker CLI Reflectors List initialize":{"type":"method","name":"initialize","children":[],"call":["options [] "]}," Faker CLI Reflector faker_descendants":{"type":"method","name":"faker_descendants","children":[],"call":["Faker Base  descendants "]}," Faker CLI Reflector store":{"type":"method","name":"store","children":[],"call":[" descendants_with_methods [] concat "," descendants_with_methods [] "," descendants_with_methods ","methods empty? "]}," Faker CLI Reflector initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","Hash  new "]}," Faker CLI Reflector my_singleton_methods":{"type":"method","name":"my_singleton_methods","children":[],"call":[]}," Faker CLI Reflector descendants":{"type":"method","name":"descendants","children":[],"call":[]}," Faker CLI Commands Search not_found":{"type":"method","name":"not_found","children":[],"call":["output puts "]}," Faker CLI Commands Search render":{"type":"method","name":"render","children":[],"call":[" not_found ","result empty? "]}," Faker CLI Commands Search execute":{"type":"method","name":"execute","children":[],"call":[" render ","Reflectors Search  call "]}," Faker CLI Commands List execute":{"type":"method","name":"execute","children":[],"call":[" render ","Reflectors List  call "," options "]}," Faker CLI Command render":{"type":"method","name":"render","children":[],"call":["Renderer  call "," options "]}," Faker CLI Command initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Faker File dir":{"type":"method","name":"dir","children":[],"call":["(send\n  (const nil :Array) :new\n  (lvar :segment_count)) unshift compact join squeeze ","(send\n  (const nil :Array) :new\n  (lvar :segment_count)) unshift compact join ","(send\n  (const nil :Array) :new\n  (lvar :segment_count)) unshift compact ","(send\n  (const nil :Array) :new\n  (lvar :segment_count)) unshift ","Faker Internet  slug ","Array  new ","keywords << ","legacy_directory_separator != ","legacy_root != ","legacy_segment_count != "," warn_for_deprecated_arguments "," warn_with_uplevel "]}," Faker Time get_time_object":{"type":"method","name":"get_time_object","children":[],"call":["time to_time ","time respond_to? "," Time  parse ","time is_a? ","time to_time  to_time to_time  "," Time  parse  to_ Time  parse  ","time to_time  respond_to? "," Time  parse  respond_to? ","time to_time  is_a? "," Time  parse  is_a? "]}," Faker Time between_dates":{"type":"method","name":"between_dates","children":[],"call":[" time_with_format "," date_with_random_time ","Faker Date  between ","keywords << ","legacy_format != ","legacy_period != ","legacy_to != ","legacy_from != "," warn_for_deprecated_arguments "," warn_with_uplevel ","  date_with_random_time _with_format "," date_with_random_ date_with_random_time  "," Faker Date  between _with_random_time "]}," Faker Space launch_vehicle":{"type":"method","name":"launch_vehicle","children":[],"call":[" fetch "]}," Faker Number generate":{"type":"method","name":"generate","children":[],"call":[" digit ","Array  new ","count zero? "]}," Faker Cannabis brand":{"type":"method","name":"brand","children":[],"call":[]}," Faker IDNumber brazilian_id_digit":{"type":"method","name":"brazilian_id_digit","children":[],"call":["subtraction to_s ","digits [] ","digits include? ","11 - ","remainder to_i ","11 -  to_s "]}," Faker IDNumber brazilian_citizen_number_digit":{"type":"method","name":"brazilian_citizen_number_digit","children":[],"call":["remainder to_s ","remainder == "]}," Faker IDNumber brazilian_document_digit":{"type":"method","name":"brazilian_document_digit","children":[],"call":[" brazilian_citizen_number_digit "," brazilian_id_digit ","checksum % "]}," Faker IDNumber brazilian_document_checksum":{"type":"method","name":"brazilian_document_checksum","children":[],"call":["(send\n  (send\n    (send\n      (lvar :digits) :chars) :each_with_index) :inject\n  (int 0)) * ","acc + ","digit to_i * ","digits size + - ","digits size + ","digits size ","digit to_i ","digits chars each_with_index inject ","digits chars each_with_index ","digits chars "]}," Faker IDNumber brazilian_id_checksum_digit":{"type":"method","name":"brazilian_id_checksum_digit","children":[],"call":[" brazilian_document_digit "," brazilian_document_checksum "," brazilian_document_ brazilian_document_checksum  "]}," Faker IDNumber brazilian_id":{"type":"method","name":"brazilian_id","children":[],"call":[" format ","number scan flatten ","number scan ","(lvar :digits) join "," brazilian_id_checksum_digit ","Faker Number  between to_s ","Faker Number  between ","keywords << ","legacy_formatted != "," warn_for_deprecated_arguments "," warn_with_uplevel ","(lvar :digits) join  scan flatten ","(lvar :digits) join  scan ","(lvar :Faker Number  between to_s ) join "]}," Faker Base parse_caller":{"type":"method","name":"parse_caller","children":[],"call":["Regexp  last_match to_i ","Regexp  last_match "]}," Faker Base warn_with_uplevel":{"type":"method","name":"warn_with_uplevel","children":[],"call":[" warn "," parse_caller join "," parse_caller "," caller [] "," caller "]}," Faker Base warn_for_deprecated_arguments":{"type":"method","name":"warn_for_deprecated_arguments","children":[],"call":[" warn "," warn_with_uplevel ","keywords each with_index ","keywords each "," caller first match [] "," caller first match "," caller first "," caller ","keywords empty? "]}," Faker TvShows DrWho villain":{"type":"method","name":"villain","children":[],"call":[" fetch "]}," Faker Restaurant review":{"type":"method","name":"review","children":[],"call":[" fetch "]}," Faker Restaurant description":{"type":"method","name":"description","children":[],"call":[" fetch "]}," Faker Restaurant type":{"type":"method","name":"type","children":[],"call":[" fetch "]}," Faker Omniauth apple":{"type":"method","name":"apple","children":[],"call":["auth email ","Time  forward to_i ","Time  forward ","Crypto  md5 ","auth last_name ","auth first_name ","Omniauth  new ","Number  number ","Number  hexadecimal ","Omniauth  new  email ","Omniauth  new  last_name ","Omniauth  new  first_name ","OmniOmniauth  new   new "]}," Faker IDNumber chilean_verification_code":{"type":"method","name":"chilean_verification_code","children":[],"call":["CHILEAN_MODULO  - ","sum modulo ","(send\n  (send\n    (lvar :digits_splitted) :map) :with_index) reduce ","digit * ","multiplication_rule [] ","digits_splitted map with_index ","digits_splitted map ","digits to_s chars map ","digits to_s chars ","digits to_s ","sum sum modulo  ","(send\n  (send\n    (lvar :digits_splitted) :map) :with_index) reduce  modulo ","(send\n  (send\n    (lvar :digits to_s chars map ) :map) :with_index) reduce ","digits to_s chars map  map with_index ","digits to_s chars map  map "]}," Faker IDNumber chilean_id":{"type":"method","name":"chilean_id","children":[],"call":["digits to_s + + ","verification_code to_s ","digits to_s + ","digits to_s "," chilean_verification_code ","Faker Number  number ","Faker Number  number  to_s + + "," chilean_verification_code  to_s ","Faker Number  number  to_s + ","Faker Number  number  to_s "," chilean_ chilean_verification_code  "]}," Faker Gender short_binary_type":{"type":"method","name":"short_binary_type","children":[],"call":[" fetch "]}," Faker Date in_date_period":{"type":"method","name":"in_date_period","children":[],"call":[" between to_date "," between "," Date  new "," Date  civil day "," Date  civil "," between  Date  new _date "]}," Faker Bank valid_checksum?":{"type":"method","name":"valid_checksum?","children":[],"call":["routing_number [] to_i == ","routing_number [] to_i ","routing_number [] "]}," Faker Address mail_box":{"type":"method","name":"mail_box","children":[],"call":[" bothify "," fetch "]}," Faker Blockchain Aeternity rand_strings":{"type":"method","name":"rand_strings","children":[],"call":["var << "," sample "," shuffle ","hex_alphabet split ","length times "," +@ ","hex_alphabet chars "," +@  << "]}," Faker Blockchain Aeternity oracle":{"type":"method","name":"oracle","children":[],"call":["ok_ + "," rand_strings "]}," Faker Blockchain Aeternity contract":{"type":"method","name":"contract","children":[],"call":["ct_ + "," rand_strings "]}," Faker Blockchain Aeternity transaction":{"type":"method","name":"transaction","children":[],"call":["th_ + "," rand_strings "]}," Faker Blockchain Aeternity address":{"type":"method","name":"address","children":[],"call":["ak_ + "," rand_strings "]}," Faker Quotes Rajnikanth joke":{"type":"method","name":"joke","children":[],"call":[" fetch "]}," Faker Quotes Chiquito sentences":{"type":"method","name":"sentences","children":[],"call":[" fetch "]}," Faker Quotes Chiquito jokes":{"type":"method","name":"jokes","children":[],"call":[" fetch "]}," Faker Quotes Chiquito terms":{"type":"method","name":"terms","children":[],"call":[" fetch "]}," Faker Quotes Chiquito expressions":{"type":"method","name":"expressions","children":[],"call":[" fetch "]}," Faker Quotes Chiquito sentence":{"type":"method","name":"sentence","children":[],"call":[" sample "," sentences "]}," Faker Quotes Chiquito joke":{"type":"method","name":"joke","children":[],"call":[" sample "," jokes "]}," Faker Quotes Chiquito term":{"type":"method","name":"term","children":[],"call":[" sample "," terms "]}," Faker Quotes Chiquito expression":{"type":"method","name":"expression","children":[],"call":[" sample "," expressions "]}," Faker Internet base64":{"type":"method","name":"base64","children":[],"call":["(send\n  (const nil :Array) :new\n  (lvar :length)) join "," sample ","Array  new ","(send nil :Array\n  (irange\n    (str \"0\")\n    (str \"9\"))) flatten "," Array ","((send\n  (const nil :Array) :new\n  (lvar :length)) join end\n  (con(send\n  (const nil :Array) :new\n  (lvar :length)) join t nil :Array) :new\n  (lvar :length)) join "," (send\n  (const nil :Array) :new\n  (lvar :length)) join ample ","((send\n  (const nil :Array) :new\n  (lvar :length)) join end nil :Array\n  (irange\n    ((send\n  (const nil :Array) :new\n  (lvar :length)) join tr \"0\")\n    ((send\n  (const nil :Array) :new\n  (lvar :length)) join tr \"9\"))) flatten "]}," Faker TvShows Suits quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows Suits character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Show play":{"type":"method","name":"play","children":[],"call":[" fetch "]}," Faker Show kids_musical":{"type":"method","name":"kids_musical","children":[],"call":[" fetch "]}," Faker Show adult_musical":{"type":"method","name":"adult_musical","children":[],"call":[" fetch "]}," Faker Music Phish musician":{"type":"method","name":"musician","children":[],"call":[" fetch "]}," Faker Music Phish album":{"type":"method","name":"album","children":[],"call":[" fetch "]}," Faker Music PearlJam song":{"type":"method","name":"song","children":[],"call":[" fetch "]}," Faker Music PearlJam album":{"type":"method","name":"album","children":[],"call":[" fetch "]}," Faker Music PearlJam musician":{"type":"method","name":"musician","children":[],"call":[" fetch "]}," Faker Movies Departed quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies Departed character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Movies Departed actor":{"type":"method","name":"actor","children":[],"call":[" fetch "]}," Faker Games WarhammerFantasy creature":{"type":"method","name":"creature","children":[],"call":[" fetch "]}," Faker Games WarhammerFantasy faction":{"type":"method","name":"faction","children":[],"call":[" fetch "]}," Faker Games WarhammerFantasy location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games WarhammerFantasy quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Games WarhammerFantasy hero":{"type":"method","name":"hero","children":[],"call":[" fetch "]}," Faker Games DnD alignment":{"type":"method","name":"alignment","children":[],"call":[" fetch "]}," Faker Games DnD background":{"type":"method","name":"background","children":[],"call":[" fetch "]}," Faker Games DnD klass":{"type":"method","name":"klass","children":[],"call":[" fetch "]}," Faker Games DnD species":{"type":"method","name":"species","children":[],"call":[" fetch "," warn "]}," Faker Games Control quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Games Control the_board":{"type":"method","name":"the_board","children":[],"call":[" fetch "]}," Faker Games Control hiss":{"type":"method","name":"hiss","children":[],"call":[" fetch "]}," Faker Games Control altered_world_event":{"type":"method","name":"altered_world_event","children":[],"call":[" fetch "]}," Faker Games Control altered_item":{"type":"method","name":"altered_item","children":[],"call":[" fetch "]}," Faker Games Control object_of_power":{"type":"method","name":"object_of_power","children":[],"call":[" fetch "]}," Faker Games Control location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games Control character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker PhoneNumber cell_phone_in_e164":{"type":"method","name":"cell_phone_in_e164","children":[],"call":[" cell_phone_with_country_code delete "," cell_phone_with_country_code "]}," Faker Computer stack":{"type":"method","name":"stack","children":[],"call":[" fetch ","platform downcase "," platform "," platform  downcase ","  platform  "]}," Faker Computer os":{"type":"method","name":"os","children":[],"call":[" fetch ","platform downcase "," platform "," fetch_all include? "," fetch_all "," platform  downcase ","  platform  "]}," Faker Computer type":{"type":"method","name":"type","children":[],"call":[" fetch "]}," Faker Computer platform":{"type":"method","name":"platform","children":[],"call":[" fetch "]}," Faker Company inn_checksum":{"type":"method","name":"inn_checksum","children":[],"call":["(send\n  (send\n    (block\n      (send\n        (send\n          (send\n            (lvar :factor) :map) :with_index) :reduce\n        (int 0))\n      (args\n        (arg :v)\n        (arg :i))\n      (send\n        (lvar :v) :+\n        (send\n          (send\n            (lvar :i) :[]\n            (int 0)) :*\n          (send\n            (send\n              (lvar :number) :[]\n              (send\n                (lvar :i) :[]\n                (int 1))) :to_i)))) :%\n    (int 11)) :%\n  (int 10)) to_s ","(send\n  (send\n    (send\n      (lvar :factor) :map) :with_index) :reduce\n  (int 0)) % % ","(send\n  (send\n    (send\n      (lvar :factor) :map) :with_index) :reduce\n  (int 0)) % ","v + ","i [] * ","number [] to_i ","number [] ","i [] ","factor map with_index reduce ","factor map with_index ","factor map "]}," Faker Company inn_number":{"type":"method","name":"inn_number","children":[],"call":["number + "," inn_checksum + "," inn_checksum ","region to_s + "," rand to_s "," rand ","region to_s ","type == "," format ","region nil? ","region to_s +  + "," format  to_s + "," format  to_s "," format  nil? "]}," Faker Company russian_tax_number":{"type":"method","name":"russian_tax_number","children":[],"call":[" inn_number "]}," Faker Blood group":{"type":"method","name":"group","children":[],"call":[" parse "]}," Faker Blood rh_factor":{"type":"method","name":"rh_factor","children":[],"call":[" fetch "]}," Faker Blood type":{"type":"method","name":"type","children":[],"call":[" fetch "]}," Faker Bank compile_bsb_number":{"type":"method","name":"compile_bsb_number","children":[],"call":["digit_one_two sample + + + + "," rand_numstring ","digit_one_two sample + + + ","digit_one_two sample + + ","digit_one_two sample + ","digit_one_two sample ","(irange\n  (int 2)\n  (int 7)) to_a map sample ","(irange\n  (int 2)\n  (int 7)) to_a map ","(irange\n  (int 2)\n  (int 7)) to_a "]}," Faker Bank bsb_number":{"type":"method","name":"bsb_number","children":[],"call":[" compile_bsb_number "]}," Faker TvShows Simpsons episode_title":{"type":"method","name":"episode_title","children":[],"call":[" fetch "]}," Faker TvShows Futurama hermes_catchphrase":{"type":"method","name":"hermes_catchphrase","children":[],"call":[" fetch "]}," Faker TvShows Futurama quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows Futurama location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker TvShows Futurama character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows BigBangTheory quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows BigBangTheory character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows AquaTeenHungerForce quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Music Rush album":{"type":"method","name":"album","children":[],"call":[" fetch "]}," Faker Music Rush player":{"type":"method","name":"player","children":[],"call":[" fetch "]}," Faker Music Prince band":{"type":"method","name":"band","children":[],"call":[" fetch "]}," Faker Music Prince album":{"type":"method","name":"album","children":[],"call":[" fetch "]}," Faker Music Prince lyric":{"type":"method","name":"lyric","children":[],"call":[" fetch "]}," Faker Music Prince song":{"type":"method","name":"song","children":[],"call":[" fetch "]}," Faker Movie title":{"type":"method","name":"title","children":[],"call":[" fetch "]}," Faker Games Minecraft mob":{"type":"method","name":"mob","children":[],"call":[" fetch "]}," Faker Games Minecraft item":{"type":"method","name":"item","children":[],"call":[" fetch "]}," Faker Games Minecraft block":{"type":"method","name":"block","children":[],"call":[" fetch "]}," Faker Games HeroesOfTheStorm class_name":{"type":"method","name":"class_name","children":[],"call":[" fetch "]}," Faker Name neutral_first_name":{"type":"method","name":"neutral_first_name","children":[],"call":[" fetch "]}," Faker Internet HTTP status_code":{"type":"method","name":"status_code","children":[],"call":["STATUS_CODES  [] sample ","STATUS_CODES  [] "," raise ","STATUS_CODES_GROUPS  include? ","STATUS_CODES_GROUPS  sample "]}," Faker Internet construct_email":{"type":"method","name":"construct_email","children":[],"call":["(lvar :local_part) join "]}," Faker Internet sanitize_email_local_part":{"type":"method","name":"sanitize_email_local_part","children":[],"call":["(send\n  (send\n    (lvar :local_part) :split\n    (regexp\n      (regopt))) :map) join ","char_range include? ","local_part split map ","local_part split ","(send nil :Array\n  (irange\n    (str \"0\")\n    (str \"9\"))) flatten ","!#$%&'*+-/=?^_`{|}~. split "," Array ","(send\n  (send\n    (lvar :local_part) :chars) :map) join ","local_part chars map ","local_part chars ","!#$%&'*+-/=?^_`{|}~. chars ","(send nil :Array\n  (irange\n    (str \"0\")\n    (str \"9\"))) flatten  include? "]}," Faker Address full_address_as_hash":{"type":"method","name":"full_address_as_hash","children":[],"call":["(send\n  (lvar :attrs) :map) reduce "," send ","attrs_params [] ","attrs map ","attrs_params transform_keys! ","attrs map! "]}," Faker Games StreetFighter move":{"type":"method","name":"move","children":[],"call":[" fetch "]}," Faker Games StreetFighter quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Games StreetFighter stage":{"type":"method","name":"stage","children":[],"call":[" fetch "]}," Faker Games StreetFighter character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games DnD ranged_weapon":{"type":"method","name":"ranged_weapon","children":[],"call":[" fetch "]}," Faker Games DnD race":{"type":"method","name":"race","children":[],"call":[" fetch "]}," Faker Games DnD monster":{"type":"method","name":"monster","children":[],"call":[" fetch "]}," Faker Games DnD melee_weapon":{"type":"method","name":"melee_weapon","children":[],"call":[" fetch "]}," Faker Games DnD language":{"type":"method","name":"language","children":[],"call":[" fetch "]}," Faker Games DnD city":{"type":"method","name":"city","children":[],"call":[" fetch "]}," Faker Drone min_shutter_speed":{"type":"method","name":"min_shutter_speed","children":[],"call":[" fetch "]}," Faker Drone max_shutter_speed":{"type":"method","name":"max_shutter_speed","children":[],"call":[" fetch "]}," Faker Drone shutter_speed_range":{"type":"method","name":"shutter_speed_range","children":[],"call":[" fetch "]}," Faker Drone video_format":{"type":"method","name":"video_format","children":[],"call":[" parse "]}," Faker Drone photo_format":{"type":"method","name":"photo_format","children":[],"call":[" parse "]}," Faker Drone max_resolution":{"type":"method","name":"max_resolution","children":[],"call":[" parse "]}," Faker Drone iso":{"type":"method","name":"iso","children":[],"call":[" parse "]}," Faker Drone max_charging_power":{"type":"method","name":"max_charging_power","children":[],"call":[" parse "]}," Faker Drone charging_temperature":{"type":"method","name":"charging_temperature","children":[],"call":[" parse "]}," Faker Drone battery_weight":{"type":"method","name":"battery_weight","children":[],"call":[" parse "]}," Faker Drone battery_type":{"type":"method","name":"battery_type","children":[],"call":[" parse "]}," Faker Drone battery_voltage":{"type":"method","name":"battery_voltage","children":[],"call":[" parse "]}," Faker Drone battery_capacity":{"type":"method","name":"battery_capacity","children":[],"call":[" parse "]}," Faker Drone operating_temperature":{"type":"method","name":"operating_temperature","children":[],"call":[" parse "]}," Faker Drone max_tilt_angle":{"type":"method","name":"max_tilt_angle","children":[],"call":[" parse "]}," Faker Drone max_angular_velocity":{"type":"method","name":"max_angular_velocity","children":[],"call":[" parse "]}," Faker Drone max_wind_resistance":{"type":"method","name":"max_wind_resistance","children":[],"call":[" parse "]}," Faker Drone max_speed":{"type":"method","name":"max_speed","children":[],"call":[" parse "]}," Faker Drone max_flight_distance":{"type":"method","name":"max_flight_distance","children":[],"call":[" parse "]}," Faker Drone max_altitude":{"type":"method","name":"max_altitude","children":[],"call":[" parse "]}," Faker Drone flight_time":{"type":"method","name":"flight_time","children":[],"call":[" parse "]}," Faker Drone max_descent_speed":{"type":"method","name":"max_descent_speed","children":[],"call":[" parse "]}," Faker Drone max_ascent_speed":{"type":"method","name":"max_ascent_speed","children":[],"call":[" parse "]}," Faker Drone weight":{"type":"method","name":"weight","children":[],"call":[" parse "]}," Faker Drone name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker InvalidStatePassed initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Faker DrivingLicence usa_driving_licence":{"type":"method","name":"usa_driving_licence","children":[],"call":[" raise "," bothify "," fetch ","state to_s strip downcase gsub ","state to_s strip downcase ","state to_s strip ","state to_s "]}," Faker Barcode generate_check_digit":{"type":"method","name":"generate_check_digit","children":[],"call":["(send\n  (int 10) :-\n  (send\n    (begin\n      (send\n        (send\n          (lvar :odd_sum) :*\n          (int 3)) :+\n        (lvar :even_sum))) :%\n    (int 10))) % ","10 - ","(send\n  (send\n    (lvar :odd_sum) :*\n    (int 3)) :+\n  (lvar :even_sum)) % ","odd_sum * + ","odd_sum * "]}," Faker Barcode sum_even_odd":{"type":"method","name":"sum_even_odd","children":[],"call":["number % ","index even? ","number != ","fake_num to_i ","fake_num to_i  % ","fake_num to_i  != "]}," Faker Barcode generate_barcode":{"type":"method","name":"generate_barcode","children":[],"call":[" generate_check_digit "," sum_even_odd "," parse "," generate_ generate_check_digit  "]}," Faker Barcode issn":{"type":"method","name":"issn","children":[],"call":[" generate_barcode "]}," Faker Barcode ismn":{"type":"method","name":"ismn","children":[],"call":[" generate_barcode "]}," Faker Barcode isbn":{"type":"method","name":"isbn","children":[],"call":[" generate_barcode "]}," Faker Barcode upc_e_with_composite_symbology":{"type":"method","name":"upc_e_with_composite_symbology","children":[],"call":[" bothify "," parse "," upc_e "]}," Faker Barcode upc_a_with_composite_symbology":{"type":"method","name":"upc_a_with_composite_symbology","children":[],"call":[" bothify "," parse "," upc_a "]}," Faker Barcode upc_e":{"type":"method","name":"upc_e","children":[],"call":[" generate_barcode "]}," Faker Barcode upc_a":{"type":"method","name":"upc_a","children":[],"call":[" generate_barcode "]}," Faker Barcode ean_with_composite_symbology":{"type":"method","name":"ean_with_composite_symbology","children":[],"call":[" bothify "," parse "," ean "]}," Faker Barcode ean":{"type":"method","name":"ean","children":[],"call":[" generate_barcode "," Integer "]}," Faker load_i18n":{"type":"method","name":"load_i18n","children":[],"call":["I18n  reload! ","I18n  backend initialized? ","I18n  backend "," Dir  [] "," File  join "," __dir__ ","I18n  load_path ","I18n  available_locales join ","I18n  available_locales "]}," Faker TvShows TheFreshPrinceOfBelAir actor":{"type":"method","name":"actor","children":[],"call":[" fetch "]}," Faker TvShows FinalSpace quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows FinalSpace vehicle":{"type":"method","name":"vehicle","children":[],"call":[" fetch "]}," Faker TvShows FinalSpace character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows Buffy actor":{"type":"method","name":"actor","children":[],"call":[" fetch "]}," Faker Sports Volleyball formation":{"type":"method","name":"formation","children":[],"call":[" fetch "]}," Faker Sports Volleyball position":{"type":"method","name":"position","children":[],"call":[" fetch "]}," Faker Sports Volleyball coach":{"type":"method","name":"coach","children":[],"call":[" fetch "]}," Faker Sports Volleyball player":{"type":"method","name":"player","children":[],"call":[" fetch "]}," Faker Sports Volleyball team":{"type":"method","name":"team","children":[],"call":[" fetch "]}," Faker Quote fortune_cookie":{"type":"method","name":"fortune_cookie","children":[],"call":[" fetch "]}," Faker Quote jack_handey":{"type":"method","name":"jack_handey","children":[],"call":[" fetch "]}," Faker Music Opera saint_saens":{"type":"method","name":"saint_saens","children":[],"call":[" fetch "]}," Faker Music Opera gounod":{"type":"method","name":"gounod","children":[],"call":[" fetch "]}," Faker Music Opera bizet":{"type":"method","name":"bizet","children":[],"call":[" fetch "]}," Faker Music Opera berlioz":{"type":"method","name":"berlioz","children":[],"call":[" fetch "]}," Faker Music Opera ravel":{"type":"method","name":"ravel","children":[],"call":[" fetch "]}," Faker Music Opera berg":{"type":"method","name":"berg","children":[],"call":[" fetch "]}," Faker Music Opera schubert":{"type":"method","name":"schubert","children":[],"call":[" fetch "]}," Faker Music Opera schumann":{"type":"method","name":"schumann","children":[],"call":[" fetch "]}," Faker Music Opera wagner":{"type":"method","name":"wagner","children":[],"call":[" fetch "]}," Faker Music Opera strauss":{"type":"method","name":"strauss","children":[],"call":[" fetch "]}," Faker Music Opera weber":{"type":"method","name":"weber","children":[],"call":[" fetch "]}," Faker Music Opera beethoven":{"type":"method","name":"beethoven","children":[],"call":[" fetch "]}," Faker Music Opera gluck_french":{"type":"method","name":"gluck_french","children":[],"call":[" fetch "]}," Faker Music Opera gluck_italian":{"type":"method","name":"gluck_italian","children":[],"call":[" fetch "]}," Faker Music Opera gluck":{"type":"method","name":"gluck","children":[],"call":[" fetch + "," fetch "]}," Faker Music Opera mozart_german":{"type":"method","name":"mozart_german","children":[],"call":[" fetch "]}," Faker Music Opera mozart_italian":{"type":"method","name":"mozart_italian","children":[],"call":[" fetch "]}," Faker Music Opera mozart":{"type":"method","name":"mozart","children":[],"call":[" fetch + "," fetch "]}," Faker Music Hiphop subgenres":{"type":"method","name":"subgenres","children":[],"call":[" fetch "]}," Faker Music Hiphop groups":{"type":"method","name":"groups","children":[],"call":[" fetch "]}," Faker Music Hiphop artist":{"type":"method","name":"artist","children":[],"call":[" fetch "]}," Faker Movies TheRoom quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies TheRoom location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Movies TheRoom character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Movies TheRoom actor":{"type":"method","name":"actor","children":[],"call":[" fetch "]}," Faker Movies HowToTrainYourDragon dragon":{"type":"method","name":"dragon","children":[],"call":[" fetch "]}," Faker Movies HowToTrainYourDragon location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Movies HowToTrainYourDragon character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker JapaneseMedia StudioGhibli movie":{"type":"method","name":"movie","children":[],"call":[" fetch "]}," Faker JapaneseMedia StudioGhibli quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker JapaneseMedia StudioGhibli character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker JapaneseMedia Naruto demon":{"type":"method","name":"demon","children":[],"call":[" fetch "]}," Faker JapaneseMedia Naruto eye":{"type":"method","name":"eye","children":[],"call":[" fetch "]}," Faker JapaneseMedia Naruto village":{"type":"method","name":"village","children":[],"call":[" fetch "]}," Faker JapaneseMedia Naruto character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker JapaneseMedia DragonBall planet":{"type":"method","name":"planet","children":[],"call":[" fetch "]}," Faker JapaneseMedia DragonBall race":{"type":"method","name":"race","children":[],"call":[" fetch "]}," Faker JapaneseMedia Doraemon location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker JapaneseMedia Doraemon gadget":{"type":"method","name":"gadget","children":[],"call":[" fetch "]}," Faker JapaneseMedia Doraemon character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker JapaneseMedia Conan vehicle":{"type":"method","name":"vehicle","children":[],"call":[" fetch "]}," Faker JapaneseMedia Conan gadget":{"type":"method","name":"gadget","children":[],"call":[" fetch "]}," Faker JapaneseMedia Conan character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games WorldOfWarcraft race":{"type":"method","name":"race","children":[],"call":[" fetch "]}," Faker Games WorldOfWarcraft class_name":{"type":"method","name":"class_name","children":[],"call":[" fetch "]}," Faker Games SuperMario location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games SuperMario game":{"type":"method","name":"game","children":[],"call":[" fetch "]}," Faker Games SuperMario character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games Minecraft status_effect":{"type":"method","name":"status_effect","children":[],"call":[" fetch "]}," Faker Games Minecraft game_mode":{"type":"method","name":"game_mode","children":[],"call":[" fetch "]}," Faker Games Minecraft enchantment":{"type":"method","name":"enchantment","children":[],"call":[" fetch "]}," Faker Games Minecraft biome":{"type":"method","name":"biome","children":[],"call":[" fetch "]}," Faker Games Minecraft achievement":{"type":"method","name":"achievement","children":[],"call":[" fetch "]}," Faker Games Heroes artifact":{"type":"method","name":"artifact","children":[],"call":[" fetch "]}," Faker Games ElderScrolls jewelry":{"type":"method","name":"jewelry","children":[],"call":[" fetch "]}," Faker Games ElderScrolls weapon":{"type":"method","name":"weapon","children":[],"call":[" fetch "]}," Faker Games ClashOfClans defensive_building":{"type":"method","name":"defensive_building","children":[],"call":[" fetch "]}," Faker Games ClashOfClans rank":{"type":"method","name":"rank","children":[],"call":[" fetch "]}," Faker Games ClashOfClans troop":{"type":"method","name":"troop","children":[],"call":[" fetch "]}," Faker Fantasy Tolkien poem":{"type":"method","name":"poem","children":[],"call":[" fetch "]}," Faker Fantasy Tolkien race":{"type":"method","name":"race","children":[],"call":[" fetch "]}," Faker Fantasy Tolkien location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Fantasy Tolkien character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Mountain range":{"type":"method","name":"range","children":[],"call":[" fetch "]}," Faker Mountain name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Military coast_guard_rank":{"type":"method","name":"coast_guard_rank","children":[],"call":[" fetch "]}," Faker Military space_force_rank":{"type":"method","name":"space_force_rank","children":[],"call":[" fetch "]}," Faker Finance ticker":{"type":"method","name":"ticker","children":[],"call":[" raise "," fetch "," sample ","markets empty? "," sample s empty? "]}," Faker Adjective negative":{"type":"method","name":"negative","children":[],"call":[" fetch "]}," Faker Adjective positive":{"type":"method","name":"positive","children":[],"call":[" fetch "]}," Faker Company spanish_b_algorithm":{"type":"method","name":"spanish_b_algorithm","children":[],"call":["result to_s [] to_i + ","result to_s [] to_i ","result to_s [] ","result to_s ","result < ","value to_i * ","value to_i ","value to_i *  to_s [] to_i + ","value to_i *  to_s [] to_i ","value to_i *  to_s [] ","value to_i *  to_s ","value to_i *  < "]}," Faker Company spanish_cif_control_digit":{"type":"method","name":"spanish_cif_control_digit","children":[],"call":["letters [] ","(str \"A\") include? ","10 - ","control zero? ","control to_s [] to_i ","control to_s [] ","control to_s ","sum + "," spanish_b_algorithm ","value to_i ","(send\n  (lvar :index) :+\n  (int 1)) even? ","index + ","code split each_with_index inject ","code split each_with_index ","code split ","code chars each_with_index inject ","code chars each_with_index ","code chars ","10 -  zero? ","control to_s [] to_i  zero? ","10 -  to_s [] to_i ","control to_s [] to_i  to_s [] to_i ","10 -  to_s [] ","control to_s [] to_i  to_s [] ","10 -  to_s ","control to_s [] to_i  to_s "]}," Faker Camera brand_with_model":{"type":"method","name":"brand_with_model","children":[],"call":[" fetch "]}," Faker Camera model":{"type":"method","name":"model","children":[],"call":[" fetch "]}," Faker Camera brand":{"type":"method","name":"brand","children":[],"call":[" fetch "]}," Faker Books Dune city":{"type":"method","name":"city","children":[],"call":[" fetch "]}," Faker Music RockBand song":{"type":"method","name":"song","children":[],"call":[" fetch "]}," Faker Games Touhou song":{"type":"method","name":"song","children":[],"call":[" fetch "]}," Faker Games Touhou spell_card":{"type":"method","name":"spell_card","children":[],"call":[" fetch "]}," Faker Games Touhou location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games Touhou character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games Touhou game":{"type":"method","name":"game","children":[],"call":[" fetch "]}," Faker Blockchain Tezos secret_key":{"type":"method","name":"secret_key","children":[],"call":[" encode_tz "]}," Faker Blockchain Tezos public_key":{"type":"method","name":"public_key","children":[],"call":[" encode_tz "]}," Faker Number binary":{"type":"method","name":"binary","children":[],"call":[" rand to_s "," rand ","digits times "]}," Faker Educator primary_school":{"type":"method","name":"primary_school","children":[],"call":[" parse "]}," Faker Bank iban_country_code":{"type":"method","name":"iban_country_code","children":[],"call":[" sample to_s upcase "," sample to_s "," sample "," translate keys "," translate "]}," Faker Music mambo_no_5":{"type":"method","name":"mambo_no_5","children":[],"call":[" fetch "]}," Faker Games Witcher book":{"type":"method","name":"book","children":[],"call":[" fetch "]}," Faker Games Witcher potion":{"type":"method","name":"potion","children":[],"call":[" fetch "]}," Faker Games Witcher sign":{"type":"method","name":"sign","children":[],"call":[" fetch "]}," Faker Tea type":{"type":"method","name":"type","children":[],"call":[" fetch "]}," Faker Tea variety":{"type":"method","name":"variety","children":[],"call":[" fetch ","type downcase "]}," Faker Science element_subcategory":{"type":"method","name":"element_subcategory","children":[],"call":[" fetch "]}," Faker Science element_state":{"type":"method","name":"element_state","children":[],"call":[" fetch "]}," Faker IDNumber croatian_id_checksum_digit":{"type":"method","name":"croatian_id_checksum_digit","children":[],"call":["control_sum % ","11 - ","control_sum zero? ","digits chars map each ","digits chars map ","digits chars ","11 -  % ","11 -  zero? "]}," Faker IDNumber croatian_id":{"type":"method","name":"croatian_id","children":[],"call":[" croatian_id_checksum_digit ","Faker Number  number to_s ","Faker Number  number "," croatian_id_ croatian_id_checksum_digit  "]}," Faker Crypto sha512":{"type":"method","name":"sha512","children":[],"call":["OpenSSL Digest SHA512  hexdigest ","Lorem  characters "]}," Faker Creature Bird order_with_common_name":{"type":"method","name":"order_with_common_name","children":[],"call":[" sample ","map [] ","o to_sym "," order ","tax_order nil? ","I18n  translate ","I18n  translate  [] "," order  t order _sym ","  order rder ","tax_ order rder nil? "]}," Faker Creature Bird implausible_common_name":{"type":"method","name":"implausible_common_name","children":[],"call":[" parse capitalize "," parse "]}," Faker Creature Bird plausible_common_name":{"type":"method","name":"plausible_common_name","children":[],"call":[" parse capitalize "," parse "]}," Faker Creature Bird common_name":{"type":"method","name":"common_name","children":[],"call":[" sample downcase "," sample "," translate [] ","tax_order to_sym "," translate "," raise ","map keys include? ","map keys ","tax_order respond_to? ","map values flatten ","map values ","tax_order nil? "," translate  keys include? "," translate  keys "," translate  values flatten "," translate  values "]}," Faker Creature Bird silly_adjective":{"type":"method","name":"silly_adjective","children":[],"call":[" fetch "]}," Faker Creature Bird emotional_adjective":{"type":"method","name":"emotional_adjective","children":[],"call":[" fetch "]}," Faker Creature Bird adjective":{"type":"method","name":"adjective","children":[],"call":[" fetch "]}," Faker Creature Bird color":{"type":"method","name":"color","children":[],"call":[" fetch "]}," Faker Creature Bird geo":{"type":"method","name":"geo","children":[],"call":[" fetch "]}," Faker Creature Bird anatomy_past_tense":{"type":"method","name":"anatomy_past_tense","children":[],"call":[" fetch "]}," Faker Creature Bird anatomy":{"type":"method","name":"anatomy","children":[],"call":[" fetch "]}," Faker Creature Bird order":{"type":"method","name":"order","children":[],"call":[" sample to_s "," sample ","I18n  translate keys ","I18n  translate "]}," Faker Creature Bird common_family_name":{"type":"method","name":"common_family_name","children":[],"call":[" fetch "]}," Faker TvShows TheOffice quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows TheOffice character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker TvShows Supernatural weapon":{"type":"method","name":"weapon","children":[],"call":[" fetch "]}," Faker TvShows Supernatural creature":{"type":"method","name":"creature","children":[],"call":[" fetch "]}," Faker TvShows Supernatural character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Australia state":{"type":"method","name":"state","children":[],"call":[" fetch "]}," Faker Australia animal":{"type":"method","name":"animal","children":[],"call":[" fetch "]}," Faker Australia location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Games Dota building":{"type":"method","name":"building","children":[],"call":[" fetch "]}," Faker Science tool":{"type":"method","name":"tool","children":[],"call":[" modifier ","tool start_with? "," loop "," fetch ","  modifier  "," fetch  start_with? "]}," Faker Science modifier":{"type":"method","name":"modifier","children":[],"call":[" fetch "]}," Faker Science science":{"type":"method","name":"science","children":[],"call":[" sample "," translate ","selected each "," raise ","selected empty? ","BRANCHES  [] ","BRANCHES  key? ","branches each ","BRANCHES  values flatten uniq ","BRANCHES  values flatten ","BRANCHES  values ","BRANCHES  values flatten uniq  each ","BRANCHES  values flatten uniq  empty? "]}," Faker Internet user":{"type":"method","name":"user","children":[],"call":["user_hash []= "," send ","args each ","args empty? "]}," Faker Hobby activity":{"type":"method","name":"activity","children":[],"call":[" fetch "]}," Faker Food ethnic_category":{"type":"method","name":"ethnic_category","children":[],"call":[" fetch "]}," Faker Finance stock_market":{"type":"method","name":"stock_market","children":[],"call":[" fetch "]}," Faker Emotion adjective":{"type":"method","name":"adjective","children":[],"call":[" fetch "]}," Faker Emotion noun":{"type":"method","name":"noun","children":[],"call":[" fetch "]}," Faker Commerce vendor":{"type":"method","name":"vendor","children":[],"call":[" fetch "]}," Faker Commerce brand":{"type":"method","name":"brand","children":[],"call":[" fetch "]}," Faker TvShows BrooklynNineNine quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows BrooklynNineNine character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Religion Bible quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Religion Bible location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Religion Bible character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker JapaneseMedia KamenRider from_eras":{"type":"method","name":"from_eras","children":[],"call":[" fetch ","selected_eras sample yield_self ","selected_eras sample "," raise ","selected_eras empty? "," block_given? ","(send\n  (begin\n    (send\n      (const nil :ERAS) :&\n      (lvar :input_eras))) :yield_self) dup "," eras ","selected empty? ","(send\n  (const nil :ERAS) :&\n  (lvar :input_eras)) yield_self ","ERAS  & ","selected_eras sample then ","(send\n  (begin\n    (send\n      (const nil :ERAS) :&\n      (lvar :input_eras))) :then) dup ","(send\n  (const nil :ERAS) :&\n  (lvar :input_eras)) then ","(send\n  (begin\n    (send\n      (const nil :ERAS) :&\n      (lvar :input_eras))) :yield_self) dup  sample yield_self ","(send\n  (begin\n    (send\n      (const nil :ERAS) :&\n      (lvar :input_eras))) :then) dup  sample yield_self ","(send\n  (begin\n    (send\n      (const nil :ERAS) :&\n      (lvar :input_eras))) :yield_self) dup  sample ","(send\n  (begin\n    (send\n      (const nil :ERAS) :&\n      (lvar :input_eras))) :then) dup  sample ","(send\n  (begin\n    (send\n      (const nil :ERAS) :&\n      (lvar :input_eras))) :yield_self) dup  empty? ","(send\n  (begin\n    (send\n      (const nil :ERAS) :&\n      (lvar :input_eras))) :then) dup  empty? ","(send\n  (begin\n    (send\n      (const nil :ERAS) :&\n      (lvar :input_eras))) :yield_self) dup  sample then ","(send\n  (begin\n    (send\n      (const nil :ERAS) :&\n      (lvar :input_eras))) :then) dup  sample then "]}," Faker JapaneseMedia KamenRider eras":{"type":"method","name":"eras","children":[],"call":[]}," Faker JapaneseMedia KamenRider transformation_device":{"type":"method","name":"transformation_device","children":[],"call":[" from_eras "]}," Faker JapaneseMedia KamenRider collectible_device":{"type":"method","name":"collectible_device","children":[],"call":["e delete "," from_eras "]}," Faker JapaneseMedia KamenRider series":{"type":"method","name":"series","children":[],"call":[" from_eras "]}," Faker JapaneseMedia KamenRider user":{"type":"method","name":"user","children":[],"call":[" from_eras "]}," Faker JapaneseMedia KamenRider kamen_rider":{"type":"method","name":"kamen_rider","children":[],"call":[" from_eras "]}," Faker JapaneseMedia KamenRider eras=":{"type":"method","name":"eras=","children":[],"call":["selected_eras empty? ","ERAS  & ","ERAS  &  empty? "]}," Faker JapaneseMedia FmaBrotherhood country":{"type":"method","name":"country","children":[],"call":[" fetch "]}," Faker JapaneseMedia FmaBrotherhood city":{"type":"method","name":"city","children":[],"call":[" fetch "]}," Faker JapaneseMedia FmaBrotherhood character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Omniauth auth0":{"type":"method","name":"auth0","children":[],"call":["Time  forward to_i ","Time  forward ","auth email ","Crypto  md5 ","Crypto  sha256 "," image ","auth name ","Omniauth  new ","Number  hexadecimal ","Omniauth  new  email ","Omniauth  new  name ","OmniOmniauth  new   new "]}," Faker Books TheKingkillerChronicle location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Books TheKingkillerChronicle creature":{"type":"method","name":"creature","children":[],"call":[" fetch "]}," Faker Books TheKingkillerChronicle character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Books TheKingkillerChronicle book":{"type":"method","name":"book","children":[],"call":[" fetch "]}," Faker Movies Tron vehicles":{"type":"method","name":"vehicles","children":[],"call":[" fetch_all "]}," Faker Movies Tron users":{"type":"method","name":"users","children":[],"call":[" fetch_all "]}," Faker Movies Tron taglines":{"type":"method","name":"taglines","children":[],"call":[" fetch_all "]}," Faker Movies Tron programs":{"type":"method","name":"programs","children":[],"call":[" fetch_all "]}," Faker Movies Tron locations":{"type":"method","name":"locations","children":[],"call":[" fetch_all "]}," Faker Movies Tron games":{"type":"method","name":"games","children":[],"call":[" fetch_all "]}," Faker Movies Tron characters":{"type":"method","name":"characters","children":[],"call":[" translate values flatten "," translate values "," translate "]}," Faker Movies Tron vehicle":{"type":"method","name":"vehicle","children":[],"call":[" sample "," vehicles "]}," Faker Movies Tron user":{"type":"method","name":"user","children":[],"call":[" sample "," users "]}," Faker Movies Tron tagline":{"type":"method","name":"tagline","children":[],"call":[" sample "," taglines "]}," Faker Movies Tron quote":{"type":"method","name":"quote","children":[],"call":[" fetch "," raise ","quoted_characters keys join ","quoted_characters keys ","quoted_characters key? ","character to_sym ","k to_s ","v include? "," translate each "," translate ","character to_s downcase ","character to_s "," sample to_s "," sample ","character nil? ","quoted_k to_s s keys join ","quoted_character to_s downcase s keys join ","quoted_ sample to_s s keys join "," translate  keys join ","quoted_k to_s s keys ","quoted_character to_s downcase s keys ","quoted_ sample to_s s keys "," translate  keys ","quoted_k to_s s key? ","quoted_character to_s downcase s key? ","quoted_ sample to_s s key? "," translate  key? ","k to_s  to_sym ","character to_s downcase  to_sym "," sample to_s  to_sym ","k to_s  to_s downcase ","character to_s downcase  to_s downcase "," sample to_s  to_s downcase ","k to_s  to_s ","character to_s downcase  to_s "," sample to_s  to_s ","k to_s  nil? ","character to_s downcase  nil? "," sample to_s  nil? "]}," Faker Movies Tron program":{"type":"method","name":"program","children":[],"call":[" sample "," programs "]}," Faker Movies Tron location":{"type":"method","name":"location","children":[],"call":[" sample "," locations "]}," Faker Movies Tron game":{"type":"method","name":"game","children":[],"call":[" sample "," games "]}," Faker Movies Tron character":{"type":"method","name":"character","children":[],"call":[" sample "," characters "]}," Faker Sports Mountaineering mountaineer":{"type":"method","name":"mountaineer","children":[],"call":[" fetch "]}," Faker Internet bot_user_agent":{"type":"method","name":"bot_user_agent","children":[],"call":[" sample ","agent_hash [] ","agent_hash keys ","vendor to_sym ","vendor respond_to? "," translate "," translate  [] "," translate  keys "]}," Faker UniqueGenerator marked_unique":{"type":"method","name":"marked_unique","children":[],"call":[]}," Faker UniqueGenerator previous_results":{"type":"method","name":"previous_results","children":[],"call":["hash []= ","Set  new ","Hash  new ","Thread  current [] [] ","Thread  current [] ","Thread  current "]}," Faker Config random=":{"type":"method","name":"random=","children":[],"call":["Thread  current []= ","Thread  current "]}," Faker Sport ancient_olympics_sport":{"type":"method","name":"ancient_olympics_sport","children":[],"call":[" fetch "]}," Faker Sport unusual_sport":{"type":"method","name":"unusual_sport","children":[],"call":[" fetch "]}," Faker Sport winter_paralympics_sport":{"type":"method","name":"winter_paralympics_sport","children":[],"call":[" fetch "]}," Faker Sport summer_paralympics_sport":{"type":"method","name":"summer_paralympics_sport","children":[],"call":[" fetch "]}," Faker Sport winter_olympics_sport":{"type":"method","name":"winter_olympics_sport","children":[],"call":[" fetch "]}," Faker Sport summer_olympics_sport":{"type":"method","name":"summer_olympics_sport","children":[],"call":[" fetch "]}," Faker Sport sport":{"type":"method","name":"sport","children":[],"call":[" sample ","sports << "," fetch_all "," fetch_all + + + "," fetch_all + + "," fetch_all + ","sports concat "," fetch_all + + +  << "," fetch_all + + +  concat "]}," Faker VulnerabilityIdentifier cve":{"type":"method","name":"cve","children":[],"call":[" rand_in_range to_s rjust "," rand_in_range to_s "," rand_in_range "]}," Faker Vehicle version":{"type":"method","name":"version","children":[],"call":[" fetch "]}," Faker IDNumber danish_control_digits":{"type":"method","name":"danish_control_digits","children":[],"call":[" raise ","year to_s slice to_i ","year to_s slice ","year to_s ","birthday year ","birthday year  to_s slice to_i ","birthday year  to_s slice ","birthday year  to_s ","birthday birthday year  "]}," Faker IDNumber french_insee_number":{"type":"method","name":"french_insee_number","children":[],"call":["(send\n  (int 97) :-\n  (lvar :mod)) to_s rjust ","(send\n  (int 97) :-\n  (lvar :mod)) to_s ","97 - ","num to_i % ","num to_i ","(send\n  (array\n    (int 1)\n    (int 2)) :sample\n  (hash\n    (pair\n      (sym :random)\n      (send\n        (const\n          (const nil :Faker) :Config) :random)))) join ","Faker Number  number ","Faker Number  between to_s rjust ","Faker Number  between to_s ","Faker Number  between ","(int 1) sample ","Faker Config  random ","(send\n  (int 97) :-\n  (lvar :num to_i % )) to_s rjust ","(send\n  (int 97) :-\n  (lvar :num to_i % )) to_s ","(send\n  (array\n    (int 1)\n    (int 2)) :sample\n  (hash\n    (pair\n      (sym :random)\n      (send\n        (const\n          (const nil :Faker) :Config) :random)))) join  to_i % ","(send\n  (array\n    (int 1)\n    (int 2)) :sample\n  (hash\n    (pair\n      (sym :random)\n      (send\n        (const\n          (const nil :Faker) :Config) :random)))) join  to_i ","Faker Number  (send\n  (array\n    (int 1)\n    (int 2)) :sample\n  (hash\n    (pair\n      (sym :random)\n      (send\n        (const\n          (const nil :Faker) :Config) :random)))) join ber "]}," Faker IDNumber danish_id_number":{"type":"method","name":"danish_id_number","children":[],"call":["(send\n  (lvar :birthday) :strftime\n  (str \"%d%m%y\")) join ","Faker Number  number ","birthday strftime "," raise "," sample ","digits select ","gender to_sym ","gender respond_to? ","(irange\n  (int 0)\n  (int 9)) to_a "," danish_control_digits ","(irange\n  (int 0)\n  (int 9)) to_a  select ","gender to_sym  to_sym ","gender to_sym  respond_to? "," danish_control_(irange\n  (int 0)\n  (int 9)) to_a  "," danish_ sample s "]}," Faker Finance condominium_fiscal_code":{"type":"method","name":"condominium_fiscal_code","children":[],"call":[" numerify "," fetch "]}," Faker Movies Hackers quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies Hackers handle":{"type":"method","name":"handle","children":[],"call":[" fetch "]}," Faker Movies Hackers character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games Tarkov fence_quest":{"type":"method","name":"fence_quest","children":[],"call":[" fetch "]}," Faker Games Tarkov jaeger_quest":{"type":"method","name":"jaeger_quest","children":[],"call":[" fetch "]}," Faker Games Tarkov ragman_quest":{"type":"method","name":"ragman_quest","children":[],"call":[" fetch "]}," Faker Games Tarkov mechanic_quest":{"type":"method","name":"mechanic_quest","children":[],"call":[" fetch "]}," Faker Games Tarkov peacekeeper_quest":{"type":"method","name":"peacekeeper_quest","children":[],"call":[" fetch "]}," Faker Games Tarkov skier_quest":{"type":"method","name":"skier_quest","children":[],"call":[" fetch "]}," Faker Games Tarkov therapist_quest":{"type":"method","name":"therapist_quest","children":[],"call":[" fetch "]}," Faker Games Tarkov prapor_quest":{"type":"method","name":"prapor_quest","children":[],"call":[" fetch "]}," Faker Games Tarkov quest":{"type":"method","name":"quest","children":[],"call":[" fetch ","@traders sample "]}," Faker Games Tarkov faction":{"type":"method","name":"faction","children":[],"call":[" fetch "]}," Faker Games Tarkov boss":{"type":"method","name":"boss","children":[],"call":[" fetch "]}," Faker Games Tarkov weapon":{"type":"method","name":"weapon","children":[],"call":[" fetch "]}," Faker Games Tarkov item":{"type":"method","name":"item","children":[],"call":[" fetch "]}," Faker Games Tarkov trader":{"type":"method","name":"trader","children":[],"call":[" fetch "]}," Faker Games Tarkov location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker Color hsl_to_hex":{"type":"method","name":"hsl_to_hex","children":[],"call":[" format ","rgb [] ","(send\n  (begin\n    (send\n      (lvar :value) :+\n      (lvar :m))) :*\n  (int 255)) round ","(send\n  (lvar :value) :+\n  (lvar :m)) * ","value + ","(send\n  (lvar :h_prime) :to_i) map ","h_prime to_i ","l - ","0.5 * ","c * ","1 - ","(send\n  (send\n    (lvar :h_prime) :%\n    (int 2)) :-\n  (int 1)) abs ","h_prime % - ","h_prime % ","h / ","(send\n  (int 1) :-\n  (send\n    (begin\n      (send\n        (send\n          (int 2) :*\n          (lvar :l)) :-\n        (int 1))) :abs)) * ","(send\n  (send\n    (int 2) :*\n    (lvar :l)) :-\n  (int 1)) abs ","2 * - ","2 * "," forl - at ","(send\n  (begin\n    (send\n      (lvar :value) :+\n      (lvar :l - ))) :*\n  (int 255)) round ","(send\n  (lvar :value) :+\n  (lvar :l - )) * ","(send\n  (lvar :h_pril - e) :to_i) l - ap ","(send\n  (lvar :h / ) :to_i) map ","h_pril - e to_i ","h /  to_i ","(send\n  (int 1) :-\n  (send\n    (begin\n      (send\n        (send\n          (int 2) :*\n          (lvar :l)) :-\n        (int 1))) :abs)) *  * ","(send\n  (send\n    (lvar :h_pril - e) :%\n    (int 2)) :-\n  (int 1)) abs ","(send\n  (send\n    (lvar :h / ) :%\n    (int 2)) :-\n  (int 1)) abs ","h_pril - e % - ","h /  % - ","h_pril - e % ","h /  % "]}," Faker TvShows Spongebob episode":{"type":"method","name":"episode","children":[],"call":[" fetch "]}," Faker TvShows Spongebob quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows Spongebob character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker JapaneseMedia CowboyBebop quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker JapaneseMedia CowboyBebop song":{"type":"method","name":"song","children":[],"call":[" fetch "]}," Faker JapaneseMedia CowboyBebop episode":{"type":"method","name":"episode","children":[],"call":[" fetch "]}," Faker JapaneseMedia CowboyBebop character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Travel Airport iata":{"type":"method","name":"iata","children":[],"call":[" p "," fetch "]}," Faker Travel Airport name":{"type":"method","name":"name","children":[],"call":[" p "," fetch "]}," Faker Sports Chess title":{"type":"method","name":"title","children":[],"call":[" fetch "]}," Faker Sports Chess opening":{"type":"method","name":"opening","children":[],"call":[" fetch "]}," Faker Sports Chess rating":{"type":"method","name":"rating","children":[],"call":["Faker Base  rand_in_range "]}," Faker Sports Chess tournament":{"type":"method","name":"tournament","children":[],"call":[" fetch "]}," Faker Sports Chess federation":{"type":"method","name":"federation","children":[],"call":["Faker Address  country_code_long "]}," Faker Sports Chess player":{"type":"method","name":"player","children":[],"call":[" fetch "]}," Faker Quote mitch_hedberg":{"type":"method","name":"mitch_hedberg","children":[],"call":[" fetch "]}," Faker Movies Avatar quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker Movies Avatar date":{"type":"method","name":"date","children":[],"call":[" fetch "]}," Faker Movies Avatar character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Games DnD title_name":{"type":"method","name":"title_name","children":[],"call":[" fetch "]}," Faker Games DnD name":{"type":"method","name":"name","children":[],"call":[" fetch "]}," Faker Games DnD last_name":{"type":"method","name":"last_name","children":[],"call":[" fetch "]}," Faker Games DnD first_name":{"type":"method","name":"first_name","children":[],"call":[" fetch "]}," Faker Food allergen":{"type":"method","name":"allergen","children":[],"call":[" fetch "]}," Faker Company department":{"type":"method","name":"department","children":[],"call":[" fetch "]}," PositionalGenerator Builder Computed generate":{"type":"method","name":"generate","children":[],"call":["@block call "]}," PositionalGenerator Builder Computed initialize":{"type":"method","name":"initialize","children":[],"call":[]}," PositionalGenerator Builder Literal generate":{"type":"method","name":"generate","children":[],"call":[]}," PositionalGenerator Builder Literal initialize":{"type":"method","name":"initialize","children":[],"call":[]}," PositionalGenerator Builder Letter char":{"type":"method","name":"char","children":[],"call":["Faker Base  sample "," raise ","s inspect ","s sample ","Faker Config  random ","s to_a sample ","s to_a ","@ranges sample ","Faker Ba@ranges sample e  @ranges sample ample "," rai@ranges sample e ","@ranges sample  in@ranges sample pect ","@ranges sample  @ranges sample ample ","@ranges sample  to_a @ranges sample ample ","@ranges sample  to_a ","@range@ranges sample  @ranges sample ample "]}," PositionalGenerator Builder Letter generate":{"type":"method","name":"generate","children":[],"call":[" char ","@length times inject ","@length times "]}," PositionalGenerator Builder Letter initialize":{"type":"method","name":"initialize","children":[],"call":[]}," PositionalGenerator Builder Int generate":{"type":"method","name":"generate","children":[],"call":["Faker Base  rand ","@ranges sample ","Faker Config  random "]}," PositionalGenerator Builder Int initialize":{"type":"method","name":"initialize","children":[],"call":["(send\n  (int 10) :**\n  (lvar :length)) - ","10 ** ","length - ","ranges nil? "]}," PositionalGenerator Builder Oneof OneofSelector generate":{"type":"method","name":"generate","children":[],"call":["@builder build "]}," PositionalGenerator Builder Oneof OneofSelector sample":{"type":"method","name":"sample","children":[],"call":["@builder send ","Faker Base  sample "]}," PositionalGenerator Builder Oneof OneofSelector respond_to_missing?":{"type":"method","name":"respond_to_missing?","children":[],"call":["@builder respond_to? "]}," PositionalGenerator Builder Oneof OneofSelector method_missing":{"type":"method","name":"method_missing","children":[],"call":["@subgens << "]}," PositionalGenerator Builder Oneof OneofSelector initialize":{"type":"method","name":"initialize","children":[],"call":["Builder  new ","builder as_type "]}," PositionalGenerator Builder Oneof generate":{"type":"method","name":"generate","children":[],"call":["subgens generate ","subgens sample ","@block call ","OneofSelector  new ","OneofSelector  new  generate ","OneofSelector  new  sample "]}," PositionalGenerator Builder Oneof initialize":{"type":"method","name":"initialize","children":[],"call":[]}," PositionalGenerator Builder Group generate":{"type":"method","name":"generate","children":[],"call":["builder build ","@block call ","Builder  new ","Builder  new  build "]}," PositionalGenerator Builder Group initialize":{"type":"method","name":"initialize","children":[],"call":[]}," PositionalGenerator Builder convert":{"type":"method","name":"convert","children":[],"call":[" raise ","values inject "]}," PositionalGenerator Builder generate_values":{"type":"method","name":"generate_values","children":[],"call":["result sort_by ","result << ","component generator generate ","component generator ","component name ","component position ","component deps include? ","component deps ","result filter_map "," raise ","component nil? ","@components [] ","top each ","stack pop ","@components []  generator generate ","@components []  generator ","@components []  name ","@components []  position ","@components []  deps include? ","@components []  deps ","@components []  nil? ","@@components [] s [] ","stack pop  each "]}," PositionalGenerator Builder build_stack":{"type":"method","name":"build_stack","children":[],"call":["deps empty? ","stack << ","deps any? ","seen << ","(send\n  (lvar :graph) :select) map ","seen include? ! ","seen include? ","to == ","graph select ","stack [] each ","stack [] "," loop ","Set  new ","to nil? ","graph filter_map "," require ","Set  new  << ","Set  new  include? ! ","Set  new  include? "]}," PositionalGenerator Builder build_graph":{"type":"method","name":"build_graph","children":[],"call":["graph push ","component position ","from == ","graph none? ","@components each ","dep_component position "," raise ","dep_component nil? ","c name == ","c name ","@components detect ","component deps each ","component deps "]}," PositionalGenerator Builder build":{"type":"method","name":"build","children":[],"call":[" convert "," generate_values "," build_stack "," build_graph "," generate_ generate_values  "," build_ build_stack  "," build_ build_graph  "]}," PositionalGenerator Builder group":{"type":"method","name":"group","children":[],"call":["@components << ","Component  new ","Group  new ","@components count "]}," PositionalGenerator Builder oneof":{"type":"method","name":"oneof","children":[],"call":["@components << ","Component  new ","Oneof  new ","@components count "]}," PositionalGenerator Builder computed":{"type":"method","name":"computed","children":[],"call":["@components << ","Component  new ","Computed  new ","@components count "]}," PositionalGenerator Builder lit":{"type":"method","name":"lit","children":[],"call":["@components << ","Component  new ","Literal  new ","@components count "]}," PositionalGenerator Builder letter":{"type":"method","name":"letter","children":[],"call":["@components << ","Component  new ","Letter  new ","@components count "]}," PositionalGenerator Builder int":{"type":"method","name":"int","children":[],"call":["@components << ","Component  new ","Int  new ","@components count "]}," PositionalGenerator Builder initialize":{"type":"method","name":"initialize","children":[],"call":[]}," PositionalGenerator generate":{"type":"method","name":"generate","children":[],"call":["@generator_builder build ","@block call "]}," PositionalGenerator initialize":{"type":"method","name":"initialize","children":[],"call":["Builder  new "]}," Faker Base generate":{"type":"method","name":"generate","children":[],"call":["PositionalGenerator  new generate ","PositionalGenerator  new "]}," Faker TvShows SouthPark episode_name":{"type":"method","name":"episode_name","children":[],"call":[" fetch "]}," Faker TvShows Archer quote":{"type":"method","name":"quote","children":[],"call":[" fetch "]}," Faker TvShows Archer location":{"type":"method","name":"location","children":[],"call":[" fetch "]}," Faker TvShows Archer character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker Travel TrainStation validate_arguments":{"type":"method","name":"validate_arguments","children":[],"call":[" raise ","correct_values join ","correct_values include? "]}," Faker Travel TrainStation fill_missing_inputs_with_samples":{"type":"method","name":"fill_missing_inputs_with_samples","children":[],"call":[" sample "," validate_arguments ","type nil? ","region nil? "," sample  nil? "]}," Faker Travel TrainStation name":{"type":"method","name":"name","children":[],"call":[" fetch "," fill_missing_inputs_with_samples "]}," Faker Games FinalFantasyXIV zone":{"type":"method","name":"zone","children":[],"call":[" fetch "]}," Faker Games FinalFantasyXIV data_center":{"type":"method","name":"data_center","children":[],"call":[" fetch "]}," Faker Games FinalFantasyXIV race":{"type":"method","name":"race","children":[],"call":[" fetch "]}," Faker Games FinalFantasyXIV job":{"type":"method","name":"job","children":[],"call":[" fetch "]}," Faker Games FinalFantasyXIV character":{"type":"method","name":"character","children":[],"call":[" fetch "]}," Faker HTML generate_table_row":{"type":"method","name":"generate_table_row","children":[],"call":["tag == ","Lorem  word ","cell_count times "]}," Faker HTML available_methods":{"type":"method","name":"available_methods","children":[],"call":["(send\n  (send\n    (const nil :HTML) :public_methods\n    (false)) :-\n  (send\n    (const nil :Base) :methods)) sort ","HTML  public_methods - ","Base  methods ","HTML  public_methods "]}," Faker HTML sandwich":{"type":"method","name":"sandwich","children":[],"call":["text_block join ","text_block << "," random "," paragraph ","repeat times "," heading "]}," Faker HTML random":{"type":"method","name":"random","children":[],"call":[" send ","method_list [] ","Faker Config  random rand ","method_list length - ","method_list length ","Faker Config  random ","meth == ","ex to_sym ","method_list delete_if ","exclude each "," available_methods "," available_methods  [] "," available_methods  length - "," available_methods  length "," available_methods  delete_if "]}," Faker HTML element":{"type":"method","name":"element","children":[],"call":["(send\n  (lvar :attributes) :map) join ","attributes map "]}," Faker HTML link":{"type":"method","name":"link","children":[],"call":["Faker Internet  url "]}," Faker HTML script":{"type":"method","name":"script","children":[],"call":["Faker Internet  url "]}," Faker HTML table":{"type":"method","name":"table","children":[],"call":["body_rows join ","body_rows << "," generate_table_row ","3 times ","body_ generate_table_row s join ","body_ generate_table_row s << "," generate_table_ generate_table_row  "]}," Faker HTML code":{"type":"method","name":"code","children":[],"call":["Lorem  sentence "]}," Faker HTML unordered_list":{"type":"method","name":"unordered_list","children":[],"call":["items join ","items << ","Faker Lorem  sentence ","number times "," rand "," rand  times "]}," Faker HTML ordered_list":{"type":"method","name":"ordered_list","children":[],"call":["items join ","items << ","Faker Lorem  sentence ","number times "," rand "," rand  times "]}," Faker HTML emphasis":{"type":"method","name":"emphasis","children":[],"call":["Faker Lorem  paragraph "]}," Faker HTML paragraph":{"type":"method","name":"paragraph","children":[],"call":["Faker Lorem  paragraph "]}," Faker HTML heading":{"type":"method","name":"heading","children":[],"call":["Lorem  word capitalize ","Lorem  word "," rand "]}," Faker Date on_day_of_week_between":{"type":"method","name":"on_day_of_week_between","children":[],"call":[" raise ","DAYS_OF_WEEK  [] capitalize ","DAYS_OF_WEEK  [] ","date wday ","date < ","date > "," sample - "," sample ","numeric_weekdays include? ","Faker Base  rand_in_range "," get_date_object ","DAYS_OF_WEEK  index ","d to_sym downcase ","d to_sym ","days map ","days empty? ","(lvar :day) flatten ","Faker Base  rand_in_range  wday ","Faker Base  rand_in_range  < ","Faker Base  rand_in_range  > ","numeric_week(lvar :day) flatten  include? "," get_Faker Base  rand_in_range _object ","d  get_date_object _sym downcase ","d  get_date_object _sym ","(lvar :day) flatten  map ","(lvar :day) flatten  empty? "]}," Faker ChileRut format_rut":{"type":"method","name":"format_rut","children":[],"call":["rut to_s reverse gsub reverse ","rut to_s reverse gsub ","rut to_s reverse ","rut to_s "]}," Faker Music SmashingPumpkins song":{"type":"method","name":"song","children":[],"call":[" fetch "]}," Faker Music SmashingPumpkins lyric":{"type":"method","name":"lyric","children":[],"call":[" fetch "]}," Faker Music SmashingPumpkins album":{"type":"method","name":"album","children":[],"call":[" fetch "]}," Faker Music SmashingPumpkins musician":{"type":"method","name":"musician","children":[],"call":[" fetch "]}," Faker Company calculate_gst_checksum":{"type":"method","name":"calculate_gst_checksum","children":[],"call":["chars [] ","(send\n  (send\n    (lvar :chars) :length) :-\n  (begin\n    (send\n      (lvar :sum) :%\n      (send\n        (lvar :chars) :length)))) % ","chars length ","chars length - ","sum % ","(send\n  (send\n    (lvar :values) :map) :with_index) reduce ","(send\n  (lvar :product) :/\n  (send\n    (lvar :chars) :length)) floor + ","product % ","(send\n  (lvar :product) :/\n  (send\n    (lvar :chars) :length)) floor ","product / ","chars index * ","index odd? ","chars index ","values map with_index ","values map ","gst_base upcase chars ","gst_base upcase ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  [] ","(send\n  (send\n    (lvar :chars) :length) :-\n  (begin\n    (send\n      (lvar :(send\n  (send\n    (lvar :values) :map) :with_index) reduce ) :%\n      (send\n        (lvar :chars) :length)))) % ","(send\n  (send\n    (lvar :0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars ) :length) :-\n  (begin\n    (send\n      (lvar :sum) :%\n      (send\n        (lvar :0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars ) :length)))) % ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  length ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  length - ","(send\n  (send\n    (lvar :values) :map) :with_index) reduce  % ","(send\n  (send\n    (lvar :gst_base upcase chars ) :map) :with_index) reduce ","(send\n  (lvar :chars index * ) :/\n  (send\n    (lvar :chars) :length)) floor + ","(send\n  (lvar :product) :/\n  (send\n    (lvar :0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars ) :length)) floor + ","chars index *  % ","(send\n  (lvar :chars index * ) :/\n  (send\n    (lvar :chars) :length)) floor ","(send\n  (lvar :product) :/\n  (send\n    (lvar :0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars ) :length)) floor ","chars index *  / ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  index * ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  index ","gst_base upcase chars  map with_index ","gst_base upcase chars  map ","gst_base upcase 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  "]}," Faker Company indian_gst_number":{"type":"method","name":"indian_gst_number","children":[],"call":["(send\n  (const nil :PositionalGenerator) :new\n  (sym :string)) generate ","chars [] ","(send\n  (send\n    (lvar :chars) :length) :-\n  (begin\n    (send\n      (lvar :sum) :%\n      (send\n        (lvar :chars) :length)))) % ","chars length ","chars length - ","sum % ","(send\n  (send\n    (lvar :values) :map) :with_index) reduce ","(send\n  (lvar :product) :/\n  (send\n    (lvar :chars) :length)) floor + ","product % ","(send\n  (lvar :product) :/\n  (send\n    (lvar :chars) :length)) floor ","product / ","chars index * ","index odd? ","chars index ","values map with_index ","values map ","gst_base chars ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars ","gen computed ","gen letter ","gen int ","g_ letter ","g_ int ","(array\n  (str \"A\")\n  (str \"B\")\n  (str \"C\")\n  (str \"F\")\n  (str \"G\")\n  (str \"H\")\n  (str \"L\")\n  (str \"J\")\n  (str \"P\")\n  (str \"T\")\n  (str \"K\")) to_a ","gen group ","gen lit ","PositionalGenerator  new "," raise ","(or\n  (send\n    (send\n      (lvar :state_code_ranges) :[]\n      (int 0)) :include?\n    (lvar :state_code))\n  (send\n    (lvar :state_code) :==\n    (str \"98\"))) ! ","state_code == ","state_code_ranges [] include? ","state_code_ranges [] ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  [] ","(send\n  (send\n    (lvar :chars) :length) :-\n  (begin\n    (send\n      (lvar :(send\n  (send\n    (lvar :values) :map) :with_index) reduce ) :%\n      (send\n        (lvar :chars) :length)))) % ","(send\n  (send\n    (lvar :0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars ) :length) :-\n  (begin\n    (send\n      (lvar :sum) :%\n      (send\n        (lvar :0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars ) :length)))) % ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  length ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  length - ","(send\n  (send\n    (lvar :values) :map) :with_index) reduce  % ","(send\n  (send\n    (lvar :gst_base chars ) :map) :with_index) reduce ","(send\n  (lvar :chars index * ) :/\n  (send\n    (lvar :chars) :length)) floor + ","(send\n  (lvar :product) :/\n  (send\n    (lvar :0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars ) :length)) floor + ","chars index *  % ","(send\n  (lvar :chars index * ) :/\n  (send\n    (lvar :chars) :length)) floor ","(send\n  (lvar :product) :/\n  (send\n    (lvar :0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars ) :length)) floor ","chars index *  / ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  index * ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  index ","gst_base chars  map with_index ","gst_base chars  map ","gst_base 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  ","0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ chars  "]}}