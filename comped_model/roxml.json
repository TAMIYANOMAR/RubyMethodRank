{" ROXML String to_latin":{"type":"method","name":"to_latin","children":[],"call":["STDERR  << ","Iconv  new iconv ","Iconv  new "]}," ROXML String to_utf":{"type":"method","name":"to_utf","children":[],"call":["STDERR  << ","Iconv  new iconv ","Iconv  new "]}," ROXML method_missing":{"type":"method","name":"method_missing","children":[],"call":[" class __send__ "," class ","name id2name =~ ","name id2name "]}," ROXML to_xml":{"type":"method","name":"to_xml","children":[],"call":["ref update_xml "," __send__ ","ref accessor "," tag_refs each "," tag_refs ","REXML Element  new "," tag_name "]}," ROXML included":{"type":"method","name":"included","children":[],"call":["klass __send__ "]}," ROXML ROXML_Class add_accessor":{"type":"method","name":"add_accessor","children":[],"call":[" instance_variable_set "," define_method "," instance_methods include? "," instance_methods ","Array  new ","val nil? "," instance_variable_get "," assert_accessor ","Array  new  nil? "," instance_variable_get  nil? "]}," ROXML ROXML_Class assert_accessor":{"type":"method","name":"assert_accessor","children":[],"call":["@tag_accessors << "," raise ","@tag_accessors include? "]}," ROXML ROXML_Class add_ref":{"type":"method","name":"add_ref","children":[],"call":["@xml_refs << "]}," ROXML ROXML_Class tag_refs":{"type":"method","name":"tag_refs","children":[],"call":[]}," ROXML ROXML_Class tag_name":{"type":"method","name":"tag_name","children":[],"call":[" name downcase "," name "," name split last downcase "," name split last "," name split "]}," ROXML ROXML_Class xml_object":{"type":"method","name":"xml_object","children":[],"call":[" add_accessor ","ref array ","TAG_READONLY  & != ","TAG_READONLY  & "," add_ref ","r klass= ","r wrapper= ","r array= ","TAG_ARRAY  & == ","TAG_ARRAY  & ","XMLObjectRef  new "]}," ROXML ROXML_Class xml_text":{"type":"method","name":"xml_text","children":[],"call":[" add_accessor ","ref array ","TAG_READONLY  & != ","TAG_READONLY  & "," add_ref ","r wrapper= ","r array= ","TAG_ARRAY  & == ","TAG_ARRAY  & ","r cdata= ","TAG_CDATA  & == ","TAG_CDATA  & ","XMLTextRef  new ","r text_content= ","TEXT_CONTENT  & == ","TEXT_CONTENT  & "]}," ROXML ROXML_Class xml_attribute":{"type":"method","name":"xml_attribute","children":[],"call":[" add_accessor ","TAG_READONLY  & != ","TAG_READONLY  & "," add_ref ","XMLAttributeRef  new "]}," ROXML ROXML_Class xml_name":{"type":"method","name":"xml_name","children":[],"call":[]}," ROXML ROXML_Class parse":{"type":"method","name":"parse","children":[],"call":["ref populate "," tag_refs each "," tag_refs "," allocate ","REXML Document  new root ","REXML Document  new ","data kind_of? "]}," ROXML XMLObjectRef populate":{"type":"method","name":"populate","children":[],"call":["instance instance_variable_set "," accessor "," klass parse "," klass ","xml elements [] "," klass tag_name ","xml elements ","data << ","xml each_element "," wrapper "," array "," klass parse  << "]}," ROXML XMLObjectRef update_xml":{"type":"method","name":"update_xml","children":[],"call":["parent add_element ","value to_xml ","v to_xml ","value each "," array ","xml add_element "," wrapper ","xml add_child ","node content= ","XML Node  create "," name ","value is_a? "," array? "," opts namespace "," opts "," wrap tap "," wrap ","XML  set_content ","XML  add_node tap ","XML  add_node ","XML  add_child ","XML Node  create  content= ","XML  add_XML Node  create  tap ","XML  add_XML Node  create  "]}," ROXML XMLTextRef populate":{"type":"method","name":"populate","children":[],"call":["instance instance_variable_set "," accessor ","child text ","xml elements [] "," name ","xml elements ","data << ","e text strip to_latin ","e text strip ","e text ","xml each_element "," wrapper "," array ","xml text "," text_content ","xml elements []  text ","child text  << ","xml text  << "]}," ROXML XMLTextRef update_xml":{"type":"method","name":"update_xml","children":[],"call":["parent add_element text= ","value to_s to_utf ","value to_s ","REXML CData  new "," cdata ","parent add_element "," name ","v to_s to_utf ","v to_s ","value each "," array ","xml add_element "," wrapper ","parent text= "," text_content "," add ","xml add_child ","XML Node  create "," array? ","xml name= "," name? "," content? "," wrap tap "," wrap ","XML  add_node "]}," ROXML XMLAttributeRef populate":{"type":"method","name":"populate","children":[],"call":["instance instance_variable_set ","xml attributes [] "," name ","xml attributes "," accessor "]}," ROXML XMLAttributeRef update_xml":{"type":"method","name":"update_xml","children":[],"call":["xml attributes []= ","value to_s to_utf ","value to_s "," name ","xml attributes ","values to_s "," wrap tap "," wrap ","node attributes []= ","node attributes ","values each "," array? ","XML  set_attribute "]}," ROXML XMLRef populate":{"type":"method","name":"populate","children":[],"call":["instance instance_variable_set "," variable_name "," value "]}," ROXML XMLRef update_xml":{"type":"method","name":"update_xml","children":[],"call":[" write_xml "," returning "," wrap "]}," ROXML XMLRef initialize":{"type":"method","name":"initialize","children":[],"call":[" block_given? ","accessor id2name "]}," ROXML ClassMethods Operations parse":{"type":"method","name":"parse","children":[],"call":[" from_xml "]}," ROXML ClassMethods Operations from_xml":{"type":"method","name":"from_xml","children":[],"call":[" new ","ref value ","(send\n  (send nil :xml_construction_args_without_deprecation) :map) map ","ref accessor == ","ref accessor "," tag_refs find "," tag_refs "," xml_construction_args_without_deprecation map "," xml_construction_args_without_deprecation ","inst send ","ref populate "," tag_refs each "," returning "," allocate "," xml_construction_args_without_deprecation empty? ","XML Parser  parse root ","XML Parser  parse ","data kind_of? ","attr to_ref value_in ","attr to_ref ","attr accessor == ","attr accessor "," roxml_attrs find "," roxml_attrs ","inst instance_variable_set ","attr variable_name "," roxml_attrs each ","XML Node  from "," raise ","e message + ","e message ","inst try ","inst respond_to? ","attr instance_variable_name ","attr setter "," new tap ","ref opts instance_variable_name ","ref opts ","ref opts setter ","ref value_in ","inst roxml_references each ","inst roxml_references ","inst roxml_references= "," roxml_attrs map ","ref attr to_ref value_in  ","ref ref value_in  ","(send\n  (send nil :XML Node  from _construction_args_without_deprecation) :map) map "," XML Node  from _construction_args_without_deprecation map "," XML Node  from _construction_args_without_deprecation "," XML Node  from _construction_args_without_deprecation empty? ","attr to_ref attr to_ref value_in _in ","attr to_ref ref value_in _in "," roXML Node  from _attrs find "," roXML Node  from _attrs "," roXML Node  from _attrs each ","ref attr to_ref value_in _in ","ref ref value_in _in ","inst roXML Node  from _references each ","inst roXML Node  from _references ","inst roXML Node  from _references= "," roXML Node  from _attrs map "]}," ROXML ClassMethods Accessors tag_refs":{"type":"method","name":"tag_refs","children":[],"call":[" superclass tag_refs clone "," superclass tag_refs "," superclass "," superclass respond_to? ","a to_ref "," roxml_attrs map "," roxml_attrs "]}," ROXML ClassMethods Accessors tag_name":{"type":"method","name":"tag_name","children":[],"call":[" name split last downcase "," name split last "," name split "," name ","tag_name downcase "," roxml_naming_convention call ","tag_name underscore "," roxml_naming_convention "," roxml_tag_name "," name split last  downcase "," name split last  underscore "," roxml_ name split last  "]}," ROXML ClassMethods Accessors xml_construction_args":{"type":"method","name":"xml_construction_args","children":[],"call":[]}," ROXML ClassMethods Declarations add_accessor":{"type":"method","name":"add_accessor","children":[],"call":[" instance_variable_set ","ref accessor "," define_method "," instance_methods include? ! "," instance_methods include? "," instance_methods ","ref variable_name ","ref default ","result nil? "," instance_variable_get "," tag_refs << "," tag_refs "," raise "," name "," tag_refs map include? "," tag_refs map "," attr_writer ","attr accessor ","attr variable_name ","attr default ","@roxml_attrs << "," roxml_attrs map include? "," roxml_attrs map "," roxml_attrs ","ref default  nil? "," instance_variable_get  nil? ","attr default  nil? "]}," ROXML ClassMethods Declarations xml_construct":{"type":"method","name":"xml_construct","children":[],"call":[" raise ","All construction tags must be declared first using xml,  + + ","present_tags join ","All construction tags must be declared first using xml,  + ","missing_tags join ","missing_tags empty? ","args - "," tag_refs map "," tag_refs "," tag_refs_without_deprecation map "," tag_refs_without_deprecation "," tag_refs map  join "," tag_refs_without_deprecation map  join ","args -  join ","args -  empty? "]}," ROXML ClassMethods Declarations xml_accessor":{"type":"method","name":"xml_accessor","children":[],"call":[" xml "," xml_reference "," attr_writer ","attr variable_name "," add_reader "," xml_attr ","attr attr_name "," xml_attr each ","  xml_attr _writer "," xml_attr  variable_name "," xml_ xml_attr  "," xml_attr   xml_attr _name "," xml_ xml_attr  each "]}," ROXML ClassMethods Declarations xml_reader":{"type":"method","name":"xml_reader","children":[],"call":[" xml "," xml_reference "," add_reader "," xml_attr "," xml_attr each "," xml_ xml_attr  "," xml_ xml_attr  each "]}," ROXML ClassMethods Declarations xml":{"type":"method","name":"xml","children":[],"call":[" add_accessor ","(send\n  (lvar :opts) :type) new "," raise ","opts type ","Opts  new ","(lvar :type_and_or_opts) compact "," xml_reference "," send ","(send\n  (lvar :Opts  new ) :type) new ","Opts  new  type ","(lvar :type_and_or_Opts  new ) compact "," xml_(send\n  (lvar :opts) :type) new erence "]}," ROXML ClassMethods Declarations xml_name":{"type":"method","name":"xml_name","children":[],"call":[]}," ROXML ClassMethods Declarations xml_name?":{"type":"method","name":"xml_name?","children":[],"call":[]}," ROXML InstanceMethods Conversions to_xml":{"type":"method","name":"to_xml","children":[],"call":["ref update_xml ","v nil? "," __send__ ","ref accessor "," tag_refs each "," tag_refs "," returning ","XML Node  new_element "," tag_name ","ref to_xml ","attr to_ref "," class roxml_attrs each "," class roxml_attrs "," class "," class tag_name ","XML Node  new ","(or\n  (lvar :name)\n  (send\n    (send\n      (self) :class) :tag_name)) to_s ","attr to_ref  update_xml "," __send__  nil? ","ref to_xml  nil? ","attr to_ref  accessor "," tag_attr to_ref s each "," tag_attr to_ref s ","attr to_ref  to_xml ","attr to_attr to_ref  ","(or\n  (l __send__ ar :name)\n  (send\n    (send\n      (self) :class) :tag_name)) to_s ","(or\n  (lref to_xml ar :name)\n  (send\n    (send\n      (self) :class) :tag_name)) to_s "]}," ROXML InstanceMethods Construction xml_initialize":{"type":"method","name":"xml_initialize","children":[],"call":[]}," ROXML InstanceMethods Accessors tag_refs":{"type":"method","name":"tag_refs","children":[],"call":[" class tag_refs "," class "," class tag_refs_without_deprecation "]}," ROXML InstanceMethods Accessors tag_name":{"type":"method","name":"tag_name","children":[],"call":[" class tag_name "," class "]}," ROXML XMLObjectRef instantiate":{"type":"method","name":"instantiate","children":[],"call":[" type new "," type "," type from_xml "," type respond_to? "]}," ROXML XMLObjectRef fetch_value":{"type":"method","name":"fetch_value","children":[],"call":[" instantiate ","xml search first ","xml search "," xpath ","xml search collect "," array? ","nodes first ","nodes collect "," nodes_in "," type new "," type "," type from_xml "," type respond_to? "," sought_type new "," sought_type "," sought_type from_xml "," sought_type respond_to? "]}," ROXML XMLObjectRef write_xml":{"type":"method","name":"write_xml","children":[],"call":["xml child_add ","value to_xml "," name ","v to_xml ","value each "," array? ","node content= ","XML Node  new_element ","value is_a? ","XML Node  new ","xml add_child ","XML Node  create "," xpath_name "," opts namespace "," opts ","XML Node  new_element  content= ","XML Node  new  content= ","XML Node  create  content= "]}," ROXML XMLHashRef apply_blocks":{"type":"method","name":"apply_blocks","children":[],"call":["vals to_hash ","vals collect! "," blocks empty? "," blocks "," to_hash "]}," ROXML XMLHashRef fetch_value":{"type":"method","name":"fetch_value","children":[],"call":[" hash value value "," hash value "," hash "," hash key value "," hash key ","xml search collect ","xml search "," xpath ","@value value_in ","@key value_in ","nodes collect "," nodes_in "]}," ROXML XMLHashRef write_xml":{"type":"method","name":"write_xml","children":[],"call":[" hash value update_xml "," hash value "," hash "," hash key update_xml "," hash key ","xml child_add ","XML Node  new_element "," hash wrapper ","value each_pair ","@value update_xml ","@key update_xml ","XML Node  new ","xml add_child ","XML Node  create "]}," ROXML XMLHashRef default":{"type":"method","name":"default","children":[],"call":["result nil? "]}," ROXML XMLTextRef add":{"type":"method","name":"add","children":[],"call":["dest content= ","value to_s to_utf ","value to_s ","dest child_add ","XML Node  new_cdata "," cdata? ","CGI  escapeHTML ","value to_s to_utf_without_deprecation ","dest add_child ","XML  set_content ","XML  add_cdata "]}," ROXML XMLTextRef fetch_value":{"type":"method","name":"fetch_value","children":[],"call":["child content ","xml search first ","xml search "," xpath ","e content strip to_latin ","e content strip ","e content ","xml search collect "," array? ","xml name "," name? ","xml content strip ","xml content "," content? ","nodes first content ","nodes first ","nodes collect "," nodes_in "," default "," raise "," accessor "," name "," required? ","value empty? ","xml content to_s strip ","xml content to_s ","e content strip to_latin_without_deprecation ","node content strip ","node content ","value blank? ","xml search first  content ","xml content to_s strip  empty? ","xml content to_s  empty? ","xml content to_s strip  blank? ","xml content to_s  blank? "]}," ROXML XMLTextRef write_xml":{"type":"method","name":"write_xml","children":[],"call":[" add ","xml child_add ","XML Node  new_element "," name ","value each "," array? ","xml name= "," name? "," content? ","XML Node  new ","xml add_child ","XML Node  create "," xpath_name "]}," ROXML XMLTextRef name?":{"type":"method","name":"name?","children":[],"call":[" name == "," name "]}," ROXML XMLAttributeRef xpath_name":{"type":"method","name":"xpath_name","children":[],"call":[" name "]}," ROXML XMLAttributeRef fetch_value":{"type":"method","name":"fetch_value","children":[],"call":["attr value ","xml search first ","xml search "," xpath ","nodes first value ","nodes first "," nodes_in ","node value ","xml search first  value "]}," ROXML XMLAttributeRef write_xml":{"type":"method","name":"write_xml","children":[],"call":["xml attributes []= ","value to_s to_utf ","value to_s "," name ","xml attributes ","value to_s to_utf_without_deprecation "]}," ROXML XMLRef wrap":{"type":"method","name":"wrap","children":[],"call":["xml child_add ","XML Node  new_element "," wrapper ","xml name != ","xml name ","c name == ","c name ","xml children find ","xml children ","xml name == "," wrapper ! ","XML Node  new "," wrapper to_s ","xml add_child ","XML Node  create ","wrap_with to_s ","wrap_with ! "," auto_wrapper ","opts [] ! ","opts [] ","XML  add_node ","wraps inject ","wrap_with to_s split ","node children find ","node children "," wrapper  to_s "," auto_wrapper  to_s "," wrapper  ! "," auto_wrapper  ! ","wrap_with to_s split  inject "," wrapper  to_s split "," auto_wrapper  to_s split "]}," ROXML XMLRef xpath":{"type":"method","name":"xpath","children":[],"call":[" xpath_name to_s "," xpath_name "," wrapper "," namespacify "," opts wrapper "," opts "]}," ROXML XMLRef apply_blocks":{"type":"method","name":"apply_blocks","children":[],"call":["block [] "," blocks inject "," blocks "," blocks apply_to "," raise ","ex message "," accessor ","block call "]}," ROXML XMLRef value":{"type":"method","name":"value","children":[],"call":[" apply_blocks "," default "," raise "," accessor to_s "," accessor "," required? ","value blank? "," fetch_value "," default  blank? "," fetch_value  blank? "," fetch_ default  "," fetch_ fetch_value  "]}," ROXML XMLRef default":{"type":"method","name":"default","children":[],"call":["@default dup ","@default duplicable? ","Array  new ","@opts array? ","@opts default "]}," ROXML XMLRef name?":{"type":"method","name":"name?","children":[],"call":[]}," ROXML XML Document root=":{"type":"method","name":"root=","children":[],"call":[" add "," raise "," root "]}," ROXML XML Parser register_error_handler":{"type":"method","name":"register_error_handler","children":[],"call":[]}," ROXML XML Parser parse_file":{"type":"method","name":"parse_file","children":[],"call":["REXML Document  new "," open "," file parse "," file "," parse ","path sub ","path starts_with? ","path sub  sub ","path sub  starts_with? "]}," ROXML XML Parser parse":{"type":"method","name":"parse","children":[],"call":["REXML Document  new "," string parse "," string ","Nokogiri  XML "]}," ROXML XML Node ==":{"type":"method","name":"==","children":[],"call":[" to_s == ","other to_s "," to_s "]}," ROXML XML Node child_add":{"type":"method","name":"child_add","children":[],"call":[" add_element ","REXML CData  new ","element is_a? "]}," ROXML XML Node search":{"type":"method","name":"search","children":[],"call":["REXML XPath  match "," raise "]}," ROXML XML Node new_element":{"type":"method","name":"new_element","children":[],"call":["REXML Element  new ","name id2name ","name is_a? ","name id2name  id2name id2name  ","name id2name  is_a? "]}," ROXML XML Node new_cdata":{"type":"method","name":"new_cdata","children":[],"call":["REXML CData  new ","Nokogiri XML CDATA  new ","Document  new "]}," ROXML XML Node default_namespace":{"type":"method","name":"default_namespace","children":[],"call":["n to_s nil? ","n to_s "," namespace find "," namespace "," doc default_namespace "," doc "]}," ROXML XML NamespacedSearch in_default_namespace":{"type":"method","name":"in_default_namespace","children":[],"call":[]}," ROXML XML NamespacedSearch namespaced":{"type":"method","name":"namespaced","children":[],"call":[" in_default_namespace ","component starts_with? ! ","component starts_with? ","component include? ! ","component include? ","component =~ ","xpath between ","(send\n  (send\n    (lvar :xpath) :split\n    (str \"/\")) :map) join ","xpath split map ","xpath split "]}," ROXML XML NamespacedSearch search":{"type":"method","name":"search","children":[],"call":[" find "," in_default_namespace "," default_namespace href "," default_namespace "," namespaced ","xpath include? ! ","xpath include? "," raise "," namespaces default href "," namespaces default "," namespaces ","(lvar :prefix) join ","roxml_namespaces map ","roxml_namespaces present? ","(pair\n  (sym :xmlns)\n  (send\n    (send\n      (send nil :namespaces) :default) :href)) merge ","(pair\n  (sym :xmlns)\n  (send\n    (send\n      (send nil :namespaces) :default) :href)) merge  map ","(pair\n  (sym :xmlns)\n  (send\n    (send\n      (send nil :namespaces) :default) :href)) merge  present? "]}," ROXML Opts extract_type":{"type":"method","name":"extract_type","children":[],"call":[" raise ","types join ","types empty? ","types only ","@opts []= ","@opts delete ","types one? ","(str \"too many arguments (\") + ","(send\n  (lvar :args) :+\n  (lvar :types)) join ","args + ","args empty? ","args only ","args only is_a? ","args only only ","@opts [] << ","@opts [] ","args one? ","@opts keys & ","@opts keys ","types first ","type is_a? ","type first ","args first ","args first s join ","args first s empty? ","args first s only ","args first s one? ","(send\n  (lvar :args) :+\n  (lvar :args first s)) join ","args first s first ","args first  is_a? ","args first  first "]}," ROXML Opts extract_options!":{"type":"method","name":"extract_options!","children":[],"call":["args push ","(send\n  (send\n    (lvar :opts) :keys) :&\n  (const nil :HASH_KEYS)) empty? ","opts keys & ","opts keys ","args extract_options! ","(send\n  (send\n    (lvar :args extract_options! ) :keys) :&\n  (const nil :HASH_KEYS)) empty? ","args extract_options!  keys & ","args extract_options!  keys "]}," ROXML Opts collect_blocks":{"type":"method","name":"collect_blocks","children":[],"call":["(send\n  (const nil :BLOCK_SHORTHANDS) :[]\n  (lvar :shorthand)) compact ","BLOCK_SHORTHANDS  [] ","shorthand == ","shorthands first "," raise ","shorthands map join ","shorthands map ","shorthands size > ","shorthands size ","as & ","BLOCK_SHORTHANDS  keys ","(send\n  (const nil :BLOCK_SHORTHANDS) :[]\n  (lvar :shorthands first )) compact ","shorthands first  == ","shorthands first s first ","as &  first ","shorthands first s map join ","as &  map join ","shorthands first s map ","as &  map ","shorthands first s size > ","as &  size > ","shorthands first s size ","as &  size "]}," ROXML Opts required?":{"type":"method","name":"required?","children":[],"call":["@opts [] "]}," ROXML Opts wrapper":{"type":"method","name":"wrapper","children":[],"call":["@opts [] "]}," ROXML Opts cdata?":{"type":"method","name":"cdata?","children":[],"call":["@opts [] include? ","@opts [] "]}," ROXML Opts array?":{"type":"method","name":"array?","children":[],"call":["@opts [] include? ","@opts [] "]}," ROXML Opts content?":{"type":"method","name":"content?","children":[],"call":["@type == "]}," ROXML Opts hash?":{"type":"method","name":"hash?","children":[],"call":["@type == "]}," ROXML Opts hash":{"type":"method","name":"hash","children":[],"call":["HashDesc  new "," name ","@opts delete "," hash? "]}," ROXML Opts variable_name":{"type":"method","name":"variable_name","children":[],"call":[" accessor to_s "," accessor "," accessor to_s chomp "," accessor to_s ends_with? "]}," ROXML Opts initialize":{"type":"method","name":"initialize","children":[],"call":[" raise "," default "," required? "," hash value name? "," hash value "," hash "," hash key name? "," hash key "," hash? ","@name singularize "," array? ","@opts [] to_s ","@opts [] "," collect_blocks "," variable_name ","@type tag_name "," class silence_xml_name_warning! "," class "," warn ","WARNING: As of 2.3, a breaking change has been in the naming of sub-objects.  + + ","WARNING: As of 2.3, a breaking change has been in the naming of sub-objects.  + "," class silence_xml_name_warning? ","@type xml_name? ","@type respond_to? ","@opts [] << ","@accessor to_s ends_with? ","@accessor to_s "," extract_type ","@opts []= ","@opts reverse_merge! ","@opts delete "," extract_options! ","@type try ","@opts has_key? ","@name singularize  singularize ","@opts [] to_s  singularize "," extract_options!  [] to_s "," extract_options!  [] "," extract_type  tag_name "," extract_type  xml_name? "," extract_type  respond_to? "," extract_options!  [] << "," extract_options!  []= "," extract_options!  reverse_merge! "," extract_options!  delete "," extract_type  try "," extract_options!  has_key? "]}," ROXML Opts silence_xml_name_warning!":{"type":"method","name":"silence_xml_name_warning!","children":[],"call":[]}," ROXML Opts silence_xml_name_warning?":{"type":"method","name":"silence_xml_name_warning?","children":[],"call":["ROXML  const_defined? "]}," ROXML HashDesc to_hash_args":{"type":"method","name":"to_hash_args","children":[],"call":[" raise ","opts to_s ","args extract_options! ","Opts  new ","(or-asgn\n  (send\n    (lvar :opts) :[]\n    (sym :as))\n  (array)) << ","opts [] ","opts []= ","type == ","(send\n  (send\n    (send\n      (lvar :args) :only) :keys) :&\n  (const nil :HASH_KEYS)) empty? ! ","(send\n  (send\n    (send\n      (lvar :args) :only) :keys) :&\n  (const nil :HASH_KEYS)) empty? ","args only keys & ","args only keys ","args only ","args one? ","args is_a? ","opts inspect ","(send\n  (send\n    (send\n      (lvar :args) :first) :keys) :&\n  (const nil :HASH_KEYS)) empty? ! ","(send\n  (send\n    (send\n      (lvar :args) :first) :keys) :&\n  (const nil :HASH_KEYS)) empty? ","args first keys & ","args first keys ","args first ","args extract_options!  to_s ","(or-asgn\n  (send\n    (lvar :args extract_options! ) :[]\n    (sym :as))\n  (array)) << ","args extract_options!  [] ","args extract_options!  []= ","args extract_options!  inspect "]}," ROXML HashDesc to_ref":{"type":"method","name":"to_ref","children":[],"call":[" raise ","(pair\n  (sym :type)\n  (lvar :type)) pp_s ","XMLTextRef  new "," to_hash_args ","XMLAttributeRef  new "]}," ROXML HashDesc fetch_element":{"type":"method","name":"fetch_element","children":[],"call":[" raise ","opts [] ","opts [] [] ","opts [] keys first ","opts [] keys ","opts [] pp_s ","opts [] keys one? ","opts [] inspect "]}," ROXML HashDesc names":{"type":"method","name":"names","children":[],"call":["@value name ","@key name "]}," ROXML HashDesc types":{"type":"method","name":"types","children":[],"call":["@value class ","@key class "]}," ROXML HashDesc initialize":{"type":"method","name":"initialize","children":[],"call":[" to_ref "," fetch_element ","opts [] [] ","opts [] ","opts has_key? "," raise ","invalid_keys join ","(lvasgn :invalid_keys\n  (send\n    (send\n      (lvar :opts) :keys) :-\n    (const nil :HASH_KEYS))) empty? ","opts keys - ","opts keys "," to_hash_args ","opts keys -  join ","(lvasgn :opts keys - \n  (send\n    (send\n      (lvar :opts) :keys) :-\n    (const nil :HASH_KEYS))) empty? "]}," Object to_latin":{"type":"method","name":"to_latin","children":[],"call":[" to_s to_latin "," to_s ","ActiveSupport Deprecation  warn "]}," Object to_utf":{"type":"method","name":"to_utf","children":[],"call":[" to_s to_utf "," to_s ","ActiveSupport Deprecation  warn "]}," ROXML CoreExtensions String Iterators between":{"type":"method","name":"between","children":[],"call":[" split collect join "," split collect "," split "]}," String between":{"type":"method","name":"between","children":[],"call":[" split collect join "," split collect "," split "]}," ROXML CoreExtensions String Conversions to_latin":{"type":"method","name":"to_latin","children":[],"call":["STDERR  << ","Iconv  new iconv "," to_s ","Iconv  new "]}," ROXML CoreExtensions String Conversions to_utf":{"type":"method","name":"to_utf","children":[],"call":["STDERR  << ","Iconv  new iconv "," to_s ","Iconv  new "]}," ActiveSupport Deprecation ClassMethods deprecated_method_warning":{"type":"method","name":"deprecated_method_warning","children":[],"call":[]}," ActiveSupport Deprecation deprecation_message":{"type":"method","name":"deprecation_message","children":[],"call":[" deprecation_caller_message "]}," ROXML CoreExtensions Array Conversions to_h":{"type":"method","name":"to_h","children":[],"call":[" to_hash "]}," ROXML CoreExtensions Array Conversions to_hash":{"type":"method","name":"to_hash","children":[],"call":["result []= "," inject ","hash []= ","v only ","v one? ","hash each_pair ","result [] << ","result [] ","v first "]}," ROXML ClassMethods Accessors roxml_attrs":{"type":"method","name":"roxml_attrs","children":[],"call":["(send\n  (ivar :@roxml_attrs) :+\n  (begin\n    (or\n      (send\n        (send nil :superclass) :try\n        (sym :roxml_attrs))\n      (array)))) freeze ","@roxml_attrs + "," superclass try "," superclass ","(send\n  (ivar :@roxml_attrs) :+\n  (begin\n    (if\n      (send\n        (send nil :superclass) :respond_to?\n        (sym :roxml_attrs))\n      (send\n        (send nil :superclass) :roxml_attrs)\n      (array)))) freeze "," superclass roxml_attrs "," superclass respond_to? "]}," ROXML ClassMethods Accessors roxml_tag_name":{"type":"method","name":"roxml_tag_name","children":[],"call":[" superclass try "," superclass "," superclass roxml_tag_name "," superclass respond_to? "]}," ROXML ClassMethods Accessors xml_name?":{"type":"method","name":"xml_name?","children":[],"call":[]}," ROXML ClassMethods Declarations roxml_naming_convention":{"type":"method","name":"roxml_naming_convention","children":[],"call":["(or\n  (ivar :@roxml_naming_convention)\n  (send\n    (send nil :superclass) :try\n    (sym :roxml_naming_convention))) freeze "," superclass try "," superclass ","(or\n  (ivar :@roxml_naming_convention)\n  (kwbegin\n    (if\n      (send\n        (send nil :superclass) :respond_to?\n        (sym :roxml_naming_convention))\n      (send\n        (send nil :superclass) :roxml_naming_convention) nil))) freeze "," superclass roxml_naming_convention "," superclass respond_to? "]}," ROXML ClassMethods Declarations xml_convention":{"type":"method","name":"xml_convention","children":[],"call":[" block_given? ","to_proc_able try "," raise ","to_proc_able respond_to? ","to_proc_able to_proc "]}," ROXML XMLHashRef freeze":{"type":"method","name":"freeze","children":[],"call":["vals freeze ","v freeze ","k freeze ","vals each_pair "," opts freeze? "," opts "," opts frozen? "]}," ROXML XMLHashRef initialize":{"type":"method","name":"initialize","children":[],"call":["opts hash value to_ref ","opts hash value ","opts hash ","opts hash key to_ref ","opts hash key "]}," ROXML XMLRef nodes_in":{"type":"method","name":"nodes_in","children":[],"call":[" default "," raise "," accessor "," name "," required? ","vals empty? ","vals empty? ! ","xml search "," auto_xpath "," wrapper ! "," wrapper "," opts array? "," opts "," opts hash? "," xpath ","vals first ","vals map "," several? ","@instance class roxml_namespaces ","@instance class ","xml default_namespace ","xml roxml_search ","XML  search ","XML  default_namespace ","xml search  empty? ","xml roxml_search  empty? ","XML  search  empty? ","xml search  empty? ! ","xml roxml_search  empty? ! ","XML  search  empty? ! ","xml search  first ","xml roxml_search  first ","XML  search  first ","xml search  map ","xml roxml_search  map ","XML  search  map "]}," ROXML XMLRef auto_xpath":{"type":"method","name":"auto_xpath","children":[],"call":[" xpath_name "," conventionize "," opts name pluralize "," opts name "," opts "," array? "," namespacify "," auto_wrapper "]}," ROXML XMLRef freeze":{"type":"method","name":"freeze","children":[],"call":["val freeze ","val each ","val is_a? "," opts freeze? "," opts "," opts frozen? "]}," ROXML XMLRef wrapper":{"type":"method","name":"wrapper","children":[],"call":[" conventionize "," opts wrapper "," opts "]}," ROXML XMLRef conventionize":{"type":"method","name":"conventionize","children":[],"call":["@instance class roxml_naming_convention call ","@instance class roxml_naming_convention ","@instance class ","@instance try try respond_to? ","@instance try try ","@instance try ","what blank? ! ","what blank? ","URI  unescape ","URI  escape "," require ","convention call ","convention respond_to? ","@instance class respond_to? ","URI  decode_www_form_component ","URI  encode_www_form_component "]}," ROXML XMLRef value_in":{"type":"method","name":"value_in","children":[],"call":[" freeze "," apply_blocks "," fetch_value "," default ","value nil? ","XML Node  from "," opts frozen? "," opts ","value to_s empty? ","value to_s "," fetch_ fetch_value  "," fetch_ default  "," fetch_ freeze  "," fetch_ apply_blocks  "," fetch_value  nil? "," default  nil? "," freeze  nil? "," apply_blocks  nil? "," fetch_value  to_s empty? "," default  to_s empty? "," freeze  to_s empty? "," apply_blocks  to_s empty? "," fetch_value  to_s "," default  to_s "," freeze  to_s "," apply_blocks  to_s "]}," ROXML XMLRef name":{"type":"method","name":"name","children":[],"call":[" conventionize "," opts name "," opts "," opts name_explicit? "]}," ROXML XMLRef to_xml":{"type":"method","name":"to_xml","children":[],"call":[" opts to_xml call "," opts to_xml "," opts "," opts to_xml respond_to? ","@instance __send__ "," accessor ","instance __send__ "]}," ROXML Opts to_ref":{"type":"method","name":"to_ref","children":[],"call":["(send nil :type) new "," raise "," opts type "," opts "," type "]}," ROXML Opts default":{"type":"method","name":"default","children":[],"call":["@default dup ","@default duplicable? "," hash? "," array? "]}," ROXML Opts freeze?":{"type":"method","name":"freeze?","children":[],"call":["@opts [] "]}," ROXML Opts name?":{"type":"method","name":"name?","children":[],"call":["@name == "]}," ROXML CoreExtensions Array Conversions apply_to":{"type":"method","name":"apply_to","children":[],"call":["block call "," inject "]}," Object try":{"type":"method","name":"try","children":[],"call":[" send "," respond_to? "]}," ROXML ClassMethods Declarations xml_reference":{"type":"method","name":"xml_reference","children":[],"call":[" add_accessor ","Opts  new ","(lvar :type_and_or_opts) compact ","Definition  new ","(lvar :type_and_or_Opts  new ) compact ","(lvar :type_and_or_Definition  new ) compact "]}," ROXML ClassMethods Accessors roxml_namespace":{"type":"method","name":"roxml_namespace","children":[],"call":[" superclass try "," superclass "," superclass roxml_namespace "," superclass respond_to? "]}," ROXML ClassMethods Declarations xml_namespace":{"type":"method","name":"xml_namespace","children":[],"call":["namespace to_s "]}," ROXML XML Node from":{"type":"method","name":"from","children":[],"call":[]}," ROXML XMLRef xpath_name":{"type":"method","name":"xpath_name","children":[],"call":[" name ","@instance class roxml_namespace ","@instance class "," opts name_explicit? ! "," opts name_explicit? "," opts "," namespacify ","@instance class roxml_@instance class roxml_namespace  "]}," ROXML XML Parser parse_io":{"type":"method","name":"parse_io","children":[],"call":[" parse "," io parse "," io "]}," ROXML HashDefinition to_hash_args":{"type":"method","name":"to_hash_args","children":[],"call":[" raise ","opts inspect ","args extract_options! ","Definition  new ","(or-asgn\n  (send\n    (lvar :opts) :[]\n    (sym :as))\n  (array)) << ","opts [] ","opts []= ","type == ","(send\n  (send\n    (send\n      (lvar :args) :first) :keys) :&\n  (const nil :HASH_KEYS)) empty? ! ","(send\n  (send\n    (send\n      (lvar :args) :first) :keys) :&\n  (const nil :HASH_KEYS)) empty? ","args first keys & ","args first keys ","args first ","args one? ","args is_a? ","args extract_options!  inspect ","(or-asgn\n  (send\n    (lvar :args extract_options! ) :[]\n    (sym :as))\n  (array)) << ","args extract_options!  [] ","args extract_options!  []= "]}," ROXML HashDefinition fetch_element":{"type":"method","name":"fetch_element","children":[],"call":[" raise ","opts [] ","opts [] [] ","opts [] keys first ","opts [] keys ","opts [] inspect ","opts [] keys one? ","ActiveSupport Deprecation  warn "]}," ROXML HashDefinition initialize":{"type":"method","name":"initialize","children":[],"call":[" to_hash_args "," fetch_element ","opts [] [] ","opts [] ","opts has_key? "," raise ","invalid_keys join ","(lvasgn :invalid_keys\n  (send\n    (send\n      (lvar :opts) :keys) :-\n    (const nil :HASH_KEYS))) empty? ","opts keys - ","opts keys ","ActiveSupport Deprecation  warn ","Definition  new "," to_definition_options ","opts assert_valid_keys ","opts keys -  join ","(lvasgn :opts keys - \n  (send\n    (send\n      (lvar :opts) :keys) :-\n    (const nil :HASH_KEYS))) empty? "]}," ROXML Definition extract_type":{"type":"method","name":"extract_type","children":[],"call":[" raise ","types join ","types empty? ","types first ","@opts []= ","@opts delete ","types one? ","(str \"too many arguments (\") + ","(send\n  (lvar :args) :+\n  (lvar :types)) join ","args + ","args empty? ","type is_a? ","type first ","@opts [] << ","@opts [] ","args first ","args one? ","@opts keys & ","@opts keys ","ActiveSupport Deprecation  warn ","opts []= ","opts [] == ","opts [] ","opts delete ","opts [] first ","opts [] first respond_to? ","opts [] is_a? ","opts [] respond_to? ","HashDefinition  new ","opts [] nil? ","opts [] sub! ","opts [] to_s starts_with? ","opts [] to_s ","type == ","opts keys & ","opts keys ","as first ","as first respond_to? ","as is_a? ","as respond_to? ","args first s join ","args first s empty? ","args first s first ","args first s one? ","(send\n  (lvar :args) :+\n  (lvar :args first s)) join ","args first  is_a? ","args first  first ","args first  == "]}," ROXML Definition extract_options!":{"type":"method","name":"extract_options!","children":[],"call":["args push ","(send\n  (send\n    (lvar :opts) :keys) :&\n  (const nil :HASH_KEYS)) empty? ","opts keys & ","opts keys ","args extract_options! ","ActiveSupport Deprecation  warn ","opts [] join ","opts [] ","opts [] size > ","opts [] size ","opts [] is_a? "," extract_from_as ","opts delete ","opts has_key? ","(send\n  (send\n    (lvar :args extract_options! ) :keys) :&\n  (const nil :HASH_KEYS)) empty? ","args extract_options!  keys & ","args extract_options!  keys ","args extract_options!  [] join ","args extract_options!  [] ","args extract_options!  [] size > ","args extract_options!  [] size ","args extract_options!  [] is_a? ","args extract_options!  delete ","args extract_options!  has_key? "]}," ROXML Definition collect_blocks":{"type":"method","name":"collect_blocks","children":[],"call":["(send\n  (const nil :BLOCK_SHORTHANDS) :[]\n  (lvar :shorthand)) compact ","BLOCK_SHORTHANDS  [] ","shorthand == ","shorthands first "," raise ","shorthands map join ","shorthands map ","shorthands size > ","shorthands size ","as & ","BLOCK_SHORTHANDS  keys ","ActiveSupport Deprecation  warn ","as include? ","(lvar :as) compact ","as inspect ","as nil? ","(send\n  (send\n    (lvar :as) :keys) :&\n  (const nil :HASH_KEYS)) empty? ! ","(send\n  (send\n    (lvar :as) :keys) :&\n  (const nil :HASH_KEYS)) empty? ","as keys & ","as keys ","as is_a? ","as try respond_to? ","as try ","as respond_to? "," class block_shorthands fetch "," class block_shorthands "," class ","as == ","as first ","as map join ","as map ","as empty? ","as one? ","(send\n  (send\n    (lvar :as) :keys) :&\n  (array\n    (sym :key)\n    (sym :value))) empty? ! ","(send\n  (send\n    (lvar :as) :keys) :&\n  (array\n    (sym :key)\n    (sym :value))) empty? ","as first respond_to? ","as size > ","as size ","(send\n  (const nil :BLOCK_SHORTHANDS) :[]\n  (lvar :shorthands first )) compact ","shorthands first  == ","shorthands first s first ","as &  first ","shorthands first s map join ","as &  map join ","shorthands first s map ","as &  map ","shorthands first s size > ","as &  size > ","shorthands first s size ","as &  size ","as first  & ","as first  include? ","(lvar :as first ) compact ","as first  inspect ","as first  nil? ","(send\n  (send\n    (lvar :as first ) :keys) :&\n  (const nil :HASH_KEYS)) empty? ! ","(send\n  (send\n    (lvar :as first ) :keys) :&\n  (const nil :HASH_KEYS)) empty? ","as first  keys & ","as first  keys ","as first  is_a? ","as first  try respond_to? ","as first  try ","as first  respond_to? "," class block_shorthands first s fetch "," class block_as &  fetch "," clas first s block_shorthands fetch "," class block_shorthands first s "," class block_as &  "," clas first s block_shorthands "," clas first s ","as first  == ","as first  first ","as first  map join ","as first  map ","as first  empty? ","as first  one? ","(send\n  (send\n    (lvar :as first ) :keys) :&\n  (array\n    (sym :key)\n    (sym :value))) empty? ! ","(send\n  (send\n    (lvar :as first ) :keys) :&\n  (array\n    (sym :key)\n    (sym :value))) empty? ","as first  first respond_to? ","as first  size > ","as first  size "]}," ROXML Definition blank_string?":{"type":"method","name":"blank_string?","children":[],"call":[]}," ROXML Definition fetch_bool":{"type":"method","name":"fetch_bool","children":[],"call":[]}," ROXML Definition all":{"type":"method","name":"all","children":[],"call":[]}," ROXML Definition to_ref":{"type":"method","name":"to_ref","children":[],"call":["(send nil :type) new "," raise "," opts type "," opts "," type ","(send nil :sought_type) new "," sought_type "]}," ROXML Definition default":{"type":"method","name":"default","children":[],"call":["@default dup ","@default duplicable? "," hash? "," array? ","@default nil? "]}," ROXML Definition freeze?":{"type":"method","name":"freeze?","children":[],"call":["@opts [] "]}," ROXML Definition required?":{"type":"method","name":"required?","children":[],"call":["@opts [] "]}," ROXML Definition wrapper":{"type":"method","name":"wrapper","children":[],"call":["@opts [] "]}," ROXML Definition cdata?":{"type":"method","name":"cdata?","children":[],"call":["@opts [] include? ","@opts [] "]}," ROXML Definition array?":{"type":"method","name":"array?","children":[],"call":["@opts [] include? ","@opts [] "]}," ROXML Definition content?":{"type":"method","name":"content?","children":[],"call":["@type == ","@name == "]}," ROXML Definition name_explicit?":{"type":"method","name":"name_explicit?","children":[],"call":[]}," ROXML Definition name?":{"type":"method","name":"name?","children":[],"call":["@name == "]}," ROXML Definition hash?":{"type":"method","name":"hash?","children":[],"call":["@type == ","@type is_a? ","@sought_type is_a? "]}," ROXML Definition hash":{"type":"method","name":"hash","children":[],"call":["HashDefinition  new "," name ","@opts delete "," hash? ","@type wrapper ","@sought_type wrapper "]}," ROXML Definition variable_name":{"type":"method","name":"variable_name","children":[],"call":[" accessor to_s "," accessor "," accessor to_s chomp "," accessor to_s ends_with? "]}," ROXML Definition initialize":{"type":"method","name":"initialize","children":[],"call":[" raise "," required? "," hash value name? "," hash value "," hash "," hash key name? "," hash key "," hash? ","@name singularize "," array? ","@opts [] to_s ","@opts [] "," collect_blocks "," variable_name ","@type tag_name "," class silence_xml_name_warning! "," class "," warn ","WARNING: As of 2.3, a breaking change has been in the naming of sub-objects.  + + ","WARNING: As of 2.3, a breaking change has been in the naming of sub-objects.  + "," class silence_xml_name_warning? ","@type try ","@opts [] << ","@accessor to_s ends_with? ","@accessor to_s "," extract_type ","@opts []= ","@opts reverse_merge! ","@opts has_key? ","@opts delete "," extract_options! ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (send nil :variable_name)) to_s ","opts [] ","opts [] sub! ","opts [] to_s starts_with? ","opts [] to_s ","opts []= ","opts [] == ","opts has_key? "," extract_from_as ","opts [] is_a? ","ActiveSupport Deprecation  warn ","@type xml_name_without_deprecation? ","@type respond_to? ","@namespace == ","@namespace present? ","@name include? ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@attr_name)) to_s "," accessor to_s chomp "," accessor to_s "," accessor ","@type roxml_tag_name ","@accessor ends_with? ","sym to_s ","opts delete ","opts assert_valid_keys ","@sought_type roxml_tag_name ","@sought_type respond_to? ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@name)) to_s ","opts [] sub ","@name singularize  singularize ","@opts [] to_s  singularize ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (send nil :variable_name)) to_s  singularize ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@attr_name)) to_s  singularize ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@name)) to_s  singularize "," extract_options!  [] to_s ","@ extract_options!  [] to_s "," extract_options!  [] ","@ extract_options!  [] "," extract_type  tag_name "," extract_type  try "," extract_options!  [] << ","@ extract_options!  [] << ","sym to_s  to_s ends_with? ","sym to_s  to_s "," extract_options!  []= ","@ extract_options!  []= "," extract_options!  reverse_merge! ","@ extract_options!  reverse_merge! "," extract_options!  has_key? ","@ extract_options!  has_key? "," extract_options!  delete ","@ extract_options!  delete ","(or\n  (send\n    (lvar : extract_options! ) :[]\n    (sym :from))\n  (send nil :variable_name)) to_s "," extract_options!  [] sub! "," extract_options!  [] to_s starts_with? "," extract_options!  [] == "," extract_options!  [] is_a? "," extract_type  xml_name_without_deprecation? "," extract_type  respond_to? ","@name singularize space == ","@opts [] to_s space == ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (send nil :variable_name)) to_s space == ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@attr_name)) to_s space == ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@name)) to_s space == ","opts delete  == ","@name singularize space present? ","@opts [] to_s space present? ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (send nil :variable_name)) to_s space present? ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@attr_name)) to_s space present? ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@name)) to_s space present? ","opts delete  present? ","@name singularize  include? ","@opts [] to_s  include? ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (send nil :variable_name)) to_s  include? ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@attr_name)) to_s  include? ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@name)) to_s  include? ","(or\n  (send\n    (lvar : extract_options! ) :[]\n    (sym :from))\n  (ivar :@attr_name)) to_s ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar : accessor to_s chomp )) to_s "," extract_type  roxml_tag_name ","sym to_s  ends_with? "," extract_options!  assert_valid_keys ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@name singularize )) to_s ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@opts [] to_s )) to_s ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (send nil :variable_name)) to_s )) to_s ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@attr_name)) to_s )) to_s ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :(or\n  (send\n    (lvar :opts) :[]\n    (sym :from))\n  (ivar :@name)) to_s )) to_s ","(or\n  (send\n    (lvar : extract_options! ) :[]\n    (sym :from))\n  (ivar :@name)) to_s "," extract_options!  [] sub "]}," ROXML Definition silence_xml_name_warning!":{"type":"method","name":"silence_xml_name_warning!","children":[],"call":[]}," ROXML Definition silence_xml_name_warning?":{"type":"method","name":"silence_xml_name_warning?","children":[],"call":["ROXML  const_defined? "]}," Enumerable one?":{"type":"method","name":"one?","children":[],"call":[" size == "," size "]}," ROXML ClassMethods Declarations add_reader":{"type":"method","name":"add_reader","children":[],"call":[" instance_variable_get ","attr variable_name "," define_method ","attr accessor ","attr instance_variable_name "," instance_variable_set ","attr default "," instance_variable_get nil? "," instance_variable_defined? "]}," ROXML ClassMethods Declarations xml_attr":{"type":"method","name":"xml_attr","children":[],"call":["@roxml_attrs << "," raise "," name ","attr accessor "," roxml_attrs map include? "," roxml_attrs map "," roxml_attrs "," returning ","Definition  new ","(lvar :type_and_or_opts) compact ","Definition  new tap ","syms map ","syms extract_options! ","(lvar :type_and_or_syms extract_options! ) compact "]}," ROXML XML Node new":{"type":"method","name":"new","children":[],"call":["REXML Element  new ","name id2name ","name is_a? ","name id2name  id2name id2name  ","name id2name  is_a? "]}," ROXML XML Node new_with_entity_escaping":{"type":"method","name":"new_with_entity_escaping","children":[],"call":[" new_without_entity_escaping ","CGI  escapeHTML "]}," ActiveSupport Deprecation warn_with_internals_exclusion":{"type":"method","name":"warn_with_internals_exclusion","children":[],"call":[" warn_without_internals_exclusion ","line =~ ","callstack reject "]}," ROXML Definition extract_from_as":{"type":"method","name":"extract_from_as","children":[],"call":["opts [] delete ","opts [] ","opts []= ","opts [] == ","ActiveSupport Deprecation  warn ","entry inspect ","(splat\n  (send\n    (lvar :opts) :[]\n    (sym :as))) include? "]}," ROXML Definition block_shorthands":{"type":"method","name":"block_shorthands","children":[],"call":[]}," Module bool_attr_reader":{"type":"method","name":"bool_attr_reader","children":[],"call":[" instance_variable_get "," define_method ","attrs each "]}," ROXML XML Document save":{"type":"method","name":"save","children":[],"call":["opts [] write ","opts [] ","File  open "," << ","REXML XMLDecl  new "," xml_decl != ","REXML XMLDecl  default "," xml_decl ","file << "," serialize "," open "]}," ROXML XML Error reset_handler":{"type":"method","name":"reset_handler","children":[],"call":[]}," ROXML XML Node content=":{"type":"method","name":"content=","children":[],"call":[" set_libxml_content ","string gsub "]}," ROXML XML Node add_child":{"type":"method","name":"add_child","children":[],"call":[" add_element ","REXML CData  new ","element is_a? "," << "]}," ROXML ClassMethods Declarations roxml_namespaces":{"type":"method","name":"roxml_namespaces","children":[],"call":[]}," ROXML ClassMethods Declarations xml_namespaces":{"type":"method","name":"xml_namespaces","children":[],"call":["all []= ","href to_s ","prefix to_s ","namespaces inject "]}," ROXML InstanceMethods to_xml":{"type":"method","name":"to_xml","children":[],"call":["ref update_xml ","value nil? ","ref to_xml ","attr to_ref "," class roxml_attrs each "," class roxml_attrs "," class ","XML Node  create tap ","XML Node  create ","name to_s ","refs each "," class roxml_attrs map "," roxml_references "," roxml_references present? ","(send\n  (lvar :params) :[]\n  (sym :namespace)) compact join ","(send\n  (lvar :params) :[]\n  (sym :namespace)) compact ","params [] ","params reverse_merge! "," class roxml_namespace "," class tag_name ","params []= ","(str \"*\") include? ","XML  new_node tap ","XML  new_node ","root add_namespace_definition ","params [] each ","attr to_ref  update_xml ","ref to_xml  nil? ","attr to_ref  to_xml ","attr to_attr to_ref  ","attr to_ref s each "," roxml_attr to_ref erences "," roxml_attr to_ref erences present? "]}," ROXML XMLHashRef to_hash":{"type":"method","name":"to_hash","children":[],"call":["hash []= ","v first ","v size == ","v size ","hash each_pair ","result [] << ","result [] ","array inject "]}," ROXML XMLHashRef several?":{"type":"method","name":"several?","children":[],"call":[]}," ROXML XMLRef several?":{"type":"method","name":"several?","children":[],"call":[" array? "]}," ROXML XMLRef namespacify":{"type":"method","name":"namespacify","children":[],"call":[" opts namespace != "," opts namespace "," opts ","what include? ! ","what include? ","what present? ","@instance class roxml_namespace ","@instance class "," opts namespace == ","(send\n  (send nil :opts) :namespace) each ","what to_s include? ! ","what to_s include? ","what to_s ","what to_s present? ","what == ","parser abbreviate ","a [] replace ","a [] ","parsed []= ","i + ","a [] != ","ns == ","a [] == ","parsed each_cons with_index each ","parsed each_cons with_index ","parsed each_cons ","parser parse ","REXML Parsers XPathParser  new ","(send\n  (send nil :opts) :namespace) compact map first ","(send\n  (send nil :opts) :namespace) compact map ","(send\n  (send nil :opts) :namespace) compact "," require ","@i(send\n  (send nil :opts) :namespace) compact map first tance class roxml_namespace ","@i(send\n  (send nil :opts) :namespace) compact map first tance class ","REXML Parsers XPathParser  new  abbreviate ","parser parse  []= ","(send\n  (send nil :opts) :namespace) compact map first  == ","parser parse  each_cons with_index each ","parsed each_co(send\n  (send nil :opts) :namespace) compact map first  with_index each ","parser parse  each_cons with_index ","parsed each_co(send\n  (send nil :opts) :namespace) compact map first  with_index ","parser parse  each_cons ","parsed each_co(send\n  (send nil :opts) :namespace) compact map first  ","REXML Parsers XPathParser  new  parse "]}," ROXML XML Node create":{"type":"method","name":"create","children":[],"call":[" new ","Document  new "]}," ROXML XML Element empty?":{"type":"method","name":"empty?","children":[],"call":[" children empty? "," children "]}," ROXML XML NodeExtensions default_namespace":{"type":"method","name":"default_namespace","children":[],"call":[" document default_namespace "," document "]}," ROXML XML NodeExtensions attributes":{"type":"method","name":"attributes","children":[],"call":[]}," ROXML XML NodeExtensions search":{"type":"method","name":"search","children":[],"call":["(if\n  (send\n    (lvar :roxml_namespaces) :present?)\n  (super\n    (lvar :xpath)\n    (lvar :roxml_namespaces))\n  (super\n    (lvar :xpath))) map ","roxml_namespaces present? "]}," ROXML XML Document default_namespace":{"type":"method","name":"default_namespace","children":[],"call":[" root namespaces [] "," root namespaces "," root ","default prefix "," namespaces default "," namespaces "," namespaces default  prefix "," namespaces  namespaces default  "]}," ROXML HashDefinition to_definition_options":{"type":"method","name":"to_definition_options","children":[],"call":[" raise ","opts [] "]}," ROXML Definition setter":{"type":"method","name":"setter","children":[],"call":[" attr_name "]}," ROXML Definition instance_variable_name":{"type":"method","name":"instance_variable_name","children":[],"call":[" attr_name "]}," ROXML XMLRef auto_wrapper":{"type":"method","name":"auto_wrapper","children":[],"call":[" namespacify "," conventionize "," opts name pluralize "," opts name "," opts "]}," ROXML XMLHashRef update_xml":{"type":"method","name":"update_xml","children":[],"call":["@value update_xml ","@key update_xml ","xml add_child ","XML Node  create "," hash wrapper "," hash ","value each_pair "," wrap tap "," wrap ","XML  add_node ","XML  add_xml add_child  ","XML  add_XML  add_node  "]}," ROXML XMLRef blocks":{"type":"method","name":"blocks","children":[],"call":[" opts blocks "," opts "]}," ROXML XMLNameSpaceRef fetch_value":{"type":"method","name":"fetch_value","children":[],"call":["xml namespace prefix ","xml namespace "]}," ROXML XML NodeExtensions roxml_search":{"type":"method","name":"roxml_search","children":[],"call":[" search ","roxml_namespaces present? "]}," ROXML XML save_doc":{"type":"method","name":"save_doc","children":[],"call":["file << ","doc serialize "," open ","doc save "]}," ROXML XML parse_io":{"type":"method","name":"parse_io","children":[],"call":["Nokogiri  XML ","LibXML XML Parser  io parse ","LibXML XML Parser  io "]}," ROXML XML parse_file":{"type":"method","name":"parse_file","children":[],"call":[" parse_io "," open ","path sub ","path starts_with? ","LibXML XML Parser  file parse ","LibXML XML Parser  file ","path sub  sub ","path sub  starts_with? "]}," ROXML XML parse_string":{"type":"method","name":"parse_string","children":[],"call":["Nokogiri  XML ","LibXML XML Parser  string parse ","LibXML XML Parser  string "]}," ROXML XML add_child":{"type":"method","name":"add_child","children":[],"call":["parent add_child ","parent << "]}," ROXML XML add_cdata":{"type":"method","name":"add_cdata","children":[],"call":["parent add_child ","Nokogiri XML CDATA  new ","parent document "," add_child ","LibXML XML Node  new_cdata "]}," ROXML XML add_node":{"type":"method","name":"add_node","children":[],"call":[" add_child ","Nokogiri XML Node  new ","parent document "," new_node "]}," ROXML XML new_node":{"type":"method","name":"new_node","children":[],"call":["Nokogiri XML Node  new ","Document  new ","LibXML XML Node  new "]}," ROXML XML set_content":{"type":"method","name":"set_content","children":[],"call":["node content= ","content gsub "]}," ROXML XML set_attribute":{"type":"method","name":"set_attribute","children":[],"call":["node []= ","node attributes []= ","node attributes "]}," ROXML XML NamespacedSearch roxml_search":{"type":"method","name":"roxml_search","children":[],"call":[" find ","(lvar :prefix) join ","roxml_namespaces map ","roxml_namespaces present? ","(pair\n  (sym :xmlns)\n  (send\n    (send\n      (send nil :namespaces) :default) :href)) merge "," namespaces default href "," namespaces default "," namespaces ","(pair\n  (sym :xmlns)\n  (send\n    (send\n      (send nil :namespaces) :default) :href)) merge  map ","(pair\n  (sym :xmlns)\n  (send\n    (send\n      (send nil :namespaces) :default) :href)) merge  present? "]}," ROXML XML search":{"type":"method","name":"search","children":[],"call":["xml search ","roxml_namespaces present? ","xml find ","(lvar :prefix) join ","roxml_namespaces map ","(pair\n  (sym :xmlns)\n  (send\n    (send\n      (send nil :namespaces) :default) :href)) merge "," namespaces default href "," namespaces default "," namespaces ","xml namespaces default ","xml namespaces ","(pair\n  (sym :xmlns)\n  (send\n    (send\n      (send nil :namespaces) :default) :href)) merge  present? ","(pair\n  (sym :xmlns)\n  (send\n    (send\n      (send nil :namespaces) :default) :href)) merge  map "]}," ROXML XML default_namespace":{"type":"method","name":"default_namespace","children":[],"call":["doc root namespaces [] ","doc root namespaces ","doc root ","doc document ","doc respond_to? ","default prefix ","doc root namespaces default ","doc doc ","doc document  root namespaces [] ","doc doc  root namespaces [] ","doc document  root namespaces ","doc doc  root namespaces ","doc document  root ","doc doc  root ","doc document  doc document ument ","doc doc  doc doc ument ","doc document  respond_to? ","doc doc  respond_to? ","doc root namespaces default  prefix ","doc document  root namespaces default ","doc doc  root namespaces default ","doc root namespaces doc root namespaces default  ","doc document  doc document  ","doc doc  doc doc  "]}}