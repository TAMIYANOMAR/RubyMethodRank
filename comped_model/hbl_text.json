{" String to_utf8!":{"type":"method","name":"to_utf8!","children":[],"call":[" replace ","HBLText Setter  convert_encoding "]}," String to_utf8":{"type":"method","name":"to_utf8","children":[],"call":["HBLText Setter  convert_encoding "]}," HBLText Setter get_charset_from_tag":{"type":"method","name":"get_charset_from_tag","children":[],"call":["values compact last ","values compact ","values << ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact ","s match ","(send\n  (send\n    (send\n      (lvar :value) :to_s) :split\n    (regexp\n      (str \";\")\n      (regopt))) :select) map ","s =~ ","value to_s split select ","value to_s split ","value to_s ","html xpath last try ","html xpath last ","html xpath ","Nokogiri HTML  fragment "," to_utf8 ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try s compact last ","html xpath last try s compact last ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try s compact ","html xpath last try s compact ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try s << ","html xpath last try s << ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try ) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :html xpath last try ) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try ) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :html xpath last try ) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try ) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :html xpath last try ) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact ","(send\n  (send\n    (send\n      (lvar :(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try ) :to_s) :split\n    (regexp\n      (str \";\")\n      (regopt))) :select) map ","(send\n  (send\n    (send\n      (lvar :html xpath last try ) :to_s) :split\n    (regexp\n      (str \";\")\n      (regopt))) :select) map ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try  to_s split select ","html xpath last try  to_s split select ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try  to_s split ","html xpath last try  to_s split ","(send\n  (block\n    (send\n      (send\n        (send\n          (lvar :value) :to_s) :split\n        (regexp\n          (str \";\")\n          (regopt))) :select)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :=~\n      (regexp\n        (str \"\\s*(?<=charset=).*\")\n        (regopt)))) :map) compact last try  to_s ","html xpath last try  to_s ","Nokogiri HTML  fragment  xpath last try ","Nokogiri HTML  fragment  xpath last ","Nokogiri HTML  fragment  xpath "]}," HBLText Setter get_charset":{"type":"method","name":"get_charset","children":[],"call":["str force_encoding valid_encoding? ","str force_encoding ","Encoding  list each ","Encoding  list ","encodings each ","str dup ","str dup  force_encoding valid_encoding? ","str dup  force_encoding ","str dup  dup "]}," HBLText Setter convert_encoding":{"type":"method","name":"convert_encoding","children":[],"call":["str encode ","encoding present? "," get_charset "]}," HBLText Setter to_utf8":{"type":"method","name":"to_utf8","children":[],"call":["(send\n  (lvar :arg) :map) to_h "," to_utf8 ","arg map "," convert_encoding "]}," HBLText IDMaker abbreviation":{"type":"method","name":"abbreviation","children":[],"call":["exclusions include? ! ","exclusions include? ","abbr length == ","abbr length ","abbr present? ","(send\n  (block\n    (send\n      (lvar :combination) :map)\n    (args\n      (arg :word))\n    (send\n      (lvar :word) :first\n      (lvar :stem))) :select) join first ","(send\n  (block\n    (send\n      (lvar :combination) :map)\n    (args\n      (arg :word))\n    (send\n      (lvar :word) :first\n      (lvar :stem))) :select) join ","w length >= ","w length ","(send\n  (lvar :combination) :map) select ","word first ","combination map ","words combination each_with_index ","words combination ","(send\n  (block\n    (send\n      (lvar :combination) :map)\n    (args\n      (arg :word))\n    (send\n      (lvar :word) :first\n      (lvar :stem))) :select) join first  length == ","(send\n  (block\n    (send\n      (lvar :combination) :map)\n    (args\n      (arg :word))\n    (send\n      (lvar :word) :first\n      (lvar :stem))) :select) join first  length ","(send\n  (block\n    (send\n      (lvar :combination) :map)\n    (args\n      (arg :word))\n    (send\n      (lvar :word) :first\n      (lvar :stem))) :select) join first  present? "]}," HBLText IDMaker find_identifier":{"type":"method","name":"find_identifier","children":[],"call":["Rails  logger info ","(str \"no suffix\") join + ","(str \"no suffix\") join ","Rails  logger "," refs include? "," refs ","(lvar :ref) join ","comb join ","combs each_with_index ","chars combination ","chunk split ","words join + ","words join ","suffix present? ","ref [] != ","chunk [] ","ref [] ","(send\n  (lvar :words) :map) drop ","w [] + ","w [] ","n - ","words map ","(send\n  (lvar :words) :join\n  (str \", \")) join + ","(send\n  (lvar :words) :join\n  (str \", \")) join ","ref length == ","ref length ","chunks each_with_index ","words length > ","words length ","words [] [] to_s + ","words [] [] to_s ","words [] [] ","words [] ","(lvar :chunk) join + ","(lvar :chunk) join ","chunk length > ","chunk length ","(send\n  (lvar :words) :map) each ","abbr present? "," abbreviation ","(send\n  (lvar :words) :<<\n  (lvar :suffix)) join split ","(send\n  (lvar :words) :<<\n  (lvar :suffix)) join ","words << ","words join split ","n > ","words map! ","words select ","(send\n  (lvar :words) :map) flatten ","word split ","words split ","identifiable to_s "," comb join s include? "," comb join s ","(lvar :comb join ) join ","chars combination  each_with_index ","chunk split  combination ","words join +  split ","(send\n  (lvar :words) :map) drop  split ","words [] [] to_s +  split ","words select  join + ","(send\n  (lvar :words) :map) flatten  join + ","words split  join + ","identifiable to_s  join + ","words select  join ","(send\n  (lvar :words) :map) flatten  join ","words split  join ","identifiable to_s  join ","comb join  [] != ","words join +  [] ","(send\n  (lvar :words) :map) drop  [] ","words [] [] to_s +  [] ","comb join  [] ","(send\n  (lvar :words select ) :map) drop ","(send\n  (lvar :(send\n  (lvar :words) :map) flatten ) :map) drop ","(send\n  (lvar :words split ) :map) drop ","(send\n  (lvar :identifiable to_s ) :map) drop ","words select  map ","(send\n  (lvar :words) :map) flatten  map ","words split  map ","identifiable to_s  map ","(send\n  (lvar :words select ) :join\n  (str \", \")) join + ","(send\n  (lvar :(send\n  (lvar :words) :map) flatten ) :join\n  (str \", \")) join + ","(send\n  (lvar :words split ) :join\n  (str \", \")) join + ","(send\n  (lvar :identifiable to_s ) :join\n  (str \", \")) join + ","(send\n  (lvar :words select ) :join\n  (str \", \")) join ","(send\n  (lvar :(send\n  (lvar :words) :map) flatten ) :join\n  (str \", \")) join ","(send\n  (lvar :words split ) :join\n  (str \", \")) join ","(send\n  (lvar :identifiable to_s ) :join\n  (str \", \")) join ","comb join  length == ","comb join  length ","words join + s each_with_index ","(send\n  (lvar :words) :map) drop s each_with_index ","words [] [] to_s + s each_with_index ","(send\n  (lvar :words) :map) drop  each_with_index ","words select  length > ","(send\n  (lvar :words) :map) flatten  length > ","words split  length > ","identifiable to_s  length > ","words select  length ","(send\n  (lvar :words) :map) flatten  length ","words split  length ","identifiable to_s  length ","words select  [] [] to_s + ","(send\n  (lvar :words) :map) flatten  [] [] to_s + ","words split  [] [] to_s + ","identifiable to_s  [] [] to_s + ","words select  [] [] to_s ","(send\n  (lvar :words) :map) flatten  [] [] to_s ","words split  [] [] to_s ","identifiable to_s  [] [] to_s ","words select  [] [] ","(send\n  (lvar :words) :map) flatten  [] [] ","words split  [] [] ","identifiable to_s  [] [] ","words select  [] ","(send\n  (lvar :words) :map) flatten  [] ","words split  [] ","identifiable to_s  [] ","(lvar :words join + ) join + ","(lvar :(send\n  (lvar :words) :map) drop ) join + ","(lvar :words [] [] to_s + ) join + ","(lvar :words join + ) join ","(lvar :(send\n  (lvar :words) :map) drop ) join ","(lvar :words [] [] to_s + ) join ","words join +  length > ","(send\n  (lvar :words) :map) drop  length > ","words [] [] to_s +  length > ","words join +  length ","(send\n  (lvar :words) :map) drop  length ","words [] [] to_s +  length ","(send\n  (lvar :words select ) :map) each ","(send\n  (lvar :(send\n  (lvar :words) :map) flatten ) :map) each ","(send\n  (lvar :words split ) :map) each ","(send\n  (lvar :identifiable to_s ) :map) each ","(send\n  (lvar :words select ) :<<\n  (lvar :suffix)) join split ","(send\n  (lvar :(send\n  (lvar :words) :map) flatten ) :<<\n  (lvar :suffix)) join split ","(send\n  (lvar :words split ) :<<\n  (lvar :suffix)) join split ","(send\n  (lvar :identifiable to_s ) :<<\n  (lvar :suffix)) join split ","(send\n  (lvar :words select ) :<<\n  (lvar :suffix)) join ","(send\n  (lvar :(send\n  (lvar :words) :map) flatten ) :<<\n  (lvar :suffix)) join ","(send\n  (lvar :words split ) :<<\n  (lvar :suffix)) join ","(send\n  (lvar :identifiable to_s ) :<<\n  (lvar :suffix)) join ","words select  << ","(send\n  (lvar :words) :map) flatten  << ","words split  << ","identifiable to_s  << ","words select  join split ","(send\n  (lvar :words) :map) flatten  join split ","words split  join split ","identifiable to_s  join split ","words select  map! ","(send\n  (lvar :words) :map) flatten  map! ","words split  map! ","identifiable to_s  map! ","words select  select ","(send\n  (lvar :words) :map) flatten  select ","words split  select ","identifiable to_s  select ","(send\n  (lvar :words select ) :map) flatten ","(send\n  (lvar :(send\n  (lvar :words) :map) flatten ) :map) flatten ","(send\n  (lvar :words split ) :map) flatten ","(send\n  (lvar :identifiable to_s ) :map) flatten ","words select  split ","(send\n  (lvar :words) :map) flatten  split ","words split  split ","identifiable to_s  split "]}," HBLText IDMaker make_identifier":{"type":"method","name":"make_identifier","children":[],"call":["ref present? ","Rails  logger info ","(lvar :ref) map join ","(lvar :ref) map "," sprintf ","uggliness presence ","Rails  logger "," find_identifier ","suffix [] ","(irange\n  (int 0)\n  (begin\n    (send\n      (send\n        (lvar :suffix) :length) :+\n      (int 1)))) each ","suffix length + ","suffix length ","options [] "]}}