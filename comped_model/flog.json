{" Flog process_sclass":{"type":"method","name":"process_sclass","children":[],"call":[" s "," add_to_score "," process ","exp shift ","exp empty? "," bad_dog! ","OTHER_SCORES  [] "," bleed "," analyze_list "," penalize_by "," process_until_empty ","@sclass pop ","@sclass push "]}," Flog process_module":{"type":"method","name":"process_module","children":[],"call":[" s "," process ","exp shift ","exp empty? "," bleed "," klass "," analyze_list "," in_klass "," process_until_empty "]}," Flog process_lit":{"type":"method","name":"process_lit","children":[],"call":[" s "," raise ","value inspect "," add_to_score ","exp shift ","OTHER_SCORES  [] ","value class "," context [] == "," context [] "," context ","exp shift  inspect ","exp shift  class "]}," Flog process_defs":{"type":"method","name":"process_defs","children":[],"call":[" s "," process ","exp shift ","exp empty? "," bleed "," method "," analyze_list "," in_method "," process_until_empty ","exp line ","exp file "]}," Flog process_defn":{"type":"method","name":"process_defn","children":[],"call":[" s "," process ","exp shift ","exp empty? "," bleed "," method "," analyze_list "," in_method "," process_until_empty ","exp line ","exp file ","@sclass empty? "]}," Flog process_class":{"type":"method","name":"process_class","children":[],"call":[" s "," process ","exp shift ","exp empty? "," bad_dog! "," bleed "," klass "," analyze_list "," penalize_by "," in_klass "," process_until_empty "]}," Flog process_call":{"type":"method","name":"process_call","children":[],"call":[" s "," add_to_score ","SCORES  [] "," process ","exp shift "," bad_dog! "," penalize_by "," process_until_empty "," add_to_SCORES  []  "]}," Flog process_block_pass":{"type":"method","name":"process_block_pass","children":[],"call":[" s "," process "," raise ","(pair\n  (sym :block_pass)\n  (array\n    (lvar :call)\n    (lvar :arg))) inspect "," add_to_score ","arg first ","exp shift ","(pair\n  (sym :block_pass)\n  (array\n    (lvar :arg)\n    (lvar :call))) inspect ","OTHER_SCORES  [] ","(pair\n  (sym :block_pass_even_ickier!)\n  (array\n    (lvar :arg)\n    (send nil :call))) inspect "," call ","(pair\n  (sym :block_pass_even_ickier!)\n  (lvar :arg)) inspect ","arg sexp_type ","(pair\n  (sym :block_pass)\n  (array\n    (lvar : process )\n    (lvar :arg))) inspect ","(pair\n  (sym :block_pass)\n  (array\n    (lvar :exp shift )\n    (lvar :arg))) inspect ","(pair\n  (sym :block_pass)\n  (array\n    (lvar :call)\n    (lvar :exp shift ))) inspect ","exp shift  first ","(pair\n  (sym :block_pass)\n  (array\n    (lvar :arg)\n    (lvar : process ))) inspect ","(pair\n  (sym :block_pass)\n  (array\n    (lvar :arg)\n    (lvar :exp shift ))) inspect ","(pair\n  (sym :block_pass)\n  (array\n    (lvar :exp shift )\n    (lvar :call))) inspect ","(pair\n  (sym :block_pass_even_ickier!)\n  (array\n    (lvar :arg)\n    (send nil : process ))) inspect ","(pair\n  (sym :block_pass_even_ickier!)\n  (array\n    (lvar :arg)\n    (send nil :exp shift ))) inspect ","(pair\n  (sym :block_pass_even_ickier!)\n  (array\n    (lvar :exp shift )\n    (send nil :call))) inspect ","  process  "," exp shift  ","(pair\n  (sym :block_pass_even_ickier!)\n  (lvar :exp shift )) inspect ","exp shift  sexp_type "]}," Flog process_alias":{"type":"method","name":"process_alias","children":[],"call":[" s "," add_to_score "," process ","exp shift ","OTHER_SCORES  [] "]}," Flog bad_dog!":{"type":"method","name":"bad_dog!","children":[],"call":[]}," Flog add_to_score":{"type":"method","name":"add_to_score","children":[],"call":["score * ","@calls [] [] ","@calls [] ","@totals [] "," method_name "," klass_name "," signature "," method_stack empty? "," method_stack "," option [] "," option "]}," Flog report":{"type":"method","name":"report","children":[],"call":["current >= "," puts ","  %4d: %s % ","(send\n  (lvar :calls) :sort_by) each ","v -@ ","calls sort_by ","%s: (%d) % ","@totals [] ","(send\n  (ivar :@calls) :sort_by) each ","@totals [] -@ ","@calls sort_by ","total_score * ","sum + ","@totals values inject ","@totals values "," reset ","io puts ","  %6.1f: %s % ","%s: (%.1f) % ","totals [] ","totals [] -@ "," exit "," totals "," total ","klass_method =~ ","Total Flog = %.1f (%.1f +/- %.1f flog / method) % "," stddev "," average "," output_details "," total * "," options [] "," options "," output_summary "," option [] "," option ","%8.1f: %s % "," output_details_grouped ","@@totals [] s [] ","@totals [] s [] ","@ totals  [] ","@@totals [] s [] -@ ","@totals [] s [] -@ ","@ totals  [] -@ ","@totals [] _score * ","totals [] _score * "," total  * ","@@totals [] s values inject ","@totals [] s values inject ","@ totals  values inject ","@@totals [] s values ","@totals [] s values ","@ totals  values ","totals [] s [] "," totals  [] ","totals [] s [] -@ "," totals  [] -@ "," @totals [] s "," totals [] s ","  totals  "," @totals []  "," totals []  "," @totals []  * "," totals []  * "]}," Flog process_files":{"type":"method","name":"process_files","children":[],"call":[" process ","Sexp  from_array ","@pt parse_tree_for_string ","File  read ","$stdin read ","file == ","File  file? ","files flatten each ","files flatten "]}," Flog initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","Hash  new "," require_empty= "," auto_shift_type= ","ParseTree  new "," reset ","RubyParser  new ","option [] new ","option [] "]}," Flog process_yield":{"type":"method","name":"process_yield","children":[],"call":[" s "," bleed "," add_to_score ","OTHER_SCORES  [] "," analyze_list "," process_until_empty "]}," Flog process_while":{"type":"method","name":"process_while","children":[],"call":[" s ","exp shift "," process "," bad_dog! "," add_to_score ","OTHER_SCORES  [] "," penalize_by "]}," Flog process_when":{"type":"method","name":"process_when","children":[],"call":[" s "," bleed "," bad_dog! "," add_to_score ","OTHER_SCORES  [] "]}," Flog process_until":{"type":"method","name":"process_until","children":[],"call":[" s ","exp shift "," process "," bad_dog! "," add_to_score ","OTHER_SCORES  [] "]}," Flog process_super":{"type":"method","name":"process_super","children":[],"call":[" s "," bleed "," add_to_score ","OTHER_SCORES  [] "," analyze_list "," process_until_empty "]}," Flog process_rescue":{"type":"method","name":"process_rescue","children":[],"call":[" s "," bleed "," bad_dog! "," add_to_score ","OTHER_SCORES  [] "]}," Flog process_or":{"type":"method","name":"process_or","children":[],"call":[" s "," process ","exp shift "," bad_dog! "," add_to_score ","OTHER_SCORES  [] "]}," Flog process_masgn":{"type":"method","name":"process_masgn","children":[],"call":[" s "," process ","exp shift "," add_to_score ","OTHER_SCORES  [] "," bleed "," analyze_list "," process_until_empty ","Sexp  === ","exp map! "]}," Flog process_lasgn":{"type":"method","name":"process_lasgn","children":[],"call":[" s "," process ","exp shift "," add_to_score ","OTHER_SCORES  [] "]}," Flog process_iter":{"type":"method","name":"process_iter","children":[],"call":[" s "," bleed "," bad_dog! "," process ","exp shift "," add_to_score ","OTHER_SCORES  [] "," klass "," method ","recv arglist [] [] ","recv arglist [] ","recv arglist ","recv [] ","(sym :lit) include? ","recv [] == ","exp first ","(send\n  (send\n    (lvar :context) :uniq) :sort_by) == ","s to_s ","context uniq sort_by ","context uniq "," context - "," context "," analyze_list "," penalize_by ","exp pop ","exp last == ","exp last "," in_klass "," in_method ","exp delete "," process_until_empty ","exp line ","exp file ","context == ","(const nil :String) include? ","submsg class "," dsl_name? ","r == ","t == ","a [] ","exp max_line ","exp line_max ","exp first  arglist [] [] ","exp first  arglist [] ","exp first  arglist ","exp first  [] ","exp first  [] == ","recv arglist [] []  class "," dsl_name?  class ","a []  class ","subrecv []  class "]}," Flog process_if":{"type":"method","name":"process_if","children":[],"call":[" s "," process ","exp shift "," bad_dog! "," add_to_score ","OTHER_SCORES  [] "," penalize_by "]}," Flog process_iasgn":{"type":"method","name":"process_iasgn","children":[],"call":[" s "," process ","exp shift "," add_to_score ","OTHER_SCORES  [] "]}," Flog process_else":{"type":"method","name":"process_else","children":[],"call":[" s "," bleed "," bad_dog! "," add_to_score ","OTHER_SCORES  [] "," analyze_list "," penalize_by "," process_until_empty "]}," Flog process_dasgn_curr":{"type":"method","name":"process_dasgn_curr","children":[],"call":[" s "," process ","exp shift "," add_to_score ","OTHER_SCORES  [] "]}," Flog process_case":{"type":"method","name":"process_case","children":[],"call":[" s "," bleed "," bad_dog! "," process ","exp shift "," add_to_score ","OTHER_SCORES  [] "," analyze_list "," penalize_by "," process_until_empty "]}," Flog process_block":{"type":"method","name":"process_block","children":[],"call":[" s "," bleed "," bad_dog! "," analyze_list "," penalize_by "," process_until_empty "]}," Flog process_attrset":{"type":"method","name":"process_attrset","children":[],"call":[" s "," raise ","exp inspect "," add_to_score ","OTHER_SCORES  [] "]}," Flog process_attrasgn":{"type":"method","name":"process_attrasgn","children":[],"call":[" s "," process ","exp shift "," add_to_score ","OTHER_SCORES  [] "," process_until_empty "]}," Flog process_and":{"type":"method","name":"process_and","children":[],"call":[" s "," process ","exp shift "," bad_dog! "," add_to_score ","OTHER_SCORES  [] "," penalize_by "]}," Flog totals":{"type":"method","name":"totals","children":[],"call":["@totals []= ","Math  sqrt ","a * + + ","c * ","a * + ","b * ","a * ","tally each "," calls each "," calls ","Hash  new ","1 / * ","1 / ","(send\n  (lvar :i) :-\n  (ivar :@average)) ** ","i - ","@totals values each ","@totals values ","@total / "," calls size to_f "," calls size ","meth =~ "," summarize_method "," score_method "," option [] "," option ","Hash  new  []= ","(send\n  (lvar :i) :-\n  (ivar :@total / )) ** ","Hash  new  values each ","Hash  new  values "," calls  calls size to_f  to_f "," calls  calls size to_f  "," Math  sqrt _method ","  score_method _method "]}," Flog total":{"type":"method","name":"total","children":[],"call":[" totals "]}," Flog reset":{"type":"method","name":"reset","children":[],"call":["h []= ","Hash  new "," method_locations clear "," method_locations "]}," Flog method_name":{"type":"method","name":"method_name","children":[],"call":["@methods first ","@method_stack first ","m =~ ","m == "]}," Flog method":{"type":"method","name":"method","children":[],"call":["@methods shift ","@methods unshift "]}," Flog klass_name":{"type":"method","name":"klass_name","children":[],"call":["@klasses first ","name last ","name join ","name delete ","name flatten ","name first ","Sexp  === ","@class_stack first ","name last to_s ","@class_stack reverse join ","@class_stack reverse ","@class_stack any? "," raise ","@class_stack reverse join sub ","name last  last ","name join  last ","name flatten  last ","@class_stack first  last ","name last  join ","name join  join ","name flatten  join ","@class_stack first  join ","name last  delete ","name join  delete ","name flatten  delete ","@class_stack first  delete ","name last  flatten ","name join  flatten ","name flatten  flatten ","@class_stack first  flatten ","name last  first ","name join  first ","name flatten  first ","@class_stack first  first ","name last  last to_s ","name join  last to_s ","name flatten  last to_s ","@class_stack first  last to_s "]}," Flog klass":{"type":"method","name":"klass","children":[],"call":["@klasses shift ","@klasses unshift "]}," Flog flog_files":{"type":"method","name":"flog_files","children":[],"call":[" raise "," warn ","e inspect + + ","e backtrace first join ","e backtrace first ","e backtrace ","e inspect + ","e inspect ","e inspect =~ "," process ","Sexp  from_array first ","Sexp  from_array ","@pt parse_tree_for_string ","File  read ","$stdin read ","file == "," flog_files ","Dir  [] ","File  directory? ","files flatten each ","files flatten "," flog_file "]}," Flog bleed":{"type":"method","name":"bleed","children":[],"call":[" process ","exp shift ","exp empty? "]}," FlogGauntlet group_by_owner":{"type":"method","name":"group_by_owner","children":[],"call":["$owners []= ","owner uniq ","spec full_name ","owner << ","name =~ ","name !~ ","owner include? ","o sub ","owner map! "," Array ","spec email ","owner empty? ","spec authors compact ","spec authors ","spec name "," latest_gems each "," latest_gems ","$ Array s []= ","$spec authors compact s []= "," Array  uniq ","spec authors compact  uniq ","spec full_spec name  "," Array  << ","spec authors compact  << ","spec name  =~ ","spec name  !~ "," Array  include? ","spec authors compact  include? "," Array  map! ","spec authors compact  map! "," Array  empty? ","spec authors compact  empty? ","spec spec name  "]}," FlogGauntlet report_worst":{"type":"method","name":"report_worst","children":[],"call":[" puts ","(str \"%3d: %9.2f: %-\") % ","i + ","data each_with_index ","(send\n  (lvar :data) :map) max ","k first size ","k first ","data map "," title "]}," FlogGauntlet report_bad_people":{"type":"method","name":"report_bad_people","children":[],"call":[" puts ","fmt % ","$score_per_owner [] ","projects size ","i + ","projects values average ","projects values ","bad_people each_with_index ","(send\n  (lvar :bad_people) :map) max ","a first size ","a first ","bad_people map "," title "]}," FlogGauntlet report":{"type":"method","name":"report","children":[],"call":[" puts ","(str \"%4d: %-\") % ","i + ","data each_with_index "," title ","data size ","(send\n  (lvar :data) :map) max ","d first size ","d first ","data map ","(send\n  (lvar :data) :map) (send\n  (lvar :data) :map) max  "]}," FlogGauntlet title":{"type":"method","name":"title","children":[],"call":[" block_given? "," puts "]}," FlogGauntlet score_for":{"type":"method","name":"score_for","children":[],"call":["$misc_error dup "," warn ","e inspect + + ","e backtrace first join ","e backtrace first ","e backtrace ","e inspect + ","e inspect ","$syntax_error dup ","flogger stddev ","flogger average ","methods size ","flogger total ","methods values max ","methods values ","Hash  [] ","(send\n  (lvar :methods) :sort_by) first flatten ","(send\n  (lvar :methods) :sort_by) first ","v -@ ","methods sort_by ","k =~ ","flogger totals reject ","flogger totals ","flogger flog_files ","Flog  new ","f =~ ","Dir  [] reject ","Dir  [] ","flogger total_score ","Flog  new  stddev ","Flog  new  average ","Flog  new  total ","Flog  new  totals reject ","Flog  new  totals ","Flog  new  flog_files ","Flog  new  total_score "]}," FlogGauntlet display_report":{"type":"method","name":"display_report","children":[],"call":["(send\n  (gvar :$projects_per_owner) :sort_by) first ","$score_per_owner [] -@ ","$score_per_owner [] ","v size -@ ","v size ","$projects_per_owner sort_by "," report_bad_people ","v values average -@ ","v values average ","v values ","$projects_per_owner [] []= ","$projects_per_owner [] ","scores [] [] ","scores [] ","owner =~ ","owners each ","scores has_key? ","$owners each ","h []= ","Hash  new "," report ","(send\n  (lvar :project_stats) :sort_by) first ","a -@ ","project_stats sort_by ","c -@ "," puts ","(str \"%3d: %9.2f: %-\") % ","i + ","worst each_with_index "," title ","(send\n  (lvar :worst) :map) max ","name size ","worst map ","(send\n  (lvar :worst) :sort_by) first ","v -@ ","worst sort_by ","worst []= ","spec [] each ","spec [] ","long_name sub ","scores each ","score [] "," raise ","owner nil? ","owner empty? ","$owners [] join ","$owners [] "," report_worst ","(send\n  (lvar :scores) :sort_by) first ","v [] -@ ","v [] ","scores sort_by ","avg flog / gem    : %8.2f (%8.2f stddev) % ","flog_numbers stddev ","flog_numbers average ","avg methods / gem : %8.2f (%8.2f stddev) % ","method_counts stddev ","method_counts average ","total # methods   : %8d % ","total # gems      : %8d % ","scores size ","scores map "," group_by_owner ","project_stats each ","v stddev ","v average ","project_numbers map ","v [] values ","v [] empty? ","v [] nil? ","@data reject ","Hash  new  [] -@ ","Hash  new  [] ","(send\n  (lvar :worst) :sort_by) first  each_with_index ","(send\n  (lvar :scores) :sort_by) first  each_with_index ","(send\n  (lvar :(send\n  (lvar :worst) :sort_by) first ) :map) max ","(send\n  (lvar :(send\n  (lvar :scores) :sort_by) first ) :map) max ","long_name sub  size ","(send\n  (lvar :worst) :sort_by) first  map ","(send\n  (lvar :scores) :sort_by) first  map ","(send\n  (lvar :(send\n  (lvar :worst) :sort_by) first ) :sort_by) first ","(send\n  (lvar :(send\n  (lvar :scores) :sort_by) first ) :sort_by) first ","(send\n  (lvar :worst) :sort_by) first  sort_by ","(send\n  (lvar :scores) :sort_by) first  sort_by ","(send\n  (lvar :worst) :sort_by) first  []= ","(send\n  (lvar :scores) :sort_by) first  []= ","long_long_name sub  sub "," report_(send\n  (lvar :worst) :sort_by) first  "," report_(send\n  (lvar :scores) :sort_by) first  "]}," FlogGauntlet run":{"type":"method","name":"run","children":[],"call":[" dirty= "," data []= "," score_for "," data "," warn "]}," Flog summarize_method":{"type":"method","name":"summarize_method","children":[],"call":[" increment_total_score_by "," record_method_score "," score_method ","meth =~ "," options [] "," options "," increment_total_ score_method _by "," record_method_ score_method  ","  score_method _method "]}," Flog score_method":{"type":"method","name":"score_method","children":[],"call":["Math  sqrt ","a * + + ","c * ","a * + ","b * ","a * ","tally each "]}," Flog record_method_score":{"type":"method","name":"record_method_score","children":[],"call":["@totals []= ","Hash  new "]}," Flog process_parse_tree":{"type":"method","name":"process_parse_tree","children":[],"call":[" process ","Sexp  from_array first ","Sexp  from_array "," parse_tree parse_tree_for_string "," parse_tree "]}," Flog penalize_by":{"type":"method","name":"penalize_by","children":[],"call":[]}," Flog parse_tree":{"type":"method","name":"parse_tree","children":[],"call":["ParseTree  new "]}," Flog output_summary":{"type":"method","name":"output_summary","children":[],"call":["io puts ","Total Flog = %.1f (%.1f flog / method)\n % "," average "," total ","%8.1f: %s % "]}," Flog output_method_details":{"type":"method","name":"output_method_details","children":[],"call":["io puts ","  %6.1f: %s % ","(send\n  (lvar :call_list) :sort_by) each ","v -@ ","call_list sort_by "," options [] "," options ","%s: (%.1f) % "," totals [] "," totals ","class_method =~ ","%8.1f: %s % ","  %6.1f:   %s % "," option [] "," option ","%8.1f: %-32s %s % ","@method_locations [] ","  totals [] s [] ","  totals [] s ","@method_@method_locations [] s [] "]}," Flog output_details":{"type":"method","name":"output_details","children":[],"call":["current >= "," output_method_details ","(send\n  (send nil :calls) :sort_by) each ","my_totals [] -@ ","my_totals [] "," calls sort_by "," calls "," totals ","io puts ","%8.1f: %s % ","methods [] each ","methods [] ","(send\n  (lvar :scores) :sort_by) each ","n -@ ","scores sort_by ","scores [] ","methods [] << "," totals [] ","class_method split first ","class_method split ","h []= ","Hash  new "," options [] "," options ","%8.1f: %-32s %s % ","@method_locations [] "," option [] "," option ","  %6.1f:   %s % ","(send\n  (lvar :call_list) :sort_by) each ","v -@ ","call_list sort_by "," print_score ","class_method =~ "," each_by_score "," totals  [] -@ "," totals  [] ","(send\n  (lvar : totals [] s) :sort_by) each ","(send\n  (lvar :Hash  new ) :sort_by) each "," totals [] s sort_by ","Hash  new  sort_by "," totals [] s [] ","Hash  new  [] ","@method_@method_locations [] s [] "," print_ totals []  "," each_by_ totals []  "]}," Flog increment_total_score_by":{"type":"method","name":"increment_total_score_by","children":[],"call":[" raise "]}," Flog in_method":{"type":"method","name":"in_method","children":[],"call":["@method_stack shift ","@method_stack unshift ","@method_locations []= "," signature ","name to_s ","name inspect ","Regexp  === "]}," Flog in_klass":{"type":"method","name":"in_klass","children":[],"call":["@class_stack shift ","@class_stack unshift "," raise ","name inspect ","name last to_s ","name last ","name join ","name delete ","name flatten ","name first ","Sexp  === ","name flatten  inspect ","name flatten  last to_s ","name flatten  last ","name flatten  join ","name flatten  delete ","name flatten  flatten ","name flatten  first "]}," Flog flog_file":{"type":"method","name":"flog_file","children":[],"call":[" flog "," warn "," options [] "," options ","File  read ","$stdin read "," raise ","file == "," flog_directory ","File  directory? "]}," Flog flog_directory":{"type":"method","name":"flog_directory","children":[],"call":[" flog_file ","Dir  [] each ","Dir  [] "]}," Flog flog":{"type":"method","name":"flog","children":[],"call":[" warn ","e backtrace first join ","e backtrace first ","e backtrace ","e inspect "," raise "," options [] "," options ","e inspect + + ","e inspect + ","e inspect =~ "," process_parse_tree "," collect_blame "," process "," mass []= ","ast mass "," mass ","@parser process ","File  read ","$stdin read ","file == ","files each ","Flog  expand_dirs_to_files ","ruby =~ "," option [] "," option ","e message strip ","e message ","e class "," option [] new ","File  binread ","%s: %s at:\n  %s % ","(or\n  (send\n    (send nil :option) :[]\n    (sym :parser))\n  (const nil :RubyParser)) new "," flog_ruby ","File  readable? "," calculate_total_scores ","@parser process  mass "," option [] new  process ","(or\n  (send\n    (send nil :option) :[]\n    (sym :parser))\n  (const nil :RubyParser)) new  process ","Flog  expand_dirs_to_files  each ","Flog  expand_dirs_to_Flog  expand_dirs_to_files  ","File  read  =~ ","$stdin read  =~ ","File  binread  =~ "," flog_File  read  "," flog_$stdin read  "," flog_File  binread  "]}," Flog collect_blame":{"type":"method","name":"collect_blame","children":[],"call":[]}," Flog average":{"type":"method","name":"average","children":[],"call":[" total / "," calls size "," calls "," total "," calls size == "," total_score / "," total_score "]}," Flog analyze_list":{"type":"method","name":"analyze_list","children":[],"call":[" process ","exp shift ","exp empty? "]}," FlogTask define":{"type":"method","name":"define","children":[],"call":[" raise "," threshold ","flog total ","flog total > ","flog report "," verbose ","flog flog_files "," dirs ","Flog  new "," task "," name "," desc "," dirs join ","flog flog "," require ","score > ","flog send "," method ","FlogCLI  new ","expander process ","PathExpander  new ","Flog  new  total ","FlogCLI  new  total ","Flog  new  total > ","FlogCLI  new  total > ","Flog  new  report ","FlogCLI  new  report ","Flog  new  Flog  new _files ","FlogCLI  new  FlogCLI  new _files ","flog flog_expander process  ","Flog  new  Flog  new  ","FlogCLI  new  FlogCLI  new  ","Flog  new  send ","FlogCLI  new  send ","PathExpander  new  process "]}," FlogTask initialize":{"type":"method","name":"initialize","children":[],"call":[" define ","File  directory? ! ","File  directory? ","@dirs reject! "," block_given? ","Rake  application options trace ","Rake  application options ","Rake  application "]}," Flog parse_options":{"type":"method","name":"parse_options","children":[],"call":[]}," Flog default_options":{"type":"method","name":"default_options","children":[],"call":[]}," Flog expand_dirs_to_files":{"type":"method","name":"expand_dirs_to_files","children":[],"call":[]}," Sexp mass":{"type":"method","name":"mass","children":[],"call":[" structure flatten size "," structure flatten "," structure "]}," Flog signature":{"type":"method","name":"signature","children":[],"call":[" klass_name ","m == "," method_name "," klass_na method_name e "," method_name  == ","  method_name ethod_na method_name e "]}," Flog process_until_empty":{"type":"method","name":"process_until_empty","children":[],"call":[" process ","exp shift ","exp empty? "]}," Flog print_score":{"type":"method","name":"print_score","children":[],"call":["io puts ","%8.1f: %s % ","%8.1f: %-32s %s % ","@method_locations [] ","@method_@method_locations [] s [] "]}," Flog output_details_grouped":{"type":"method","name":"output_details_grouped","children":[],"call":[" print_score ","methods [] each ","methods [] ","io puts ","%8.1f: %s % ","(send\n  (lvar :scores) :sort_by) each ","n -@ ","scores sort_by ","scores [] ","methods [] << ","class_method split first ","class_method split "," each_by_score ","h []= ","Hash  new ","(send\n  (lvar :Hash  new ) :sort_by) each ","Hash  new  sort_by ","Hash  new  [] "]}," Flog each_by_score":{"type":"method","name":"each_by_score","children":[],"call":["current >= ","my_totals [] ","(send\n  (send nil :calls) :sort_by) each ","my_totals [] -@ "," calls sort_by "," calls "," totals "," totals [] "," totals [] -@ "," totals  [] "," totals  [] -@ "]}," Flog load_plugins":{"type":"method","name":"load_plugins","children":[],"call":[]}," Flog plugins":{"type":"method","name":"plugins","children":[],"call":[]}," Flog dsl_name?":{"type":"method","name":"dsl_name?","children":[],"call":["first_arg [] ","(sym :lit) include? ","first_arg [] == ","args first ","args empty? ! ","args empty? ","first_arg sexp_type == ","first_arg sexp_type ","first_arg []  [] ","args first  [] ","first_arg []  [] == ","args first  [] == ","first_arg []  sexp_type == ","args first  sexp_type == ","first_arg []  sexp_type ","args first  sexp_type "]}," Flog max_method":{"type":"method","name":"max_method","children":[],"call":[" totals max_by "," totals "]}," Flog max_score":{"type":"method","name":"max_score","children":[],"call":[" max_method last "," max_method "]}," Flog flog_ruby!":{"type":"method","name":"flog_ruby!","children":[],"call":[" process "," mass []= ","ast mass "," mass ","@parser process "," warn "," option [] "," option ","(or\n  (send\n    (send nil :option) :[]\n    (sym :parser))\n  (const nil :RubyParser)) new ","@parser process  mass ","(or\n  (send\n    (send nil :option) :[]\n    (sym :parser))\n  (const nil :RubyParser)) new  process "]}," Flog flog_ruby":{"type":"method","name":"flog_ruby","children":[],"call":[" warn ","%s: %s at:\n  %s % ","e backtrace first join ","e backtrace first ","e backtrace ","e message strip ","e message ","e class "," raise "," option [] "," option ","e inspect ","ruby =~ ","e inspect =~ "," flog_ruby! "]}," FlogCLI report":{"type":"method","name":"report","children":[],"call":[" reset "," output_details "," threshold "," output_details_grouped "," option [] "," option ","io puts ","%8.1f: %s % "," average "," total_score "]}," FlogCLI print_score":{"type":"method","name":"print_score","children":[],"call":["io puts ","%8.1f: %s % ","%8.1f: %-32s %s % "," method_locations [] "," method_locations ","%8.1f: %-32s%s%s % ","%-11s % "," option [] "," option "," method_ method_locations [] s [] "," method_ method_locations [] s "]}," FlogCLI output_details_grouped":{"type":"method","name":"output_details_grouped","children":[],"call":[" print_score "," method_scores [] each "," method_scores [] "," method_scores ","io puts ","%8.1f: %s % ","(send\n  (send nil :scores) :sort_by) each ","n -@ "," scores sort_by "," scores "," calculate "]}," FlogCLI output_details":{"type":"method","name":"output_details","children":[],"call":["io puts ","  %6.1f:   %s % ","(send\n  (lvar :call_list) :sort_by) each ","v -@ ","call_list sort_by "," option [] "," option "," print_score ","class_method =~ "," no_method "," each_by_score "]}," FlogCLI initialize":{"type":"method","name":"initialize","children":[],"call":["Flog  new "]}," FlogCLI flog":{"type":"method","name":"flog","children":[],"call":["@flog flog ","FlogCLI  expand_dirs_to_files ","files << ","files empty? ","FlogCLI  expand_dirs_to_FlogCLI  expand_dirs_to_files  ","FlogCLI  expand_dirs_to_files  << ","FlogCLI  expand_dirs_to_files  empty? "]}," FlogCLI plugins":{"type":"method","name":"plugins","children":[],"call":[]}," FlogCLI parse_options":{"type":"method","name":"parse_options","children":[],"call":[]}," FlogCLI load_plugins":{"type":"method","name":"load_plugins","children":[],"call":[]}," FlogCLI expand_dirs_to_files":{"type":"method","name":"expand_dirs_to_files","children":[],"call":[]}," Flog no_method":{"type":"method","name":"no_method","children":[],"call":[]}," Flog calculate_total_scores":{"type":"method","name":"calculate_total_scores","children":[],"call":["@totals []= "," score_method ","meth =~ "," option [] "," option "," calls each "," calls ","Hash  new ","Hash  new  []= ","  score_method _method "]}," Flog threshold":{"type":"method","name":"threshold","children":[],"call":[" total_score * "," total_score "," option [] "," option "]}," Flog calculate":{"type":"method","name":"calculate","children":[],"call":[" scores [] "," scores "," method_scores [] << "," method_scores [] "," method_scores ","class_method split first ","class_method split "," each_by_score "," threshold ","class_method scan first ","class_method scan "]}," FlogCLI run":{"type":"method","name":"run","children":[],"call":[]}," Flog process_safe_call":{"type":"method","name":"process_safe_call","children":[],"call":[" s "," add_to_score ","SCORES  [] "," process_until_empty "," penalize_by ","exp shift "," process "]}}