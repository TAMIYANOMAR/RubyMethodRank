{" Mustermann extend_object":{"type":"method","name":"extend_object","children":[],"call":[]}," Mustermann register":{"type":"method","name":"register","children":[],"call":["identifier to_s capitalize ","identifier to_s ","identifiers first ","identifiers first to_s capitalize ","identifiers first to_s "]}," Mustermann []":{"type":"method","name":"[]","children":[],"call":[]}," Mustermann new":{"type":"method","name":"new","children":[],"call":[]}," Mustermann Template always_array?":{"type":"method","name":"always_array?","children":[],"call":["@split_params include? "]}," Mustermann Template map_param":{"type":"method","name":"map_param","children":[],"call":["value map! ","e sub ","variable [] ","value split ","@split_params [] ","value split  map! ","@split_params []  [] ","value split  split "]}," Mustermann Template compile":{"type":"method","name":"compile","children":[],"call":[]}," Mustermann Template parse_literal":{"type":"method","name":"parse_literal","children":[],"call":["Char  new ","Separator  new ","char == "," raise "," unexpected ","buffer getch ","buffer getch  == "]}," Mustermann Template parse_variable":{"type":"method","name":"parse_variable","children":[],"call":["Variable  new ","match [] "," expect "," expect  [] "]}," Mustermann Template parse_expression":{"type":"method","name":"parse_expression","children":[],"call":[" expect "," parse_variable ","buffer scan ","expression parse ","Expression  new ","Expression  new  parse "]}," Mustermann Template parse_element":{"type":"method","name":"parse_element","children":[],"call":[" parse_literal "," parse_expression "]}," Mustermann Template Variable register_param":{"type":"method","name":"register_param","children":[],"call":["split_params []= "," name "," explode "]}," Mustermann Template Variable default":{"type":"method","name":"default","children":[],"call":[]}," Mustermann Template Variable qualified":{"type":"method","name":"qualified","children":[],"call":[" prefix "]}," Mustermann Template Variable parametric":{"type":"method","name":"parametric","children":[],"call":["Regexp  escape "," name "]}," Mustermann Template Variable pattern":{"type":"method","name":"pattern","children":[],"call":["Regexp  escape ","options fetch "," explode "," parametric "," register_param "]}," Mustermann Template Variable compile":{"type":"method","name":"compile","children":[],"call":[" parametric ","options [] ! ","options [] "," explode "]}," Mustermann Template Expression separator":{"type":"method","name":"separator","children":[],"call":["AST  const_get new ","AST  const_get "]}," Mustermann Template Expression compile":{"type":"method","name":"compile","children":[],"call":[" operator separator "," operator "," operator parametric "," operator allow_reserved ! "," operator allow_reserved "]}," Mustermann Template Expression transform":{"type":"method","name":"transform","children":[],"call":[" payload unshift "," separator "," operator prefix "," operator "," payload "," Array map! "," Array "," Array << << "," Array << "," payload inject "," operator= "," raise ","OPERATORS  fetch "]}," Mustermann Sinatra parse_suffix":{"type":"method","name":"parse_suffix","children":[],"call":["Optional  new ","buffer scan "]}," Mustermann Sinatra parse_element":{"type":"method","name":"parse_element","children":[],"call":["Char  new "," expect ","buffer scan ","Capture  parse "," parse_buffer ","Group  parse ","Separator  new ","Splat  new "," unexpected ","buffer getch "]}," Mustermann SimpleMatch []":{"type":"method","name":"[]","children":[],"call":[" captures [] "," captures ","@captures [] "," names index ","arg to_s "," names ","arg is_a? ","args map! "]}," Mustermann SimpleMatch captures":{"type":"method","name":"captures","children":[],"call":["@captures dup "]}," Mustermann SimpleMatch names":{"type":"method","name":"names","children":[],"call":["@names dup "]}," Mustermann SimpleMatch to_s":{"type":"method","name":"to_s","children":[],"call":["@string dup "]}," Mustermann SimpleMatch initialize":{"type":"method","name":"initialize","children":[],"call":["string dup "]}," Mustermann Simple encoded":{"type":"method","name":"encoded","children":[],"call":["Regexp  union "," encoded ","char == ","parser escape upcase ","parser escape ","parser escape downcase ","URI Parser  new ","Regexp  escape "," Regexp  union  ","URI Parser  new  escape upcase ","URI Parser  new  escape ","URI Parser  new  escape downcase "]}," Mustermann Simple compile":{"type":"method","name":"compile","children":[],"call":[" raise ","error backtrace ","error message ","error message [] ","Regexp  new ","2 [] ","match == ","pattern gsub! "," encoded ","string gsub ","@string gsub "]}," Mustermann Shell ===":{"type":"method","name":"===","children":[],"call":["File  fnmatch? "," unescape "]}," Mustermann RegexpBased compile":{"type":"method","name":"compile","children":[],"call":[" raise "]}," Mustermann RegexpBased initialize":{"type":"method","name":"initialize","children":[],"call":[" compile "]}," Mustermann Rails parse_element":{"type":"method","name":"parse_element","children":[],"call":["Char  new ","buffer scan ","Capture  parse ","Optional  new "," parse_buffer ","Group  parse ","Separator  new ","NamedSplat  parse "," unexpected ","buffer getch "]}," Mustermann Pattern always_array?":{"type":"method","name":"always_array?","children":[],"call":["ALWAYS_ARRAY  include? "]}," Mustermann Pattern unescape":{"type":"method","name":"unescape","children":[],"call":["@uri unescape ","URI Parser  new ","@@uri unescape "]}," Mustermann Pattern map_param":{"type":"method","name":"map_param","children":[],"call":[" unescape "]}," Mustermann Pattern inspect":{"type":"method","name":"inspect","children":[],"call":["#<%p:%p> % "," class "]}," Mustermann Pattern params":{"type":"method","name":"params","children":[],"call":["Hash  [] ","values first "," always_array? ! "," always_array? ","values size < ","values size ","(send\n  (lvar :positions) :map) flatten "," map_param ","captures [] ","positions map "," named_captures map "," named_captures "," match ","pos + ","values first  first ","(send\n  (lvar :positions) :map) flatten  first ","values first  size < ","(send\n  (lvar :positions) :map) flatten  size < ","values first  size ","(send\n  (lvar :positions) :map) flatten  size "]}," Mustermann Pattern names":{"type":"method","name":"names","children":[],"call":[]}," Mustermann Pattern named_captures":{"type":"method","name":"named_captures","children":[],"call":[]}," Mustermann Pattern ===":{"type":"method","name":"===","children":[],"call":[" raise "]}," Mustermann Pattern =~":{"type":"method","name":"=~","children":[],"call":[" === "]}," Mustermann Pattern match":{"type":"method","name":"match","children":[],"call":["SimpleMatch  new "," === "]}," Mustermann Pattern to_s":{"type":"method","name":"to_s","children":[],"call":["@string dup "]}," Mustermann Pattern initialize":{"type":"method","name":"initialize","children":[],"call":["string dup ","string to_s dup ","string to_s "," freeze "," block_given? "]}," Mustermann Pattern new":{"type":"method","name":"new","children":[],"call":[]}," Mustermann Pattern supported?":{"type":"method","name":"supported?","children":[],"call":[]}," Mustermann Pattern supported_options":{"type":"method","name":"supported_options","children":[],"call":[]}," Mustermann Identity ===":{"type":"method","name":"===","children":[],"call":[" unescape == "," unescape "]}," Mustermann Extension compile!":{"type":"method","name":"compile!","children":[],"call":[" params merge! ","path params "," request path_info "," request "," params "," condition ","path is_a? ","Mustermann  new ","Hash  new merge! ","Hash  new ","global merge ","global is_a? ","local is_a? ","pattern merge! "," settings pattern "," settings "," settings respond_to? ","pattern []= ","path respond_to? "," Array "," params [] "," settings pattern? ","Mustermann  new  params "," request Mustermann  new _info ","Mustermann  new  is_a? ","Mustermann  new  respond_to? "]}," Mustermann AST expect":{"type":"method","name":"expect","children":[],"call":["regexp match ","regexp names any? ","regexp names "," unexpected ","buffer scan ","Regexp  new ","Regexp  escape ","regexp to_str ","regexp is_a? ","Regexp  new  match ","Regexp  new  names any? ","Regexp  new  names ","Regexp  new  to_str ","Regexp  new  is_a? "]}," Mustermann AST unexpected":{"type":"method","name":"unexpected","children":[],"call":[" raise ","char == ","char getch ","char respond_to? ","char getch  == ","char getch  getch ","char getch  respond_to? "]}," Mustermann AST parse_suffix":{"type":"method","name":"parse_suffix","children":[],"call":[]}," Mustermann AST parse_element":{"type":"method","name":"parse_element","children":[],"call":[" raise "]}," Mustermann AST parse_buffer":{"type":"method","name":"parse_buffer","children":[],"call":[" parse_suffix "," parse_element "]}," Mustermann AST compile":{"type":"method","name":"compile","children":[],"call":[" parse compile "," parse ","options []= "," compile "]}," Mustermann AST parse":{"type":"method","name":"parse","children":[],"call":[" raise ","e message << ","string inspect ","e message "," parse_buffer ","buffer eos? ","Root  parse ","StringScanner  new "," parse_StringScanner  new  ","StringScanner  new  eos? "]}," Mustermann AST Root compile":{"type":"method","name":"compile","children":[],"call":[" raise ","e message << "," pattern inspect "," pattern ","e message ","Regexp  new "," check_captures "]}," Mustermann AST Root check_captures":{"type":"method","name":"check_captures","children":[],"call":[" raise ","names uniq != ","names uniq ","names delete "," capture_names "," capture_names  uniq != "," capture_names  uniq "," capture_names  delete "," capture_ capture_names  "]}," Mustermann AST Root capture_names":{"type":"method","name":"capture_names","children":[],"call":[" flatten "]}," Mustermann AST Root parse":{"type":"method","name":"parse","children":[],"call":[]}," Mustermann AST WithLookAhead compile":{"type":"method","name":"compile","children":[],"call":[" head compile + "," head compile "," head ","lookahead << "," at_end ","e lookahead "," payload inject "," payload "]}," Mustermann AST WithLookAhead initialize":{"type":"method","name":"initialize","children":[],"call":[" at_end= "," payload= "," head= "]}," Mustermann AST Splat pattern":{"type":"method","name":"pattern","children":[],"call":[]}," Mustermann AST Splat name":{"type":"method","name":"name","children":[],"call":[]}," Mustermann AST Splat expect_lookahead?":{"type":"method","name":"expect_lookahead?","children":[],"call":[]}," Mustermann AST Capture with_lookahead":{"type":"method","name":"with_lookahead","children":[],"call":[]}," Mustermann AST Capture from_string":{"type":"method","name":"from_string","children":[],"call":["Regexp  new ","(send\n  (send\n    (lvar :string) :chars) :map) join "," encoded ","string chars map ","string chars "]}," Mustermann AST Capture from_symbol":{"type":"method","name":"from_symbol","children":[],"call":[" qualified "," with_lookahead "]}," Mustermann AST Capture from_array":{"type":"method","name":"from_array","children":[],"call":["Regexp  union "," pattern ","array map "]}," Mustermann AST Capture from_hash":{"type":"method","name":"from_hash","children":[],"call":[" pattern ","hash [] "," name to_sym "," name "]}," Mustermann AST Capture from_nil":{"type":"method","name":"from_nil","children":[],"call":[" qualified "," with_lookahead "," default "]}," Mustermann AST Capture default":{"type":"method","name":"default","children":[],"call":[]}," Mustermann AST Capture qualified":{"type":"method","name":"qualified","children":[],"call":[]}," Mustermann AST Capture compile":{"type":"method","name":"compile","children":[],"call":[" compile "," name "," pattern ","options [] "]}," Mustermann AST Capture lookahead":{"type":"method","name":"lookahead","children":[],"call":["ahead + "," pattern to_s "," pattern "]}," Mustermann AST Capture pattern":{"type":"method","name":"pattern","children":[],"call":[" from_nil "," from_string "," from_hash "," from_array "," from_symbol "]}," Mustermann AST Capture name":{"type":"method","name":"name","children":[],"call":[" payload "," raise "," payload == "," payload =~ "," payload empty? "," payload nil? "]}," Mustermann AST Capture capture_names":{"type":"method","name":"capture_names","children":[],"call":[" name "]}," Mustermann AST Capture parse":{"type":"method","name":"parse","children":[],"call":[" payload "]}," Mustermann AST Capture expect_lookahead?":{"type":"method","name":"expect_lookahead?","children":[],"call":[]}," Mustermann AST Group lookahead":{"type":"method","name":"lookahead","children":[],"call":["e lookahead "," payload inject "," payload "]}," Mustermann AST Group parse":{"type":"method","name":"parse","children":[],"call":[]}," Mustermann AST Group transform":{"type":"method","name":"transform","children":[],"call":[" payload first transform "," payload first "," payload "," payload size == "," payload size "]}," Mustermann AST Group lookahead?":{"type":"method","name":"lookahead?","children":[],"call":[" payload last lookahead? "," payload last "," payload "," payload last expect_lookahead? ","e lookahead? "," payload [] all? "," payload [] "]}," Mustermann AST Group initialize":{"type":"method","name":"initialize","children":[],"call":[" Array "]}," Mustermann AST Optional lookahead?":{"type":"method","name":"lookahead?","children":[],"call":[" payload expect_lookahead? "," payload "," payload lookahead? "]}," Mustermann AST Optional compile":{"type":"method","name":"compile","children":[],"call":["(?:%s)? % "," payload compile "," payload "]}," Mustermann AST Optional lookahead":{"type":"method","name":"lookahead","children":[],"call":[" payload lookahead "," payload "]}," Mustermann AST Separator separator?":{"type":"method","name":"separator?","children":[],"call":[]}," Mustermann AST Separator compile":{"type":"method","name":"compile","children":[],"call":["Regexp  escape "," payload "]}," Mustermann AST Char lookahead":{"type":"method","name":"lookahead","children":[],"call":["ahead + "," compile "]}," Mustermann AST Char lookahead?":{"type":"method","name":"lookahead?","children":[],"call":[]}," Mustermann AST Char compile":{"type":"method","name":"compile","children":[],"call":[" encoded "," payload "]}," Mustermann AST Node capture_names":{"type":"method","name":"capture_names","children":[],"call":["e capture_names ","e respond_to? "," payload map "," payload "," payload respond_to? "," payload capture_names "]}," Mustermann AST Node encoded":{"type":"method","name":"encoded","children":[],"call":["(?:%s) % ","list join ","list << "," encoded ","char == ","Regexp  escape ","(send\n  (lvar :uri_parser) :escape\n  (lvar :char)) uniq map ","(send\n  (lvar :uri_parser) :escape\n  (lvar :char)) uniq ","encoded upcase ","encoded downcase ","uri_parser escape ","URI Parser  new "," uri_parser escape  ","(send\n  (lvar :URI Parser  new ) :escape\n  (lvar :char)) uniq map ","(send\n  (lvar :URI Parser  new ) :escape\n  (lvar :char)) uniq ","uri_parser escape  upcase ","uri_parser escape  downcase ","URI Parser  new  escape "]}," Mustermann AST Node expect_lookahead?":{"type":"method","name":"expect_lookahead?","children":[],"call":[]}," Mustermann AST Node lookahead?":{"type":"method","name":"lookahead?","children":[],"call":[]}," Mustermann AST Node separator?":{"type":"method","name":"separator?","children":[],"call":[]}," Mustermann AST Node transform":{"type":"method","name":"transform","children":[],"call":["new_payload concat ","WithLookAhead  new ","with_lookahead size > ","with_lookahead size ","with_lookahead clear ","new_payload << ","element separator? ","with_lookahead << ","element lookahead? ","list << ","element expect_lookahead? ","with_lookahead empty? ","element transform "," payload each "," payload ","Array  === "," payload= "," payload transform "," payload respond_to? ","element transform  separator? ","element transform  lookahead? ","element transform  expect_lookahead? ","element transform  transform "]}," Mustermann AST Node compile":{"type":"method","name":"compile","children":[],"call":["(send\n  (send nil :Array\n    (send nil :payload)) :map) join ","e compile "," Array map "," Array "," payload "]}," Mustermann AST Node parse":{"type":"method","name":"parse","children":[],"call":[" payload << "," payload "," new "]}," Mustermann AST Node initialize":{"type":"method","name":"initialize","children":[],"call":[" payload= "," public_send ","options each "]}," Mustermann Pattern respond_to?":{"type":"method","name":"respond_to?","children":[],"call":["method to_s == ","method to_s "," respond_to_special? ","(sym :expand) include? "]}," Mustermann Pattern expand":{"type":"method","name":"expand","children":[],"call":[" raise "," class "]}," Mustermann AST Validation names":{"type":"method","name":"names","children":[],"call":[]}," Mustermann AST Validation validate":{"type":"method","name":"validate","children":[],"call":[]}," Mustermann AST TreeRenderer type":{"type":"method","name":"type","children":[],"call":["node class name [] split map join ","node class name [] split map ","node class name [] split ","node class name [] ","node class name ","node class "]}," Mustermann AST TreeRenderer render":{"type":"method","name":"render","children":[],"call":[]}," Mustermann AST Translator escape":{"type":"method","name":"escape","children":[],"call":["parser escape ","Regexp  union ","char =~ ","char to_s =~ ","char to_s ","parser Regexp  union  "]}," Mustermann AST Translator uri_parser":{"type":"method","name":"uri_parser","children":[],"call":["URI Parser  new "]}," Mustermann AST Translator translate":{"type":"method","name":"translate","children":[],"call":["result node ","result is_a? "," decorator_for translate "," decorator_for ","result node  node "," decorator_for translate  node ","result node  is_a? "," decorator_for translate  is_a? "]}," Mustermann AST Translator decorator_for":{"type":"method","name":"decorator_for","children":[],"call":["factory new "," raise ","node class "," class "," error_class "," class dispatch_table [] ","a name "," class dispatch_table ","node class ancestors inject ","node class ancestors "]}," Mustermann AST Translator raises":{"type":"method","name":"raises","children":[],"call":[]}," Mustermann AST Translator inherited":{"type":"method","name":"inherited","children":[],"call":[]}," Mustermann AST Translator dispatch_table":{"type":"method","name":"dispatch_table","children":[],"call":[]}," Mustermann AST Translator NodeTranslator t":{"type":"method","name":"t","children":[],"call":[" translator translate "," translator ","args any? "]}," Mustermann AST Translator NodeTranslator initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Mustermann AST Translator NodeTranslator register":{"type":"method","name":"register","children":[],"call":[]}," Mustermann AST Transformer ArrayTransform list_for":{"type":"method","name":"list_for","children":[],"call":[" payload "," lookahead_buffer "," expect_lookahead? "]}," Mustermann AST Transformer ArrayTransform expect_lookahead?":{"type":"method","name":"expect_lookahead?","children":[],"call":[" expect_lookahead? ","element payload all? ","element payload ","element class == ","Node  [] ","element class ","element is_a? "]}," Mustermann AST Transformer ArrayTransform lookahead_payload?":{"type":"method","name":"lookahead_payload?","children":[],"call":[" lookahead? ","payload last "," expect_lookahead? ","payload [] all? ","payload [] "]}," Mustermann AST Transformer ArrayTransform lookahead?":{"type":"method","name":"lookahead?","children":[],"call":[" expect_lookahead? ","element payload "," lookahead? ","Node  [] "," lookahead_payload? "]}," Mustermann AST Transformer ArrayTransform create_lookahead":{"type":"method","name":"create_lookahead","children":[],"call":["Node  [] new ","Node  [] ","elements size > ","elements size ","elements last stop ","elements last ","elements first start ","elements first "]}," Mustermann AST Transformer ArrayTransform track":{"type":"method","name":"track","children":[],"call":[" payload concat << "," payload concat "," payload "," lookahead_buffer clear "," lookahead_buffer "," create_lookahead ","element is_a? ","Node  [] "," lookahead_buffer dup "," lookahead_buffer << "," lookahead? "," list_for << "," list_for "," lookahead_buffer empty? ","  create_lookahead _buffer clear ","  lookahead_buffer dup _buffer clear ","  create_lookahead _buffer ","  lookahead_buffer dup _buffer "," create_ create_lookahead  "," create_ lookahead_buffer dup  ","  create_lookahead _buffer dup ","  lookahead_buffer dup _buffer dup ","  create_lookahead _buffer << ","  lookahead_buffer dup _buffer << ","  create_lookahead ? ","  lookahead_buffer dup ? ","  create_lookahead _buffer empty? ","  lookahead_buffer dup _buffer empty? "]}," Mustermann AST Transformer ArrayTransform translate":{"type":"method","name":"translate","children":[],"call":[" payload concat "," create_lookahead "," lookahead_buffer "," payload "," track "," t "," each "]}," Mustermann AST Transformer ArrayTransform lookahead_buffer":{"type":"method","name":"lookahead_buffer","children":[],"call":[]}," Mustermann AST Transformer ArrayTransform payload":{"type":"method","name":"payload","children":[],"call":[]}," Mustermann AST Transformer transform":{"type":"method","name":"transform","children":[],"call":[]}," Mustermann AST Pattern expand":{"type":"method","name":"expand","children":[],"call":[" expander expand "," expander ","@expander expand ","Mustermann Expander  new "]}," Mustermann AST Pattern compile":{"type":"method","name":"compile","children":[],"call":[" raise ","error message << ",": %p % ","error message "," compiler compile "," compiler "," expander add "," expander "," validate "," transform "," parse ","options [] "," expander= "," expander_class new "," expander_class "," to_ast ","error backtrace ","@string inspect ","error class "," to_ validate  "]}," Mustermann AST Pattern expander_class":{"type":"method","name":"expander_class","children":[],"call":[]}," Mustermann AST Pattern validation":{"type":"method","name":"validation","children":[],"call":[]}," Mustermann AST Pattern transformer":{"type":"method","name":"transformer","children":[],"call":[]}," Mustermann AST Pattern compiler":{"type":"method","name":"compiler","children":[],"call":[]}," Mustermann AST Pattern parser":{"type":"method","name":"parser","children":[],"call":[]}," Mustermann AST Parser unexpected":{"type":"method","name":"unexpected","children":[],"call":[" raise "," string inspect "," string ","char == "," getch "]}," Mustermann AST Parser expect":{"type":"method","name":"expect","children":[],"call":[" unexpected "," scan "]}," Mustermann AST Parser scan":{"type":"method","name":"scan","children":[],"call":["regexp match ","regexp names any? ","regexp names "," buffer scan "," buffer ","Regexp  new ","Regexp  escape ","regexp is_a? "," match_buffer ","Regexp  new  match ","Regexp  new  names any? ","Regexp  new  names ","Regexp  new  is_a? "]}," Mustermann AST Parser read_suffix":{"type":"method","name":"read_suffix","children":[],"call":[" instance_exec "," scan "," class suffix inject "," class suffix "," class "," min_size "," pos ","element start ","ele is_a? "]}," Mustermann AST Parser read":{"type":"method","name":"read","children":[],"call":[" read_suffix "," default_node "," send "," respond_to? ","read %p % "," getch "," min_size "," pos "]}," Mustermann AST Parser default_node":{"type":"method","name":"default_node","children":[],"call":[" node ","char == "]}," Mustermann AST Parser node":{"type":"method","name":"node","children":[],"call":["type new ","type parse ","Node  [] ","type respond_to? "," min_size "," pos ","Node  []  new ","Node  []  parse ","Node  []  respond_to? "]}," Mustermann AST Parser parse":{"type":"method","name":"parse","children":[],"call":[" read "," eos? "," node ","StringScanner  new "," StringScanner  new "]}," Mustermann AST Parser suffix":{"type":"method","name":"suffix","children":[],"call":[]}," Mustermann AST Parser on":{"type":"method","name":"on","children":[],"call":[]}," Mustermann AST Node WithLookAhead initialize":{"type":"method","name":"initialize","children":[],"call":[" at_end= "," Array "," payload= "," head= "]}," Mustermann AST Node Splat name":{"type":"method","name":"name","children":[],"call":[]}," Mustermann AST Node Root parse":{"type":"method","name":"parse","children":[],"call":[]}," Mustermann AST Node Group initialize":{"type":"method","name":"initialize","children":[],"call":[" Array "]}," Mustermann AST Node Capture parse":{"type":"method","name":"parse","children":[],"call":[" payload ","String  new "]}," Mustermann AST Node each_leaf":{"type":"method","name":"each_leaf","children":[],"call":["entry each_leaf ","entry respond_to? "," Array each "," Array "," payload "," enum_for "," __method__ "," block_given? "]}," Mustermann AST Node constant_name":{"type":"method","name":"constant_name","children":[],"call":[]}," Mustermann AST Node []":{"type":"method","name":"[]","children":[],"call":[]}," Mustermann AST Expander add_to":{"type":"method","name":"add_to","children":[],"call":["l + ","p1 + ","k1 + ","result map ","list inject ","list << ","list empty? ","f1 merge "]}," Mustermann AST Expander pattern":{"type":"method","name":"pattern","children":[],"call":[]}," Mustermann AST Expander escape":{"type":"method","name":"escape","children":[],"call":["string =~ ","string respond_to? "]}," Mustermann AST Expander error_for":{"type":"method","name":"error_for","children":[],"call":[" raise ","cannot expand with keys %p, possible expansions: %s % ","values keys sort ","values keys "," error_class "," mappings keys map join "," mappings keys map "," mappings keys "," mappings ","cannot expand with keys %p, possible  mappings keys map join : %s % "]}," Mustermann AST Expander expand":{"type":"method","name":"expand","children":[],"call":["pattern % ","values values_at "," escape ","values [] ","filters each "," error_for "," mappings fetch ","values keys sort ","values keys "," mappings ","values keys flatten sort ","values keys flatten ","new_hash []= ","(lvar :key) * ","value length ","value instance_of? ","values each_with_object ","adjusted values_at ","adjusted [] ","adjusted keys flatten sort ","adjusted keys flatten ","adjusted keys "]}," Mustermann AST Expander pattern_for":{"type":"method","name":"pattern_for","children":[],"call":["Compiler  new decorator_for pattern ","Compiler  new decorator_for ","Compiler  new "]}," Mustermann AST Expander add":{"type":"method","name":"add","children":[],"call":[" mappings [] ","keys uniq sort ","keys uniq "," mappings "," translate each "," translate "," keys concat uniq! "," keys concat "," keys ","keys sort "]}," Mustermann AST Expander mappings":{"type":"method","name":"mappings","children":[],"call":[]}," Mustermann AST Expander for_capture":{"type":"method","name":"for_capture","children":[],"call":[" pattern "," pattern_for ","node name to_sym ","node name ","node node name to_sym  to_sym ","node node name to_sym  "]}," Mustermann AST Compiler compile":{"type":"method","name":"compile","children":[],"call":["Regexp  new "," translate "]}," Mustermann AST Compiler encoded":{"type":"method","name":"encoded","children":[],"call":["(?:%s) % ","list join ","list << "," encoded ","char == ","Regexp  escape ","(send nil :escape\n  (lvar :char)) uniq map ","(send nil :escape\n  (lvar :char)) uniq ","encoded upcase ","encoded downcase "," escape ","  escape  "," escape  upcase "," escape  downcase "]}," Mustermann AST Compiler Variable register_param":{"type":"method","name":"register_param","children":[],"call":["split_params []= "," name "," explode "]}," Mustermann AST Compiler Variable default":{"type":"method","name":"default","children":[],"call":[]}," Mustermann AST Compiler Variable qualified":{"type":"method","name":"qualified","children":[],"call":[" prefix "]}," Mustermann AST Compiler Variable parametric":{"type":"method","name":"parametric","children":[],"call":["Regexp  escape "," name "]}," Mustermann AST Compiler Variable pattern":{"type":"method","name":"pattern","children":[],"call":["Regexp  escape "," explode "," parametric "," register_param "]}," Mustermann AST Compiler Variable translate":{"type":"method","name":"translate","children":[],"call":[" parametric ","options [] ! ","options [] "," explode ","options delete ","options has_key? "]}," Mustermann AST Compiler Splat pattern":{"type":"method","name":"pattern","children":[],"call":[" constraint "]}," Mustermann AST Compiler Capture default":{"type":"method","name":"default","children":[],"call":[" constraint "]}," Mustermann AST Compiler Capture from_nil":{"type":"method","name":"from_nil","children":[],"call":[" qualified "," with_lookahead "," default "]}," Mustermann AST Compiler Capture from_string":{"type":"method","name":"from_string","children":[],"call":["Regexp  new ","(send\n  (send\n    (lvar :string) :chars) :map) join "," t encoded "," t ","string chars map ","string chars "]}," Mustermann AST Compiler Capture from_symbol":{"type":"method","name":"from_symbol","children":[],"call":[" qualified "," with_lookahead "]}," Mustermann AST Compiler Capture from_array":{"type":"method","name":"from_array","children":[],"call":["Regexp  union "," pattern ","array map "]}," Mustermann AST Compiler Capture from_hash":{"type":"method","name":"from_hash","children":[],"call":[" pattern ","hash [] "," name to_sym "," name "]}," Mustermann AST Compiler Capture with_lookahead":{"type":"method","name":"with_lookahead","children":[],"call":[]}," Mustermann AST Compiler Capture qualified":{"type":"method","name":"qualified","children":[],"call":[" qualifier "]}," Mustermann AST Compiler Capture pattern":{"type":"method","name":"pattern","children":[],"call":[" from_nil "," from_string "," from_hash "," from_array "," from_symbol "]}," Mustermann AST Compiler Capture translate":{"type":"method","name":"translate","children":[],"call":[" translate "," name "," pattern ","options [] "]}," Mustermann Shell initialize":{"type":"method","name":"initialize","children":[],"call":["File FNM_PATHNAME  | "]}," Mustermann Router Simple string_for":{"type":"method","name":"string_for","children":[],"call":["input to_str "]}," Mustermann Router Simple invoke":{"type":"method","name":"invoke","children":[],"call":["callback call "]}," Mustermann Router Simple call":{"type":"method","name":"call","children":[],"call":[" invoke ","pattern params "," string_for "," catch ","@map each ","pattern pattern params  "]}," Mustermann Router Simple on":{"type":"method","name":"on","children":[],"call":["@map << ","Mustermann  new ","pattern to_str ","pattern respond_to? ","patterns each ","Mustermann  new  to_str ","Mustermann  new  respond_to? ","Mustermann  new s each "]}," Mustermann Router Simple []=":{"type":"method","name":"[]=","children":[],"call":[" on "]}," Mustermann Router Simple []":{"type":"method","name":"[]","children":[],"call":["(send\n  (ivar :@map) :detect) [] ","p === ","@map detect "," string_for ","string is_a? ","  string_for _for "," string_for  is_a? "]}," Mustermann Router Simple initialize":{"type":"method","name":"initialize","children":[],"call":[" instance_eval ","block arity == ","block arity "]}," Mustermann Router Rack string_for":{"type":"method","name":"string_for","children":[],"call":["env [] "]}," Mustermann Router Rack invoke":{"type":"method","name":"invoke","children":[],"call":["env []= "," throw ","v == ","k downcase == ","k downcase ","response [] each ","response [] ","callback call ","env [] ","callback call  [] each ","callback call  [] "]}," Mustermann Router Rack initialize":{"type":"method","name":"initialize","children":[],"call":["options [] ","options []= ","options include? "]}," Mustermann Expander append":{"type":"method","name":"append","children":[],"call":["entries join ","uri [] ","(send\n  (lvar :pair) :map) join ","@api_expander escape ","pair map ","values map ","values any? "]}," Mustermann Expander slice":{"type":"method","name":"slice","children":[],"call":["Hash  [] ","hash [] ","keys map "]}," Mustermann Expander with_rest":{"type":"method","name":"with_rest","children":[],"call":[" slice "," expand ","values keys - ","values keys ","@api_expander expandable_keys "," split_values ","@api_expander @api_expander expandable_keys _keys "]}," Mustermann Expander expand":{"type":"method","name":"expand","children":[],"call":[" raise ","unknown behavior %p % "," append "," with_rest ","@api_expander expand "," additional_values "," caster cast "," caster "," map_values ","behavior is_a? "," additional_ caster cast  "," additional_ map_values  "," map_ caster cast  "," map_ map_values  "]}," Mustermann Expander cast":{"type":"method","name":"cast","children":[],"call":[" caster register "," caster "]}," Mustermann Expander add":{"type":"method","name":"add","children":[],"call":["@patterns << ","@api_expander add ","pattern to_ast "," raise ","pattern class ","pattern respond_to? ","Mustermann  new ","pattern to_str ","patterns each "," block_given? ","@Mustermann  new s << ","Mustermann  new  to_ast ","Mustermann  new  class ","Mustermann  new  respond_to? ","Mustermann  new  to_str ","Mustermann  new s each "]}," Mustermann Expander initialize":{"type":"method","name":"initialize","children":[],"call":[" add ","Caster  new ","AST Expander  new "," raise ","Illegal value %p for additional_values % ","additional_values == "]}," Mustermann EqualityMap finalizer":{"type":"method","name":"finalizer","children":[],"call":["@keys delete "," proc "]}," Mustermann EqualityMap track":{"type":"method","name":"track","children":[],"call":["@keys []= ","key hash ","ObjectSpace  define_finalizer "," finalizer "," hash ","object dup ","object frozen? ","object dup  dup ","object dup  frozen? "]}," Mustermann EqualityMap fetch":{"type":"method","name":"fetch","children":[],"call":[" track ","@map [] ","identity == ","@keys [] ","key hash ","key dup ","key frozen? ","@keys []  == ","@key dup s [] ","key dup  hash ","key dup  dup ","key dup  frozen? "]}," Mustermann EqualityMap initialize":{"type":"method","name":"initialize","children":[],"call":["ObjectSpace WeakMap  new "]}," Mustermann Caster Key cast":{"type":"method","name":"cast","children":[],"call":["@type === "]}," Mustermann Caster Key initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Mustermann Caster Value cast":{"type":"method","name":"cast","children":[],"call":["@type === "]}," Mustermann Caster Value initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Mustermann Caster Any cast":{"type":"method","name":"cast","children":[],"call":["@block call ","@block arity "]}," Mustermann Caster Any initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Mustermann Caster Nil cast":{"type":"method","name":"cast","children":[],"call":[]}," Mustermann Caster cast":{"type":"method","name":"cast","children":[],"call":["hash update ","merge update ","casted to_hash ","casted respond_to? ","(send\n  (send nil :lazy) :map) detect ","e cast "," lazy map "," lazy ","hash delete_if "," empty? "]}," Mustermann Caster caster_for":{"type":"method","name":"caster_for","children":[],"call":["Value  new ","type respond_to? ","Key  new "]}," Mustermann Caster register":{"type":"method","name":"register","children":[],"call":[" << "," caster_for ","types each ","types << ","Any  new ","types empty? ","block nil? "]}," Mustermann Caster initialize":{"type":"method","name":"initialize","children":[],"call":[" register "]}," Mustermann AST Validation check_name":{"type":"method","name":"check_name","children":[],"call":[" names << "," names "," raise "," names include? ","name == ","name =~ ","name empty? ","name nil? "," Array include? "," Array "]}," Mustermann AST Transformer ExpressionTransform translate":{"type":"method","name":"translate","children":[],"call":[" payload unshift "," payload "," operator prefix "," operator "," payload= "," Array "," Array << << "," t "," Array << "," payload inject ","Node  [] new ","Node  [] "," operator separator "," operator= "," raise ","OPERATORS  fetch ","separator dup "," operator Node  [] new  ","Node  [] new  dup "]}," Mustermann AST Pattern to_ast":{"type":"method","name":"to_ast","children":[],"call":[" validate "," transform "," parse ","@ast_cache fetch ","EqualityMap  new ","Tool EqualityMap  new "," set_boundaries ","@ parse _cache fetch "]}," Mustermann AST Expander expandable_keys":{"type":"method","name":"expandable_keys","children":[],"call":["(send\n  (send\n    (send nil :mappings) :keys) :select) max_by ","(send\n  (lvar :k) :-\n  (lvar :keys)) empty? ","k - "," mappings keys select "," mappings keys "," mappings "]}," Mustermann ToPattern to_pattern":{"type":"method","name":"to_pattern","children":[],"call":["Mustermann  new "," to_s "," __getobj__ "," respond_to? "," is_a? ","PRIMITIVES  any? "]}," Mustermann Regular compile":{"type":"method","name":"compile","children":[],"call":[" check_anchors ","scanner eos? "," StringScanner  new "," StringScanner  new  eos? "]}," Mustermann Regular initialize":{"type":"method","name":"initialize","children":[],"call":["string inspect == ","string inspect ","string to_s =~ ","string to_s ","string source gsub! ","string source "," extended_regexp? ","string source gsub!  inspect == ","string source gsub!  inspect ","string source gsub!  to_s =~ ","string source gsub!  to_s ","string source gsub!  source gsub! ","string source gsub!  source "]}," Mustermann Mapper []=":{"type":"method","name":"[]=","children":[],"call":[" update "]}," Mustermann Mapper convert":{"type":"method","name":"convert","children":[],"call":["expander expand ","expander expandable? ","Hash  [] ","k to_s ","values merge map ","values merge ","pattern params ","@map inject ","pattern pattern params  "]}," Mustermann Mapper to_h":{"type":"method","name":"to_h","children":[],"call":["Hash  [] "]}," Mustermann Mapper update":{"type":"method","name":"update","children":[],"call":["@map << ","Expander  new ","output is_a? ","Mustermann  new ","map to_h each_pair ","map to_h ","Expander  new  is_a? "]}," Mustermann Mapper initialize":{"type":"method","name":"initialize","children":[],"call":[" update ","block arity == ","block arity "]}," Mustermann Expander map_values":{"type":"method","name":"map_values","children":[],"call":[" caster cast "," caster ","values delete ","key to_s ","values [] ","values include? ","@api_expander keys each ","@api_expander keys ","values dup ","v nil? "," caster cast delete_if ","values dup  delete ","values dup  [] ","values dup  include? ","values dup  dup "]}," Mustermann Expander split_values":{"type":"method","name":"split_values","children":[],"call":["values keys - ","values keys ","@api_expander expandable_keys ","@api_expander @api_expander expandable_keys _keys "]}," Mustermann Expander expandable?":{"type":"method","name":"expandable?","children":[],"call":["@api_expander expandable? "," split_values "," map_values "]}," Mustermann Expander hash":{"type":"method","name":"hash","children":[],"call":[" patterns hash + "," additional_values hash "," additional_values "," patterns hash "," patterns "]}," Mustermann Expander eql?":{"type":"method","name":"eql?","children":[],"call":["other additional_values eql? "," additional_values ","other additional_values ","other patterns eql? "," patterns ","other patterns ","other class == "," class ","other class "]}," Mustermann Expander ==":{"type":"method","name":"==","children":[],"call":["other additional_values == "," additional_values ","other additional_values ","other patterns == "," patterns ","other patterns ","other class == "," class ","other class "]}," Mustermann AST Expander expandable?":{"type":"method","name":"expandable?","children":[],"call":[" mappings include? "," mappings ","values sort ","values respond_to? ","values keys ","values sort  sort ","values keys  sort ","values sort  respond_to? ","values keys  respond_to? ","values sort  keys ","values keys  keys "]}," Mustermann AST Expander keys":{"type":"method","name":"keys","children":[],"call":[]}," Mustermann normalized_type":{"type":"method","name":"normalized_type","children":[],"call":[]}," Mustermann try_require":{"type":"method","name":"try_require","children":[],"call":[]}," Mustermann SimpleMatch inspect":{"type":"method","name":"inspect","children":[],"call":["#<%p %p> % "," class "]}," Mustermann RegexpBased peek_match":{"type":"method","name":"peek_match","children":[],"call":["@peek_regexp match "]}," Mustermann RegexpBased peek_size":{"type":"method","name":"peek_size","children":[],"call":["match to_s size ","match to_s "," peek_match "," peek_match  to_s size "," peek_match  to_s "," peek_ peek_match  "]}," Mustermann PatternCache size":{"type":"method","name":"size","children":[],"call":["@cached size ","@mutex synchronize "]}," Mustermann PatternCache clear":{"type":"method","name":"clear","children":[],"call":["@cached clear ","@mutex synchronize "]}," Mustermann PatternCache create_pattern":{"type":"method","name":"create_pattern","children":[],"call":["@cached add ","@mutex synchronize ","@cached include? ","Mustermann  new "]}," Mustermann PatternCache initialize":{"type":"method","name":"initialize","children":[],"call":["Mutex  new ","Set  new "]}," Mustermann Pattern simple_inspect":{"type":"method","name":"simple_inspect","children":[],"call":["%s:%p % "," class name [] downcase "," class name [] "," class name "," class "]}," Mustermann Pattern respond_to_special?":{"type":"method","name":"respond_to_special?","children":[],"call":[" method owner != "," method owner "," method "]}," Mustermann Pattern to_proc":{"type":"method","name":"to_proc","children":[],"call":[" method to_proc "," method "]}," Mustermann Pattern |":{"type":"method","name":"|","children":[],"call":["Mustermann  new "," __callee__ ","Mustermann Composite  new "]}," Mustermann Pattern to_templates":{"type":"method","name":"to_templates","children":[],"call":[" raise "," class "]}," Mustermann Pattern peek_params":{"type":"method","name":"peek_params","children":[],"call":["match to_s size ","match to_s "," params "," peek_match "," peek_match  to_s size "," peek_match  to_s "," peek_ peek_match  "]}," Mustermann Pattern peek_match":{"type":"method","name":"peek_match","children":[],"call":[" match "," peek "]}," Mustermann Pattern peek":{"type":"method","name":"peek","children":[],"call":["string [] "," peek_size "," peek_ peek_size  "]}," Mustermann Pattern peek_size":{"type":"method","name":"peek_size","children":[],"call":[" === ","string [] ","string size downto detect ","string size downto ","string size "]}," Mustermann Pattern register":{"type":"method","name":"register","children":[],"call":[]}," Mustermann Identity expand":{"type":"method","name":"expand","children":[],"call":["@string + + ","params join ","@string + ","@string include? ","@@uri escape + + ","@@uri escape ","value to_s ","@@uri escape + ","key to_s ","values map "," raise ","unknown behavior %p % ","behavior != ","cannot expand with keys %p % ","values keys sort ","values keys ","behavior == "," to_s ","values empty? "]}," Mustermann Identity to_ast":{"type":"method","name":"to_ast","children":[],"call":["AST Node  [] new ","@string length ","AST Node  [] ","i + ","c == ","@string each_char with_index map ","@string each_char with_index ","@string each_char "]}," Mustermann Identity to_templates":{"type":"method","name":"to_templates","children":[],"call":["@@uri escape "," to_s "]}," Mustermann Identity peek_size":{"type":"method","name":"peek_size","children":[],"call":["count + ","escaped size ","string [] downcase == ","escaped downcase ","string [] downcase ","string [] ","@@uri escape ","@string each_char with_index inject ","@string each_char with_index ","@string each_char ","@string size ","string start_with? "," unescape start_with? "," unescape ","@@uri escape  size ","@@uri escape  downcase "]}," Mustermann Composite patterns_from":{"type":"method","name":"patterns_from","children":[],"call":["Mustermann  new ","pattern patterns ","pattern operator == "," operator ","pattern operator ","pattern is_a? ","options empty? "]}," Mustermann Composite with_matching":{"type":"method","name":"with_matching","children":[],"call":["pattern public_send ","p === "," patterns detect "," patterns "," === "]}," Mustermann Composite simple_inspect":{"type":"method","name":"simple_inspect","children":[],"call":["pattern_strings join "," operator ","p simple_inspect "," patterns map "," patterns "]}," Mustermann Composite inspect":{"type":"method","name":"inspect","children":[],"call":["#<%p:%s> % "," simple_inspect "," class "]}," Mustermann Composite to_s":{"type":"method","name":"to_s","children":[],"call":[" simple_inspect "]}," Mustermann Composite to_templates":{"type":"method","name":"to_templates","children":[],"call":[" patterns flat_map uniq "," patterns flat_map "," patterns "," raise "," respond_to? "]}," Mustermann Composite expand":{"type":"method","name":"expand","children":[],"call":["@expander expand ","Mustermann Expander  new "," patterns "," raise "," respond_to? "]}," Mustermann Composite respond_to_special?":{"type":"method","name":"respond_to_special?","children":[],"call":["p respond_to? "," patterns all? "," patterns "," operator == "," operator "]}," Mustermann Composite match":{"type":"method","name":"match","children":[],"call":[" with_matching "]}," Mustermann Composite params":{"type":"method","name":"params","children":[],"call":[" with_matching "]}," Mustermann Composite ===":{"type":"method","name":"===","children":[],"call":["(send\n  (send nil :patterns) :map) inject "," operator ","p === "," patterns map "," patterns "]}," Mustermann Composite ==":{"type":"method","name":"==","children":[],"call":[" patterns == "," patterns_from "," patterns "]}," Mustermann Composite initialize":{"type":"method","name":"initialize","children":[],"call":[" patterns_from ","patterns flat_map ","operator to_sym "]}," Mustermann Composite new":{"type":"method","name":"new","children":[],"call":[]}," Mustermann Composite supported?":{"type":"method","name":"supported?","children":[],"call":[]}," Mustermann AST Translator create":{"type":"method","name":"create","children":[],"call":[]}," Mustermann AST TemplateGenerator generate_templates":{"type":"method","name":"generate_templates","children":[],"call":[]}," Mustermann AST Pattern param_converters":{"type":"method","name":"param_converters","children":[],"call":[" scan_params "," to_ast "]}," Mustermann AST Pattern map_param":{"type":"method","name":"map_param","children":[],"call":[" param_converters [] [] "," param_converters [] "," param_converters "," param_converters include? "]}," Mustermann AST Pattern to_templates":{"type":"method","name":"to_templates","children":[],"call":[" generate_templates "," to_ast "]}," Mustermann AST Pattern param_scanner":{"type":"method","name":"param_scanner","children":[],"call":[]}," Mustermann AST Pattern template_generator":{"type":"method","name":"template_generator","children":[],"call":[]}," Mustermann AST Pattern boundaries":{"type":"method","name":"boundaries","children":[],"call":[]}," Mustermann AST Parser read_escaped":{"type":"method","name":"read_escaped","children":[],"call":[" unexpected ","result << "," getch ","String  new ","String  new  << "]}," Mustermann AST Parser read_list":{"type":"method","name":"read_list","children":[],"call":[" unexpected ","element << "," read_escaped "," getch ","result << ","result last ","result empty? ","String  new ","result last  << "]}," Mustermann AST Parser read_args":{"type":"method","name":"read_args","children":[],"call":[" expect "," buffer pos "," buffer "," unexpected ","map []= ","entries last ","entries first ","entries first to_sym ","entries size "," read_list "," scan "," buffer peek != "," buffer peek "," read_list  last "," read_list  first "," read_list  first to_sym "," read_list  size "]}," Mustermann AST Parser read_brackets":{"type":"method","name":"read_brackets","children":[],"call":[" unexpected ","result << ","result << << "," getch ","result << << << "," read_brackets ","escape nil? ","String  new ","String  new  << ","String  new  << << ","String  new  << << << "]}," Mustermann AST Parser match_buffer":{"type":"method","name":"match_buffer","children":[],"call":["regexp match ","regexp names any? ","regexp names "," buffer public_send "," buffer ","Regexp  new ","Regexp  escape ","regexp is_a? ","Regexp  new  match ","Regexp  new  names any? ","Regexp  new  names ","Regexp  new  is_a? "]}," Mustermann AST Parser check":{"type":"method","name":"check","children":[],"call":[" match_buffer "]}," Mustermann AST Parser min_size":{"type":"method","name":"min_size","children":[],"call":["node stop= ","node stop > ","node stop ","node start= ","node start < ","node start "]}," Mustermann AST Parser initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Mustermann AST ParamScanner scan_params":{"type":"method","name":"scan_params","children":[],"call":[]}," Mustermann AST Node Separator min_size":{"type":"method","name":"min_size","children":[],"call":[]}," Mustermann AST Node Composition initialize":{"type":"method","name":"initialize","children":[],"call":[" Array "]}," Mustermann AST Node Char min_size":{"type":"method","name":"min_size","children":[],"call":[]}," Mustermann AST Node type":{"type":"method","name":"type","children":[],"call":[" class type "," class "]}," Mustermann AST Node min_size":{"type":"method","name":"min_size","children":[],"call":[]}," Mustermann AST Node length":{"type":"method","name":"length","children":[],"call":[" stop - "," start "," stop "]}," Mustermann AST Node is_a?":{"type":"method","name":"is_a?","children":[],"call":["Node  [] ","type is_a? ","Node  []  is_a? "]}," Mustermann AST Boundaries set_boundaries":{"type":"method","name":"set_boundaries","children":[],"call":["node stop= ","node stop > ","node stop ","node start + ","node min_size ","node start ","node stop < ","node stop nil? ","node start= ","node start < ","node start nil? ","string length "]}," Mustermann Sinatra native_concat":{"type":"method","name":"native_concat","children":[],"call":[" safe_string + ","converted safe_string "," safe_string "," class try_convert "," options "," class "," class try_convert  safe_string "]}," Mustermann Sinatra safe_string":{"type":"method","name":"safe_string","children":[],"call":["SafeRenderer  translate "," to_ast "]}," Mustermann Sinatra |":{"type":"method","name":"|","children":[],"call":[" class new "," options "," safe_string + + ","converted safe_string "," safe_string + "," safe_string "," class "," names empty? "," names ","converted names empty? ","converted names "," class try_convert "," class try_convert  safe_string "," class try_convert  names empty? "," class try_convert  names "]}," Mustermann Sinatra try_convert":{"type":"method","name":"try_convert","children":[],"call":[]}," Mustermann Sinatra escape":{"type":"method","name":"escape","children":[],"call":[]}," Mustermann Sinatra TryConvert uri_decode":{"type":"method","name":"uri_decode","children":[],"call":[" options fetch "," options "]}," Mustermann Sinatra TryConvert new":{"type":"method","name":"new","children":[],"call":["Mustermann Sinatra  new "," options ","Mustermann Sinatra  escape "]}," Mustermann Sinatra TryConvert initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Mustermann Sinatra TryConvert convert":{"type":"method","name":"convert","children":[],"call":[]}," Mustermann SimpleMatch +":{"type":"method","name":"+","children":[],"call":["SimpleMatch  new ","@captures + ","other captures ","@names + ","other names ","@string + ","other to_s "]}," Mustermann Regular check_anchors":{"type":"method","name":"check_anchors","children":[],"call":[" raise ","regular expression should not contain %s: %p % ","illegal to_s ","scanner scan ","scanner scan_until ","scanner scan  to_s "]}," Mustermann Pattern +":{"type":"method","name":"+","children":[],"call":["Concat  new "]}," Mustermann Pattern eql?":{"type":"method","name":"eql?","children":[],"call":["other options eql? "," options ","other options ","other to_s eql? ","other to_s ","other class eql? "," class ","other class "]}," Mustermann Pattern ==":{"type":"method","name":"==","children":[],"call":["other options == "," options ","other options ","other to_s == ","other to_s ","other class == "," class ","other class "]}," Mustermann Pattern hash":{"type":"method","name":"hash","children":[],"call":[" class hash | | "," options hash "," options "," class hash | ","@string hash "," class hash "," class "]}," Mustermann EqualityMap new":{"type":"method","name":"new","children":[],"call":[]}," Mustermann Concat combined_ast":{"type":"method","name":"combined_ast","children":[],"call":["AST Node  [] new ","AST Node  [] ","p to_ast payload ","p to_ast "," patterns map "," patterns "]}," Mustermann Concat pump":{"type":"method","name":"pump","children":[],"call":["string size - ","substring size ","string size ","results inject ","substring [] ","results << "," patterns each "," patterns "," Array ","substring []  size ","results inject  inject "," Array  inject ","substring []  [] ","results inject  << "," Array  << "]}," Mustermann Concat respond_to_special?":{"type":"method","name":"respond_to_special?","children":[],"call":["p respond_to? "," patterns all? "," patterns ","method to_sym == ","method to_sym "]}," Mustermann Concat to_templates":{"type":"method","name":"to_templates","children":[],"call":["(send\n  (send nil :patterns) :inject\n  (array\n    (str \"\"))) uniq ","list product map ","list product ","pattern to_templates "," patterns inject "," patterns "," raise "," respond_to? "]}," Mustermann Concat expand":{"type":"method","name":"expand","children":[],"call":["@expander expand "," combined_ast ","Mustermann Expander  new "," raise "," respond_to? "]}," Mustermann Concat peek_params":{"type":"method","name":"peek_params","children":[],"call":["p peek_params "," pump "]}," Mustermann Concat peek_match":{"type":"method","name":"peek_match","children":[],"call":["match to_s size ","match to_s ","pattern peek_match "," pump ","SimpleMatch  new ","pattern peek_match  to_s size ","pattern peek_match  to_s ","pattern peek_pattern peek_match  "]}," Mustermann Concat peek_size":{"type":"method","name":"peek_size","children":[],"call":["p peek_size "," pump "]}," Mustermann Concat params":{"type":"method","name":"params","children":[],"call":["size == ","string size "," peek_params "]}," Mustermann Concat match":{"type":"method","name":"match","children":[],"call":["peeked to_s == ","peeked to_s "," peek_match "," peek_match  to_s == "," peek_match  to_s "]}," Mustermann Concat ===":{"type":"method","name":"===","children":[],"call":[" peek_size == ","string size "," peek_size "]}," Mustermann Concat operator":{"type":"method","name":"operator","children":[],"call":[]}," Mustermann Concat initialize":{"type":"method","name":"initialize","children":[],"call":["AST Validation  validate "," combined_ast "," respond_to? "]}," Mustermann Concat Native native_concat?":{"type":"method","name":"native_concat?","children":[],"call":["other options == "," options ","other options ","other class == "," class ","other class "]}," Mustermann Concat Native native_concat":{"type":"method","name":"native_concat","children":[],"call":[" native_concat? "]}," Mustermann Concat Native +":{"type":"method","name":"+","children":[],"call":[" class new "," options "," class "," native_concat ","Mustermann  new ","concat + ","other patterns slice inject ","other patterns slice ","patterns length ","other patterns "," + ","patterns inject ","patterns empty? ! ","patterns empty? "," look_ahead ","  native_concat _concat ","other  look_ahead  slice inject ","other  look_ahead  slice "," look_ahead  length ","other  look_ahead  "," look_ahead  inject "," look_ahead  empty? ! "," look_ahead  empty? "]}," Mustermann Composite hash":{"type":"method","name":"hash","children":[],"call":[" patterns hash | "," operator hash "," operator "," patterns hash "," patterns "]}," Mustermann Composite eql?":{"type":"method","name":"eql?","children":[],"call":[" patterns eql? "," patterns_from "," patterns "]}," Mustermann AST Transformer RootTransformer union":{"type":"method","name":"union","children":[],"call":[" payload= "]}," Mustermann AST Transformer GroupTransformer split_payload":{"type":"method","name":"split_payload","children":[],"call":["groups map! ","groups last << ","groups last ","groups << ","e is_a? "," payload each "," payload "]}," Mustermann AST Transformer GroupTransformer group":{"type":"method","name":"group","children":[],"call":["Node  [] new "," t ","Node  [] ","elements last stop ","elements last ","elements first start ","elements first ","elements any? ","elements size == ","elements size "]}," Mustermann AST Transformer GroupTransformer union":{"type":"method","name":"union","children":[],"call":["Node  [] new "," node stop "," node "," node start ","Node  [] "," group "," split_payload map "," split_payload "]}," Mustermann AST Transformer GroupTransformer translate":{"type":"method","name":"translate","children":[],"call":[" payload= "," t "," payload "," union ","e is_a? "," payload any? "," payload flatten! "," payload is_a? "]}," Mustermann Regular extended_regexp?":{"type":"method","name":"extended_regexp?","children":[],"call":["(send\n  (send\n    (send\n      (const nil :Regexp) :new\n      (lvar :string)) :options) :&\n  (const\n    (const nil :Regexp) :EXTENDED)) zero? ! ","(send\n  (send\n    (send\n      (const nil :Regexp) :new\n      (lvar :string)) :options) :&\n  (const\n    (const nil :Regexp) :EXTENDED)) zero? ","Regexp  new options & ","Regexp  new options ","Regexp  new "]}," Mustermann Concat Native look_ahead":{"type":"method","name":"look_ahead","children":[],"call":["other patterns take_while "," method ","other patterns ","other is_a? "]}}