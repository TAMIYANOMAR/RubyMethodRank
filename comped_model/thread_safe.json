{" ThreadSafe allocate":{"type":"method","name":"allocate","children":[],"call":[]}," ThreadSafe _mon_initialize":{"type":"method","name":"_mon_initialize","children":[],"call":["Monitor  new "]}," ThreadSafe Util XorShiftRandom xorshift":{"type":"method","name":"xorshift","children":[],"call":["x >> ","(send\n  (lvar :x) :<<\n  (int 1)) & ","x << "]}," ThreadSafe Util XorShiftRandom get":{"type":"method","name":"get","children":[],"call":["Kernel  rand + ","Kernel  rand "]}," ThreadSafe Util VolatileTuple each":{"type":"method","name":"each","children":[],"call":["ref get ","@tuple each "]}," ThreadSafe Util VolatileTuple size":{"type":"method","name":"size","children":[],"call":["@tuple size "]}," ThreadSafe Util VolatileTuple compare_and_set":{"type":"method","name":"compare_and_set","children":[],"call":["@tuple [] compare_and_set ","@tuple [] "]}," ThreadSafe Util VolatileTuple volatile_set":{"type":"method","name":"volatile_set","children":[],"call":["@tuple [] set ","@tuple [] "]}," ThreadSafe Util VolatileTuple volatile_get":{"type":"method","name":"volatile_get","children":[],"call":["@tuple [] get ","@tuple [] "]}," ThreadSafe Util VolatileTuple initialize":{"type":"method","name":"initialize","children":[],"call":["tuple []= ","AtomicReference  new ","i < ","Tuple  new ","Tuple  new  []= "]}," ThreadSafe Util Volatile attr_volatile":{"type":"method","name":"attr_volatile","children":[],"call":[" include "," alias_method "," class_eval ","41 + ","attr_names each ","28 + ","initialize_copy_setup join ","atomic_ref_setup join ","attr_names zip map ","attr_names zip ","attr_names map ","Module  new ","attr_names empty? ","43 + ","30 + "]}," ThreadSafe Util Striped64 try_in_busy":{"type":"method","name":"try_in_busy","children":[],"call":[" busy= "," cas_busy "]}," ThreadSafe Util Striped64 try_to_install_new_cell":{"type":"method","name":"try_to_install_new_cell","children":[],"call":["current_cells volatile_set ","current_cells volatile_get ! ","current_cells volatile_get ","current_cells hash_to_index "," cells "," try_in_busy ","current_cells volatcurrent_cells hash_to_index le_set "," cells  volatile_set ","current_cells volatcurrent_cells hash_to_index le_get ! "," cells  volatile_get ! ","current_cells volatcurrent_cells hash_to_index le_get "," cells  volatile_get ","current_cells hash_to_current_cells hash_to_index ndex "," cells  hash_to_index "," try_current_cells hash_to_index n_busy "]}," ThreadSafe Util Striped64 expand_table_unless_stale":{"type":"method","name":"expand_table_unless_stale","children":[],"call":[" cells= ","new_cells volatile_set ","current_cells each_with_index ","current_cells next_in_size_table ","current_cells == "," cells "," try_in_busy ","current_cells next_in_size_table  volatile_set "]}," ThreadSafe Util Striped64 try_initialize_cells":{"type":"method","name":"try_initialize_cells","children":[],"call":[" cells= ","new_cells volatile_set_by_hash ","Cell  new ","PowerOfTwoTuple  new "," cells "," try_in_busy "," cells ! "," free? ","PowerOfTwoTuple  new  volatile_set_by_hash "]}," ThreadSafe Util Striped64 free?":{"type":"method","name":"free?","children":[],"call":[" busy? ! "," busy? "]}," ThreadSafe Util Striped64 cas_base_computed":{"type":"method","name":"cas_base_computed","children":[],"call":[" cas_base "," base "]}," ThreadSafe Util Striped64 internal_reset":{"type":"method","name":"internal_reset","children":[],"call":["cell value= ","current_cells each "," base= "," cells "," cells  each "]}," ThreadSafe Util Striped64 hash_code=":{"type":"method","name":"hash_code=","children":[],"call":["Thread  current []= ","Thread  current "]}," ThreadSafe Util Striped64 hash_code":{"type":"method","name":"hash_code","children":[],"call":["XorShiftRandom  get ","Thread  current [] ","Thread  current "]}," ThreadSafe Util Striped64 retry_update":{"type":"method","name":"retry_update","children":[],"call":[" hash_code= "," cas_base_computed "," try_initialize_cells ","XorShiftRandom  xorshift "," expand_table_unless_stale "," cells != "," cells ","current_cells size >= ","current_cells size ","cell cas_computed ","was_uncontended ! "," try_to_install_new_cell ","Cell  new "," busy? ","(lvasgn :cell\n  (send\n    (lvar :current_cells) :volatile_get_by_hash\n    (lvar :hash))) ! ","current_cells volatile_get_by_hash "," XorShiftRandom  xorshift _code= "," try_initialize_current_cells volatile_get_by_hash s "," current_cells volatile_get_by_hash s != "," current_cells volatile_get_by_hash s ","current_current_cells volatile_get_by_hash s size >= "," cells  size >= ","current_current_cells volatile_get_by_hash s size "," cells  size ","current_cells volatile_get_by_hash  cas_computed "," try_to_install_new_current_cells volatile_get_by_hash  ","(lvasgn :cell\n  (send\n    (lvar :current_cells) :volatile_get_by_XorShiftRandom  xorshift \n    (lvar :XorShiftRandom  xorshift ))) ! ","(lvasgn :current_cells volatile_get_by_hash \n  (send\n    (lvar :current_current_cells volatile_get_by_hash s) :volatile_get_by_hash\n    (lvar :hash))) ! ","(lvasgn :cell\n  (send\n    (lvar : cells ) :volatile_get_by_hash\n    (lvar :hash))) ! ","current_cells volatile_get_by_XorShiftRandom  xorshift  ","current_current_cells volatile_get_by_hash s volatile_get_by_hash "," cells  volatile_get_by_hash "]}," ThreadSafe Util Striped64 initialize":{"type":"method","name":"initialize","children":[],"call":[" base= "," busy= "]}," ThreadSafe Util Striped64 Cell cas_computed":{"type":"method","name":"cas_computed","children":[],"call":[" cas "," value "]}," ThreadSafe Util PowerOfTwoTuple next_in_size_table":{"type":"method","name":"next_in_size_table","children":[],"call":[" class new "," size << "," size "," class "]}," ThreadSafe Util PowerOfTwoTuple volatile_set_by_hash":{"type":"method","name":"volatile_set_by_hash","children":[],"call":[" volatile_set "," hash_to_index "]}," ThreadSafe Util PowerOfTwoTuple volatile_get_by_hash":{"type":"method","name":"volatile_get_by_hash","children":[],"call":[" volatile_get "," hash_to_index "]}," ThreadSafe Util PowerOfTwoTuple hash_to_index":{"type":"method","name":"hash_to_index","children":[],"call":["(send\n  (send nil :size) :-\n  (int 1)) & "," size - "," size "]}," ThreadSafe Util PowerOfTwoTuple initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","size inspect ","size & == ","size & ","size - ","size > "]}," ThreadSafe Util CheapLockable cheap_broadcast":{"type":"method","name":"cheap_broadcast","children":[],"call":["conditional_variable broadcast ","JRuby  reference0 notify_all ","JRuby  reference0 ","waiters shift << ","waiters shift ","waiters empty? "]}," ThreadSafe Util CheapLockable cheap_wait":{"type":"method","name":"cheap_wait","children":[],"call":["conditional_variable wait "," mutex ","ConditionVariable  new ","JRuby  reference0 wait ","JRuby  reference0 ","waiters shift << ","waiters shift ","waiters empty? ","waiters delete ","Rubinius  lock ","wchan receive_timeout ","Rubinius  unlock ","waiters push ","Rubinius Channel  new ","Rubinius Channel  new  receive_timeout "]}," ThreadSafe Util CheapLockable cheap_synchronize":{"type":"method","name":"cheap_synchronize","children":[],"call":["my_mutex synchronize "," cas_mutex ","Mutex  new "," mutex ","JRuby  reference0 synchronized ","JRuby  reference0 ","Rubinius  unlock ","Rubinius  lock ","Mutex  new  synchronize "," mutex  synchronize "]}," ThreadSafe Util Adder reset":{"type":"method","name":"reset","children":[],"call":[" internal_reset "]}," ThreadSafe Util Adder sum":{"type":"method","name":"sum","children":[],"call":["cell value ","current_cells each "," cells "," base "," cells  each "]}," ThreadSafe Util Adder decrement":{"type":"method","name":"decrement","children":[],"call":[" add "]}," ThreadSafe Util Adder increment":{"type":"method","name":"increment","children":[],"call":[" add "]}," ThreadSafe Util Adder add":{"type":"method","name":"add","children":[],"call":["current_value + "," retry_update ","cell cas_computed ","current_cells volatile_get_by_hash "," hash_code ","(send nil :cas_base_computed) ! ","current_base + "," cas_base_computed "," cells ","current_cells volatile_get_by_hash  cas_computed ","current_current_cells volatile_get_by_hash s volatile_get_by_hash ","current_cells volatile_get_by_ hash_code  "," cells  volatile_get_by_hash ","  hash_code _code "," current_cells volatile_get_by_hash s "]}," ThreadSafe SynchronizedCacheBackend dupped_backend":{"type":"method","name":"dupped_backend","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend get_or_default":{"type":"method","name":"get_or_default","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend size":{"type":"method","name":"size","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend clear":{"type":"method","name":"clear","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend delete_pair":{"type":"method","name":"delete_pair","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend delete":{"type":"method","name":"delete","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend value?":{"type":"method","name":"value?","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend key?":{"type":"method","name":"key?","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend get_and_set":{"type":"method","name":"get_and_set","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend replace_if_exists":{"type":"method","name":"replace_if_exists","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend replace_pair":{"type":"method","name":"replace_pair","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend merge_pair":{"type":"method","name":"merge_pair","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend compute":{"type":"method","name":"compute","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend compute_if_present":{"type":"method","name":"compute_if_present","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend compute_if_absent":{"type":"method","name":"compute_if_absent","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend []=":{"type":"method","name":"[]=","children":[],"call":[" synchronize "]}," ThreadSafe SynchronizedCacheBackend []":{"type":"method","name":"[]","children":[],"call":[" synchronize "]}," ThreadSafe NonConcurrentCacheBackend store_computed_value":{"type":"method","name":"store_computed_value","children":[],"call":["@backend []= ","@backend delete ","new_value nil? "]}," ThreadSafe NonConcurrentCacheBackend pair?":{"type":"method","name":"pair?","children":[],"call":["expected_value equal? ","NULL  != ","@backend fetch "]}," ThreadSafe NonConcurrentCacheBackend dupped_backend":{"type":"method","name":"dupped_backend","children":[],"call":["@backend dup "]}," ThreadSafe NonConcurrentCacheBackend initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[]}," ThreadSafe NonConcurrentCacheBackend get_or_default":{"type":"method","name":"get_or_default","children":[],"call":["@backend fetch "]}," ThreadSafe NonConcurrentCacheBackend size":{"type":"method","name":"size","children":[],"call":["@backend size "]}," ThreadSafe NonConcurrentCacheBackend each_pair":{"type":"method","name":"each_pair","children":[],"call":[" dupped_backend each_pair "," dupped_backend "]}," ThreadSafe NonConcurrentCacheBackend clear":{"type":"method","name":"clear","children":[],"call":["@backend clear "]}," ThreadSafe NonConcurrentCacheBackend delete_pair":{"type":"method","name":"delete_pair","children":[],"call":["@backend delete "," pair? "]}," ThreadSafe NonConcurrentCacheBackend delete":{"type":"method","name":"delete","children":[],"call":["@backend delete "]}," ThreadSafe NonConcurrentCacheBackend value?":{"type":"method","name":"value?","children":[],"call":["@backend value? "]}," ThreadSafe NonConcurrentCacheBackend key?":{"type":"method","name":"key?","children":[],"call":["@backend key? "]}," ThreadSafe NonConcurrentCacheBackend get_and_set":{"type":"method","name":"get_and_set","children":[],"call":["@backend []= ","@backend [] "]}," ThreadSafe NonConcurrentCacheBackend merge_pair":{"type":"method","name":"merge_pair","children":[],"call":[" store_computed_value ","@backend []= ","NULL  == ","@backend fetch "]}," ThreadSafe NonConcurrentCacheBackend compute":{"type":"method","name":"compute","children":[],"call":[" store_computed_value ","@backend [] "]}," ThreadSafe NonConcurrentCacheBackend compute_if_present":{"type":"method","name":"compute_if_present","children":[],"call":[" store_computed_value ","NULL  != ","@backend fetch "]}," ThreadSafe NonConcurrentCacheBackend replace_if_exists":{"type":"method","name":"replace_if_exists","children":[],"call":["@backend []= ","NULL  != ","@backend fetch "]}," ThreadSafe NonConcurrentCacheBackend replace_pair":{"type":"method","name":"replace_pair","children":[],"call":["@backend []= "," pair? "]}," ThreadSafe NonConcurrentCacheBackend compute_if_absent":{"type":"method","name":"compute_if_absent","children":[],"call":["@backend []= ","NULL  != ","@backend fetch "]}," ThreadSafe NonConcurrentCacheBackend []=":{"type":"method","name":"[]=","children":[],"call":["@backend []= "]}," ThreadSafe NonConcurrentCacheBackend []":{"type":"method","name":"[]","children":[],"call":["@backend [] "]}," ThreadSafe NonConcurrentCacheBackend initialize":{"type":"method","name":"initialize","children":[],"call":[]}," ThreadSafe MriCacheBackend clear":{"type":"method","name":"clear","children":[],"call":["WRITE_LOCK  synchronize "]}," ThreadSafe MriCacheBackend delete_pair":{"type":"method","name":"delete_pair","children":[],"call":["WRITE_LOCK  synchronize "]}," ThreadSafe MriCacheBackend delete":{"type":"method","name":"delete","children":[],"call":["WRITE_LOCK  synchronize "]}," ThreadSafe MriCacheBackend get_and_set":{"type":"method","name":"get_and_set","children":[],"call":["WRITE_LOCK  synchronize "]}," ThreadSafe MriCacheBackend replace_if_exists":{"type":"method","name":"replace_if_exists","children":[],"call":["WRITE_LOCK  synchronize "]}," ThreadSafe MriCacheBackend replace_pair":{"type":"method","name":"replace_pair","children":[],"call":["WRITE_LOCK  synchronize "]}," ThreadSafe MriCacheBackend merge_pair":{"type":"method","name":"merge_pair","children":[],"call":["WRITE_LOCK  synchronize "]}," ThreadSafe MriCacheBackend compute":{"type":"method","name":"compute","children":[],"call":["WRITE_LOCK  synchronize "]}," ThreadSafe MriCacheBackend compute_if_present":{"type":"method","name":"compute_if_present","children":[],"call":["WRITE_LOCK  synchronize "]}," ThreadSafe MriCacheBackend compute_if_absent":{"type":"method","name":"compute_if_absent","children":[],"call":["WRITE_LOCK  synchronize "," _get "]}," ThreadSafe MriCacheBackend []=":{"type":"method","name":"[]=","children":[],"call":["WRITE_LOCK  synchronize "]}," ThreadSafe Cache validate_options_hash!":{"type":"method","name":"validate_options_hash!","children":[],"call":[" raise ","load_factor > ","load_factor <= ","load_factor kind_of? ! ","load_factor kind_of? ","options [] ","initial_capacity < ","initial_capacity kind_of? ! ","initial_capacity kind_of? ","0 class ","options []  > ","options []  <= ","options []  kind_of? ! ","options []  kind_of? ","options []  < "]}," ThreadSafe Cache populate_from":{"type":"method","name":"populate_from","children":[],"call":[" []= ","hash each_pair "]}," ThreadSafe Cache initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" populate_from "]}," ThreadSafe Cache marshal_load":{"type":"method","name":"marshal_load","children":[],"call":[" populate_from "," initialize "]}," ThreadSafe Cache marshal_dump":{"type":"method","name":"marshal_dump","children":[],"call":["h []= "," each_pair "," raise "]}," ThreadSafe Cache size":{"type":"method","name":"size","children":[],"call":[" each_pair "]}," ThreadSafe Cache empty?":{"type":"method","name":"empty?","children":[],"call":[" each_pair "]}," ThreadSafe Cache each_value":{"type":"method","name":"each_value","children":[],"call":[" each_pair "]}," ThreadSafe Cache each_key":{"type":"method","name":"each_key","children":[],"call":[" each_pair "]}," ThreadSafe Cache values":{"type":"method","name":"values","children":[],"call":["arr << "," each_pair "]}," ThreadSafe Cache keys":{"type":"method","name":"keys","children":[],"call":["arr << "," each_pair "]}," ThreadSafe Cache value?":{"type":"method","name":"value?","children":[],"call":["value equal? "," each_value "]}," ThreadSafe Cache put_if_absent":{"type":"method","name":"put_if_absent","children":[],"call":[" compute_if_absent "]}," ThreadSafe Cache fetch":{"type":"method","name":"fetch","children":[],"call":[" raise ","NULL  != "," block_given? "," get_or_default "," raise_fetch_no_key "]}," ThreadSafe Cache []":{"type":"method","name":"[]","children":[],"call":["@default_proc call "," key? ! "," key? ","NULL  == "," get_or_default "," == "]}," ThreadSafe Cache initialize":{"type":"method","name":"initialize","children":[],"call":[" validate_options_hash! ","options kind_of? "]}," ThreadSafe AtomicReferenceCacheBackend decrement_size":{"type":"method","name":"decrement_size","children":[],"call":["@counter add ","by -@ "]}," ThreadSafe AtomicReferenceCacheBackend increment_size":{"type":"method","name":"increment_size","children":[],"call":["@counter increment "]}," ThreadSafe AtomicReferenceCacheBackend split_bin":{"type":"method","name":"split_bin","children":[],"call":["new_table volatile_set ","i + ","current_node next ","Node  new ","current_node value ","current_node key ","(send\n  (lvar :pure_hash) :&\n  (lvar :bit)) == ","pure_hash & ","current_node pure_hash ","current_node == ","run_bit == ","(lvasgn :b\n  (send\n    (send\n      (lvar :current_node) :hash) :&\n    (lvar :bit))) == ","current_node hash & ","current_node hash ","node_hash & ","new_table size >> ","new_table size ","new_tacurrent_node hash & le volatile_set ","current_node next  next ","current_node next  value ","current_node next  key ","(send\n  (lvar :current_node pure_hash ) :&\n  (lvar :bit)) == ","(send\n  (lvar :pure_hash) :&\n  (lvar :current_node hash & it)) == ","(send\n  (lvar :pure_hash) :&\n  (lvar :new_table size >> )) == ","current_node pure_hash  & ","current_node next  pure_hash ","current_node current_node pure_hash  ","current_node next  == ","run_current_node hash & it == ","node_hash &  == ","run_new_table size >>  == ","(lvasgn :b\n  (send\n    (send\n      (lvar :current_node next ) :hash) :&\n    (lvar :bit))) == ","(lvasgn :current_node hash & \n  (send\n    (send\n      (lvar :current_node) :hash) :&\n    (lvar :current_node hash & it))) == ","(lvasgn :b\n  (send\n    (send\n      (lvar :current_node) :hash) :&\n    (lvar :new_table size >> ))) == ","current_node next  hash & ","current_node next  hash ","new_tacurrent_node hash & le size >> ","new_tacurrent_node hash & le size "]}," ThreadSafe AtomicReferenceCacheBackend split_old_bin":{"type":"method","name":"split_old_bin","children":[],"call":["table volatile_set "," split_bin ","table try_lock_via_hash "]}," ThreadSafe AtomicReferenceCacheBackend lock_and_clean_up_reverse_forwarders":{"type":"method","name":"lock_and_clean_up_reverse_forwarders","children":[],"call":["locked_forwarder unlock_via_hash ","old_table volatile_set ","new_table volatile_set ","i + ","old_table cas ","Node  new ","MOVED  | ","Node  new  unlock_via_hash "]}," ThreadSafe AtomicReferenceCacheBackend rebuild":{"type":"method","name":"rebuild","children":[],"call":["locked_indexes size - ","locked_indexes size ","locked_indexes pop ","locked_indexes empty? ! ","locked_indexes empty? ","bin > "," split_old_bin ","new_table volatile_set ","i + ","locked_indexes << ","node locked? ","table volatile_get == ","table volatile_get ","Node  new ","node try_await_lock ","locked_indexes size >= ","bin < ","locked_indexes [] ","locked_indexes []= ","locked_arr_idx > ","Array  new ","Node  locked_hash? ","node hash "," lock_and_clean_up_reverse_forwarders ","table cas ","bin >= ","(lvasgn :node\n  (send\n    (lvar :table) :volatile_get\n    (lvar :i))) ! ","old_table_size - ","table next_in_size_table ","table size ","locked_locked_indexes pop ndexes slocked_indexes pop ze - ","locked_locked_indexes pop ndexes slocked_indexes pop ze ","locked_locked_indexes pop ndexes pop ","locked_locked_indexes pop ndexes empty? ! ","locked_locked_indexes pop ndexes empty? ","blocked_indexes pop n > ","old_table_size -  > "," spllocked_indexes pop t_old_blocked_indexes pop n "," split_old_old_table_size -  ","new_table volatlocked_indexes pop le_set ","table next_in_size_table  volatile_set ","locked_indexes pop  + ","locked_locked_indexes pop ndexes << ","table volatile_get  locked? ","table volatlocked_indexes pop le_get == ","table volatlocked_indexes pop le_get ","node try_awalocked_indexes pop t_lock ","table volatile_get  try_await_lock ","locked_locked_indexes pop ndexes slocked_indexes pop ze >= ","blocked_indexes pop n < ","old_table_size -  < ","locked_locked_indexes pop ndexes [] ","locked_locked_indexes pop ndexes []= ","locked_indexes size -  > ","locked_arr_locked_indexes pop dx > ","table volatile_get  hash "," lock_and_clean_up_reverse_Node  new s ","blocked_indexes pop n >= ","old_table_size -  >= ","(lvasgn :node\n  (send\n    (lvar :table) :volatlocked_indexes pop le_get\n    (lvar :locked_indexes pop ))) ! ","(lvasgn :table volatile_get \n  (send\n    (lvar :table) :volatile_get\n    (lvar :i))) ! ","old_table_slocked_indexes pop ze - ","table size  - ","table next_locked_indexes pop n_slocked_indexes pop ze_table ","table slocked_indexes pop ze "]}," ThreadSafe AtomicReferenceCacheBackend try_in_resize_lock":{"type":"method","name":"try_in_resize_lock","children":[],"call":[" size_control= ","current_table == "," table "," cas_size_control "]}," ThreadSafe AtomicReferenceCacheBackend check_for_resize":{"type":"method","name":"check_for_resize","children":[],"call":["(send\n  (lvar :table_size) :<<\n  (int 1)) - ","table_size >> ","table_size << "," table= "," rebuild "," try_in_resize_lock ","size_ctrl < ","@counter sum ","NOW_RESIZING  != "," size_control ","MAX_CAPACITY  > ","current_table size "," table ","(send\n  (lvar :current_table size ) :<<\n  (int 1)) - ","current_table size  >> ","current_table size  << "," size_control  < "," table  size "]}," ThreadSafe AtomicReferenceCacheBackend initialize_table":{"type":"method","name":"initialize_table","children":[],"call":["initial_size - ","initial_size >> "," table= ","Table  new ","size_ctrl > "," try_in_resize_lock ","Thread  pass ","(lvasgn :size_ctrl\n  (send nil :size_control)) == "," size_control "," table "," size_control  > ","(lvasgn : size_control \n  (send nil :size_control)) == "]}," ThreadSafe AtomicReferenceCacheBackend table_size_for":{"type":"method","name":"table_size_for","children":[],"call":["size < "]}," ThreadSafe AtomicReferenceCacheBackend key_hash":{"type":"method","name":"key_hash","children":[],"call":["key hash & ","key hash "]}," ThreadSafe AtomicReferenceCacheBackend try_await_lock":{"type":"method","name":"try_await_lock","children":[],"call":["node try_await_lock "," check_for_resize "]}," ThreadSafe AtomicReferenceCacheBackend initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" size_control= ","other_table size ","other table "," table= ","Util Adder  new ","other table  size "]}," ThreadSafe AtomicReferenceCacheBackend attempt_get_and_set":{"type":"method","name":"attempt_get_and_set","children":[],"call":[" check_for_resize ","current_table size <= ","current_table size ","node_nesting > "," increment_size ","last next= ","Node  new ","node next ","node value= ","NULL  != ","node value ","node matches? ","current_table try_lock_via_hash ","node next _nesting > ","node next  next ","node next  value= ","node next  value ","node next  matches? "]}," ThreadSafe AtomicReferenceCacheBackend attempt_compute":{"type":"method","name":"attempt_compute","children":[],"call":[" check_for_resize "," increment_size ","predecessor_node next= ","Node  new ","NULL  == ","node next "," decrement_size ","current_table delete_node_at ","node value= ","NULL  != ","node value ","node matches? ","current_table try_lock_via_hash ","predecessor_node next  next= ","node next  next ","current_table delete_node next _at ","node next  value= ","node node value = ","node next  value ","node node value  ","node next  matches? "]}," ThreadSafe AtomicReferenceCacheBackend attempt_internal_compute_if_absent":{"type":"method","name":"attempt_internal_compute_if_absent","children":[],"call":[" check_for_resize "," increment_size ","last next= ","Node  new ","node next ","NULL  != ","node value ","node matches? ","current_table try_lock_via_hash ","node next  next ","node next  value ","node node value  ","node next  matches? "]}," ThreadSafe AtomicReferenceCacheBackend internal_compute":{"type":"method","name":"internal_compute","children":[],"call":[" attempt_compute "," try_await_lock ","Node  locked_hash? ","node key ","(lvasgn :node_hash\n  (send\n    (lvar :node) :hash)) == ","node hash "," increment_size ","NULL  == ","current_table try_to_cas_in_computed ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) :hash_to_index\n        (lvar :hash))))) ! ","current_table volatile_get ","current_table hash_to_index "," initialize_table "," table "," key_hash "," try_awacurrent_table hash_to_index t_lock ","Node  locked_ key_hash ? ","current_table volatile_get  key ","(lvasgn :node hash \n  (send\n    (lvar :node) :hash)) == ","(lvasgn :current_table volatile_get _hash\n  (send\n    (lvar :current_table volatile_get ) :hash)) == ","(lvasgn :node_ key_hash \n  (send\n    (lvar :node) : key_hash )) == ","current_table volatile_get  hash ","node  key_hash  "," current_table hash_to_index ncrement_scurrent_table hash_to_index ze ","node key  try_to_cas_in_computed ","current_table try_to_cas_current_table hash_to_index n_computed ","(lvasgn :node\n  (send\n    (lvar :node key ) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :node key ) :hash_to_index\n        (lvar :hash))))) ! ","(lvasgn :current_table volatile_get \n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) :hash_to_index\n        (lvar :hash))))) ! ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatcurrent_table hash_to_index le_get\n    (lvasgn :current_table hash_to_index \n      (send\n        (lvar :current_table) :hash_to_current_table hash_to_index ndex\n        (lvar :hash))))) ! ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) : key_hash _to_index\n        (lvar : key_hash ))))) ! ","node key  volatile_get ","current_table volatcurrent_table hash_to_index le_get ","node key  hash_to_index ","current_table hash_to_current_table hash_to_index ndex ","current_table  key_hash _to_index "," current_table hash_to_index ncurrent_table hash_to_index tcurrent_table hash_to_index alcurrent_table hash_to_index ze_table "," key_ key_hash  "]}," ThreadSafe AtomicReferenceCacheBackend find_value_in_node_list":{"type":"method","name":"find_value_in_node_list","children":[],"call":[" check_for_resize ","node pure_hash ","node next ","NULL  != ","node value ","node key? ","pure_hash == ","node node pure_hash  ","node next  pure_hash ","node next  next ","node next  value ","node node value  ","node next  key? ","node pure_hash  == "]}," ThreadSafe AtomicReferenceCacheBackend attempt_internal_replace":{"type":"method","name":"attempt_internal_replace","children":[],"call":[" decrement_size ","current_table delete_node_at ","NULL  == ","node value= ","expected_old_value == ","NULL  != ","node value ","node matches? ","node next ","current_table try_lock_via_hash ","current_table delete_node next _at ","node next  value= ","node next  value ","node next  matches? ","node next  next "]}," ThreadSafe AtomicReferenceCacheBackend internal_replace":{"type":"method","name":"internal_replace","children":[],"call":[" attempt_internal_replace "," try_await_lock ","Node  locked_hash? ","node next ! ","node next ","(send\n  (lvar :node_hash) :&\n  (const nil :HASH_BITS)) != ","node_hash & ","node key ","(lvasgn :node_hash\n  (send\n    (lvar :node) :hash)) == ","node hash ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) :hash_to_index\n        (lvar :hash))))) ! ","current_table volatile_get ","current_table hash_to_index "," table "," key_hash "," attempt_current_table hash_to_index nternal_replace "," try_awacurrent_table hash_to_index t_lock ","Node  locked_ key_hash ? ","current_table volatile_get  next ! ","current_table volatile_get  next ","(send\n  (lvar :node hash ) :&\n  (const nil :HASH_BITS)) != ","(send\n  (lvar :current_table volatile_get _hash) :&\n  (const nil :HASH_BITS)) != ","(send\n  (lvar :node_hash) :&\n  (const ncurrent_table hash_to_index l :HASH_BITS)) != ","(send\n  (lvar :node_ key_hash ) :&\n  (const nil :HASH_BITS)) != ","node hash  & ","current_table volatile_get _hash & ","node_ key_hash  & ","current_table volatile_get  key ","(lvasgn :node hash \n  (send\n    (lvar :node) :hash)) == ","(lvasgn :current_table volatile_get _hash\n  (send\n    (lvar :current_table volatile_get ) :hash)) == ","(lvasgn :node_ key_hash \n  (send\n    (lvar :node) : key_hash )) == ","current_table volatile_get  hash ","node  key_hash  ","(lvasgn :node\n  (send\n    (lvar :node key ) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :node key ) :hash_to_index\n        (lvar :hash))))) ! ","(lvasgn :node\n  (send\n    (lvar : table ) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar : table ) :hash_to_index\n        (lvar :hash))))) ! ","(lvasgn :current_table volatile_get \n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) :hash_to_index\n        (lvar :hash))))) ! ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatcurrent_table hash_to_index le_get\n    (lvasgn :current_table hash_to_index \n      (send\n        (lvar :current_table) :hash_to_current_table hash_to_index ndex\n        (lvar :hash))))) ! ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) : key_hash _to_index\n        (lvar : key_hash ))))) ! ","node key  volatile_get "," table  volatile_get ","current_table volatcurrent_table hash_to_index le_get ","node key  hash_to_index "," table  hash_to_index ","current_table hash_to_current_table hash_to_index ndex ","current_table  key_hash _to_index "," key_ key_hash  "]}," ThreadSafe AtomicReferenceCacheBackend clear":{"type":"method","name":"clear","children":[],"call":[" decrement_size ","current_table volatile_set ","node value= ","NULL  != ","node value ","node next ","current_table try_lock_via_hash ","node try_await_lock ","Node  locked_hash? ","current_table size ","node key ","(lvasgn :node_hash\n  (send\n    (lvar :node) :hash)) == ","node hash ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatile_get\n    (lvar :i))) ! ","current_table volatile_get ","i < "," table ","node key  volatile_set "," table  volatile_set ","node next  value= ","current_table volatile_get  value= ","node next  value ","current_table volatile_get  value ","node next  next ","current_table volatile_get  next ","node key  try_lock_via_hash "," table  try_lock_via_hash ","node next  try_await_lock ","current_table volatile_get  try_await_lock ","node key  size "," table  size ","node next  key ","current_table volatile_get  key ","(lvasgn :node next _hash\n  (send\n    (lvar :node next ) :hash)) == ","(lvasgn :current_table volatile_get _hash\n  (send\n    (lvar :current_table volatile_get ) :hash)) == ","(lvasgn :node hash \n  (send\n    (lvar :node) :hash)) == ","node next  hash ","current_table volatile_get  hash ","(lvasgn :node next \n  (send\n    (lvar :current_table) :volatile_get\n    (lvar :i))) ! ","(lvasgn :current_table volatile_get \n  (send\n    (lvar :current_table) :volatile_get\n    (lvar :i))) ! ","(lvasgn :node\n  (send\n    (lvar :node key ) :volatile_get\n    (lvar :i))) ! ","(lvasgn :node\n  (send\n    (lvar : table ) :volatile_get\n    (lvar :i))) ! ","node key  volatile_get "," table  volatile_get "]}," ThreadSafe AtomicReferenceCacheBackend empty?":{"type":"method","name":"empty?","children":[],"call":[" size == "," size "]}," ThreadSafe AtomicReferenceCacheBackend size":{"type":"method","name":"size","children":[],"call":["(lvasgn :sum\n  (send\n    (ivar :@counter) :sum)) < ","@counter sum ","(lvasgn :@counter sum \n  (send\n    (ivar :@counter) :@counter sum )) < ","@counter @counter sum  "]}," ThreadSafe AtomicReferenceCacheBackend each_pair":{"type":"method","name":"each_pair","children":[],"call":["(lvasgn :i_with_base\n  (send\n    (lvar :i) :+\n    (lvar :base_size))) < ","i + ","node key ","NULL  != ","node value ","node next ","current_table size ","node hash == ","node hash ","current_table volatile_get ","base_index < "," table ","(lvasgn :i + \n  (send\n    (lvar :i) :+\n    (lvar :base_size))) < ","(lvasgn :i_with_base\n  (send\n    (lvar :i) :+\n    (lvar :current_table size ))) < ","node next  key ","current_table volatile_get  key ","node node value  ","node next  value ","current_table volatile_get  value ","node next  next ","current_table volatile_get  next ","node key  size "," table  size ","node next  hash == ","current_table volatile_get  hash == ","node next  hash ","current_table volatile_get  hash ","node key  volatile_get "," table  volatile_get "]}," ThreadSafe AtomicReferenceCacheBackend delete_pair":{"type":"method","name":"delete_pair","children":[],"call":["result ! ! ","result ! ","NULL  != "," internal_replace "]}," ThreadSafe AtomicReferenceCacheBackend delete":{"type":"method","name":"delete","children":[],"call":[" replace_if_exists "]}," ThreadSafe AtomicReferenceCacheBackend get_and_set":{"type":"method","name":"get_and_set","children":[],"call":[" attempt_get_and_set "," try_await_lock ","Node  locked_hash? ","node key ","(lvasgn :node_hash\n  (send\n    (lvar :node) :hash)) == ","node hash "," increment_size ","current_table cas_new_node ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) :hash_to_index\n        (lvar :hash))))) ! ","current_table volatile_get ","current_table hash_to_index "," initialize_table "," table "," key_hash "," try_awacurrent_table hash_to_index t_lock ","Node  locked_ key_hash ? ","current_table volatile_get  key ","(lvasgn :node hash \n  (send\n    (lvar :node) :hash)) == ","(lvasgn :current_table volatile_get _hash\n  (send\n    (lvar :current_table volatile_get ) :hash)) == ","(lvasgn :node_ key_hash \n  (send\n    (lvar :node) : key_hash )) == ","current_table volatile_get  hash ","node  key_hash  "," current_table hash_to_index ncrement_scurrent_table hash_to_index ze ","node key  cas_new_node ","current_table cas_new_current_table volatile_get  ","(lvasgn :node\n  (send\n    (lvar :node key ) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :node key ) :hash_to_index\n        (lvar :hash))))) ! ","(lvasgn :current_table volatile_get \n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) :hash_to_index\n        (lvar :hash))))) ! ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatcurrent_table hash_to_index le_get\n    (lvasgn :current_table hash_to_index \n      (send\n        (lvar :current_table) :hash_to_current_table hash_to_index ndex\n        (lvar :hash))))) ! ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) : key_hash _to_index\n        (lvar : key_hash ))))) ! ","node key  volatile_get ","current_table volatcurrent_table hash_to_index le_get ","node key  hash_to_index ","current_table hash_to_current_table hash_to_index ndex ","current_table  key_hash _to_index "," current_table hash_to_index ncurrent_table hash_to_index tcurrent_table hash_to_index alcurrent_table hash_to_index ze_table "," key_ key_hash  "]}," ThreadSafe AtomicReferenceCacheBackend replace_if_exists":{"type":"method","name":"replace_if_exists","children":[],"call":["NULL  != "," internal_replace "]}," ThreadSafe AtomicReferenceCacheBackend replace_pair":{"type":"method","name":"replace_pair","children":[],"call":["NULL  != "," internal_replace "]}," ThreadSafe AtomicReferenceCacheBackend merge_pair":{"type":"method","name":"merge_pair","children":[],"call":["(lvasgn :value\n  (yield\n    (lvar :old_value))) nil? ! ","(lvasgn :value\n  (yield\n    (lvar :old_value))) nil? ","NULL  == "," internal_compute "]}," ThreadSafe AtomicReferenceCacheBackend compute":{"type":"method","name":"compute","children":[],"call":["(lvasgn :new_value\n  (yield\n    (if\n      (send\n        (const nil :NULL) :==\n        (lvar :old_value))\n      (nil)\n      (lvar :old_value)))) nil? ","NULL  == "," internal_compute "]}," ThreadSafe AtomicReferenceCacheBackend compute_if_present":{"type":"method","name":"compute_if_present","children":[],"call":["(lvasgn :new_value\n  (yield\n    (if\n      (send\n        (const nil :NULL) :==\n        (lvar :old_value))\n      (nil)\n      (lvar :old_value)))) nil? ","NULL  == "," internal_replace "]}," ThreadSafe AtomicReferenceCacheBackend compute_if_absent":{"type":"method","name":"compute_if_absent","children":[],"call":[" attempt_internal_compute_if_absent "," try_await_lock ","Node  locked_hash? ","NULL  != "," find_value_in_node_list ","node_hash & ","node key ","(lvasgn :node_hash\n  (send\n    (lvar :node) :hash)) == ","node hash "," increment_size ","current_table try_to_cas_in_computed ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) :hash_to_index\n        (lvar :hash))))) ! ","current_table volatile_get ","current_table hash_to_index "," initialize_table "," table "," key_hash "," attempt_current_table hash_to_index nternal_compute_current_table hash_to_index f_absent "," try_awacurrent_table hash_to_index t_lock ","Node  locked_ key_hash ? "," find_value_in_current_table volatile_get _list "," fcurrent_table hash_to_index nd_value_current_table hash_to_index n_node_lcurrent_table hash_to_index st ","node hash  & ","current_table volatile_get _hash & ","node_ key_hash  & ","current_table volatile_get  key ","(lvasgn :node hash \n  (send\n    (lvar :node) :hash)) == ","(lvasgn :current_table volatile_get _hash\n  (send\n    (lvar :current_table volatile_get ) :hash)) == ","(lvasgn :node_ key_hash \n  (send\n    (lvar :node) : key_hash )) == ","current_table volatile_get  hash ","node  key_hash  "," current_table hash_to_index ncrement_scurrent_table hash_to_index ze ","node key  try_to_cas_in_computed ","current_table try_to_cas_current_table hash_to_index n_computed ","(lvasgn :node\n  (send\n    (lvar :node key ) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :node key ) :hash_to_index\n        (lvar :hash))))) ! ","(lvasgn :current_table volatile_get \n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) :hash_to_index\n        (lvar :hash))))) ! ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatcurrent_table hash_to_index le_get\n    (lvasgn :current_table hash_to_index \n      (send\n        (lvar :current_table) :hash_to_current_table hash_to_index ndex\n        (lvar :hash))))) ! ","(lvasgn :node\n  (send\n    (lvar :current_table) :volatile_get\n    (lvasgn :i\n      (send\n        (lvar :current_table) : key_hash _to_index\n        (lvar : key_hash ))))) ! ","node key  volatile_get ","current_table volatcurrent_table hash_to_index le_get ","node key  hash_to_index ","current_table hash_to_current_table hash_to_index ndex ","current_table  key_hash _to_index "," current_table hash_to_index ncurrent_table hash_to_index tcurrent_table hash_to_index alcurrent_table hash_to_index ze_table "," key_ key_hash  "]}," ThreadSafe AtomicReferenceCacheBackend []=":{"type":"method","name":"[]=","children":[],"call":[" get_and_set "]}," ThreadSafe AtomicReferenceCacheBackend key?":{"type":"method","name":"key?","children":[],"call":[" get_or_default != "," get_or_default "]}," ThreadSafe AtomicReferenceCacheBackend []":{"type":"method","name":"[]","children":[],"call":[" get_or_default "]}," ThreadSafe AtomicReferenceCacheBackend get_or_default":{"type":"method","name":"get_or_default","children":[],"call":["node next ","NULL  != ","node value ","node key? ","(send\n  (lvar :node_hash) :&\n  (const nil :HASH_BITS)) == ","node_hash & ","node key ","(lvasgn :node_hash\n  (send\n    (lvar :node) :hash)) == ","node hash ","current_table volatile_get_by_hash "," table "," key_hash ","node next  next ","current_table volatile_get_by_hash  next ","node next  value ","current_table volatile_get_by_hash  value ","node node value  ","node next  key? ","current_table volatile_get_by_hash  key? ","(send\n  (lvar :node next _hash) :&\n  (const nil :HASH_BITS)) == ","(send\n  (lvar :current_table volatile_get_by_hash _hash) :&\n  (const nil :HASH_BITS)) == ","(send\n  (lvar :node hash ) :&\n  (const nil :HASH_BITS)) == ","(send\n  (lvar :node_ key_hash ) :&\n  (const nil :HASH_BITS)) == ","node next _hash & ","current_table volatile_get_by_hash _hash & ","node hash  & ","node_ key_hash  & ","node next  key ","current_table volatile_get_by_hash  key ","(lvasgn :node next _hash\n  (send\n    (lvar :node next ) :hash)) == ","(lvasgn :current_table volatile_get_by_hash _hash\n  (send\n    (lvar :current_table volatile_get_by_hash ) :hash)) == ","(lvasgn :node hash \n  (send\n    (lvar :node) :hash)) == ","(lvasgn :node_ key_hash \n  (send\n    (lvar :node) : key_hash )) == ","node next  hash ","current_table volatile_get_by_hash  hash ","node  key_hash  "," table  volatile_get_by_hash ","current_table volatile_get_by_ key_hash  "," key_ key_hash  "]}," ThreadSafe AtomicReferenceCacheBackend initialize":{"type":"method","name":"initialize","children":[],"call":[" size_control= ","(lvasgn :capacity\n  (send nil :table_size_for\n    (lvar :initial_capacity))) > "," table_size_for ","options [] ","Util Adder  new ","(lvasgn : table_size_for \n  (send nil :table_size_for\n    (lvar :initial_ table_size_for ))) > "]}," ThreadSafe AtomicReferenceCacheBackend Node locked_hash?":{"type":"method","name":"locked_hash?","children":[],"call":["(send\n  (lvar :hash) :&\n  (const nil :LOCKED)) != ","hash & "]}," ThreadSafe AtomicReferenceCacheBackend Node force_aquire_lock":{"type":"method","name":"force_aquire_lock","children":[],"call":[" cheap_broadcast "," cheap_wait ","(send\n  (send nil :hash) :&\n  (const nil :WAITING)) == "," hash & "," hash "," equal? ","table volatile_get "," cheap_synchronize "]}," ThreadSafe AtomicReferenceCacheBackend Node unlock_via_hash":{"type":"method","name":"unlock_via_hash","children":[],"call":[" cheap_broadcast "," cheap_synchronize "," hash= "," cas_hash "]}," ThreadSafe AtomicReferenceCacheBackend Node locked?":{"type":"method","name":"locked?","children":[],"call":[" class locked_hash? "," hash "," class "]}," ThreadSafe AtomicReferenceCacheBackend Node try_lock_via_hash":{"type":"method","name":"try_lock_via_hash","children":[],"call":[" unlock_via_hash "," cas_hash ","node_hash | "]}," ThreadSafe AtomicReferenceCacheBackend Node pure_hash":{"type":"method","name":"pure_hash","children":[],"call":[" hash & "," hash "]}," ThreadSafe AtomicReferenceCacheBackend Node matches?":{"type":"method","name":"matches?","children":[],"call":[" key? "," pure_hash == "," pure_hash "]}," ThreadSafe AtomicReferenceCacheBackend Node key?":{"type":"method","name":"key?","children":[],"call":["@key eql? "]}," ThreadSafe AtomicReferenceCacheBackend Node try_await_lock":{"type":"method","name":"try_await_lock","children":[],"call":[" force_aquire_lock "," cas_hash ","my_hash | ","Util XorShiftRandom  xorshift ","randomizer zero? ","Thread  pass ","(op-asgn\n  (lvasgn :spins) :-\n  (int 1)) == ","(lvasgn :randomizer\n  (begin\n    (send\n      (lvar :randomizer) :>>\n      (int 1)))) even? ","randomizer >> ","spins >= "," class locked_hash? "," hash "," class "," equal? ","table volatile_get ","Util XorShiftRandom  get ","i < ","table size ","i >= "," hash  | "]}," ThreadSafe AtomicReferenceCacheBackend Node initialize":{"type":"method","name":"initialize","children":[],"call":[" next= "," lazy_set_value "," lazy_set_hash "]}," ThreadSafe AtomicReferenceCacheBackend Table delete_node_at":{"type":"method","name":"delete_node_at","children":[],"call":[" volatile_set ","node next ","predecessor_node next= "]}," ThreadSafe AtomicReferenceCacheBackend Table try_lock_via_hash":{"type":"method","name":"try_lock_via_hash","children":[],"call":[" volatile_get == "," volatile_get ","node try_lock_via_hash "]}," ThreadSafe AtomicReferenceCacheBackend Table try_to_cas_in_computed":{"type":"method","name":"try_to_cas_in_computed","children":[],"call":["new_node unlock_via_hash "," volatile_set ","succeeded ! ","new_node value= ","NULL  == "," cas ","Node  new ","hash | ","Node  new  unlock_via_hash ","Node  new  value= "]}," ThreadSafe AtomicReferenceCacheBackend Table cas_new_node":{"type":"method","name":"cas_new_node","children":[],"call":[" cas ","Node  new "]}," SynchronizedDelegator method_missing":{"type":"method","name":"method_missing","children":[],"call":["mutex unlock ","mutex lock ","monitor exit ","target __send__ ","target respond_to? "," __getobj__ ","monitor enter "," __getobj__  __send__ "," __getobj__  respond_to? "]}," SynchronizedDelegator initialize":{"type":"method","name":"initialize","children":[],"call":["Mutex  new ","Monitor  new "," __setobj__ "]}," Threadsafe const_missing":{"type":"method","name":"const_missing","children":[],"call":[]}," ThreadSafe Cache key":{"type":"method","name":"key","children":[],"call":["v == "," each_pair "]}," ThreadSafe Util FullLockingAtomicReference compare_and_set":{"type":"method","name":"compare_and_set","children":[],"call":["@___mutex unlock ","@___value equal? ","@___mutex try_lock "]}," ThreadSafe Util FullLockingAtomicReference set":{"type":"method","name":"set","children":[],"call":["@___mutex synchronize "]}," ThreadSafe Util FullLockingAtomicReference get":{"type":"method","name":"get","children":[],"call":["@___mutex synchronize "]}," ThreadSafe Util FullLockingAtomicReference initialize":{"type":"method","name":"initialize","children":[],"call":["Mutex  new "]}," SynchronizedDelegator teardown":{"type":"method","name":"teardown","children":[],"call":["Thread  abort_on_exception= "]}," SynchronizedDelegator setup":{"type":"method","name":"setup","children":[],"call":["Thread  abort_on_exception= ","Thread  abort_on_exception "]}," ThreadSafe Cache raise_fetch_no_key":{"type":"method","name":"raise_fetch_no_key","children":[],"call":[" raise "]}," ThreadSafe Cache fetch_or_store":{"type":"method","name":"fetch_or_store","children":[],"call":[" put "," raise_fetch_no_key ","NULL  == "," block_given? "," fetch "]}}