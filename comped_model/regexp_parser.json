{" Regexp previous":{"type":"method","name":"previous","children":[],"call":[]}," Regexp next":{"type":"method","name":"next","children":[],"call":[]}," Regexp to_h":{"type":"method","name":"to_h","children":[],"call":["hash []= "," send ","member to_sym "," members each "," members "," [] "," members inject "]}," Regexp length":{"type":"method","name":"length","children":[],"call":[" te - "," ts "," te "]}," Regexp offset":{"type":"method","name":"offset","children":[],"call":[" te "," ts "]}," Syntax Any implements!":{"type":"method","name":"implements!","children":[],"call":[]}," Syntax Any implements?":{"type":"method","name":"implements?","children":[],"call":[]}," Syntax Any initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Base normalize_backref":{"type":"method","name":"normalize_backref","children":[],"call":[]}," Syntax Base normalize_group":{"type":"method","name":"normalize_group","children":[],"call":[]}," Syntax Base normalize":{"type":"method","name":"normalize","children":[],"call":[" normalize_backref "," normalize_group "]}," Syntax Base implements!":{"type":"method","name":"implements!","children":[],"call":[" raise ","NotImplementedError  new "," implements? "]}," Syntax Base implements?":{"type":"method","name":"implements?","children":[],"call":["@implements [] include? ","@implements [] "," implementations include? "," implementations "]}," Syntax Base excludes":{"type":"method","name":"excludes","children":[],"call":["@implements []= ","@implements [] empty? ","@implements [] ","@implements [] - ","tokens is_a? "," implementations subtract "," Array "," implementations "," implementations delete "," Array each "," removed_features []= "," removed_features "," features [] delete "," features [] "," features ","tokens each "]}," Syntax Base implements":{"type":"method","name":"implements","children":[],"call":["@implements []= ","(send\n  (send\n    (ivar :@implements) :[]\n    (lvar :type)) :+\n  (lvar :tokens)) uniq ","@implements [] + ","@implements [] "," implementations merge "," Array "," implementations "," implementations concat "," added_features []= "," added_features ","(or-asgn\n  (send\n    (send nil :features) :[]\n    (lvar :type))\n  (array)) concat "," features [] "," features "]}," Syntax Base implementation":{"type":"method","name":"implementation","children":[],"call":[]}," Syntax Base initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "," warn "]}," Syntax load":{"type":"method","name":"load","children":[],"call":[]}," Syntax new":{"type":"method","name":"new","children":[],"call":[" version_class new "," version_class ","Regexp Syntax Any  new ","(str \"*\") include? ","name to_s "," for "," warn "]}," Syntax NotImplementedError initialize":{"type":"method","name":"initialize","children":[],"call":["syntax class name ","syntax class "]}," Syntax MissingSyntaxSpecError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax UnknownSyntaxNameError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax SyntaxError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V193 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements ","(sym :script_mandaic) + "]}," Syntax Ruby V191 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements ","CharacterSet OpenClose  + + + ","CharacterSet OpenClose  + + ","CharacterSet OpenClose  + ","CharacterSet POSIX StandardNegative  + + ","CharacterSet POSIX StandardNegative  + ","Quantifier Possessive  + ","Group Backreference All  + ","CharacterSet POSIX StandardNegative  + + + ","Group Assertion Lookbehind  + ","Backreference All  + ","Assertion Lookbehind  + ","CharacterType Hex  + ","Escape Unicode  + ","Escape Unicode  + + "]}," Syntax Ruby V18 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements ","CharacterSet OpenClose  + + + ","CharacterSet OpenClose  + + ","CharacterSet OpenClose  + ","Quantifier Greedy  + + + ","Quantifier Greedy  + + ","Quantifier Greedy  + ","Escape Basic  + + + ","Escape Basic  + + ","Escape Basic  + "]}," Syntax Ruby V187 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V186 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements ","CharacterSet OpenClose  + + + ","CharacterSet OpenClose  + + ","CharacterSet OpenClose  + ","Quantifier Greedy  + + + ","Quantifier Greedy  + + ","Quantifier Greedy  + ","Escape Basic  + + + + ","Escape Basic  + + + ","Escape Basic  + + ","Escape Basic  + "]}," Scanner emit":{"type":"method","name":"emit","children":[],"call":["@tokens << ","@block call "," emit_literal "," tokens << "," tokens "," block call "," block "," literal "," char_pos= "," char_pos + ","text length "," char_pos "," collect_tokens "," prev_token= "," literal_run "]}," Scanner emit_literal":{"type":"method","name":"emit_literal","children":[],"call":[" emit ","text force_encoding ","text respond_to? ","(send\n  (ivar :@literal) :map) join ","t [] ","@literal map ","@literal last [] ","@literal last ","@literal first [] ","@literal first "," literal= ","(send\n  (send nil :literal) :map) join "," literal map "," literal "," literal last [] "," literal last "," literal first [] "," literal first "," literal join "," literal_run= "," literal_run join "," literal_run ","(send\n  (ivar :@literal) :map) join  force_encoding ","(send\n  (send nil :literal) :map) join  force_encoding "," literal join  force_encoding "," literal_run join  force_encoding ","(send\n  (ivar :@literal) :map) join  respond_to? ","(send\n  (send nil :literal) :map) join  respond_to? "," literal join  respond_to? "," literal_run join  respond_to? "]}," Scanner append_literal":{"type":"method","name":"append_literal","children":[],"call":["@literal << "," text "," literal << "," literal "," literal= "," copy ","(or-asgn\n  (send\n    (self) :literal_run)\n  (array)) << "," literal_run "]}," Scanner scan":{"type":"method","name":"scan","children":[],"call":[" emit_literal "," raise ","PrematureEndError  new ","(missing set closing bracket)  + ","(missing group closing paranthesis)  + ","ScannerError  new ","data pack "," copy ","ts - ","cs == "," re_scanner_error ","_goto_level <= "," _re_scanner_eof_actions [] "," _re_scanner_eof_actions "," _re_scanner_eof_trans [] - "," _re_scanner_eof_trans [] "," _re_scanner_eof_trans "," _re_scanner_eof_trans [] > ","p == ","p != "," _re_scanner_to_state_actions [] "," _re_scanner_to_state_actions ","p + "," emit "," text ","@spacing_stack last [] ","@spacing_stack last ","@spacing_stack pop ","@spacing_stack last [] == ","@group_depth + ","@spacing_stack length > ","@spacing_stack length ","conditional_stack length == ","conditional_stack length ","conditional_stack pop ","conditional_stack last [] == ","conditional_stack last [] ","conditional_stack last ","@group_depth > ","stack [] ","InvalidSequenceError  new ","te + ","c =~ ","data [] chr ","data [] ","(begin\n  (lvar :te)) - ","p - ","stack []= ","set_depth > "," append_literal "," text first ","1 == "," empty_backref_error "," empty_name_error ","1 empty? "," scan_options ","te - ","text [] ","conditional_stack << ","conditional_stack length > ","text [] chr == ","text [] chr ","(str \"class_\") to_sym ","class_name [] ","class_name [] chr == ","class_name [] chr ","@tokens last [] == ","@tokens last [] ","@tokens last ","set_depth == ","ts + ","UnknownUnicodePropertyError  new ","name [] ","name [] chr == ","name [] chr ","data [] pack gsub downcase ","data [] pack gsub ","data [] pack ","(send\n  (send\n    (lvar :text) :[]\n    (int 1)) :==\n  (str \"P\")) ^ ","text [] == "," _re_scanner_trans_actions [] "," _re_scanner_trans_actions "," _re_scanner_trans_actions [] != "," _re_scanner_trans_targs [] "," _re_scanner_trans_targs "," _re_scanner_indicies [] ","_inds + "," _re_scanner_indicies ","_inds + - "," _re_scanner_trans_keys [] "," _re_scanner_trans_keys ","_wide <= ","_keys + "," _re_scanner_trans_keys [] <= ","_slen > ","data [] ord "," _re_scanner_key_spans [] "," _re_scanner_key_spans "," _re_scanner_index_offsets [] "," _re_scanner_index_offsets ","cs << "," _re_scanner_from_state_actions [] "," _re_scanner_from_state_actions "," re_scanner_start ","data length "," re_scanner_en_main= "," attr_accessor "," re_scanner_en_conditional_expression= "," re_scanner_en_escape_sequence= "," re_scanner_en_set_escape_sequence= "," re_scanner_en_character_set= "," re_scanner_en_unicode_property= "," re_scanner_error= "," re_scanner_first_final= "," re_scanner_start= "," _re_scanner_eof_trans= "," private "," _re_scanner_eof_actions= "," _re_scanner_from_state_actions= "," _re_scanner_to_state_actions= "," _re_scanner_trans_actions= "," _re_scanner_trans_targs= "," _re_scanner_indicies= "," _re_scanner_index_offsets= "," _re_scanner_key_spans= "," _re_scanner_trans_keys= "," block_given? ","input unpack ","input is_a? ","input_object options & != ","input_object options & ","input_object options ","input_object source ","input_object is_a? "," tokens "," literal "," group_depth "," group_depth= "," group_depth + "," free_spacing= "," spacing_stack last [] "," spacing_stack last "," spacing_stack "," spacing_stack pop "," spacing_stack last [] == "," spacing_stack length > "," spacing_stack length "," group_depth > "," group_depth - "," free_spacing "," tokens last [] == "," tokens last [] "," tokens last "," spacing_stack= "," in_group= "," block= "," tokens= "," literal= ","char force_encoding ","char respond_to? ","class_name to_sym ","token to_sym "," class long_prop_map [] "," class long_prop_map "," class "," class short_prop_map [] "," class short_prop_map "," re_scanner_en_char_type= "," set_depth "," in_set? "," in_group? "," set_depth= "," set_depth + "," set_depth - "," conditional_stack pop "," conditional_stack "," conditional_stack last == "," conditional_stack last "," validation_error "," emit_meta_control_sequence "," emit_options ","InvalidGroupOption  new ","text [] =~ "," conditional_stack << "," conditional_stack= "," free_spacing? ","(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - "," char_pos= "," class posix_classes include? "," class posix_classes ","class_name [] == "," literal_run "," prev_token [] == "," prev_token [] "," prev_token ","text [] gsub downcase ","text [] gsub "," literal_run= "," collect_tokens= ","ValidationError  for "," group_depth >= "," emit_lip + ral ","(missing set data [] chr losing bradata [] chr ket)  + ","(missing group data [] chr losing paranthesis)  + ","(missing grou(begin\n  (lvar :te)) -  closing (begin\n  (lvar :te)) - aranthesis)  + ","(missing group -  closing p - aranthesis)  + ","(missing grou scan_options  closing  scan_options aranthesis)  + ","(missing grou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  closing (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - aranthesis)  + ","Sdata [] chr annerError  new ","data padata [] chr k ","data (begin\n  (lvar :te)) - ack ","data p - ack ","data  scan_options ack ","data (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ack ","input unpack  pack "," data [] chr opy "," co(begin\n  (lvar :te)) - y "," cop - y "," co scan_options y "," co(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - y ","stack []  == "," _re_scanner_trans_targs []  == "," re_scanner_start  == ","data [] chr s == "," re_sdata [] chr anner_error "," _re_sdata [] chr anner_eof_adata [] chr tions [] "," _re_scanner_data length _actions [] "," _re_sdata [] chr anner_eof_adata [] chr tions "," _re_scanner_data length _actions "," _re_scanner_eof _re_scanner_eof_trans [] -  [] - "," _re_scanner_eof _re_scanner_indicies []  [] - "," _re_sdata [] chr anner_eof_trans [] - "," _re_scanner_data length _trans [] - "," _re_scanner_eof _re_scanner_eof_trans [] -  [] "," _re_scanner_eof _re_scanner_indicies []  [] "," _re_sdata [] chr anner_eof_trans [] "," _re_scanner_data length _trans [] "," _re_scanner_eof _re_scanner_eof_trans [] -  "," _re_scanner_eof _re_scanner_indicies []  "," _re_sdata [] chr anner_eof_trans "," _re_scanner_data length _trans "," _re_scanner_eof _re_scanner_eof_trans [] -  [] > "," _re_scanner_eof _re_scanner_indicies []  [] > "," _re_sdata [] chr anner_eof_trans [] > "," _re_scanner_data length _trans [] > ","(begin\n  (lvar :te)) -  == ","p -  == "," scan_options  == ","(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  == ","(begin\n  (lvar :te)) -  != ","p -  != "," scan_options  != ","(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  != "," _re_scanner_to_stap + _actions [] "," _re_sdata [] chr anner_to_state_adata [] chr tions [] "," _re_scanner_to_stap + _actions "," _re_sdata [] chr anner_to_state_adata [] chr tions ","(begin\n  (lvar :te)) -  + ","p -  + "," scan_options  + ","(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  + "," data pack  ","  copy  ","  text first  "," p + xt ","@spadata [] chr ing_stadata [] chr k last [] ","@s(begin\n  (lvar :te)) - acing_stack last [] ","@sp - acing_stack last [] ","@s scan_options acing_stack last [] ","@s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack last [] ","@spadata [] chr ing_stadata [] chr k last ","@s(begin\n  (lvar :te)) - acing_stack last ","@sp - acing_stack last ","@s scan_options acing_stack last ","@s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack last ","@spadata [] chr ing_stadata [] chr k pop ","@s(begin\n  (lvar :te)) - acing_stack (begin\n  (lvar :te)) - o(begin\n  (lvar :te)) -  ","@sp - acing_stack p - op -  ","@s scan_options acing_stack  scan_options o scan_options  ","@s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - o(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  ","@spadata [] chr ing_stadata [] chr k last [] == ","@s(begin\n  (lvar :te)) - acing_stack last [] == ","@sp - acing_stack last [] == ","@s scan_options acing_stack last [] == ","@s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack last [] == ","@grou(begin\n  (lvar :te)) - _de(begin\n  (lvar :te)) - th + ","@group - _dep - th + ","@grou scan_options _de scan_options th + ","@grou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th + ","@spadata [] chr ing_stadata [] chr k length > ","@s(begin\n  (lvar :te)) - acing_stack length > ","@sp - acing_stack length > ","@s scan_options acing_stack length > ","@s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack length > ","@spadata [] chr ing_stadata [] chr k length ","@s(begin\n  (lvar :te)) - acing_stack length ","@sp - acing_stack length ","@s scan_options acing_stack length ","@s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack length ","data [] chr onditional_stadata [] chr k length == ","data [] chr onditional_stadata [] chr k length ","data [] chr onditional_stadata [] chr k pop ","conditional_stack (begin\n  (lvar :te)) - o(begin\n  (lvar :te)) -  ","conditional_stack p - op -  ","conditional_stack  scan_options o scan_options  ","conditional_stack (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - o(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  ","data [] chr onditional_stadata [] chr k last [] == ","data [] chr onditional_stadata [] chr k last [] ","data [] chr onditional_stadata [] chr k last ","@grou(begin\n  (lvar :te)) - _de(begin\n  (lvar :te)) - th > ","@group - _dep - th > ","@grou scan_options _de scan_options th > ","@grou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th > ","stadata [] chr k [] ","InvalidSequendata [] chr eError  new ","p +  + ","data [] chr  =~ ","data [] data [] chr hr ","input unpack  [] chr ","input unpack  [] ","(begin\n  (lvar :p + )) - ","(begin\n  (lvar :te)) -  - ","p -  - "," scan_options  - ","(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  - ","stadata [] chr k []= ","set_de(begin\n  (lvar :te)) - th > ","set_dep - th > ","set_de scan_options th > ","set_de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th > "," append_lip + ral "," a(begin\n  (lvar :te)) - (begin\n  (lvar :te)) - end_literal "," ap - p - end_literal "," a scan_options  scan_options end_literal "," a(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - end_literal "," data pack  first ","  copy  first ","  text first  first "," p + xt first "," empty_badata [] chr kref_error "," em(begin\n  (lvar :te)) - ty_backref_error "," emp - ty_backref_error "," em scan_options ty_backref_error "," em(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ty_backref_error "," em(begin\n  (lvar :te)) - ty_name_error "," emp - ty_name_error "," em scan_options ty_name_error "," em(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ty_name_error "," empty_name [] _error "," empty_data [] pack gsub downcase _error "," empty_text [] gsub downcase _error ","1 em(begin\n  (lvar :te)) - ty? ","1 emp - ty? ","1 em scan_options ty? ","1 em(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ty? "," sdata [] chr an_options "," scan_o(begin\n  (lvar :te)) - tions "," scan_op - tions "," scan_o scan_options tions "," scan_o(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - tions ","p +  - ","data pack  [] "," copy  [] "," text first  [] ","p + xt [] ","data [] chr onditional_stadata [] chr k << ","data [] chr onditional_stadata [] chr k length > ","data pack  [] chr == "," copy  [] chr == "," text first  [] chr == ","p + xt [] chr == ","text [] data [] chr hr == ","data pack  [] chr "," copy  [] chr "," text first  [] chr ","p + xt [] chr ","text [] data [] chr hr ","(str \"data [] chr lass_\") to_sym ","data [] chr lass_name [] ","text []  [] ","class_name []  [] ","class_data [] pack gsub downcase  [] ","class_text [] gsub downcase  [] ","data [] chr lass_name [] data [] chr hr == ","text []  [] chr == ","class_name []  [] chr == ","class_data [] pack gsub downcase  [] chr == ","class_text [] gsub downcase  [] chr == ","data [] chr lass_name [] data [] chr hr ","text []  [] chr ","class_name []  [] chr ","class_data [] pack gsub downcase  [] chr ","class_text [] gsub downcase  [] chr ","set_de(begin\n  (lvar :te)) - th == ","set_dep - th == ","set_de scan_options th == ","set_de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th == ","UnknownUnidata [] chr odePropertyError  new ","UnknownUnicodePro(begin\n  (lvar :te)) - ertyError  new ","UnknownUnicodeProp - ertyError  new ","UnknownUnicodePro scan_options ertyError  new ","UnknownUnicodePro(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ertyError  new ","name []  [] ","data [] pack gsub downcase  [] ","text [] gsub downcase  [] ","name [] data [] chr hr == ","name []  [] chr == ","data [] pack gsub downcase  [] chr == ","text [] gsub downcase  [] chr == ","name [] data [] chr hr ","name []  [] chr ","data [] pack gsub downcase  [] chr ","text [] gsub downcase  [] chr ","data [] padata [] chr k gsub downdata [] chr ase ","data [] (begin\n  (lvar :te)) - ack gsub downcase ","data [] p - ack gsub downcase ","data []  scan_options ack gsub downcase ","data [] (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ack gsub downcase ","input unpack  [] pack gsub downcase ","data [] padata [] chr k gsub ","data [] (begin\n  (lvar :te)) - ack gsub ","data [] p - ack gsub ","data []  scan_options ack gsub ","data [] (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ack gsub ","input unpack  [] pack gsub ","data [] padata [] chr k ","data [] (begin\n  (lvar :te)) - ack ","data [] p - ack ","data []  scan_options ack ","data [] (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ack ","input unpack  [] pack ","(send\n  (send\n    (lvar :data pack ) :[]\n    (int 1)) :==\n  (str \"P\")) ^ ","(send\n  (send\n    (lvar : copy ) :[]\n    (int 1)) :==\n  (str \"P\")) ^ ","(send\n  (send\n    (lvar : text first ) :[]\n    (int 1)) :==\n  (str \"P\")) ^ ","(send\n  (send\n    (lvar :p + xt) :[]\n    (int 1)) :==\n  (str \"P\")) ^ ","data pack  [] == "," copy  [] == "," text first  [] == ","p + xt [] == "," _re_scanner _re_scanner_eof_trans [] - _actions [] "," _re_scanner _re_scanner_indicies [] _actions [] "," _re_sdata [] chr anner_trans_adata [] chr tions [] "," _re_scanner _re_scanner_eof_trans [] - _actions "," _re_scanner _re_scanner_indicies [] _actions "," _re_sdata [] chr anner_trans_adata [] chr tions "," _re_scanner _re_scanner_eof_trans [] - _actions [] != "," _re_scanner _re_scanner_indicies [] _actions [] != "," _re_sdata [] chr anner_trans_adata [] chr tions [] != "," _re_scanner _re_scanner_eof_trans [] - _targs [] "," _re_scanner _re_scanner_indicies [] _targs [] "," _re_sdata [] chr anner_trans_targs [] "," _re_scanner _re_scanner_eof_trans [] - _targs "," _re_scanner _re_scanner_indicies [] _targs "," _re_sdata [] chr anner_trans_targs "," _re_sdata [] chr anner_indidata [] chr ies [] "," _re_scanner_index_offsets []  + "," _re_sdata [] chr anner_indidata [] chr ies "," _re_scanner_index_offsets []  + - "," _re_scanner _re_scanner_eof_trans [] - _keys [] "," _re_scanner _re_scanner_indicies [] _keys [] "," _re_sdata [] chr anner_trans_keys [] "," _re_scanner_transcs <<  [] "," _re_scanner _re_scanner_eof_trans [] - _keys "," _re_scanner _re_scanner_indicies [] _keys "," _re_sdata [] chr anner_trans_keys "," _re_scanner_transcs <<  ","data [] ord  <= ","cs <<  + "," _re_scanner _re_scanner_eof_trans [] - _keys [] <= "," _re_scanner _re_scanner_indicies [] _keys [] <= "," _re_sdata [] chr anner_trans_keys [] <= "," _re_scanner_transcs <<  [] <= "," _re_scanner_key_spans []  > ","input unpack  [] ord "," _re_sdata [] chr anner_key_spans [] "," _re_scanner_key_s(begin\n  (lvar :te)) - ans [] "," _re_scanner_key_sp - ans [] "," _re_scanner_key_s scan_options ans [] "," _re_scanner_key_s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ans [] "," _re_sdata [] chr anner_key_spans "," _re_scanner_key_s(begin\n  (lvar :te)) - ans "," _re_scanner_key_sp - ans "," _re_scanner_key_s scan_options ans "," _re_scanner_key_s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ans "," _re_sdata [] chr anner_index_offsets [] "," _re_sdata [] chr anner_index_offsets ","stack []  << "," _re_scanner_trans_targs []  << "," re_scanner_start  << ","data [] chr s << "," _re_scanner_from_stap + _actions [] "," _re_sdata [] chr anner_from_state_adata [] chr tions [] "," _re_scanner_from_stap + _actions "," _re_sdata [] chr anner_from_state_adata [] chr tions "," re_sdata [] chr anner_start ","input unpack  length "," re_sdata [] chr anner_en_main= "," attr_adata [] chr data [] chr essor "," re_sdata [] chr anner_en_data [] chr onditional_expression= "," re_scanner_en_conditional_ex(begin\n  (lvar :te)) - ression= "," re_scanner_en_conditional_exp - ression= "," re_scanner_en_conditional_ex scan_options ression= "," re_scanner_en_conditional_ex(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ression= "," re_sdata [] chr anner_en_esdata [] chr ape_sequendata [] chr e= "," re_scanner_en_esca(begin\n  (lvar :te)) - e_sequence= "," re_scanner_en_escap - e_sequence= "," re_scanner_en_esca scan_options e_sequence= "," re_scanner_en_esca(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - e_sequence= "," re_sdata [] chr anner_en_set_esdata [] chr ape_sequendata [] chr e= "," re_scanner_en_set_esca(begin\n  (lvar :te)) - e_sequence= "," re_scanner_en_set_escap - e_sequence= "," re_scanner_en_set_esca scan_options e_sequence= "," re_scanner_en_set_esca(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - e_sequence= "," re_scanner_en_characp + r_set= "," re_sdata [] chr anner_en_data [] chr haradata [] chr ter_set= "," re_sdata [] chr anner_en_unidata [] chr ode_property= "," re_scanner_en_unicode_(begin\n  (lvar :te)) - ro(begin\n  (lvar :te)) - erty= "," re_scanner_en_unicode_p - rop - erty= "," re_scanner_en_unicode_ scan_options ro scan_options erty= "," re_scanner_en_unicode_(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ro(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - erty= "," re_sdata [] chr anner_error= "," re_sdata [] chr anner_first_final= "," re_sdata [] chr anner_start= "," _re_scanner_eof _re_scanner_eof_trans [] - = "," _re_scanner_eof _re_scanner_indicies [] = "," _re_sdata [] chr anner_eof_trans= "," _re_scanner_data length _trans= "," privap +  "," (begin\n  (lvar :te)) - rivate "," p - rivate ","  scan_options rivate "," (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - rivate "," _re_sdata [] chr anner_eof_adata [] chr tions= "," _re_scanner_data length _actions= "," _re_scanner_from_stap + _actions= "," _re_sdata [] chr anner_from_state_adata [] chr tions= "," _re_scanner_to_stap + _actions= "," _re_sdata [] chr anner_to_state_adata [] chr tions= "," _re_scanner _re_scanner_eof_trans [] - _actions= "," _re_scanner _re_scanner_indicies [] _actions= "," _re_sdata [] chr anner_trans_adata [] chr tions= "," _re_scanner _re_scanner_eof_trans [] - _targs= "," _re_scanner _re_scanner_indicies [] _targs= "," _re_sdata [] chr anner_trans_targs= "," _re_sdata [] chr anner_indidata [] chr ies= "," _re_sdata [] chr anner_index_offsets= "," _re_sdata [] chr anner_key_spans= "," _re_scanner_key_s(begin\n  (lvar :te)) - ans= "," _re_scanner_key_sp - ans= "," _re_scanner_key_s scan_options ans= "," _re_scanner_key_s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ans= "," _re_scanner _re_scanner_eof_trans [] - _keys= "," _re_scanner _re_scanner_indicies [] _keys= "," _re_sdata [] chr anner_trans_keys= "," _re_scanner_transcs << = "," blodata [] chr k_given? ","input unpadata [] chr k ","in(begin\n  (lvar :te)) - ut un(begin\n  (lvar :te)) - ack ","inp - ut unp - ack ","in scan_options ut un scan_options ack ","in(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ut un(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ack ","input_object source  unpack ","in(begin\n  (lvar :te)) - ut is_a? ","inp - ut is_a? ","in scan_options ut is_a? ","in(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ut is_a? ","input_object source  is_a? ","input_objedata [] chr t options & != ","in(begin\n  (lvar :te)) - ut_object o(begin\n  (lvar :te)) - tions & != ","inp - ut_object op - tions & != ","in scan_options ut_object o scan_options tions & != ","in(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ut_object o(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - tions & != ","input_object source _object options & != ","input_objedata [] chr t options & ","in(begin\n  (lvar :te)) - ut_object o(begin\n  (lvar :te)) - tions & ","inp - ut_object op - tions & ","in scan_options ut_object o scan_options tions & ","in(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ut_object o(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - tions & ","input_object source _object options & ","input_objedata [] chr t options ","in(begin\n  (lvar :te)) - ut_object o(begin\n  (lvar :te)) - tions ","inp - ut_object op - tions ","in scan_options ut_object o scan_options tions ","in(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ut_object o(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - tions ","input_object source _object options ","input_objedata [] chr t sourdata [] chr e ","in(begin\n  (lvar :te)) - ut_object source ","inp - ut_object source ","in scan_options ut_object source ","in(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ut_object source ","input_object source _object source ","input_objedata [] chr t is_a? ","in(begin\n  (lvar :te)) - ut_object is_a? ","inp - ut_object is_a? ","in scan_options ut_object is_a? ","in(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ut_object is_a? ","input_object source _object is_a? "," lip + ral "," grou(begin\n  (lvar :te)) - _de(begin\n  (lvar :te)) - th "," group - _dep - th "," grou scan_options _de scan_options th "," grou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th "," grou(begin\n  (lvar :te)) - _de(begin\n  (lvar :te)) - th= "," group - _dep - th= "," grou scan_options _de scan_options th= "," grou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th= "," grou(begin\n  (lvar :te)) - _de(begin\n  (lvar :te)) - th + "," group - _dep - th + "," grou scan_options _de scan_options th + "," grou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th + "," free_spadata [] chr ing= "," free_s(begin\n  (lvar :te)) - acing= "," free_sp - acing= "," free_s scan_options acing= "," free_s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing= "," spadata [] chr ing_stadata [] chr k last [] "," s(begin\n  (lvar :te)) - acing_stack last [] "," sp - acing_stack last [] "," s scan_options acing_stack last [] "," s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack last [] "," spadata [] chr ing_stadata [] chr k last "," s(begin\n  (lvar :te)) - acing_stack last "," sp - acing_stack last "," s scan_options acing_stack last "," s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack last "," spadata [] chr ing_stadata [] chr k "," s(begin\n  (lvar :te)) - acing_stack "," sp - acing_stack "," s scan_options acing_stack "," s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack "," spadata [] chr ing_stadata [] chr k pop "," s(begin\n  (lvar :te)) - acing_stack (begin\n  (lvar :te)) - o(begin\n  (lvar :te)) -  "," sp - acing_stack p - op -  "," s scan_options acing_stack  scan_options o scan_options  "," s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - o(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  "," spadata [] chr ing_stadata [] chr k last [] == "," s(begin\n  (lvar :te)) - acing_stack last [] == "," sp - acing_stack last [] == "," s scan_options acing_stack last [] == "," s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack last [] == "," spadata [] chr ing_stadata [] chr k length > "," s(begin\n  (lvar :te)) - acing_stack length > "," sp - acing_stack length > "," s scan_options acing_stack length > "," s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack length > "," spadata [] chr ing_stadata [] chr k length "," s(begin\n  (lvar :te)) - acing_stack length "," sp - acing_stack length "," s scan_options acing_stack length "," s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack length "," grou(begin\n  (lvar :te)) - _de(begin\n  (lvar :te)) - th > "," group - _dep - th > "," grou scan_options _de scan_options th > "," grou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th > "," grou(begin\n  (lvar :te)) - _de(begin\n  (lvar :te)) - th - "," group - _dep - th - "," grou scan_options _de scan_options th - "," grou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th - "," free_spadata [] chr ing "," free_s(begin\n  (lvar :te)) - acing "," free_sp - acing "," free_s scan_options acing "," free_s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing "," spadata [] chr ing_stadata [] chr k= "," s(begin\n  (lvar :te)) - acing_stack= "," sp - acing_stack= "," s scan_options acing_stack= "," s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing_stack= "," in_grou(begin\n  (lvar :te)) - = "," in_group - = "," in_grou scan_options = "," in_grou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - = "," blodata [] chr k= "," lip + ral= ","data [] chr har fordata [] chr e_endata [] chr oding ","data [] chr har respond_to? ","char res(begin\n  (lvar :te)) - ond_to? ","char resp - ond_to? ","char res scan_options ond_to? ","char res(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ond_to? ","data [] chr lass_name to_sym ","text []  to_sym ","class_name []  to_sym ","class_data [] pack gsub downcase  to_sym ","class_text [] gsub downcase  to_sym "," data [] chr lass long_prop_map [] "," class long_(begin\n  (lvar :te)) - ro(begin\n  (lvar :te)) - _ma(begin\n  (lvar :te)) -  [] "," class long_p - rop - _map -  [] "," class long_ scan_options ro scan_options _ma scan_options  [] "," class long_(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ro(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _ma(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  [] "," data [] chr lass long_prop_map "," class long_(begin\n  (lvar :te)) - ro(begin\n  (lvar :te)) - _ma(begin\n  (lvar :te)) -  "," class long_p - rop - _map -  "," class long_ scan_options ro scan_options _ma scan_options  "," class long_(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ro(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _ma(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  "," data [] chr lass "," data [] chr lass short_prop_map [] "," class short_(begin\n  (lvar :te)) - ro(begin\n  (lvar :te)) - _ma(begin\n  (lvar :te)) -  [] "," class short_p - rop - _map -  [] "," class short_ scan_options ro scan_options _ma scan_options  [] "," class short_(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ro(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _ma(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  [] "," data [] chr lass short_prop_map "," class short_(begin\n  (lvar :te)) - ro(begin\n  (lvar :te)) - _ma(begin\n  (lvar :te)) -  "," class short_p - rop - _map -  "," class short_ scan_options ro scan_options _ma scan_options  "," class short_(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ro(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _ma(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  "," re_sdata [] chr anner_en_data [] chr har_type= "," re_scanner_en_char_ty(begin\n  (lvar :te)) - e= "," re_scanner_en_char_typ - e= "," re_scanner_en_char_ty scan_options e= "," re_scanner_en_char_ty(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - e= "," set_de(begin\n  (lvar :te)) - th "," set_dep - th "," set_de scan_options th "," set_de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th "," in_grou(begin\n  (lvar :te)) - ? "," in_group - ? "," in_grou scan_options ? "," in_grou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - ? "," set_de(begin\n  (lvar :te)) - th= "," set_dep - th= "," set_de scan_options th= "," set_de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th= "," set_de(begin\n  (lvar :te)) - th + "," set_dep - th + "," set_de scan_options th + "," set_de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th + "," set_de(begin\n  (lvar :te)) - th - "," set_dep - th - "," set_de scan_options th - "," set_de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th - "," data [] chr onditional_stadata [] chr k pop "," conditional_stack (begin\n  (lvar :te)) - o(begin\n  (lvar :te)) -  "," conditional_stack p - op -  "," conditional_stack  scan_options o scan_options  "," conditional_stack (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - o(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) -  "," data [] chr onditional_stadata [] chr k "," data [] chr onditional_stadata [] chr k last == "," data [] chr onditional_stadata [] chr k last "," emit_meta_data [] chr ontrol_sequendata [] chr e "," emit_o(begin\n  (lvar :te)) - tions "," emit_op - tions "," emit_o scan_options tions "," emit_o(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - tions ","InvalidGrou(begin\n  (lvar :te)) - O(begin\n  (lvar :te)) - tion  new ","InvalidGroup - Op - tion  new ","InvalidGrou scan_options O scan_options tion  new ","InvalidGrou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - O(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - tion  new ","data pack  [] =~ "," copy  [] =~ "," text first  [] =~ ","p + xt [] =~ "," data [] chr onditional_stadata [] chr k << "," data [] chr onditional_stadata [] chr k= "," free_spadata [] chr ing? "," free_s(begin\n  (lvar :te)) - acing? "," free_sp - acing? "," free_s scan_options acing? "," free_s(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - acing? "," data [] chr har_pos= "," char_(begin\n  (lvar :te)) - os= "," char_p - os= "," char_ scan_options os= "," char_(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - os= "," data [] chr lass posix_data [] chr lasses indata [] chr lude? "," class (begin\n  (lvar :te)) - osix_classes include? "," class p - osix_classes include? "," class  scan_options osix_classes include? "," class (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - osix_classes include? "," data [] chr lass posix_data [] chr lasses "," class (begin\n  (lvar :te)) - osix_classes "," class p - osix_classes "," class  scan_options osix_classes "," class (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - osix_classes ","data [] chr lass_name [] == ","text []  [] == ","class_name []  [] == ","class_data [] pack gsub downcase  [] == ","class_text [] gsub downcase  [] == "," lip + ral_run "," (begin\n  (lvar :te)) - rev_token [] == "," p - rev_token [] == ","  scan_options rev_token [] == "," (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - rev_token [] == "," (begin\n  (lvar :te)) - rev_token [] "," p - rev_token [] ","  scan_options rev_token [] "," (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - rev_token [] "," (begin\n  (lvar :te)) - rev_token "," p - rev_token ","  scan_options rev_token "," (begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - rev_token ","data pack  [] gsub downcase "," copy  [] gsub downcase "," text first  [] gsub downcase ","p + xt [] gsub downcase ","text [] gsub downdata [] chr ase ","data pack  [] gsub "," copy  [] gsub "," text first  [] gsub ","p + xt [] gsub "," lip + ral_run= "," data [] chr olledata [] chr t_tokens= "," grou(begin\n  (lvar :te)) - _de(begin\n  (lvar :te)) - th >= "," group - _dep - th >= "," grou scan_options _de scan_options th >= "," grou(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - _de(begin\n  (send\n    (lvar :ts) :+\n    (int 1))) - th >= "]}," Scanner UnknownUnicodePropertyError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Scanner PrematureEndError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Scanner ScannerError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Parser close_set":{"type":"method","name":"close_set","children":[],"call":["@set close "," current_set close "," current_set "," decrease_nesting "]}," Parser append_set":{"type":"method","name":"append_set","children":[],"call":["@set << ","token text "," current_set << "," current_set "]}," Parser negate_set":{"type":"method","name":"negate_set","children":[],"call":["@set negate "," current_set negate "," current_set "," node negate "," node "]}," Parser open_set":{"type":"method","name":"open_set","children":[],"call":["@node << ","CharacterSet  new "," active_opts ","@set << ","CharacterSubSet  new ","token type == ","token type ","token token= "," node << "," current_set "," node "," current_set= "," current_set << "," nest ","CharacterSet  new  << "]}," Parser close_group":{"type":"method","name":"close_group","children":[],"call":["@node last ","@node last is_a? ","@nesting last ","@options_stack pop ","@nesting pop "," node= "," node last "," node "," node last is_a? "," nesting last "," nesting "," switching_options= "," options_stack pop "," options_stack "," switching_options "," nesting pop "," decrease_nesting ","@node last  last ","@nesting last  last ","@node last  last is_a? ","@nesting last  last is_a? "]}," Parser open_group":{"type":"method","name":"open_group","children":[],"call":[" nest ","@options_stack << "," active_opts "," raise ","UnknownTokenError  new ","Assertion NegativeLookbehind  new ","Assertion Lookbehind  new ","Assertion NegativeLookahead  new ","Assertion Lookahead  new ","Group Absence  new ","Group Capture  new ","Group Named  new ","Group Atomic  new ","Group Passive  new ","token token "," options_stack << "," options_stack "," count_captured_group ","exp number_at_level= "," captured_group_count_at_level + "," captured_group_count_at_level ","exp number= "," total_captured_group_count + "," total_captured_group_count ","exp capturing? ","group number_at_level= ","group number= ","group capturing? ","group_class new "," count_captured_group_class new  ","Assertion NegativeLookbehind  new  number_at_level= ","Assertion Lookbehind  new  number_at_level= ","Assertion NegativeLookahead  new  number_at_level= ","Assertion Lookahead  new  number_at_level= ","Group Absence  new  number_at_level= ","Group Capture  new  number_at_level= ","Group Named  new  number_at_level= ","Group Atomic  new  number_at_level= ","Group Passive  new  number_at_level= "," captured_group_class new _count_at_level + "," captured_group_class new _count_at_level ","Assertion NegativeLookbehind  new  number= ","Assertion Lookbehind  new  number= ","Assertion NegativeLookahead  new  number= ","Assertion Lookahead  new  number= ","Group Absence  new  number= ","Group Capture  new  number= ","Group Named  new  number= ","Group Atomic  new  number= ","Group Passive  new  number= "," total_captured_group_class new _count + "," total_captured_group_class new _count ","Assertion NegativeLookbehind  new  capturing? ","Assertion Lookbehind  new  capturing? ","Assertion NegativeLookahead  new  capturing? ","Assertion Lookahead  new  capturing? ","Group Absence  new  capturing? ","Group Capture  new  capturing? ","Group Named  new  capturing? ","Group Atomic  new  capturing? ","Group Passive  new  capturing? ","group_class new  number_at_level= ","group_class new  number= ","group_class new  capturing? ","group_class new _class new "]}," Parser options":{"type":"method","name":"options","children":[],"call":[]}," Parser group":{"type":"method","name":"group","children":[],"call":[" open_group ","@node << ","Group Comment  new "," active_opts "," close_group "," options_group ","token token "," node << "," node "]}," Parser interval":{"type":"method","name":"interval","children":[],"call":["target_node quantify ","max to_i ","min to_i ","range [] ","range [] empty? ","i strip ","range_text gsub split each ","range_text gsub split ","range_text gsub ","text [] ","text [] chr ","text length - ","text length ","text [] chr =~ ","token text ","range []  to_i ","range_text gsub split  [] ","range_text gsub split  [] empty? ","text []  gsub split each ","range_token text  gsub split each ","range_text gsub split _text gsub split each ","text []  gsub split ","range_token text  gsub split ","range_text gsub split _text gsub split ","text []  gsub ","range_token text  gsub ","range_text gsub split _text gsub ","token text  [] ","token text  [] chr ","token text  length - ","token text  length ","token text  [] chr =~ ","token token text  "]}," Parser quantifier":{"type":"method","name":"quantifier","children":[],"call":[" raise ","UnknownTokenError  new "," interval ","target_node quantify ","token text ","token token ","ArgumentError  new ","(str \"No valid target found for '\") + ","@node expressions [] ","@node expressions ","target_node is_a? "," node expressions [] "," node expressions "," node "," node expressions []= "," increase_level ","new_group << ","new_group implicit= ","Group Passive  new "," active_opts ","Regexp Token  new ","target_node conditional_level ","target_node set_level ","target_node level ","target_node ts ","target_node quantified? "," node expressions index ","exp is_a? ! ","exp is_a? "," node expressions reverse find "," node expressions reverse ","token token =~ "," increase_group_level ","Group Passive  construct "," node extract_quantifier_target ","@node expressions []  quantify "," node expressions []  quantify "," node extract_quantifier_target  quantify ","@node expressions []  is_a? "," node expressions []  is_a? "," node extract_quantifier_target  is_a? ","Group Passive  new  << ","Group Passive  construct  << ","Group Passive  new  implicit= ","Group Passive  construct  implicit= ","@node expressions []  conditional_level "," node expressions []  conditional_level "," node extract_quantifier_target  conditional_level ","@node expressions []  set_level "," node expressions []  set_level "," node extract_quantifier_target  set_level ","@node expressions []  level "," node expressions []  level "," node extract_quantifier_target  level ","@node expressions []  ts "," node expressions []  ts "," node extract_quantifier_target  ts ","@node expressions []  quantified? "," node expressions []  quantified? "," node extract_quantifier_target  quantified? "]}," Parser escape":{"type":"method","name":"escape","children":[],"call":["@node << ","EscapeSequence Literal  new "," active_opts ","EscapeSequence Meta  new ","EscapeSequence MetaControl  new ","token text =~ ","token text ","EscapeSequence Control  new ","EscapeSequence VerticalTab  new ","EscapeSequence Tab  new ","EscapeSequence Space  new ","EscapeSequence Return  new ","EscapeSequence Newline  new ","EscapeSequence FormFeed  new ","EscapeSequence Bell  new ","EscapeSequence AsciiEscape  new ","EscapeSequence Backspace  new ","token token "," node << "," node ","EscapeSequence CodepointList  new ","EscapeSequence Codepoint  new ","EscapeSequence Octal  new ","EscapeSequence Hex  new "]}," Parser anchor":{"type":"method","name":"anchor","children":[],"call":[" raise ","UnknownTokenError  new ","@node << ","Anchor MatchStart  new "," active_opts ","Anchor NonWordBoundary  new ","Anchor WordBoundary  new ","Anchor EOSobEOL  new ","Anchor EOS  new ","Anchor BOS  new ","Anchor EndOfLine  new ","Anchor BeginningOfLine  new ","token token "," node << "," node "]}," Parser property":{"type":"method","name":"property","children":[],"call":[" raise ","UnknownTokenError  new ","@node << ","Block  new "," active_opts ","Script  new ","Emoji  new ","Derived  new ","Age  new ","Codepoint Unassigned  new ","Codepoint PrivateUse  new ","Codepoint Surrogate  new ","Codepoint Format  new ","Codepoint Control  new ","Codepoint Any  new ","Symbol Other  new ","Symbol Modifier  new ","Symbol Currency  new ","Symbol Math  new ","Symbol Any  new ","Separator Paragraph  new ","Separator Line  new ","Separator Space  new ","Separator Any  new ","Punctuation Other  new ","Punctuation Final  new ","Punctuation Initial  new ","Punctuation Close  new ","Punctuation Open  new ","Punctuation Dash  new ","Punctuation Connector  new ","Punctuation Any  new ","Number Other  new ","Number Letter  new ","Number Decimal  new ","Number Any  new ","Mark Enclosing  new ","Mark Spacing  new ","Mark Nonspacing  new ","Mark Any  new ","Letter Other  new ","Letter Modifier  new ","Letter Titlecase  new ","Letter Lowercase  new ","Letter Uppercase  new ","Letter Any  new ","Assigned  new ","Any  new ","Newline  new ","XPosixPunct  new ","Xdigit  new ","Word  new ","Upper  new ","Space  new ","Punct  new ","Print  new ","Lower  new ","Graph  new ","Digit  new ","Cntrl  new ","Blank  new ","Ascii  new ","Alpha  new ","Alnum  new ","token token "," node << "," node ","Mark Combining  new ","Letter Cased  new ","UP Block  new ","UP Script  new ","UP Emoji  new ","UP Derived  new ","UP Age  new ","UP Codepoint Unassigned  new ","UP Codepoint PrivateUse  new ","UP Codepoint Surrogate  new ","UP Codepoint Format  new ","UP Codepoint Control  new ","UP Codepoint Any  new ","UP Symbol Other  new ","UP Symbol Modifier  new ","UP Symbol Currency  new ","UP Symbol Math  new ","UP Symbol Any  new ","UP Separator Paragraph  new ","UP Separator Line  new ","UP Separator Space  new ","UP Separator Any  new ","UP Punctuation Other  new ","UP Punctuation Final  new ","UP Punctuation Initial  new ","UP Punctuation Close  new ","UP Punctuation Open  new ","UP Punctuation Dash  new ","UP Punctuation Connector  new ","UP Punctuation Any  new ","UP Number Other  new ","UP Number Letter  new ","UP Number Decimal  new ","UP Number Any  new ","UP Mark Enclosing  new ","UP Mark Spacing  new ","UP Mark Nonspacing  new ","UP Mark Combining  new ","UP Mark Any  new ","UP Letter Other  new ","UP Letter Modifier  new ","UP Letter Titlecase  new ","UP Letter Lowercase  new ","UP Letter Uppercase  new ","UP Letter Cased  new ","UP Letter Any  new ","UP Assigned  new ","UP Any  new ","UP Newline  new ","UP XPosixPunct  new ","UP Xdigit  new ","UP Word  new ","UP Upper  new ","UP Space  new ","UP Punct  new ","UP Print  new ","UP Lower  new ","UP Graph  new ","UP Digit  new ","UP Cntrl  new ","UP Blank  new ","UP Ascii  new ","UP Alpha  new ","UP Alnum  new "]}," Parser type":{"type":"method","name":"type","children":[],"call":[" raise ","UnknownTokenError  new ","@node << ","CharacterType ExtendedGrapheme  new "," active_opts ","CharacterType Linebreak  new ","CharacterType NonWord  new ","CharacterType Word  new ","CharacterType NonSpace  new ","CharacterType Space  new ","CharacterType NonHex  new ","CharacterType Hex  new ","CharacterType NonDigit  new ","CharacterType Digit  new ","token token "," node << "," node "]}," Parser backref":{"type":"method","name":"backref","children":[],"call":[" raise ","UnknownTokenError  new ","@node << ","Backreference NumberCallRelative  new "," active_opts ","Backreference NumberCall  new ","Backreference NumberNestLevel  new ","Backreference NumberRelative  new ","Backreference Number  new ","Backreference NameCall  new ","Backreference NameNestLevel  new ","Backreference Name  new ","token token "," node << "," node ","Backreference NumberRecursionLevel  new ","Backreference NameRecursionLevel  new "," assign_effective_number ","Backreference NumberCallRelative  new tap ","Backreference NumberRelative  new tap ","exp effective_number= ","exp number ","exp text =~ ","exp text ","Backreference NumberRecursionLevel  new tap "]}," Parser meta":{"type":"method","name":"meta","children":[],"call":[" raise ","UnknownTokenError  new ","@node alternative ","@node << ","alt alternative ","seq insert ","@node expressions pop ","@node expressions ","@node expressions last ","Alternative  new ","alt conditional_level ","alt set_level ","alt level ","Alternation  new "," active_opts ","@node last ","@node last is_a? ","@node token == ","@node token ","CharacterType Any  new ","token token "," node alternative "," node "," node= "," node << "," node expressions pop "," node expressions "," node expressions count times "," node expressions count "," node last "," node last is_a? "," node token == "," node token "," sequence_operation ","@node Alternation  new ernative ","@node last  alternative ","@node last  << ","Alternation  new  Alternation  new ernative ","Alternative  new  insert ","@node last  expressions pop ","@node last  expressions ","@node last  expressions last ","Alternation  new  conditional_level ","Alternation  new  set_level ","Alternation  new  level ","@node last  last ","@node last  last is_a? ","@node last  token == ","@node last  token "," node Alternation  new ernative "," Alternative  new uence_operation "]}," Parser set":{"type":"method","name":"set","children":[],"call":[" raise ","UnknownTokenError  new "," append_set "," negate_set "," close_set "," open_set ","token token "," node << ","Literal  new "," active_opts "," node "," intersection "," range "]}," Parser parse_token":{"type":"method","name":"parse_token","children":[],"call":[" raise ","UnknownTokenTypeError  new ","token type "," free_space ","@node << ","Literal  new "," active_opts "," property "," keep "," conditional "," backref "," type "," set "," group "," escape "," anchor "," quantifier "," meta "," node << "," node "," posixclass "," close_completed_character_set_range "," literal "]}," Parser nest":{"type":"method","name":"nest","children":[],"call":["@node << ","@nesting push "," node= "," node << "," node "," nesting push "," nesting "," update_transplanted_subtree "]}," Parser parse":{"type":"method","name":"parse","children":[],"call":["block call "," block_given? "," parse_token ","Regexp Lexer  scan ","@root options ","Root  new "," options_from_input "," conditional_nesting= "," switching_options= "," options_stack= ","root options "," nesting= "," node= "," root= "," captured_group_counts= ","Hash  new ","Root  build "," assign_referenced_expressions "," extract_options ","root nesting_level= ","Root  construct ","@Root  new  options ","@Root  build  options ","@Root  construct  options ","Root  new  options ","Root  build  options ","Root  construct  options "," Root  new = "," Root  build = "," Root  construct = ","Root  new  nesting_level= ","Root  build  nesting_level= ","Root  construct  nesting_level= "]}," Parser UnknownTokenError initialize":{"type":"method","name":"initialize","children":[],"call":["token token "]}," Parser UnknownTokenTypeError initialize":{"type":"method","name":"initialize","children":[],"call":["token inspect "]}," Parser ParserError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Lexer merge_literal":{"type":"method","name":"merge_literal","children":[],"call":["Regexp Token  new ","current te ","last ts ","last text + ","current text ","last text ","@tokens pop "," conditional_nesting "," set_nesting "," nesting "," tokens pop "," tokens ","@tokens pop  ts "," tokens pop  ts ","@tokens pop  text + "," tokens pop  text + ","@tokens pop  text "," tokens pop  text "]}," Lexer break_literal":{"type":"method","name":"break_literal","children":[],"call":["@tokens << ","Regexp Token  new ","token te ","token ts + ","token ts ","token te - ","@tokens pop ","last length ","lead length ","last bytesize ","lead bytesize ","RUBY_VERSION  >= ","text [] ","text sub ","text scan length > ","text scan length ","text scan ","token text "," tokens << "," conditional_nesting "," set_nesting "," nesting "," tokens "," tokens pop ","lead empty? ","token text partition ","token_2 previous= ","token_1 next= ","token_1 previous= "," preprev_token ","text sub  length ","text sub  bytesize ","token text  [] ","token text  sub ","token text  scan length > ","token text  scan length ","token text  scan ","token token text  ","text sub  empty? ","token token text  partition ","Regexp Token  new  previous= ","Regexp Token  new  next= "]}," Lexer descend":{"type":"method","name":"descend","children":[],"call":["token == ","type == ","OPENING_TOKENS  include? "," conditional_nesting= "," conditional_nesting + "," conditional_nesting "," set_nesting= "," set_nesting + "," set_nesting "," nesting= "," nesting + "," nesting "," raise "]}," Lexer ascend":{"type":"method","name":"ascend","children":[],"call":["token == ","type == ","CLOSING_TOKENS  include? "," conditional_nesting= "," conditional_nesting - "," conditional_nesting "," set_nesting= "," set_nesting - "," set_nesting "," nesting= "," nesting - "," nesting "," raise "]}," Lexer scan":{"type":"method","name":"scan","children":[],"call":[]}," Expression Group Comment to_s":{"type":"method","name":"to_s","children":[],"call":["@text dup "," text dup "," text "]}," Expression Group Base to_s":{"type":"method","name":"to_s","children":[],"call":["s << ","@quantifier to_s "," quantified? ","@expressions join ","@text dup "," quantifier_affix "," expressions join "," expressions "," text "]}," Expression Group Base comment?":{"type":"method","name":"comment?","children":[],"call":["@type == "," type == "," type "]}," Expression Group Base capturing?":{"type":"method","name":"capturing?","children":[],"call":["(sym :capture) include? "," token "]}," Expression Sequence quantify":{"type":"method","name":"quantify","children":[],"call":[" last quantify "," last ","target quantify "," raise ","ArgumentError  new ","(str \"No valid target found for '\") + "," expressions [] "," expressions ","target is_a? ","exp is_a? ! ","exp is_a? "," expressions reverse find "," expressions reverse "," text "," extract_quantifier_target quantify "," extract_quantifier_target ","token text "," expressions []  quantify ","(str \"No valid  expressions []  found for '\") + "," expressions []  is_a? "," extract_quantifier_ expressions []  quantify "," extract_quantifier_ expressions []  "]}," Expression Sequence last":{"type":"method","name":"last","children":[],"call":["@expressions last "]}," Expression Sequence first":{"type":"method","name":"first","children":[],"call":["@expressions first "]}," Expression Sequence insert":{"type":"method","name":"insert","children":[],"call":["@expressions insert "]}," Expression Sequence <<":{"type":"method","name":"<<","children":[],"call":["@expressions << "]}," Expression Sequence initialize":{"type":"method","name":"initialize","children":[],"call":["Regexp Token  new "," class at_levels "," class "," warn ","args count == ","args count "]}," Expression Alternation to_s":{"type":"method","name":"to_s","children":[],"call":["(send\n  (ivar :@expressions) :map) join ","e to_s ","@expressions map ","(send\n  (send nil :alternatives) :map) join "," alternatives map "," alternatives "]}," Expression Alternation quantify":{"type":"method","name":"quantify","children":[],"call":["@expressions last last quantify ","@expressions last last ","@expressions last "," alternatives last last quantify "," alternatives last last "," alternatives last "," alternatives "]}," Expression Alternation alternatives":{"type":"method","name":"alternatives","children":[],"call":[]}," Expression Alternation alternative":{"type":"method","name":"alternative","children":[],"call":["@expressions << ","Sequence  new ","Alternative  new "," conditional_level "," set_level "," level "," expressions << "," expressions "]}," Expression Alternation <<":{"type":"method","name":"<<","children":[],"call":["@expressions last << ","@expressions last "," expressions last << "," expressions last "," expressions "]}," Expression Quantifier to_s":{"type":"method","name":"to_s","children":[],"call":["@text dup "," text dup "," text "]}," Expression Quantifier initialize":{"type":"method","name":"initialize","children":[],"call":[" token= "," token to_s sub to_sym "," token to_s sub "," token to_s "," token "," minmax ","(or\n  (send\n    (send nil :token) :[]\n    (regexp\n      (str \"greedy|reluctant|possessive\")\n      (regopt)))\n  (sym :greedy)) to_sym "," token [] "," init_from_token_and_options "," deprecated_old_init ","args count == ","args count ","(or\n  (send\n    (send\n      (send nil :token) :to_s) :[]\n    (regexp\n      (str \"greedy|reluctant|possessive\")\n      (regopt)))\n  (sym :greedy)) to_sym "," token to_s [] "]}," Expression Root free_spacing?":{"type":"method","name":"free_spacing?","children":[],"call":["@expressions [] x? ","@expressions [] "]}," Expression Root case_insensitive?":{"type":"method","name":"case_insensitive?","children":[],"call":["@expressions [] i? ","@expressions [] "]}," Expression Root multiline?":{"type":"method","name":"multiline?","children":[],"call":["@expressions [] m? ","@expressions [] "]}," Expression Root initialize":{"type":"method","name":"initialize","children":[],"call":["Regexp Token  new "," class build_token "," class "," warn ","args first is_a? ","args first "]}," Expression Base free_spacing?":{"type":"method","name":"free_spacing?","children":[],"call":["@options [] ","@options [] == "," options [] == "," options [] "," options "]}," Expression Base case_insensitive?":{"type":"method","name":"case_insensitive?","children":[],"call":["@options [] ","@options [] == "," options [] == "," options [] "," options "]}," Expression Base multiline?":{"type":"method","name":"multiline?","children":[],"call":["@options [] ","@options [] == "," options [] == "," options [] "," options "]}," Expression Base possessive?":{"type":"method","name":"possessive?","children":[],"call":["@quantifier mode == ","@quantifier mode "," quantified? "," quantifier mode == "," quantifier mode "," quantifier "," quantifier possessive? "]}," Expression Base reluctant?":{"type":"method","name":"reluctant?","children":[],"call":["@quantifier mode == ","@quantifier mode "," quantified? "," quantifier mode == "," quantifier mode "," quantifier "," quantifier reluctant? "]}," Expression Base greedy?":{"type":"method","name":"greedy?","children":[],"call":["@quantifier mode == ","@quantifier mode "," quantified? "," quantifier mode == "," quantifier mode "," quantifier "," quantifier greedy? "]}," Expression Base quantity":{"type":"method","name":"quantity","children":[],"call":["@quantifier max ","@quantifier min "," quantified? "," quantifier max "," quantifier "," quantifier min "]}," Expression Base quantified?":{"type":"method","name":"quantified?","children":[],"call":["@quantifier nil? ! ","@quantifier nil? "," quantifier nil? ! "," quantifier nil? "," quantifier "]}," Expression Base quantify":{"type":"method","name":"quantify","children":[],"call":["Quantifier  new "," quantifier= "]}," Expression Base []":{"type":"method","name":"[]","children":[],"call":["@expressions [] "]}," Expression Base each":{"type":"method","name":"each","children":[],"call":["@expressions each "]}," Expression Base <<":{"type":"method","name":"<<","children":[],"call":["@expressions << "]}," Expression Base to_s":{"type":"method","name":"to_s","children":[],"call":["s << "," quantified? ","(send\n  (ivar :@expressions) :map) join ","e to_s ","@expressions map ","@expressions empty? ","@text dup "," quantifier_affix "," text "]}," Expression Base initialize":{"type":"method","name":"initialize","children":[],"call":["token text ","token token ","token type ","token level ","token ts ","token conditional_level ","token set_level "," options= "," quantifier= "," conditional_level= "," set_level= "," level= "," ts= "," text= "," token= "," type= "," nesting_level= "," init_from_token_and_options "]}," Expression CharacterSet matches?":{"type":"method","name":"matches?","children":[],"call":["input =~ "," to_s "]}," Expression CharacterSet to_s":{"type":"method","name":"to_s","children":[],"call":["s << ","@quantifier to_s "," quantified? ","@members join "," negative? ","@text dup ","format == "," quantifier_affix "," members join "," members "," text "," expressions join "," expressions "," negated? "]}," Expression CharacterSet negative?":{"type":"method","name":"negative?","children":[],"call":[]}," Expression CharacterSet negate":{"type":"method","name":"negate","children":[],"call":["@members last negate ","@members last ","@members last is_a? "," negative= "]}," Expression CharacterSet include?":{"type":"method","name":"include?","children":[],"call":["member == ","m to_s ","m include? ","m is_a? ","@members each ","directly ! "]}," Expression CharacterSet <<":{"type":"method","name":"<<","children":[],"call":["@members << ","@members last << ","@members last ","@members last is_a? ","@members last closed? ! ","@members last closed? "]}," Expression CharacterSet initialize":{"type":"method","name":"initialize","children":[],"call":[" closed= "," negative= "]}," Expression UnicodeProperty Base name":{"type":"method","name":"name","children":[],"call":["@text =~ "," text =~ "," text "," text [] "]}," Expression UnicodeProperty Base negative?":{"type":"method","name":"negative?","children":[],"call":["@type == "," type == "," type "]}," CType ascii?":{"type":"method","name":"ascii?","children":[],"call":[]}," CType word?":{"type":"method","name":"word?","children":[],"call":[]}," CType xdigit?":{"type":"method","name":"xdigit?","children":[],"call":[]}," CType upper?":{"type":"method","name":"upper?","children":[],"call":[]}," CType space?":{"type":"method","name":"space?","children":[],"call":[]}," CType punct?":{"type":"method","name":"punct?","children":[],"call":[]}," CType print?":{"type":"method","name":"print?","children":[],"call":[]}," CType lower?":{"type":"method","name":"lower?","children":[],"call":[]}," CType graph?":{"type":"method","name":"graph?","children":[],"call":[]}," CType digit?":{"type":"method","name":"digit?","children":[],"call":[]}," CType cntrl?":{"type":"method","name":"cntrl?","children":[],"call":[]}," CType blank?":{"type":"method","name":"blank?","children":[],"call":[]}," CType alpha?":{"type":"method","name":"alpha?","children":[],"call":[]}," CType alnum?":{"type":"method","name":"alnum?","children":[],"call":[]}," Syntax Ruby V21 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V20 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Scanner empty_name_error":{"type":"method","name":"empty_name_error","children":[],"call":[" validation_error "]}," Scanner empty_backref_error":{"type":"method","name":"empty_backref_error","children":[],"call":[" validation_error "]}," Scanner validation_error":{"type":"method","name":"validation_error","children":[],"call":[" raise ","ValidationError  new ","InvalidSequenceError  new ","InvalidBackrefError  new ","InvalidGroupError  new ","UnknownUnicodePropertyError  new ","UnknownPosixClassError  new ","InvalidGroupOption  new "]}," Scanner text":{"type":"method","name":"text","children":[],"call":["ts - "," copy ","te - "]}," Scanner copy":{"type":"method","name":"copy","children":[],"call":["data [] pack ","data [] ","data [] pack force_encoding "]}," Scanner scan_options":{"type":"method","name":"scan_options","children":[],"call":[" raise ","PrematureEndError  new ","ScannerError  new "," emit_options ","te + ","c == ","text << ","data [] chr ","data [] ","InvalidGroupOption  new ","c =~ "," text first "," text ","Sdata [] chr annerError  new ","data [] chr  == "," text first  << ","data [] data [] chr hr ","data [] chr  =~ ","  text first  first ","  text first  "]}," Scanner InvalidBackrefError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Scanner InvalidGroupError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Scanner InvalidSequenceError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Scanner ValidationError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Expression parsed":{"type":"method","name":"parsed","children":[],"call":[]}," Expression Base terminal?":{"type":"method","name":"terminal?","children":[],"call":[" respond_to? ! "," respond_to? "]}," Expression Base coded_offset":{"type":"method","name":"coded_offset","children":[],"call":["@%d+%d % "," offset "]}," Expression Base offset":{"type":"method","name":"offset","children":[],"call":[" full_length "," starts_at "]}," Expression Base full_length":{"type":"method","name":"full_length","children":[],"call":[" to_s length "," to_s "]}," Expression Base starts_at":{"type":"method","name":"starts_at","children":[],"call":[]}," Expression Base to_re":{"type":"method","name":"to_re","children":[],"call":[" Regexp  new "," to_s "," warn "," set_level > "," set_level "]}," Expression Base clone":{"type":"method","name":"clone","children":[],"call":["copy quantifier= "," quantifier clone "," quantifier ","copy options= "," options dup "," options ","copy text= "," text dup "," text "," dup "," dup  quantifier= "," dup  options= "," dup  text= "]}," Expression Subexpression to_s":{"type":"method","name":"to_s","children":[],"call":["s << "," quantified? ","(send\n  (ivar :@expressions) :map) join ","e to_s ","@expressions map ","@expressions empty? ","@text dup "," quantifier_affix "," expressions join "," expressions "]}," Expression Subexpression length":{"type":"method","name":"length","children":[],"call":["@expressions length "]}," Expression Subexpression []":{"type":"method","name":"[]","children":[],"call":["@expressions [] "]}," Expression Subexpression last":{"type":"method","name":"last","children":[],"call":["@expressions last "]}," Expression Subexpression first":{"type":"method","name":"first","children":[],"call":["@expressions first "]}," Expression Subexpression each_with_index":{"type":"method","name":"each_with_index","children":[],"call":["@expressions each_with_index "]}," Expression Subexpression each":{"type":"method","name":"each","children":[],"call":["@expressions each "]}," Expression Subexpression insert":{"type":"method","name":"insert","children":[],"call":["@expressions insert "," expressions insert "," expressions "]}," Expression Subexpression <<":{"type":"method","name":"<<","children":[],"call":["@expressions << ","@expressions last merge ","@expressions last ","@expressions last is_a? ","exp is_a? "," expressions << "," expressions "," last merge "," last "," last is_a? ","exp nesting_level= "," nesting_level + "," nesting_level ","exp parent= "]}," Expression Subexpression clone":{"type":"method","name":"clone","children":[],"call":["copy expressions= ","e clone ","@expressions map "," expressions map "," expressions "]}," Expression Subexpression initialize":{"type":"method","name":"initialize","children":[],"call":[" expressions= "]}," Expression Quantifier clone":{"type":"method","name":"clone","children":[],"call":["copy instance_variable_set ","@text dup "," dup "," text dup "," text "," dup  instance_variable_set "]}," Expression CharacterSet closed?":{"type":"method","name":"closed?","children":[],"call":[]}," Expression CharacterSet close":{"type":"method","name":"close","children":[],"call":["@members last close ","@members last ","@members last closed? ! ","@members last closed? ","@members last is_a? "," closed= "]}," Expression CharacterSet length":{"type":"method","name":"length","children":[],"call":["@members length "]}," Expression CharacterSet each_with_index":{"type":"method","name":"each_with_index","children":[],"call":["@members each_with_index "]}," Expression CharacterSet each":{"type":"method","name":"each","children":[],"call":["@members each "]}," Expression CharacterSet clone":{"type":"method","name":"clone","children":[],"call":["copy members= ","m clone ","@members map "]}," Expression Group Named clone":{"type":"method","name":"clone","children":[],"call":["copy instance_variable_set ","@name dup "," name dup "," name "]}," Expression Group Named initialize":{"type":"method","name":"initialize","children":[],"call":["token text [] ","token text "]}," Expression Backreference NameCall initialize":{"type":"method","name":"initialize","children":[],"call":["token text [] ","token text "]}," Expression Backreference Number initialize":{"type":"method","name":"initialize","children":[],"call":["token text [] ","token text ","token token equal? ","token token ","token text [] to_i "]}," Expression Backreference Name initialize":{"type":"method","name":"initialize","children":[],"call":["token text [] ","token text "]}," Expression Sequence starts_at":{"type":"method","name":"starts_at","children":[],"call":["@expressions first starts_at ","@expressions first "," expressions first starts_at "," expressions first "," expressions "]}," Expression Alternation starts_at":{"type":"method","name":"starts_at","children":[],"call":["@expressions first starts_at ","@expressions first "," expressions first starts_at "," expressions first "," expressions "]}," Syntax Ruby V213 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V212 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V210 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V200 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax Ruby V220 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax Ruby V215 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V214 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Scanner emit_options":{"type":"method","name":"emit_options","children":[],"call":[" emit ","@spacing_stack last []= ","@spacing_stack last ","@spacing_stack << ","negative include? ","positive include? ","text =~ "," spacing_stack last []= "," free_spacing "," spacing_stack last "," spacing_stack "," spacing_stack << "," group_depth "," free_spacing= "]}," Scanner InvalidGroupOption initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Parser free_space":{"type":"method","name":"free_space","children":[],"call":[" raise ","UnknownTokenError  new ","@node << ","WhiteSpace  new "," active_opts ","@node last merge ","@node last ","@node last is_a? ","Comment  new ","token token "," node << "," node "," node last merge "," node last "," node last is_a? "]}," Parser keep":{"type":"method","name":"keep","children":[],"call":["@node << ","Keep Mark  new "," active_opts "," node << "," node "]}," Parser conditional":{"type":"method","name":"conditional","children":[],"call":[" raise ","UnknownTokenError  new ","@conditional_nesting last ","@nesting last ","@conditional_nesting empty? ","@conditional_nesting pop ","@conditional_nesting last branches last ","@conditional_nesting last branches ","@conditional_nesting last branch ","@conditional_nesting last condition ","Conditional Condition  new "," active_opts "," nest_conditional ","Conditional Expression  new ","token token "," node= "," conditional_nesting last "," conditional_nesting "," nesting last "," nesting "," conditional_nesting empty? "," conditional_nesting pop "," conditional_nesting last branches last "," conditional_nesting last branches "," conditional_nesting last branch "," conditional_nesting last condition= "," decrease_nesting "," conditional_nesting last add_sequence ","token te "]}," Parser nest_conditional":{"type":"method","name":"nest_conditional","children":[],"call":["@node << ","@conditional_nesting push "," node= "," node << "," node "," conditional_nesting push "," conditional_nesting "," nest "]}," Lexer merge_condition":{"type":"method","name":"merge_condition","children":[],"call":["Regexp Token  new ","current te ","last ts ","last text + ","current text ","last text ","@tokens pop "," conditional_nesting "," set_nesting "," nesting "," tokens pop "," tokens ","token previous= "," preprev_token ","@tokens pop  ts "," tokens pop  ts ","@tokens pop  text + "," tokens pop  text + ","@tokens pop  text "," tokens pop  text ","@Regexp Token  new s pop "," Regexp Token  new s pop "," Regexp Token  new s ","Regexp Token  new  previous= "," preprev_Regexp Token  new  "]}," Lexer lex":{"type":"method","name":"lex","children":[],"call":["block call ","@tokens map "," block_given? "," descend ","@tokens << ","current previous ","last next "," merge_condition ","(sym :condition) include? ","type == "," merge_literal ","last type == ","last type ","Regexp Token  new "," break_literal "," ascend ","syntax check! ","syntax normalize ","Regexp Scanner  scan ","Regexp Syntax  new "," tokens "," tokens map "," tokens << ","current previous= ","last next= "," conditional_nesting "," set_nesting "," nesting "," conditional_nesting= "," set_nesting= "," nesting= "," tokens= "," set_nesting == ","te + "," shift ","ts + "," break_codepoint_list ","last token == ","last token "," shift= ","CONDITION_TOKENS  include? ","Regexp Syntax  for "," emit "," prev_token "," prev_token= "," preprev_token= ","parts [] "," collect_tokens= "," block= "," merge_condition  previous "," merge_literal  previous ","Regexp Token  new  previous ","parts []  next "," prev_token  next ","parts []  type == "," prev_token  type == ","parts []  type "," prev_token  type ","Regexp Syntax  new  check! ","Regexp Syntax  for  check! ","Regexp Syntax  new  normalize ","Regexp Syntax  for  normalize "," merge_condition  previous= "," merge_literal  previous= ","Regexp Token  new  previous= ","parts []  next= "," prev_token  next= ","parts []  token == "," prev_token  token == ","parts []  token "," prev_token  token "," break_codepoint_list  [] "," break_literal  [] "]}," Expression Base to_h":{"type":"method","name":"to_h","children":[],"call":["@quantifier to_h "," quantified? "," full_length "," to_s "," quantifier to_h "," quantifier "," options "," conditional_level "," set_level "," level "," ts "," token "," type "]}," Expression Base match":{"type":"method","name":"match","children":[],"call":["Regexp  new match ","Regexp  new "," to_s "]}," Expression Base matches?":{"type":"method","name":"matches?","children":[],"call":["Regexp  new =~ ","Regexp  new "," to_s "]}," Expression Base unicode_classes?":{"type":"method","name":"unicode_classes?","children":[],"call":["@options [] ","@options [] == "," options [] == "," options [] "," options "]}," Expression Base ascii_classes?":{"type":"method","name":"ascii_classes?","children":[],"call":["@options [] ","@options [] == "," options [] == "," options [] "," options "]}," Expression Base default_classes?":{"type":"method","name":"default_classes?","children":[],"call":["@options [] ","@options [] == "," options [] == "," options [] "," options "]}," Expression Subexpression to_h":{"type":"method","name":"to_h","children":[],"call":["h []= ","@expressions map "," to_s "," merge "," expressions map "," expressions "," attributes merge "," attributes "]}," Expression Subexpression te":{"type":"method","name":"te","children":[],"call":[" ts + "," to_s length "," to_s "," ts "," base_length "]}," Expression Subexpression ts":{"type":"method","name":"ts","children":[],"call":[" starts_at "]}," Expression Subexpression all?":{"type":"method","name":"all?","children":[],"call":["@expressions all? "]}," Expression Subexpression empty?":{"type":"method","name":"empty?","children":[],"call":["@expressions empty? "]}," Expression Sequence text":{"type":"method","name":"text","children":[],"call":[" to_s "]}," Expression Quantifier to_h":{"type":"method","name":"to_h","children":[],"call":[" max "," min "," mode "," text "," token "]}," Expression Subexpression map":{"type":"method","name":"map","children":[],"call":["result << "," block_given? "," each_expression "]}," Expression Subexpression each_expression":{"type":"method","name":"each_expression","children":[],"call":["event == "," traverse "," enum_for "," __method__ "," block_given? ","exp each_expression ","exp terminal? ","block call "," each_with_index "," each_expression_with_index "," each_expression_without_index ","block arity == ","block arity "]}," Expression Subexpression traverse":{"type":"method","name":"traverse","children":[],"call":["block call ","exp traverse ","exp terminal? "," each_with_index "," raise "," block_given? "," enum_for "," __method__ "]}," Expression Base one_of?":{"type":"method","name":"one_of?","children":[],"call":[" raise ","scope class name ","scope class "," type? "," is? ","scope == "," one_of? ","scope [] "," type ","scope has_key? ","scope include? "," token ","scope equal? "]}," Expression Base is?":{"type":"method","name":"is?","children":[],"call":[" type? "," token == "," token ","test_token === "]}," Expression Base type?":{"type":"method","name":"type?","children":[],"call":[" raise ","test_type class name ","test_type class ","test_type == "," type == "," type ","test_type include? ","test_types include? "," Array map "," Array "," Array map  include? "]}," Expression Subexpression strfregexp_tree":{"type":"method","name":"strfregexp_tree","children":[],"call":["output join ","exp strfregexp "," map "," strfregexp "," flat_map "]}," Expression Base strfregexp":{"type":"method","name":"strfregexp","children":[],"call":["out gsub! ","part [] to_s ","part [] ","part_keys each ","format dup ","part []= "," to_s "," token "," type "," terminal? "," quantifier max "," quantifier "," quantifier min "," quantifier text "," quantifier max == "," quantified? "," class name "," class "," coded_offset "," starts_at + "," full_length "," starts_at ","%d % "," level ","   * "," level + ","part keys each ","part keys ","print_level + "," nesting_level - "," nesting_level "," nesting_level > ","format dup  gsub! "," nesting_level -  + "]}," Expression CharacterSet expand_members":{"type":"method","name":"expand_members","children":[],"call":["@members map "]}," Expression WhiteSpace merge":{"type":"method","name":"merge","children":[],"call":["@text << ","exp text "," text << "," text "," warn "," __method__ "," class "]}," Expression FreeSpace quantify":{"type":"method","name":"quantify","children":[],"call":[" raise "]}," Expression Conditional Expression to_s":{"type":"method","name":"to_s","children":[],"call":["s << ","(send\n  (send nil :branches) :map) join ","e to_s "," branches map "," branches ","@condition text ","@text dup "," text + + + "," text + + "," branches join "," text + "," condition text "," condition "," text "," quantifier_affix ","@text dup  << ","(@text dup end\n  (@text dup end nil :branche@text dup ) :map) join ","e to_@text dup  "," branche@text dup  map "," branche@text dup  "," branche@text dup  join "]}," Expression Conditional Expression quantify":{"type":"method","name":"quantify","children":[],"call":[" branches last last quantify "," branches last last "," branches last "," branches "]}," Expression Conditional Expression branches":{"type":"method","name":"branches","children":[],"call":[" expressions - "," condition "," expressions ","subexp is_a? "," select "]}," Expression Conditional Expression branch":{"type":"method","name":"branch","children":[],"call":["@branches << ","@expressions last ","@expressions << ","Branch  new "," conditional_level + "," conditional_level "," set_level "," level "," raise ","TooManyBranches  new ","@branches length == ","@branches length "," branches << "," expressions last "," expressions "," branches "," expressions << "," branches length == "," branches length "]}," Expression Conditional Expression <<":{"type":"method","name":"<<","children":[],"call":["@expressions last << ","@expressions last "," expressions last << "," expressions last "," expressions "]}," Expression Conditional Expression condition":{"type":"method","name":"condition","children":[],"call":["@expressions << ","subexp is_a? "," find "]}," Expression Conditional Expression initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Expression Conditional TooManyBranches initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V222 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V221 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V216 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V223 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V217 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax instantiate":{"type":"method","name":"instantiate","children":[],"call":[]}," Syntax Ruby V230 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax Ruby V224 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V218 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V231 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V225 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V219 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Regexp initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax version_class":{"type":"method","name":"version_class","children":[],"call":[" raise "," const_get "," version_const_name ","version =~ ","version to_s scan join ","version to_s scan ","version to_s "," warn_if_future_version ","(str \"*\") include? ","  version_const_name  "]}," Syntax supported?":{"type":"method","name":"supported?","children":[],"call":[" comparable_version >= "," comparable_version ","name =~ "," comparable >= "," comparable "]}," Syntax InvalidVersionNameError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V232 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V226 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V2110 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V233 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V260 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V250 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax Ruby V243 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V242 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V241 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax Ruby V240 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax Ruby V236 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V235 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V234 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V229 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V228 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V227 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Parser active_opts":{"type":"method","name":"active_opts","children":[],"call":["@options_stack last "," options_stack last "," options_stack "]}," Parser options_group":{"type":"method","name":"options_group","children":[],"call":[" nest ","Group Options  new "," active_opts ","@options_stack << ","new_options []= ","flag to_sym ","new_options delete ","key to_sym ","(str \"a\") each ","positive reverse [] ","positive reverse ","negative include? ","positive include? ","(str \"i\") each "," active_opts dup ","token text include? ! ","token text include? ","token text ","token text split "," options_stack << "," options_stack "," switching_options= ","token token equal? ","token token ","options_group option_changes= ","opt_changes []= ","new_active_opts []= ","new_active_opts delete ","new_active_opts [] ","(send\n  (const nil :ENC_FLAGS) :-\n  (array\n    (lvar :enc_flag))) each ","ENC_FLAGS  - ","enc_flag to_sym ","flag to_s ","MOD_FLAGS  each "," active_opts dup  []= ","positive reverse []  to_sym "," active_opts dup  delete ","Group Options  new  option_changes= "," active_opts dup  [] ","(send\n  (const nil :ENC_FLAGS) :-\n  (array\n    (lvar :enc_positive reverse [] ))) each ","(send\n  (const nil :ENC_FLAGS) :-\n  (array\n    (lvar :enc_flag to_sym ))) each ","(send\n  (const nil :ENC_FLAGS) :-\n  (array\n    (lvar :positive reverse [] ))) each ","enc_positive reverse []  to_sym ","enc_flag to_sym  to_sym ","positive reverse []  to_s "]}," Parser options_from_input":{"type":"method","name":"options_from_input","children":[],"call":["options []= ","input options & != ","input options & ","input options ","input is_a? "]}," Syntax Ruby V251 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V244 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V237 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax Ruby V2210 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Syntax V2_5_0 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax V2_4_1 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax V2_4_0 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax V2_3_0 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax V2_2_0 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax V2_0_0 initialize":{"type":"method","name":"initialize","children":[],"call":[" excludes "," implements "]}," Syntax V1_9_3 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax V1_9_1 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements ","CharacterSet OpenClose  + + + ","CharacterSet OpenClose  + + ","CharacterSet OpenClose  + ","CharacterSet POSIX StandardNegative  + + + ","CharacterSet POSIX StandardNegative  + + ","CharacterSet POSIX StandardNegative  + ","Quantifier Possessive  + ","Escape Unicode  + + ","Escape Unicode  + ","Backreference All  + ","Assertion Lookbehind  + ","Backreference V1_9_1  + "]}," Syntax V1_8_6 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements ","CharacterSet OpenClose  + + + ","CharacterSet OpenClose  + + ","CharacterSet OpenClose  + ","Quantifier Greedy  + + + ","Quantifier Greedy  + + ","Quantifier Greedy  + ","Escape Basic  + + + + ","Escape Basic  + + + ","Escape Basic  + + ","Escape Basic  + "]}," Syntax warn_if_future_version":{"type":"method","name":"warn_if_future_version","children":[],"call":[" warn "," const_get inspect "," const_get "," comparable_version < "," comparable_version "," comparable < "," comparable "]}," Syntax comparable_version":{"type":"method","name":"comparable_version","children":[],"call":["Gem Version  new ","(send\n  (send\n    (send\n      (lvar :name) :to_s) :scan\n    (regexp\n      (str \"\\\\d+\")\n      (regopt))) :<<\n  (int 99)) join ","name to_s scan << ","name to_s scan ","name to_s "]}," Syntax specified_versions":{"type":"method","name":"specified_versions","children":[],"call":["const_name =~ "," constants select "," constants "]}," Syntax inherit_from_version":{"type":"method","name":"inherit_from_version","children":[],"call":[" const_get "," warn_if_future_version "," const_set ","Class  new "," const_defined? "," version_const_name "]}," Syntax fallback_version_class":{"type":"method","name":"fallback_version_class","children":[],"call":[" inherit_from_version ","sorted_versions [] ","version_index - ","(lvasgn :version_index\n  (send\n    (lvar :sorted_versions) :index\n    (lvar :version))) < ","sorted_versions index "," comparable_version ","(send\n  (send nil :specified_versions) :+\n  (array\n    (lvar :version))) sort_by "," specified_versions + "," specified_versions "," const_get ","sorted [] ","index - ","index > ","sorted index "," comparable ","sorted_versions index  - ","version_sorted index  - ","(lvasgn :sorted_versions index \n  (send\n    (lvar :sorted_versions) :index\n    (lvar :version))) < ","(lvasgn :version_sorted index \n  (send\n    (lvar :sorted_versions) :sorted index \n    (lvar :version))) < ","sorted_versions sorted index  ","sorted index  - ","sorted index  > ","sorted sorted index  "]}," Syntax const_missing":{"type":"method","name":"const_missing","children":[],"call":[" fallback_version_class ","const_name =~ "]}," Syntax version_const_name":{"type":"method","name":"version_const_name","children":[],"call":["version_string to_s scan join ","version_string to_s scan ","version_string to_s "]}," Syntax Base inspect":{"type":"method","name":"inspect","children":[],"call":[]}," Syntax Base implementations":{"type":"method","name":"implementations","children":[],"call":["Set  new ","@implements [] "," features [] "," features "]}," Expression Base quantifier_affix":{"type":"method","name":"quantifier_affix","children":[],"call":[" quantifier to_s "," quantifier ","expression_format != "," quantified? "]}," Expression Conditional Expression condition=":{"type":"method","name":"condition=","children":[],"call":[" expressions << "," expressions "," expressions unshift "," expressions delete "," condition "]}," Expression CharacterClass name":{"type":"method","name":"name","children":[],"call":[" token to_s "," token "]}," Expression CharacterClass negative?":{"type":"method","name":"negative?","children":[],"call":[" type == "," type "]}," Scanner long_prop_map":{"type":"method","name":"long_prop_map","children":[],"call":[]}," Scanner short_prop_map":{"type":"method","name":"short_prop_map","children":[],"call":[]}," Parser count_captured_group":{"type":"method","name":"count_captured_group","children":[],"call":[" captured_group_counts [] "," node level "," node "," captured_group_counts "]}," Parser captured_group_count_at_level":{"type":"method","name":"captured_group_count_at_level","children":[],"call":[" captured_group_counts [] "," node level "," node "," captured_group_counts "]}," Parser total_captured_group_count":{"type":"method","name":"total_captured_group_count","children":[],"call":[" captured_group_counts values reduce "," captured_group_counts values "," captured_group_counts "]}," Parser sequence_operation":{"type":"method","name":"sequence_operation","children":[],"call":[" node add_sequence "," node "," nest "," node expressions= ","sequence expressions= "," node expressions ","operator add_sequence ","klass new "," active_opts "," node is_a? ! "," node is_a? "," node= "," node last "," node last is_a? "," node instance_of? ","token te ","token ts "," node add_operator add_sequence  ","operator add_sequence  expressions= ","operator add_operator add_sequence  ","klass new  add_sequence "]}," Parser intersection":{"type":"method","name":"intersection","children":[],"call":[" sequence_operation "]}," Parser close_completed_character_set_range":{"type":"method","name":"close_completed_character_set_range","children":[],"call":[" decrease_nesting "," node complete? "," node "," node is_a? "," node instance_of? "]}," Parser range":{"type":"method","name":"range","children":[],"call":[" nest ","exp << ","scope expressions pop ","scope expressions "," node "," node last "," node last is_a? ","CharacterSet Range  new "," active_opts "," node last instance_of? ","CharacterSet Range  new  << "," node  expressions pop "," node last  expressions pop ","scope CharacterSet Range  new ressions pop "," node  expressions "," node last  expressions ","scope CharacterSet Range  new ressions "]}," Parser posixclass":{"type":"method","name":"posixclass","children":[],"call":[" node << ","PosixClass  new "," node "," active_opts "]}," Parser decrease_nesting":{"type":"method","name":"decrease_nesting","children":[],"call":[" node= "," node last "," node "," node last is_a? "," nesting last "," nesting "," block_given? "," nesting pop "," nesting last is_a? "]}," Parser update_transplanted_subtree":{"type":"method","name":"update_transplanted_subtree","children":[],"call":[" update_transplanted_subtree ","exp each ","exp respond_to? ","exp nesting_level= ","new_parent nesting_level + ","new_parent nesting_level "]}," Expression Base initialize_clone":{"type":"method","name":"initialize_clone","children":[],"call":["other quantifier= "," quantifier clone "," quantifier ","other options= "," options dup "," options ","other text= "," text dup "," text "," quantifier= ","orig quantifier clone ","orig quantifier "," options= ","orig options dup ","orig options "," text= ","orig text dup ","orig text "]}," Expression Subexpression initialize_clone":{"type":"method","name":"initialize_clone","children":[],"call":["other expressions= "," expressions map "," expressions "," expressions= ","orig expressions map ","orig expressions "]}," Expression SequenceOperation to_s":{"type":"method","name":"to_s","children":[],"call":["(send\n  (send nil :sequences) :map) join "," text ","e to_s "," sequences map "," sequences "]}," Expression SequenceOperation quantify":{"type":"method","name":"quantify","children":[],"call":[" sequences last last quantify "," sequences last last "," sequences last "," sequences "]}," Expression SequenceOperation add_sequence":{"type":"method","name":"add_sequence","children":[],"call":[" expressions << "," expressions ","exp nesting_level= "," nesting_level + "," nesting_level "," class OPERAND  new "," conditional_level "," set_level "," level "," class "," class OPERAND  add_to ","  class OPERAND  new ressions << ","  class OPERAND  new ressions "," class OPERAND  new  nesting_level= "]}," Expression SequenceOperation <<":{"type":"method","name":"<<","children":[],"call":[" expressions last << "," expressions last "," expressions "]}," Expression SequenceOperation starts_at":{"type":"method","name":"starts_at","children":[],"call":[" expressions first starts_at "," expressions first "," expressions "]}," Expression Quantifier initialize_clone":{"type":"method","name":"initialize_clone","children":[],"call":["other instance_variable_set "," text dup "," text ","orig text dup ","orig text "]}," Expression Subexpression flat_map":{"type":"method","name":"flat_map","children":[],"call":["result << "," block_given? "," each_expression ","block call "," each_expression map "," each_expression to_a ","block arity "]}," Expression CharacterSet Range to_s":{"type":"method","name":"to_s","children":[],"call":[" expressions join "," text "," expressions "]}," Expression CharacterSet Range complete?":{"type":"method","name":"complete?","children":[],"call":[" count == "," count "]}," Expression CharacterSet Range <<":{"type":"method","name":"<<","children":[],"call":[" raise "," complete? "]}," Expression CharacterSet Range starts_at":{"type":"method","name":"starts_at","children":[],"call":[" expressions first starts_at "," expressions first "," expressions "]}," Expression UnicodeProperty Base shortcut":{"type":"method","name":"shortcut","children":[],"call":["(or\n  (send\n    (send\n      (const\n        (const nil :Regexp) :Scanner) :short_prop_map) :rassoc\n    (send\n      (send nil :token) :to_s))\n  (array)) first ","Regexp Scanner  short_prop_map rassoc "," token to_s "," token ","Regexp Scanner  short_prop_map ","Regexp Scanner  short_prop_map key "]}," Expression PosixClass name":{"type":"method","name":"name","children":[],"call":[" token to_s "," token "," text [] "," text "]}," Expression PosixClass negative?":{"type":"method","name":"negative?","children":[],"call":[" type == "," type "]}," Expression Group Comment comment?":{"type":"method","name":"comment?","children":[],"call":[]}," Expression Group Named initialize_clone":{"type":"method","name":"initialize_clone","children":[],"call":["other instance_variable_set "," name dup "," name ","orig name dup ","orig name "]}," Expression Group Capture capturing?":{"type":"method","name":"capturing?","children":[],"call":[]}," Expression EscapeSequence MetaControl codepoint":{"type":"method","name":"codepoint","children":[],"call":[" meta_char_to_codepoint "," control_sequence_to_s "," text "]}," Expression EscapeSequence Meta codepoint":{"type":"method","name":"codepoint","children":[],"call":[" meta_char_to_codepoint "," text [] "," text "]}," Expression EscapeSequence Control codepoint":{"type":"method","name":"codepoint","children":[],"call":[" control_sequence_to_s ord "," control_sequence_to_s "," text "]}," Expression EscapeSequence AbstractMetaControlSequence meta_char_to_codepoint":{"type":"method","name":"meta_char_to_codepoint","children":[],"call":["byte_value + ","byte_value < ","meta_char ord ","meta_char ord  + ","meta_char ord  < "]}," Expression EscapeSequence AbstractMetaControlSequence control_sequence_to_s":{"type":"method","name":"control_sequence_to_s","children":[],"call":["(dstr\n  (str \"000\")\n  (begin\n    (lvar :five_lsb))) pack ","control_sequence unpack first [] ","control_sequence unpack first ","control_sequence unpack ","(dstr\n  (str \"000\")\n  (begin\n    (lvar :control_sequence unpack first [] ))) pack "]}," Expression EscapeSequence AbstractMetaControlSequence codepoint":{"type":"method","name":"codepoint","children":[],"call":[" raise "]}," Expression EscapeSequence AbstractMetaControlSequence char":{"type":"method","name":"char","children":[],"call":[" codepoint chr "," codepoint "]}," Expression EscapeSequence Octal char":{"type":"method","name":"char","children":[],"call":[" text [] to_i chr "," text [] to_i "," text [] "," text "]}," Expression EscapeSequence CodepointList codepoints":{"type":"method","name":"codepoints","children":[],"call":[" text scan map "," text scan "," text "]}," Expression EscapeSequence CodepointList chars":{"type":"method","name":"chars","children":[],"call":["cp chr "," codepoints map "," codepoints "]}," Expression EscapeSequence CodepointList codepoint":{"type":"method","name":"codepoint","children":[],"call":[" raise "]}," Expression EscapeSequence CodepointList char":{"type":"method","name":"char","children":[],"call":[" raise "]}," Expression EscapeSequence Literal char":{"type":"method","name":"char","children":[],"call":[" text [] "," text "]}," Expression EscapeSequence Base codepoint":{"type":"method","name":"codepoint","children":[],"call":[" char ord "," char "]}," Expression EscapeSequence Base char":{"type":"method","name":"char","children":[],"call":["YAML  load "," text ","(str \"\\\"\") undump "]}," Expression Backreference NameRecursionLevel initialize":{"type":"method","name":"initialize","children":[],"call":["recursion_level to_i ","token text [] split ","token text [] ","token text "]}," Expression Backreference NumberRecursionLevel initialize":{"type":"method","name":"initialize","children":[],"call":["token text [] split map ","token text [] split ","token text [] ","token text "]}," Expression Subexpression dig":{"type":"method","name":"dig","children":[],"call":["exp [] ","exp terminal? ","exp nil? ","indices each ","exp []  [] ","exp []  terminal? ","exp []  nil? "]}," Expression Sequence at_levels":{"type":"method","name":"at_levels","children":[],"call":[" new ","Regexp Token  new "]}," Expression Sequence add_to":{"type":"method","name":"add_to","children":[],"call":["subexpression expressions << ","subexpression expressions ","sequence nesting_level= ","subexpression nesting_level + ","subexpression nesting_level "," at_levels ","subexpression conditional_level ","options [] ","subexpression set_level ","subexpression level ","sequence options= ","params [] ","exp expressions << ","exp expressions ","exp nesting_level + ","exp nesting_level "," construct ","exp conditional_level ","exp set_level ","exp level "," at_levels  nesting_level= "," construct  nesting_level= "," at_levels  options= "," construct  options= "]}," Expression Root build_token":{"type":"method","name":"build_token","children":[],"call":["Regexp Token  new "]}," Expression Root build":{"type":"method","name":"build","children":[],"call":[" new "," build_token "]}," Expression Conditional Expression reference":{"type":"method","name":"reference","children":[],"call":[" condition reference "," condition "]}," Expression Conditional Expression add_sequence":{"type":"method","name":"add_sequence","children":[],"call":["Branch  add_to "," conditional_level + "," conditional_level "," raise ","TooManyBranches  new "," branches length == "," branches length "," branches ","params merge ","params merge  merge "]}," Expression Conditional Condition reference":{"type":"method","name":"reference","children":[],"call":[" Integer ","ref =~ "," text tr "," text "," text tr  =~ "]}," Expression Base attributes":{"type":"method","name":"attributes","children":[],"call":[" quantifier to_h "," quantifier "," quantified? "," options "," conditional_level "," set_level "," level "," full_length "," ts "," to_s "," token "," type "]}," Syntax Base features":{"type":"method","name":"features","children":[],"call":[]}," Syntax V2_6_0 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Parser assign_referenced_expressions":{"type":"method","name":"assign_referenced_expressions","children":[],"call":["exp referenced_expression= ","targets [] ","exp reference ","exp respond_to? "," root each_expression "," root ","targets []= ","exp identifier ","exp is_a? "," raise ","referrers each ","referrers << ","exp referential? ","exp ts "]}," Parser assign_effective_number":{"type":"method","name":"assign_effective_number","children":[],"call":["exp effective_number= ","exp number + + ","exp number < ","exp number ","exp number + "," total_captured_group_count "," raise ","exp reference ","exp effective_number > ","exp effective_number "]}," Lexer break_codepoint_list":{"type":"method","name":"break_codepoint_list","children":[],"call":[" shift= "," shift + "," shift "," tokens << ","Regexp Token  new "," conditional_nesting "," set_nesting "," nesting ","token te + ","token te ","token ts + + ","token ts + ","lead length ","token ts ","\\u{ + "," tokens ","token te - ","tail length ","lead + "," tokens pop ","lead empty? ","token text rpartition ","token text ","token_2 previous= ","token_1 next= ","token_1 previous= "," preprev_token ","Regexp Token  new  previous= ","Regexp Token  new  next= "]}," Expression Base repetitions":{"type":"method","name":"repetitions","children":[],"call":["r define_singleton_method ","(irange\n  (lvar :min)\n  (lvar :max)) tap "," quantifier max "," quantifier "," quantifier max < "," quantifier min "," quantified? ","range define_singleton_method ","RUBY_VERSION  to_f < ","RUBY_VERSION  to_f ","(irange\n  (lvar :min)\n  (lvar : quantifier max )) tap ","(irange\n  (lvar : quantifier min )\n  (lvar :max)) tap "," quantifier  quantifier max  "," quantifier  quantifier max  < "," quantifier  quantifier min  "]}," Expression Base unquantified_clone":{"type":"method","name":"unquantified_clone","children":[],"call":["exp quantifier= "," clone tap "," clone "]}," Expression Absence match_length":{"type":"method","name":"match_length","children":[],"call":["MatchLength  new "," lambda "]}," Expression CodepointList match_length":{"type":"method","name":"match_length","children":[],"call":["MatchLength  new "," codepoints count "," codepoints "]}," Expression Base match_length":{"type":"method","name":"match_length","children":[],"call":[" referenced_expression unquantified_clone match_length "," referenced_expression unquantified_clone "," referenced_expression "," raise "," referenced_expression nil? "]}," Expression Subexpression inner_match_length":{"type":"method","name":"inner_match_length","children":[],"call":["dummy match_length ","dummy quantifier= "," quantifier clone "," quantifier ","dummy expressions= "," expressions map "," expressions ","Regexp Expression Root  build ","Regexp Expression Root  construct ","Regexp Expression Root  build  match_length ","Regexp Expression Root  construct  match_length ","Regexp Expression Root  build  quantifier= ","Regexp Expression Root  construct  quantifier= ","Regexp Expression Root  build  expressions= ","Regexp Expression Root  construct  expressions= "]}," Expression Subexpression match_length":{"type":"method","name":"match_length","children":[],"call":["MatchLength  new ","(send nil :map) join ","exp match_length to_re ","exp match_length "," map "," lambda ","(send nil :map) inject ","exp match_length max ","exp match_length min "]}," Expression Literal match_length":{"type":"method","name":"match_length","children":[],"call":["MatchLength  new "," text length "," text "]}," MatchLength test_regexp":{"type":"method","name":"test_regexp","children":[{"type":"method","name":"match?","children":[],"asgn":[],"call":[]}],"call":[" match ! ! "," match ! "," match ","regexp respond_to? ","Regexp  new tap ","Regexp  new "," to_re ","(str \"^\") tap "]}," MatchLength to_re":{"type":"method","name":"to_re","children":[],"call":[" max_rep "," max_rep == "," min_rep "," reify call "," reify "]}," MatchLength inspect":{"type":"method","name":"inspect","children":[],"call":[" max "," min "," class "," exp_class name sub "," exp_class name "," exp_class "]}," MatchLength minmax":{"type":"method","name":"minmax","children":[],"call":[" max "," min "]}," MatchLength max":{"type":"method","name":"max","children":[],"call":[" max_rep * "," base_max "," max_rep "]}," MatchLength min":{"type":"method","name":"min","children":[],"call":[" min_rep * "," base_min "," min_rep "]}," MatchLength fixed?":{"type":"method","name":"fixed?","children":[],"call":[" min == "," max "," min "]}," MatchLength include?":{"type":"method","name":"include?","children":[],"call":[" test_regexp match? ","X * "," test_regexp "]}," MatchLength endless_each":{"type":"method","name":"endless_each","children":[],"call":[" include? ","(irange\n  (send nil :min)\n  (send nil :max)) each "," max "," min "," enum_for "," __method__ "," block_given? "]}," MatchLength each":{"type":"method","name":"each","children":[],"call":["(op-asgn\n  (lvasgn :yielded) :+\n  (int 1)) >= "," include? ","(irange\n  (send nil :min)\n  (send nil :max)) each "," max "," min ","opts [] "," enum_for "," __method__ "," block_given? "]}," MatchLength initialize":{"type":"method","name":"initialize","children":[],"call":[" reify= ","opts fetch "," base_max= "," base_min= ",". * "," lambda ","opts [] "," max_rep= ","exp repetitions max ","exp repetitions "," min_rep= ","exp repetitions min "," exp_class= ","exp class "," opts [] _max= "," opts [] _min= "]}," MatchLength of":{"type":"method","name":"of","children":[],"call":[]}," Scanner emit_meta_control_sequence":{"type":"method","name":"emit_meta_control_sequence","children":[],"call":[" emit "," text "," validation_error ","token to_s ","data last > ","data last ","data last < "," copy ","ts - "," raise ","ValidationError  for "]}," Scanner in_set?":{"type":"method","name":"in_set?","children":[],"call":[" set_depth > "," set_depth "]}," Scanner in_group?":{"type":"method","name":"in_group?","children":[],"call":[" group_depth > "," group_depth "]}," Expression Base match?":{"type":"method","name":"match?","children":[],"call":[" match ! ! "," match ! "," match "]}," Syntax V2_6_3 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Syntax V2_6_2 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Scanner free_spacing?":{"type":"method","name":"free_spacing?","children":[],"call":["options & != ","options & ","input_object options ","input_object is_a? "," raise ","input_object is_a? ! ","input_object options  & != ","input_object options  & ","input_object input_object options  "]}," Parser extract_options":{"type":"method","name":"extract_options","children":[],"call":["enabled_options []= ","options & != ","options & ","input options ","input is_a? "," raise ","input is_a? ! ","enabled_input options  []= ","input options  & != ","input options  & ","input input options  "]}," Parser increase_level":{"type":"method","name":"increase_level","children":[],"call":[" increase_level ","exp each ","exp respond_to? ","exp level "]}," Expression Base base_length":{"type":"method","name":"base_length","children":[],"call":[" to_s length "," to_s "]}," Expression Quantifier ==":{"type":"method","name":"==","children":[],"call":["other max == "," max ","other max ","other min == "," min ","other min ","other mode == "," mode ","other mode ","other token == "," token ","other token ","other class == "," class ","other class "]}," Expression Group Passive implicit?":{"type":"method","name":"implicit?","children":[],"call":[]}," Expression Group Passive to_s":{"type":"method","name":"to_s","children":[],"call":[" quantifier_affix "," expressions join "," expressions "," implicit? "]}," Expression Group Passive initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Parser literal":{"type":"method","name":"literal","children":[],"call":[" node << ","Literal  new "," active_opts "," node "]}," Expression Base initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" quantifier= ","orig quantifier clone ","orig quantifier "," options= ","orig options dup ","orig options "," text= ","orig text dup ","orig text "]}," Expression Subexpression initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" expressions= ","orig expressions map ","orig expressions ","copy parent= ","exp clone tap ","exp clone "]}," Expression Quantifier initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["orig text dup ","orig text "]}," Expression Group Named initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["orig name dup ","orig name "]}," Expression Group Options initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" option_changes= ","orig option_changes dup ","orig option_changes "]}," Expression Conditional Expression initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" referenced_expression= ","orig referenced_expression dup ","orig referenced_expression "]}," Expression Conditional Condition initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" referenced_expression= ","orig referenced_expression dup ","orig referenced_expression "]}," Expression Backreference Base initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" referenced_expression= ","orig referenced_expression dup ","orig referenced_expression ","copied clear ","copied []= ","copied [] "," starts_at "," class "]}," Syntax V3_1_0 initialize":{"type":"method","name":"initialize","children":[],"call":[" implements "]}," Scanner parse_prop_map":{"type":"method","name":"parse_prop_map","children":[],"call":[]}," Syntax comparable":{"type":"method","name":"comparable","children":[],"call":["Gem Version  new ","(send\n  (send\n    (send\n      (lvar :name) :to_s) :scan\n    (regexp\n      (str \"\\\\d+\")\n      (regopt))) :<<\n  (int 99)) join ","name to_s scan << ","name to_s scan ","name to_s "]}," Syntax for":{"type":"method","name":"for","children":[],"call":[" version_class ","(or-asgn\n  (ivasgn :@alias_map)\n  (hash)) [] "]}," Syntax Base respond_to_missing?":{"type":"method","name":"respond_to_missing?","children":[],"call":[" class respond_to? "," class "]}," Syntax Base method_missing":{"type":"method","name":"method_missing","children":[],"call":[" class send "," class "," warn "," class respond_to? "]}," Syntax Base removed_features":{"type":"method","name":"removed_features","children":[],"call":[]}," Syntax Base added_features":{"type":"method","name":"added_features","children":[],"call":[]}," Syntax Base inherited":{"type":"method","name":"inherited","children":[],"call":["subclass features= ","(send\n  (send\n    (send nil :features) :to_h) :map) to_h ","v dup "," features to_h map "," features to_h "," features "]}," Scanner posix_classes":{"type":"method","name":"posix_classes","children":[],"call":[]}," Scanner UnknownPosixClassError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Parser increase_group_level":{"type":"method","name":"increase_group_level","children":[],"call":[" increase_group_level ","exp each ","exp terminal? ","exp quantifier level ","exp quantifier ","exp level "]}," Expression Subexpression intersperse":{"type":"method","name":"intersperse","children":[],"call":["(send\n  (lvar :expressions) :flat_map) slice ","expressions flat_map "]}," Expression Subexpression parts":{"type":"method","name":"parts","children":[],"call":[" expressions "]}," Expression Shared nesting_level=":{"type":"method","name":"nesting_level=","children":[],"call":["subexp nesting_level= ","lvl + "," each "," terminal? "," quantifier nesting_level= "," quantifier "]}," Expression Shared terminal?":{"type":"method","name":"terminal?","children":[],"call":[" respond_to? ! "," respond_to? "]}," Expression Shared coded_offset":{"type":"method","name":"coded_offset","children":[],"call":["@%d+%d % "," offset "]}," Expression Shared offset":{"type":"method","name":"offset","children":[],"call":[" full_length "," starts_at "]}," Expression Shared quantified?":{"type":"method","name":"quantified?","children":[],"call":[" quantifier nil? ! "," quantifier nil? "," quantifier "]}," Expression Shared quantifier_affix":{"type":"method","name":"quantifier_affix","children":[],"call":[" quantifier to_s "," quantifier ","expression_format != "," quantified? "]}," Expression Shared parts":{"type":"method","name":"parts","children":[],"call":[" text dup "," text "]}," Expression Shared to_s":{"type":"method","name":"to_s","children":[],"call":[" quantifier_affix "," parts join "," parts "," pre_quantifier_decoration ","buff << ","part to_s ","part custom_to_s_handling ! ","part custom_to_s_handling ","part instance_of? "," parts each_with_object "," dup "]}," Expression Shared full_length":{"type":"method","name":"full_length","children":[],"call":[" to_s length "," to_s "]}," Expression Shared base_length":{"type":"method","name":"base_length","children":[],"call":[" to_s length "," to_s "]}," Expression Shared starts_at":{"type":"method","name":"starts_at","children":[],"call":[" ts "]}," Expression Shared initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" quantifier= ","orig quantifier clone ","orig quantifier "," options= ","orig options dup ","orig options "," text= ","orig text dup ","orig text "," pre_quantifier_decorations= ","orig pre_quantifier_decorations map ","orig pre_quantifier_decorations "," parent= "]}," Expression Shared init_from_token_and_options":{"type":"method","name":"init_from_token_and_options","children":[],"call":[" options= "," nesting_level= "," conditional_level= ","token conditional_level "," set_level= ","token set_level "," level= ","token level "," te= ","token te "," ts= ","token ts "," text= ","token text "," token= ","token token "," type= ","token type "]}," Expression Shared included":{"type":"method","name":"included","children":[],"call":[]}," Expression SequenceOperation parts":{"type":"method","name":"parts","children":[],"call":[" intersperse "," text dup "," text "," expressions "]}," Expression Quantifier minmax":{"type":"method","name":"minmax","children":[],"call":["int_max to_i ","int_max empty? ","int_min to_i "," text [] "," text "," token "," text []  to_i "," text []  empty? "]}," Expression Quantifier deprecated_old_init":{"type":"method","name":"deprecated_old_init","children":[],"call":[" warn "," class "]}," Expression Shared ==":{"type":"method","name":"==","children":[],"call":["other options == "," options ","other options ","other to_s == "," to_s ","other to_s ","other class == "," class ","other class "," expressions == ","other expressions "," expressions "," terminal? "," options == "," quantifier == ","other quantifier "," quantifier "," text == ","other text "," text "," class == "]}," Expression Shared one_of?":{"type":"method","name":"one_of?","children":[],"call":[" raise ","scope class name ","scope class "," is? "," type? ","scope equal? "," one_of? ","scope [] "," type ","scope has_key? ","scope include? "," token "]}," Expression Shared is?":{"type":"method","name":"is?","children":[],"call":[" type? "," token == "," token ","test_token === "]}," Expression Shared type?":{"type":"method","name":"type?","children":[],"call":["test_types include? "," type "," Array map "," Array "," Array map  include? "]}," Expression Group Comment parts":{"type":"method","name":"parts","children":[],"call":[" text dup "," text "]}," Expression Group Passive parts":{"type":"method","name":"parts","children":[],"call":[" expressions "," implicit? "]}," Expression Group Base parts":{"type":"method","name":"parts","children":[],"call":[" expressions "," text dup "," text "]}," Expression Conditional Expression parts":{"type":"method","name":"parts","children":[],"call":[" intersperse "," branches "," condition "," text dup "," text "]}," Expression CharacterSet parts":{"type":"method","name":"parts","children":[],"call":[" expressions "," negated? "," text "]}," Expression CharacterSet Range parts":{"type":"method","name":"parts","children":[],"call":[" intersperse "," text dup "," text "," expressions "]}," Expression Shared token_class":{"type":"method","name":"token_class","children":[],"call":[" class token_class "," class "]}," Expression Shared ClassMethods token_class":{"type":"method","name":"token_class","children":[],"call":["Regexp Syntax Token  const_get "," name split [] "," name split "," name "," <= "," == "," < "]}," Expression Shared ClassMethods construct_defaults":{"type":"method","name":"construct_defaults","children":[],"call":["(send\n  (self) :==\n  (const nil :Root)) merge "," token_class "," < "," == "]}," Expression Shared ClassMethods construct":{"type":"method","name":"construct","children":[],"call":[" new "," raise ","attrs any? ","Regexp Token  new ","attrs delete ","Regexp TOKEN_KEYS  map "," construct_defaults merge "," construct_defaults "," construct_defaults merge  any? "," construct_defaults merge  delete "]}," Expression Shared quantifier=":{"type":"method","name":"quantifier=","children":[],"call":[]}," Expression Shared optional?":{"type":"method","name":"optional?","children":[],"call":[" quantifier min == "," quantifier min "," quantifier "," quantified? "]}," Expression human_name":{"type":"method","name":"human_name","children":[],"call":[" number "]}," Expression Shared human_name":{"type":"method","name":"human_name","children":[],"call":["(send nil :token) compact join tr ","(send nil :token) compact join ","(send nil :token) compact "," type "," token "]}," Expression Group Options quantify":{"type":"method","name":"quantify","children":[],"call":[" raise "," token == "," token "]}," Lexer emit":{"type":"method","name":"emit","children":[],"call":[" tokens << "," tokens "," collect_tokens "," block call "," block "]}," Expression Subexpression terminal?":{"type":"method","name":"terminal?","children":[],"call":[]}," Expression Shared referential?":{"type":"method","name":"referential?","children":[],"call":[]}," Expression Conditional Expression referential?":{"type":"method","name":"referential?","children":[],"call":[]}," Expression Conditional Condition referential?":{"type":"method","name":"referential?","children":[],"call":[]}," Expression Backreference Base referential?":{"type":"method","name":"referential?","children":[],"call":[]}," Scanner ValidationError types":{"type":"method","name":"types","children":[],"call":[]}," Scanner ValidationError for":{"type":"method","name":"for","children":[],"call":[]}," Expression Subexpression extract_quantifier_target":{"type":"method","name":"extract_quantifier_target","children":[],"call":["target pre_quantifier_decorations= "," raise ","pre_quantifier_decorations << ","exp text ","exp custom_to_s_handling= ","exp decorative? "," expressions reverse find "," expressions reverse "," expressions "]}," Expression Shared pre_quantifier_decoration":{"type":"method","name":"pre_quantifier_decoration","children":[],"call":[" pre_quantifier_decorations to_a join "," pre_quantifier_decorations to_a "," pre_quantifier_decorations ","expression_format == "]}," Expression Shared ends_at":{"type":"method","name":"ends_at","children":[],"call":[" ts + "," base_length "," full_length "," ts "]}," Expression SequenceOperation ts":{"type":"method","name":"ts","children":[],"call":["head ts "," expressions first "," expressions "," expressions first  ts "]}," Expression Sequence ts":{"type":"method","name":"ts","children":[],"call":["head ts "," expressions first "," expressions "," expressions first  ts "]}," Expression Quantifier derived_data":{"type":"method","name":"derived_data","children":[],"call":["mod == "," text [] "," text ","int_max to_i ","int_max empty? ","int_min to_i "," text []  == "," text []  to_i "," text []  empty? "]}," Expression Quantifier mode":{"type":"method","name":"mode","children":[],"call":[" derived_data [] "," derived_data "]}," Expression Quantifier max":{"type":"method","name":"max","children":[],"call":[" derived_data [] "," derived_data "]}," Expression Quantifier min":{"type":"method","name":"min","children":[],"call":[" derived_data [] "," derived_data "]}," Expression Subexpression each_expression_without_index":{"type":"method","name":"each_expression_without_index","children":[],"call":["exp each_expression_without_index ","exp terminal? ","block call "," each "]}," Expression Subexpression each_expression_with_index":{"type":"method","name":"each_expression_with_index","children":[],"call":["exp each_expression_with_index ","exp terminal? ","block call "," each_with_index "]}," Expression referential?":{"type":"method","name":"referential?","children":[],"call":[" class referential? "," class "]}," Expression decorative?":{"type":"method","name":"decorative?","children":[],"call":[" class decorative? "," class "]}," Expression comment?":{"type":"method","name":"comment?","children":[],"call":[" class comment? "," class "]}," Expression capturing?":{"type":"method","name":"capturing?","children":[],"call":[" class capturing? "," class "]}," Expression terminal?":{"type":"method","name":"terminal?","children":[],"call":[" class terminal? "," class "]}," Expression Shared pretty_print_instance_variables":{"type":"method","name":"pretty_print_instance_variables","children":[],"call":["(begin\n  (if\n    (send\n      (send\n        (send nil :text) :to_s) :empty?) nil\n    (sym :@text))) compact "," terminal? "," options empty? "," options "," quantified? "," text to_s empty? "," text to_s "," text "]}," Expression Shared pretty_print":{"type":"method","name":"pretty_print","children":[],"call":["q pp_object "]}," Expression Shared inspect":{"type":"method","name":"inspect","children":[],"call":["(dstr\n  (str \"#<\")\n  (begin\n    (send\n      (self) :class))) join "," instance_variable_get inspect "," instance_variable_get "," pretty_print_instance_variables map "," pretty_print_instance_variables "," class "]}," Expression parts":{"type":"method","name":"parts","children":[],"call":[" intersperse "," text dup "," text "," expressions "," implicit? "," branches "," condition "," negated? "]}," Expression Shared intersperse":{"type":"method","name":"intersperse","children":[],"call":["(send\n  (lvar :expressions) :flat_map) slice ","expressions flat_map "]}," Expression CharacterSet Range ts":{"type":"method","name":"ts","children":[],"call":["head ts "," expressions first "," expressions "," expressions first  ts "]}}