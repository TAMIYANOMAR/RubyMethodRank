{" PGconn parse_connect_args":{"type":"method","name":"parse_connect_args","children":[],"call":[]}," PGconn quote_connstr":{"type":"method","name":"quote_connstr","children":[],"call":[]}," PG connect":{"type":"method","name":"connect","children":[],"call":[]}," PG version_string":{"type":"method","name":"version_string","children":[],"call":[]}," Connection parse_connect_args":{"type":"method","name":"parse_connect_args","children":[],"call":[]}," Connection quote_connstr":{"type":"method","name":"quote_connstr","children":[],"call":[]}," Result values":{"type":"method","name":"values","children":[],"call":[" enum_for to_a "," enum_for "]}," Connection socket_io":{"type":"method","name":"socket_io","children":[],"call":["@socket_io autoclose= ","@socket_io respond_to? ","IO  for_fd "," socket ","IO  for_fd  autoclose= ","IO  for_fd  respond_to? "]}," Connection copy_data":{"type":"method","name":"copy_data","children":[],"call":[" raise "," get_result "," get_copy_data ","res result_status != ","res result_status "," get_last_result "," cancel "," put_copy_end ","%s while copy data: %s % ","err message ","err class name ","err class "," exec "," decoder_for_get_copy_data= "," decoder_for_get_copy_data "," encoder_for_put_copy_data= "," encoder_for_put_copy_data ","res ! "," nonblocking? ","PG NotAllCopyDataRetrieved  new ","PG NotInBlockingMode  new "," discard_results ","PG LostCopyState  new "," get_ get_last_result ult "," get_ exec ult "," get_last_result   get_last_result ult_status != "," exec   exec ult_status != "," get_last_result   get_last_result ult_status "," exec   exec ult_status "," get_last_ get_last_result ult "," get_last_ exec ult "," get_last_result  ! "," exec  ! "," discard_ get_last_result ults "," discard_ exec ults "]}," Connection conndefaults":{"type":"method","name":"conndefaults","children":[],"call":[" class conndefaults "," class "]}," TypeMapByColumn inspect":{"type":"method","name":"inspect","children":[],"call":["type_strings join "," class ","c format ","c name "," coders map "," coders ","c inspect_short "]}," TypeMapByColumn oids":{"type":"method","name":"oids","children":[],"call":["c oid "," coders map "," coders "]}," PG TextEncoder TimestampWithTimeZone encode":{"type":"method","name":"encode","children":[],"call":["value strftime ","value respond_to? "]}," PG TextEncoder TimestampWithoutTimeZone encode":{"type":"method","name":"encode","children":[],"call":["value strftime ","value respond_to? "]}," PG TextEncoder Date encode":{"type":"method","name":"encode","children":[],"call":["value strftime ","value respond_to? "]}," PG TextDecoder TimestampWithTimeZone decode":{"type":"method","name":"decode","children":[],"call":["Time  new ","(begin\n  (nth-ref 6)) to_r ","5 to_i ","4 to_i ","3 to_i ","2 to_i ","1 to_i ","string =~ "]}," PG TextDecoder TimestampWithoutTimeZone decode":{"type":"method","name":"decode","children":[],"call":["Time  new ","(begin\n  (nth-ref 6)) to_r ","5 to_i ","4 to_i ","3 to_i ","2 to_i ","1 to_i ","string =~ "]}," PG TextDecoder Date decode":{"type":"method","name":"decode","children":[],"call":["Time  new ","3 to_i ","2 to_i ","1 to_i ","string =~ "," Date  new "]}," Result inspect":{"type":"method","name":"inspect","children":[],"call":["str []= "," cmd_tuples "," nfields "," ntuples "," res_status "," result_status "," to_s "," cleared? "," to_s  []= "]}," Result map_types!":{"type":"method","name":"map_types!","children":[],"call":[" type_map= "]}," Connection conninfo_hash":{"type":"method","name":"conninfo_hash","children":[],"call":["hash []= ","info [] ","info [] to_sym "," conninfo each_with_object "," conninfo "]}," Connection conndefaults_hash":{"type":"method","name":"conndefaults_hash","children":[],"call":[" class conndefaults_hash "," class "]}," PG CopyCoder to_h":{"type":"method","name":"to_h","children":[],"call":[" merge! "," null_string "," delimiter "," type_map "]}," PG CompositeCoder inspect":{"type":"method","name":"inspect","children":[],"call":["str []= "," needs_quotation? "," elements_type inspect "," elements_type "]}," PG CompositeCoder to_h":{"type":"method","name":"to_h","children":[],"call":[" merge! "," delimiter "," needs_quotation? "," elements_type "]}," PG Coder inspect":{"type":"method","name":"inspect","children":[],"call":["str []= "," name inspect "," name "," format "," format == "," oid "," oid == "," to_s "," to_s  []= "]}," PG Coder marshal_load":{"type":"method","name":"marshal_load","children":[],"call":[" initialize ","Marshal  load "]}," PG Coder marshal_dump":{"type":"method","name":"marshal_dump","children":[],"call":["Marshal  dump "," to_h "]}," PG Coder ==":{"type":"method","name":"==","children":[],"call":[" to_h == ","v to_h "," to_h "," class == ","v class "," class "]}," PG Coder to_h":{"type":"method","name":"to_h","children":[],"call":[" name "," format "," oid "," flags "]}," PG Coder dup":{"type":"method","name":"dup","children":[],"call":[" class new "," to_h "," class "]}," PG Coder initialize":{"type":"method","name":"initialize","children":[],"call":[" send ","params each ","(or\n  (lvar :hash)\n  (lvar :kwargs)) each "," warn "," caller first "," caller "]}," PG Coder BinaryFormatting initialize":{"type":"method","name":"initialize","children":[],"call":["params merge ","Params  merge "," warn "," caller first "," caller ","hash empty? "]}," BasicTypeMapForQueries get_array_type":{"type":"method","name":"get_array_type","children":[],"call":["(send\n  (send\n    (send\n      (send\n        (lvar :elem) :class) :ancestors) :lazy) :map) find ","@array_encoders_by_klass [] ","elem class ancestors lazy map ","elem class ancestors lazy ","elem class ancestors ","elem class ","elem first ","elem kind_of? ","(send\n  (send\n    (send\n      (send\n        (lvar :elem first ) :class) :ancestors) :lazy) :map) find ","elem first  class ancestors lazy map ","elem first  class ancestors lazy ","elem first  class ancestors ","elem first  class ","elem first  first ","elem first  kind_of? "]}," BasicTypeMapForQueries array_encoders_by_klass":{"type":"method","name":"array_encoders_by_klass","children":[],"call":["h []= "," coder_by_name ","DEFAULT_ARRAY_TYPE_MAP  inject "]}," BasicTypeMapForQueries populate_encoder_list":{"type":"method","name":"populate_encoder_list","children":[],"call":[" []= ","coder oid= "," coder_by_name oid "," coder_by_name "," coder_by_name dup ","Array  === ","DEFAULT_TYPE_MAP  each "," raise ","@encode_array_as inspect ","PG TextEncoder Record  new ","PG TextEncoder JSON  new "," undefined ","oid_coder oid "," coder_by_name dup  oid= "," coder_by_name  oid= ","  coder_by_name dup _by_name oid ","  coder_by_name _by_name oid ","  coder_by_name dup _by_name ","  coder_by_name _by_name ","  coder_by_name dup _by_name dup ","  coder_by_name _by_name dup ","PG TextEn coder_by_name dup  Record  new ","PG TextEn coder_by_name  Record  new ","PG TextEn coder_by_name dup  JSON  new ","PG TextEn coder_by_name  JSON  new ","oid_ coder_by_name dup  oid ","oid_ coder_by_name  oid "," coder_by_name  oid "]}," BasicTypeMapForQueries coder_by_name":{"type":"method","name":"coder_by_name","children":[],"call":["@coder_maps [] [] coder_by_name ","@coder_maps [] [] ","@coder_maps [] "," check_format_and_direction ","@coder_maps map_for coder_by_name ","@coder_maps map_for "]}," BasicTypeMapForQueries initialize":{"type":"method","name":"initialize","children":[],"call":[" coder_by_name "," array_encoders_by_klass "," populate_encoder_list "," build_coder_maps "," init_encoders "," raise ","oid_name inspect "," proc "," method to_proc "," method "]}," BasicTypeMapBasedOnResult initialize":{"type":"method","name":"initialize","children":[],"call":[" add_coder ","(send\n  (ivar :@coder_maps) :map) flatten each ","(send\n  (ivar :@coder_maps) :map) flatten ","f [] coders ","f [] ","@coder_maps map "," build_coder_maps ","(send\n  (send\n    (ivar :@coder_maps) :each_format\n    (sym :encoder)) :flat_map) each ","f coders ","@coder_maps each_format flat_map ","@coder_maps each_format ","(send\n  (ivar : build_coder_maps ) :map) flatten each ","(send\n  (ivar : build_coder_maps ) :map) flatten "," build_coder_maps  map ","(send\n  (send\n    (ivar : build_coder_maps ) :each_format\n    (sym :encoder)) :flat_map) each "," build_coder_maps  each_format flat_map "," build_coder_maps  each_format "]}," BasicTypeMapForResults initialize":{"type":"method","name":"initialize","children":[],"call":[" default_type_map= ","WarningTypeMap  new ","f [] typenames_by_oid ","f [] ","@coder_maps map "," add_coder ","(send\n  (ivar :@coder_maps) :map) flatten each ","(send\n  (ivar :@coder_maps) :map) flatten ","f [] coders "," build_coder_maps ","@coder_maps typenames_by_oid ","(send\n  (send\n    (ivar :@coder_maps) :each_format\n    (sym :decoder)) :flat_map) each ","f coders ","@coder_maps each_format flat_map ","@coder_maps each_format ","f [] @coder_maps typenames_by_oid _by_oid "," build_coder_maps  map ","(send\n  (ivar : build_coder_maps ) :map) flatten each ","(send\n  (ivar : build_coder_maps ) :map) flatten "," build_coder_maps  typenames_by_oid ","@coder_maps @coder_maps typenames_by_oid _by_oid ","(send\n  (send\n    (ivar : build_coder_maps ) :each_format\n    (sym :decoder)) :flat_map) each "," build_coder_maps  each_format flat_map "," build_coder_maps  each_format "]}," BasicTypeMapForResults WarningTypeMap typecast_result_value":{"type":"method","name":"typecast_result_value","children":[],"call":["@already_warned [] []= ","@already_warned [] ","STDERR  puts ","@typenames_by_oid [] [] inspect ","@typenames_by_oid [] [] ","@typenames_by_oid [] ","@already_warned [] [] ","result ftype ","result fformat ","$stderr puts "," warn ","@typenames_by_oid [] inspect "," frozen? ","@already_warned dig ","@typenames_by_result ftype  [] [] inspect ","@typenames_by_result ftype  [] [] ","@typenames_by_result ftype  [] ","result fresult fformat  ","@typenames_by_result ftype  [] inspect "]}," BasicTypeMapForResults WarningTypeMap initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","Hash  new "]}," BasicTypeRegistry alias_type":{"type":"method","name":"alias_type","children":[],"call":["@coders_by_name [] [] delete ","@coders_by_name [] [] ","@coders_by_name [] ","@coders_by_name [] [] []= ","@coders_by_name [] [] [] ","(sym :encoder) each ","(sym :@coders_by_name [] [] [] oder) each "]}," BasicTypeRegistry register_type":{"type":"method","name":"register_type","children":[],"call":[" register_coder ","decoder_class new ","encoder_class new ","decoder_class new freeze ","encoder_class new freeze "]}," BasicTypeRegistry check_format_and_direction":{"type":"method","name":"check_format_and_direction","children":[],"call":[" raise ","Invalid direction %p % ","ValidDirections  [] ","Invalid format value %p % ","ValidFormats  [] "]}," BasicTypeRegistry build_coder_maps":{"type":"method","name":"build_coder_maps","children":[],"call":["h [] []= ","CoderMap  new ","CODERS_BY_NAME  [] [] ","CODERS_BY_NAME  [] ","h [] ","(array\n  (int 0)\n  (sym :encoder)\n  (const\n    (const\n      (const nil :PG) :TextEncoder) :Array)) inject ","connection exec "," supports_ranges? "]}," BasicTypeRegistry supports_ranges?":{"type":"method","name":"supports_ranges?","children":[],"call":["connection server_version >= ","connection server_version "]}," BasicTypeRegistry CoderMap coder_by_oid":{"type":"method","name":"coder_by_oid","children":[],"call":["@coders_by_oid [] "]}," BasicTypeRegistry CoderMap coder_by_name":{"type":"method","name":"coder_by_name","children":[],"call":["@coders_by_name [] "]}," BasicTypeRegistry CoderMap initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","t [] ","t [] to_i ","result inject ","t oid ","@coders inject ","t name ","coder_map values ","coder_map []= ","coder oid ","coder needs_quotation= ","DONT_QUOTE_TYPES  [] ! ","DONT_QUOTE_TYPES  [] ","elements_coder name ","coder elements_type= ","coder format= ","coder name= ","row [] ","coder oid= ","row [] to_i ","arraycoder new ","coder_map [] ","arrays each ","result group_by ","coders_by_name [] dup ","coders_by_name [] ","(send\n  (lvar :leaves) :find_all) each ","coders_by_name key? ","leaves find_all ","row [] == ","leaves partition ","nodes partition ","row [] to_i == ","result partition ","(send\n  (lvar :nodes) :find_all) each ","nodes find_all "," freeze ","(send\n  (ivar :@coders) :inject\n  (hash)) freeze ","coder_map values freeze ","coder freeze ","coder_map values  inject ","coder_map values freeze  inject ","@arraycoder new s inject ","@coders_by_name [] dup s inject ","arraycoder new _map values ","coders_by_name [] dup _map values ","arraycoder new _map []= ","coders_by_name [] dup _map []= ","arraycoder new  oid ","coders_by_name [] dup  oid ","arraycoder new  needs_quotation= ","coders_by_name [] dup  needs_quotation= ","elements_arraycoder new  name ","elements_coders_by_name [] dup  name ","coder_map []  name ","arraycoder new  elements_type= ","coders_by_name [] dup  elements_type= ","arraycoder new  format= ","coders_by_name [] dup  format= ","arraycoder new  name= ","coders_by_name [] dup  name= ","arraycoder new  oid= ","coders_by_name [] dup  oid= ","arrayarraycoder new  new ","arraycoders_by_name [] dup  new ","arraycoder new _map [] ","coders_by_name [] dup _map [] ","arraycoder new s_by_name [] dup ","coders_by_name [] dup s_by_name [] dup ","arraycoder new s_by_name [] ","coders_by_name [] dup s_by_name [] ","arraycoder new s_by_name key? ","coders_by_name [] dup s_by_name key? ","(send\n  (ivar :coder_map values ) :inject\n  (hash)) freeze ","(send\n  (ivar :coder_map values freeze ) :inject\n  (hash)) freeze ","(send\n  (ivar :@arraycoder new s) :inject\n  (hash)) freeze ","(send\n  (ivar :@coders_by_name [] dup s) :inject\n  (hash)) freeze ","arraycoder new _map values freeze ","coders_by_name [] dup _map values freeze ","arraycoder new  freeze ","coders_by_name [] dup  freeze "]}," PG TextEncoder JSON encode":{"type":"method","name":"encode","children":[],"call":[" JSON  dump "," JSON  generate "]}," PG TextDecoder JSON decode":{"type":"method","name":"decode","children":[],"call":[" JSON  load "," JSON  parse "]}," Connection ssl_attributes":{"type":"method","name":"ssl_attributes","children":[],"call":["h []= "," ssl_attribute "," ssl_attribute_names each with_object "," ssl_attribute_names each "," ssl_attribute_names "]}," Tuple each_key":{"type":"method","name":"each_key","children":[],"call":[" field_map each_key "," field_map ","fn each "," field_names "," field_names  each "]}," Tuple keys":{"type":"method","name":"keys","children":[],"call":[" field_map keys freeze "," field_map keys "," field_map "," field_names "]}," Tuple has_key?":{"type":"method","name":"has_key?","children":[],"call":[" field_map has_key? "," field_map "]}," Tuple inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (self) :map) join ","v inspect "," map "," class "]}," PG TextEncoder Inet encode":{"type":"method","name":"encode","children":[],"call":["s << << ","prefix to_s ","s << ","prefix != ","default_prefix - ","Math  log to_i ","Math  log ","(send\n  (send\n    (send\n      (lvar :range) :end) :to_i) :-\n  (send\n    (send\n      (lvar :range) :begin) :to_i)) + ","range end to_i - ","range begin to_i ","range begin ","range end to_i ","range end ","value to_range ","value prefix ","value respond_to? ","value to_s ","value family == ","value family ","value to_s  << << ","default_prefix -  to_s ","value prefix  to_s ","prefix to_value to_s  ","value to_s  << ","default_prefix -  != ","value prefix  != ","default_default_prefix -  - ","default_value prefix  - ","(send\n  (send\n    (send\n      (lvar :value to_range ) :end) :to_i) :-\n  (send\n    (send\n      (lvar :value to_range ) :begin) :to_i)) + ","(value to_s end\n  (value to_s end\n    (value to_s end\n      (lvar :range) :end) :to_i) :-\n  (value to_s end\n    (value to_s end\n      (lvar :range) :begin) :to_i)) + ","value to_range  end to_i - ","value to_range  begin to_i ","value to_range  begin ","value to_range  end to_i ","value to_range  end ","value to_value to_range  ","value default_prefix -  ","value value prefix  ","value revalue to_s pond_to? ","value to_value to_s  "]}," PG TextEncoder Numeric encode":{"type":"method","name":"encode","children":[],"call":["value to_s ","value is_a? "]}," PG TextEncoder TimestampUtc encode":{"type":"method","name":"encode","children":[],"call":["value utc strftime ","value utc ","value respond_to? "]}," PG TextDecoder TimestampLocal initialize":{"type":"method","name":"initialize","children":[],"call":["params merge ","PG Coder TIMESTAMP_DB_LOCAL  | "," warn "," caller first "," caller ","hash empty? "]}," PG TextDecoder TimestampUtcToLocal initialize":{"type":"method","name":"initialize","children":[],"call":["params merge ","PG Coder TIMESTAMP_DB_UTC  | "," warn "," caller first "," caller ","hash empty? "]}," PG TextDecoder TimestampUtc initialize":{"type":"method","name":"initialize","children":[],"call":["params merge ","PG Coder TIMESTAMP_DB_UTC  | "," warn "," caller first "," caller ","hash empty? "]}," Connection async_api=":{"type":"method","name":"async_api=","children":[],"call":[" singleton_class alias_method "," singleton_class "," singleton_class remove_method "," method_defined? ","REDIRECT_CLASS_METHODS  each "," alias_method "," remove_method ","REDIRECT_METHODS  each "," async_send_api= "]}," PG BinaryDecoder TimestampLocal initialize":{"type":"method","name":"initialize","children":[],"call":["params merge ","PG Coder TIMESTAMP_DB_LOCAL  | "," warn "," caller first "," caller ","hash empty? "]}," PG BinaryDecoder TimestampUtcToLocal initialize":{"type":"method","name":"initialize","children":[],"call":["params merge ","PG Coder TIMESTAMP_DB_UTC  | "," warn "," caller first "," caller ","hash empty? "]}," PG BinaryDecoder TimestampUtc initialize":{"type":"method","name":"initialize","children":[],"call":["params merge ","PG Coder TIMESTAMP_DB_UTC  | "," warn "," caller first "," caller ","hash empty? "]}," Result field_names_as":{"type":"method","name":"field_names_as","children":[],"call":[" field_name_type= "]}," PG RecordCoder to_h":{"type":"method","name":"to_h","children":[],"call":[" merge! "," type_map "]}," PG Coder inspect_short":{"type":"method","name":"inspect_short","children":[],"call":[" class name "," class "," name "," respond_to? "," format to_s "," format "]}," BasicTypeMapForQueries init_encoders":{"type":"method","name":"init_encoders","children":[],"call":[" coder_by_name "," populate_encoder_list "," []= "," coders each "," coders "]}," BasicTypeMapForQueries encode_array_as=":{"type":"method","name":"encode_array_as=","children":[],"call":[" init_encoders "," raise ","pg_type inspect "]}," BasicTypeRegistry register_coder":{"type":"method","name":"register_coder","children":[],"call":["h [] []= ","h [] ","coder respond_to? "," raise ","coder inspect ","coder name ","@coders_by_name [] ","coder format "]}," Connection async_send_api=":{"type":"method","name":"async_send_api=","children":[],"call":[" alias_method "," undef_method "," method_defined? ","REDIRECT_SEND_METHODS  each "]}," Connection ping":{"type":"method","name":"ping","children":[],"call":[" sync_ping ","(send\n  (const nil :Thread) :new) value ","Thread  new ","Fiber  scheduler ","Fiber  respond_to? "]}," Connection new":{"type":"method","name":"new","children":[],"call":["conn send "," raise ","conn error_message ","conn status == ","conn status "," connect_start ","PG Connection  connect_start ","conn finish "," block_given? "," connect_to_hosts "," connect_start  send ","PG Connection  connect_start  send "," connect_to_hosts  send "," connect_start  error_message ","PG Connection  connect_start  error_message "," connect_to_hosts  error_message "," connect_start  status == ","PG Connection  connect_start  status == "," connect_to_hosts  status == "," connect_start  status ","PG Connection  connect_start  status "," connect_to_hosts  status ","  connect_start ect_start "," PG Connection  connect_start ect_start ","  connect_to_hosts ect_start ","PG Connection   connect_start ect_start ","PG Connection  PG Connection  connect_start ect_start ","PG Connection   connect_to_hosts ect_start "," connect_start  finish ","PG Connection  connect_start  finish "," connect_to_hosts  finish ","  connect_start ect_to_hosts "," PG Connection  connect_start ect_to_hosts ","  connect_to_hosts ect_to_hosts "]}," Connection async_connect_or_reset":{"type":"method","name":"async_connect_or_reset","children":[],"call":[" set_default_encoding "," flush_data= "," sync_setnonblocking "," raise "," error_message "," status == "," status "," send ","socket wait_writable ","socket wait_readable ","poll_status == "," socket_io "," finish "," socket_io wait_writable "," socket_io wait_readable ","PG ConnectionBad  new ","(const\n  (const nil :PG) :CONNECTION_BAD) include? "," port "," host "," hostaddr "," respond_to? "," class send "," class ","IO  select "," socket_io wait ","IO WRITABLE  | ","IO READABLE  | ","timeout >= ","timeout ! ","Process  clock_gettime ","timeo + ","(lvar :timeo) max ","timeo > "," conninfo_hash [] to_i "," conninfo_hash [] "," conninfo_hash ","(lvar :timeo) min ","stop_time - ","timeo * + ","timeo * "," conninfo_hash [] to_s count + "," conninfo_hash [] to_s count "," conninfo_hash [] to_s "," socket_io  wait_writable "," socket_io  wait_readable "," send  == ","  socket_io _io ","  socket_io _io wait_writable ","  socket_io _io wait_readable ","  socket_io _io wait ","(lvar :timeo) max ut >= "," conninfo_hash [] to_i ut >= ","(lvar :timeo) min  >= ","(lvar :timeo) max ut ! "," conninfo_hash [] to_i ut ! ","(lvar :timeo) min  ! ","(lvar :timeo) max  + "," conninfo_hash [] to_i  + ","(lvar :(lvar :timeo) max ) max ","(lvar : conninfo_hash [] to_i ) max ","(lvar :timeo) max  > "," conninfo_hash [] to_i  > ","(lvar :(lvar :timeo) max ) min ","(lvar : conninfo_hash [] to_i ) min ","timeo +  - ","timeo * +  - ","(lvar :timeo) max  * + "," conninfo_hash [] to_i  * + ","(lvar :timeo) max  * "," conninfo_hash [] to_i  * "]}," Connection cancel":{"type":"method","name":"cancel","children":[],"call":["err to_s ","cl close ","cl read ","cl write "," socket_io remote_address connect "," socket_io remote_address "," socket_io ","cl autoclose= ","UNIXSocket  new ","adr unix_path ","TCPSocket  new ","adr ip_port ","adr ip_address ","adr ip? ","cl2 remote_address ","cl2 autoclose= ","Socket  for_fd "," socket_io fileno ","RUBY_ENGINE  == ","cl wait_readable ","cl read_nonblock ","cl wait_writable ","cl write_nonblock ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value ","ra connect ","Thread  new ","RUBY_PLATFORM  =~ ","Fiber  scheduler ","Fiber  respond_to? ","(int 16) pack "," backend_key "," backend_pid "," socket_io remote_address connect   socket_io remote_address connect ose ","UNIXSocket  new  UNIXSocket  new ose ","TCPSocket  new  TCPSocket  new ose ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  (send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value ose "," socket_io remote_address connect  read ","UNIXSocket  new  read ","TCPSocket  new  read ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  read "," socket_io remote_address connect  write ","UNIXSocket  new  write ","TCPSocket  new  write ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  write "," socket_io remote_address connect  auto socket_io remote_address connect ose= ","UNIXSocket  new  autoUNIXSocket  new ose= ","TCPSocket  new  autoTCPSocket  new ose= ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  auto(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value ose= ","cl2 remote_address  unix_path ","cl2 remote_address  ip_port ","cl2 remote_address  ip_address ","cl2 remote_address  ip? "," socket_io remote_address connect 2 remote_address ","UNIXSocket  new 2 remote_address ","TCPSocket  new 2 remote_address ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value 2 remote_address ","Socket  for_fd  remote_address "," socket_io remote_address connect 2 auto socket_io remote_address connect ose= ","UNIXSocket  new 2 autoUNIXSocket  new ose= ","TCPSocket  new 2 autoTCPSocket  new ose= ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value 2 auto(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value ose= ","Socket  for_fd  autoclose= "," socket_io remote_address connect  wait_readable ","UNIXSocket  new  wait_readable ","TCPSocket  new  wait_readable ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  wait_readable "," socket_io remote_address connect  read_nonblock ","UNIXSocket  new  read_nonblock ","TCPSocket  new  read_nonblock ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  read_nonblock "," socket_io remote_address connect  wait_writable ","UNIXSocket  new  wait_writable ","TCPSocket  new  wait_writable ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  wait_writable "," socket_io remote_address connect  write_nonblock ","UNIXSocket  new  write_nonblock ","TCPSocket  new  write_nonblock ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  write_nonblock "]}," Connection reset":{"type":"method","name":"reset","children":[],"call":[" async_connect_or_reset "," reset_start "]}," Connection encrypt_password":{"type":"method","name":"encrypt_password","children":[],"call":[" sync_encrypt_password "," exec getvalue "," exec "]}," Connection put_copy_end":{"type":"method","name":"put_copy_end","children":[],"call":[" flush "," sync_put_copy_end "]}," Connection put_copy_data":{"type":"method","name":"put_copy_data","children":[],"call":[" flush "," sync_put_copy_data ","(op-asgn\n  (ivasgn :@calls_to_put_copy_data) :+\n  (int 1)) > "]}," Connection isnonblocking":{"type":"method","name":"isnonblocking","children":[],"call":[]}," Connection setnonblocking":{"type":"method","name":"setnonblocking","children":[],"call":[" sync_setnonblocking "," flush_data= ","enabled ! "," singleton_class async_send_api= "," singleton_class "]}," Connection get_copy_data":{"type":"method","name":"get_copy_data","children":[],"call":[" consume_input "," socket_io wait_readable "," socket_io ","(lvasgn :res\n  (send nil :sync_get_copy_data\n    (true)\n    (lvar :decoder))) == "," sync_get_copy_data ","(lvasgn : sync_get_copy_data \n  (send nil :sync_get_copy_data\n    (true)\n    (lvar :decoder))) == "]}," Connection get_result":{"type":"method","name":"get_result","children":[],"call":[" sync_get_result "," block "]}," Connection transaction":{"type":"method","name":"transaction","children":[],"call":[" exec "," raise "," block "," cancel "," transaction_status != "," transaction_status "," transaction_status == "]}," Connection connect_string_to_hash":{"type":"method","name":"connect_string_to_hash","children":[],"call":[]}," Connection connect_hash_to_string":{"type":"method","name":"connect_hash_to_string","children":[],"call":[]}," BasicTypeRegistry define_default_types":{"type":"method","name":"define_default_types","children":[],"call":[" register_type "," alias_type "]}," BasicTypeRegistry coders_for":{"type":"method","name":"coders_for","children":[],"call":["@coders_by_name [] "," check_format_and_direction "]}," BasicTypeRegistry initialize":{"type":"method","name":"initialize","children":[],"call":[]}," BasicTypeRegistry Checker build_coder_maps":{"type":"method","name":"build_coder_maps","children":[],"call":["PG BasicTypeRegistry CoderMapsBundle  new "," raise ","conn_or_maps is_a? ","PG BasicTypeRegistry CoderMapsBundle  new freeze "]}," BasicTypeRegistry Checker check_format_and_direction":{"type":"method","name":"check_format_and_direction","children":[],"call":[" raise ","Invalid direction %p % ","ValidDirections  [] ","Invalid format value %p % ","ValidFormats  [] "]}," BasicTypeRegistry CoderMapsBundle map_for":{"type":"method","name":"map_for","children":[],"call":["@maps [] [] ","@maps [] "]}," BasicTypeRegistry CoderMapsBundle each_format":{"type":"method","name":"each_format","children":[],"call":["f [] ","@maps map "]}," BasicTypeRegistry CoderMapsBundle initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","t [] ","t [] to_i ","result inject ","h [] []= ","CoderMap  new ","h [] ","registry coders_for ","(array\n  (int 0)\n  (sym :encoder)\n  (const\n    (const\n      (const nil :PG) :TextEncoder) :Array)) inject ","connection exec to_a ","connection exec "," freeze "," init_maps ","result freeze ","connection exec to_a  inject ","connection exec to_a  freeze "]}," BasicTypeMapForQueries undefined":{"type":"method","name":"undefined","children":[],"call":["@if_undefined call "]}," Connection async_ping":{"type":"method","name":"async_ping","children":[],"call":[" sync_ping ","(send\n  (const nil :Thread) :new) value ","Thread  new ","Fiber  scheduler ","Fiber  respond_to? "]}," Connection async_connect":{"type":"method","name":"async_connect","children":[],"call":["conn send "," raise ","conn error_message ","conn status == ","conn status ","PG Connection  connect_start ","PG Connection  connect_start  send ","PG Connection  connect_start  error_message ","PG Connection  connect_start  status == ","PG Connection  connect_start  status ","PG Connection  PG Connection  connect_start ect_start "]}," Connection async_cancel":{"type":"method","name":"async_cancel","children":[],"call":["err to_s ","cl close ","cl read ","cl write "," socket_io remote_address connect "," socket_io remote_address "," socket_io ","cl autoclose= ","UNIXSocket  new ","adr unix_path ","TCPSocket  new ","adr ip_port ","adr ip_address ","adr ip? ","cl2 remote_address ","cl2 autoclose= ","Socket  for_fd "," socket_io fileno ","RUBY_ENGINE  == ","cl wait_readable ","cl read_nonblock ","cl wait_writable ","cl write_nonblock ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value ","ra connect ","Thread  new ","RUBY_PLATFORM  =~ ","Fiber  scheduler ","Fiber  respond_to? ","(int 16) pack "," backend_key "," backend_pid "," socket_io remote_address connect   socket_io remote_address connect ose ","UNIXSocket  new  UNIXSocket  new ose ","TCPSocket  new  TCPSocket  new ose ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  (send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value ose "," socket_io remote_address connect  read ","UNIXSocket  new  read ","TCPSocket  new  read ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  read "," socket_io remote_address connect  write ","UNIXSocket  new  write ","TCPSocket  new  write ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  write "," socket_io remote_address connect  auto socket_io remote_address connect ose= ","UNIXSocket  new  autoUNIXSocket  new ose= ","TCPSocket  new  autoTCPSocket  new ose= ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  auto(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value ose= ","cl2 remote_address  unix_path ","cl2 remote_address  ip_port ","cl2 remote_address  ip_address ","cl2 remote_address  ip? "," socket_io remote_address connect 2 remote_address ","UNIXSocket  new 2 remote_address ","TCPSocket  new 2 remote_address ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value 2 remote_address ","Socket  for_fd  remote_address "," socket_io remote_address connect 2 auto socket_io remote_address connect ose= ","UNIXSocket  new 2 autoUNIXSocket  new ose= ","TCPSocket  new 2 autoTCPSocket  new ose= ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value 2 auto(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value ose= ","Socket  for_fd  autoclose= "," socket_io remote_address connect  wait_readable ","UNIXSocket  new  wait_readable ","TCPSocket  new  wait_readable ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  wait_readable "," socket_io remote_address connect  read_nonblock ","UNIXSocket  new  read_nonblock ","TCPSocket  new  read_nonblock ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  read_nonblock "," socket_io remote_address connect  wait_writable ","UNIXSocket  new  wait_writable ","TCPSocket  new  wait_writable ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  wait_writable "," socket_io remote_address connect  write_nonblock ","UNIXSocket  new  write_nonblock ","TCPSocket  new  write_nonblock ","(send\n  (const nil :Thread) :new\n  (send\n    (send nil :socket_io) :remote_address)) value  write_nonblock "]}," Connection async_reset":{"type":"method","name":"async_reset","children":[],"call":[" async_connect_or_reset "," reset_start "]}," Connection async_encrypt_password":{"type":"method","name":"async_encrypt_password","children":[],"call":[" sync_encrypt_password "," exec getvalue "," exec "]}," Connection async_put_copy_end":{"type":"method","name":"async_put_copy_end","children":[],"call":[" flush "," sync_put_copy_end "]}," Connection async_put_copy_data":{"type":"method","name":"async_put_copy_data","children":[],"call":[" flush "," sync_put_copy_data "]}," Connection async_isnonblocking":{"type":"method","name":"async_isnonblocking","children":[],"call":[]}," Connection async_setnonblocking":{"type":"method","name":"async_setnonblocking","children":[],"call":[" sync_setnonblocking "," flush_data= ","enabled ! "," singleton_class async_send_api= "," singleton_class "]}," Connection async_get_copy_data":{"type":"method","name":"async_get_copy_data","children":[],"call":[" consume_input "," socket_io wait_readable "," socket_io ","(lvasgn :res\n  (send nil :sync_get_copy_data\n    (true)\n    (lvar :decoder))) == "," sync_get_copy_data ","(lvasgn : sync_get_copy_data \n  (send nil :sync_get_copy_data\n    (true)\n    (lvar :decoder))) == "]}," Connection async_get_result":{"type":"method","name":"async_get_result","children":[],"call":[" sync_get_result "," block "]}," BasicTypeRegistry register_default_types":{"type":"method","name":"register_default_types","children":[],"call":[" register_type "," alias_type "]}," PG Error initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Connection host_is_named_pipe?":{"type":"method","name":"host_is_named_pipe?","children":[],"call":["host_string =~ ","RUBY_PLATFORM  =~ ","host_string start_with? ","host_string empty? "]}," Connection connect_internal":{"type":"method","name":"connect_internal","children":[],"call":[" raise ","errors << ","(and\n  (lvar :conn)\n  (send\n    (array\n      (const\n        (const nil :PG) :CONNECTION_AWAITING_RESPONSE)) :include?\n    (send\n      (lvar :conn) :instance_variable_get\n      (sym :@last_status)))) ! ","(const\n  (const nil :PG) :CONNECTION_AWAITING_RESPONSE) include? ","conn instance_variable_get ","conn send ","PG ConnectionBad  new ","conn error_message ","conn status == ","conn status "," connect_start ","(and\n  (lvar : connect_start )\n  (send\n    (array\n      (const\n        (const nil :PG) :CONNECTION_AWAITING_RESPONSE)) :include?\n    (send\n      (lvar : connect_start ) :instance_variable_get\n      (sym :@last_status)))) ! "," connect_start  instance_variable_get "," connect_start  send "," connect_start  error_message "," connect_start  status == "," connect_start  status ","  connect_start ect_start "]}," Connection connect_to_hosts":{"type":"method","name":"connect_to_hosts","children":[],"call":[" raise ","errors join "," connect_internal ","iopts merge ","iports [] ","addrs each ","Addrinfo  getaddrinfo map ","Addrinfo  getaddrinfo ","(send\n  (const nil :Thread) :new) value ","Thread  new ","RUBY_VERSION  < ","Fiber  scheduler ","Fiber  respond_to? "," host_is_named_pipe? ","ihosts each_with_index ","ihosts size ","iports size ","iports size != ","iports * ","iports size == ","iopts [] split ","iopts [] ","oopts []= ","ihosts [] ","ihostaddrs each_with_index ","ihostaddrs size ","ihosts size != ","(send\n  (send\n    (const\n      (const nil :PG) :Connection) :conndefaults) :each_with_object\n  (hash)) merge ","o []= ","h [] ","h [] to_sym ","PG Connection  conndefaults each_with_object ","PG Connection  conndefaults ","PG Connection  conninfo_parse each_with_object ","PG Connection  conninfo_parse "," parse_connect_args ","iopts [] empty? ! ","iopts [] empty? ","conn send ","conn error_message ","conn status == ","conn status "," connect_start ","iopts merge! ","(send\n  (lvar :dests) :map) join ","d [] ","dests map ","hostaddrs map ","ihosts each_with_index flat_map ","PG  library_version >= ","PG  library_version ","  connect_internal onne connect_internal t_internal ","  connect_start ect_internal ","(send\n  (send\n    (const\n      (const nil :PG) :Connection) :conndefaults) :each_with_object\n  (hash)) merge  merge ","iports *  [] ","iopts [] split  [] ","addrs ea connect_internal h ","(send\n  (const nil :Thread) :new) value  each ","(send\n  ( connect_internal onst nil :Thread) :new) value ","Fiber  s connect_internal heduler ","ihosts ea connect_internal h_with_index ","iopts [] split  each_with_index ","iopts [] split  size ","iports *  size ","iports *  size != ","iopts [] split  size != ","iports *  * ","iopts [] split  * ","iports *  size == ","iopts [] split  size == ","(send\n  (send\n    (const\n      (const nil :PG) :Connection) :conndefaults) :each_with_object\n  (hash)) merge  [] split ","(send\n  (send\n    (const\n      (const nil :PG) :Connection) :conndefaults) :each_with_object\n  (hash)) merge  [] ","iopts merge  []= ","ihostaddrs ea connect_internal h_with_index ","ihost(send\n  (const nil :Thread) :new) value  each_with_index ","i(send\n  (const nil :Thread) :new) value  each_with_index ","ihost(send\n  (const nil :Thread) :new) value  size ","i(send\n  (const nil :Thread) :new) value  size ","(send\n  (send\n    ( connect_internal onst\n      ( connect_internal onst nil :PG) :Conne connect_internal tion) : connect_internal onndefaults) :ea connect_internal h_with_obje connect_internal t\n  (hash)) merge ","(send\n  (send\n    (const\n      (const nil :PG) :Connection) : connect_start defaults) :each_with_object\n  (hash)) merge ","PG Conne connect_internal tion   connect_internal onndefaults ea connect_internal h_with_obje connect_internal t ","PG Connection   connect_start defaults each_with_object ","PG Conne connect_internal tion   connect_internal onndefaults ","PG Connection   connect_start defaults ","PG Conne connect_internal tion   connect_internal onninfo_parse ea connect_internal h_with_obje connect_internal t ","PG Connection   connect_start info_parse each_with_object ","PG Conne connect_internal tion   connect_internal onninfo_parse ","PG Connection   connect_start info_parse "," parse_ connect_internal onne connect_internal t_args "," parse_ connect_start ect_args ","(send\n  (send\n    (const\n      (const nil :PG) :Connection) :conndefaults) :each_with_object\n  (hash)) merge  [] empty? ! ","(send\n  (send\n    (const\n      (const nil :PG) :Connection) :conndefaults) :each_with_object\n  (hash)) merge  [] empty? "," connect_internal onn send "," connect_start  send "," connect_internal onn error_message "," connect_start  error_message "," connect_internal onn status == "," connect_start  status == "," connect_internal onn status "," connect_start  status ","  connect_internal onne connect_internal t_start ","  connect_start ect_start ","(send\n  (send\n    (const\n      (const nil :PG) :Connection) :conndefaults) :each_with_object\n  (hash)) merge  merge! ","host(send\n  (const nil :Thread) :new) value  map ","(send\n  (const nil :Thread) :new) value  map ","ihosts ea connect_internal h_with_index flat_map ","iopts [] split  each_with_index flat_map "]}," Connection inspect":{"type":"method","name":"inspect","children":[],"call":["str []= ","stats join "," user "," port "," host ","stats << "," decoder_for_get_copy_data to_s "," decoder_for_get_copy_data "," encoder_for_put_copy_data to_s "," encoder_for_put_copy_data "," type_map_for_queries to_s "," type_map_for_queries "," type_map_for_queries is_a? "," type_map_for_results to_s "," type_map_for_results "," type_map_for_results is_a? "," get_client_encoding "," get_client_encoding != ","PG  const_get == "," pipeline_status ","PG  const_get ","PG  constants grep find ","PG  constants grep ","PG  constants "," pipeline_status != "," respond_to? "," isnonblocking "," transaction_status "," transaction_status != "," status "," status != "," finished? "," to_s "," to_s  []= "]}," PG make_shareable":{"type":"method","name":"make_shareable","children":[],"call":[]}," PG BinaryEncoder TimestampLocal initialize":{"type":"method","name":"initialize","children":[],"call":[" warn "," caller first "," caller ","hash empty? "]}," PG BinaryEncoder TimestampUtc initialize":{"type":"method","name":"initialize","children":[],"call":[" warn "," caller first "," caller ","hash empty? "]}," BasicTypeRegistry CoderMapsBundle init_maps":{"type":"method","name":"init_maps","children":[],"call":["(send\n  (lvar :result) :inject\n  (hash)) freeze ","h []= ","t [] ","t [] to_i ","result inject ","(send\n  (block\n    (send\n      (array\n        (array\n          (int 0)\n          (sym :encoder)\n          (const\n            (const\n              (const nil :PG) :TextEncoder) :Array))\n        (array\n          (int 0)\n          (sym :decoder)\n          (const\n            (const\n              (const nil :PG) :TextDecoder) :Array))\n        (array\n          (int 1)\n          (sym :encoder)\n          (nil))\n        (array\n          (int 1)\n          (sym :decoder)\n          (nil))) :inject\n      (array))\n    (args\n      (arg :h)\n      (mlhs\n        (arg :format)\n        (arg :direction)\n        (arg :arraycoder)))\n    (begin\n      (lvasgn :coders\n        (or\n          (send\n            (lvar :registry) :coders_for\n            (lvar :format)\n            (lvar :direction))\n          (hash)))\n      (or-asgn\n        (send\n          (lvar :h) :[]\n          (lvar :format))\n        (hash))\n      (send\n        (send\n          (lvar :h) :[]\n          (lvar :format)) :[]=\n        (lvar :direction)\n        (send\n          (const nil :CoderMap) :new\n          (lvar :result)\n          (lvar :coders)\n          (lvar :format)\n          (lvar :arraycoder)))\n      (lvar :h))) :each) freeze ","h freeze ","(send\n  (array\n    (array\n      (int 0)\n      (sym :encoder)\n      (const\n        (const\n          (const nil :PG) :TextEncoder) :Array))\n    (array\n      (int 0)\n      (sym :decoder)\n      (const\n        (const\n          (const nil :PG) :TextDecoder) :Array))\n    (array\n      (int 1)\n      (sym :encoder)\n      (nil))\n    (array\n      (int 1)\n      (sym :decoder)\n      (nil))) :inject\n  (array)) each ","h [] []= ","CoderMap  new ","h [] ","registry coders_for ","(array\n  (int 0)\n  (sym :encoder)\n  (const\n    (const\n      (const nil :PG) :TextEncoder) :Array)) inject "]}," BasicTypeMapForQueries raise_undefined_type":{"type":"method","name":"raise_undefined_type","children":[],"call":[" raise ","oid_name inspect "]}," PG TruffleFixWarn warn":{"type":"method","name":"warn","children":[],"call":[]}}