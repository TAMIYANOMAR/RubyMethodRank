{" CodeRay NotStreamableError to_s":{"type":"method","name":"to_s","children":[],"call":["%s is not Streamable! % ","@obj class "]}," CodeRay NotStreamableError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," CodeRay get_scanner_options":{"type":"method","name":"get_scanner_options","children":[],"call":["options fetch "]}," CodeRay encoder":{"type":"method","name":"encoder","children":[],"call":["Encoders  [] new ","Encoders  [] ","CodeRay Encoders  [] new ","CodeRay Encoders  [] "]}," CodeRay encode_file":{"type":"method","name":"encode_file","children":[],"call":[" encode_tokens "," scan_file "," get_scanner_options "," auto "," encode_ scan_file  "]}," CodeRay encode_tokens":{"type":"method","name":"encode_tokens","children":[],"call":[" encoder encode_tokens "," encoder "]}," CodeRay encode":{"type":"method","name":"encode","children":[],"call":[" encoder encode "," encoder "]}," CodeRay encode_stream":{"type":"method","name":"encode_stream","children":[],"call":[" encoder encode_stream "," encoder "]}," CodeRay scan_stream":{"type":"method","name":"scan_stream","children":[],"call":[" scan ","options []= "]}," CodeRay scan_file":{"type":"method","name":"scan_file","children":[],"call":[" scan ","FileType  fetch "," require ","lang == ","IO  read ","File  read ","CodeRay FileType  fetch ","FileType  fetch  == ","CodeRay FileType  fetch  == "]}," CodeRay scan":{"type":"method","name":"scan","children":[],"call":["scanner tokenize ","Scanners  [] new ","Scanners  [] ","TokensProxy  new "," scanner tokenize "," scanner ","CodeRay TokensProxy  new ","Scanners  [] new  tokenize "," Scanners  [] new  tokenize "," Scanners  [] new  "]}," CodeRay Scanners Ruby scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << "," raise_inspect ","error token %p in line %d % "," line ","tokens last ","type == ","type ! ","last_token_dot == ","fancy_allowed == ","regexp_allowed == "," getch "," scan ","state == ","StringState  new "," [] "," raise ","Unknown fancy string: %%%p % "," k ","FancyStringType  fetch ","heredocs << ","quote != ","QUOTE_TO_TYPE  [] "," [] == ","match [] ","match [] == ","match != ","REGEXP_ALLOWED  [] ","DEF_NEW_STATE  [] ","IDENT_KIND  [] ","states pop ","depth == ","states empty? ","match == ","match =~ ","match !~ ","else-case _ reached, because case %p was not handled % "," matched [] chr "," matched [] "," matched ","match << "," eos? ","heredocs empty? ","state type ","heredocs shift "," unscan ","m == "," bol? ","else-case \" reached; %p not handled, state = %p % ","state paren_depth ","state paren ","else-case # reached; #%p not handled % "," peek ","match + ","states push "," peek [] ","state delim ","state interpreted ","text [] ","text scan ","text is_a? ","modifiers index ","modifiers empty? "," eos? ! ","state type == ","state paren_depth > "," getch + "," scan_until ","state heredoc ","match empty? ","state pattern ","state instance_of? ","state next_state= ","delim == ","delim chr ","last_token_dot ! "," check ","match [] ! ","state next_state ","states pop type ","states << ","state is_a? ","Error token %p in line %d % ","kind == ","kind ! "," StringState  new "," FancyStringType  fetch "," QUOTE_TO_TYPE  [] "," REGEXP_ALLOWED  [] "," DEF_NEW_STATE  [] "," match? ! "," match? "," IDENT_KIND  [] ","this_block first ","this_block size > ","this_block size ","inline_block_stack pop ","inline_block_stack empty? ","inline_block_stack << "," getch to_s ","value_expected == ","(str \"else-case _ reached, because case %p was\\n\") % "," [] [] == "," [] [] ","match index ","match size > ","match size ","unicode ! "," KEYWORDS_EXPECTING_VALUE  [] "," string encoding name == "," string encoding name "," string encoding "," string "," string respond_to? "," check size > "," check size "," string respond_to? ! "," exist? "," string= "," string encode "," string encoding == ","value_expected != "," scan_rest ","encoder end_group ","(or-asgn\n  (lvasgn :heredocs)\n  (array)) unshift ","options [] ","encoder text_token ","state opening_paren ","encoder begin_group ","Unknown state: %p % "," class StringState  new "," class "," FANCY_STRING_INTERPRETED  [] "," FANCY_STRING_KIND  [] ","match size == ","inline_block_curly_depth == ","method_call_expected ! ","method_call_expected == ","value_expected ! "," KEYWORD_NEW_STATE  [] ","(or\n  (send\n    (lvar :match) :[]\n    (regexp\n      (str \"[!?]$\")\n      (regopt)))\n  (send nil :match?\n    (regexp\n      (str \"\\\\(\")\n      (regopt)))) ! ","heredocs dup ","heredocs is_a? "," [] ! ! "," [] ! "," class StringState  simple_key_pattern ","QUOTE_TO_TYPE  []  == ","IDENT_KIND  []  == "," QUOTE_TO_TYPE  []  == "," IDENT_KIND  []  == ","QUOTE_TO_TYPE  []  ! ","IDENT_KIND  []  ! "," QUOTE_TO_TYPE  []  ! "," IDENT_KIND  []  ! ","last_token_dot ==  == ","fancy_allowed ==  == ","regexp_allowed ==  == ","REGEXP_ALLOWED  []  == ","m ==  == ","StringState  new  == ","DEF_NEW_STATE  []  == ","heredocs shift  == ","state next_state  == "," StringState  new  == "," DEF_NEW_STATE  []  == ","this_block first  == "," class StringState  new  == "," KEYWORD_NEW_STATE  []  == ","StringState  new s << "," StringState  new s << ","heredocs dup  << "," []  != "," getch  [] "," scan  [] "," getch +  [] ","delim chr  [] "," getch to_s  [] ","match [] atch [] "," getch atch [] "," getch  [] == "," scan  [] == "," getch +  [] == ","delim chr  [] == "," getch to_s  [] == ","match [] atch [] == "," getch atch [] == "," getch  != "," scan  != "," getch +  != ","delim chr  != "," getch to_s  != ","match [] atch != "," getch atch != ","StringState  new s pop ","DEF_NEW_STATE  [] s pop ","heredocs shift s pop ","state next_state s pop "," StringState  new s pop "," DEF_NEW_STATE  [] s pop ","this_block first s pop "," class StringState  new s pop "," KEYWORD_NEW_STATE  [] s pop ","StringState  new s empty? ","DEF_NEW_STATE  [] s empty? ","heredocs shift s empty? ","state next_state s empty? "," StringState  new s empty? "," DEF_NEW_STATE  [] s empty? ","this_block first s empty? "," class StringState  new s empty? "," KEYWORD_NEW_STATE  [] s empty? ","states ematch [] pty? ","states e getch pty? "," getch  == "," scan  == "," getch +  == ","delim chr  == "," getch to_s  == ","match [] atch == "," getch atch == "," getch  =~ "," scan  =~ "," getch +  =~ ","delim chr  =~ "," getch to_s  =~ ","match [] atch =~ "," getch atch =~ "," getch  !~ "," scan  !~ "," getch +  !~ ","delim chr  !~ "," getch to_s  !~ ","match [] atch !~ "," getch atch !~ ","  getch ed [] chr ","  scan ed [] chr ","  getch + ed [] chr "," delim chr ed [] chr ","  getch to_s ed [] chr "," match [] atched [] chr ","  getch atched [] chr ","  getch ed [] ","  scan ed [] ","  getch + ed [] "," delim chr ed [] ","  getch to_s ed [] "," match [] atched [] ","  getch atched [] ","  getch ed ","  scan ed ","  getch + ed "," delim chr ed ","  getch to_s ed "," match [] atched ","  getch atched "," getch  << "," scan  << "," getch +  << ","delim chr  << "," getch to_s  << ","match [] atch << "," getch atch << ","heredocs ematch [] pty? ","heredocs e getch pty? ","heredocs dup  empty? ","StringState  new  type ","DEF_NEW_STATE  []  type ","heredocs shift  type ","state next_state  type "," StringState  new  type "," DEF_NEW_STATE  []  type ","this_block first  type "," class StringState  new  type "," KEYWORD_NEW_STATE  []  type ","state QUOTE_TO_TYPE  []  ","state IDENT_KIND  []  ","state  QUOTE_TO_TYPE  []  ","state  IDENT_KIND  []  ","StringState  new s shift "," StringState  new s shift ","heredocs dup  shift ","match []  == ","else-case \" reached; %p not handled, StringState  new  = %p % ","else-case \" reached; %p not handled, DEF_NEW_STATE  []  = %p % ","else-case \" reached; %p not handled, heredocs shift  = %p % ","else-case \" reached; %p not handled, state next_state  = %p % ","else-case \" reached; %p not handled,  StringState  new  = %p % ","else-case \" reached; %p not handled,  DEF_NEW_STATE  []  = %p % ","else-case \" reached; %p not handled, this_block first  = %p % ","else-case \" reached; %p not handled,  class StringState  new  = %p % ","else-case \" reached; %p not handled,  KEYWORD_NEW_STATE  []  = %p % ","StringState  new  paren_depth ","DEF_NEW_STATE  []  paren_depth ","heredocs shift  paren_depth ","state next_state  paren_depth "," StringState  new  paren_depth "," DEF_NEW_STATE  []  paren_depth ","this_block first  paren_depth "," class StringState  new  paren_depth "," KEYWORD_NEW_STATE  []  paren_depth ","StringState  new  paren ","DEF_NEW_STATE  []  paren ","heredocs shift  paren ","state next_state  paren "," StringState  new  paren "," DEF_NEW_STATE  []  paren ","this_block first  paren "," class StringState  new  paren "," KEYWORD_NEW_STATE  []  paren "," getch  + "," scan  + "," getch +  + ","delim chr  + "," getch to_s  + ","match [] atch + "," getch atch + ","StringState  new s push ","DEF_NEW_STATE  [] s push ","heredocs shift s push ","state next_state s push "," StringState  new s push "," DEF_NEW_STATE  [] s push ","this_block first s push "," class StringState  new s push "," KEYWORD_NEW_STATE  [] s push ","StringState  new  delim ","DEF_NEW_STATE  []  delim ","heredocs shift  delim ","state next_state  delim "," StringState  new  delim "," DEF_NEW_STATE  []  delim ","this_block first  delim "," class StringState  new  delim "," KEYWORD_NEW_STATE  []  delim ","state  []  ","state match []  ","state delimatch []  ","state deli getch  ","StringState  new  interpreted ","DEF_NEW_STATE  []  interpreted ","heredocs shift  interpreted ","state next_state  interpreted "," StringState  new  interpreted "," DEF_NEW_STATE  []  interpreted ","this_block first  interpreted "," class StringState  new  interpreted "," KEYWORD_NEW_STATE  []  interpreted ","match [] odifiers index "," getch odifiers index "," scan  index ","match [] odifiers ematch [] pty? "," getch odifiers e getch pty? "," scan  empty? ","StringState  new  type == ","DEF_NEW_STATE  []  type == ","heredocs shift  type == ","state next_state  type == "," StringState  new  type == "," DEF_NEW_STATE  []  type == ","this_block first  type == "," class StringState  new  type == "," KEYWORD_NEW_STATE  []  type == ","state QUOTE_TO_TYPE  []  == ","state IDENT_KIND  []  == ","state  QUOTE_TO_TYPE  []  == ","state  IDENT_KIND  []  == ","StringState  new  paren_depth > ","DEF_NEW_STATE  []  paren_depth > ","heredocs shift  paren_depth > ","state next_state  paren_depth > "," StringState  new  paren_depth > "," DEF_NEW_STATE  []  paren_depth > ","this_block first  paren_depth > "," class StringState  new  paren_depth > "," KEYWORD_NEW_STATE  []  paren_depth > ","StringState  new  heredoc ","DEF_NEW_STATE  []  heredoc ","heredocs shift  heredoc ","state next_state  heredoc "," StringState  new  heredoc "," DEF_NEW_STATE  []  heredoc ","this_block first  heredoc "," class StringState  new  heredoc "," KEYWORD_NEW_STATE  []  heredoc ","state StringState  new  ","state  StringState  new  "," getch  empty? "," getch +  empty? ","delim chr  empty? "," getch to_s  empty? ","match [] atch ematch [] pty? "," getch atch e getch pty? ","StringState  new  pattern ","DEF_NEW_STATE  []  pattern ","heredocs shift  pattern ","state next_state  pattern "," StringState  new  pattern "," DEF_NEW_STATE  []  pattern ","this_block first  pattern "," class StringState  new  pattern "," KEYWORD_NEW_STATE  []  pattern ","StringState  new  instance_of? ","DEF_NEW_STATE  []  instance_of? ","heredocs shift  instance_of? ","state next_state  instance_of? "," StringState  new  instance_of? "," DEF_NEW_STATE  []  instance_of? ","this_block first  instance_of? "," class StringState  new  instance_of? "," KEYWORD_NEW_STATE  []  instance_of? ","StringState  new  next_StringState  new = ","DEF_NEW_STATE  []  next_DEF_NEW_STATE  [] = ","heredocs shift  next_heredocs shift = ","state next_state  next_state next_state = "," StringState  new  next_ StringState  new = "," DEF_NEW_STATE  []  next_ DEF_NEW_STATE  [] = ","this_block first  next_this_block first = "," class StringState  new  next_ class StringState  new = "," KEYWORD_NEW_STATE  []  next_ KEYWORD_NEW_STATE  [] = "," []  == ","delimatch []  == ","deli getch  == "," []  chr ","match []  chr ","delimatch []  chr ","deli getch  chr ","last_token_dot ==  ! "," getch  [] ! "," scan  [] ! "," getch +  [] ! ","delim chr  [] ! "," getch to_s  [] ! ","match [] atch [] ! "," getch atch [] ! ","StringState  new  next_StringState  new  ","DEF_NEW_STATE  []  next_DEF_NEW_STATE  []  ","heredocs shift  next_heredocs shift  ","state next_state  next_state next_state  "," StringState  new  next_ StringState  new  "," DEF_NEW_STATE  []  next_ DEF_NEW_STATE  []  ","this_block first  next_this_block first  "," class StringState  new  next_ class StringState  new  "," KEYWORD_NEW_STATE  []  next_ KEYWORD_NEW_STATE  []  ","StringState  new s pop type ","DEF_NEW_STATE  [] s pop type ","heredocs shift s pop type ","state next_state s pop type "," StringState  new s pop type "," DEF_NEW_STATE  [] s pop type ","this_block first s pop type "," class StringState  new s pop type "," KEYWORD_NEW_STATE  [] s pop type ","states pop QUOTE_TO_TYPE  []  ","states pop IDENT_KIND  []  ","states pop  QUOTE_TO_TYPE  []  ","states pop  IDENT_KIND  []  ","DEF_NEW_STATE  [] s << ","heredocs shift s << ","state next_state s << "," DEF_NEW_STATE  [] s << ","this_block first s << "," class StringState  new s << "," KEYWORD_NEW_STATE  [] s << ","StringState  new  is_a? ","DEF_NEW_STATE  []  is_a? ","heredocs shift  is_a? ","state next_state  is_a? "," StringState  new  is_a? "," DEF_NEW_STATE  []  is_a? ","this_block first  is_a? "," class StringState  new  is_a? "," KEYWORD_NEW_STATE  []  is_a? "," FANCY_STRING_KIND  []  == "," FANCY_STRING_KIND  []  ! ","  getch ? ! ","  scan ? ! ","  getch + ? ! "," delim chr ? ! ","  getch to_s ? ! "," match [] atch? ! ","  getch atch? ! ","  getch ? ","  scan ? ","  getch + ? "," delim chr ? ","  getch to_s ? "," match [] atch? ","  getch atch? ","inline_block_stack pop  first ","inline_block_stack pop  size > ","inline_block_stack pop  size ","inline_block_stack ematch [] pty? ","inline_block_stack e getch pty? ","value_expected ==  == "," check  == "," getch  index "," getch +  index ","delim chr  index "," getch to_s  index ","match [] atch index "," getch atch index "," getch  size > "," scan  size > "," getch +  size > ","delim chr  size > "," getch to_s  size > ","match [] atch size > "," getch atch size > "," getch  size "," scan  size "," getch +  size ","delim chr  size "," getch to_s  size ","match [] atch size "," getch atch size "," exist?  ! "," string encoding namatch [] e == "," string encoding na getch e == "," string encoding namatch [] e "," string encoding na getch e ","value_expected ==  != "," check  != ","(or-asgn\n  (lvasgn :StringState  new s)\n  (array)) unshift ","(or-asgn\n  (lvasgn : StringState  new s)\n  (array)) unshift ","(or-asgn\n  (lvasgn :heredocs dup )\n  (array)) unshift ","StringState  new  opening_paren ","DEF_NEW_STATE  []  opening_paren ","heredocs shift  opening_paren ","state next_state  opening_paren "," StringState  new  opening_paren "," DEF_NEW_STATE  []  opening_paren ","this_block first  opening_paren "," class StringState  new  opening_paren "," KEYWORD_NEW_STATE  []  opening_paren ","Unknown StringState  new : %p % ","Unknown DEF_NEW_STATE  [] : %p % ","Unknown heredocs shift : %p % ","Unknown state next_state : %p % ","Unknown  StringState  new : %p % ","Unknown  DEF_NEW_STATE  [] : %p % ","Unknown this_block first : %p % ","Unknown  class StringState  new : %p % ","Unknown  KEYWORD_NEW_STATE  [] : %p % "," getch  size == "," scan  size == "," getch +  size == ","delim chr  size == "," getch to_s  size == ","match [] atch size == "," getch atch size == ","match [] ethod_call_expected ! "," getch ethod_call_expected ! "," []  ! ","match [] ethod_call_expected == "," getch ethod_call_expected == ","value_expected ==  ! "," check  ! ","(or\n  (send\n    (lvar : getch ) :[]\n    (regexp\n      (str \"[!?]$\")\n      (regopt)))\n  (send nil : getch ?\n    (regexp\n      (str \"\\\\(\")\n      (regopt)))) ! ","(or\n  (send\n    (lvar : scan ) :[]\n    (regexp\n      (str \"[!?]$\")\n      (regopt)))\n  (send nil : scan ?\n    (regexp\n      (str \"\\\\(\")\n      (regopt)))) ! ","(or\n  (send\n    (lvar : getch + ) :[]\n    (regexp\n      (str \"[!?]$\")\n      (regopt)))\n  (send nil : getch + ?\n    (regexp\n      (str \"\\\\(\")\n      (regopt)))) ! ","(or\n  (send\n    (lvar :delim chr ) :[]\n    (regexp\n      (str \"[!?]$\")\n      (regopt)))\n  (send nil :delim chr ?\n    (regexp\n      (str \"\\\\(\")\n      (regopt)))) ! ","(or\n  (send\n    (lvar : getch to_s ) :[]\n    (regexp\n      (str \"[!?]$\")\n      (regopt)))\n  (send nil : getch to_s ?\n    (regexp\n      (str \"\\\\(\")\n      (regopt)))) ! ","(or\n  (send\n    (lvar :match [] atch) :[]\n    (regexp\n      (str \"[!?]$\")\n      (regopt)))\n  (send nil :match [] atch?\n    (regexp\n      (str \"\\\\(\")\n      (regopt)))) ! ","(or\n  (send\n    (lvar : getch atch) :[]\n    (regexp\n      (str \"[!?]$\")\n      (regopt)))\n  (send nil : getch atch?\n    (regexp\n      (str \"\\\\(\")\n      (regopt)))) ! ","StringState  new s dup "," StringState  new s dup ","heredocs dup  dup ","StringState  new s is_a? "," StringState  new s is_a? ","heredocs dup  is_a? "," class StringState  simatch [] ple_key_pattern "," class StringState  si getch ple_key_pattern "]}," CodeRay Scanners Plaintext scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << "," scan_until "," scan_rest ","encoder text_token "," string "]}," CodeRay Scanners Ruby StringState initialize":{"type":"method","name":"initialize","children":[],"call":["STRING_PATTERN  [] ","HEREDOC_PATTERN  [] ","heredoc == ","CLOSING_PAREN  [] "," heredoc_pattern "," heredoc_STRING_PATTERN  []  "," heredoc_HEREDOC_PATTERN  []  "," heredoc_ heredoc_pattern  "]}," CodeRay Scanners Delphi scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << "," raise ","kind == "," matched ","else case ' reached; %p not handled. % "," peek "," scan ","state == "," getch "," [] ","IDENT_KIND  [] "," eos? "," raise_inspect ","Error token %p in line %d % "," line ","kind ! ","NAME_FOLLOWS  [] ","last_token == ","encoder end_group ","encoder text_token ","encoder begin_group "," skip ","IDENT_KIND  []  == ","  scan ed ","  skip ed ","IDENT_KIND  []  ! "]}," CodeRay Scanners C scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << "," raise ","kind == "," matched "," getch ","match index "," scan ","state == ","else case \" reached; %p not handled. % "," peek "," [] == "," [] ","match [] == ","match [] ","match << "," check ","IDENT_KIND  [] "," scan_until "," eos? "," raise_inspect ","Error token %p in line %d % "," line ","kind ! ","in_preproc_line ! ","match == ","match =~ ","match != ","encoder end_group ","encoder text_token ","encoder begin_group ","match empty? ","IDENT_KIND  []  == ","  scan ed "," scan  index "," scan  [] == "," scan  [] "," scan  << ","IDENT_KIND  []  ! "," scan  == "," scan  =~ "," scan  != "," scan  empty? "]}," CodeRay Scanners Scanner raise_inspect":{"type":"method","name":"raise_inspect","children":[],"call":[" raise ","(str \"\\n\") % "," string [] "," pos "," string "," pos - "," eos? "," bol? "," matched "," line ","(send\n  (send\n    (lvar :tokens) :last\n    (int 10)) :map) join ","t inspect ","tokens last map ","tokens last ","File  basename "," caller [] "," caller ","tokens size "," column "," binary_string [] "," binary_string ","tokens respond_to? ","SCAN_ERROR_MESSAGE  % "," raise_inspect_arguments "]}," CodeRay Scanners Scanner scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":[" raise "," class "]}," CodeRay Scanners Scanner line":{"type":"method","name":"line","children":[],"call":[" string [] count + "," string [] count "," string [] "," pos "," string "," binary_string [] count + "," binary_string [] count "," binary_string [] "," binary_string ","pos <= "]}," CodeRay Scanners Scanner each":{"type":"method","name":"each","children":[],"call":[" tokens each "," tokens "," raise ","@options [] "]}," CodeRay Scanners Scanner tokenize":{"type":"method","name":"tokenize","children":[],"call":[" scan_tokens "," reset ","@options [] ","@options merge "," string= ","@tokens split_into_parts ","part size ","source map ","source is_a? "," raise_inspect ","e backtrace ","e message ","Error in %s#scan_tokens, initial state was: %p % "," state "," class "," class normalize ","source join ","@tokens scanner= ","@tokens respond_to? ","Tokens  new ","options [] "," raise "," set_string_from_source "," set_tokens_from_options ","@@options merge  [] ","@@options merge  merge ","e Error in %s#scan_tokens, initial state was: %p %  ","@options merge  [] "," set_tokens_from_@options merge  "]}," CodeRay Scanners Scanner initialize":{"type":"method","name":"initialize","children":[],"call":["Tokens  new "," warn ","@options [] "," block_given? ","TokenStream  new "," raise "," kind_of? ","code gsub "," class == "," class "," class DEFAULT_OPTIONS  merge "," setup ","options [] ","Scanner  normify ","@tokens scanner= ","@tokens respond_to? "," class normalize "," class DEFAULT_OPTIONS  merge  [] ","Tokens  new  scanner= ","TokenStream  new  scanner= ","options []  scanner= ","Tokens  new  respond_to? ","TokenStream  new  respond_to? ","options []  respond_to? "]}," CodeRay Scanners Scanner streamable?":{"type":"method","name":"streamable?","children":[],"call":[" is_a? "]}," CodeRay Scanners Scanner WordList mind_case":{"type":"method","name":"mind_case","children":[],"call":["word dup ","word downcase "]}," CodeRay Scanners Scanner WordList case_ignore?":{"type":"method","name":"case_ignore?","children":[],"call":[]}," CodeRay Scanners Scanner WordList add":{"type":"method","name":"add","children":[],"call":[" []= "," mind_case ","words each "]}," CodeRay Scanners Scanner WordList include?":{"type":"method","name":"include?","children":[],"call":[" has_key? "," [] "]}," CodeRay Scanners Scanner WordList initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","h fetch ","k downcase "," raise "," class name "," class "]}," require_plugin":{"type":"method","name":"require_plugin","children":[],"call":["host load_plugin "," raise ","host_id inspect ","PluginHost  host_by_id ","path split ","host load ","PluginHost  host_by_id  load_plugin ","PluginHost  host_by_id _id inspect ","PluginHost  PluginHost  host_by_id _by_id ","PluginHost  host_by_id  load "]}," Plugin plugin_host":{"type":"method","name":"plugin_host","children":[],"call":[" const_set "," raise ","host class ","host is_a? ! ","host is_a? "]}," Plugin register_for":{"type":"method","name":"register_for","children":[],"call":[" plugin_host register "," plugin_host "]}," Plugin included":{"type":"method","name":"included","children":[],"call":[" warn "," name "]}," PluginHost validate_id":{"type":"method","name":"validate_id","children":[],"call":[" raise ","id class ","id downcase to_sym ","id downcase ","id [] == ","id [] ","id is_a? ","id to_sym ","id nil? "]}," PluginHost path_to":{"type":"method","name":"path_to","children":[],"call":["File  join "," plugin_path "]}," PluginHost fetch":{"type":"method","name":"fetch","children":[],"call":[" plugin_hash fetch "," validate_id "," plugin_hash "]}," PluginHost []":{"type":"method","name":"[]","children":[],"call":[" plugin_hash [] "," validate_id "," plugin_hash ","plugin is_a? ","  plugin_hash [] _hash [] ","  validate_id _hash [] ","  plugin_hash [] _hash ","  validate_id _hash "," plugin_hash []  is_a? "," validate_id  is_a? "]}," PluginHost load_all":{"type":"method","name":"load_all","children":[],"call":[" load_plugin "," all_plugin_names "," load "," list "]}," PluginHost all_plugin_names":{"type":"method","name":"all_plugin_names","children":[],"call":["File  basename ","Dir  [] map ","Dir  [] "," path_to ","(send\n  (send\n    (const nil :Dir) :[]\n    (send nil :path_to\n      (str \"*\"))) :select) map ","File  basename [] ","Dir  [] select "]}," PluginHost register":{"type":"method","name":"register","children":[],"call":[" plugin_hash []= "," validate_id "," plugin_hash "," raise ","id class ","id is_a? "]}," PluginHost plugin_hash":{"type":"method","name":"plugin_hash","children":[],"call":[" create_plugin_hash "]}," PluginHost create_plugin_hash":{"type":"method","name":"create_plugin_hash","children":[],"call":["h [] "," raise ","id inspect "," name ","h has_key? "," require ","$stderr puts ","Loading plugin:  + "," path_to "," validate_id ","Hash  new ","Could not load plugin %p: %s % ","h []= "," validate_id  inspect ","  path_to _to "," val validate_id ate_ validate_id  "]}," PluginHost host_id":{"type":"method","name":"host_id","children":[],"call":[" name "," const_defined? "]}," PluginHost plugin_path":{"type":"method","name":"plugin_path","children":[],"call":["File  join ","args empty? "," load_map ","File  expand_path "]}," PluginHost plugin_host_id":{"type":"method","name":"plugin_host_id","children":[],"call":[" raise "," lang class "," lang ","host_id is_a? "]}," PluginHost host_by_id":{"type":"method","name":"host_by_id","children":[],"call":["PLUGIN_HOSTS_BY_ID  [] ","PLUGIN_HOSTS_BY_ID  replace ","h fetch ","h []= ","host host_id ","Hash  new ","PLUGIN_HOSTS_BY_ID  default_proc "]}," PluginHost included":{"type":"method","name":"included","children":[],"call":[" warn "," name "]}," PluginHost extended":{"type":"method","name":"extended","children":[],"call":["PLUGIN_HOSTS  << "]}," String gzip!":{"type":"method","name":"gzip!","children":[],"call":[" replace "," gzip "]}," String gzip":{"type":"method","name":"gzip","children":[],"call":["GZip  gzip "]}," String gunzip!":{"type":"method","name":"gunzip!","children":[],"call":[" replace "," gunzip "]}," String gunzip":{"type":"method","name":"gunzip","children":[],"call":["GZip  gunzip "]}," GZip gzip":{"type":"method","name":"gzip","children":[],"call":[]}," GZip gunzip":{"type":"method","name":"gunzip","children":[],"call":[]}," FileType fetch":{"type":"method","name":"fetch","children":[],"call":[" raise ","Could not determine type of %p. % "," block_given? "," [] "," warn ","Could not determine  []  of %p. % "]}," FileType shebang":{"type":"method","name":"shebang","children":[],"call":["first_line [] ","f gets ","File  open ","f gets  [] "]}," FileType []":{"type":"method","name":"[]","children":[],"call":[" shebang ","TypeFromName  [] ","name downcase ","TypeFromExt  [] ","ext downcase ","ext sub! ","File  extname ","File  basename ","File  basename  downcase ","File  extname  downcase ","File  extname  sub! ","File  File  extname name ","File  extFile  basename  ","File  baseFile  basename  "]}," CodeRay Encoders YAML compile":{"type":"method","name":"compile","children":[],"call":["tokens to_a to_yaml ","tokens to_a "," require "]}," CodeRay Encoders Tokens token":{"type":"method","name":"token","children":[],"call":["@out << ","CodeRay Tokens  write_token "]}," CodeRay Encoders Text finish":{"type":"method","name":"finish","children":[],"call":["@out chomp "," chomp "]}," CodeRay Encoders Text token":{"type":"method","name":"token","children":[],"call":["@out << ","text + ","text respond_to? ","text is_a? "]}," CodeRay Encoders Text setup":{"type":"method","name":"setup","children":[],"call":["options [] "]}," CodeRay Encoders Statistic finish":{"type":"method","name":"finish","children":[],"call":["STATS  % ","(send\n  (ivar :@type_stats) :delete_if) size ","k is_a? ","@type_stats delete_if ","(send\n  (block\n    (send\n      (ivar :@type_stats) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (send\n      (send\n        (lvar :v) :count) :-@)) :map) join ","TOKEN_TYPES_ROW  % ","v size ","100.0 * / ","100.0 * ","v count ","(send\n  (ivar :@type_stats) :sort_by) map ","v count -@ ","@type_stats sort_by ","stat count to_f ","stat count ","stat size ","@type_stats each ","all size ","all count ","@type_stats [] ","(send\n  (block\n    (send\n      (ivar :@type_stats) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (array\n      (send\n        (send\n          (lvar :v) :count) :-@)\n      (send\n        (lvar :k) :to_s))) :map) join ","k to_s ","@out << ","@type_stats []  size ","@type_stats []  count "]}," CodeRay Encoders Statistic token":{"type":"method","name":"token","children":[],"call":["@type_stats [] count ","@type_stats [] ","text size ","@type_stats [] size ","type == ","text is_a? "]}," CodeRay Encoders Statistic generate":{"type":"method","name":"generate","children":[],"call":[]}," CodeRay Encoders Statistic setup":{"type":"method","name":"setup","children":[],"call":["h []= ","TypeStats  new ","Hash  new "]}," CodeRay Encoders Null token":{"type":"method","name":"token","children":[],"call":[]}," CodeRay Encoders HTML Output Template Simple `":{"type":"method","name":"`","children":[],"call":["Template  new "]}," CodeRay Encoders HTML Output Template apply":{"type":"method","name":"apply","children":[],"call":[" raise ","Template target <%%%p%%> not found % ","Template  new ","$` + + ","$` + "," =~ ","Regexp  new ","Regexp  escape ","Template Regexp  new  <%%%p%%> not found % "]}," CodeRay Encoders HTML Output Template wrap!":{"type":"method","name":"wrap!","children":[],"call":[]}," CodeRay Encoders HTML Output numerize":{"type":"method","name":"numerize","children":[],"call":[" clone numerize! "," clone "]}," CodeRay Encoders HTML Output numerize!":{"type":"method","name":"numerize!","children":[],"call":[" raise ","Unknown value %p for mode: :inline or :table expected % "," wrap_in! "," gsub! ","DIV_TABLE  apply ","line_numbers gsub! ","line_numbers << ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (lvar :line_count))) to_a map join ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (lvar :line_count))) to_a map ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (lvar :line_count))) to_a ","start + "," wrap! ","line_number rjust ","bolding call ","(send\n  (lvar :start) :+\n  (lvar :line_count)) to_s size ","(send\n  (lvar :start) :+\n  (lvar :line_count)) to_s "," [] != "," [] "," count ","Invalid value %p for :bolding; :no_bolding or Integer expected. % ","line to_s ","line % == ","line % "," proc ","bold_every is_a? ","bold_every == ","options fetch ","DEFAULT_OPTIONS  [] ","Can't numerize, :wrap must be in %p, but is %p % ","options [] ","NUMERIZABLE_WRAPPINGS  include? ","Invalid value %p for :line_number_start; Integer expected. % ","start is_a? ","allowed_wrappings include? ","allowed_wrappings == ","NUMERIZABLE_WRAPPINGS  [] ","DEFAULT_OPTIONS  merge ","Unknown value %p for mode: expected one of %p % ","NUMERIZABLE_WRAPPINGS  keys - ","NUMERIZABLE_WRAPPINGS  keys ","</span> * ","opened_tags size ","opened_tags << ","opened_tags pop ","line scan ","opened_tags join ","line chomp! ","TABLE  apply ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line_count))) to_a map join ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line_count))) to_a map ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line_count))) to_a "," line_count ","  * ","max_width - ","line to_s size ","(send\n  (lvar :start) :+\n  (send nil :line_count)) to_s size ","(send\n  (lvar :start) :+\n  (send nil :line_count)) to_s ","Invalid value %p for :bolding; false or Integer expected. % "," chomp! ","line_number to_s size ","line_number to_s ","highlight_lines include? ","highlight_lines to_set ","highlight_lines is_a? ","highlight_lines == ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (lvar :line_count))) to_a map join  gsub! ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line_count))) to_a map join  gsub! ","bolding call s gsub! ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (lvar :line_count))) to_a map join  << ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line_count))) to_a map join  << ","bolding call s << ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (lvar : count ))) to_a map join ","(erange\n  (lvar :options fetch )\n  (send\n    (lvar :options fetch ) :+\n    (lvar :line_count))) to_a map join ","(erange\n  (lvar :options [] )\n  (send\n    (lvar :options [] ) :+\n    (lvar :line_count))) to_a map join ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (lvar : count ))) to_a map ","(erange\n  (lvar :options fetch )\n  (send\n    (lvar :options fetch ) :+\n    (lvar :line_count))) to_a map ","(erange\n  (lvar :options [] )\n  (send\n    (lvar :options [] ) :+\n    (lvar :line_count))) to_a map ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (lvar : count ))) to_a ","(erange\n  (lvar :options fetch )\n  (send\n    (lvar :options fetch ) :+\n    (lvar :line_count))) to_a ","(erange\n  (lvar :options [] )\n  (send\n    (lvar :options [] ) :+\n    (lvar :line_count))) to_a ","options fetch  + ","options []  + ","bolding call  rjust ","(send\n  (lvar :start) :+\n  (lvar : count )) to_s size ","(send\n  (lvar :options fetch ) :+\n  (lvar :line_count)) to_s size ","(send\n  (lvar :options [] ) :+\n  (lvar :line_count)) to_s size ","(send\n  (lvar :start) :+\n  (lvar : count )) to_s ","(send\n  (lvar :options fetch ) :+\n  (lvar :line_count)) to_s ","(send\n  (lvar :options [] ) :+\n  (lvar :line_count)) to_s ","options fetch  is_a? ","options []  is_a? ","options fetch  == ","options []  == ","DEFAULT_OPTIONS  merge  fetch ","DEFAULT_OPTIONS  merge  [] ","Invalid value %p for :bolding call _start; Integer expected. % ","Invalid value %p for :line_number_options fetch ; Integer expected. % ","Invalid value %p for :line_number_options [] ; Integer expected. % ","NUMERIZABLE_WRAPPINGS  []  include? ","NUMERIZABLE_WRAPPINGS  []  == ","opened_tags join ed_tags size ","opened_tags join ed_tags << ","opened_tags join ed_tags pop ","opened_tags join ed_tags join ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil : count ))) to_a map join ","(erange\n  (lvar :options fetch )\n  (send\n    (lvar :options fetch ) :+\n    (send nil :line_count))) to_a map join ","(erange\n  (lvar :options [] )\n  (send\n    (lvar :options [] ) :+\n    (send nil :line_count))) to_a map join ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil : count ))) to_a map ","(erange\n  (lvar :options fetch )\n  (send\n    (lvar :options fetch ) :+\n    (send nil :line_count))) to_a map ","(erange\n  (lvar :options [] )\n  (send\n    (lvar :options [] ) :+\n    (send nil :line_count))) to_a map ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil : count ))) to_a ","(erange\n  (lvar :options fetch )\n  (send\n    (lvar :options fetch ) :+\n    (send nil :line_count))) to_a ","(erange\n  (lvar :options [] )\n  (send\n    (lvar :options [] ) :+\n    (send nil :line_count))) to_a ","  count  ","(send\n  (lvar :start) :+\n  (lvar :line_count)) to_s size  - ","(send\n  (lvar :start) :+\n  (send nil :line_count)) to_s size  - ","(send\n  (lvar :start) :+\n  (send nil : count )) to_s size ","(send\n  (lvar :options fetch ) :+\n  (send nil :line_count)) to_s size ","(send\n  (lvar :options [] ) :+\n  (send nil :line_count)) to_s size ","(send\n  (lvar :start) :+\n  (send nil : count )) to_s ","(send\n  (lvar :options fetch ) :+\n  (send nil :line_count)) to_s ","(send\n  (lvar :options [] ) :+\n  (send nil :line_count)) to_s ","bolding call  to_s size ","bolding call  to_s ","highlight_lines to_set  include? ","options []  include? ","highlight_lines to_set  to_set ","options []  to_set ","highlight_lines to_set  is_a? ","highlight_lines to_set  == "]}," CodeRay Encoders HTML Output wrap":{"type":"method","name":"wrap","children":[],"call":[" clone wrap! "," clone "]}," CodeRay Encoders HTML Output wrap!":{"type":"method","name":"wrap!","children":[],"call":[" raise ","Unknown value %p for :wrap % "," wrap_in! ","Output  page_template_for_css ","Can't wrap %p in %p % "," wrapped_in "," wrapped_in? "," wrap! ","element == ","element ! "," apply_title! ","args first [] ","args first ","args first is_a? "," apply_args first [] ! "]}," CodeRay Encoders HTML Output wrap_in!":{"type":"method","name":"wrap_in!","children":[],"call":["Template  wrap! "]}," CodeRay Encoders HTML Output wrap_in":{"type":"method","name":"wrap_in","children":[],"call":[" clone wrap_in! "," clone "]}," CodeRay Encoders HTML Output wrapped_in?":{"type":"method","name":"wrapped_in?","children":[],"call":[" wrapped_in == "," wrapped_in "]}," CodeRay Encoders HTML Output wrapped_in":{"type":"method","name":"wrapped_in","children":[],"call":[]}," CodeRay Encoders HTML Output wrapper":{"type":"method","name":"wrapper","children":[],"call":[" wrap! "," define_method ","(begin\n  (lvar :wrapper)) to_sym "," wrap ","wrappers each "]}," CodeRay Encoders HTML Output page_template_for_css":{"type":"method","name":"page_template_for_css","children":[],"call":["PAGE  apply ","css == "," stylesheet "," make_stylesheet "," stylesheet  == "," style make_stylesheet  "," make_style make_stylesheet  "]}," CodeRay Encoders HTML Output extended":{"type":"method","name":"extended","children":[],"call":[" warn ","o class ","o respond_to? "]}," CodeRay Encoders HTML Output new":{"type":"method","name":"new","children":[],"call":["output wrapped_in= ","string clone extend ","string clone ","output css= ","string clone extend  wrapped_in= ","string clone extend  css= "]}," CodeRay Encoders HTML CSS parse":{"type":"method","name":"parse","children":[],"call":["@classes [] []= ","style strip ","@classes [] ","Hash  new ","styles pop ","classes scan "," raise ","error inspect ","stylesheet scan ","style to_s strip ","style to_s ","style to_s strip delete chomp ","style to_s strip delete ","classes pop ","selector scan ","selectors split ","@styles [] []= ","@styles [] ","@styles pop asses [] []= ","@classes pop asses [] []= ","@selector scan  [] []= ","@styles pop asses [] ","@classes pop asses [] ","@selector scan  [] ","classes scan  pop ","styles pop asses scan ","classes pop asses scan ","selector scan  scan ","classes scan heet scan ","styles pop asses pop ","classes pop asses pop ","selector scan  pop ","@classes scan  [] []= ","@classes scan  [] "]}," CodeRay Encoders HTML CSS []":{"type":"method","name":"[]","children":[],"call":["cl [] ","styles [] ","1 upto ","cl size + ","cl size ","@classes [] ","styles first "," raise ","Style not found: %p % ","style empty? ","styles size ","$stderr puts ","@classes []  [] ","cl [] s [] ","@classes []  size + ","@classes []  size ","@@classes [] asses [] ","cl [] s first ","cl []  empty? ","cl [] s size "]}," CodeRay Encoders HTML CSS initialize":{"type":"method","name":"initialize","children":[],"call":[" parse ","Hash  new ","(const\n  (lvar :style) :CSS_MAIN_STYLES) join "," TOKEN_COLORS  gsub ","CSS  load_stylesheet ","(const\n  (lvar :CSS  load_stylesheet ) :CSS_MAIN_STYLES) join ","CSS  load_CSS  load_stylesheet sheet "]}," CodeRay Encoders Count token":{"type":"method","name":"token","children":[],"call":[]}," CodeRay Encoders Count setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Encoders Encoder compile":{"type":"method","name":"compile","children":[],"call":["tokens each "," token "," raise ","item is_a? "]}," CodeRay Encoders Encoder finish":{"type":"method","name":"finish","children":[],"call":[]}," CodeRay Encoders Encoder token":{"type":"method","name":"token","children":[],"call":[" raise "," class "," block_token "," text_token ","text is_a? ","Unknown token text type: %p % ","text instance_of? ","@out << "," append_encoded_token_to_output ","Unknown token content type: %p % ","content is_a? ","Unknown token content type: %p, kind = %p % "," end_line "," begin_line "," end_group "," begin_group ","@ text_token  << "," append_encoded_token_to_ text_token put "," append_ text_token _to_output "]}," CodeRay Encoders Encoder setup":{"type":"method","name":"setup","children":[],"call":[" get_output "]}," CodeRay Encoders Encoder to_proc":{"type":"method","name":"to_proc","children":[],"call":[" method to_proc "," method "]}," CodeRay Encoders Encoder encode_stream":{"type":"method","name":"encode_stream","children":[],"call":[" finish ","CodeRay  scan_stream ","CodeRay  get_scanner_options "," setup ","@options merge "," raise "," kind_of? ","CodeRay  get_CodeRay  get_scanner_options  ","CodeRay  get_scanner_@options merge  ","@@options merge  merge "]}," CodeRay Encoders Encoder encode":{"type":"method","name":"encode","children":[],"call":[" encode_tokens ","CodeRay  scan ","CodeRay  get_scanner_options ","@options merge "," finish ","@scanner tokenize "," setup ","Scanners  [] new ","CodeRay  get_scanner_options update ","Scanners  [] ","scanner_options []= "," encode_CodeRay  scan  ","CodeRay  get_CodeRay  get_scanner_options  ","CodeRay  get_scanner_@options merge  ","@@options merge  merge ","Scanners  [] new  tokenize ","CodeRay  get_CodeRay  get_scanner_options  update ","CodeRay  get_scanner_@options merge  update ","CodeRay  get_scanner_options  []= ","scanner_@options merge  []= "]}," CodeRay Encoders Encoder encode_tokens":{"type":"method","name":"encode_tokens","children":[],"call":[" finish "," compile "," setup ","@options merge ","tokens scanner ","tokens respond_to? ","@@options merge  merge "]}," CodeRay Encoders Encoder initialize":{"type":"method","name":"initialize","children":[],"call":[" raise "," class == "," class "," class DEFAULT_OPTIONS  merge "]}," CodeRay Encoders Encoder const_missing":{"type":"method","name":"const_missing","children":[],"call":["sym to_s downcase ","sym to_s ","sym == "," plugin_id ","(or\n  (and\n    (defined?\n      (ivar :@plugin_id))\n    (ivar :@plugin_id))\n  (send\n    (send\n      (send nil :name) :[]\n      (regexp\n        (str \"\\\\w+$\")\n        (regopt))) :downcase)) to_s "," name [] downcase "," name [] "," name "," plugin_id to_s ","(or\n  (ivar :@plugin_id)\n  (send\n    (send\n      (send nil :name) :[]\n      (regexp\n        (str \"\\\\w+$\")\n        (regopt))) :downcase)) to_s "]}," CodeRay Encoders Encoder streamable?":{"type":"method","name":"streamable?","children":[],"call":[" is_a? "]}," CodeRay highlight_file":{"type":"method","name":"highlight_file","children":[],"call":[" encode_file "]}," CodeRay highlight":{"type":"method","name":"highlight","children":[],"call":[" encode "]}," CodeRay Encoders XML close_token":{"type":"method","name":"close_token","children":[],"call":["@node parent "," raise ","@node == ","@node parent  parent ","@node parent  == "]}," CodeRay Encoders XML open_token":{"type":"method","name":"open_token","children":[],"call":["@node add_element ","kind to_s ","@node add_element  add_element "]}," CodeRay Encoders XML text_token":{"type":"method","name":"text_token","children":[],"call":["token << ","REXML Text  new ","text scan ","@node add_element ","kind to_s ","kind == ","@node add_element  << "]}," CodeRay Encoders XML finish":{"type":"method","name":"finish","children":[],"call":["@doc write ","options [] "]}," CodeRay Encoders XML setup":{"type":"method","name":"setup","children":[],"call":["@doc add_element ","options [] ","@doc << ","REXML XMLDecl  new ","REXML Document  new ","REXML Document  new  add_element ","REXML Document  new  << "]}," CodeRay Encoders Statistic block_token":{"type":"method","name":"block_token","children":[],"call":["@type_stats [] count ","@type_stats [] "]}," CodeRay Encoders Statistic text_token":{"type":"method","name":"text_token","children":[],"call":["text size ","@type_stats [] size ","@type_stats [] ","@type_stats [] count ","kind == "]}," CodeRay Encoders Null to_proc":{"type":"method","name":"to_proc","children":[],"call":[" proc "]}," CodeRay Encoders HTML Output stylesheet":{"type":"method","name":"stylesheet","children":[],"call":["Output  stylesheet ","Output  make_stylesheet "]}," CodeRay Encoders Debug close_token":{"type":"method","name":"close_token","children":[],"call":[]}," CodeRay Encoders Debug open_token":{"type":"method","name":"open_token","children":[],"call":[]}," CodeRay Encoders Debug block_token":{"type":"method","name":"block_token","children":[],"call":["@out << "]}," CodeRay Encoders Debug text_token":{"type":"method","name":"text_token","children":[],"call":["@out << ","text gsub ","kind == ","@out << << << << ","@out << << << ","@out << << ","kind to_s ","text index ","text gsub  gsub ","text gsub  index "]}," CodeRay Encoders Encoder block_token":{"type":"method","name":"block_token","children":[],"call":[" raise ","unknown block action: %p % "," close_token "," open_token "," end_line "," begin_line "]}," CodeRay Encoders Encoder text_token":{"type":"method","name":"text_token","children":[],"call":["@out << "]}," CodeRay Encoders Encoder file_extension":{"type":"method","name":"file_extension","children":[],"call":[" class "," class file_extension "]}," CodeRay Scanners Scanner CaseIgnoringWordList add":{"type":"method","name":"add","children":[],"call":[" []= ","word downcase ","words each "]}," CodeRay Scanners Scanner CaseIgnoringWordList include?":{"type":"method","name":"include?","children":[],"call":[" has_key? ","word downcase "]}," CodeRay Scanners Scanner CaseIgnoringWordList initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","h fetch ","k downcase "," proc "]}," Plugin plugin_id":{"type":"method","name":"plugin_id","children":[],"call":[" name [] downcase "," name [] "," name "]}," Plugin helper":{"type":"method","name":"helper","children":[],"call":[" PLUGIN_HOST  require_helper ","helper to_s "," plugin_id "]}," PluginHost load_map":{"type":"method","name":"load_map","children":[],"call":[" warn ","no _map.rb found for %s % "," name "," require "," path_to ","File  exist? "]}," PluginHost inspect":{"type":"method","name":"inspect","children":[],"call":["map inspect ","map []= ","plugin name [] ","plugin name ","map each "," plugin_hash dup "," plugin_hash "," host_id "," name ","plugin to_s [] ","plugin to_s "," plugin_hash dup  inspect "," plugin_hash dup  []= "," plugin_hash dup  each "]}," PluginHost map":{"type":"method","name":"map","children":[],"call":[" plugin_hash []= "," plugin_hash "," plugin_hash has_key? "," validate_id "]}," PluginHost require_helper":{"type":"method","name":"require_helper","children":[],"call":[" require "," path_to ","File  join ","  path_to _to "]}," CodeRay Encoders HTML Output make_stylesheet":{"type":"method","name":"make_stylesheet","children":[],"call":["css stylesheet ","css stylecss stylesheet  "]}," CodeRay Encoders HTML CSS load_stylesheet":{"type":"method","name":"load_stylesheet","children":[],"call":[]}," CaseIgnoringWordList add":{"type":"method","name":"add","children":[],"call":[" []= ","word downcase ","words each "]}," CaseIgnoringWordList include?":{"type":"method","name":"include?","children":[],"call":[" has_key? ","word downcase "]}," CaseIgnoringWordList initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","h fetch ","k downcase "," proc ","key downcase "]}," WordList add":{"type":"method","name":"add","children":[],"call":[" []= ","words each "]}," WordList include?":{"type":"method","name":"include?","children":[],"call":[" has_key? "]}," WordList initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","h fetch "," raise "]}," WordList for":{"type":"method","name":"for","children":[],"call":[]}," CodeRay Encoders HTML token":{"type":"method","name":"token","children":[],"call":[" raise ","unknown token kind: %p % ","Token with nil as text was given: %p % ","@opened pop ","@out << ","@opened size > ","@opened size ","@opened empty? ","@opened << ","@css_style [] ","@opened []= ","@out << << << ","@out << << ","@HTML_ESCAPE [] ","text gsub ","text =~ ","text is_a? ","Malformed token stream: Trying to close a token (%p) that is not open. Open are: %p. % ","@opened [] ","@opened last != ","@opened last ","@opened size == ","(str \"Malformed token stream: Trying to close a token (%p) \\\\\\n\") % ","(str \"Malformed token stream: Trying to close a line (%p) \\\\\\n\") % ","style sub ","text != ","style [] ","@css_@css_style []  [] ","@css_style []  sub ","@css_style []  [] "]}," CodeRay Encoders HTML finish":{"type":"method","name":"finish","children":[],"call":["@out wrap! ","options [] ","@out numerize! ","@out css= ","@out extend ","@out << ","</span> * ","@opened size ","@opened shift "," warn ","%d tokens still open % ","@opened empty? ","%d tokens still open: %p % ","@out apply_title! ","@real_out << ","Numbering  number! ","@opened pop ","@out number! ","@out respond_to? "]}," CodeRay Encoders HTML setup":{"type":"method","name":"setup","children":[],"call":[" raise ","Unknown value %p for :css. % ","options [] ","h []= ","<span%s style=\"%s\"> % ","@css [] ","classes delete ","HTML  token_path_to_hint ","styles shift ","(sym :delimiter) include? ","styles first ","hint ! ","classes first == ","classes first ","ClassOfKind  [] ","styles map ","k dup ","k is_a? ","Hash  new ","<span%s class=\"%s\"> % ","k [] << ","k first ","k [] ","c == ","Unknown value %p for :hint; expected :info, :debug, false or nil. % ","(sym :debug) include? ! ","(sym :debug) include? ","CSS  new ","@HTML_ESCAPE []= ","  * ","HTML_ESCAPE  dup ","options == ","TRANSPARENT_TOKEN_KINDS  include? ","Unknown value %p for :hint;           expected :info, :debug, false, or nil. % ","Tokens ClassOfKind  [] ","<span%s> % ","CodeRay Tokens ClassOfKind  [] ","options [] == ","@css get_style ","css_classes [] "," Array map "," Array ","kind != ","Unknown value %p for :hint;           expected :info, :info_long, :debug, false, or nil. % ","k first != ","classes first != ","Tokens AbbreviationForKind  [] ","k map ","c != ","options []= "," make_span_for_kinds ","HTML_ESCAPE  merge "," check_options! "," dup ","Unknown value %p for :ClassOfKind  [] ss. % ","Unknown value %p for :CodeRay Tokens ClassOfKind  [] ss. % ","Unknown value %p for :Tokens AbbreviationForKind  [] ss. % ","<span%s @css [] =\"%s\"> % ","<span%s @css get_style =\"%s\"> % ","@ClassOfKind  [] ss [] ","@CodeRay Tokens ClassOfKind  [] ss [] ","@Tokens AbbreviationForKind  [] ss [] ","CSS  new  [] ","ClassOfKind  [] lasses delete ","CodeRay Tokens ClassOfKind  [] lasses delete ","Tokens AbbreviationForKind  [] lasses delete ","HTML  token_path_to_options []  ","@css [] s shift ","@css get_style s shift ","k dup  shift ","(sym :delimiter) inClassOfKind  [] lude? ","(sym :delimiter) inCodeRay Tokens ClassOfKind  [] lude? ","(sym :delimiter) inTokens AbbreviationForKind  [] lude? ","@css [] s first ","@css get_style s first ","k dup  first ","options []  ! ","ClassOfKind  [] lasses first == ","CodeRay Tokens ClassOfKind  [] lasses first == ","Tokens AbbreviationForKind  [] lasses first == ","ClassOfKind  [] lasses first ","CodeRay Tokens ClassOfKind  [] lasses first ","Tokens AbbreviationForKind  [] lasses first ","@css [] s map ","@css get_style s map ","k dup  map ","<span%s ClassOfKind  [] lass=\"%s\"> % ","<span%s CodeRay Tokens ClassOfKind  [] lass=\"%s\"> % ","<span%s Tokens AbbreviationForKind  [] lass=\"%s\"> % ","ClassOfKind  []  == ","CodeRay Tokens ClassOfKind  []  == ","Tokens AbbreviationForKind  []  == ","Unknown value %p for :hint; expeClassOfKind  [] ted :info, :debug, false or nil. % ","Unknown value %p for :hint; expeCodeRay Tokens ClassOfKind  [] ted :info, :debug, false or nil. % ","Unknown value %p for :hint; expeTokens AbbreviationForKind  [] ted :info, :debug, false or nil. % ","Unknown value %p for :options [] ; expected :info, :debug, false or nil. % ","(sym :debug) inClassOfKind  [] lude? ! ","(sym :debug) inCodeRay Tokens ClassOfKind  [] lude? ! ","(sym :debug) inTokens AbbreviationForKind  [] lude? ! ","(sym :debug) inClassOfKind  [] lude? ","(sym :debug) inCodeRay Tokens ClassOfKind  [] lude? ","(sym :debug) inTokens AbbreviationForKind  [] lude? ","HTML_ESCAPE  dup  []= ","HTML_ESCAPE  merge  []= ","TRANSPARENT_TOKEN_KINDS  inClassOfKind  [] lude? ","TRANSPARENT_TOKEN_KINDS  inCodeRay Tokens ClassOfKind  [] lude? ","TRANSPARENT_TOKEN_KINDS  inTokens AbbreviationForKind  [] lude? ","Unknown value %p for :hint;           expeClassOfKind  [] ted :info, :debug, false, or nil. % ","Unknown value %p for :hint;           expeCodeRay Tokens ClassOfKind  [] ted :info, :debug, false, or nil. % ","Unknown value %p for :hint;           expeTokens AbbreviationForKind  [] ted :info, :debug, false, or nil. % ","Unknown value %p for :options [] ;           expected :info, :debug, false, or nil. % ","@css get_@css []  ","@css get_@css get_style  ","@ClassOfKind  [] ss get_style ","@CodeRay Tokens ClassOfKind  [] ss get_style ","@Tokens AbbreviationForKind  [] ss get_style ","CSS  new  get_style ","ClassOfKind  [] ss_ClassOfKind  [] lasses [] ","CodeRay Tokens ClassOfKind  [] ss_CodeRay Tokens ClassOfKind  [] lasses [] ","Tokens AbbreviationForKind  [] ss_Tokens AbbreviationForKind  [] lasses [] ","css_classes [] es [] ","k first  != ","Unknown value %p for :hint;           expeClassOfKind  [] ted :info, :info_long, :debug, false, or nil. % ","Unknown value %p for :hint;           expeCodeRay Tokens ClassOfKind  [] ted :info, :info_long, :debug, false, or nil. % ","Unknown value %p for :hint;           expeTokens AbbreviationForKind  [] ted :info, :info_long, :debug, false, or nil. % ","Unknown value %p for :options [] ;           expected :info, :info_long, :debug, false, or nil. % ","ClassOfKind  [] lasses first != ","CodeRay Tokens ClassOfKind  [] lasses first != ","Tokens AbbreviationForKind  [] lasses first != ","ClassOfKind  []  != ","CodeRay Tokens ClassOfKind  []  != ","Tokens AbbreviationForKind  []  != "," make_span_for_k first s "," ClassOfKind  [] heClassOfKind  [] k_options! "," CodeRay Tokens ClassOfKind  [] heCodeRay Tokens ClassOfKind  [] k_options! "," Tokens AbbreviationForKind  [] heTokens AbbreviationForKind  [] k_options! "]}," CodeRay Encoders HTML token_path_to_hint":{"type":"method","name":"token_path_to_hint","children":[],"call":[]}," CodeRay Encoders HTML initialize":{"type":"method","name":"initialize","children":[],"call":[]}," CodeRay scanner":{"type":"method","name":"scanner","children":[],"call":["Scanners  [] new ","Scanners  [] ","CodeRay Scanners  [] new ","CodeRay Scanners  [] "]}," CodeRay Scanners YAML scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["options [] ","tokens << "," raise_inspect ","Error token %p in line %d % "," line ","kind == ","kind ! "," matched ","Unknown state: %p % "," getch "," scan ","[BUG] else-case reached with state %p % "," bol? ","match index "," eos? "," [] "," column "," pos - - "," pos - ","match size "," pos ","match [] ","state == ","match == ","string_indent + ","key_indent + "," check ! "," check ","indent to_s "," matched size ","encoder text_token "," raise "," column - ","encoder end_group ","encoder begin_group ","match size > ","match empty? ! ","match empty? ","  scan ed "," scan  index "," scan  size "," scan  [] "," scan  == ","string_ matched size  + "," column  + "," column -  + ","key_ matched size  + "," matched size  to_s ","  scan ed size "," scan  size > "," scan  empty? ! "," scan  empty? "]}," CodeRay Scanners YAML setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Scanners Patterns StringState initialize":{"type":"method","name":"initialize","children":[],"call":["CLOSING_PAREN  [] ","STRING_PATTERN  [] ","HEREDOC_PATTERN  [] ","heredoc == "]}," CodeRay Scanners RHTML scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":[" raise_inspect ","tokens << ","end_tag empty? ","@ruby_scanner tokenize ","match [] ","-1 - ","end_tag size ","start_tag size "," scan ","@html_scanner tokenize ","match empty? ! ","match empty? "," scan_until "," eos? ","start_tag == "," scan_rest ","encoder end_group ","encoder text_token ","encoder begin_group ","start_tag [] ","code empty? ","match []  empty? "," scan  [] ","match []  size "," scan  empty? ! "," scan  empty? ","match []  == ","enmatch [] r end_group ","enmatch [] r text_token ","enmatch [] r begin_group ","match []  [] "]}," CodeRay Scanners RHTML setup":{"type":"method","name":"setup","children":[],"call":["CodeRay  scanner "]}," CodeRay Scanners NitroHTML scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":[" raise_inspect ","tokens << "," scan ","end_tag empty? ","@ruby_scanner tokenize ","match [] ","(send\n  (lvar :end_tag) :size) -@ - ","(send\n  (lvar :end_tag) :size) -@ ","end_tag size ","start_tag size ","match [] == ","-1 - ","CLOSING_PAREN  [] ","start_tag [] ","@html_scanner tokenize ","match empty? ! ","match empty? "," scan_until "," eos? "," scan  [] ","match []  size "," scan  [] == ","match []  [] "," scan  empty? ! "," scan  empty? "]}," CodeRay Scanners NitroHTML setup":{"type":"method","name":"setup","children":[],"call":["CodeRay  scanner "]}," CodeRay Scanners HTML scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["options [] ","tokens << "," raise_inspect ","Error token %p in line %d % "," line ","kind == ","kind ! "," matched ","Unknown state: %p % "," scan "," getch ","PLAIN_STRING_CONTENT  [] ","[BUG] else-case reached with state %p % ","match [] == ","match [] "," eos? ","encoder end_group ","state == "," raise ","unknown special tag: %p % ","encoder text_token "," scan_java_script ","encoder begin_group ","code empty? "," scan_until "," [] ","match == ","in_attribute == ","IN_ATTRIBUTE  [] ","state != ","match downcase == ","match downcase "," scan_css ","in_tag == ","  scan ed "," scan  [] == "," scan  [] ","en scan_until r end_group ","en scan_until r text_token ","en scan_until r begin_group "," scan_until  empty? "," scan  == ","IN_ATTRIBUTE  []  == "," scan  downcase == "," scan  downcase "," []  == "]}," CodeRay Scanners HTML setup":{"type":"method","name":"setup","children":[],"call":[]}," String to_unix":{"type":"method","name":"to_unix","children":[],"call":[" gsub "," index "]}," CodeRay Scanners Scanner reset_instance":{"type":"method","name":"reset_instance","children":[],"call":["@tokens clear ","@options [] ","@options [] ! ","@tokens respond_to? "]}," CodeRay Scanners Scanner setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Scanners Scanner tokens":{"type":"method","name":"tokens","children":[],"call":[" tokenize "]}," CodeRay Scanners Scanner string=":{"type":"method","name":"string=","children":[],"call":[" reset_instance ","Scanner  normify "," reset_state ","RUBY_DESCRIPTION  [] "," class normalize "," class "]}," CodeRay Scanners Scanner reset":{"type":"method","name":"reset","children":[],"call":[" reset_instance "]}," CodeRay Scanners Scanner normify":{"type":"method","name":"normify","children":[],"call":["code to_s to_unix ","code to_s ","code to_unix ","code force_encoding ","code respond_to? ","code [] ","code encode! ","code encoding name == ","code encoding name ","code encoding ","code valid_encoding? ","code valid_encoding? ! ","code encoding name != ","code dup ","code gsub! ","code index ","code to_s dup ","code to_s to_unix  to_s to_unix ","code to_s  to_s to_unix ","code dup  to_s to_unix ","code to_s dup  to_s to_unix ","code to_s to_unix  to_s ","code to_s  to_s ","code dup  to_s ","code to_s dup  to_s ","code to_s to_unix  to_unix ","code to_s  to_unix ","code dup  to_unix ","code to_s dup  to_unix ","code to_s to_unix  force_encoding ","code to_s  force_encoding ","code dup  force_encoding ","code to_s dup  force_encoding ","code to_s to_unix  respond_to? ","code to_s  respond_to? ","code dup  respond_to? ","code to_s dup  respond_to? ","code to_s to_unix  [] ","code to_s  [] ","code dup  [] ","code to_s dup  [] ","code to_s to_unix  encode to_s to_unix ! ","code to_s  encode to_s ! ","code dup  encode dup ! ","code to_s dup  encode to_s dup ! ","code to_s to_unix  encoding name == ","code to_s  encoding name == ","code dup  encoding name == ","code to_s dup  encoding name == ","code to_s to_unix  encoding name ","code to_s  encoding name ","code dup  encoding name ","code to_s dup  encoding name ","code to_s to_unix  encoding ","code to_s  encoding ","code dup  encoding ","code to_s dup  encoding ","code to_s to_unix  valid_encoding? ","code to_s  valid_encoding? ","code dup  valid_encoding? ","code to_s dup  valid_encoding? ","code to_s to_unix  valid_encoding? ! ","code to_s  valid_encoding? ! ","code dup  valid_encoding? ! ","code to_s dup  valid_encoding? ! ","code to_s to_unix  encoding name != ","code to_s  encoding name != ","code dup  encoding name != ","code to_s dup  encoding name != ","code to_s to_unix  dup ","code to_s  dup ","code dup  dup ","code to_s dup  dup ","code to_s to_unix  gsub! ","code to_s  gsub! ","code dup  gsub! ","code to_s dup  gsub! ","code to_s to_unix  index ","code to_s  index ","code dup  index ","code to_s dup  index ","code to_s to_unix  to_s dup ","code to_s  to_s dup ","code dup  to_s dup ","code to_s dup  to_s dup "]}," PluginHost default":{"type":"method","name":"default","children":[],"call":[" plugin_hash []= "," plugin_hash "," validate_id "," val validate_id ate_ validate_id  "]}," CodeRay Encoders HTML Output line_count":{"type":"method","name":"line_count","children":[],"call":["ends_with_newline ! ","after_last_newline [] "," [] ","position_of_last_newline + "," rindex "," count ","after_last_newline []  ! "," []  [] "," rindex  + "]}," CodeRay Duo encode":{"type":"method","name":"encode","children":[],"call":["@encoder encode_tokens "," scanner tokenize "," scanner ","@scanner string= "," encoder encode_tokens "," encoder "," scanner code= "," encoder encode_stream ","@options merge ","options delete "," encoder encode "," encoder encode_options delete  ","@@options merge  merge ","@options merge  delete "]}," CodeRay Duo initialize":{"type":"method","name":"initialize","children":[],"call":["CodeRay  encoder ","CodeRay  scanner ","CodeRay  get_scanner_options ","lang [] ","lang keys first ","lang keys ","lang size == ","lang size ","lang is_a? ","format == ","format nil? "]}," CodeRay Scanners RHTML reset_instance":{"type":"method","name":"reset_instance","children":[],"call":["@html_scanner reset "]}," CodeRay Scanners NitroXHTML scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":[" raise_inspect ","tokens << "," scan ","end_tag empty? ","@ruby_scanner tokenize ","match [] ","(send\n  (lvar :end_tag) :size) -@ - ","(send\n  (lvar :end_tag) :size) -@ ","end_tag size ","start_tag size ","match [] == ","-1 - ","CLOSING_PAREN  [] ","start_tag [] ","@html_scanner tokenize ","match empty? ! ","match empty? "," scan_until "," eos? "," matched "," scan_rest ","encoder text_token ","encoder end_group ","encoder begin_group "," scan  [] "," scan_until  [] ","match []  size "," scan  [] == "," scan_until  [] == ","match []  [] "," scan  empty? ! "," scan_until  empty? ! "," scan  empty? "," scan_until  empty? ","  scan ed ","  scan_until ed ","enmatch [] r text_token ","enmatch [] r end_group ","enmatch [] r begin_group "]}," CodeRay Scanners NitroXHTML reset_instance":{"type":"method","name":"reset_instance","children":[],"call":["@html_scanner reset "]}," CodeRay Scanners NitroXHTML setup":{"type":"method","name":"setup","children":[],"call":["CodeRay  scanner "]}," CodeRay Scanners HTML reset":{"type":"method","name":"reset","children":[],"call":[]}," PluginHost list":{"type":"method","name":"list","children":[],"call":["File  basename ","(send\n  (send\n    (const nil :Dir) :[]\n    (send nil :path_to\n      (str \"*\"))) :select) map ","File  basename [] ","Dir  [] select ","Dir  [] "," path_to "]}," CodeRay Scanners Debug scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << "," raise_inspect ","Error token %p in line %d % "," line ","kind ! "," matched "," getch ","opened_tokens pop "," scan ","opened_tokens << "," [] to_sym "," [] "," [] gsub "," eos? ","opened_tokens empty? ! ","opened_tokens empty? ","encoder end_group ","encoder text_token ","encoder end_line "," raise ","encoder begin_line ","encoder begin_group ","TokenKinds  has_key? ","Tokens AbbreviationForKind  has_key? ","@known_token_kinds include? ","opened_tokens pop  ! "," [] to_sym  ! ","  [] gsub ed ","  scan ed ","  matched ed ","@known_token_opened_tokens pop s include? ","@known_token_ [] to_sym s include? "]}," Term ANSIColor attributes":{"type":"method","name":"attributes","children":[],"call":[]}," Term ANSIColor uncolored":{"type":"method","name":"uncolored","children":[],"call":[" gsub "," respond_to? ","string gsub "," block_given? "]}," Term ANSIColor coloring=":{"type":"method","name":"coloring=","children":[],"call":[]}," Term ANSIColor coloring?":{"type":"method","name":"coloring?","children":[],"call":[]}," CodeRay Scanners SQL scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << "," matched "," raise ","else case \" reached; %p not handled. % "," peek ","string_content empty? "," scan ","string_content << ","string_content << << "," getch "," peek == ","string_type == ","state == ","IDENT_KIND  [] ","match downcase "," eos? "," raise_inspect ","Error token %p in line %d % "," line ","kind ! ","match << "," check ","kind == ","match [] == ","match [] "," [] ","encoder end_group ","encoder text_token ","encoder begin_group ","match == ","match empty? ","match + ","STRING_CONTENT_PATTERN  [] ","  scan ed "," matched  == "," []  == "," scan  downcase ","IDENT_KIND  []  ! "," scan  << ","IDENT_KIND  []  == "," scan  [] == "," scan  [] "," scan  == "," scan  empty? "," scan  + "]}," CodeRay Scanners Scheme scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << ","state == "," raise_inspect ","Error token %p in line %d % "," line ","kind ! "," matched "," raise ","else case \" reached; %p not handled. % "," peek "," scan "," getch "," matched empty? ! "," matched empty? ","ident_kind [] "," eos? ","encoder end_group ","encoder text_token ","encoder begin_group ","ident_kind []  ! ","  scan ed ","  scan ed empty? ! ","  scan ed empty? ","ident_ident_kind []  [] "]}," CodeRay Scanners JavaScript scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << ","(sym :string) include? "," raise_inspect ","Error token %p in line %d % "," line ","kind ! "," matched ","else case \" reached; %p not handled. % "," peek "," scan ","state == ","(or\n  (send\n    (lvar :match) :==\n    (str \"\\\\\\\\\"))\n  (send\n    (lvar :match) :==\n    (str \"\\\\'\"))) ! ","match == ","string_delimiter == ","modifiers empty? ! ","modifiers empty? ","STRING_CONTENT_PATTERN  [] "," getch "," check ","match index ","kind == ","KEYWORDS_EXPECTING_VALUE  [] ","IDENT_KIND  [] ","last_operator == ","match [] ","value_expected ! "," eos? ","state != ","KEY_CHECK_PATTERN  [] "," xml_scanner tokenize "," xml_scanner ","encoder end_group ","encoder text_token ","encoder begin_group ","options [] ","Unknown state: %p % ","(str \"else case \") % ","match empty? "," [] ","IDENT_KIND  []  ! ","  scan ed ","(or\n  (send\n    (lvar : scan ) :==\n    (str \"\\\\\\\\\"))\n  (send\n    (lvar : scan ) :==\n    (str \"\\\\'\"))) ! "," scan  == "," scan  empty? ! "," scan  empty? "," scan  index ","IDENT_KIND  []  == ","match []  == "," scan  [] "]}," CodeRay Scanners Java scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << ","(sym :string) include? ","match == "," raise_inspect ","Error token %p in line %d % "," line ","kind ! "," matched ","else case \" reached; %p not handled. % "," peek "," scan ","state == ","(or\n  (send\n    (lvar :match) :==\n    (str \"\\\\\\\\\"))\n  (send\n    (lvar :match) :==\n    (str \"\\\\'\"))) ! ","string_delimiter == ","modifiers empty? ! ","modifiers empty? ","STRING_CONTENT_PATTERN  [] "," getch "," check ","IDENT_KIND  [] "," eos? ","encoder end_group ","encoder text_token ","encoder begin_group ","match empty? "," scan  == ","IDENT_KIND  []  ! ","  scan ed ","(or\n  (send\n    (lvar : scan ) :==\n    (str \"\\\\\\\\\"))\n  (send\n    (lvar : scan ) :==\n    (str \"\\\\'\"))) ! "," scan  empty? ! "," scan  empty? "]}," CodeRay Scanners Diff scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << "," raise_inspect ","Error token %p in line %d % "," line ","kind ! "," matched "," scan "," [] "," eos? ","match [] "," check ","encoder end_line ","encoder text_token ","encoder begin_line ","content_scanner tokenize ","options [] ","content_scanner state= "," match? "," match? ! ","match empty? ","content_scanner state ","deleted_lines == ","encoder tokens ","encoder end_group ","encoder begin_group ","inserted empty? ","Tokens  new ","deleted empty? "," diff "," skip ","scanners [] ","file_type == ","FileType  fetch ","line_kind == ","h []= ","Scanners  [] new ","Scanners  [] ","Hash  new ","content_scanner instance_variable_set ","content_scanner instance_variable_get ","content_scanner instance_variable_defined? ","match size > ","match size ","match != ","CodeRay FileType  fetch ","deleted_lines_count == ","changed_lines_count > ","inserted_part empty? ","deleted_part empty? ","inserted_lines_tokenized << ","deleted_lines_tokenized << ","deleted_lines zip ","Array  new ","i > ","changed_lines_count - ","1 + "," check count ","changed_lines_count <= ","  scan ed "," scan  [] ","scanners []  tokenize ","scanners []  state= ","  scan ? ","  scan ? ! "," scan  empty? ","scanners []  state ","FileType  fetch  == ","CodeRay FileType  fetch  == ","scanners []  instance_variable_set ","scanners []  instance_variable_get ","scanners []  instance_variable_defined? "," scan  size > "," scan  size "," scan  != ","1 +  > ","1 +  - ","1 +  <= "]}," CodeRay Scanners Scanner streaming?":{"type":"method","name":"streaming?","children":[],"call":["@options [] ! ! ","@options [] ! ","@options [] "]}," CodeRay Scanners Scanner file_extension":{"type":"method","name":"file_extension","children":[],"call":[" plugin_id to_s "," plugin_id ","extension to_s "," class file_extension "," class "]}," CodeRay CaseIgnoringWordList add":{"type":"method","name":"add","children":[],"call":[" []= ","word downcase ","words each "]}," CodeRay CaseIgnoringWordList initialize":{"type":"method","name":"initialize","children":[{"type":"method","name":"[]","children":[],"asgn":[],"call":[]}],"call":["key downcase ","h []= ","h fetch ","k downcase "," extend "]}," CodeRay WordList add":{"type":"method","name":"add","children":[],"call":[" []= ","words each "]}," CodeRay WordList initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","h fetch "," raise "]}," CodeRay require_plugin":{"type":"method","name":"require_plugin","children":[],"call":[]}," CodeRay Plugin plugin_id":{"type":"method","name":"plugin_id","children":[],"call":[" name [] downcase "," name [] "," name "]}," CodeRay Plugin helper":{"type":"method","name":"helper","children":[],"call":[" PLUGIN_HOST  require_helper ","helper to_s "," plugin_id ","helper [] ","helper is_a? "," plugin_id to_s "]}," CodeRay Plugin plugin_host":{"type":"method","name":"plugin_host","children":[],"call":[" const_set "," raise ","host class ","host is_a? ! ","host is_a? "]}," CodeRay Plugin register_for":{"type":"method","name":"register_for","children":[],"call":[" plugin_host register "," plugin_host ","ids first "]}," CodeRay Plugin included":{"type":"method","name":"included","children":[],"call":[" warn "," name "]}," CodeRay PluginHost validate_id":{"type":"method","name":"validate_id","children":[],"call":[" raise ","id class ","id to_sym ","id [] == ","id [] ","id is_a? ","id nil? ","id downcase to_sym ","id downcase ","id to_s "]}," CodeRay PluginHost path_to":{"type":"method","name":"path_to","children":[],"call":["File  join "," plugin_path "]}," CodeRay PluginHost fetch":{"type":"method","name":"fetch","children":[],"call":[" plugin_hash fetch "," validate_id "," plugin_hash "]}," CodeRay PluginHost load_map":{"type":"method","name":"load_map","children":[],"call":[" warn ","no _map.rb found for %s % "," name "," require ","File  exist? "," path_to "]}," CodeRay PluginHost create_plugin_hash":{"type":"method","name":"create_plugin_hash","children":[],"call":["h [] "," raise ","id inspect "," name ","h has_key? ","Could not load plugin %p: %s % ","h []= "," require "," path_to "," validate_id ","Hash  new "," validate_id  inspect ","  path_to _to "," val validate_id ate_ validate_id  "]}," CodeRay PluginHost inspect":{"type":"method","name":"inspect","children":[],"call":["map inspect "," host_id "," name ","map []= ","plugin to_s [] ","plugin to_s ","map each "," plugin_hash dup "," plugin_hash "," plugin_hash dup  inspect "," plugin_hash dup  []= "," plugin_hash dup  each "]}," CodeRay PluginHost list":{"type":"method","name":"list","children":[],"call":["File  basename ","(send\n  (send\n    (const nil :Dir) :[]\n    (send nil :path_to\n      (str \"*\"))) :select) map ","File  basename [] ","Dir  [] select ","Dir  [] "," path_to ","File  basename to_sym "]}," CodeRay PluginHost plugin_hash":{"type":"method","name":"plugin_hash","children":[],"call":[" create_plugin_hash "," make_plugin_hash "," load_plugin_map ","(ivasgn :@plugin_hash\n  (send nil :make_plugin_hash)) tap ","(ivasgn : make_plugin_hash \n  (send nil :make_plugin_hash)) tap "]}," CodeRay PluginHost register":{"type":"method","name":"register","children":[],"call":[" plugin_hash []= "," validate_id "," plugin_hash "," raise ","id class ","id is_a? "]}," CodeRay PluginHost default":{"type":"method","name":"default","children":[],"call":[" plugin_hash [] "," plugin_hash "," plugin_hash []= "," validate_id "," load "," raise ","id == "," val validate_id ate_ validate_id  "," validate_id  == "]}," CodeRay PluginHost map":{"type":"method","name":"map","children":[],"call":[" plugin_hash []= "," plugin_hash "," plugin_hash has_key? "," validate_id "]}," CodeRay PluginHost host_id":{"type":"method","name":"host_id","children":[],"call":[" name "," const_defined? "]}," CodeRay PluginHost plugin_path":{"type":"method","name":"plugin_path","children":[],"call":[" load_map ","File  expand_path ","File  join ","args empty? "]}," CodeRay PluginHost host_by_id":{"type":"method","name":"host_by_id","children":[],"call":["PLUGIN_HOSTS_BY_ID  [] ","PLUGIN_HOSTS_BY_ID  replace ","h fetch ","h []= ","host host_id ","Hash  new ","PLUGIN_HOSTS_BY_ID  default_proc "]}," CodeRay PluginHost included":{"type":"method","name":"included","children":[],"call":[" warn "," name "]}," CodeRay PluginHost extended":{"type":"method","name":"extended","children":[],"call":["PLUGIN_HOSTS  << "]}," CodeRay PluginHost require_helper":{"type":"method","name":"require_helper","children":[],"call":[" require "," path_to ","File  join ","  path_to _to "]}," CodeRay PluginHost []":{"type":"method","name":"[]","children":[],"call":[" plugin_hash [] "," plugin_hash ","plugin is_a? "," validate_id ","  plugin_hash [] _hash [] ","  validate_id _hash [] ","  plugin_hash [] _hash ","  validate_id _hash "," plugin_hash []  is_a? "," validate_id  is_a? "]}," CodeRay PluginHost load_all":{"type":"method","name":"load_all","children":[],"call":[" load "," list "]}," CodeRay FileType fetch":{"type":"method","name":"fetch","children":[],"call":[" raise ","Could not determine type of %p. % "," block_given? "," [] "," warn ","Could not determine  []  of %p. % "]}," CodeRay FileType shebang":{"type":"method","name":"shebang","children":[],"call":["type to_sym ","first_line [] ","f gets ","File  open ","File  exist? ","first_line []  to_sym ","f gets  [] "]}," CodeRay FileType []":{"type":"method","name":"[]","children":[],"call":[" shebang ","TypeFromName  [] ","name downcase ","TypeFromExt  [] ","ext2 downcase ","ext downcase ","filename [] ","File  extname sub ","File  extname ","File  basename ","filename to_s [] ","filename to_s "," type_from_shebang ","File  basename  downcase ","filename []  downcase ","filename to_s []  downcase ","File  extname sub 2 downcase ","File  extname sub  downcase ","fileFile  basename  [] ","File  File  extname sub name sub ","File  extFile  basename  sub ","File  File  extname sub name ","File  extFile  basename  ","File  baseFile  basename  ","fileFile  basename  to_s [] ","fileFile  basename  to_s "]}," CodeRay ForRedCloth install":{"type":"method","name":"install","children":[{"type":"method","name":"unescape","children":[],"asgn":[null],"call":["replacements [] ","html gsub "]},{"type":"method","name":"code","children":[],"asgn":[{"type":"local","name":"highlighted_code","value":" unescape "},[" unescape "],{"type":"local","name":"highlighted_code","value":"CodeRay  encode "},["CodeRay  encode "],null,null],"call":["opts [] "," pba "," unescape ","m + "," pba ","highlighted_code sub! ","CodeRay  encode ","opts [] ","opts [] "," require "," filter_coderay ! "," filter_coderay ","opts [] ","opts []= "]},{"type":"method","name":"bc_open","children":[],"asgn":[null],"call":[" pba ","opts [] ","opts []= "]},{"type":"method","name":"bc_close","children":[],"asgn":[null],"call":["opts [] "]},{"type":"method","name":"escape_pre","children":[],"asgn":[null],"call":[" html_esc "]}],"call":[]}," CodeRay Encoders Debug end_line":{"type":"method","name":"end_line","children":[],"call":["@out << "]}," CodeRay Encoders Debug begin_line":{"type":"method","name":"begin_line","children":[],"call":["@out << << ","@out << ","kind to_s "]}," CodeRay Duo encoder":{"type":"method","name":"encoder","children":[],"call":["CodeRay  encoder "]}," CodeRay Duo scanner":{"type":"method","name":"scanner","children":[],"call":["CodeRay  scanner ","CodeRay  get_scanner_options "]}," CodeRay Scanners JSON scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << ","(sym :string) include? "," raise_inspect ","Error token %p in line %d % "," line ","kind ! "," matched ","else case \" reached; %p not handled. % "," peek "," scan "," getch ","match << ","IDENT_KIND  [] ","stack pop ","stack last == ","stack last ","stack << "," eos? ","encoder end_group ","Unknown state: %p % ","encoder text_token ","encoder begin_group ","options [] ","match empty? "," check ","IDENT_KIND  []  ! ","  scan ed "," scan  << "," scan  empty? "]}," CodeRay Scanners Scanner column":{"type":"method","name":"column","children":[],"call":["pos - "," string rindex "," string ","pos <= ","string rindex ","string dup force_encoding ","string dup ","string bytesize != ","string size ","string bytesize ","string respond_to? "," binary_string rindex "," binary_string ","  string  rindex "," string dup force_encoding  rindex ","  string  "," string dup force_encoding  "," string  rindex ","string dup force_encoding  rindex "," string  dup force_encoding ","string dup force_encoding  dup force_encoding "," string  dup ","string dup force_encoding  dup "," string  bytesize != ","string dup force_encoding  bytesize != "," string  size ","string dup force_encoding  size "," string  bytesize ","string dup force_encoding  bytesize "," string  respond_to? ","string dup force_encoding  respond_to? "," binary_ string  rindex "," binary_string dup force_encoding  rindex "," binary_ string  "," binary_string dup force_encoding  "]}," CodeRay TokenStream optimize":{"type":"method","name":"optimize","children":[],"call":[" raise "]}," CodeRay TokenStream dump":{"type":"method","name":"dump","children":[],"call":[" raise "]}," CodeRay TokenStream text_size":{"type":"method","name":"text_size","children":[],"call":[" raise "]}," CodeRay TokenStream <<":{"type":"method","name":"<<","children":[],"call":["@callback call "]}," CodeRay TokenStream initialize":{"type":"method","name":"initialize","children":[],"call":[" raise "]}," CodeRay TokenStream stream?":{"type":"method","name":"stream?","children":[],"call":[]}," CodeRay Tokens load":{"type":"method","name":"load","children":[],"call":[]}," CodeRay Tokens Undumping undump":{"type":"method","name":"undump","children":[],"call":["Tokens  load "]}," CodeRay Tokens text":{"type":"method","name":"text","children":[],"call":["(send nil :map) join ","t is_a? "," map "]}," CodeRay Tokens text_size":{"type":"method","name":"text_size","children":[],"call":["size + ","t size "," each_text_token "]}," CodeRay Tokens dump":{"type":"method","name":"dump","children":[],"call":["dump extend ","dump gzip ","Marshal  dump "," require ","GZip  gzip ","dump gzip  extend ","Marshal  dump  extend ","GZip  gzip  extend ","dump gzip  gzip ","Marshal  dump  gzip ","GZip  gzip  gzip ","Marshal  dump gzip  ","Marshal  Marshal  dump  ","Marshal  GZip  gzip  "]}," CodeRay Tokens split_into_lines!":{"type":"method","name":"split_into_lines!","children":[],"call":[" replace "," split_into_lines "]}," CodeRay Tokens split_into_lines":{"type":"method","name":"split_into_lines","children":[],"call":[" raise "]}," CodeRay Tokens fix!":{"type":"method","name":"fix!","children":[],"call":[" replace "," fix "]}," CodeRay Tokens fix":{"type":"method","name":"fix","children":[],"call":["tokens << ","opened pop "," token ","(lvasgn :token\n  (send\n    (lvar :opened) :pop)) == ","opened rindex ","(lvar :type) != ","opened push "," class new "," class "," raise ","opened pop s << "," class new  << "," opened pop  ","(lvasgn :opened pop \n  (send\n    (lvar :opened) :pop)) == "]}," CodeRay Tokens optimize!":{"type":"method","name":"optimize!","children":[],"call":[" replace "," optimize "]}," CodeRay Tokens optimize":{"type":"method","name":"optimize","children":[],"call":[" print ","after: %d (%d saved = %2.0f%%) % ","1.0 - ","new size to_f / "," size ","new size to_f ","new size "," size - ","new << ","last_text << ","kind == ","text is_a? "," class new "," class "," Tokens#optimize: before: %d -  % "," raise "," class new  size to_f / "," class new  size to_f "," class new  size "," class new  << "," class  class new  "]}," CodeRay Tokens method_missing":{"type":"method","name":"method_missing","children":[],"call":["Encoders  [] new encode_tokens ","Encoders  [] new ","Encoders  [] "," encode "," encode_with "]}," CodeRay Tokens to_s":{"type":"method","name":"to_s","children":[],"call":[" encode ","CodeRay Encoders Encoder  new "]}," CodeRay Tokens encode":{"type":"method","name":"encode","children":[],"call":["encoder encode_tokens ","encoder_class new ","Encoders  [] ","encoder is_a? ","Encoders  [] new ","encoder respond_to? ","encoder_class new  encode_tokens ","Encoders  [] new  encode_tokens ","encoder_class new _class new ","Encoders  [] new _class new ","Encoders  []  new ","encoder_class new  is_a? ","Encoders  [] new  is_a? ","encoder_class new  respond_to? ","Encoders  [] new  respond_to? "]}," CodeRay Tokens each_text_token":{"type":"method","name":"each_text_token","children":[],"call":["text is_a? "," each "]}," CodeRay Tokens each":{"type":"method","name":"each","children":[],"call":["kind == "]}," CodeRay Tokens stream?":{"type":"method","name":"stream?","children":[],"call":[]}," CodeRay Scanners Python scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << ","state == ","match == "," raise_inspect ","Error token %p in line %d % "," line ","kind ! "," matched ","from_import_state pop ","from_import_state last == ","from_import_state last "," scan "," unscan ","IDENT_KIND  [] == ","IDENT_KIND  [] ","from_import_state << ","from_import_state first == ","from_import_state first "," getch ","match << "," [] == "," [] ","match to_sym ","DEF_NEW_STATE  [] ","kind == "," check ","modifiers index ! ! ","modifiers index ! ","modifiers index ","modifiers empty? ","else case \" reached; %p not handled. % "," peek ","string_raw ! ","STRING_CONTENT_REGEXP  [] ","string_delimiter size == ","string_delimiter size ","STRING_DELIMITER_REGEXP  [] "," eos? "," string encoding name == "," string encoding name "," string encoding "," string "," string respond_to? ","encoder end_group ","encoder text_token ","encoder begin_group "," match? ","modifiers == ","match empty? ","DEF_NEW_STATE  []  == "," scan  == ","IDENT_KIND  []  ! ","  scan ed ","from_import_DEF_NEW_STATE  []  pop ","from_import_DEF_NEW_STATE  []  last == ","from_import_DEF_NEW_STATE  []  last ","from_import_DEF_NEW_STATE  []  << ","from_import_DEF_NEW_STATE  []  first == ","from_import_DEF_NEW_STATE  []  first "," scan  << "," scan  to_sym ","IDENT_KIND  []  == "," []  index ! ! "," []  index ! "," []  index "," []  empty? ","modifiers index ! !  ! "," []  size == "," []  size ","  scan ? "," []  == "," scan  empty? "]}," CodeRay Scanners JavaScript xml_scanner":{"type":"method","name":"xml_scanner","children":[],"call":["CodeRay  scanner "]}," CodeRay Scanners JavaScript reset_instance":{"type":"method","name":"reset_instance","children":[],"call":["@xml_scanner reset "]}," CodeRay Scanners Groovy scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << ","(sym :multiline_string) include? ","(sym :space) include? "," raise_inspect ","Error token %p in line %d % "," line ","kind ! "," matched ","else case \" reached; %p not handled. % "," peek "," scan ","inline_block_stack << ","IDENT_KIND  [] ","match [] ","state == ","(or\n  (send\n    (lvar :match) :==\n    (str \"\\\\\\\\\"))\n  (send\n    (lvar :match) :==\n    (str \"\\\\'\"))) ! ","match == ","string_delimiter [] == ","string_delimiter [] ","modifiers empty? ! ","modifiers empty? ","STRING_CONTENT_PATTERN  [] "," getch "," check ","inline_block_stack pop ","inline_block_paren_depth == ","inline_block_stack empty? ! ","inline_block_stack empty? ","last_token != ","kind == ","last_token == ","KEYWORDS_EXPECTING_VALUE  [] "," bol? ","match index "," eos? ","encoder end_group ","encoder text_token ","encoder begin_group ","options [] ","IDENT_KIND  []  ! ","  scan ed "," match [] ed "," scan  [] ","match []  [] ","(or\n  (send\n    (lvar : scan ) :==\n    (str \"\\\\\\\\\"))\n  (send\n    (lvar : scan ) :==\n    (str \"\\\\'\"))) ! ","(or\n  (send\n    (lvar :match [] ) :==\n    (str \"\\\\\\\\\"))\n  (send\n    (lvar :match [] ) :==\n    (str \"\\\\'\"))) ! "," scan  == ","match []  == "," scan  empty? ! "," scan  empty? ","IDENT_KIND  []  == "," scan  index ","match []  index "]}," CodeRay Scanners CPlusPlus scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << ","state == "," raise_inspect ","Error token %p in line %d % "," line ","kind ! "," matched "," getch "," scan ","match index ","else case \" reached; %p not handled. % "," peek "," [] == "," [] ","match [] == ","match [] ","kind == ","match << ","in_preproc_line ! ","IDENT_KIND  [] ","match == ","match =~ "," scan_until "," eos? ","match != ","encoder end_group ","encoder text_token ","encoder begin_group ","match empty? ","IDENT_KIND  []  ! ","  scan ed "," scan  index "," scan  [] == "," scan  [] ","IDENT_KIND  []  == "," scan  << "," scan  == "," scan  =~ "," scan  != "," scan  empty? "]}," CodeRay Scanners Scanner marshal_load":{"type":"method","name":"marshal_load","children":[],"call":[]}," CodeRay Scanners Scanner marshal_dump":{"type":"method","name":"marshal_dump","children":[],"call":[]}," CodeRay Scanners Scanner lang":{"type":"method","name":"lang","children":[],"call":[" class plugin_id "," class "," class lang "," class plugin_id to_s "]}," CodeRay CaseIgnoringWordList Uncached []":{"type":"method","name":"[]","children":[],"call":["key downcase "]}," CodeRay Plugin title":{"type":"method","name":"title","children":[],"call":[" name [] "," name ","title to_s "]}," CodeRay Encoders TokenClassFilter include_text_token?":{"type":"method","name":"include_text_token?","children":[],"call":["(or\n  (send\n    (ivar :@exclude) :==\n    (sym :all))\n  (send\n    (ivar :@exclude) :include?\n    (lvar :kind))) ! ","@exclude include? ","@exclude == ","@include include? ","@include == "]}," CodeRay Encoders TokenClassFilter setup":{"type":"method","name":"setup","children":[],"call":[" Array ","@include == ","options [] ","@exclude == "," Array  == ","options []  == "]}," CodeRay Encoders Text text_token":{"type":"method","name":"text_token","children":[],"call":["text + ","@out << "]}," CodeRay Encoders Term col":{"type":"method","name":"col","children":[],"call":["(send\n  (send nil :Array\n    (lvar :color)) :map) join "," Array map "," Array "]}," CodeRay Encoders Term token":{"type":"method","name":"token","children":[],"call":[" raise ","unknown token kind: %p % ","@opened pop ","@out << "," col ","(or\n  (ivar :@subcolors)\n  (hash)) [] ","@opened empty? ","@opened << ","color [] ","Hash  === ","TOKEN_COLORS  [] ","@opened []= ","@subcolors [] "," col + + "," col + ","text gsub ","(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) [] ","(or\n  (ivar :@subTOKEN_COLORS  [] s)\n  (hash)) [] ","(or\n  (ivar :@sub(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) [] s)\n  (hash)) [] ","TOKEN_COLORS  []  [] ","(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) []  [] ","@subTOKEN_COLORS  [] s [] ","@sub(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) [] s [] ","(or\n  (ivar :@subTOKEN_COLORS  [] s)\n  (const nil :TOKEN_COLORS)) [] ","(or\n  (ivar :@sub(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) [] s)\n  (const nil :TOKEN_COLORS)) [] "]}," CodeRay Encoders Term finish":{"type":"method","name":"finish","children":[],"call":[]}," CodeRay Encoders Term setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Encoders LinesOfCode finish":{"type":"method","name":"finish","children":[],"call":[" output ","@tokens text scan size ","@tokens text scan ","@tokens text ","@out to_s scan size ","@out to_s scan ","@out to_s "]}," CodeRay Encoders LinesOfCode compile":{"type":"method","name":"compile","children":[],"call":["code text scan size ","code text scan ","code text ","tokens token_class_filter "," warn ","scanner class ","tokens scanner ","tokens token_kind_filter ","code to_s scan size ","code to_s scan ","code to_s ","tokens token_class_filter  text scan size ","tokens token_kind_filter  text scan size ","tokens token_class_filter  text scan ","tokens token_kind_filter  text scan ","tokens token_class_filter  text ","tokens token_kind_filter  text ","tokens scanner  class ","tokens tokens scanner  ","tokens token_class_filter  to_s scan size ","tokens token_kind_filter  to_s scan size ","tokens token_class_filter  to_s scan ","tokens token_kind_filter  to_s scan ","tokens token_class_filter  to_s ","tokens token_kind_filter  to_s "]}," CodeRay Encoders JSON finish":{"type":"method","name":"finish","children":[],"call":["@out to_json ","@out << "]}," CodeRay Encoders JSON block_token":{"type":"method","name":"block_token","children":[],"call":[]}," CodeRay Encoders JSON text_token":{"type":"method","name":"text_token","children":[],"call":[" append ","@out << "]}," CodeRay Encoders JSON setup":{"type":"method","name":"setup","children":[],"call":[" require ","@out << "]}," CodeRay Encoders HTML Output apply_title!":{"type":"method","name":"apply_title!","children":[],"call":["1 + + ","1 + "," sub! "]}," CodeRay Encoders Filter include_block_token?":{"type":"method","name":"include_block_token?","children":[],"call":[]}," CodeRay Encoders Filter block_token":{"type":"method","name":"block_token","children":[],"call":[" include_block_token? "]}," CodeRay Encoders Filter include_text_token?":{"type":"method","name":"include_text_token?","children":[],"call":[]}," CodeRay Encoders Filter text_token":{"type":"method","name":"text_token","children":[],"call":[" include_text_token? ","@tokens text_token ","@out text_token "]}," CodeRay Encoders Filter setup":{"type":"method","name":"setup","children":[],"call":["Tokens  new ","options [] "]}," CodeRay Encoders Encoder end_line":{"type":"method","name":"end_line","children":[],"call":[]}," CodeRay Encoders Encoder begin_line":{"type":"method","name":"begin_line","children":[],"call":[]}," CodeRay Encoders Encoder close_token":{"type":"method","name":"close_token","children":[],"call":[]}," CodeRay Encoders Encoder open_token":{"type":"method","name":"open_token","children":[],"call":[]}," CodeRay Encoders Encoder append_encoded_token_to_output":{"type":"method","name":"append_encoded_token_to_output","children":[],"call":["@out << "]}," CodeRay Scanners CSS scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["tokens << "," raise_inspect ","Error token %p in line %d % "," line ","kind ! "," matched "," getch ","match == "," scan ","match [] ","start size ","match [] == ","match size >= ","match size ","match size > ","states pop ","states last == ","states last ","states push ","states []= "," eos? ","encoder text_token ","encoder end_group ","encoder begin_group ","options [] "," Array ","start size + "," Array dup ","  scan ed "," scan  == "," scan  [] ","match []  size "," scan  [] == "," scan  size >= "," scan  size "," scan  size > "," Array  pop "," Array dup  pop "," Array  last == "," Array dup  last == "," Array  last "," Array dup  last "," Array  push "," Array dup  push "," Array  []= "," Array dup  []= ","match []  size + "]}," CodeRay Scanners Scanner scan_rest":{"type":"method","name":"scan_rest","children":[],"call":[" terminate "," rest ","  rest  "]}," CodeRay TokensProxy each":{"type":"method","name":"each","children":[],"call":[" tokens each "," tokens "]}," CodeRay TokensProxy scanner":{"type":"method","name":"scanner","children":[],"call":["CodeRay  scanner "," block "," options "," lang "]}," CodeRay TokensProxy tokens":{"type":"method","name":"tokens","children":[],"call":[" scanner tokenize "," input "," scanner "]}," CodeRay TokensProxy method_missing":{"type":"method","name":"method_missing","children":[],"call":[" tokens send "," tokens "," encode ","method to_sym "]}," CodeRay TokensProxy encode":{"type":"method","name":"encode","children":[],"call":["encoder encode_tokens "," tokens ","CodeRay  encode "," lang "," input ","encoder respond_to? "]}," CodeRay TokensProxy initialize":{"type":"method","name":"initialize","children":[],"call":[]}," CodeRay Tokens end_line":{"type":"method","name":"end_line","children":[],"call":[" push "," << << "," << "]}," CodeRay Tokens begin_line":{"type":"method","name":"begin_line","children":[],"call":[" push "," << << "," << "]}," CodeRay Tokens end_group":{"type":"method","name":"end_group","children":[],"call":[" push "," << << "," << "]}," CodeRay Tokens begin_group":{"type":"method","name":"begin_group","children":[],"call":[" push "," << << "," << "]}," CodeRay Tokens count":{"type":"method","name":"count","children":[],"call":[" size / "," size "]}," CodeRay Tokens split_into_parts":{"type":"method","name":"split_into_parts","children":[],"call":["parts << ","Tokens  new ","parts size < ","sizes size ","parts size "," raise ","Token input junk: %p, kind = %p % ","part << << ","part << ","Unknown token action: %p, kind = %p % ","opened pop ","opened << ","content size ","content empty? ","part concat ","opened flatten ","sizes [] ","size > ","size nil? ","opened reverse flatten map ","opened reverse flatten ","opened reverse ","content slice! ","size - ","content dup ","part_size < ","part_size + > ","part_size + ","sizes first ","Array  new "," first == "," first "," size == "," size ","Tokens  new s << ","parts sizes []  < ","parts sizes first  < ","Tokens  new s size < ","sizes [] s sizes []  ","sizes first s sizes first  ","parts sizes []  ","parts sizes first  ","Tokens  new s size ","Tokens  new  << << ","Tokens  new  << ","content sizes []  ","content sizes first  ","content dup  size ","content dup  empty? ","Tokens  new  concat ","sizes [] s [] ","sizes first s [] ","sizes []  > ","sizes first  > ","sizes []  nil? ","sizes first  nil? ","content dup  slice! ","sizes []  - ","sizes first  - ","content dup  dup ","part_sizes []  < ","part_sizes first  < ","Tokens  new _size < ","part_sizes []  + > ","part_sizes first  + > ","Tokens  new _size + > ","part_sizes []  + ","part_sizes first  + ","Tokens  new _size + ","sizes [] s first ","sizes first s first "," sizes []  == "," sizes first  == "," sizes []  "," sizes first  "]}," CodeRay Scanners Text scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["encoder text_token "," string "]}," CodeRay Scanners Ruby setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Scanners Ruby interpreted_string_state":{"type":"method","name":"interpreted_string_state","children":[],"call":["StringState  new "]}," CodeRay Scanners Ruby StringState heredoc_pattern":{"type":"method","name":"heredoc_pattern","children":[],"call":["Regexp  new ","Regexp  escape "]}," CodeRay Scanners Raydebug scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["encoder end_group ","opened_tokens pop ","opened_tokens empty? ","encoder text_token "," getch "," scan ","opened_tokens empty? ! "," [] ","encoder begin_group ","opened_tokens << ","kind to_sym "," raise "," eos? "," [] to_sym ","@known_token_kinds include? ","match empty? ","kind to_sym  to_sym "," []  to_sym "," [] to_sym  to_sym ","@known_token_kind to_sym s include? ","@known_token_ [] s include? ","@known_token_ [] to_sym s include? "," scan  empty? "," []  empty? "]}," CodeRay Scanners HTML scan_java_script":{"type":"method","name":"scan_java_script","children":[],"call":["@java_script_scanner tokenize ","Scanners JavaScript  new ","code empty? ! ","code empty? "]}," CodeRay Scanners HAML scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["encoder text_token "," scan ","@html_scanner tokenize "," [] ","@ruby_scanner tokenize ","@embedded_ruby_scanner tokenize "," [] + ","code empty? ","code << ","level > "," getch "," [] == "," raise ","else-case reached: %p % ","@java_script_scanner tokenize ","CodeRay  scanner "," bol? "," eos? ","en [] r text_token "," []  empty? "," []  << "]}," CodeRay Scanners HAML setup":{"type":"method","name":"setup","children":[],"call":["CodeRay  scanner ","@ruby_scanner interpreted_string_state ","CodeRay  scanner  interpreted_string_state "]}," CodeRay Scanners ERB scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":[" raise_inspect ","encoder end_group ","encoder text_token ","end_tag empty? ","@ruby_scanner tokenize ","start_tag == ","code empty? ","encoder begin_group "," [] "," scan ","@html_scanner tokenize ","match empty? ! ","match empty? "," scan_rest "," scan_until "," eos? ","start_tag [] ","match [] ","-1 - ","end_tag size ","start_tag size ","en [] r end_group ","enmatch [] r end_group ","en [] r text_token ","enmatch [] r text_token "," []  empty? ","match []  empty? "," []  == ","match []  == ","en [] r begin_group ","enmatch [] r begin_group "," scan  empty? ! "," scan  empty? "," []  [] ","match []  [] "," scan  [] "," []  size ","match []  size "]}," CodeRay Scanners ERB reset_instance":{"type":"method","name":"reset_instance","children":[],"call":["@html_scanner reset "]}," CodeRay Scanners ERB setup":{"type":"method","name":"setup","children":[],"call":["CodeRay  scanner "]}," CodeRay Scanners Diff diff":{"type":"method","name":"diff","children":[],"call":["a [] ","j + ","j < ","b [] ","a [] == ","j >= ","i - ","i < ","(send\n  (lvar :a) :size) min ","b size ","a size "]}," CodeRay Scanners Clojure scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["encoder end_group ","(sym :string) include? "," raise "," raise_inspect ","else case \" reached; %p not handled. % "," peek ","encoder text_token "," scan "," getch ","match [] "," matched empty? ! "," matched empty? "," matched ","encoder begin_group "," [] ","KEYWORD_NEXT_TOKEN_KIND  [] ","kind == "," rest? ","IDENT_KIND  [] "," eos? ","ident_kind [] "," scan  [] ","  scan ed empty? ! ","  scan ed empty? ","  scan ed ","KEYWORD_NEXT_TOKEN_KIND  []  == ","IDENT_KIND  []  == ","ident_KEYWORD_NEXT_TOKEN_KIND  []  [] ","ident_IDENT_KIND  []  [] "]}," CodeRay Scanners Scanner binary_string":{"type":"method","name":"binary_string","children":[],"call":[" string "," string dup force_encoding "," string dup "," string bytesize != "," string size "," string bytesize "," string respond_to? "]}," CodeRay Scanners Scanner guess_encoding":{"type":"method","name":"guess_encoding","children":[],"call":["Encoding  find ","file gets [] ","file gets ","file close_write ","file write ","s [] ","IO  popen "]}," CodeRay Scanners Scanner to_unix":{"type":"method","name":"to_unix","children":[],"call":["code gsub ","code index "]}," CodeRay Scanners Scanner encode_with_encoding":{"type":"method","name":"encode_with_encoding","children":[],"call":["code encode ","code encoding "," guess_encoding "," to_unix ","code valid_encoding? ","code encoding == "]}," CodeRay Scanners Scanner encoding":{"type":"method","name":"encoding","children":[],"call":["Encoding  find "]}," CodeRay Scanners Scanner normalize":{"type":"method","name":"normalize","children":[],"call":[" to_unix "," encode_with_encoding "," encoding ","code respond_to? ","code empty? ","code to_s ","code is_a? ","code index "," en to_unix _with_encoding "," en encode_with_encoding _with_encoding "," encode to_s _with_encoding "," to_unix  respond_to? "," encode_with_encoding  respond_to? ","code to_s  respond_to? "," to_unix  empty? "," encode_with_encoding  empty? ","code to_s  empty? "," to_unix  to_s "," encode_with_encoding  to_s ","code to_s  to_s "," to_unix  is_a? "," encode_with_encoding  is_a? ","code to_s  is_a? "," to_unix  index "," encode_with_encoding  index ","code to_s  index "]}," CodeRay CaseIgnoring []=":{"type":"method","name":"[]=","children":[],"call":["key downcase "]}," CodeRay CaseIgnoring []":{"type":"method","name":"[]","children":[],"call":["key downcase "]}," CodeRay Plugin aliases":{"type":"method","name":"aliases","children":[],"call":["aliases << "," plugin_host [] == "," plugin_host [] "," plugin_host "," plugin_host plugin_hash inject "," plugin_host plugin_hash "," plugin_host load_plugin_map "]}," CodeRay PluginHost make_plugin_hash":{"type":"method","name":"make_plugin_hash","children":[],"call":[" raise ","id inspect "," name ","h [] ","h has_key? "," load_plugin_map ","%p could not load plugin %p: %s % "," warn ","%p could not load plugin %p; falling back to %p % "," require ","File  exist? "," path_to "," validate_id ","Hash  new "," load_map ","Could not load plugin %p: %s % "," validate_id  inspect ","  path_to _to "," val validate_id ate_ validate_id  "]}," CodeRay PluginHost load_plugin_map":{"type":"method","name":"load_plugin_map","children":[],"call":[" require ","File  exist? "," path_to "]}," CodeRay PluginHost all_plugins":{"type":"method","name":"all_plugins","children":[],"call":[" plugin_hash values grep "," plugin_hash values "," plugin_hash "," load_all "]}," CodeRay PluginHost const_missing":{"type":"method","name":"const_missing","children":[],"call":[" load ","const to_s gsub gsub downcase ","const to_s gsub gsub ","const to_s gsub ","const to_s "]}," CodeRay GZip gzip":{"type":"method","name":"gzip","children":[],"call":[]}," CodeRay GZip gunzip":{"type":"method","name":"gunzip","children":[],"call":[]}," CodeRay Encoders YAML end_line":{"type":"method","name":"end_line","children":[],"call":["@data << ","@out << "]}," CodeRay Encoders YAML begin_line":{"type":"method","name":"begin_line","children":[],"call":["@data << ","@out << "]}," CodeRay Encoders YAML end_group":{"type":"method","name":"end_group","children":[],"call":["@data << ","@out << "]}," CodeRay Encoders YAML begin_group":{"type":"method","name":"begin_group","children":[],"call":["@data << ","@out << "]}," CodeRay Encoders YAML text_token":{"type":"method","name":"text_token","children":[],"call":["@data << ","@out << "]}," CodeRay Encoders YAML finish":{"type":"method","name":"finish","children":[],"call":[" output "," YAML  dump ","@out to_a to_yaml ","@out to_a ","YAML  dump "]}," CodeRay Encoders YAML setup":{"type":"method","name":"setup","children":[],"call":[" require "]}," CodeRay Encoders XML end_group":{"type":"method","name":"end_group","children":[],"call":["@node parent "," raise ","@node == ","@node parent  parent ","@node parent  == "]}," CodeRay Encoders XML begin_group":{"type":"method","name":"begin_group","children":[],"call":["@node add_element ","kind to_s ","@node add_element  add_element "]}," CodeRay Encoders TokenKindFilter end_line":{"type":"method","name":"end_line","children":[],"call":["@group_excluded zero? "]}," CodeRay Encoders TokenKindFilter end_group":{"type":"method","name":"end_group","children":[],"call":["@group_excluded zero? "]}," CodeRay Encoders TokenKindFilter begin_line":{"type":"method","name":"begin_line","children":[],"call":[" include_group? "]}," CodeRay Encoders TokenKindFilter begin_group":{"type":"method","name":"begin_group","children":[],"call":[" include_group? "]}," CodeRay Encoders TokenKindFilter text_token":{"type":"method","name":"text_token","children":[],"call":[" include_text_token? ","@group_excluded ! "]}," CodeRay Encoders TokenKindFilter include_group?":{"type":"method","name":"include_group?","children":[],"call":["(or\n  (send\n    (ivar :@exclude) :==\n    (sym :all))\n  (send\n    (ivar :@exclude) :include?\n    (lvar :kind))) ! ","@exclude include? ","@exclude == ","@include include? ","@include == "]}," CodeRay Encoders TokenKindFilter include_text_token?":{"type":"method","name":"include_text_token?","children":[],"call":[" include_group? "]}," CodeRay Encoders TokenKindFilter setup":{"type":"method","name":"setup","children":[],"call":[" Array ","@include == ","options [] ","@exclude == "," Array  == ","options []  == "]}," CodeRay Encoders Terminal ansi_clear":{"type":"method","name":"ansi_clear","children":[],"call":[" ansi_colorize "]}," CodeRay Encoders Terminal ansi_colorize":{"type":"method","name":"ansi_colorize","children":[],"call":["(send\n  (send nil :Array\n    (lvar :color)) :map) join "," Array map "," Array "]}," CodeRay Encoders Terminal open_token":{"type":"method","name":"open_token","children":[],"call":[" ansi_colorize ","color [] ","Hash  === ","TOKEN_COLORS  [] ","@color_scopes << ","@color_scopes last ","color is_a? ","@color_scopes last [] "," ansi_TOKEN_COLORS  [] ize "," ansi_@color_scopes last [] ize ","TOKEN_COLORS  []  [] ","@color_scopes last []  [] ","@TOKEN_COLORS  [] _scopes << ","@@color_scopes last [] _scopes << ","@TOKEN_COLORS  [] _scopes last ","@@color_scopes last [] _scopes last ","TOKEN_COLORS  []  is_a? ","@color_scopes last []  is_a? ","@TOKEN_COLORS  [] _scopes last [] ","@@color_scopes last [] _scopes last [] "]}," CodeRay Encoders Terminal end_line":{"type":"method","name":"end_line","children":[],"call":["@out << "," open_token ","@opened last ","\t * + "," ansi_clear ","\t * ","@opened pop ","@opened empty? "," end_group "]}," CodeRay Encoders Terminal end_group":{"type":"method","name":"end_group","children":[],"call":["@out << "," open_token ","@opened last "," ansi_clear ","@opened pop ","@opened empty? ","@color_scopes last [] ","@color_scopes last ","@color_scopes pop "]}," CodeRay Encoders Terminal begin_group":{"type":"method","name":"begin_group","children":[],"call":["@out << "," open_token ","@opened << "]}," CodeRay Encoders Terminal text_token":{"type":"method","name":"text_token","children":[],"call":["@out << "," ansi_colorize ","@subcolors [] "," ansi_clear ","text gsub "," ansi_clear + + "," ansi_clear + ","color [] ","Hash  === ","(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) [] ","@color_scopes last [] ","@color_scopes last ","\u001b[0m\n + ","text index ","color is_a? "," ansi_color [] ize "," ansi_(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) [] ize "," ansi_@color_scopes last [] ize ","@subcolor [] s [] ","@sub(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) [] s [] ","@sub@color_scopes last [] s [] ","color []  [] ","(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) []  [] ","@color_scopes last []  [] ","(or\n  (ivar :@subcolor [] s)\n  (const nil :TOKEN_COLORS)) [] ","(or\n  (ivar :@sub(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) [] s)\n  (const nil :TOKEN_COLORS)) [] ","(or\n  (ivar :@sub@color_scopes last [] s)\n  (const nil :TOKEN_COLORS)) [] ","@color [] _scopes last [] ","@(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) [] _scopes last [] ","@@color_scopes last [] _scopes last [] ","@color [] _scopes last ","@(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) [] _scopes last ","@@color_scopes last [] _scopes last ","color []  is_a? ","(or\n  (ivar :@subcolors)\n  (const nil :TOKEN_COLORS)) []  is_a? ","@color_scopes last []  is_a? "]}," CodeRay Encoders Terminal setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Encoders Statistic end_line":{"type":"method","name":"end_line","children":[],"call":[" block_token "]}," CodeRay Encoders Statistic begin_line":{"type":"method","name":"begin_line","children":[],"call":[" block_token "]}," CodeRay Encoders Statistic end_group":{"type":"method","name":"end_group","children":[],"call":[" block_token "]}," CodeRay Encoders Statistic begin_group":{"type":"method","name":"begin_group","children":[],"call":[" block_token "]}," CodeRay Encoders Null text_token":{"type":"method","name":"text_token","children":[],"call":[]}," CodeRay Encoders LinesOfCode setup":{"type":"method","name":"setup","children":[],"call":["options []= "," warn "," scanner class "," scanner "]}," CodeRay Encoders JSON end_line":{"type":"method","name":"end_line","children":[],"call":[" append ","@out << "]}," CodeRay Encoders JSON begin_line":{"type":"method","name":"begin_line","children":[],"call":[" append ","@out << "]}," CodeRay Encoders JSON end_group":{"type":"method","name":"end_group","children":[],"call":[" append ","@out << "]}," CodeRay Encoders JSON begin_group":{"type":"method","name":"begin_group","children":[],"call":[" append ","@out << "]}," CodeRay Encoders JSON append":{"type":"method","name":"append","children":[],"call":["@out << ","data to_json "]}," CodeRay Encoders HTML end_line":{"type":"method","name":"end_line","children":[],"call":["@opened last ","@out << ","@opened pop "," warn ","(str \"Malformed token stream: Trying to close a line (%p) \") % ","@opened [] ","@opened last != ","@opened empty? ","@opened size == ","@opened size "," close_span "," check_group_nesting "]}," CodeRay Encoders HTML begin_line":{"type":"method","name":"begin_line","children":[],"call":["@options [] == ","@options [] ","@opened << ","@out << ","style sub ","style [] ","@span_for_kind [] ","@css_style [] ","@opened []= ","@span_for_kinds [] ","@span_for_kind []  sub ","@css_style []  sub ","@span_for_kinds []  sub ","@span_for_kind []  [] ","@css_style []  [] ","@span_for_kinds []  [] ","@css_@span_for_kind []  [] ","@css_@css_style []  [] ","@css_@span_for_kinds []  [] "]}," CodeRay Encoders HTML end_group":{"type":"method","name":"end_group","children":[],"call":["@opened last ","@out << ","@opened pop "," warn ","(str \"Malformed token stream: Trying to close a token (%p) \") % ","@opened [] ","@opened last != ","@opened empty? ","@opened size == ","@opened size "," close_span "," check_group_nesting "]}," CodeRay Encoders HTML begin_group":{"type":"method","name":"begin_group","children":[],"call":["@opened << ","@out << ","@span_for_kind [] ","@css_style [] ","@opened []= ","@options [] == ","@options [] ","@span_for_kinds [] "]}," CodeRay Encoders HTML text_token":{"type":"method","name":"text_token","children":[],"call":["@out << ","@out << << << ","@out << << ","@span_for_kind [] ","@HTML_ESCAPE [] ","text gsub ","text =~ ","style + + ","style + ","@css_style [] ","@opened []= ","text []= ","text [] gsub ","text [] ","reopen << ","@opened [] ","index > ","@opened each_with_index ","</span> * ","(lvasgn :c\n  (send\n    (send\n      (ivar :@opened) :size) :+\n    (begin\n      (if\n        (lvar :style)\n        (int 1)\n        (int 0))))) > ","@opened size + ","@opened size ","text index "," break_lines ","@opened size > ","@span_for_kinds [] ","@span_for_ktext index nd [] "," break_lines  gsub "," break_lines  =~ ","@span_for_kind []  + + ","@css_style []  + + ","@span_for_kinds []  + + ","@span_for_kind []  + ","@css_style []  + ","@span_for_kinds []  + ","@css_@span_for_kind []  [] ","@css_@css_style []  [] ","@css_@span_for_kinds []  [] ","@@opened size + ss_style [] "," break_lines  []= "," break_lines  [] gsub "," break_lines  [] ","text index ndex > ","@opened ea@opened size + h_with_index ","@opened each_wtext index th_text index ndex ","(lvasgn :c\n  (send\n    (send\n      (ivar :@opened) :size) :+\n    (begin\n      (if\n        (lvar :@span_for_kind [] )\n        (int 1)\n        (int 0))))) > ","(lvasgn :c\n  (send\n    (send\n      (ivar :@opened) :size) :+\n    (begin\n      (if\n        (lvar :@css_style [] )\n        (int 1)\n        (int 0))))) > ","(lvasgn :c\n  (send\n    (send\n      (ivar :@opened) :size) :+\n    (begin\n      (if\n        (lvar :@span_for_kinds [] )\n        (int 1)\n        (int 0))))) > ","(lvasgn :@opened size + \n  (send\n    (send\n      (ivar :@opened) :size) :+\n    (begin\n      (if\n        (lvar :style)\n        (int 1)\n        (int 0))))) > ","(lvasgn :c\n  (send\n    (send\n      (text index var :@opened) :stext index ze) :+\n    (begtext index n\n      (text index f\n        (lvar :style)\n        (text index nt 1)\n        (text index nt 0))))) > ","@opened stext index ze + ","@opened stext index ze ","text text index ndex "," break_lines  index "," break_ltext index nes ","@opened stext index ze > ","@span_for_ktext index nds [] "]}," CodeRay Encoders HTML Numbering number!":{"type":"method","name":"number!","children":[],"call":[]}," CodeRay Encoders HTML CSS get_style":{"type":"method","name":"get_style","children":[],"call":["cl [] ","styles [] ","1 upto ","styles size ","@classes [] ","styles first ","@classes []  [] ","cl [] s [] ","cl [] s size ","@@classes [] asses [] ","cl [] s first "]}," CodeRay Encoders Filter end_line":{"type":"method","name":"end_line","children":[],"call":["@tokens end_line ","@out end_line "]}," CodeRay Encoders Filter end_group":{"type":"method","name":"end_group","children":[],"call":["@tokens end_group ","@out end_group "]}," CodeRay Encoders Filter begin_line":{"type":"method","name":"begin_line","children":[],"call":["@tokens begin_line ","@out begin_line "]}," CodeRay Encoders Filter begin_group":{"type":"method","name":"begin_group","children":[],"call":["@tokens begin_group ","@out begin_group "]}," CodeRay Encoders Filter finish":{"type":"method","name":"finish","children":[],"call":[" output "]}," CodeRay Encoders Debug end_group":{"type":"method","name":"end_group","children":[],"call":["@out << ","@opened pop "," raise ","@opened inspect "," puts ","@opened last != ","@opened last "]}," CodeRay Encoders Debug begin_group":{"type":"method","name":"begin_group","children":[],"call":["@out << << ","@out << ","kind to_s ","@opened << "]}," CodeRay Encoders Debug initialize":{"type":"method","name":"initialize","children":[],"call":[]}," CodeRay Encoders Count begin_group":{"type":"method","name":"begin_group","children":[],"call":[]}," CodeRay Encoders Count text_token":{"type":"method","name":"text_token","children":[],"call":[]}," CodeRay Encoders Count finish":{"type":"method","name":"finish","children":[],"call":[" output "]}," CodeRay Encoders Encoder output":{"type":"method","name":"output","children":[],"call":["@out << ","data to_s "]}," CodeRay Encoders Encoder get_output":{"type":"method","name":"get_output","children":[],"call":["options [] "," dup "]}," CodeRay Encoders Encoder end_group":{"type":"method","name":"end_group","children":[],"call":[]}," CodeRay Encoders Encoder begin_group":{"type":"method","name":"begin_group","children":[],"call":[]}," CodeRay Encoders Encoder <<":{"type":"method","name":"<<","children":[],"call":[" token "," warn "]}," CodeRay Tokens encode_with":{"type":"method","name":"encode_with","children":[],"call":["Encoders  [] new encode_tokens ","Encoders  [] new ","Encoders  [] "]}," CodeRay Encoders HTML Output number!":{"type":"method","name":"number!","children":[],"call":[" raise ","Unknown value %p for mode: expected one of %p % "," wrap_in! "," gsub! ","TABLE  apply ","line_numbers << ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line_count))) to_a map join ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line_count))) to_a map ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line_count))) to_a ","start + "," line_count ","  * ","max_width - ","line_number to_s size ","line_number to_s ","bolding call ","</span> * ","opened_tags size ","opened_tags << ","opened_tags pop ","line scan ","opened_tags join ","line chomp! ","(send\n  (lvar :start) :+\n  (send nil :line_count)) to_s size ","(send\n  (lvar :start) :+\n  (send nil :line_count)) to_s ","Invalid value %p for :bolding; false or Integer expected. % ","anchoring [] ","line % == ","line % "," proc ","bold_every == ","bold_every is_a? ","highlight_lines include? ","highlight_lines to_set ","highlight_lines is_a? ","highlight_lines == ","options [] ","line to_s ","anchor_prefix + ","anchor_prefix to_s [] ","anchor_prefix to_s ","anchor_prefix == ","Invalid value %p for :line_number_start; Integer expected. % ","start is_a? ","DEFAULT_OPTIONS  merge ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line_count))) to_a map join  << ","line to_s _numbers << ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line to_s _count))) to_a map join ","(erange\n  (lvar :options [] )\n  (send\n    (lvar :options [] ) :+\n    (send nil :line_count))) to_a map join ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line to_s _count))) to_a map ","(erange\n  (lvar :options [] )\n  (send\n    (lvar :options [] ) :+\n    (send nil :line_count))) to_a map ","(erange\n  (lvar :start)\n  (send\n    (lvar :start) :+\n    (send nil :line to_s _count))) to_a ","(erange\n  (lvar :options [] )\n  (send\n    (lvar :options [] ) :+\n    (send nil :line_count))) to_a ","options []  + "," line to_s _count ","(send\n  (lvar :start) :+\n  (send nil :line_count)) to_s size  - ","line to_s _number to_s size ","line to_s _number to_s ","opened_tags join ed_tags size ","opened_tags join ed_tags << ","opened_tags join ed_tags pop ","line to_s  scan ","opened_tags join ed_tags join ","line to_s  chomp! ","(send\n  (lvar :start) :+\n  (send nil :line to_s _count)) to_s size ","(send\n  (lvar :options [] ) :+\n  (send nil :line_count)) to_s size ","(send\n  (lvar :start) :+\n  (send nil :line to_s _count)) to_s ","(send\n  (lvar :options [] ) :+\n  (send nil :line_count)) to_s ","anchor_prefix + ing [] ","line to_s  % == ","line to_s  % ","options []  == ","options []  is_a? ","highlight_lines to_set  include? ","options []  include? ","highlight_line to_s s include? ","highlight_lines to_set  to_set ","options []  to_set ","highlight_line to_s s to_set ","highlight_lines to_set  is_a? ","highlight_line to_s s is_a? ","highlight_lines to_set  == ","highlight_line to_s s == ","DEFAULT_OPTIONS  merge  [] ","line to_s  to_s ","anchor_prefix + _prefix + ","anchor_prefix to_s []  + ","anchor_prefix + _prefix to_s [] ","anchor_prefix to_s []  to_s [] ","options []  to_s [] ","anchor_prefix + _prefix to_s ","anchor_prefix to_s []  to_s ","options []  to_s ","anchor_prefix + _prefix == ","anchor_prefix to_s []  == ","Invalid value %p for :line to_s _number_start; Integer expected. % ","Invalid value %p for :line_number_options [] ; Integer expected. % "]}," CodeRay Tokens text_token":{"type":"method","name":"text_token","children":[],"call":[" << << "," << "]}," CodeRay PluginHost all_titles":{"type":"method","name":"all_titles","children":[],"call":["plugin title "," all_plugins map "," all_plugins "]}," CodeRay CaseIgnoringWordList []=":{"type":"method","name":"[]=","children":[],"call":["key downcase "]}," CodeRay CaseIgnoringWordList []":{"type":"method","name":"[]","children":[],"call":["key downcase "]}," CodeRay TokensProxy count":{"type":"method","name":"count","children":[],"call":[" tokens count "," tokens "]}," CodeRay Scanners CSS setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay coderay_path":{"type":"method","name":"coderay_path","children":[],"call":[]}," CodeRay Scanners PHP scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":[" raise_inspect ","states pop ","encoder text_token "," scan ","states push ","states []= ","states last ","encoder begin_group "," check ","match << ","encoder end_group ","delimiter == "," matched ","heredoc_delimiter ! "," getch ","match == "," [] ","Regexp  escape ","states last [] ","states last is_a? ","states size == ","states size ","Words VARIABLE_KIND  [] ","states << ","kind == ","match =~ ","Words IDENT_KIND  [] ","@html_scanner tokenize ","match empty? "," scan_rest "," scan_until "," eos? "," match? ","(sym :sqstring) include? ","state first ","state is_a? ","state == ","states pop s pop ","states pop s push ","states pop s []= ","states pop s last "," scan  << ","states last []  == ","  scan ed ","Regexp  escape  ! ","heredoc_states last []  ! "," scan  == ","states pop s last [] ","states pop s last is_a? ","states pop s size == ","states pop s size ","states pop s << ","Words IDENT_KIND  []  == "," scan  =~ "," scan  empty? ","  scan ? ","states pop  first ","states pop  is_a? ","states pop  == "]}," CodeRay Scanners PHP reset_instance":{"type":"method","name":"reset_instance","children":[],"call":["@html_scanner reset "]}," CodeRay Scanners PHP setup":{"type":"method","name":"setup","children":[],"call":["CodeRay  scanner "]}," CodeRay Scanners Taskpaper scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["encoder text_token "," getch "," scan "," eos? "]}," CodeRay Scanners Sass scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["encoder end_group ","state == ","states pop ","states dup ","options [] ","states last == ","states last ","encoder text_token "," getch ","match == "," scan ","match [] ","start size ","start size < ","match size ","match [] == ","encoder begin_group ","states push ","content empty? "," scan_until ","states include? "," raise_inspect ","Unknown state: %p % ","(str \"else case \") % "," peek ","match empty? ","states << ","match size > ","value_expected ! "," check ","match index "," [] "," bol? "," eos? "," Array dup "," Array ","states pop  == ","states pop s pop "," Array dup  pop ","states pop s dup "," Array dup  dup ","states pop s last == "," Array dup  last == ","states pop s last "," Array dup  last "," scan  == "," scan  [] ","match []  size ","match []  size < "," scan  size "," scan  [] == ","states pop s push "," Array dup  push "," scan_until  empty? ","states pop s include? "," Array dup  include? ","Unknown states pop : %p % "," scan  empty? ","states pop s << "," Array dup  << "," scan  size > "," scan  index "]}," CodeRay Scanners Sass setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Scanners Raydebug setup":{"type":"method","name":"setup","children":[],"call":["TokenKinds  keys map to_set ","TokenKinds  keys map ","TokenKinds  keys "]}," CodeRay Scanners Lua scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["encoder end_group ","brace_depth times ","(sym :string) include? ","options [] "," raise ","encoder text_token "," scan "," check "," getch ","Regexp  compile "," terminate "," rest ","brace_depth >= ","state == ","encoder begin_group ","brace_depth == ","match == ","kind == ","IDENT_KIND  [] ","match count "," eos? "," scan  == ","IDENT_KIND  []  == "," scan  count "]}," CodeRay Scanners Lua setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Scanners JSON setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Scanners JavaScript setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Scanners HTML scan_css":{"type":"method","name":"scan_css","children":[],"call":["@css_scanner tokenize ","Scanners CSS  new ","code empty? ! ","code empty? "]}," CodeRay Scanners Groovy setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Scanners Go scan_tokens":{"type":"method","name":"scan_tokens","children":[],"call":["encoder end_group ","state == "," raise_inspect ","match index ","encoder text_token "," scan ","else case \" reached; %p not handled. % "," peek "," getch "," [] == "," [] ","match << "," scan_until "," eos? ","encoder begin_group ","match [] == ","match [] ","kind == "," matched ","in_preproc_line ! ","IDENT_KIND  [] ","match == ","match != "," scan  index "," scan  << "," scan  [] == "," scan  [] ","IDENT_KIND  []  == ","  scan ed "," scan  == "," scan  != "]}," CodeRay Scanners Debug setup":{"type":"method","name":"setup","children":[],"call":["TokenKinds  keys map to_set ","TokenKinds  keys map ","TokenKinds  keys "]}," CodeRay Scanners Scanner tokens_last":{"type":"method","name":"tokens_last","children":[],"call":["tokens last ","tokens respond_to? "]}," CodeRay Scanners Scanner tokens_size":{"type":"method","name":"tokens_size","children":[],"call":["tokens size ","tokens respond_to? "]}," CodeRay Scanners Scanner scanner_state_info":{"type":"method","name":"scanner_state_info","children":[],"call":["SCANNER_STATE_INFO  % "," eos? "," bol? "," matched "," pos "," column "," line "]}," CodeRay Scanners Scanner raise_inspect_arguments":{"type":"method","name":"raise_inspect_arguments","children":[],"call":[" binary_string [] "," pos "," binary_string "," pos - "," scanner_state_info "," tokens_last map join "," tokens_last map "," tokens_last "," tokens_size ","File  basename "," caller [] "," caller "]}," CodeRay Scanners Scanner set_tokens_from_options":{"type":"method","name":"set_tokens_from_options","children":[],"call":["@tokens scanner= ","@tokens respond_to? ","Tokens  new ","options [] "]}," CodeRay Scanners Scanner set_string_from_source":{"type":"method","name":"set_string_from_source","children":[],"call":[" string= "," class normalize "," class "," reset ","source join "]}," CodeRay FileType type_from_shebang":{"type":"method","name":"type_from_shebang","children":[],"call":["type to_sym ","first_line [] ","f gets ","File  open ","File  exist? ","first_line []  to_sym ","f gets  [] "]}," CodeRay Encoders Lint finish":{"type":"method","name":"finish","children":[],"call":[" raise ","Some tokens still open at end of token stream: %p % ","@opened empty? "]}," CodeRay Encoders Lint setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Encoders Lint end_line":{"type":"method","name":"end_line","children":[],"call":["@opened pop "," raise ","We are inside %s, not %p (end_line) % ","@opened reverse map join ","@opened reverse map ","@opened reverse ","@opened last != ","@opened last "]}," CodeRay Encoders Lint begin_line":{"type":"method","name":"begin_line","children":[],"call":["@opened << "]}," CodeRay Encoders Lint end_group":{"type":"method","name":"end_group","children":[],"call":["@opened pop "," raise ","We are inside %s, not %p (end_group) % ","@opened reverse map join ","@opened reverse map ","@opened reverse ","@opened last != ","@opened last "]}," CodeRay Encoders Lint begin_group":{"type":"method","name":"begin_group","children":[],"call":["@opened << "]}," CodeRay Encoders Lint text_token":{"type":"method","name":"text_token","children":[],"call":[" raise ","unknown token kind %p (text was %p) % ","TokenKinds  has_key? ","empty token for %p % ","text empty? "]}," CodeRay Encoders HTML close_span":{"type":"method","name":"close_span","children":[],"call":["@opened last ","@out << ","@opened pop "]}," CodeRay Encoders HTML break_lines":{"type":"method","name":"break_lines","children":[],"call":["text gsub ","</span> * ","@opened size ","reopen << ","@span_for_kinds [] ","@opened [] ","index > ","@opened each_with_index "," dup "," dup  << "]}," CodeRay Encoders HTML check_group_nesting":{"type":"method","name":"check_group_nesting","children":[],"call":[" warn ","(str \"Malformed token stream: Trying to close a \") % ","@opened [] ","@opened last != ","@opened last ","@opened empty? "]}," CodeRay Encoders HTML make_span_for_kinds":{"type":"method","name":"make_span_for_kinds","children":[],"call":["h []= ","h clear ","h size >= ","h size ","(lvasgn :css_class\n  (send nil :css_class_for_kinds\n    (lvar :kinds))) tap "," style_for_kinds ","method == ","HTML  token_path_to_hint "," css_class_for_kinds ","Hash  new ","kinds dup ","kinds is_a? ","(lvasgn : css_class_for_kinds \n  (send nil : css_class_for_kinds _for_kinds\n    (lvar :kinds))) tap ","  style_for_kinds _for_kinds ","  css_class_for_kinds _for_kinds "]}," CodeRay Encoders HTML style_for_kinds":{"type":"method","name":"style_for_kinds","children":[],"call":["@css get_style_for_css_classes ","TokenKinds  [] ","kinds map ","kinds is_a? "]}," CodeRay Encoders HTML css_class_for_kinds":{"type":"method","name":"css_class_for_kinds","children":[],"call":["TokenKinds  [] ","kinds first ","kinds is_a? "]}," CodeRay Encoders HTML check_options!":{"type":"method","name":"check_options!","children":[],"call":["options []= ","options [] == ","options [] "," raise ","Unknown value %p for :css. % ","(sym :class) include? ","Unknown value %p for :hint; expected :info, :info_long, :debug, false, or nil. % ","(false) include? "]}," CodeRay Encoders HTML make_html_escape_hash":{"type":"method","name":"make_html_escape_hash","children":[],"call":[]}," CodeRay Encoders HTML CSS get_style_for_css_classes":{"type":"method","name":"get_style_for_css_classes","children":[],"call":["cl [] ","css_classes [] ","1 upto ","css_classes size ","@styles [] ","css_classes first ","@styles []  [] ","css_@styles [] asses [] ","css_@styles [] asses size ","@cl [] s [] ","css_@styles [] asses first "]}," CodeRay Encoders DebugLint finish":{"type":"method","name":"finish","children":[],"call":[" raise ","Some tokens still open at end of token stream: %p % ","@opened empty? "]}," CodeRay Encoders DebugLint setup":{"type":"method","name":"setup","children":[],"call":[]}," CodeRay Encoders DebugLint end_line":{"type":"method","name":"end_line","children":[],"call":["@opened pop "," raise ","We are inside %s, not %p (end_line) % ","@opened reverse map join ","@opened reverse map ","@opened reverse ","@opened last != ","@opened last "]}," CodeRay Encoders DebugLint begin_line":{"type":"method","name":"begin_line","children":[],"call":["@opened << "]}," CodeRay Encoders DebugLint end_group":{"type":"method","name":"end_group","children":[],"call":["@opened pop "," raise ","We are inside %s, not %p (end_group) % ","@opened reverse map join ","@opened reverse map ","@opened reverse ","@opened last != ","@opened last "]}," CodeRay Encoders DebugLint begin_group":{"type":"method","name":"begin_group","children":[],"call":["@opened << "]}," CodeRay Encoders DebugLint text_token":{"type":"method","name":"text_token","children":[],"call":[" raise ","unknown token kind %p (text was %p) % ","TokenKinds  has_key? ","empty token for %p % ","text empty? "]}," CodeRay Scanners Ruby StringState simple_key_pattern":{"type":"method","name":"simple_key_pattern","children":[],"call":[]}}