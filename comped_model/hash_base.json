{" Hash zip_out":{"type":"method","name":"zip_out","children":[],"call":["zip_stream read ","zip_stream rewind ","zip write "," block_given? ","zip put_next_entry "," each ","Zip OutputStream  write_buffer "]}," Hash to_table":{"type":"method","name":"to_table","children":[],"call":["arry to_html "," to_table ","format == ","arry to_text ","Array  new ","max_len - ","l length ","arry map! ","content == ","(send\n  (lvar :arry) :map) max ","r length ","arry map ","arry << ","(dstr\n  (begin\n    (lvar :grand_total_caption))) + + ","grand_total yield ","(dstr\n  (begin\n    (lvar :grand_total_caption))) + ","divisor to_s * ","divisor to_s ","max_len + ","(str \"grand_total_caption level_0\") + + ","(str \"grand_total_caption level_0\") + ","l + ","level == ","(dstr\n  (begin\n    (lvar :total_caption))) + + ","total yield ","(dstr\n  (begin\n    (lvar :total_caption))) + ","(str \"total_caption level_0\") + + ","(str \"total_caption level_0\") + ","lines drop ","lines drop present? ","lines [] ","lines << ","(send\n  (const nil :Array) :new\n  (if\n    (send\n      (lvar :i) :>\n      (int 0))\n    (send\n      (lvar :level) :+\n      (int 1))\n    (int 0))) + ","elem length ","level + ","i > ","av is_a? ","v each_with_index ","v is_a? ","v to_table ","(send\n  (const nil :Array) :new\n  (if\n    (send\n      (lvar :i) :>\n      (int 0))\n    (lvar :level)\n    (int 0))) + ","h each "," sort ","arry to_ sort tml ","(send\n  (lvar :arry) :map) max  - ","l lengt sort  ","r lengt sort  ","(send\n  (lvar :arry) :map) max  + ","v to_table  drop ","v to_table  drop present? ","v to_table  [] ","v to_table  << ","elem lengt sort  ","v eac sort _wit sort _index "," sort  eac sort  "]}," Hash expand":{"type":"method","name":"expand","children":[],"call":["arry << ","path_to_here + + ","path_to_here + ","el is_a? ","v each ","v is_a? ","v expand "," each "]}," Hash group_by_positions":{"type":"method","name":"group_by_positions","children":[],"call":["ohash []= ","val group_by_positions "," each ","ActiveSupport OrderedHash  new ","ActiveSupport OrderedHash  new  []= "]}," Hash deep_diff":{"type":"method","name":"deep_diff","children":[],"call":["memo []= ","left deep_diff ","right respond_to? ","left respond_to? ","left == "," block_given? ","other [] "," [] ","(send\n  (send\n    (self) :keys) :+\n  (send\n    (lvar :other) :keys)) uniq inject ","(send\n  (send\n    (self) :keys) :+\n  (send\n    (lvar :other) :keys)) uniq "," keys + ","other keys "," keys "," []  deep_diff ","other []  respond_to? "," []  respond_to? "," []  == "]}," Hash max_depth":{"type":"method","name":"max_depth","children":[],"call":["(lvar :max_depth) max ","v max_depth ","depth + ","v is_a? "," each ","(lvar :(lvar :max_depth) max ) max ","v (lvar :max_depth) max  "]}," Hash deep_values":{"type":"method","name":"deep_values","children":[],"call":["arr << ","value deep_values ","value is_a? "," each ","Array  new ","Array  new  << "]}," Hash apply!":{"type":"method","name":"apply!","children":[],"call":[" []= ","value apply ","value is_a? "," each "," to_enum "," block_given? "]}," Hash apply":{"type":"method","name":"apply","children":[],"call":["hash []= ","value apply ","value is_a? "," each ","Hash  new "," to_enum "," block_given? ","Hash  new  []= "]}," Array to_text":{"type":"method","name":"to_text","children":[],"call":["(send nil :map) join ","(send\n  (lvar :ln) :map) join ","e to_s ljust ","e to_s "," sprintf rjust "," sprintf ","e to_s rjust ","ln map ","line is_a? "," map "]}," Array to_list":{"type":"method","name":"to_list","children":[],"call":["(send nil :map) unshift ","hash [] ","keys map "," map ","(send nil :map) flatten uniq ","(send nil :map) flatten ","hash keys "," raise ","hash is_a? "," each ","(send nil :map) flatten uniq  map ","hash (send nil :map) flatten uniq  "]}," Array html_tag":{"type":"method","name":"html_tag","children":[],"call":["content first ","(send\n  (send\n    (send\n      (lvar :content) :[]\n      (int 1)) :to_h) :map) join ","content [] to_h map ","content [] to_h ","content [] ","(send\n  (send\n    (send\n      (lvar :content) :first) :to_h) :map) join ","content first to_h map ","content first to_h "," block_given? "]}," Array style_value":{"type":"method","name":"style_value","children":[],"call":["CGI  escapeHTML ","value to_s ","options [] "," sprintf ","value class "]}," Array table_row":{"type":"method","name":"table_row","children":[],"call":["(send\n  (send nil :collect) :with_index) join "," style_value "," block_given? "," html_tag ","options [] to_h except compact ","options [] to_h except ","options [] to_h ","options [] ","options dig "," collect with_index "," collect ","options [] to_h compact "]}," Array table_row_group":{"type":"method","name":"table_row_group","children":[],"call":[" html_tag ","options dig ","rows present? ","(send\n  (send nil :collect) :with_index) join ","row table_row "," collect with_index "," collect ","(send\n  (send nil :collect) :with_index) join  present? "]}," Array to_html":{"type":"method","name":"to_html","children":[],"call":["(lvar :head) compact table_row_group + + ","(lvar :foot) compact table_row_group ","options merge ","(lvar :foot) compact ","(lvar :head) compact table_row_group + ","body compact table_row_group ","body compact ","(lvar :head) compact table_row_group ","(lvar :head) compact "," html_tag ","options [] to_h compact ","options [] to_h ","options [] ","t pop ","t shift "," dup ","options []= ","options [] to_h merge ","(pair\n  (sym :class)\n  (send\n    (lvar :options) :[]\n    (sym :table_class))) compact ","(lvar :head) compac dup   dup able_row_group + + ","(lvar :foo dup ) compac dup   dup able_row_group ","op dup ions merge ","(lvar :foo dup ) compac dup  ","(lvar :head) compac dup   dup able_row_group + ","body compac dup   dup able_row_group ","body compac dup  ","(lvar :head) compac dup   dup able_row_group ","(lvar :head) compac dup  "," h dup ml_ dup ag ","op dup ions []  dup o_h compac dup  ","op dup ions []  dup o_h ","op dup ions [] "," dup  pop "," dup  shif dup  ","op dup ions []= ","op dup ions []  dup o_h merge ","(pair\n  (sym :class)\n  (send\n    (lvar :op dup ions) :[]\n    (sym : dup able_class))) compac dup  "]}," Array group_by_headings":{"type":"method","name":"group_by_headings","children":[],"call":["copy group_by_positions ","header_row find_index ","headings map ","copy shift "," dup "," dup  group_by_positions ","copy shift  find_index "," dup  shift "]}," Array group_by_positions":{"type":"method","name":"group_by_positions","children":[],"call":["ohash group_by_positions ","positions drop ","p - ","p > ","positions [] ","positions map! ","positions length > ","positions length ","ohash []= ","ohash [] << ","ohash [] ","ohash has_key? "," raise ","subarray delete_at "," each ","ActiveSupport OrderedHash  new ","ActiveSupport OrderedHash  new  group_by_positions ","ActiveSupport OrderedHash  new  []= ","ActiveSupport OrderedHash  new  [] << ","ActiveSupport OrderedHash  new  [] ","ohash has_subarray delete_at ? ","ActiveSupport OrderedHash  new  has_key? "]}}