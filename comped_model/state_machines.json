{" StateMachines AttributeTransitionCollection rollback":{"type":"method","name":"rollback","children":[],"call":["transition machine write ","transition event "," object ","transition machine ","transition transient? "," each "]}," StateMachines AttributeTransitionCollection reset":{"type":"method","name":"reset","children":[],"call":[]}," StateMachines AttributeTransitionCollection persist":{"type":"method","name":"persist","children":[],"call":[]}," StateMachines AttributeTransitionCollection run_callbacks":{"type":"method","name":"run_callbacks","children":[],"call":["transition machine write "," object ","transition machine "," each "," success? "," skip_after "," raise "," rollback ","index == "]}," StateMachines AttributeTransitionCollection initialize":{"type":"method","name":"initialize","children":[],"call":["(pair\n  (sym :transaction)\n  (false)) merge ","(pair\n  (sym :use_transactions)\n  (false)) merge "]}," StateMachines TransitionCollection within_transaction":{"type":"method","name":"within_transaction","children":[],"call":[" success? "," first within_transaction "," first "," empty? ! "," empty? "," use_transaction "," use_transactions "]}," StateMachines TransitionCollection catch_exceptions":{"type":"method","name":"catch_exceptions","children":[],"call":[" raise "," rollback "]}," StateMachines TransitionCollection rollback":{"type":"method","name":"rollback","children":[],"call":["transition rollback "," each "]}," StateMachines TransitionCollection run_actions":{"type":"method","name":"run_actions","children":[],"call":[" results values all? "," results values "," results "," results []= "," object send "," object "," skip_actions ! "," skip_actions "," actions compact each "," actions compact "," actions ","result ! ! ","result ! "," actions each "," block_given? "," catch_exceptions "]}," StateMachines TransitionCollection persist":{"type":"method","name":"persist","children":[],"call":["transition persist "," each "]}," StateMachines TransitionCollection run_callbacks":{"type":"method","name":"run_callbacks","children":[],"call":[" run_actions "," persist "," throw "," success? "," results [] ","transition action "," results "," run_callbacks ","index + ","transition run_callbacks "," skip_after ! "," skip_after "," [] "," []  action "," []  run_callbacks "]}," StateMachines TransitionCollection reset":{"type":"method","name":"reset","children":[],"call":[]}," StateMachines TransitionCollection use_event_attributes?":{"type":"method","name":"use_event_attributes?","children":[],"call":[" first machine action_hook? "," first machine "," first "," actions length == "," actions length "," actions "," actions all? "," skip_after ! "," skip_after "," skip_actions ! "," skip_actions "]}," StateMachines TransitionCollection actions":{"type":"method","name":"actions","children":[],"call":["(send nil :map) uniq ","transition action "," map "," empty? "]}," StateMachines TransitionCollection object":{"type":"method","name":"object","children":[],"call":[" first object "," first "]}," StateMachines TransitionCollection success?":{"type":"method","name":"success?","children":[],"call":[]}," StateMachines TransitionCollection valid?":{"type":"method","name":"valid?","children":[],"call":[]}," StateMachines TransitionCollection perform":{"type":"method","name":"perform","children":[],"call":[" success? "," results [] "," actions first "," actions "," results "," results include? "," actions length == "," actions length "," rollback "," run_callbacks "," catch "," within_transaction "," run_actions ","transition machine write "," object ","transition machine ","transition transient= "," each "," block_given? ! "," block_given? "," use_event_attributes? "," valid? "," reset "]}," StateMachines TransitionCollection initialize":{"type":"method","name":"initialize","children":[],"call":["options [] ","options [] ! ","(pair\n  (sym :actions)\n  (true)) merge ","options assert_valid_keys "," fail ","attributes length != "," length ","attributes length ","(send nil :map) uniq ","transition attribute "," map ","transition ! "," reject! "," all? ","(pair\n  (sym :actions)\n  (true)) merge  [] ","(pair\n  (sym :actions)\n  (true)) merge  [] ! ","(pair\n  (sym :actions)\n  (true)) merge  assert_valid_keys ","(send nil :map) uniq  length != ","(send nil :map) uniq  length "]}," StateMachines Transition context":{"type":"method","name":"context","children":[],"call":[" to_name "," from_name "," event "]}," StateMachines Transition after":{"type":"method","name":"after","children":[],"call":["callback call "," context "," object "," machine callbacks [] each "," machine callbacks [] "," machine callbacks "," machine "," catch "," resume "]}," StateMachines Transition before":{"type":"method","name":"before","children":[],"call":["action [] ","(pair\n  (sym :success)\n  (true)) merge "," block_given? ","callback call "," context "," object "," throw "," pause ","complete ! "," before "," catch ","callback type == ","callback type "," machine callbacks [] [] "," machine callbacks [] "," machine callbacks "," machine ","(pair\n  (sym :success)\n  (true)) merge  [] "," machine callbacks [] []  call "," machine callbacks [] []  type == "," machine callbacks [] []  type "," machine  machine callbacks [] [] s [] [] "," machine  machine callbacks [] [] s [] "," machine  machine callbacks [] [] s "]}," StateMachines Transition resume":{"type":"method","name":"resume","children":[],"call":["halted ! "," raise ","@paused_block call "," callcc "]}," StateMachines Transition pause":{"type":"method","name":"pause","children":[],"call":[" throw "," callcc "," require "," raise "," class pause_supported? "," class "]}," StateMachines Transition pausable":{"type":"method","name":"pausable","children":[],"call":["@resume_block call "," raise ","(send nil :catch\n  (sym :halt)) ! "," catch "]}," StateMachines Transition inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (array\n    (str \"attribute\")\n    (str \"event\")\n    (str \"from\")\n    (str \"from_name\")\n    (str \"to\")\n    (str \"to_name\")) :map) * "," send inspect "," send ","(str \"attribute\") map "," class "]}," StateMachines Transition ==":{"type":"method","name":"==","children":[],"call":["other event == "," event ","other event ","other to_name == "," to_name ","other to_name ","other from_name == "," from_name ","other from_name ","other machine == "," machine ","other machine ","other object == "," object ","other object ","other instance_of? "," class "]}," StateMachines Transition reset":{"type":"method","name":"reset","children":[],"call":[]}," StateMachines Transition rollback":{"type":"method","name":"rollback","children":[],"call":[" machine write "," from "," object "," machine "," reset "]}," StateMachines Transition persist":{"type":"method","name":"persist","children":[],"call":[" machine write "," to "," object "," machine "]}," StateMachines Transition run_callbacks":{"type":"method","name":"run_callbacks","children":[],"call":[" after ","@success ! ","options [] ","(and\n  (ivar :@before_run)\n  (lvar :halted)) ! "," before "," pausable ","(pair\n  (sym :before)\n  (true)) merge ","(pair\n  (sym :before)\n  (true)) merge  [] "]}," StateMachines Transition within_transaction":{"type":"method","name":"within_transaction","children":[],"call":[" machine within_transaction "," object "," machine "]}," StateMachines Transition perform":{"type":"method","name":"perform","children":[],"call":["TransitionCollection  new perform ! ! ","TransitionCollection  new perform ! ","TransitionCollection  new perform ","TransitionCollection  new "," args= ","args pop ","(true) include? ","args last "," machine use_transactions "," machine "]}," StateMachines Transition attributes":{"type":"method","name":"attributes","children":[],"call":[" to "," from "," event "," attribute "," object "]}," StateMachines Transition transient?":{"type":"method","name":"transient?","children":[],"call":[]}," StateMachines Transition loopback?":{"type":"method","name":"loopback?","children":[],"call":[" from_name == "," to_name "," from_name "]}," StateMachines Transition human_to_name":{"type":"method","name":"human_to_name","children":[],"call":["@to_state human_name ","@object class "]}," StateMachines Transition qualified_to_name":{"type":"method","name":"qualified_to_name","children":[],"call":["@to_state qualified_name "]}," StateMachines Transition to_name":{"type":"method","name":"to_name","children":[],"call":["@to_state name "]}," StateMachines Transition human_from_name":{"type":"method","name":"human_from_name","children":[],"call":["@from_state human_name ","@object class "]}," StateMachines Transition qualified_from_name":{"type":"method","name":"qualified_from_name","children":[],"call":["@from_state qualified_name "]}," StateMachines Transition from_name":{"type":"method","name":"from_name","children":[],"call":["@from_state name "]}," StateMachines Transition human_event":{"type":"method","name":"human_event","children":[],"call":["@event human_name ","@object class "]}," StateMachines Transition qualified_event":{"type":"method","name":"qualified_event","children":[],"call":["@event qualified_name "]}," StateMachines Transition event":{"type":"method","name":"event","children":[],"call":["@event name "]}," StateMachines Transition action":{"type":"method","name":"action","children":[],"call":[" machine action "," machine "]}," StateMachines Transition attribute":{"type":"method","name":"attribute","children":[],"call":[" machine attribute "," machine "]}," StateMachines Transition initialize":{"type":"method","name":"initialize","children":[],"call":[" reset ","@to_state value ","machine states fetch ","machine states ","@from_state value ","machine read ","machine events fetch ","machine events ","@to_state value _state value ","machine states fetch  value ","@from_state value _state value ","machine read _state value "]}," StateMachines Transition pause_supported?":{"type":"method","name":"pause_supported?","children":[],"call":[]}," StateMachines InvalidParallelTransition initialize":{"type":"method","name":"initialize","children":[],"call":["events * "]}," StateMachines InvalidTransition qualified_from_name":{"type":"method","name":"qualified_from_name","children":[],"call":["@from_state qualified_name "]}," StateMachines InvalidTransition from_name":{"type":"method","name":"from_name","children":[],"call":["@from_state name "]}," StateMachines InvalidTransition qualified_event":{"type":"method","name":"qualified_event","children":[],"call":["@event qualified_name "]}," StateMachines InvalidTransition event":{"type":"method","name":"event","children":[],"call":["@event name "]}," StateMachines InvalidTransition initialize":{"type":"method","name":"initialize","children":[],"call":["message << ","errors empty? "," from_name inspect "," from_name "," event ","machine name ","machine errors_for ","machine events fetch ","machine events ","machine read ","machine states match! ","machine states ","machine errors_for  empty? ","machine machine errors_for _for "]}," StateMachines StateContext method_missing":{"type":"method","name":"method_missing","children":[],"call":[" machine owner_class send "," machine owner_class "," machine ","options []= ","(send\n  (send nil :Array\n    (lvar :unless_condition)) :any?) ! ","proxy evaluate_method "," Array any? "," Array "," Array all? ","condition_args first "," lambda ","options delete ","args << ","args last ","args last is_a? ","args last  []= ","(send\n  (send nil :Array\n    (lvar :options delete )) :any?) ! ","args last  delete "]}," StateMachines StateContext transition":{"type":"method","name":"transition","children":[],"call":[" machine transition ","options merge "," state name "," state ","options [] "," machine "," raise ","options [] ! ^ ","options [] ! ","options assert_valid_keys "]}," StateMachines StateContext initialize":{"type":"method","name":"initialize","children":[],"call":["object class state_machine states matches? ","object class state_machine states ","object class state_machine ","object class "," lambda "," machine name "," machine ","state name ","state machine "]}," StateMachines StateCollection value":{"type":"method","name":"value","children":[],"call":["node value ","attribute == "]}," StateMachines StateCollection by_priority":{"type":"method","name":"by_priority","children":[],"call":[" [] ","order map! ","order uniq! "," keys "," keys - ","(send\n  (send\n    (send\n      (send\n        (send nil :machine) :callbacks) :values) :flatten) :map) flatten ","callback known_states "," machine callbacks values flatten map "," machine callbacks values flatten "," machine callbacks values "," machine callbacks "," machine ","state name ","(send nil :select) map ","state context_methods any? ","state context_methods "," select ","event known_states "," machine events each "," machine events ","state initial "," machine callbacks values flatten flat_map "]}," StateMachines StateCollection match!":{"type":"method","name":"match!","children":[],"call":[" raise "," machine name "," machine "," machine read inspect "," machine read "," match "]}," StateMachines StateCollection match":{"type":"method","name":"match","children":[],"call":["state matches? "," detect "," [] "," machine read "," machine "]}," StateMachines StateCollection matches?":{"type":"method","name":"matches?","children":[],"call":[" fetch matches? "," machine read "," machine "," fetch "]}," StateMachines StateCollection initialize":{"type":"method","name":"initialize","children":[],"call":[]}," StateMachines State context_name_for":{"type":"method","name":"context_name_for","children":[],"call":["@context object_id "," name "," machine name "," machine "]}," StateMachines State add_predicate":{"type":"method","name":"add_predicate","children":[],"call":["machine states matches? "," name ","machine states "," machine define_helper "," qualified_name "," machine "]}," StateMachines State cache_value?":{"type":"method","name":"cache_value?","children":[],"call":[]}," StateMachines State inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (lvar :attributes) :map) * ","value inspect ","attributes map "," class "," initial? "," name "]}," StateMachines State draw":{"type":"method","name":"draw","children":[],"call":[" fail "]}," StateMachines State call":{"type":"method","name":"call","children":[],"call":[" raise ","InvalidContext  new ","options [] "," machine name inspect "," machine name "," machine ","state name inspect ","state name ","ex args == ","ex args ","ex name to_s == ","options [] to_s ","ex name to_s ","ex name ","method_missing call ","object send ","object respond_to? ","state == "," machine states match! "," machine states ","(pair\n  (sym :method_name)\n  (lvar :method)) merge ","args pop ","args last is_a? ","args last ","(pair\n  (sym :method_name)\n  (lvar :method)) merge  [] ","args pop  [] "," machine states match!  name inspect "," machine states match!  name ","(pair\n  (sym :method_name)\n  (lvar :method)) merge  [] to_s ","args pop  [] to_s ","options []  call "," machine states match!  == "," machine  machine states match! s match! "," machine  machine states match! s "]}," StateMachines State context_methods":{"type":"method","name":"context_methods","children":[],"call":["methods merge ","@context instance_method ","name to_sym ","@context instance_methods inject ","@context instance_methods "]}," StateMachines State context":{"type":"method","name":"context","children":[],"call":["context class_eval ","193 + ","method_name inspect "," name inspect "," name "," machine name inspect "," machine name "," machine "," context_name_for ","new_methods each ","old_methods [] != ","old_methods [] "," context_methods to_a select "," context_methods to_a "," context_methods "," include "," machine owner_class class_eval "," machine owner_class ","190 + ","189 + ","194 + ","  context_name_for _for "," context_methods  [] != "," context_methods  [] "]}," StateMachines State matches?":{"type":"method","name":"matches?","children":[],"call":["other_value == "," value "," matcher call "," matcher "]}," StateMachines State value":{"type":"method","name":"value","children":[],"call":["@value call "," machine states update "," machine states "," machine "," cache_value? ","@value is_a? ","@value call  call ","@value call  is_a? "]}," StateMachines State description":{"type":"method","name":"description","children":[],"call":["description << ","@value inspect ","@value is_a? "," name to_s == ","@value to_s "," name to_s "," name ","label inspect ","label to_s "," human_name ","options [] ","label inspect  << ","label to_s  << "," name  inspect "," human_name  inspect "," name  to_s "," human_name  to_s "]}," StateMachines State human_name":{"type":"method","name":"human_name","children":[],"call":["@human_name call ","@human_name is_a? "]}," StateMachines State final?":{"type":"method","name":"final?","children":[],"call":["(send\n  (send\n    (send nil :machine) :events) :any?) ! ","requirement [] matches? ! ","requirement [] matches? "," name ","requirement [] ","branch state_requirements any? ","branch state_requirements ","event branches any? ","event branches "," machine events any? "," machine events "," machine "]}," StateMachines State initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["StateContext  new "]}," StateMachines State initialize":{"type":"method","name":"initialize","children":[],"call":[" add_predicate ","conflicting_machines empty? "," warn ","other_machine name inspect ","other_machine name ","machine name inspect ","machine name "," qualified_name inspect "," qualified_name ","other_machine attribute != ","machine attribute ","other_machine attribute ","conflicting_machines detect ","other_machine states [] ","other_machine states ","other_machine != ","machine owner_class state_machines select ","machine owner_class state_machines ","machine owner_class ","StateContext  new ","options [] == ","options [] ","name to_s ","options include? ","@name to_s tr ","@name to_s ","machine namespace ","options assert_valid_keys "]}," StateMachines PathCollection walk":{"type":"method","name":"walk","children":[],"call":[" walk ","path walk ","@deep ! ","path complete? "," to_name "," << "]}," StateMachines PathCollection initial_paths":{"type":"method","name":"initial_paths","children":[],"call":["path << ","Path  new "," to_name "," machine "," object "," machine events transitions_for map "," machine events transitions_for "," from_name "," machine events ","Path  new  << "]}," StateMachines PathCollection events":{"type":"method","name":"events","children":[],"call":["(send nil :map) flatten uniq ","(send nil :map) flatten ","path events "," map "," flat_map uniq "," flat_map "]}," StateMachines PathCollection to_states":{"type":"method","name":"to_states","children":[],"call":["(send nil :map) flatten uniq ","(send nil :map) flatten ","path to_states "," map "," flat_map uniq "," flat_map "]}," StateMachines PathCollection from_states":{"type":"method","name":"from_states","children":[],"call":["(send nil :map) flatten uniq ","(send nil :map) flatten ","path from_states "," map "," flat_map uniq "," flat_map "]}," StateMachines PathCollection initialize":{"type":"method","name":"initialize","children":[],"call":[" walk "," initial_paths each "," initial_paths ","options [] ","machine states fetch name ","machine states fetch ","machine states ","options assert_valid_keys ","(pair\n  (sym :deep)\n  (false)) merge ","machine states match! name ","machine states match! ","(pair\n  (sym :deep)\n  (false)) merge  [] ","(pair\n  (sym :deep)\n  (false)) merge  assert_valid_keys "]}," StateMachines Path transitions":{"type":"method","name":"transitions","children":[],"call":[" can_walk_to? "," machine events transitions_for select "," machine events transitions_for "," to_name "," object "," machine events "," machine "," empty? "]}," StateMachines Path can_walk_to?":{"type":"method","name":"can_walk_to?","children":[],"call":[" times_walked_to < "," times_walked_to ","@target ! "," recently_walked? ! "," recently_walked? "]}," StateMachines Path recently_walked?":{"type":"method","name":"recently_walked?","children":[],"call":["transitions include? ","transitions [] "," index + "," index ","t to_name == ","t to_name "," detect ","@target != "," to_name ","transitions []  include? ","transitions []  [] "]}," StateMachines Path times_walked_to":{"type":"method","name":"times_walked_to","children":[],"call":["(send nil :select) length ","transition to_name == ","transition to_name "," select "]}," StateMachines Path complete?":{"type":"method","name":"complete?","children":[],"call":[" transitions empty? "," transitions "," to_name == "," to_name "," empty? ! "," empty? "]}," StateMachines Path walk":{"type":"method","name":"walk","children":[],"call":[" dup push "," dup "," transitions each "," transitions "]}," StateMachines Path events":{"type":"method","name":"events","children":[],"call":["(send nil :map) uniq ","transition event "," map "]}," StateMachines Path to_states":{"type":"method","name":"to_states","children":[],"call":["(send nil :map) uniq ","transition to_name "," map "]}," StateMachines Path to_name":{"type":"method","name":"to_name","children":[],"call":[" last to_name "," last "]}," StateMachines Path from_states":{"type":"method","name":"from_states","children":[],"call":["(send nil :map) uniq ","transition from_name "," map "]}," StateMachines Path from_name":{"type":"method","name":"from_name","children":[],"call":[" first from_name "," first "]}," StateMachines Path initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[]}," StateMachines Path initialize":{"type":"method","name":"initialize","children":[],"call":["options [] ","options assert_valid_keys "]}," StateMachines NodeCollection eval_context":{"type":"method","name":"eval_context","children":[],"call":["node context ","context [] ","context [] matches? ","node name "]}," StateMachines NodeCollection to_sym?":{"type":"method","name":"to_sym?","children":[],"call":["(begin\n  (lvar :value)) != "]}," StateMachines NodeCollection update_index":{"type":"method","name":"update_index","children":[],"call":[" add_to_index "," remove_from_index ","old_key != "," value ","index key "," index "," add_to_ index  "," remove_from_ index  ","index key  != "," index  key ","  index  "]}," StateMachines NodeCollection remove_from_index":{"type":"method","name":"remove_from_index","children":[],"call":[" index delete "," index "," to_sym? ","key to_s "]}," StateMachines NodeCollection add_to_index":{"type":"method","name":"add_to_index","children":[],"call":[" index []= "," index "," to_sym? ","key to_s "]}," StateMachines NodeCollection value":{"type":"method","name":"value","children":[],"call":["node send "]}," StateMachines NodeCollection index":{"type":"method","name":"index","children":[],"call":[" fail ","name inspect ","@indices [] ","@indices any? "]}," StateMachines NodeCollection fetch":{"type":"method","name":"fetch","children":[],"call":[" fail ","key inspect "," [] "]}," StateMachines NodeCollection []":{"type":"method","name":"[]","children":[],"call":[" index [] "," index "," to_sym? ","key to_s "]}," StateMachines NodeCollection at":{"type":"method","name":"at","children":[],"call":["@nodes [] "]}," StateMachines NodeCollection each":{"type":"method","name":"each","children":[],"call":["@nodes each "]}," StateMachines NodeCollection update":{"type":"method","name":"update","children":[],"call":[" update_index ","@index_names each "]}," StateMachines NodeCollection concat":{"type":"method","name":"concat","children":[],"call":[" << ","nodes each "]}," StateMachines NodeCollection <<":{"type":"method","name":"<<","children":[],"call":[" eval_context ","@contexts each "," add_to_index "," value ","@index_names each ","@nodes << "]}," StateMachines NodeCollection context":{"type":"method","name":"context","children":[],"call":[" eval_context "," each ","@contexts << ","WhitelistMatcher  new ","nodes first ","nodes first is_a? ","WhitelistMatcher  new  first ","nodes first  first ","WhitelistMatcher  new  first is_a? ","nodes first  first is_a? "]}," StateMachines NodeCollection keys":{"type":"method","name":"keys","children":[],"call":[" index keys "," index "]}," StateMachines NodeCollection length":{"type":"method","name":"length","children":[],"call":["@nodes length "]}," StateMachines NodeCollection machine=":{"type":"method","name":"machine=","children":[],"call":["node machine= "," each "]}," StateMachines NodeCollection initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["contexts dup "," concat ","n dup ","nodes map ","indices []= ","@indices reduce "]}," StateMachines NodeCollection initialize":{"type":"method","name":"initialize","children":[],"call":[" Array first "," Array ","options [] ","indices []= ","@index_names reduce ","(pair\n  (sym :index)\n  (sym :name)) merge ","options assert_valid_keys ","(pair\n  (sym :index)\n  (sym :name)) merge  [] "," Array  reduce ","(pair\n  (sym :index)\n  (sym :name)) merge  assert_valid_keys "]}," StateMachines MatcherHelpers same":{"type":"method","name":"same","children":[],"call":["LoopbackMatcher  instance "]}," StateMachines MatcherHelpers all":{"type":"method","name":"all","children":[],"call":["AllMatcher  instance "]}," StateMachines LoopbackMatcher description":{"type":"method","name":"description","children":[],"call":[]}," StateMachines LoopbackMatcher matches?":{"type":"method","name":"matches?","children":[],"call":["context [] == ","context [] "]}," StateMachines BlacklistMatcher description":{"type":"method","name":"description","children":[],"call":[" values inspect "," values "," values first inspect "," values first "," values length == "," values length "]}," StateMachines BlacklistMatcher filter":{"type":"method","name":"filter","children":[],"call":["values - "," values "]}," StateMachines BlacklistMatcher matches?":{"type":"method","name":"matches?","children":[],"call":[" values include? ! "," values include? "," values "]}," StateMachines WhitelistMatcher description":{"type":"method","name":"description","children":[],"call":[" values inspect "," values "," values first inspect "," values first "," values length == "," values length "]}," StateMachines WhitelistMatcher matches?":{"type":"method","name":"matches?","children":[],"call":[" values include? "," values "]}," StateMachines AllMatcher description":{"type":"method","name":"description","children":[],"call":[]}," StateMachines AllMatcher filter":{"type":"method","name":"filter","children":[],"call":[]}," StateMachines AllMatcher matches?":{"type":"method","name":"matches?","children":[],"call":[]}," StateMachines AllMatcher -":{"type":"method","name":"-","children":[],"call":["BlacklistMatcher  new "]}," StateMachines Matcher filter":{"type":"method","name":"filter","children":[],"call":[" values & "," values "]}," StateMachines Matcher initialize":{"type":"method","name":"initialize","children":[],"call":["values is_a? "]}," StateMachines MacroMethods state_machine":{"type":"method","name":"state_machine","children":[],"call":["StateMachines Machine  find_or_create "]}," StateMachines MachineCollection transitions":{"type":"method","name":"transitions","children":[],"call":["AttributeTransitionCollection  new ","transitions compact ","machine events attribute_transition_for ","machine events ","machine action == ","machine action "," map ","(pair\n  (sym :use_transactions)\n  (send nil :resolve_use_transactions)) merge "," resolve_use_transactions "]}," StateMachines MachineCollection fire_events":{"type":"method","name":"fire_events","children":[],"call":["TransitionCollection  new perform ","TransitionCollection  new ","events length == ","transitions length ","events length ","(send\n  (lvar :events) :collect) compact ","event on_failure ","event transition_for "," raise ","InvalidEvent  new ","machine events [] ","machine events "," detect ","events collect ","events pop ","(true) include? ","events last "," resolve_use_transactions ","machine events [] s length == ","(send\n  (lvar :events) :collect) compact  length ","event transition_for s length ","machine events [] s length ","(send\n  (lvar :machine events [] s) :collect) compact ","machine events []  on_failure ","event event transition_for _for ","machine events []  transition_for ","machine machine events [] s [] ","machine machine events [] s ","machine events [] s collect ","machine events [] s pop ","machine events [] s last "]}," StateMachines MachineCollection initialize_states":{"type":"method","name":"initialize_states","children":[],"call":["machine initialize_state ","options [] ","options [] == ","machine dynamic_initial_state? "," each_value "," block_given? ","(pair\n  (sym :static)\n  (true)) merge ","options assert_valid_keys ","attributes keys include? ! ","attributes keys include? ","machine attribute ","attributes keys ","attributes keys map include? ! ","attributes keys map include? ","attributes keys map ","(pair\n  (sym :static)\n  (true)) merge  [] ","(pair\n  (sym :static)\n  (true)) merge  [] == ","(pair\n  (sym :static)\n  (true)) merge  assert_valid_keys "]}," StateMachines Machine add_events":{"type":"method","name":"add_events","children":[],"call":[" events << ","Event  new "," events "," events [] "," raise ","conflict name class ","conflict name ","conflict name inspect ","new_event class ","new_event inspect ","event name class != ","event name class ","event name "," events detect ","new_events map "," Event  new s << ","  events [] s << "," Event  new s ","  events [] s "," Event  new s [] ","  events [] s [] ","new_Event  new  class ","new_ events []  class ","new_Event  new  inspect ","new_ events []  inspect ","Event  new  name class != "," events []  name class != ","Event  new  name class "," events []  name class ","Event  new  name "," events []  name "," Event  new s detect ","  events [] s detect ","new_Event  new s map ","new_ events [] s map "]}," StateMachines Machine add_states":{"type":"method","name":"add_states","children":[],"call":["machine states << ","machine states "," sibling_machines each "," sibling_machines "," states << ","State  new "," states "," states [] "," raise ","conflict name class ","conflict name ","conflict name inspect ","new_state class ","new_state inspect ","state name class != ","state name class ","state name "," states detect ","new_states map ","machine State  new s << ","machine  states [] s << ","machine State  new s ","machine  states [] s "," State  new s << ","  states [] s << "," State  new s ","  states [] s "," State  new s [] ","  states [] s [] ","new_State  new  class ","new_ states []  class ","new_State  new  inspect ","new_ states []  inspect ","State  new  name class != "," states []  name class != ","State  new  name class "," states []  name class ","State  new  name "," states []  name "," State  new s detect ","  states [] s detect ","new_State  new s map ","new_ states [] s map "]}," StateMachines Machine add_callback":{"type":"method","name":"add_callback","children":[],"call":[" add_states ","callback known_states "," callbacks [] << ","Callback  new "," callbacks [] ","type == "," callbacks ","Callback  new  known_states "," Callback  new s [] << "," Callback  new s [] "," Callback  new s "]}," StateMachines Machine add_sibling_machine_configs":{"type":"method","name":"add_sibling_machine_configs","children":[],"call":[" states << "," states "," states [] ","state name ","machine states each ","machine states "," sibling_machines each "," sibling_machines "]}," StateMachines Machine owner_class_attribute_default_matches?":{"type":"method","name":"owner_class_attribute_default_matches?","children":[],"call":["state matches? "," owner_class_attribute_default "]}," StateMachines Machine owner_class_attribute_default":{"type":"method","name":"owner_class_attribute_default","children":[],"call":[]}," StateMachines Machine transaction":{"type":"method","name":"transaction","children":[],"call":[]}," StateMachines Machine create_without_scope":{"type":"method","name":"create_without_scope","children":[],"call":[]}," StateMachines Machine create_with_scope":{"type":"method","name":"create_with_scope","children":[],"call":[]}," StateMachines Machine pluralize":{"type":"method","name":"pluralize","children":[],"call":[" name ","word pluralize ","word respond_to? ","word to_s ","word to_s  pluralize ","word to_s  respond_to? ","word to_s  to_s "]}," StateMachines Machine run_scope":{"type":"method","name":"run_scope","children":[],"call":["scope call ","machine states fetch value ","machine states fetch ","machine states ","states flatten map ","states flatten ","states flatten compact map ","states flatten compact "]}," StateMachines Machine define_scopes":{"type":"method","name":"define_scopes","children":[],"call":[" run_scope "," define_helper "," send ","(send\n  (array\n    (send nil :name)\n    (lvar :plural)) :map) uniq each ","(send\n  (array\n    (send nil :name)\n    (lvar :plural)) :map) uniq ","s to_s ","(send nil :name) map "," name ","(sym :with) each "," pluralize "," run_ send  "]}," StateMachines Machine define_name_helpers":{"type":"method","name":"define_name_helpers","children":[],"call":["machine states match! human_name ","object class ","machine states match! ","machine states "," define_helper "," attribute ","machine states match! name ","machine events fetch human_name ","machine events fetch ","machine events ","machine states fetch human_name ","machine states fetch "]}," StateMachines Machine owner_class_ancestor_has_method?":{"type":"method","name":"owner_class_ancestor_has_method?","children":[],"call":["ancestor private_method_defined? ","ancestor method_defined? ","ancestor is_a? ","scope == ","ancestors detect ","ancestors [] reverse ","ancestors [] ","ancestors index ","@helper_modules [] ","current ancestors - + ","current ancestors - ","superclass ancestors ","current ancestors "," owner_class superclass "," owner_class ","superclasses first "," owner_class ancestors [] select "," owner_class ancestors [] "," owner_class ancestors ","ancestor singleton_class "," owner_class singleton_class "," owner_class_has_method? ","(send\n  (send\n    (send nil :owner_class) :ancestors) :select) [] "," owner_class ancestors select ","ancestor singleton_class  private_method_defined? ","ancestor singleton_class  method_defined? ","ancestor singleton_class  is_a? ","ancestors [] reverse  detect ","current ancestors - +  detect ","ancestor singleton_class s detect ","ancestors [] reverse  [] reverse ","current ancestors - +  [] reverse ","ancestor singleton_class s [] reverse ","ancestors [] reverse  [] ","current ancestors - +  [] ","ancestor singleton_class s [] ","ancestors [] reverse  index ","current ancestors - +  index ","ancestor singleton_class s index ","current ancestors [] reverse  - + ","current current ancestors - +  - + "," owner_class  ancestors - + "," owner_class singleton_class  ancestors - + ","current ancestor singleton_class s - + ","current ancestors [] reverse  - ","current current ancestors - +  - "," owner_class  ancestors - "," owner_class singleton_class  ancestors - ","current ancestor singleton_class s - ","superclass ancestors [] reverse  ","superclass current ancestors - +  "," owner_class superclass  ancestors ","superclasses first  ancestors ","superclass ancestor singleton_class s ","current ancestors [] reverse  ","current current ancestors - +  "," owner_class  ancestors "," owner_class singleton_class  ancestors ","current ancestor singleton_class s "," owner_class  owner_class superclass  "," owner_class superclasses first  "," owner_class superclass es first ","superclasses first es first ","(send\n  (send\n    (send nil :owner_class) :ancestors) :select) []  first "," owner_class ancestors [] reverse  [] select "," owner_class current ancestors - +  [] select "," owner_class ancestor singleton_class s [] select "," owner_class ancestors [] reverse  [] "," owner_class current ancestors - +  [] "," owner_class ancestor singleton_class s [] "," owner_class ancestors [] reverse  "," owner_class current ancestors - +  "," owner_class ancestor singleton_class s ","ancestor singleton_class  singleton_class ","(send\n  (send\n    (send nil :owner_class) :ancestors [] reverse ) :select) [] ","(send\n  (send\n    (send nil :owner_class) :current ancestors - + ) :select) [] ","(send\n  (send\n    (send nil :owner_class) :ancestor singleton_class s) :select) [] "," owner_class ancestors [] reverse  select "," owner_class current ancestors - +  select "," owner_class ancestor singleton_class s select "]}," StateMachines Machine action_hook":{"type":"method","name":"action_hook","children":[],"call":[" action "," owner_class_ancestor_has_method? "]}," StateMachines Machine define_action_hook":{"type":"method","name":"define_action_hook","children":[],"call":[" define_helper ","2029 + ","action_hook inspect ","action inspect "," owner_class private_method_defined? "," owner_class "," action "," action_hook ","2025 + ","2032 + "," action _hook inspect "," action_hook  inspect "," action  inspect ","  action  ","  action _hook ","  action_hook  "]}," StateMachines Machine define_action_helpers":{"type":"method","name":"define_action_helpers","children":[],"call":[" define_action_hook "," action_hook "]}," StateMachines Machine define_action_helpers?":{"type":"method","name":"define_action_helpers?","children":[],"call":["(send\n  (send\n    (send nil :owner_class) :state_machines) :any?) ! ","machine != ","machine action == "," action ","machine action "," owner_class state_machines any? "," owner_class state_machines "," owner_class "]}," StateMachines Machine define_path_helpers":{"type":"method","name":"define_path_helpers","children":[],"call":["machine paths_for "," define_helper "," attribute "]}," StateMachines Machine define_event_helpers":{"type":"method","name":"define_event_helpers","children":[],"call":[" define_helper ","1989 + ","event_transition_attribute inspect "," attribute ","machine write ","event to_sym ","(and\n  (send\n    (lvar :event) :respond_to?\n    (sym :empty?))\n  (send\n    (lvar :event) :empty?)) ! ","event empty? ","event respond_to? ","machine read "," action ","machine events fetch fire ","machine events fetch ","machine events ","machine events transitions_for ","event name ","machine events valid_for map ","machine events valid_for ","1985 + ","1992 + "," attribute  inspect ","machine read _transition_attribute inspect ","machine read  to_sym ","(and\n  (send\n    (lvar :machine read ) :respond_to?\n    (sym :empty?))\n  (send\n    (lvar :machine read ) :empty?)) ! ","machine read  empty? ","machine read  respond_to? ","machine machine read s fetch fire ","machine machine read s fetch ","machine machine read s ","machine machine read s transitions_for ","machine read  name ","machine machine read s valid_for map ","machine machine read s valid_for "]}," StateMachines Machine define_state_predicate":{"type":"method","name":"define_state_predicate","children":[],"call":[" define_helper ","1946 + "," name inspect "," name "," owner_class_ancestor_has_method? ! ! "," owner_class_ancestor_has_method? ! "," owner_class_ancestor_has_method? ","1942 + ","1949 + "]}," StateMachines Machine define_state_accessor":{"type":"method","name":"define_state_accessor","children":[],"call":[" attr_writer ","@helper_modules [] class_eval ","@helper_modules [] "," owner_class_ancestor_has_method? "," attr_reader "," attribute ","  attribute  "]}," StateMachines Machine define_state_initializer":{"type":"method","name":"define_state_initializer","children":[],"call":[" define_helper ","1927 + ","1923 + ","1930 + "]}," StateMachines Machine define_helpers":{"type":"method","name":"define_helpers","children":[],"call":[" define_name_helpers "," define_action_helpers "," define_action_helpers? "," define_path_helpers "," define_event_helpers "," define_state_predicate "," define_state_accessor "]}," StateMachines Machine initialize_state?":{"type":"method","name":"initialize_state?","children":[],"call":[" states [] ! "," states [] "," states ","value empty? ","value respond_to? ","value nil? "," read "," read  empty? "," read  respond_to? "," read  nil? "]}," StateMachines Machine sibling_machines":{"type":"method","name":"sibling_machines","children":[],"call":["machines << "," owner_class state_machine "," owner_class ","machine != ","machine attribute == "," attribute ","machine attribute "," owner_class state_machines inject "," owner_class state_machines "]}," StateMachines Machine after_initialize":{"type":"method","name":"after_initialize","children":[],"call":[]}," StateMachines Machine action_hook?":{"type":"method","name":"action_hook?","children":[],"call":["machine action_hook? ","machine != ","machine action == "," action ","machine action "," owner_class state_machines any? "," owner_class state_machines "," owner_class ","self_only ! "]}," StateMachines Machine draw":{"type":"method","name":"draw","children":[],"call":[" fail "]}," StateMachines Machine within_transaction":{"type":"method","name":"within_transaction","children":[],"call":[" transaction "," use_transactions "]}," StateMachines Machine generate_message":{"type":"method","name":"generate_message","children":[],"call":["message % ","value last ","values map ","match != ","message scan any? ","message scan "," class default_messages [] "," class default_messages "," class ","@messages [] "]}," StateMachines Machine reset":{"type":"method","name":"reset","children":[],"call":[]}," StateMachines Machine errors_for":{"type":"method","name":"errors_for","children":[],"call":[]}," StateMachines Machine invalidate":{"type":"method","name":"invalidate","children":[],"call":[]}," StateMachines Machine paths_for":{"type":"method","name":"paths_for","children":[],"call":["PathCollection  new "]}," StateMachines Machine after_failure":{"type":"method","name":"after_failure","children":[],"call":[" add_callback ","options assert_valid_keys ","options []= ","args any? ","args pop ","args last is_a? ","args last "]}," StateMachines Machine around_transition":{"type":"method","name":"around_transition","children":[],"call":[" add_callback ","options []= ","args any? ","args pop ","args last is_a? ","args last "]}," StateMachines Machine after_transition":{"type":"method","name":"after_transition","children":[],"call":[" add_callback ","options []= ","args any? ","args pop ","args last is_a? ","args last "]}," StateMachines Machine before_transition":{"type":"method","name":"before_transition","children":[],"call":[" add_callback ","options []= ","args any? ","args pop ","args last is_a? ","args last "]}," StateMachines Machine transition":{"type":"method","name":"transition","children":[],"call":["branches first ","branches length == ","branches length ","branches << "," transition "," event "," Array ","options delete ","options dup "," raise ","options [] ","options dup  delete ","options dup  dup ","options dup  [] "]}," StateMachines Machine event":{"type":"method","name":"event","children":[],"call":["events first ","events length == ","events length "," add_states ","event known_states ","event human_name= ","options [] ","options include? ","events each "," add_events ","names first values ","names first "," raise ","options inspect ","options any? ","names first is_a? ","@events context "," block_given? ","options assert_valid_keys ","names pop ","names last is_a? ","names last "," add_events  first "," add_events  length == "," add_events  length ","names pop  [] ","names pop  include? "," add_events  each "," add_ add_events  ","names pop  inspect ","names pop  any? ","@ add_events  context ","names pop  assert_valid_keys "]}," StateMachines Machine write":{"type":"method","name":"write","children":[],"call":["object send ","object instance_variable_set "," attribute ","  attribute  "]}," StateMachines Machine read":{"type":"method","name":"read","children":[],"call":["object send ","object instance_variable_get ","object instance_variable_defined? "," attribute ","  attribute  "]}," StateMachines Machine state":{"type":"method","name":"state","children":[],"call":["states first ","states length == ","states length ","state matcher= ","options [] ","options include? ","state cache= ","state human_name= "," states update "," states ","state value= ","states each "," add_states ","names first values ","names first "," raise ","options inspect ","options any? ","names first is_a? ","@states context "," block_given? ","options assert_valid_keys ","names pop ","names last is_a? ","names last "," add_states  first "," add_states  length == "," add_states  length ","names pop  [] ","names pop  include? ","  add_states  update ","  add_states  "," add_states  each "," add_ add_states  ","names pop  inspect ","names pop  any? ","@ add_states  context ","names pop  assert_valid_keys "]}," StateMachines Machine define_helper":{"type":"method","name":"define_helper","children":[],"call":["helper_module class_eval ","block call ","(if\n  (send\n    (lvar :scope) :==\n    (sym :instance))\n  (send\n    (self) :class)\n  (self)) state_machine "," class ","scope == "," define_method "," name "," warn ","conflicting_ancestor to_s ","conflicting_ancestor name ","conflicting_ancestor name empty? ! ","conflicting_ancestor name empty? "," owner_class_ancestor_has_method? "," class ignore_method_conflicts ! "," class ignore_method_conflicts "," block_given? ","@helper_modules fetch ","@helper_modules fetch  class_eval ","  name  "," owner_class_ancestor_has_method?  to_s ","conflicting_ancestor  name  "," owner_class_ancestor_has_method?  name ","conflicting_ancestor  name  empty? ! "," owner_class_ancestor_has_method?  name empty? ! ","conflicting_ancestor  name  empty? "," owner_class_ancestor_has_method?  name empty? ","@@helper_modules fetch s fetch "]}," StateMachines Machine attribute":{"type":"method","name":"attribute","children":[],"call":[" name ","name == "]}," StateMachines Machine initialize_state":{"type":"method","name":"initialize_state","children":[],"call":[" write ","hash []= "," attribute to_s "," attribute ","options [] ","state value "," initialize_state? "," initial_state ","options []  []= ","state state value  "," initial_state  value "," initialize_ initial_state ? "," initial_ initial_state  "]}," StateMachines Machine dynamic_initial_state?":{"type":"method","name":"dynamic_initial_state?","children":[],"call":["@initial_state is_a? "," instance_variable_defined? "]}," StateMachines Machine initial_state":{"type":"method","name":"initial_state","children":[],"call":[" states fetch "," evaluate_method "," dynamic_initial_state? "," states "," instance_variable_defined? "]}," StateMachines Machine initial_state=":{"type":"method","name":"initial_state=","children":[],"call":[" warn "," attribute "," name inspect "," name "," owner_class name "," owner_class "," owner_class_attribute_default_matches? ! "," owner_class_attribute_default_matches? "," dynamic_initial_state? "," owner_class_attribute_default nil? ! "," owner_class_attribute_default nil? "," owner_class_attribute_default ","state initial "," states detect "," states ","state initial= ","state name == ","state name "," states each "," add_states "]}," StateMachines Machine owner_class=":{"type":"method","name":"owner_class=","children":[],"call":[" owner_class state_machines []= "," name "," owner_class state_machines "," owner_class "," define_state_initializer "," include "," extend "," owner_class class_eval "," owner_class < ","helper_modules [] ","HelperModule  new "]}," StateMachines Machine initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["@callbacks [] dup ","@callbacks [] ","@states machine= ","@states dup ","@events machine= ","@events dup ","@states dup  machine= ","@states dup  dup ","@events dup  machine= ","@events dup  dup "]}," StateMachines Machine initialize":{"type":"method","name":"initialize","children":[],"call":[" initial_state= ","options [] "," sibling_machines any? "," sibling_machines "," instance_eval "," block_given? "," after_initialize "," define_scopes "," define_helpers "," add_sibling_machine_configs "," owner_class= ","StateCollection  new ","EventCollection  new ","args first ","(pair\n  (sym :use_transactions)\n  (true)) merge ","(or\n  (send\n    (ivar :@integration) :defaults)\n  (hash)) merge ","@integration defaults "," extend ","StateMachines Integrations  match ","StateMachines Integrations  find_by_name ","options include? ","options assert_valid_keys ","args pop ","args last is_a? ","args last ","(pair\n  (sym :use_transactions)\n  (true)) merge  [] ","(or\n  (send\n    (ivar :@integration) :defaults)\n  (hash)) merge  [] ","args pop  [] ","(or\n  (send\n    (ivar :StateMachines Integrations  match ) :defaults)\n  (hash)) merge ","StateMachines Integrations  match  defaults ","(pair\n  (sym :use_transactions)\n  (true)) merge  include? ","(or\n  (send\n    (ivar :@integration) :defaults)\n  (hash)) merge  include? ","args pop  include? ","(pair\n  (sym :use_transactions)\n  (true)) merge  assert_valid_keys ","(or\n  (send\n    (ivar :@integration) :defaults)\n  (hash)) merge  assert_valid_keys ","args pop  assert_valid_keys "]}," StateMachines Machine find_or_create":{"type":"method","name":"find_or_create","children":[],"call":[" new ","machine instance_eval "," block_given? ","machine owner_class= ","machine initial_state= ","options [] ","options include? ","machine clone ","options any? ","machine owner_class != ","machine owner_class ","owner_class state_machines [] ","owner_class state_machines ","owner_class respond_to? ","args first ","args pop ","args last is_a? ","args last ","owner_class state_machines values first ","owner_class state_machines values ","args first ! "," new  instance_eval ","machine clone  instance_eval ","owner_class state_machines []  instance_eval "," new  owner_class= ","machine clone  owner_class= ","owner_class state_machines []  owner_class= "," new  initial_state= ","machine clone  initial_state= ","owner_class state_machines []  initial_state= ","args pop  [] ","args pop  include? "," new  clone ","machine clone  clone ","owner_class state_machines []  clone ","args pop  any? "," new  owner_class != ","machine clone  owner_class != ","owner_class state_machines []  owner_class != "," new  owner_class ","machine clone  owner_class ","owner_class state_machines []  owner_class ","owner_class state_ new s [] ","owner_class state_machine clone s [] ","owner_class state_owner_class state_machines [] s [] ","owner_class state_ new s ","owner_class state_machine clone s ","owner_class state_owner_class state_machines [] s ","owner_class state_ new s values first ","owner_class state_machine clone s values first ","owner_class state_owner_class state_machines [] s values first ","owner_class state_ new s values ","owner_class state_machine clone s values ","owner_class state_owner_class state_machines [] s values "]}," StateMachines Integrations all":{"type":"method","name":"all","children":[],"call":[]}," StateMachines Integrations find_by_name":{"type":"method","name":"find_by_name","children":[],"call":[" raise ","IntegrationNotFound  new ","integration integration_name == ","integration integration_name "," integrations detect "," integrations "]}," StateMachines Integrations match_ancestors":{"type":"method","name":"match_ancestors","children":[],"call":["integration matches_ancestors? "," integrations detect "," integrations "]}," StateMachines Integrations match":{"type":"method","name":"match","children":[],"call":["integration matches? "," integrations detect "," integrations "]}," StateMachines IntegrationNotFound initialize":{"type":"method","name":"initialize","children":[],"call":["name inspect ","valid_integrations_name join ","Integrations  list collect ","Integrations  list "," error_message ","Integrations  list collect  join "]}," StateMachines Integrations Base included":{"type":"method","name":"included","children":[],"call":[]}," StateMachines Integrations Base ClassMethods extended":{"type":"method","name":"extended","children":[],"call":["base extend ","version active? "," versions each "," versions "]}," StateMachines Integrations Base ClassMethods locale_path":{"type":"method","name":"locale_path","children":[],"call":["File  exist? "," integration_name ","File  dirname "]}," StateMachines Integrations Base ClassMethods version":{"type":"method","name":"version","children":[],"call":[" versions << ","Module  new "," versions "]}," StateMachines Integrations Base ClassMethods versions":{"type":"method","name":"versions","children":[],"call":[]}," StateMachines Integrations Base ClassMethods matches_ancestors?":{"type":"method","name":"matches_ancestors?","children":[],"call":["(send\n  (lvar :ancestors) :&\n  (send nil :matching_ancestors)) any? ","ancestors & "," matching_ancestors "]}," StateMachines Integrations Base ClassMethods matches?":{"type":"method","name":"matches?","children":[],"call":[" matches_ancestors? ","ancestor name ","klass ancestors map ","klass ancestors ","klass <= "," matching_ancestors any? "," matching_ancestors "]}," StateMachines Integrations Base ClassMethods matching_ancestors":{"type":"method","name":"matching_ancestors","children":[],"call":[]}," StateMachines Integrations Base ClassMethods available?":{"type":"method","name":"available?","children":[],"call":["Object  const_defined? "," matching_ancestors [] split [] "," matching_ancestors [] split "," matching_ancestors [] "," matching_ancestors "," matching_ancestors any? "]}," StateMachines Integrations Base ClassMethods integration_name":{"type":"method","name":"integration_name","children":[],"call":["name to_sym ","name downcase! ","name gsub! "," name split last "," name split "," name "," name split last  to_sym "," name split last  downcase! "," name split last  gsub! ","  name split last  split last ","  name split last  split ","  name split last  "]}," StateMachines HelperModule to_s":{"type":"method","name":"to_s","children":[],"call":["@machine name inspect ","@machine name ","owner_class to_s ","owner_class name ","owner_class name empty? ! ","owner_class name empty? ","@machine owner_class ","@machine owner_class  to_s ","@machine owner_class  name ","@machine owner_class  name empty? ! ","@machine owner_class  name empty? ","@machine @machine owner_class  "]}," StateMachines HelperModule initialize":{"type":"method","name":"initialize","children":[],"call":[]}," StateMachines InstanceMethods initialize_state_machines":{"type":"method","name":"initialize_state_machines","children":[],"call":[" class state_machines initialize_states "," class state_machines "," class "]}," StateMachines InstanceMethods fire_events!":{"type":"method","name":"fire_events!","children":[],"call":[" raise ","StateMachines InvalidParallelTransition  new "," fire_events ","events + ","events pop ","(true) include? ","events last "," fail "]}," StateMachines InstanceMethods fire_events":{"type":"method","name":"fire_events","children":[],"call":[" class state_machines fire_events "," class state_machines "," class "]}," StateMachines ClassMethods state_machines":{"type":"method","name":"state_machines","children":[],"call":[" superclass state_machines dup "," superclass state_machines "," superclass "]}," StateMachines ClassMethods extended":{"type":"method","name":"extended","children":[],"call":[]}," StateMachines EventCollection match":{"type":"method","name":"match","children":[],"call":[" fetch ","requirements delete ","requirements [] "]}," StateMachines EventCollection attribute_transition_for":{"type":"method","name":"attribute_transition_for","children":[],"call":[" machine invalidate "," machine "," machine states match! human_name ","object class "," machine states match! "," machine states ","event transition_for "," [] ","event_name to_sym "," machine read "," machine action "," []  transition_for "," [] _name to_sym "," machine read  to_sym "]}," StateMachines EventCollection transitions_for":{"type":"method","name":"transitions_for","children":[],"call":["(send\n  (send nil :match\n    (lvar :requirements)) :map) compact ","event transition_for "," match map "," match "]}," StateMachines EventCollection valid_for":{"type":"method","name":"valid_for","children":[],"call":["event can_fire? "," match select "," match "]}," StateMachines EventCollection initialize":{"type":"method","name":"initialize","children":[],"call":[]}," StateMachines Event add_actions":{"type":"method","name":"add_actions","children":[],"call":[" raise ","StateMachines InvalidTransition  new "," name ","object send "," qualified_name "," machine define_helper "," machine ","machine event fire ","machine event ","machine event transition_for ","machine event can_fire? "]}," StateMachines Event inspect":{"type":"method","name":"inspect","children":[],"call":["transitions * "," name inspect "," name "," class ","(send\n  (send\n    (lvar :branch) :state_requirements) :map) * ","state_requirement [] description ","state_requirement [] ","branch state_requirements map ","branch state_requirements "," branches map "," branches "]}," StateMachines Event draw":{"type":"method","name":"draw","children":[],"call":[" fail "]}," StateMachines Event reset":{"type":"method","name":"reset","children":[],"call":[]}," StateMachines Event on_failure":{"type":"method","name":"on_failure","children":[],"call":["Transition  new run_callbacks ","Transition  new ","state name "," name "," machine "," machine invalidate ","state human_name ","object class "," human_name "," machine states match! "," machine states ","transition run_callbacks ","transition args= ","args any? "," machine states match!  name "," machine states match!  human_name "," machine  machine states match! s match! "," machine  machine states match! s ","Transition  new  run_callbacks ","Transition  new  args= "]}," StateMachines Event fire":{"type":"method","name":"fire","children":[],"call":[" on_failure ","transition perform "," transition_for "," machine reset "," machine "," transition_for  perform ","  transition_for _for "]}," StateMachines Event transition_for":{"type":"method","name":"transition_for","children":[],"call":["Transition  new ","custom_from_state ! "," name "," machine ","match [] filter first ","match [] filter ","match [] ","(lvar :from) | ","state name "," machine states map "," machine states ","(send\n  (lvar :requirements) :[]\n  (sym :to)) flatten ","requirements [] ","requirements include? ","match [] is_a? ","branch match "," branches each "," branches ","requirements []= "," machine states match! name "," machine states match! ","requirements assert_valid_keys ","custom_requirements [] _state ! ","requirements include?  ! ","branch match  [] filter first ","branch match  [] filter ","branch match  [] ","(lvar :requirements [] ) | ","branch match  [] is_a? ","branch branch match  "," machine states branch match ! name "," machine states branch match ! "]}," StateMachines Event can_fire?":{"type":"method","name":"can_fire?","children":[],"call":[" transition_for nil? ! "," transition_for nil? "," transition_for "]}," StateMachines Event transition":{"type":"method","name":"transition","children":[],"call":["branch known_states "," branches << ","Branch  new ","options merge "," name "," branches ","options assert_valid_keys ","(send\n  (send\n    (lvar :options) :keys) :-\n  (array\n    (sym :from)\n    (sym :to)\n    (sym :on)\n    (sym :except_from)\n    (sym :except_to)\n    (sym :except_on)\n    (sym :if)\n    (sym :unless))) empty? ","options keys - ","options keys "," raise ","options empty? ","Branch  new  known_states "," Branch  new es << "," Branch  new es "]}," StateMachines Event context":{"type":"method","name":"context","children":[],"call":[" instance_eval "]}," StateMachines Event human_name":{"type":"method","name":"human_name","children":[],"call":["@human_name call ","@human_name is_a? "]}," StateMachines Event initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["@known_states dup ","@branches dup ","@known_states dup  dup ","@branches dup  dup "]}," StateMachines Event initialize":{"type":"method","name":"initialize","children":[],"call":[" add_actions "," warn ","other_machine name inspect ","other_machine name ","machine name inspect ","machine name "," qualified_name inspect "," qualified_name ","other_machine events [] ","other_machine events ","other_machine != ","machine owner_class state_machines detect ","machine owner_class state_machines ","machine owner_class "," reset ","@name to_s tr ","@name to_s ","options [] ","machine namespace ","options assert_valid_keys "]}," StateMachines InvalidEvent initialize":{"type":"method","name":"initialize","children":[],"call":[" event inspect "," event "]}," StateMachines EvalHelpers evaluate_method":{"type":"method","name":"evaluate_method","children":[],"call":[" raise "," eval "," binding ","object instance_eval ","method call ","method is_a? ","args [] ","(int 0) include? ","args << ","args [] + ","arity - ","(int 1) include? ","arity != ","Proc  === "," block_given? ","method arity ","args unshift ","object send ","object method arity == ","object method arity ","object method ","klass private_method_defined? ","klass method_defined? ","args []  [] ","args [] +  [] ","args []  << ","args [] +  << ","args []  [] + ","args [] +  [] + ","method arity  - ","method arity  != ","method method arity  ","args []  unshift ","args [] +  unshift ","object method method arity  == ","object method method arity  "]}," StateMachines Error initialize":{"type":"method","name":"initialize","children":[],"call":[]}," StateMachines Callback bound_method":{"type":"method","name":"bound_method","children":[],"call":[" define_method ","(sclass\n  (lvar :method)\n  (self)) class_eval ","object instance_exec "," lambda ","type == ","arity == ","arity >= ","block arity "," type "," type  == ","block arity  == ","block arity  >= ","block block arity  ","  type  "]}," StateMachines Callback run_methods":{"type":"method","name":"run_methods","children":[],"call":[" throw ","@terminator call "," evaluate_method ","@methods each "," block_given? "," run_methods ","index + ","@methods [] "," type == "," type "]}," StateMachines Callback call":{"type":"method","name":"call","children":[],"call":[" run_methods ","@branch matches? "]}," StateMachines Callback known_states":{"type":"method","name":"known_states","children":[],"call":[" branch known_states "," branch "]}," StateMachines Callback initialize":{"type":"method","name":"initialize","children":[],"call":["Branch  new ","options delete "," bound_method ","method is_a? ","@methods map! ","(pair\n  (sym :bind_to_object)\n  (send\n    (send\n      (self) :class) :bind_to_object)) merge "," class terminator "," class "," class bind_to_object "," raise ","@methods any? ","@methods << "," block_given? ","@methods concat "," Array ","args pop ","args last is_a? ","args last ","(sym :before) include? ","(pair\n  (sym :bind_to_object)\n  (send\n    (send\n      (self) :class) :bind_to_object)) merge  delete ","args pop  delete ","(pair\n  (sym :options delete )\n  (send\n    (send\n      (self) :class) :options delete )) merge "," class options delete  "]}," StateMachines Branch matches_conditions?":{"type":"method","name":"matches_conditions?","children":[],"call":["(send\n  (send nil :Array\n    (send nil :unless_condition)) :any?) ! "," evaluate_method "," Array any? "," Array "," unless_condition "," Array all? "," if_condition ","query [] == ","query [] "]}," StateMachines Branch matches_requirement?":{"type":"method","name":"matches_requirement?","children":[],"call":["requirement matches? ","query [] ","query include? ! ","query include? "]}," StateMachines Branch match_states":{"type":"method","name":"match_states","children":[],"call":[" matches_requirement? ","state_requirement [] ","(sym :from) all? "," state_requirements detect "," state_requirements "]}," StateMachines Branch match_event":{"type":"method","name":"match_event","children":[],"call":[" matches_requirement? "," event_requirement "]}," StateMachines Branch match_query":{"type":"method","name":"match_query","children":[],"call":["state_requirement merge "," event_requirement "," match_states "," match_event "," match_states  merge "]}," StateMachines Branch build_matcher":{"type":"method","name":"build_matcher","children":[],"call":["AllMatcher  instance ","BlacklistMatcher  new "," raise ","value is_a? ","options [] ","options include? ","WhitelistMatcher  new ","options assert_exclusive_keys ","options []  is_a? "]}," StateMachines Branch draw":{"type":"method","name":"draw","children":[],"call":[" fail "]}," StateMachines Branch match":{"type":"method","name":"match","children":[],"call":[" matches_conditions? "," match_query ","query assert_valid_keys ","  match_query es_conditions? ","  match_query _query "]}," StateMachines Branch matches?":{"type":"method","name":"matches?","children":[],"call":[" match nil? ! "," match nil? "," match "]}," StateMachines Branch initialize":{"type":"method","name":"initialize","children":[],"call":["state_requirement [] values ","state_requirement [] ","(sym :from) each ","@state_requirements each ","WhitelistMatcher  new ","to is_a? ","from is_a? ","options collect ","options delete "," build_matcher ","(send\n  (send\n    (lvar :options) :keys) :-\n  (array\n    (sym :from)\n    (sym :to)\n    (sym :on)\n    (sym :except_from)\n    (sym :except_to)\n    (sym :except_on))) empty? ","options keys - ","options keys ","(sym :WhitelistMatcher  new ) each ","WhitelistMatcher  new  is_a? ","(send\n  (send\n    (lvar :options) :keys) :-\n  (array\n    (sym :from)\n    (sym :WhitelistMatcher  new )\n    (sym :on)\n    (sym :except_from)\n    (sym :except_WhitelistMatcher  new )\n    (sym :except_on))) empty? ","(send\n  (send\n    (lvar :options) :keys) :-\n  (array\n    (sym :WhitelistMatcher  new )\n    (sym :to)\n    (sym :on)\n    (sym :except_WhitelistMatcher  new )\n    (sym :except_to)\n    (sym :except_on))) empty? "]}," Hash assert_exclusive_keys":{"type":"method","name":"assert_exclusive_keys","children":[],"call":[" raise ","conflicting_keys join ","conflicting_keys length <= ","conflicting_keys length ","exclusive_keys & "," keys ","exclusive_keys &  join ","exclusive_keys &  length <= ","exclusive_keys &  length "]}," Hash assert_valid_keys":{"type":"method","name":"assert_valid_keys","children":[],"call":[" raise ","ArgumentError  new ","valid_keys map join ","valid_keys map ","k inspect ","valid_keys include? "," each_key ","valid_keys flatten! "]}," StateMachines Integrations reset":{"type":"method","name":"reset","children":[],"call":[" name_spaced_integrations ","Set  new "]}," StateMachines Integrations add":{"type":"method","name":"add","children":[],"call":["@integrations << ","integration respond_to? ","@integrations insert ","@integrations include? "]}," StateMachines Integrations name_spaced_integrations":{"type":"method","name":"name_spaced_integrations","children":[],"call":[" add ","integration respond_to? "," const_get "," constants each "," constants "," constants reverse each "," constants reverse ","(send\n  (send\n    (self) :constants) :reject) each ","i == "," constants reject "," const_get  respond_to? "]}," StateMachines Integrations integrations":{"type":"method","name":"integrations","children":[],"call":[" name_spaced_integrations "]}," StateMachines Integrations register":{"type":"method","name":"register","children":[],"call":[" fail "," add ","arg class to_s ","arg class ","name_or_module class to_s ","name_or_module class "]}," StateMachines Integrations unregister":{"type":"method","name":"unregister","children":[],"call":["@integrations delete "]}," StateMachines IntegrationNotFound error_message":{"type":"method","name":"error_message","children":[],"call":[" valid_integrations "," no_integrations ","Integrations  list size zero? ","Integrations  list size ","Integrations  list "]}," StateMachines IntegrationNotFound no_integrations":{"type":"method","name":"no_integrations","children":[],"call":[]}," StateMachines IntegrationNotFound valid_integrations_name":{"type":"method","name":"valid_integrations_name","children":[],"call":["Integrations  list collect ","Integrations  list "]}," StateMachines IntegrationNotFound valid_integrations":{"type":"method","name":"valid_integrations","children":[],"call":[" valid_integrations_name "]}," StateMachines MachineCollection resolve_use_transactions":{"type":"method","name":"resolve_use_transactions","children":[],"call":["machine use_transactions "," raise ","use_transactions != ","use_transactions nil? ! ","use_transactions nil? "," each_value ","machine machine use_transactions  ","machine use_transactions  != ","machine use_transactions  nil? ! ","machine use_transactions  nil? "]}," StateMachines State machine=":{"type":"method","name":"machine=","children":[],"call":["StateContext  new "]}," StateMachines Machine owner_class_has_method?":{"type":"method","name":"owner_class_has_method?","children":[],"call":["target private_method_defined? ","target method_defined? "," owner_class "," owner_class singleton_class ","scope == "," owner_class  private_method_defined? "," owner_class singleton_class  private_method_defined? "," owner_class  method_defined? "," owner_class singleton_class  method_defined? "]}}