{" REXML XPathNode position":{"type":"method","name":"position","children":[],"call":["@context [] "]}," REXML XPathNode initialize":{"type":"method","name":"initialize","children":[],"call":["node raw_node ","node is_a? "]}," REXML XPathParser unnode":{"type":"method","name":"unnode","children":[],"call":[" block_given? ","node raw_node ","node is_a? ","nodeset collect "," each_unnode collect "," each_unnode "]}," REXML XPathParser compare":{"type":"method","name":"compare","children":[],"call":["a >= ","a > ","a <= ","a < ","a != ","a == "," raise ","[BUG] Unexpected compare operator:  + ","b inspect ","a inspect ","operator inspect "," normalize_compare_values "]}," REXML XPathParser equality_relational_compare":{"type":"method","name":"equality_relational_compare","children":[],"call":[" compare ","Functions  number ","Functions  string ","s2 =~ ","s1 =~ ","op == ","Functions  boolean ","s2 == ","s1 == "," unnode ","set2 is_a? ","set1 is_a? ","set1 kind_of? ","set2 kind_of? ","res << "," norm ","SyncEnumerator  new each ","SyncEnumerator  new ","nd collect ","set1 size == ","set1 size ","set2 size == ","set2 size "," each_unnode any? "," each_unnode ","set1 product any? ","set1 product ","Functions  numFunctions  string er ","Functions  numFunctions  number er ","Functions  string  =~ ","Functions  Functions  string oolean ","Functions  Functions  number oolean ","Functions  string  == ","Functions  number  is_a? ","Functions  string  is_a? ","Functions  boolean  is_a? "," unnode  is_a? ","Functions  number  kind_of? ","Functions  string  kind_of? ","Functions  boolean  kind_of? "," unnode  kind_of? ","Functions  number  size == ","Functions  string  size == ","Functions  boolean  size == "," unnode  size == ","Functions  number  size ","Functions  string  size ","Functions  boolean  size "," unnode  size ","Functions  number  product any? ","Functions  string  product any? ","Functions  boolean  product any? "," unnode  product any? ","Functions  number  product ","Functions  string  product ","Functions  boolean  product "," unnode  product "]}," REXML XPathParser norm":{"type":"method","name":"norm","children":[],"call":["Functions  string ","Functions  number ","Functions  boolean "]}," REXML XPathParser child":{"type":"method","name":"child","children":[],"call":["nodesets << ","new_nodeset empty? ","new_nodeset << ","XPathNode  new ","new_nodeset size + ","new_nodeset size ","raw_node children each ","raw_node children ","i + ","raw_node children collect with_index ","raw_node children collect ","raw_node node_type ","node raw_node ","nodeset each ","node raw_node  children each ","node raw_node  children ","node raw_node  children collect with_index ","node raw_node  children collect ","raw_node raw_node node_type  ","node raw_node  node_type ","node node raw_node  "]}," REXML XPathParser next_sibling_node":{"type":"method","name":"next_sibling_node","children":[],"call":["node next_sibling_node ","node parent ","node parent class == ","node parent class ","node parent nil? ","psn nil? ","node parent  next_sibling_node parent  ","node parent  parent ","node parent  parent class == ","node parent  parent class ","node parent  parent nil? ","node next_sibling_node  nil? "]}," REXML XPathParser following_node_of":{"type":"method","name":"following_node_of","children":[],"call":[" next_sibling_node ","node children [] ","node children ","node children size > ","node children size ","node kind_of? "]}," REXML XPathParser following":{"type":"method","name":"following","children":[],"call":[" following_node_of ","followings << ","XPathNode  new ","followings size + ","followings size "," next_sibling_node ","  following_node_of _of ","  next_sibling_node _of "]}," REXML XPathParser preceding_node_of":{"type":"method","name":"preceding_node_of","children":[],"call":["psn children [] ","psn children ","psn children size > ","psn children size ","psn kind_of? ","node parent ","node parent class == ","node parent class ","node parent nil? ","psn nil? ","node previous_sibling_node ","psn children []  children [] ","node previous_sibling_node  children [] ","psn children []  children ","node previous_sibling_node  children ","psn children []  children size > ","node previous_sibling_node  children size > ","psn children []  children size ","node previous_sibling_node  children size ","psn children []  kind_of? ","node previous_sibling_node  kind_of? ","psn children []  nil? ","node previous_sibling_node  nil? "]}," REXML XPathParser preceding":{"type":"method","name":"preceding","children":[],"call":[" preceding_node_of ","precedings << ","XPathNode  new ","precedings size + ","precedings size ","ancestors delete ","ancestors include? ","parent parent ","ancestors << ","node parent ","  preceding_node_of _of ","parent parent  parent parent  ","node parent  node parent  ","node parent parent  ","node node parent  "]}," REXML XPathParser descendant_recursive":{"type":"method","name":"descendant_recursive","children":[],"call":[" descendant_recursive ","raw_node children each ","raw_node children ","node_type == ","raw_node node_type ","new_nodes []= ","new_nodeset << ","XPathNode  new ","new_nodeset size + ","new_nodeset size ","new_nodes key? ","raw_node node_type  == ","raw_node raw_node node_type  "]}," REXML XPathParser descendant":{"type":"method","name":"descendant","children":[],"call":["nodesets << ","new_nodeset empty? "," descendant_recursive ","node raw_node ","nodeset each "]}," REXML XPathParser sort":{"type":"method","name":"sort","children":[],"call":["ordered collect ","index -@ ","order == ","new_arry sort_by ","new_arry << ","node_idx reverse ","np parent ","node_idx << ","np parent index ","np parent node_type == ","np parent node_type ","node element ","node node_type == ","node node_type ","array_of_nodes each ","np parent  parent ","node element  parent ","np parent  parent index ","node element  parent index ","np parent  parent node_type == ","node element  parent node_type == ","np parent  parent node_type ","node element  parent node_type "]}," REXML XPathParser leave":{"type":"method","name":"leave","children":[],"call":[" trace "]}," REXML XPathParser enter":{"type":"method","name":"enter","children":[],"call":[" trace "]}," REXML XPathParser trace":{"type":"method","name":"trace","children":[],"call":[" puts ","args inspect ","   * ","PP  pp each_line ","PP  pp "]}," REXML XPathParser evaluate_predicate":{"type":"method","name":"evaluate_predicate","children":[],"call":["new_nodeset << ","XPathNode  new ","new_nodeset size + ","new_nodeset size ","result size > ","result size ","result inject ","result instance_of? ","result == ","node position ","result kind_of? ","result [] ","result length == ","result length "," expr ","expression dclone ","subcontext []= ","index + ","node raw_node ","node is_a? ","nodeset each_with_index ","nodeset size ","nodesets collect "," leave "," trace "," enter ","result []  size > "," expr  size > ","result []  size "," expr  size ","result []  inject "," expr  inject ","result []  instance_of? "," expr  instance_of? ","result []  == "," expr  == ","result []  kind_of? "," expr  kind_of? ","result []  [] "," expr  [] ","result []  length == "," expr  length == ","result []  length "," expr  length "]}," REXML XPathParser filter_nodeset":{"type":"method","name":"filter_nodeset","children":[],"call":["new_nodeset << ","XPathNode  new ","new_nodeset size + ","new_nodeset size ","nodeset each "]}," REXML XPathParser node_test":{"type":"method","name":"node_test","children":[],"call":[" raise ","[BUG] Unexpected node test:  + ","path_stack inspect ","operator inspect "," filter_nodeset ","nodesets collect ","raw_node target == ","raw_node target ","target empty? ","raw_node node_type == ","raw_node node_type ","node raw_node ","path_stack shift ","raw_node namespace == ","namespaces [] ","raw_node namespace ","raw_node element namespaces ","raw_node element ","raw_node namespaces ","raw_node name == ","raw_node name "," get_namespace ","raw_node element namespace ","prefix empty? ","prefix nil? "," strict? "," leave "," enter ","path_stack i get_namespace pect ","operator i get_namespace pect ","path_stack shift  inspect ","node raw_node  target == ","raw_node path_stack shift  == ","node raw_node  target ","raw_node path_stack shift  ","path_stack shift  empty? ","node raw_node  node_type == ","node raw_node  node_type ","node node raw_node  ","node raw_node  namespace == ","raw_node path_stack shift space == ","path_stack shift spaces [] ","node raw_node  namespace ","raw_node path_stack shift space ","node raw_node  element namespaces ","raw_node element path_stack shift spaces ","node raw_node  element ","node raw_node  namespaces ","raw_node path_stack shift spaces ","node raw_node  name == ","node raw_node  name "," get_path_stack shift space ","node raw_node  element namespace ","raw_node element path_stack shift space ","path_stack shift  nil? "]}," REXML XPathParser step":{"type":"method","name":"step","children":[],"call":["new_nodeset << ","XPathNode  new ","new_nodeset size + ","new_nodeset size ","ordered_nodeset each "," sort ","raw_nodes << ","node raw_node ","node respond_to? ","nodeset each ","nodesets each ","nodesets [] ","nodesets size == ","nodesets size "," evaluate_predicate ","path_stack shift dclone ","path_stack shift ","path_stack [] == ","path_stack [] "," node_test "," leave "," enter "," sort  each ","nodesets []  each "," evaluate_predicate  each "," node_test  each "," evaluate_predicate  [] "," node_test  [] "," evaluate_predicate  size == "," node_test  size == "," evaluate_predicate  size "," node_test  size "]}," REXML XPathParser expr":{"type":"method","name":"expr","children":[],"call":[" raise ","path_stack inspect ","op inspect ","res << ","Functions  send ","Functions  context= "," unnode ","result is_a? "," expr ","arg_clone collect ","arguments dclone ","subcontext []= ","node position ","node raw_node ","node is_a? ","nodeset each_with_index ","nodeset size ","path_stack shift ","path_stack shift tr ","Functions  number -@ ","Functions  number ","res is_a? ","left | ","right is_a? ","left is_a? ","left - ","left + ","left * ","left % ","left / "," equality_relational_compare ","nodeset dup ","(send\n  (lvar :left) :inject\n  (false)) ! ","a | ","left inject ","left respond_to? ","@variables [] "," following "," step "," preceding ","nodesets << ","XPathNode  new ","i + ","preceding_siblings collect with_index ","preceding_siblings collect ","preceding_siblings empty? ","all_siblings [] reverse ","all_siblings [] ","all_siblings index ","raw_node parent children ","raw_node parent ","raw_node parent nil? ","raw_node respond_to? ","nodeset each ","following_siblings collect with_index ","following_siblings collect ","following_siblings empty? ","current_index + "," descendant ","new_nodeset empty? ","new_nodeset << ","new_nodeset size + ","new_nodeset size ","raw_node node_type == ","raw_node node_type ","raw_node element ","pre_defined_namespaces merge ","raw_node element namespaces ","raw_node namespaces ","attributes each_attribute collect with_index ","attributes each_attribute collect ","attributes each_attribute ","attributes empty? ","raw_node attributes "," child ","first_raw_node root_node ","nodeset first raw_node ","nodeset first ","path_stack clear ","nodeset length == ","nodeset length ","path_stack length > ","path_stack length ","path_stack length == "," leave ","arguments dclone collect ","target_context []= ","arguments inspect ","nodeset inspect ","nodeset size != ","Functions  boolean "," trace "," enter ","path_stack shift  inspect "," unnode  << "," expr  << "," equality_relational_compare  << "," unnodeset first  "," unnode  is_a? "," expr  is_a? "," unnode ult is_a? "," expr ult is_a? "," equality_relational_compare ult is_a? ","arguments dclone  collect ","path_stack shift  dclone ","nodeset first  position ","node node raw_node  ","node raw_node parent  ","nodeset first  raw_nodeset first  ","nodeset first  is_a? ","nodeset first set each_with_index ","nodeset first set size "," equality_relational_compare  is_a? "," unnode  | "," expr  | ","Functions  number  | ","Functions  number  is_a? "," unnode  - "," expr  - ","Functions  number  - "," unnode  + "," expr  + ","Functions  number  + "," unnode  * "," expr  * ","Functions  number  * "," unnode  % "," expr  % ","Functions  number  % "," unnode  / "," expr  / ","Functions  number  / ","nodeset first set dup ","(send\n  (lvar : unnode ) :inject\n  (false)) ! ","(send\n  (lvar : expr ) :inject\n  (false)) ! ","(send\n  (lvar :Functions  number ) :inject\n  (false)) ! "," unnode  inject "," expr  inject ","Functions  number  inject ","left  unnode pond_to? ","left  expr pond_to? ","left  equality_relational_compare pond_to? "," unnode  respond_to? "," expr  respond_to? ","Functions  number  respond_to? ","nodeset first sets << ","all_siblings [] reverse  collect with_index ","all_siblings [] reverse  collect ","all_siblings [] reverse  empty? ","raw_node parent children  [] reverse ","raw_node parent children  [] ","raw_node parent children  index ","node raw_node  parent children ","raw_node parent  parent children ","raw_node raw_node parent  children ","raw_node raw_node element  children ","raw_nodeset first  parent children ","node raw_node  parent ","raw_node parent  parent ","raw_node raw_node parent  ","raw_node raw_node element  ","raw_nodeset first  parent ","node raw_node  parent nil? ","raw_node parent  parent nil? ","raw_node raw_node parent  nil? ","raw_node raw_node element  nil? ","raw_nodeset first  parent nil? ","raw_node  unnode pond_to? ","raw_node  expr pond_to? ","raw_node  equality_relational_compare pond_to? ","node raw_node  respond_to? ","raw_node parent  respond_to? ","raw_nodeset first  respond_to? ","nodeset first set each ","all_siblings []  collect with_index ","all_siblings []  collect ","all_siblings []  empty? ","all_siblings index  + ","new_nodeset first set empty? ","new_nodeset first set << ","new_nodeset first set size + ","new_nodeset first set size ","node raw_node  node_type == ","raw_node parent  node_type == ","raw_nodeset first  nodeset first _type == ","node raw_node  node_type ","raw_node parent  node_type ","raw_nodeset first  nodeset first _type ","node raw_node  element ","raw_node parent  element ","raw_nodeset first  element ","node raw_node  element namespaces ","raw_node parent  element namespaces ","raw_nodeset first  element namespaces ","node raw_node  namespaces ","raw_node parent  namespaces ","raw_nodeset first  namespaces ","raw_node attributes  each_attribute collect with_index ","raw_node attributes  each_attribute collect ","raw_node attributes  each_attribute ","raw_node attributes  empty? ","node raw_node  attributes ","raw_node parent  attributes ","raw_node raw_node attributes  ","raw_nodeset first  attributes ","first_node raw_node  root_node ","first_raw_node parent  root_node ","nodeset first raw_node  root_node ","first_raw_nodeset first  root_nodeset first  ","nodeset first node raw_node  ","nodeset first raw_node parent  ","nodeset first set first raw_nodeset first  ","nodeset first set first ","nodeset first set length == ","nodeset first set length ","path_stack shift  dclone collect ","nodeset first set inspect ","nodeset first set size != "]}," REXML XPathParser get_namespace":{"type":"method","name":"get_namespace","children":[],"call":["node namespace ","node node_type == ","node node_type ","@namespaces [] "]}," REXML XPathParser strict?":{"type":"method","name":"strict?","children":[],"call":[]}," REXML XPathParser match":{"type":"method","name":"match","children":[],"call":[" unnode "," expr ","XPathNode  new ","i + ","nodeset collect with_index ","nodeset collect "]}," REXML XPathParser first":{"type":"method","name":"first","children":[],"call":[" first "," path [] "," path ","node children "," path size == "," path size ","node name == ","node name "," fi first st ","node child first en ","node  path []  == ","node  path []  "]}," REXML XPathParser []=":{"type":"method","name":"[]=","children":[],"call":["@variables []= "]}," REXML XPathParser predicate":{"type":"method","name":"predicate","children":[],"call":[" match ","@parser parse "]}," REXML XPathParser get_first":{"type":"method","name":"get_first","children":[],"call":[" first ","@parser parse "]}," REXML XPathParser parse":{"type":"method","name":"parse","children":[],"call":[" match ","@parser parse "]}," REXML XPathParser variables=":{"type":"method","name":"variables=","children":[],"call":["Functions  variables= "]}," REXML XPathParser namespaces=":{"type":"method","name":"namespaces=","children":[],"call":["Functions  namespace_context= "]}," REXML XPathParser initialize":{"type":"method","name":"initialize","children":[],"call":["REXML Parsers XPathParser  new "]}," Array dclone":{"type":"method","name":"dclone","children":[],"call":["klone << ","v dclone "," each ","klone clear "," clone "," clone  << "," clone  clear "]}," Float dclone":{"type":"method","name":"dclone","children":[],"call":[]}," Integer dclone":{"type":"method","name":"dclone","children":[],"call":[]}," Symbol dclone":{"type":"method","name":"dclone","children":[],"call":[]}," Object dclone":{"type":"method","name":"dclone","children":[],"call":[" clone "]}," REXML XPath match":{"type":"method","name":"match","children":[],"call":[]}," REXML XPath each":{"type":"method","name":"each","children":[],"call":[]}," REXML XPath first":{"type":"method","name":"first","children":[],"call":[]}," REXML XMLDecl content":{"type":"method","name":"content","children":[],"call":["rv << ","enc !~ ","context [] == ","context [] "," parent context "," parent "," parent context  [] == "," parent context  [] "," parent  parent context  "]}," REXML XMLDecl inspect":{"type":"method","name":"inspect","children":[],"call":["START  sub + + ","STOP  sub ","START  sub + ","START  sub "]}," REXML XMLDecl dowrite":{"type":"method","name":"dowrite","children":[],"call":[]}," REXML XMLDecl nowrite":{"type":"method","name":"nowrite","children":[],"call":[]}," REXML XMLDecl default":{"type":"method","name":"default","children":[],"call":[]}," REXML XMLDecl encoding=":{"type":"method","name":"encoding=","children":[],"call":[" dowrite "," old_enc= ","enc nil? "]}," REXML XMLDecl node_type":{"type":"method","name":"node_type","children":[],"call":[]}," REXML XMLDecl xmldecl":{"type":"method","name":"xmldecl","children":[],"call":[" encoding= "]}," REXML XMLDecl ==":{"type":"method","name":"==","children":[],"call":["other standalone == ","other standalone ","other encoding == "," encoding ","other encoding ","other version == ","other version ","other kind_of? "]}," REXML XMLDecl write":{"type":"method","name":"write","children":[],"call":["writer << ","STOP  sub "," content "," encoding ","START  sub ","writer kind_of? "]}," REXML XMLDecl clone":{"type":"method","name":"clone","children":[],"call":["XMLDecl  new "]}," REXML XMLDecl initialize":{"type":"method","name":"initialize","children":[],"call":["@version nil? "," encoding= ","version standalone ","version writeencoding ","version encoding ","version version ","version kind_of? ","encoding nil? ! ","encoding nil? ","version writethis ","version version  nil? "]}," REXML Validation ValidationException initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Validation Event inspect":{"type":"method","name":"inspect","children":[],"call":["@event_type inspect "]}," REXML Validation Event to_s":{"type":"method","name":"to_s","children":[],"call":[" inspect "]}," REXML Validation Event ==":{"type":"method","name":"==","children":[],"call":["@event_arg == ","other event_arg ","@event_type == ","other event_type ","other kind_of? "]}," REXML Validation Event matches?":{"type":"method","name":"matches?","children":[],"call":["@event_arg == ","event [] ","@event_arg nil? ","event [] == "]}," REXML Validation Event single?":{"type":"method","name":"single?","children":[],"call":["@event_type != "]}," REXML Validation Event done?":{"type":"method","name":"done?","children":[],"call":[]}," REXML Validation Event initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Validation Validator validate":{"type":"method","name":"validate","children":[],"call":[" raise ","ValidationException  new ","Validation error.  Illegal  + ","attrs inspect ","attrs length > ","attrs length ","@attr_stack pop ","event [] delete ","event [] ","@current next ","text []= ","m next ","m matches? ","sattr []= ","event [] find ","@attr_stack << ","Validation error.  Expected:  + + + ","Event  new inspect ","Event  new ","Validation error.  Expected:  + + ","@current inspect ","Validation error.  Expected:  + ","@current expected join ","@current expected ","@attr_stack pop  inspect ","@attr_stack pop  length > ","@attr_stack pop  length ","@current next  next ","m next  next ","@current next  @current next atches? ","m next  m next atches? ","m @current next es? "]}," REXML Validation Validator dump":{"type":"method","name":"dump","children":[],"call":[" puts ","@root inspect "]}," REXML Validation Validator reset":{"type":"method","name":"reset","children":[],"call":["@root previous= ","@root reset "]}," REXML Validation Ref inspect":{"type":"method","name":"inspect","children":[],"call":[" to_s "]}," REXML Validation Ref to_s":{"type":"method","name":"to_s","children":[],"call":[]}," REXML Validation Ref initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Validation Interleave inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (ivar :@choices) :collect) join ","(send\n  (lvar :e) :collect) join ","f to_s ","e collect ","@choices collect "," to_s "]}," REXML Validation Interleave expected":{"type":"method","name":"expected","children":[],"call":["(send\n  (send\n    (ivar :@choices) :[]\n    (irange\n      (ivar :@choice)\n      (int -1))) :collect) flatten ","x [] ","x [] expected ","x [] kind_of? ","@choices [] collect ","@choices [] ","@events [] "]}," REXML Validation Interleave matches?":{"type":"method","name":"matches?","children":[],"call":["(send\n  (send\n    (ivar :@choices) :[]\n    (irange\n      (ivar :@choice)\n      (int -1))) :find) nil? ! ","(send\n  (send\n    (ivar :@choices) :[]\n    (irange\n      (ivar :@choice)\n      (int -1))) :find) nil? ","evt [] matches? ","evt [] ","@choices [] find ","@choices [] ","@events [] matches? ","@events [] "]}," REXML Validation Interleave next":{"type":"method","name":"next","children":[],"call":["@events [] ","@current - ","@events [] previous= ","@events [] kind_of? ","@previous pop ","@choices [] nil? ","@choices [] ","@events [] nil? ","@events [] matches? ","@previous pop next ","@events [] next "," expand_ref_in ","@events [] class == ","@events [] class "," next_current "]}," REXML Validation Interleave next_current":{"type":"method","name":"next_current","children":[],"call":["@choices []= ","@choices index ","@choices [] ","evt [] matches? ","evt [] ","@choices [] find ","@choices delete "," expand_ref_in ","@choices [] [] class == ","@choices [] [] class ","@choices [] [] ","c < ","@choices size "]}," REXML Validation Interleave reset":{"type":"method","name":"reset","children":[],"call":[]}," REXML Validation Interleave initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Validation Choice add_event_to_arry":{"type":"method","name":"add_event_to_arry","children":[],"call":["arry [] << "," generate_event ","arry [] ","arry << ","evt [] == ","evt [] ","arry [] [] event_arg= ","arry [] [] ","arry [] [] event_type == ","arry [] [] event_type ","arry [] [] kind_of? ","evt class == ","evt class ","evt kind_of? "]}," REXML Validation Choice inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (ivar :@choices) :collect) join ","(send\n  (lvar :e) :collect) join ","f to_s ","e collect ","@choices collect "," to_s "]}," REXML Validation Choice expected":{"type":"method","name":"expected","children":[],"call":["(send\n  (ivar :@choices) :collect) flatten ","x [] ","x [] expected ","x [] kind_of? ","@choices collect ","@events [] ","@events size > ","@events size "]}," REXML Validation Choice matches?":{"type":"method","name":"matches?","children":[],"call":["(send\n  (ivar :@choices) :find) nil? ! ","(send\n  (ivar :@choices) :find) nil? ","evt [] matches? ","evt [] ","@choices find ","@events [] matches? ","@events [] ","@events size > ","@events size "]}," REXML Validation Choice next":{"type":"method","name":"next","children":[],"call":["evt [] matches? ","evt [] ","@choices find ","@choices delete ","@choices [] "," expand_ref_in ","@choices [] [] class == ","@choices [] [] class ","@choices [] [] ","c < ","@choices size ","@events size == ","@events size "]}," REXML Validation Choice <<":{"type":"method","name":"<<","children":[],"call":[" add_event_to_arry "]}," REXML Validation Choice reset":{"type":"method","name":"reset","children":[],"call":["s reset ","s kind_of? ","c each ","@choices each "]}," REXML Validation Choice initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Validation OneOrMore expected":{"type":"method","name":"expected","children":[],"call":["@events [] ","(send\n  (send\n    (ivar :@previous) :[]\n    (int -1)) :expected) flatten ","@previous [] expected ","@previous [] ","@ord > ","@current == "]}," REXML Validation OneOrMore matches?":{"type":"method","name":"matches?","children":[],"call":["@previous [] matches? ","@previous [] ","@ord > ","@current == ","@events [] matches? ","@events [] "]}," REXML Validation OneOrMore next":{"type":"method","name":"next","children":[],"call":["@previous pop next ","@previous pop ","@ord > ","@current == ","@events [] ","@current - ","@events [] previous= ","@events [] kind_of? ","@events [] nil? ","@events [] matches? "," expand_ref_in ","@events [] class == ","@events [] class "]}," REXML Validation OneOrMore reset":{"type":"method","name":"reset","children":[],"call":[]}," REXML Validation OneOrMore initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Validation ZeroOrMore expected":{"type":"method","name":"expected","children":[],"call":["@events [] ","(send\n  (ivar :@prior) :expected) flatten ","@prior expected ","@current == "]}," REXML Validation ZeroOrMore next":{"type":"method","name":"next","children":[],"call":["@prior next ","@current == ","@previous pop ","@events [] ","@current - ","@events [] previous= ","@events [] kind_of? ","@events [] nil? ","@events [] matches? "," expand_ref_in ","@events [] class == ","@events [] class ","@previous pop  next "]}," REXML Validation Optional expected":{"type":"method","name":"expected","children":[],"call":["@events [] ","(send\n  (ivar :@prior) :expected) flatten ","@prior expected ","@current == "]}," REXML Validation Optional matches?":{"type":"method","name":"matches?","children":[],"call":["@previous [] matches? ","@previous [] ","@current == ","@events [] matches? ","@events [] "]}," REXML Validation Optional next":{"type":"method","name":"next","children":[],"call":["@prior next ","@previous pop ","@current == ","@previous pop  next "]}," REXML Validation Sequence matches?":{"type":"method","name":"matches?","children":[],"call":["@events [] matches? ","@events [] "]}," REXML Validation State generate_event":{"type":"method","name":"generate_event","children":[],"call":["Event  new ","event [] ","event [] [] ","event class == ","event class ","event kind_of? "]}," REXML Validation State add_event_to_arry":{"type":"method","name":"add_event_to_arry","children":[],"call":["arry << ","arry [] event_arg= ","arry [] ","arry [] kind_of? ","evt kind_of? "," generate_event "," generate_event  kind_of? "]}," REXML Validation State expand_ref_in":{"type":"method","name":"expand_ref_in","children":[],"call":["arry []= "," add_event_to_arry ","@references [] each ","@references [] ","arry [] to_s ","arry [] "]}," REXML Validation State <<":{"type":"method","name":"<<","children":[],"call":[" add_event_to_arry "]}," REXML Validation State expected":{"type":"method","name":"expected","children":[],"call":["@events [] "]}," REXML Validation State inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (ivar :@events) :collect) join ","pre + ","e inspect "," == ","e == ","@events [] ","@events collect "," to_s "]}," REXML Validation State to_s":{"type":"method","name":"to_s","children":[],"call":[" class name =~ "," class name "," class "]}," REXML Validation State next":{"type":"method","name":"next","children":[],"call":["@events [] ","@current - ","@events [] previous= ","@events [] kind_of? ","@previous pop ","@events [] nil? ","@events [] matches? ","@events [] next "," expand_ref_in ","@events [] class == ","@events [] class ","@previous pop next "]}," REXML Validation State previous=":{"type":"method","name":"previous=","children":[],"call":["@previous << "]}," REXML Validation State reset":{"type":"method","name":"reset","children":[],"call":["s reset ","s kind_of? ","@events each ","@current == "]}," REXML Validation State initialize":{"type":"method","name":"initialize","children":[],"call":["context references ","context count "]}," REXML Validation RelaxNG receive":{"type":"method","name":"receive","children":[],"call":[" validate "]}," REXML Validation RelaxNG initialize":{"type":"method","name":"initialize","children":[],"call":["states [] << ","states [] ","@references []= ","ref shift ","states pop ","event [] ","states << ","AnyName  new ","Ref  new ","event [] [] ","Interleave  new ","Sequence  new ","ZeroOrMore  new ","OneOrMore  new ","Choice  new ","Optional  new ","parser pull ","event [] != ","@root previous= ","REXML Parsers BaseParser  new ","@states pop erences []= ","states pop  shift ","parser pull  [] ","parser pull  [] [] ","REXML Parsers BaseParser  new  pull ","parser pull  [] != "]}," REXML UndefinedNamespaceException initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Text expand":{"type":"method","name":"expand","children":[],"call":[]}," REXML Text unnormalize":{"type":"method","name":"unnormalize","children":[],"call":[]}," REXML Text normalize":{"type":"method","name":"normalize","children":[],"call":[]}," REXML Text read_with_substitution":{"type":"method","name":"read_with_substitution","children":[],"call":[]}," REXML Text clear_cache":{"type":"method","name":"clear_cache","children":[],"call":[]}," REXML Text write_with_substitution":{"type":"method","name":"write_with_substitution","children":[],"call":["out << ","copy gsub! ","SUBSTITUTES  [] ","SPECIALS  [] ","input clone ","input clone  gsub! "]}," REXML Text xpath":{"type":"method","name":"xpath","children":[],"call":["@parent xpath ","@parent x@parent xpath  "]}," REXML Text write":{"type":"method","name":"write","children":[],"call":["formatter write ","REXML Formatters Default  new ","REXML Formatters Pretty  new ","indent > ","Kernel  warn "," class name "," class ","REXML Formatters Default  new  write ","REXML Formatters Pretty  new  write "]}," REXML Text indent_text":{"type":"method","name":"indent_text","children":[],"call":["new_string strip! ","new_string << ","(send\n  (lvar :indent_string) :+\n  (lvar :line)) sub ","indent_string + ","style * ","string each_line ","level < ","(send\n  (lvar :style * ) :+\n  (lvar :line)) sub ","style *  + "]}," REXML Text wrap":{"type":"method","name":"wrap","children":[],"call":["string [] + + "," wrap ","string [] ","place + ","string [] + ","\n + + + ","\n + + ","\n + ","string rindex ","string length <= ","string length ","string rindex  + "]}," REXML Text value=":{"type":"method","name":"value=","children":[],"call":[" clear_cache ","val gsub "]}," REXML Text value":{"type":"method","name":"value","children":[],"call":["Text  unnormalize "," doctype "]}," REXML Text inspect":{"type":"method","name":"inspect","children":[],"call":["@string inspect "]}," REXML Text to_s":{"type":"method","name":"to_s","children":[],"call":["Text  normalize "," doctype "]}," REXML Text doctype":{"type":"method","name":"doctype","children":[],"call":["doc doctype ","@parent document ","@parent document  @parent document type ","@parent @parent document ument "]}," REXML Text <=>":{"type":"method","name":"<=>","children":[],"call":[" to_s <=> ","other to_s "," to_s "]}," REXML Text <<":{"type":"method","name":"<<","children":[],"call":[" clear_cache ","@string << ","to_append gsub "]}," REXML Text clone":{"type":"method","name":"clone","children":[],"call":["Text  new "]}," REXML Text empty?":{"type":"method","name":"empty?","children":[],"call":["@string size == ","@string size "]}," REXML Text node_type":{"type":"method","name":"node_type","children":[],"call":[]}," REXML Text check":{"type":"method","name":"check","children":[],"call":[]}," REXML Text parent=":{"type":"method","name":"parent=","children":[],"call":["Text  check "," doctype "]}," REXML Text initialize":{"type":"method","name":"initialize","children":[],"call":["Text  check "," doctype "," clear_cache ","raw nil? ","@string gsub! ","@string squeeze! "," raise ","arg type ","arg instance_variable_get ","arg raw ","arg instance_variable_get dup ","arg kind_of? ","arg dup ","parent raw ","arg instance_variable_get dup  gsub! ","arg dup  gsub! ","arg instance_variable_get dup  squeeze! ","arg dup  squeeze! "]}," REXML SyncEnumerator each":{"type":"method","name":"each","children":[],"call":["x [] ","@gens collect ","@length times "]}," REXML SyncEnumerator length":{"type":"method","name":"length","children":[],"call":["@gens length "]}," REXML SyncEnumerator size":{"type":"method","name":"size","children":[],"call":["@gens size "]}," REXML SyncEnumerator initialize":{"type":"method","name":"initialize","children":[],"call":["(send\n  (ivar :@gens) :collect) max ","x size ","@gens collect "]}," REXML StreamListener xmldecl":{"type":"method","name":"xmldecl","children":[],"call":[]}," REXML StreamListener cdata":{"type":"method","name":"cdata","children":[],"call":[]}," REXML StreamListener entity":{"type":"method","name":"entity","children":[],"call":[]}," REXML StreamListener notationdecl":{"type":"method","name":"notationdecl","children":[],"call":[]}," REXML StreamListener entitydecl":{"type":"method","name":"entitydecl","children":[],"call":[]}," REXML StreamListener elementdecl":{"type":"method","name":"elementdecl","children":[],"call":[]}," REXML StreamListener attlistdecl":{"type":"method","name":"attlistdecl","children":[],"call":[]}," REXML StreamListener doctype_end":{"type":"method","name":"doctype_end","children":[],"call":[]}," REXML StreamListener doctype":{"type":"method","name":"doctype","children":[],"call":[]}," REXML StreamListener comment":{"type":"method","name":"comment","children":[],"call":[]}," REXML StreamListener instruction":{"type":"method","name":"instruction","children":[],"call":[]}," REXML StreamListener text":{"type":"method","name":"text","children":[],"call":[]}," REXML StreamListener tag_end":{"type":"method","name":"tag_end","children":[],"call":[]}," REXML StreamListener tag_start":{"type":"method","name":"tag_start","children":[],"call":[]}," REXML Security entity_expansion_text_limit":{"type":"method","name":"entity_expansion_text_limit","children":[],"call":[]}," REXML Security entity_expansion_text_limit=":{"type":"method","name":"entity_expansion_text_limit=","children":[],"call":[]}," REXML Security entity_expansion_limit":{"type":"method","name":"entity_expansion_limit","children":[],"call":[]}," REXML Security entity_expansion_limit=":{"type":"method","name":"entity_expansion_limit=","children":[],"call":[]}," REXML SAX2Listener progress":{"type":"method","name":"progress","children":[],"call":[]}," REXML SAX2Listener comment":{"type":"method","name":"comment","children":[],"call":[]}," REXML SAX2Listener xmldecl":{"type":"method","name":"xmldecl","children":[],"call":[]}," REXML SAX2Listener cdata":{"type":"method","name":"cdata","children":[],"call":[]}," REXML SAX2Listener notationdecl":{"type":"method","name":"notationdecl","children":[],"call":[]}," REXML SAX2Listener entitydecl":{"type":"method","name":"entitydecl","children":[],"call":[]}," REXML SAX2Listener elementdecl":{"type":"method","name":"elementdecl","children":[],"call":[]}," REXML SAX2Listener attlistdecl":{"type":"method","name":"attlistdecl","children":[],"call":[]}," REXML SAX2Listener doctype":{"type":"method","name":"doctype","children":[],"call":[]}," REXML SAX2Listener processing_instruction":{"type":"method","name":"processing_instruction","children":[],"call":[]}," REXML SAX2Listener characters":{"type":"method","name":"characters","children":[],"call":[]}," REXML SAX2Listener end_element":{"type":"method","name":"end_element","children":[],"call":[]}," REXML SAX2Listener start_element":{"type":"method","name":"start_element","children":[],"call":[]}," REXML SAX2Listener end_prefix_mapping":{"type":"method","name":"end_prefix_mapping","children":[],"call":[]}," REXML SAX2Listener start_prefix_mapping":{"type":"method","name":"start_prefix_mapping","children":[],"call":[]}," REXML SAX2Listener end_document":{"type":"method","name":"end_document","children":[],"call":[]}," REXML SAX2Listener start_document":{"type":"method","name":"start_document","children":[],"call":[]}," REXML QuickPath parse_args":{"type":"method","name":"parse_args","children":[],"call":[]}," REXML QuickPath function":{"type":"method","name":"function","children":[],"call":[]}," REXML QuickPath method_missing":{"type":"method","name":"method_missing","children":[],"call":[]}," REXML QuickPath name":{"type":"method","name":"name","children":[],"call":[]}," REXML QuickPath attribute":{"type":"method","name":"attribute","children":[],"call":[]}," REXML QuickPath predicate":{"type":"method","name":"predicate","children":[],"call":[]}," REXML QuickPath axe":{"type":"method","name":"axe","children":[],"call":[]}," REXML QuickPath filter":{"type":"method","name":"filter","children":[],"call":[]}," REXML QuickPath match":{"type":"method","name":"match","children":[],"call":[]}," REXML QuickPath each":{"type":"method","name":"each","children":[],"call":[]}," REXML QuickPath first":{"type":"method","name":"first","children":[],"call":[]}," REXML Parsers XPathParser parse_args":{"type":"method","name":"parse_args","children":[],"call":["depth == ","string [] ","ind + ","arguments << ","s == ","string [] strip ","inapos ! ","inquot ! ","ind < ","string length ","depth > ","string []  [] ","string [] strip tring [] ","argumentstring [] strip  << ","string [] strip  == ","string []  [] strip ","string [] strip tring [] string [] strip trip ","inapostring [] strip  ! ","inapos !  ! ","inquot !  ! ","string []  length ","string [] strip tring length "]}," REXML Parsers XPathParser get_group":{"type":"method","name":"get_group","children":[],"call":["string [] ","ind - ","depth == ","ind < ","string length ","depth > ","st == ","string [] ring [] ","string [] ring length ","string []  == "]}," REXML Parsers XPathParser FunctionCall":{"type":"method","name":"FunctionCall","children":[],"call":["parsed << ","argset << "," OrExpr "," parse_args "]}," REXML Parsers XPathParser PrimaryExpr":{"type":"method","name":"PrimaryExpr","children":[],"call":["parsed concat "," OrExpr ","contents [] "," get_group ","parsed << ","1 nil? ","varname to_i ","varname to_f ","varname include? "," FunctionCall ","fname =~ ","contents []  [] "]}," REXML Parsers XPathParser FilterExpr":{"type":"method","name":"FilterExpr","children":[],"call":["parsed concat "," Predicate "," PrimaryExpr ","path == "," Predicate  == "," PrimaryExpr  == "]}," REXML Parsers XPathParser PathExpr":{"type":"method","name":"PathExpr","children":[],"call":["parsed concat "," LocationPath ","rest =~ "," RelativeLocationPath ","rest [] == ","rest [] ","rest != "," FilterExpr ","path lstrip "," LocationPath  =~ "," RelativeLocationPath  =~ "," FilterExpr  =~ "," LocationPath  [] == "," RelativeLocationPath  [] == "," FilterExpr  [] == "," LocationPath  [] "," RelativeLocationPath  [] "," FilterExpr  [] "," LocationPath  != "," RelativeLocationPath  != "," FilterExpr  != ","path lstrip  lstrip "]}," REXML Parsers XPathParser UnionExpr":{"type":"method","name":"UnionExpr","children":[],"call":["parsed << ","n size > ","n size ","parsed replace ","n size != ","parsed size == ","parsed size "," PathExpr ","n [] ","rest =~ ","rest != "," PathExpr  =~ "," PathExpr  != "]}," REXML Parsers XPathParser UnaryExpr":{"type":"method","name":"UnaryExpr","children":[],"call":["parsed concat "," UnionExpr ","parsed << ","mult < ","(send\n  (send\n    (nth-ref 1) :size) :%\n  (int 2)) != ","1 size % ","1 size ","path =~ "," UnionExpr  =~ "]}," REXML Parsers XPathParser MultiplicativeExpr":{"type":"method","name":"MultiplicativeExpr","children":[],"call":["parsed << ","n size > ","n size ","parsed replace ","n size != ","parsed size == ","parsed size "," UnaryExpr ","n [] ","1 include? ","1 [] == ","1 [] ","rest =~ ","rest != "," UnaryExpr  =~ "," UnaryExpr  != "]}," REXML Parsers XPathParser AdditiveExpr":{"type":"method","name":"AdditiveExpr","children":[],"call":["parsed << ","n size > ","n size ","parsed replace ","n size != ","parsed size == ","parsed size "," MultiplicativeExpr ","n [] ","1 [] == ","1 [] ","rest =~ ","rest != "," MultiplicativeExpr  =~ "," MultiplicativeExpr  != "]}," REXML Parsers XPathParser RelationalExpr":{"type":"method","name":"RelationalExpr","children":[],"call":["parsed << ","n size > ","n size ","parsed replace ","n size != ","parsed size == ","parsed size "," AdditiveExpr ","n [] ","sym intern ","sym << ","1 [] == ","1 [] ","rest =~ ","rest != "," AdditiveExpr  =~ "," AdditiveExpr  != "]}," REXML Parsers XPathParser EqualityExpr":{"type":"method","name":"EqualityExpr","children":[],"call":["parsed << ","n size > ","n size ","parsed replace ","n size != ","parsed size == ","parsed size "," RelationalExpr ","n [] ","1 [] == ","1 [] ","rest =~ ","rest != "," RelationalExpr  =~ "," RelationalExpr  != "]}," REXML Parsers XPathParser AndExpr":{"type":"method","name":"AndExpr","children":[],"call":["parsed << ","n size > ","n size ","parsed replace ","n size != ","parsed size == ","parsed size "," EqualityExpr ","n [] ","rest =~ ","rest != "," EqualityExpr  =~ "," EqualityExpr  != "]}," REXML Parsers XPathParser OrExpr":{"type":"method","name":"OrExpr","children":[],"call":["parsed << ","n size > ","n size ","parsed replace ","n size != ","parsed size == ","parsed size "," AndExpr ","n [] ","rest =~ ","rest != "," AndExpr  =~ "," AndExpr  != "]}," REXML Parsers XPathParser Predicate":{"type":"method","name":"Predicate","children":[],"call":[" OrExpr ","parsed << ","predicates each ","predicates << ","expr [] "," get_group ","path [] == ","path [] ","path lstrip ","path lstrip  [] == ","path lstrip  [] ","path lstrip  lstrip "]}," REXML Parsers XPathParser NodeTest":{"type":"method","name":"NodeTest","children":[],"call":["parsed << ","path [] "," raise ","ParseException  new ","path [] != ","path =~ ","path !~ ","type tr intern ","type tr ","path lstrip ","path []  [] ","path lstrip  [] ","path []  [] != ","path lstrip  [] != ","path []  =~ ","path lstrip  =~ ","path []  !~ ","path lstrip  !~ ","path []  lstrip ","path lstrip  lstrip "]}," REXML Parsers XPathParser RelativeLocationPath":{"type":"method","name":"RelativeLocationPath","children":[],"call":["path [] ","parsed << ","path [] == ","path [] != ","path empty? ","path lstrip ","parsed concat "," Predicate "," NodeTest ","1 tr intern ","1 tr ","path =~ "," loop ","path == ","parsed_not_abberviated << ","path []  [] ","path lstrip  [] "," Predicate  [] "," NodeTest  [] ","path []  [] == ","path lstrip  [] == "," Predicate  [] == "," NodeTest  [] == ","path []  [] != ","path lstrip  [] != "," Predicate  [] != "," NodeTest  [] != ","path []  empty? ","path lstrip  empty? "," Predicate  empty? "," NodeTest  empty? ","path []  lstrip ","path lstrip  lstrip "," Predicate  lstrip "," NodeTest  lstrip ","path []  =~ ","path lstrip  =~ "," Predicate  =~ "," NodeTest  =~ ","path []  == ","path lstrip  == "," Predicate  == "," NodeTest  == "]}," REXML Parsers XPathParser LocationPath":{"type":"method","name":"LocationPath","children":[],"call":[" RelativeLocationPath ","path size > ","path size ","path [] ","parsed << ","path [] == ","path lstrip ","path []  size > ","path lstrip  size > ","path []  size ","path lstrip  size ","path []  [] ","path lstrip  [] ","path []  [] == ","path lstrip  [] == ","path []  lstrip ","path lstrip  lstrip "]}," REXML Parsers XPathParser predicate_to_string":{"type":"method","name":"predicate_to_string","children":[],"call":["string squeeze ","string << ","path shift inspect ","path shift "," predicate_to_string ","op to_s ","path [] ","path shift  to_s "]}," REXML Parsers XPathParser expand":{"type":"method","name":"expand","children":[],"call":["/ + ","string << ","op inspect ","string size == ","string size "," expand "," predicate_to_string ","path shift ","prefix + ","prefix size > ","prefix size ","op to_s tr ","op to_s ","path size > ","path size "," parse ","path kind_of? ","path << "," predicate_to_path ","parsed shift ","path size == ","parsed size > ","parsed size ","path_or_parsed kind_of? ","/ +  << ","path shift  inspect ","parsed shift  inspect ","/ +  size == ","/ +  size "," predicate_to_/ +  "," parse  shift ","/ +  shift ","path shift  + ","parsed shift  + ","path shift  size > ","parsed shift  size > ","path shift  size ","parsed shift  size ","path shift  to_s tr ","parsed shift  to_s tr ","path shift  to_s ","parsed shift  to_s "," parse  size > ","/ +  size > "," parse  size "," parse  kind_of? ","/ +  kind_of? "," parse  << "," predicate_to_ parse  "," parse  size == "," parse _or_parsed kind_of? ","/ + _or_parsed kind_of? ","path_or_ parse  kind_of? "]}," REXML Parsers XPathParser abbreviate":{"type":"method","name":"abbreviate","children":[],"call":["/ + ","string << ","op inspect ","string size == ","string size ","path shift "," abbreviate "," predicate_to_string ","path shift [] ","prefix + ","prefix size > ","prefix size ","op to_s tr ","op to_s ","string size > ","path size > ","path size "," parse ","path kind_of? ","components join ","component << "," quote_literal ","parsed shift "," predicate_to_path ","parsed shift [] ","components << ","op to_s tr << ","next_op == ","parsed [] ","parsed size > ","parsed size ","path_or_parsed kind_of? ","/ +  << ","path shift  inspect ","parsed shift  inspect ","/ +  size == ","/ +  size "," parse  shift "," predicate_to_/ +  "," parse  shift [] ","path shift  + ","parsed shift  + ","path shift  size > ","parsed shift  size > ","path shift  size ","parsed shift  size ","path shift  to_s tr ","parsed shift  to_s tr ","path shift  to_s ","parsed shift  to_s ","/ +  size > "," parse  size > "," parse  size "," parse  kind_of? ","op to_s tr << s join ","op to_s tr <<  << "," predicate_to_ parse  ","op to_s tr << s << ","path shift  to_s tr << ","parsed shift  to_s tr << ","next_path shift  == ","next_parsed shift  == ","parsed []  == "," parse  [] "," parse _or_parsed kind_of? ","path_or_ parse  kind_of? "]}," REXML Parsers XPathParser predicate":{"type":"method","name":"predicate","children":[],"call":[" Predicate "]}," REXML Parsers XPathParser parse":{"type":"method","name":"parse","children":[],"call":[" OrExpr ","path gsub! ","path dup "," raise ","ParseException  new ","Garbage component exists at the end:  + ","rest strip empty? ","rest strip ","path dup  gsub! ","path dup  dup "," OrExpr  strip empty? "," OrExpr  strip "]}," REXML Parsers XPathParser namespaces=":{"type":"method","name":"namespaces=","children":[],"call":["Functions  namespace_context= "]}," REXML Parsers UltraLightParser parse":{"type":"method","name":"parse","children":[],"call":["context << ","context [] ","event []= ","event [] ","@parser pull ","context []  << ","context []  [] ","@parser pull  []= ","@parser pull  [] "]}," REXML Parsers UltraLightParser rewind":{"type":"method","name":"rewind","children":[],"call":["@parser stream= ","@stream rewind "]}," REXML Parsers UltraLightParser add_listener":{"type":"method","name":"add_listener","children":[],"call":["@parser add_listener "]}," REXML Parsers UltraLightParser initialize":{"type":"method","name":"initialize","children":[],"call":["REXML Parsers BaseParser  new "]}," REXML Parsers TreeParser parse":{"type":"method","name":"parse","children":[],"call":[" raise ","ParseException  new ","@parser source ","$! message ","@build_context add ","XMLDecl  new ","event [] ","NotationDecl  new ","Entity  new ","entities []= ","event [] =~ ","ElementDecl  new ","ExternalEntity  new ","AttlistDecl  new ","DocType  new ","@build_context parent ","@build_context entities [] value ","@build_context entities [] ","@build_context entities ","entities each ","Instruction  new ","CData  new ","Comment  new ","Text  new ","@build_context whitespace ","event [] strip size == ","event [] strip size ","event [] strip ","@build_context ignore_whitespace_nodes ","@build_context [] << ","@build_context [] ","@build_context [] instance_of? ","in_doctype ! ","tag_stack pop ","el attributes []= ","Attribute  new ","el attributes ","event [] each ","@build_context add_element ","tag_stack push ","@build_context xpath ","tag_stack empty? ","@parser pull ","ParseEXMLDecl  new ception  new ","ParseExceptioNotationDecl  new   NotationDecl  new ew ","ParseExceptioElementDecl  new   ElementDecl  new ew ","ParseExceptioExternalEntity  new   ExternalEntity  new ew ","ParseExceptioAttlistDecl  new   AttlistDecl  new ew ","ParseExCData  new eption  new ","ParseExComment  new eption  new ","@parser sourCData  new e ","@parser sourComment  new e ","@build_conteXMLDecl  new t add ","@build_coNotationDecl  new text add ","@build_coElementDecl  new text add ","@build_coExternalEntity  new text add ","@build_coAttlistDecl  new text add ","@build_context parent  add ","@build_context add_element  add ","@build_CData  new ontext add ","@build_Comment  new ontext add ","XMLDecl  NotationDecl  new ew ","XMLDecl  ElementDecl  new ew ","XMLDecl  ExternalEntity  new ew ","XMLDecl  AttlistDecl  new ew ","XMLDeCData  new l  new ","XMLDeComment  new l  new ","eveNotationDecl  new t [] ","eveElementDecl  new t [] ","eveExternalEntity  new t [] ","eveAttlistDecl  new t [] ","@parser pull  [] ","NotatioNotationDecl  new Decl  NotationDecl  new ew ","NotatioElementDecl  new Decl  ElementDecl  new ew ","NotatioExternalEntity  new Decl  ExternalEntity  new ew ","NotatioAttlistDecl  new Decl  AttlistDecl  new ew ","NotationDeCData  new l  new ","NotationDeComment  new l  new ","ENotationDecl  new tity  NotationDecl  new ew ","EElementDecl  new tity  ElementDecl  new ew ","EExternalEntity  new tity  ExternalEntity  new ew ","EAttlistDecl  new tity  AttlistDecl  new ew ","eNotationDecl  new tities []= ","eElementDecl  new tities []= ","eExternalEntity  new tities []= ","eAttlistDecl  new tities []= ","eveNotationDecl  new t [] =~ ","eveElementDecl  new t [] =~ ","eveExternalEntity  new t [] =~ ","eveAttlistDecl  new t [] =~ ","@parser pull  [] =~ ","ElemeNotationDecl  new tDecl  NotationDecl  new ew ","ElemeElementDecl  new tDecl  ElementDecl  new ew ","ElemeExternalEntity  new tDecl  ExternalEntity  new ew ","ElemeAttlistDecl  new tDecl  AttlistDecl  new ew ","ElementDeCData  new l  new ","ElementDeComment  new l  new ","EXMLDecl  new ternalEntity  new ","ExterNotationDecl  new alENotationDecl  new tity  NotationDecl  new ew ","ExterElementDecl  new alEElementDecl  new tity  ElementDecl  new ew ","ExterExternalEntity  new alEExternalEntity  new tity  ExternalEntity  new ew ","ExterAttlistDecl  new alEAttlistDecl  new tity  AttlistDecl  new ew ","AttlistDecl  NotationDecl  new ew ","AttlistDecl  ElementDecl  new ew ","AttlistDecl  ExternalEntity  new ew ","AttlistDecl  AttlistDecl  new ew ","AttlistDeCData  new l  new ","AttlistDeComment  new l  new ","DocType  NotationDecl  new ew ","DocType  ElementDecl  new ew ","DocType  ExternalEntity  new ew ","DocType  AttlistDecl  new ew ","DoCData  new Type  new ","DoComment  new Type  new ","@build_conteXMLDecl  new t parent ","@build_coNotationDecl  new text pareNotationDecl  new t ","@build_coElementDecl  new text pareElementDecl  new t ","@build_coExternalEntity  new text pareExternalEntity  new t ","@build_coAttlistDecl  new text pareAttlistDecl  new t ","@build_context parent  parent ","@build_context add_element  parent ","@build_CData  new ontext parent ","@build_Comment  new ontext parent ","@build_conteXMLDecl  new t entities [] value ","@build_coNotationDecl  new text eNotationDecl  new tities [] value ","@build_coElementDecl  new text eElementDecl  new tities [] value ","@build_coExternalEntity  new text eExternalEntity  new tities [] value ","@build_coAttlistDecl  new text eAttlistDecl  new tities [] value ","@build_context parent  entities [] value ","@build_context add_element  entities [] value ","@build_CData  new ontext entities [] value ","@build_Comment  new ontext entities [] value ","@build_conteXMLDecl  new t entities [] ","@build_coNotationDecl  new text eNotationDecl  new tities [] ","@build_coElementDecl  new text eElementDecl  new tities [] ","@build_coExternalEntity  new text eExternalEntity  new tities [] ","@build_coAttlistDecl  new text eAttlistDecl  new tities [] ","@build_context parent  entities [] ","@build_context add_element  entities [] ","@build_CData  new ontext entities [] ","@build_Comment  new ontext entities [] ","@build_conteXMLDecl  new t entities ","@build_coNotationDecl  new text eNotationDecl  new tities ","@build_coElementDecl  new text eElementDecl  new tities ","@build_coExternalEntity  new text eExternalEntity  new tities ","@build_coAttlistDecl  new text eAttlistDecl  new tities ","@build_context parent  entities ","@build_context add_element  entities ","@build_CData  new ontext entities ","@build_Comment  new ontext entities ","eNotationDecl  new tities each ","eElementDecl  new tities each ","eExternalEntity  new tities each ","eAttlistDecl  new tities each ","entities eaCData  new h ","entities eaComment  new h ","INotationDecl  new structioNotationDecl  new   NotationDecl  new ew ","IElementDecl  new structioElementDecl  new   ElementDecl  new ew ","IExternalEntity  new structioExternalEntity  new   ExternalEntity  new ew ","IAttlistDecl  new structioAttlistDecl  new   AttlistDecl  new ew ","InstruCData  new tion  new ","InstruComment  new tion  new ","CData  NotationDecl  new ew ","CData  ElementDecl  new ew ","CData  ExternalEntity  new ew ","CData  AttlistDecl  new ew ","CommeNotationDecl  new t  NotationDecl  new ew ","CommeElementDecl  new t  ElementDecl  new ew ","CommeExternalEntity  new t  ExternalEntity  new ew ","CommeAttlistDecl  new t  AttlistDecl  new ew ","TeXMLDecl  new t  new ","Text  NotationDecl  new ew ","Text  ElementDecl  new ew ","Text  ExternalEntity  new ew ","Text  AttlistDecl  new ew ","@build_conteXMLDecl  new t whitespace ","@build_coNotationDecl  new text whitespace ","@build_coElementDecl  new text whitespace ","@build_coExternalEntity  new text whitespace ","@build_coAttlistDecl  new text whitespace ","@build_context parent  whitespace ","@build_context add_element  whitespace ","@build_CData  new ontext whitespaCData  new e ","@build_Comment  new ontext whitespaComment  new e ","eveNotationDecl  new t [] strip size == ","eveElementDecl  new t [] strip size == ","eveExternalEntity  new t [] strip size == ","eveAttlistDecl  new t [] strip size == ","@parser pull  [] strip size == ","eveNotationDecl  new t [] strip size ","eveElementDecl  new t [] strip size ","eveExternalEntity  new t [] strip size ","eveAttlistDecl  new t [] strip size ","@parser pull  [] strip size ","eveNotationDecl  new t [] strip ","eveElementDecl  new t [] strip ","eveExternalEntity  new t [] strip ","eveAttlistDecl  new t [] strip ","@parser pull  [] strip ","@build_conteXMLDecl  new t ignore_whitespace_nodes ","@build_coNotationDecl  new text igNotationDecl  new ore_whitespace_NotationDecl  new odes ","@build_coElementDecl  new text igElementDecl  new ore_whitespace_ElementDecl  new odes ","@build_coExternalEntity  new text igExternalEntity  new ore_whitespace_ExternalEntity  new odes ","@build_coAttlistDecl  new text igAttlistDecl  new ore_whitespace_AttlistDecl  new odes ","@build_context parent  ignore_whitespace_nodes ","@build_context add_element  ignore_whitespace_nodes ","@build_CData  new ontext ignore_whitespaCData  new e_nodes ","@build_Comment  new ontext ignore_whitespaComment  new e_nodes ","@build_conteXMLDecl  new t [] << ","@build_coNotationDecl  new text [] << ","@build_coElementDecl  new text [] << ","@build_coExternalEntity  new text [] << ","@build_coAttlistDecl  new text [] << ","@build_context parent  [] << ","@build_context add_element  [] << ","@build_CData  new ontext [] << ","@build_Comment  new ontext [] << ","@build_conteXMLDecl  new t [] ","@build_coNotationDecl  new text [] ","@build_coElementDecl  new text [] ","@build_coExternalEntity  new text [] ","@build_coAttlistDecl  new text [] ","@build_context parent  [] ","@build_context add_element  [] ","@build_CData  new ontext [] ","@build_Comment  new ontext [] ","@build_conteXMLDecl  new t [] instance_of? ","@build_coNotationDecl  new text [] iNotationDecl  new staNotationDecl  new ce_of? ","@build_coElementDecl  new text [] iElementDecl  new staElementDecl  new ce_of? ","@build_coExternalEntity  new text [] iExternalEntity  new staExternalEntity  new ce_of? ","@build_coAttlistDecl  new text [] iAttlistDecl  new staAttlistDecl  new ce_of? ","@build_context parent  [] instance_of? ","@build_context add_element  [] instance_of? ","@build_CData  new ontext [] instanCData  new e_of? ","@build_Comment  new ontext [] instanComment  new e_of? ","iNotationDecl  new _doctype ! ","iElementDecl  new _doctype ! ","iExternalEntity  new _doctype ! ","iAttlistDecl  new _doctype ! ","in_DocType  new  ! ","in_doCData  new type ! ","in_doComment  new type ! ","tag_staCData  new k pop ","tag_staComment  new k pop ","Attribute  NotationDecl  new ew ","Attribute  ElementDecl  new ew ","Attribute  ExternalEntity  new ew ","Attribute  AttlistDecl  new ew ","eveNotationDecl  new t [] each ","eveElementDecl  new t [] each ","eveExternalEntity  new t [] each ","eveAttlistDecl  new t [] each ","event [] eaCData  new h ","event [] eaComment  new h ","@parser pull  [] each ","@build_conteXMLDecl  new t add_element ","@build_coNotationDecl  new text add_elemeNotationDecl  new t ","@build_coElementDecl  new text add_elemeElementDecl  new t ","@build_coExternalEntity  new text add_elemeExternalEntity  new t ","@build_coAttlistDecl  new text add_elemeAttlistDecl  new t ","@build_context parent  add_element ","@build_context add_element  add_element ","@build_CData  new ontext add_element ","@build_Comment  new ontext add_element ","tag_staCData  new k push ","tag_staComment  new k push ","@build_conteXMLDecl  new t XMLDecl  new path ","@build_coNotationDecl  new text xpath ","@build_coElementDecl  new text xpath ","@build_coExternalEntity  new text xpath ","@build_coAttlistDecl  new text xpath ","@build_context parent  xpath ","@build_context add_element  xpath ","@build_CData  new ontext xpath ","@build_Comment  new ontext xpath ","tag_staCData  new k empty? ","tag_staComment  new k empty? "]}," REXML Parsers TreeParser add_listener":{"type":"method","name":"add_listener","children":[],"call":["@parser add_listener "]}," REXML Parsers TreeParser initialize":{"type":"method","name":"initialize","children":[],"call":["Parsers BaseParser  new "]}," REXML Parsers StreamParser parse":{"type":"method","name":"parse","children":[],"call":["@listener entity ","entity_reference gsub ","event [] ","@listener send ","event [] to_s ","@listener doctype_end ","@listener respond_to? ","@listener doctype ","@listener instruction ","@listener text ","@parser unnormalize ","@tag_stack pop ","@listener tag_end ","@listener tag_start ","event [] []= ","event [] each ","@tag_stack << "," raise ","ParseException  new ","@parser source ","/ + ","@tag_stack join ","@tag_stack empty? ","@parser pull ","event []  gsub ","@parser pull  [] ","@parser pull  [] to_s ","@parser pull  [] []= ","@parser pull  [] each "]}," REXML Parsers StreamParser add_listener":{"type":"method","name":"add_listener","children":[],"call":["@parser add_listener "]}," REXML Parsers StreamParser initialize":{"type":"method","name":"initialize","children":[],"call":["BaseParser  new "]}," REXML Parsers SAX2Parser get_namespace":{"type":"method","name":"get_namespace","children":[],"call":["uris [] [] ","uris [] ","0 == ","uris size ","uris nil? ","ns [] nil? ! ","ns [] nil? ","ns [] ","@namespace_stack find ","@namespace_stack find_all "]}," REXML Parsers SAX2Parser add":{"type":"method","name":"add","children":[],"call":["@listeners << ","@listeners include? ","@procs << ","@procs include? ","pair [] respond_to? ","pair [] "]}," REXML Parsers SAX2Parser get_listeners":{"type":"method","name":"get_listeners","children":[],"call":["x [] ","(send\n  (ivar :@listeners) :find_all) collect ","name =~ ","match kind_of? ","name == ","match nil? ","name nil? ","symbol == ","sym nil? ","@listeners find_all ","@listeners size == ","@listeners size "]}," REXML Parsers SAX2Parser get_procs":{"type":"method","name":"get_procs","children":[],"call":["x [] ","(send\n  (ivar :@procs) :find_all) collect ","name =~ ","match kind_of? ","name == ","match nil? ","name nil? ","symbol == ","sym nil? ","@procs find_all ","@procs size == ","@procs size "]}," REXML Parsers SAX2Parser handle_entitydecl":{"type":"method","name":"handle_entitydecl","children":[],"call":[" handle ","event [] ","event []= ","event pop ","event size == ","event size ","event last == ","event last ","@entities []= "]}," REXML Parsers SAX2Parser handle":{"type":"method","name":"handle","children":[],"call":["l send ","symbol to_s ","listeners each ","ob call ","procs each "," get_listeners "," get_procs ","@tag_stack [] "," get_listeners  each "," get_procs  each "," get_ get_listeners  "," get_ get_procs  ","@@tag_stack [] _stack [] "]}," REXML Parsers SAX2Parser parse":{"type":"method","name":"parse","children":[],"call":[" handle ","@parser position "," handle_entitydecl ","(send nil :Integer\n  (lvar :m)) pack "," Integer ","m [] == ","m [] ","copy gsub! ","@entities [] gsub ","@entities [] ","@entities has_key? "," proc ","event [] clone ","event [] ","ob end_prefix_mapping ","listeners each ","ob call ","procs each ","namespace_mapping each "," get_listeners "," get_procs ","@namespace_stack pop ","ob end_element "," get_namespace ","event [] =~ ","@tag_stack pop ","ob start_element ","ob start_prefix_mapping ","@namespace_stack [] []= ","@namespace_stack [] ","nsdecl each ","@namespace_stack push ","n [] ","nsdecl collect! ","n =~ ","event [] find_all ","event [] []= ","@parser normalize ","event [] each ","@tag_stack push ","context [] ","@parser pull ","block start_document ","sym nil? ","sym == ","@listeners each ","block call ","@procs each ","event [] clone  gsub! ","@parser pull  [] clone ","@parser pull  [] "," get_listeners  each "," get_procs  each ","@namespace_stack pop  each "," get_ get_listeners  "," get_ get_procs  ","@parser pull  [] =~ ","@parser pull  [] find_all ","@parser pull  [] []= ","@parser pull  [] each ","context []  [] ","@ get_listeners  each ","@ get_procs  each "]}," REXML Parsers SAX2Parser deafen":{"type":"method","name":"deafen","children":[],"call":["item [] == ","item [] ","@procs delete_if ","@listeners size == ","@listeners size ","@listeners delete_if "]}," REXML Parsers SAX2Parser listen":{"type":"method","name":"listen","children":[],"call":[" add ","args [] ","args [] each ","args size == ","args size ","args [] kind_of? ","@procs << "]}," REXML Parsers SAX2Parser add_listener":{"type":"method","name":"add_listener","children":[],"call":["@parser add_listener "]}," REXML Parsers SAX2Parser source":{"type":"method","name":"source","children":[],"call":["@parser source "]}," REXML Parsers SAX2Parser initialize":{"type":"method","name":"initialize","children":[],"call":["BaseParser  new "]}," REXML Parsers PullEvent inspect":{"type":"method","name":"inspect","children":[],"call":["@contents [] to_s + + ","@contents [] inspect ","@contents [] ","@contents [] to_s + ","@contents [] to_s "]}," REXML Parsers PullEvent error?":{"type":"method","name":"error?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent xmldecl?":{"type":"method","name":"xmldecl?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent cdata?":{"type":"method","name":"cdata?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent entity?":{"type":"method","name":"entity?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent notationdecl?":{"type":"method","name":"notationdecl?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent entitydecl?":{"type":"method","name":"entitydecl?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent elementdecl?":{"type":"method","name":"elementdecl?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent attlistdecl?":{"type":"method","name":"attlistdecl?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent doctype?":{"type":"method","name":"doctype?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent comment?":{"type":"method","name":"comment?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent instruction?":{"type":"method","name":"instruction?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent text?":{"type":"method","name":"text?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent end_element?":{"type":"method","name":"end_element?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent start_element?":{"type":"method","name":"start_element?","children":[],"call":["@contents [] == ","@contents [] "]}," REXML Parsers PullEvent event_type":{"type":"method","name":"event_type","children":[],"call":["@contents [] "]}," REXML Parsers PullEvent []":{"type":"method","name":"[]","children":[],"call":[" raise ","start class ","start inspect ","@contents slice ","start + ","endd nil? ","start kind_of? ","start end ","start begin + ","start begin "]}," REXML Parsers PullEvent initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Parsers PullParser unshift":{"type":"method","name":"unshift","children":[],"call":["@my_stack unshift "]}," REXML Parsers PullParser pull":{"type":"method","name":"pull","children":[],"call":["PullEvent  new ","event << ","@parser unnormalize ","event [] ","@entities []= ","event [] =~ ","@parser pull ","@my_stack shift ","@my_stack length > ","@my_stack length ","@parser pull  << ","@parser pull  [] ","@parser pull  [] =~ "]}," REXML Parsers PullParser peek":{"type":"method","name":"peek","children":[],"call":["@my_stack [] ","@my_stack push ","PullEvent  new ","@parser pull ","(send\n  (send\n    (lvar :depth) :-\n    (send\n      (ivar :@my_stack) :length)) :+\n  (int 1)) times ","depth - + ","depth - ","@my_stack length ","@my_stack length <= ","PullEvPullEvent  new nt  nPullEvent  new w ","@parsPullEvent  new r pull ","(sPullEvent  new nd\n  (sPullEvent  new nd\n    (lvar :dPullEvent  new pth) :-\n    (sPullEvent  new nd\n      (ivar :@my_stack) :lPullEvent  new ngth)) :+\n  (int 1)) timPullEvent  new s ","dPullEvent  new pth - + ","dPullEvent  new pth - ","@my_stack lPullEvent  new ngth ","@my_stack lPullEvent  new ngth <= "]}," REXML Parsers PullParser each":{"type":"method","name":"each","children":[],"call":[" pull "," has_next? "]}," REXML Parsers PullParser add_listener":{"type":"method","name":"add_listener","children":[],"call":["@listeners << "]}," REXML Parsers PullParser initialize":{"type":"method","name":"initialize","children":[],"call":["BaseParser  new "]}," REXML Parsers LightParser parse":{"type":"method","name":"parse","children":[],"call":["new_node []= ","context << ","context [] ","event [] ","@parser pull ","context []  << ","context []  [] ","@parser pull  [] "]}," REXML Parsers LightParser rewind":{"type":"method","name":"rewind","children":[],"call":["@parser stream= ","@stream rewind "]}," REXML Parsers LightParser add_listener":{"type":"method","name":"add_listener","children":[],"call":["@parser add_listener "]}," REXML Parsers LightParser initialize":{"type":"method","name":"initialize","children":[],"call":["REXML Parsers BaseParser  new "]}," REXML Parsers BaseParser parse_attributes":{"type":"method","name":"parse_attributes","children":[],"call":["attributes []= "," raise ","REXML ParseException  new ","name inspect ","attributes has_key? ","prefixes << ","prefix == ","curr_ns << ","The 'xmlns' prefix must not be declared  + ","local_part == ","The 'xml' prefix must not be bound to any other namespace  + ","value != ","scanner [] ","match_data [] nil? ! ","match_data [] nil? ","match_data [] ","scanner pos= ","scanner << ","@source match ","scanner scan ","Regexp  escape ","scanner rest "," loop ","scanner pos ","scanner eos? ","StringScanner  new ","raw_attributes empty? ","raw_attributes nil? ","match_data nil? ","scanner []  inspect ","scanner [] es << ","scanner []  == ","The 'xmlns' scanner []  must not be declared  + ","The 'xml' scanner []  must not be bound to any other namespace  + ","The 'xml' prefix must not be bound to any other scanner [] space  + ","scanner []  != ","StringScanner  new  [] ","@source match  [] nil? ! ","@source match  [] nil? ","@source match  [] ","scanner scanner pos = ","StringScanner  new  pos= ","StringScanner  new  << ","StringScanner  new  scan ","StringScanner  new  rest ","scanner scanner pos  ","StringScanner  new  pos ","StringScanner  new  eos? ","match_data []  empty? ","match_data []  nil? ","@source match  nil? "]}," REXML Parsers BaseParser process_instruction":{"type":"method","name":"process_instruction","children":[],"call":["match_data [] "," raise ","REXML ParseException  new ","@source match ","@source match  [] "]}," REXML Parsers BaseParser need_source_encoding_update?":{"type":"method","name":"need_source_encoding_update?","children":[],"call":["xml_declaration_encoding nil? "]}," REXML Parsers BaseParser unnormalize":{"type":"method","name":"unnormalize","children":[],"call":["rv gsub! ","er [] ","DEFAULT_ENTITIES  [] "," entity ","filter include? ","matches each ","matches size > ","matches size ","(send\n  (lvar :matches) :collect!) compact! ","x [] ","matches collect! ","(send nil :Integer\n  (lvar :m)) pack "," Integer ","m [] == ","m [] ","matches size == ","rv scan ","string clone ","string clone  gsub! ","DEFAULT_ENTITIES  []  [] ","filtDEFAULT_ENTITIES  []  include? ","rv scan  each ","rv scan  size > ","rv scan  size ","(send\n  (lvar :rv scan ) :collect!) compact! ","rv scan  collect! ","(send nil :IntegDEFAULT_ENTITIES  [] \n  (lvar :m)) pack "," IntegDEFAULT_ENTITIES  []  ","rv scan  size == ","string clone  scan "]}," REXML Parsers BaseParser normalize":{"type":"method","name":"normalize","children":[],"call":["copy gsub! ","value [] ","DEFAULT_ENTITIES  each ","entity_filter include? "," entity ","entities each ","input clone ","input clone  gsub! "]}," REXML Parsers BaseParser entity":{"type":"method","name":"entity","children":[],"call":[" unnormalize ","value [] ","DEFAULT_ENTITIES  [] ","value ! ","entities [] ","value []  [] ","DEFAULT_ENTITIES  []  [] ","entities []  [] ","value []  ! ","DEFAULT_ENTITIES  []  ! ","entities []  ! "]}," REXML Parsers BaseParser pull_event":{"type":"method","name":"pull_event","children":[],"call":[" raise ","REXML ParseException  new ","md [] ","@source match ","md [] length == ","md [] length ","@tags push ","@nsstack shift ","UndefinedNamespaceException  new ","k member? ","@nsstack find "," parse_attributes ","@nsstack unshift ","Set  new ","prefixes << "," process_instruction ","@source buffer [] == ","@source buffer [] ","@source buffer ","Declarations can only occur  + ","md [] [] == ","md [] [] ","message << ","last_tag != ","md nil? ","@tags pop ","@nsstack [] << ","@nsstack [] ","attdef [] =~ ","attdef [] ","pairs []= ","val == ","attdef compact! ","attdef [] == ","values each ","md [] scan ","match << ","match pop ","match size == ","match size ","match []= ","match [] [] ","match [] ","match delete_at ","match size > ","match [] == ","@source match to_a compact ","@source match to_a ","@source match [] ","@document_status == ","@source buffer force_encoding ","@source encoding == ","@source encoding ","@source read ","@source buffer size < ","@source buffer size ","@stack << ","close == ","6 strip ","6 nil? ","4 strip ","4 nil? ","2 strip ","2 nil? ","name nil? ","identity =~ ","standalone [] ","standalone nil? ","STANDALONE  match ","encoding nil? ","@source encoding= "," need_source_encoding_update? ","encoding [] ","ENCODING  match ","version [] ","version nil? ","VERSION  match ","word [] ","word nil? ","@stack shift ","@stack size > ","@stack size "," empty? "," parse_id "," parse_name ","id [] ","id []= ","id [] == ","last_tag ! ","@source match  [] ","@source @source match to_a compact  ","@source @source match []  ","@source match  [] length == ","@source match  [] length ","Set  new  << ","@source match  [] [] == ","@source match  [] [] ","@tags pop  != ","@source match  nil? ","attdef []  == ","attdef [] ues each ","md [] scan  each ","@source match  [] scan ","@source match to_a compact  << ","@source match []  << ","@source match to_a compact  pop ","@source match []  pop ","@source match to_a compact  size == ","@source match []  size == ","@source match to_a compact  size ","@source match []  size ","@source match to_a compact  []= ","@source match []  []= ","@source match to_a compact  [] [] ","@source match []  [] [] ","@source match to_a compact  [] ","@source match []  [] ","@source match to_a compact  delete_at ","@source match []  delete_at ","@source match to_a compact  size > ","@source match []  size > ","@source match to_a compact  [] == ","@source match []  [] == ","@source @source match to_a compact  to_a compact ","@source @source match []  to_a compact ","@source @source match to_a compact  to_a ","@source @source match []  to_a ","@source @source match to_a compact  [] ","@source @source match []  [] ","@source buffer force_encoding []  ","@source buffer force_ENCODING  match  ","@source encoding []  == ","@source ENCODING  match  == ","@source encoding []  ","@source ENCODING  match  ","md []  == "," parse_name  nil? ","md []  =~ "," parse_id entity =~ ","standalone []  [] ","STANDALONE  match  [] ","standalone []  nil? ","STANDALONE  match  nil? ","STANDALONE  @source match to_a compact  ","STANDALONE  @source match []  ","encoding []  nil? ","ENCODING  match  nil? ","@source encoding [] = ","@source ENCODING  match = "," need_source_encoding [] _update? "," need_source_ENCODING  match _update? ","encoding []  [] ","ENCODING  match  [] ","ENCODING  @source match to_a compact  ","ENCODING  @source match []  ","version []  [] ","VERSION  match  [] ","version []  nil? ","VERSION  match  nil? ","VERSION  @source match to_a compact  ","VERSION  @source match []  ","word []  [] ","word []  nil? "," parse_ parse_id  "," parse_ parse_name  "," parse_id  [] "," parse_id  []= "," parse_id  [] == ","@tags pop  ! "]}," REXML Parsers BaseParser pull":{"type":"method","name":"pull","children":[],"call":["listener receive ","@listeners each "," pull_event tap "," pull_event "]}," REXML Parsers BaseParser peek":{"type":"method","name":"peek","children":[],"call":["@stack [] ","temp size > ","temp size ","temp push "," pull ","@stack size + < ","depth + ","@stack size + ","@stack size "," empty? ","depth == "," raise ","depth < "]}," REXML Parsers BaseParser unshift":{"type":"method","name":"unshift","children":[],"call":["@stack unshift "]}," REXML Parsers BaseParser has_next?":{"type":"method","name":"has_next?","children":[],"call":["(and\n  (send\n    (ivar :@source) :empty?)\n  (send\n    (ivar :@stack) :empty?)) ! ","@stack empty? ","@source empty? "]}," REXML Parsers BaseParser empty?":{"type":"method","name":"empty?","children":[],"call":["@stack empty? ","@source empty? "]}," REXML Parsers BaseParser position":{"type":"method","name":"position","children":[],"call":["@source position ","@source respond_to? "]}," REXML Parsers BaseParser stream=":{"type":"method","name":"stream=","children":[],"call":["SourceFactory  create_from "]}," REXML Parsers BaseParser add_listener":{"type":"method","name":"add_listener","children":[],"call":["@listeners << "]}," REXML Parsers BaseParser initialize":{"type":"method","name":"initialize","children":[],"call":[" stream= "]}," REXML ParseException context":{"type":"method","name":"context","children":[],"call":["@source current_line "]}," REXML ParseException line":{"type":"method","name":"line","children":[],"call":["@source current_line [] ","@source current_line "]}," REXML ParseException position":{"type":"method","name":"position","children":[],"call":["@source current_line [] ","@source current_line "]}," REXML ParseException to_s":{"type":"method","name":"to_s","children":[],"call":["err << ","@source buffer [] force_encoding gsub ","@source buffer [] force_encoding ","@source buffer [] ","@source buffer "," position "," line ","@continued_exception backtrace join ","@continued_exception backtrace ","@continued_exception inspect ","@continued_exception inspect  << "]}," REXML ParseException initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Parent parent?":{"type":"method","name":"parent?","children":[],"call":[]}," REXML Parent deep_clone":{"type":"method","name":"deep_clone","children":[],"call":["cl << ","child clone ","child deep_clone ","child kind_of? "," each "," clone "," clone  << ","child  clone one ","child deep_ clone one ","  clone one "]}," REXML Parent replace_child":{"type":"method","name":"replace_child","children":[],"call":["replacement parent= ","to_replace parent= ","c equal? ","@children map! "]}," REXML Parent size":{"type":"method","name":"size","children":[],"call":["@children size "]}," REXML Parent index":{"type":"method","name":"index","children":[],"call":["i hash == ","child hash ","i hash ","@children find "]}," REXML Parent to_a":{"type":"method","name":"to_a","children":[],"call":["@children dup "]}," REXML Parent insert_after":{"type":"method","name":"insert_after","children":[],"call":["child2 parent= ","@children []= ","child2 parent delete ","child2 parent "," index + "," index ","child1 parent insert_after ","child1 parent ","XPath  first ","child1 kind_of? ","  index + ex + ","  index + ex ","XPath  first  parent insert_after ","XPath  first  parent ","child1 k index + _of? ","XPath  first  kind_of? "]}," REXML Parent insert_before":{"type":"method","name":"insert_before","children":[],"call":["child2 parent= ","@children []= ","child2 parent delete ","child2 parent "," index ","child1 parent insert_before ","child1 parent ","XPath  first ","child1 kind_of? ","  index ex ","XPath  first  parent insert_before ","XPath  first  parent ","child1 k index _of? ","XPath  first  kind_of? "]}," REXML Parent []=":{"type":"method","name":"[]=","children":[],"call":["@children []= ","args [] ","args [] parent= "]}," REXML Parent []":{"type":"method","name":"[]","children":[],"call":["@children [] "]}," REXML Parent each_index":{"type":"method","name":"each_index","children":[],"call":["@children each_index "]}," REXML Parent delete_at":{"type":"method","name":"delete_at","children":[],"call":["@children delete_at "]}," REXML Parent delete_if":{"type":"method","name":"delete_if","children":[],"call":["@children delete_if "]}," REXML Parent each":{"type":"method","name":"each","children":[],"call":["@children each "]}," REXML Parent delete":{"type":"method","name":"delete","children":[],"call":["object parent= ","c equal? ","@children delete_if "]}," REXML Parent unshift":{"type":"method","name":"unshift","children":[],"call":["@children unshift ","object parent= "]}," REXML Parent add":{"type":"method","name":"add","children":[],"call":["@children << ","object parent= "]}," REXML Parent initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Output to_s":{"type":"method","name":"to_s","children":[],"call":[" encoding "]}," REXML Output <<":{"type":"method","name":"<<","children":[],"call":["@output << "," encode "]}," REXML Output initialize":{"type":"method","name":"initialize","children":[],"call":[" encoding= ","@output << "," encode "," encoding == "," encoding "," encoding != "]}," REXML Node index_in_parent":{"type":"method","name":"index_in_parent","children":[],"call":[" parent index + "," parent index "," parent "]}," REXML Node find_first_recursive":{"type":"method","name":"find_first_recursive","children":[],"call":["block call "," each_recursive "]}," REXML Node each_recursive":{"type":"method","name":"each_recursive","children":[],"call":["node each_recursive ","block call "," elements each "," elements "]}," REXML Node parent?":{"type":"method","name":"parent?","children":[],"call":[]}," REXML Node indent":{"type":"method","name":"indent","children":[],"call":["to << ","indentstyle * ","ind < ","@parent context [] ","@parent context ","@parent context [] nil? ! ","@parent context [] nil? ","@parent context []  * "]}," REXML Node to_s":{"type":"method","name":"to_s","children":[],"call":["f write ","REXML Formatters Pretty  new ","Kernel  warn "," class name "," class ","REXML Formatters Default  new ","indent nil? ","REXML Formatters Pretty  new  write ","REXML Formatters Default  new  write ","REXML Formatters DeREXML Formatters Pretty  new ault  new ","REXML Formatters DeREXML Formatters Default  new ault  new "]}," REXML Node previous_sibling_node":{"type":"method","name":"previous_sibling_node","children":[],"call":["@parent [] ","ind - ","ind == ","@parent index ","@parent nil? ","@parent index  - ","@parent index  == ","@parent @parent index ex "]}," REXML Node next_sibling_node":{"type":"method","name":"next_sibling_node","children":[],"call":["@parent [] ","@parent index + ","@parent index ","@parent nil? "]}," REXML Namespace fully_expanded_name":{"type":"method","name":"fully_expanded_name","children":[],"call":["ns size > ","ns size "," prefix "," prefix  size > "," prefix  size "]}," REXML Namespace has_name?":{"type":"method","name":"has_name?","children":[],"call":[" name == "," name "," fully_expanded_name == "," fully_expanded_name ","other include? "," namespace == "," namespace "]}," REXML Namespace name=":{"type":"method","name":"name=","children":[],"call":["name =~ "," raise ","name inspect ","name == ","name match? "]}," REXML Light Node prefix_of":{"type":"method","name":"prefix_of","children":[],"call":[" prefix_of ","node parent ","v == "," at find "," at ","name =~ ","node name ","namespace ! ","node name  =~ ","node node name  ","node name space ! "]}," REXML Light Node namespace_of":{"type":"method","name":"namespace_of","children":[],"call":[" namespace_of ","@node [] "," at [] "," at ","prefix nil? ! ","prefix nil? ","name =~ ","prefix ! ","  at space_of "," at  =~ "]}," REXML Light Node namesplit":{"type":"method","name":"namesplit","children":[],"call":[" at =~ "," at ","@name defined? "]}," REXML Light Node to_s":{"type":"method","name":"to_s","children":[],"call":[]}," REXML Light Node parent":{"type":"method","name":"parent","children":[],"call":[" at "]}," REXML Light Node children":{"type":"method","name":"children","children":[],"call":[]}," REXML Light Node has_name?":{"type":"method","name":"has_name?","children":[],"call":[" namespace == "," namespace "," at == "," at "]}," REXML Light Node root":{"type":"method","name":"root","children":[],"call":["context at ","context at  at "]}," REXML Light Node text=":{"type":"method","name":"text=","children":[],"call":[" _old_put "," normalizefoo "," at kind_of? "," at "]}," REXML Light Node node_type":{"type":"method","name":"node_type","children":[],"call":[" _old_get "]}," REXML Light Node <<":{"type":"method","name":"<<","children":[],"call":[" at "," push ","newnode parent= ","Node  new "," at << "," node_type == "," node_type ","Node  new  parent= "]}," REXML Light Node []=":{"type":"method","name":"[]=","children":[],"call":[" _old_put ","4 + ","Range  new ","reference exclude_end? ","reference end ","3 + ","reference begin ","reference kind_of? "," at []= "," at "]}," REXML Light Node =~":{"type":"method","name":"=~","children":[],"call":["XPath  match "]}," REXML Light Node []":{"type":"method","name":"[]","children":[],"call":[" _old_get ","4 + ","Range  new ","reference exclude_end? ","reference end ","reference begin ","reference kind_of? "," at [] "," at "," prefix "]}," REXML Light Node namespace=":{"type":"method","name":"namespace=","children":[],"call":[" _old_put ","@prefix size > ","@prefix size "," prefix "," prefix  size > "," prefix  size "]}," REXML Light Node namespace":{"type":"method","name":"namespace","children":[],"call":[" namespace_of "]}," REXML Light Node prefix":{"type":"method","name":"prefix","children":[],"call":[" prefix_of "]}," REXML Light Node local_name=":{"type":"method","name":"local_name=","children":[],"call":[" _old_put "]}," REXML Light Node local_name":{"type":"method","name":"local_name","children":[],"call":[" namesplit "]}," REXML Light Node parent=":{"type":"method","name":"parent=","children":[],"call":[" _old_put "]}," REXML Light Node name=":{"type":"method","name":"name=","children":[],"call":[" _old_put "," prefix "]}," REXML Light Node name":{"type":"method","name":"name","children":[],"call":[" at "]}," REXML Light Node each":{"type":"method","name":"each","children":[],"call":[" at ","x + "," size times "," size "]}," REXML Light Node size":{"type":"method","name":"size","children":[],"call":["@node [] size ","@node [] ","PARENTS  include? "]}," REXML Light Node initialize":{"type":"method","name":"initialize","children":[],"call":["node []= ","node [] == ","node [] ","node nil? ","node kind_of? "]}," REXML Instruction inspect":{"type":"method","name":"inspect","children":[],"call":[" target "]}," REXML Instruction node_type":{"type":"method","name":"node_type","children":[],"call":[]}," REXML Instruction ==":{"type":"method","name":"==","children":[],"call":["other content == ","other content ","other target == ","other target ","other kind_of? "]}," REXML Instruction write":{"type":"method","name":"write","children":[],"call":["writer << ","STOP  sub ","START  sub "," indent ","Kernel  warn "," class name "," class "]}," REXML Instruction clone":{"type":"method","name":"clone","children":[],"call":["Instruction  new "]}," REXML Instruction initialize":{"type":"method","name":"initialize","children":[],"call":["@content strip! ","target content ","target target ","target kind_of? "," raise ","message << ","target inspect ","target content  strip! "]}," REXML Functions send":{"type":"method","name":"send","children":[],"call":[]}," REXML Functions processing_instruction":{"type":"method","name":"processing_instruction","children":[],"call":[]}," REXML Functions round":{"type":"method","name":"round","children":[],"call":[]}," REXML Functions ceiling":{"type":"method","name":"ceiling","children":[],"call":[]}," REXML Functions floor":{"type":"method","name":"floor","children":[],"call":[]}," REXML Functions sum":{"type":"method","name":"sum","children":[],"call":[]}," REXML Functions number":{"type":"method","name":"number","children":[],"call":["@@context [] "]}," REXML Functions compare_language":{"type":"method","name":"compare_language","children":[],"call":[]}," REXML Functions lang":{"type":"method","name":"lang","children":[],"call":[]}," REXML Functions false":{"type":"method","name":"false","children":[],"call":[]}," REXML Functions true":{"type":"method","name":"true","children":[],"call":[]}," REXML Functions not":{"type":"method","name":"not","children":[],"call":[]}," REXML Functions boolean":{"type":"method","name":"boolean","children":[],"call":["@@context [] "]}," REXML Functions translate":{"type":"method","name":"translate","children":[],"call":[]}," REXML Functions normalize_space":{"type":"method","name":"normalize_space","children":[],"call":[]}," REXML Functions string_length":{"type":"method","name":"string_length","children":[],"call":[]}," REXML Functions substring":{"type":"method","name":"substring","children":[],"call":[]}," REXML Functions substring_after":{"type":"method","name":"substring_after","children":[],"call":[]}," REXML Functions substring_before":{"type":"method","name":"substring_before","children":[],"call":[]}," REXML Functions contains":{"type":"method","name":"contains","children":[],"call":[]}," REXML Functions starts_with":{"type":"method","name":"starts_with","children":[],"call":[]}," REXML Functions concat":{"type":"method","name":"concat","children":[],"call":[]}," REXML Functions string_value":{"type":"method","name":"string_value","children":[],"call":[]}," REXML Functions string":{"type":"method","name":"string","children":[],"call":["@@context [] "]}," REXML Functions get_namespace":{"type":"method","name":"get_namespace","children":[],"call":[]}," REXML Functions name":{"type":"method","name":"name","children":[],"call":[]}," REXML Functions namespace_uri":{"type":"method","name":"namespace_uri","children":[],"call":[]}," REXML Functions local_name":{"type":"method","name":"local_name","children":[],"call":[]}," REXML Functions id":{"type":"method","name":"id","children":[],"call":[]}," REXML Functions count":{"type":"method","name":"count","children":[],"call":[]}," REXML Functions position":{"type":"method","name":"position","children":[],"call":[]}," REXML Functions last":{"type":"method","name":"last","children":[],"call":[]}," REXML Functions text":{"type":"method","name":"text","children":[],"call":[]}," REXML Functions context=":{"type":"method","name":"context=","children":[],"call":[]}," REXML Functions variables":{"type":"method","name":"variables","children":[],"call":[]}," REXML Functions namespace_context":{"type":"method","name":"namespace_context","children":[],"call":[]}," REXML Functions variables=":{"type":"method","name":"variables=","children":[],"call":[]}," REXML Functions namespace_context=":{"type":"method","name":"namespace_context=","children":[],"call":[]}," REXML Functions singleton_method_added":{"type":"method","name":"singleton_method_added","children":[],"call":["@@available_functions []= ","INTERNAL_METHODS  include? "]}," REXML Formatters Transitive write_text":{"type":"method","name":"write_text","children":[],"call":["output << ","node to_s "]}," REXML Formatters Transitive write_element":{"type":"method","name":"write_element","children":[],"call":["output << ","  * ","node expanded_name "," write ","node children each ","node children ","node children empty? ","attr write ","node attributes each_attribute ","node attributes ","node attributes empty? "]}," REXML Formatters Transitive initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Formatters Pretty wrap":{"type":"method","name":"wrap","children":[],"call":["parts join ","parts << ","string [] ","place + ","string rindex ","string length > ","string length ","string []  [] ","string rindex  + ","string []  rindex ","string []  length > ","string []  length "]}," REXML Formatters Pretty indent_text":{"type":"method","name":"indent_text","children":[],"call":["string gsub ","style * ","level < "]}," REXML Formatters Pretty write_document":{"type":"method","name":"write_document","children":[],"call":[" write ","output << ","node children [] writethis ! ","node children [] writethis ","node children [] ","node children ","child == ","child instance_of? ","node children each "]}," REXML Formatters Pretty write_cdata":{"type":"method","name":"write_cdata","children":[],"call":["output << ","  * "]}," REXML Formatters Pretty write_comment":{"type":"method","name":"write_comment","children":[],"call":["output << ","  * "]}," REXML Formatters Pretty write_text":{"type":"method","name":"write_text","children":[],"call":["output << ","  * + ","  * "," indent_text "," wrap ","@width - ","s squeeze! ","s gsub! ","node to_s "," indent_text   indent_text queeze! "," wrap   wrap queeze! ","node to_s  node to_s queeze! "," indent_text  g indent_text ub! "," wrap  g wrap ub! ","node to_s  gnode to_s ub! ","node to_ indent_text  ","node to_ wrap  ","node to_node to_s  "]}," REXML Formatters Pretty write_element":{"type":"method","name":"write_element","children":[],"call":["output << ","node expanded_name ","  * "," write ","child to_s strip length == ","child to_s strip length ","child to_s strip ","child to_s ","child kind_of? ","node children each ","node children ","string length < ","string length ","s & ","c kind_of? ","node children inject "," compact ","node children empty? ","attr write ","node attributes each_attribute ","node attributes ","node attributes empty? "," +@ "," +@  length < "," +@  length "]}," REXML Formatters Pretty initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Formatters Default write_instruction":{"type":"method","name":"write_instruction","children":[],"call":["output << ","Instruction STOP  sub ","node content ","node target ","Instruction START  sub ","node node content  "]}," REXML Formatters Default write_cdata":{"type":"method","name":"write_cdata","children":[],"call":["output << ","node to_s "]}," REXML Formatters Default write_comment":{"type":"method","name":"write_comment","children":[],"call":["output << ","node to_s "]}," REXML Formatters Default write_text":{"type":"method","name":"write_text","children":[],"call":["output << ","node to_s "]}," REXML Formatters Default write_element":{"type":"method","name":"write_element","children":[],"call":["output << ","node expanded_name "," write ","node children each ","node children ","node children empty? ","attr write ","(send\n  (send\n    (block\n      (send\n        (send\n          (send\n            (lvar :node) :attributes) :to_a) :map)\n      (args\n        (arg :a))\n      (if\n        (send\n          (const nil :Hash) :===\n          (lvar :a))\n        (send\n          (lvar :a) :values)\n        (lvar :a))) :flatten) :sort_by) each ","attr name ","(send\n  (send\n    (send\n      (lvar :node) :attributes) :to_a) :map) flatten sort_by ","(send\n  (send\n    (send\n      (lvar :node) :attributes) :to_a) :map) flatten ","a values ","Hash  === ","node attributes to_a map ","node attributes to_a ","node attributes ","node attributes empty? "]}," REXML Formatters Default write_document":{"type":"method","name":"write_document","children":[],"call":[" write ","node children each ","node children "]}," REXML Formatters Default write":{"type":"method","name":"write","children":[],"call":[" raise ","Exception  new "," write_text "," write_cdata "," write_comment ","node write "," write_instruction "," write_element "," write_document ","Output  new ","node xml_decl encoding ","node xml_decl ","output kind_of? ! ","output kind_of? ","node xml_decl encoding != ","Output  new  kind_of? ! ","Output  new  kind_of? "]}," REXML Formatters Default initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Entity value":{"type":"method","name":"value","children":[],"call":["rv gsub! ","entity_reference join ","entity_value bytesize "," raise ","sum + > ","Security  entity_expansion_text_limit ","sum + ","@parent entity ","entity_reference [] ","matches each ","@value clone ","@value scan "," resolve_value ","@value clone  gsub! ","@parent entity  bytesize ","@value scan  each "]}," REXML Entity to_s":{"type":"method","name":"to_s","children":[],"call":[" write "]}," REXML Entity write":{"type":"method","name":"write","children":[],"call":["out << ","out << << << ","out << << ","@value include? ","@ref include? ","out << << << << ","@pubid include? "]}," REXML Entity normalized":{"type":"method","name":"normalized","children":[],"call":[]}," REXML Entity unnormalized":{"type":"method","name":"unnormalized","children":[],"call":["Text  unnormalize "," parent ","v nil? "," value "," document record_entity_expansion "," document "," document nil? "," value  nil? ","  value alue "]}," REXML Entity matches?":{"type":"method","name":"matches?","children":[],"call":[]}," REXML Entity initialize":{"type":"method","name":"initialize","children":[],"call":["stream [] ","stream size == ","stream size ","@external == ","stream [] =~ ","stream pop ","stream [] == ","stream kind_of? ","stream []  == "]}," REXML Encoding find_encoding":{"type":"method","name":"find_encoding","children":[],"call":[" Encoding Converter  search_convpath "]}," REXML Encoding decode":{"type":"method","name":"decode","children":[],"call":["string encode "]}," REXML Encoding encode":{"type":"method","name":"encode","children":[],"call":["string encode "]}," REXML Encoding encoding=":{"type":"method","name":"encoding=","children":[],"call":["encoding upcase ","encoding == "," raise "," find_encoding ","encoding is_a? ","encoding name "," find_encoding  upcase ","encoding name  upcase "," find_encoding  == ","encoding name  == "," find_ find_encoding  "," find_encoding name  "," find_encoding  is_a? ","encoding name  is_a? "," find_encoding  name ","encoding name  name "]}," REXML Attributes get_attribute_ns":{"type":"method","name":"get_attribute_ns","children":[],"call":["attribute fully_expanded_name index ! ","attribute fully_expanded_name index ","attribute fully_expanded_name ","namespace empty? ! ","namespace empty? ","result ! ","namespace == ","attribute namespace ","name == ","attribute name "," each_attribute "]}," REXML Attributes delete_all":{"type":"method","name":"delete_all","children":[],"call":["attr remove ","rv each ","rv << ","attribute expanded_name == ","attribute expanded_name "," each_attribute "]}," REXML Attributes add":{"type":"method","name":"add","children":[],"call":[" []= ","attribute name "]}," REXML Attributes delete":{"type":"method","name":"delete","children":[],"call":["old nil? "," store ","old each_value ","old size == ","old size ","old delete ","old kind_of? "," fetch ","attribute =~ ","attribute prefix ","attribute name ","attribute kind_of? "," fetch  nil? "," fetch  each_value "," fetch  size == "," fetch  size "," fetch  delete "," fetch  kind_of? ","attribute attribute prefix  ","attribute attribute name  "]}," REXML Attributes namespaces":{"type":"method","name":"namespaces","children":[],"call":["namespaces []= ","attribute value ","attribute name ","attribute name == ","attribute prefix == ","attribute prefix ","@element document doctype attributes_of each ","@element document doctype attributes_of ","@element document doctype ","@element document ","@element document doctype name ","expn size == ","expn size ","@element expanded_name "," each_attribute ","@element document doctype name  size == ","@element expanded_name  size == ","@element document doctype name  size ","@element expanded_name  size "]}," REXML Attributes prefixes":{"type":"method","name":"prefixes","children":[],"call":["ns << ","attribute name ","attribute prefix == ","attribute prefix ","@element document doctype attributes_of each ","@element document doctype attributes_of ","@element document doctype ","@element document ","@element document doctype name ","expn size == ","expn size ","@element expanded_name "," each_attribute ","@element document doctype name  size == ","@element expanded_name  size == ","@element document doctype name  size ","@element expanded_name  size "]}," REXML Attributes []=":{"type":"method","name":"[]=","children":[],"call":[" store ","value name ","value prefix ","old_attr prefix "," raise ","ParseException  new ","(str \"Namespace conflict in adding attribute \\\"\") + + + ","@element namespace ","(str \"Namespace conflict in adding attribute \\\"\") + + ","(str \"Namespace conflict in adding attribute \\\"\") + ","@element namespace == ","old_attr prefix != ","value prefix != ","old_attr []= ","old_attr kind_of? ","old_attr nil? "," fetch ","value element= ","Attribute  new ","Text  normalize ","@element document doctype ","@element document ","value kind_of? "," delete "," get_attribute ","value nil? ","old_namespace == ","value namespace ","old_attr namespace ","Attribute  new  name ","Text  normalize  name ","Attribute  new  prefix ","Text  normalize  prefix "," fetch  prefix ","old_ get_attribute  prefix ","(str \"Namespace conflict in adding  get_attribute ibute \\\"\") + + + ","(str \"Namespace conflict in adding  get_attribute ibute \\\"\") + + ","(str \"Namespace conflict in adding  get_attribute ibute \\\"\") + "," fetch  prefix != ","old_ get_attribute  prefix != ","Attribute  new  prefix != ","Text  normalize  prefix != "," fetch  []= ","old_ get_attribute  []= "," fetch  kind_of? ","old_ get_attribute  kind_of? "," fetch  nil? ","old_ get_attribute  nil? ","Attribute  new  element= ","Text  normalize  element= ","Attribute  new  kind_of? ","Text  normalize  kind_of? "," get_ get_attribute ibute ","Attribute  new  nil? ","Text  normalize  nil? ","old_attr namespace  == ","Attribute  new  namespace ","Text  normalize  namespace "," fetch  namespace ","old_ get_attribute  namespace "]}," REXML Attributes get_attribute":{"type":"method","name":"get_attribute","children":[],"call":["attr [] ","@element prefix ","attr kind_of? ","Attribute  new ","element_document doctype attribute_of ","element_document doctype ","element_document doctype name ","expn size == ","expn size ","@element expanded_name ","@element document ","prefix == ","attr prefix ","attr == "," fetch ","name =~ ","name nil? ","attr nil? ","attr []  [] "," fetch  [] ","attr []  kind_of? "," fetch  kind_of? ","element_document doctype attr [] ibute_of ","element_document doctype  fetch ibute_of ","@element document  doctype attribute_of ","@element document  doctype ","@element document  doctype name ","element_document doctype name  size == ","@element expanded_name  size == ","element_document doctype name  size ","@element expanded_name  size ","attr []  prefix "," fetch  prefix ","attr []  == "," fetch  == ","attr []  nil? "," fetch  nil? "]}," REXML Attributes each":{"type":"method","name":"each","children":[],"call":["attr value ","attr expanded_name "," each_attribute "," to_enum "," __method__ "," block_given? "]}," REXML Attributes each_attribute":{"type":"method","name":"each_attribute","children":[],"call":["val each_value ","val kind_of? "," each_value "," to_enum "," __method__ "," block_given? "]}," REXML Attributes length":{"type":"method","name":"length","children":[],"call":[" each_attribute "]}," REXML Attributes to_a":{"type":"method","name":"to_a","children":[],"call":[" enum_for to_a "," enum_for "]}," REXML Attributes []":{"type":"method","name":"[]","children":[],"call":["attr value ","attr nil? "," get_attribute "," get_attribute  value "," get_attribute  nil? "," get_ get_attribute ibute "]}," REXML Attributes initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Elements literalize":{"type":"method","name":"literalize","children":[],"call":["name [] ","name [] == ","name []  [] ","name []  [] == "]}," REXML Elements to_a":{"type":"method","name":"to_a","children":[],"call":["e kind_of? ","rv find_all ","XPath  match ","XPath  match  find_all "]}," REXML Elements size":{"type":"method","name":"size","children":[],"call":["child kind_of? ","@element each "]}," REXML Elements inject":{"type":"method","name":"inject","children":[],"call":["e kind_of? ","initial == ","XPath  each "]}," REXML Elements collect":{"type":"method","name":"collect","children":[],"call":["collection << ","e kind_of? ","XPath  each "]}," REXML Elements each":{"type":"method","name":"each","children":[],"call":["e kind_of? ","XPath  each "]}," REXML Elements add":{"type":"method","name":"add","children":[],"call":["element context= ","@element context ","@element << ","Element  new ","element kind_of? ! ","element kind_of? ","element nil? "]}," REXML Elements delete_all":{"type":"method","name":"delete_all","children":[],"call":["element remove ","@element delete ","rv each ","rv << ","element kind_of? ","XPath  each "]}," REXML Elements delete":{"type":"method","name":"delete","children":[],"call":["el remove "," [] ","@element delete ","element kind_of? "," []  remove ","@ [] ement d [] ete "," [] ement kind_of? "]}," REXML Elements index":{"type":"method","name":"index","children":[],"call":["found == ","child == ","child kind_of? ","@element find "]}," REXML Elements empty?":{"type":"method","name":"empty?","children":[],"call":["(send\n  (ivar :@element) :find) nil? ","child kind_of? ","@element find "]}," REXML Elements []=":{"type":"method","name":"[]=","children":[],"call":["previous replace_with ","@element add ","previous nil? "," [] "," []  replace_with "," []  nil? "]}," REXML Elements []":{"type":"method","name":"[]","children":[],"call":["XPath  first ","(op-asgn\n  (lvasgn :num) :+\n  (int 1)) == ","child has_name? ","name nil? ","child kind_of? ","@element find "," literalize "," raise ","index < ","index kind_of? ","child has_ literalize ? "," literalize  nil? "]}," REXML Elements initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Element each_with_something":{"type":"method","name":"each_with_something","children":[],"call":["num == ","max > ","test call ","@elements each "]}," REXML Element __to_xpath_helper":{"type":"method","name":"__to_xpath_helper","children":[],"call":["rv << ","idx + ","results index ","results length > ","results length ","n expanded_name == ","node expanded_name ","n expanded_name ","n kind_of? ","node parent find_all ","node parent ","node expanded_name clone ","node expanded_name clone  << ","results index  + "]}," REXML Element write":{"type":"method","name":"write","children":[],"call":["formatter write ","REXML Formatters Default  new ","REXML Formatters Pretty  new ","REXML Formatters Transitive  new "," require_relative ","indent > ","Kernel  warn "," class name "," class ","REXML Formatters Default  new  write "]}," REXML Element texts":{"type":"method","name":"texts","children":[],"call":["(send nil :find_all) freeze ","child kind_of? "," find_all "]}," REXML Element instructions":{"type":"method","name":"instructions","children":[],"call":["(send nil :find_all) freeze ","child kind_of? "," find_all "]}," REXML Element comments":{"type":"method","name":"comments","children":[],"call":["(send nil :find_all) freeze ","child kind_of? "," find_all "]}," REXML Element cdatas":{"type":"method","name":"cdatas","children":[],"call":["(send nil :find_all) freeze ","child kind_of? "," find_all "]}," REXML Element delete_attribute":{"type":"method","name":"delete_attribute","children":[],"call":["attr remove ","attr nil? ","@attributes get_attribute ","@attributes get_attribute  remove ","@attributes get_attribute  nil? ","@@attributes get_attribute ibutes get_@attributes get_attribute ibute "]}," REXML Element add_attributes":{"type":"method","name":"add_attributes","children":[],"call":["@attributes []= ","value [] ","hash each ","hash kind_of? ","hash each_pair "]}," REXML Element add_attribute":{"type":"method","name":"add_attribute","children":[],"call":["@attributes []= ","@attributes << ","key kind_of? "]}," REXML Element has_attributes?":{"type":"method","name":"has_attributes?","children":[],"call":["@attributes empty? ! ","@attributes empty? "]}," REXML Element attribute":{"type":"method","name":"attribute","children":[],"call":[" attributes get_attribute "," attributes "," namespaces [] == "," namespaces [] "," namespaces ","prefix nil? ","ret_val nil? ","prefix + ","prefix == "," namespaces index "," namespaces key "," namespaces respond_to? "," namespaces index  nil? "," namespaces key  nil? "," attributes get_attribute  nil? "," namespaces index  + "," namespaces key  + "," namespaces index  == "," namespaces key  == "]}," REXML Element []":{"type":"method","name":"[]","children":[],"call":[" attributes [] ","name_or_index to_s "," attributes "]}," REXML Element xpath":{"type":"method","name":"xpath","children":[],"call":["path_elements reverse join ","path_elements reverse ","path_elements << "," __to_xpath_helper ","cur parent ","cur parent  parent "]}," REXML Element node_type":{"type":"method","name":"node_type","children":[],"call":[]}," REXML Element add_text":{"type":"method","name":"add_text","children":[],"call":[" << ","text nil? ","Text  new "," raw "," whitespace ","@children [] << ","@children [] ","@children [] kind_of? ","text kind_of? ","Text  new  nil? ","Text  new  kind_of? "]}," REXML Element text=":{"type":"method","name":"text=","children":[],"call":["old_text replace_with "," << ","old_text nil? ","old_text remove ","text nil? "," get_text ","Text  new "," raw "," whitespace ","text to_s ","text kind_of? ! ","text kind_of? ","text nil? ! "," get_text  replace_with ","old_Text  new  replace_with "," get_text  nil? ","old_Text  new  nil? "," get_text  remove ","old_Text  new  remove ","Text  new  nil? "," get_Text  new  ","Text  new  to_s ","Text  new  kind_of? ! ","Text  new  kind_of? ","Text  new  nil? ! "]}," REXML Element get_text":{"type":"method","name":"get_text","children":[],"call":["node kind_of? ","@children find ","element get_text ","element nil? ","@elements [] ","@elements []  get_text ","@elements []  nil? ","@@elements [] s [] "]}," REXML Element text":{"type":"method","name":"text","children":[],"call":["rv value ","rv nil? "," get_text "," get_text  value "," get_text  nil? "]}," REXML Element has_text?":{"type":"method","name":"has_text?","children":[],"call":[" text nil? ! "," text nil? "," text "]}," REXML Element previous_element":{"type":"method","name":"previous_element","children":[],"call":["element previous_sibling ","element kind_of? ","element nil? "," previous_sibling ","element previous_sibling  previous_sibling "," previous_sibling  previous_sibling ","element previous_sibling  kind_of? "," previous_sibling  kind_of? ","element previous_sibling  nil? "," previous_sibling  nil? "]}," REXML Element next_element":{"type":"method","name":"next_element","children":[],"call":["element next_sibling ","element kind_of? ","element nil? "," next_sibling ","element next_sibling  next_sibling "," next_sibling  next_sibling ","element next_sibling  kind_of? "," next_sibling  kind_of? ","element next_sibling  nil? "," next_sibling  nil? "]}," REXML Element get_elements":{"type":"method","name":"get_elements","children":[],"call":["@elements to_a "]}," REXML Element each_element":{"type":"method","name":"each_element","children":[],"call":["@elements each "]}," REXML Element each_element_with_text":{"type":"method","name":"each_element_with_text","children":[],"call":[" each_with_something ","child text == ","child text ","child has_text? ","text nil? "," proc "]}," REXML Element each_element_with_attribute":{"type":"method","name":"each_element_with_attribute","children":[],"call":[" each_with_something ","child attributes [] == ","child attributes [] ","child attributes ","child attributes [] != ","value nil? "," proc "]}," REXML Element has_elements?":{"type":"method","name":"has_elements?","children":[],"call":["@elements empty? ! ","@elements empty? "]}," REXML Element delete_element":{"type":"method","name":"delete_element","children":[],"call":["@elements delete "]}," REXML Element add_element":{"type":"method","name":"add_element","children":[],"call":["el attributes []= ","el attributes ","attrs each ","attrs kind_of? ","@elements add "," raise ","element nil? ","@elements add  attributes []= ","@elements add  attributes ","@@elements add ements add ","@elements add ement nil? "]}," REXML Element delete_namespace":{"type":"method","name":"delete_namespace","children":[],"call":["attribute remove ","attribute nil? "," attributes get_attribute "," attributes ","namespace == "," attributes get_attribute  remove "," attributes get_attribute  nil? ","  attributes get_attribute s get_ attributes get_attribute  ","  attributes get_attribute s "]}," REXML Element add_namespace":{"type":"method","name":"add_namespace","children":[],"call":["@attributes []= ","prefix =~ "]}," REXML Element namespace":{"type":"method","name":"namespace","children":[],"call":["prefix == ","ns nil? "," parent namespace "," parent "," attributes [] "," attributes ","prefix [] == ","prefix [] "," prefix ","prefix nil? "," prefix  == "," parent namespace  nil? "," attributes []  nil? "," prefix  [] == "," prefix  [] ","  prefix  "," prefix  nil? "]}," REXML Element namespaces":{"type":"method","name":"namespaces","children":[],"call":["namespaces merge "," attributes namespaces "," attributes "," parent namespaces "," parent ","namespaces merge  merge "," parent namespaces  merge "," attributes namespaces merge  "," attributes  parent namespaces  "," parent namespaces merge  "," parent  parent namespaces  "]}," REXML Element prefixes":{"type":"method","name":"prefixes","children":[],"call":[" attributes prefixes "," attributes "," parent prefixes "," parent "," attributes  parent prefixes  "," parent  parent prefixes  "]}," REXML Element raw":{"type":"method","name":"raw","children":[],"call":["@context [] include? "," expanded_name ","@context [] ","@context [] == "]}," REXML Element ignore_whitespace_nodes":{"type":"method","name":"ignore_whitespace_nodes","children":[],"call":["@context [] include? "," expanded_name ","@context [] ","@context [] == "]}," REXML Element whitespace":{"type":"method","name":"whitespace","children":[],"call":["@whitespace == ","@context [] include? "," expanded_name ","@context [] ","@context [] == "]}," REXML Element document":{"type":"method","name":"document","children":[],"call":["rt parent "," root "," root  parent "]}," REXML Element root":{"type":"method","name":"root","children":[],"call":[" parent root "," parent "," parent nil? "," parent kind_of? "," elements [] "," elements "," kind_of? "]}," REXML Element root_node":{"type":"method","name":"root_node","children":[],"call":[" parent root_node "," parent "," parent nil? "]}," REXML Element clone":{"type":"method","name":"clone","children":[],"call":[" class new "," class "]}," REXML Element inspect":{"type":"method","name":"inspect","children":[],"call":["rv << "," children size > "," children size "," children ","attr write ","@attributes each_attribute "]}," REXML Element initialize":{"type":"method","name":"initialize","children":[],"call":["arg context ","@attributes << ","Attribute  new ","arg attributes each_attribute ","arg attributes "," name= ","arg expanded_name ","arg kind_of? ","Attributes  new ","Elements  new ","Attributes  new  << "]}," REXML DTD NotationDecl parse_source":{"type":"method","name":"parse_source","children":[],"call":[]}," REXML DTD NotationDecl write":{"type":"method","name":"write","children":[],"call":["output << "," to_s "," indent "]}," REXML DTD NotationDecl to_s":{"type":"method","name":"to_s","children":[],"call":[]}," REXML DTD NotationDecl initialize":{"type":"method","name":"initialize","children":[],"call":["md [] "," raise ","ParseException  new ","src match ","src match  [] "]}," REXML DTD EntityDecl parse_source":{"type":"method","name":"parse_source","children":[],"call":[]}," REXML DTD EntityDecl write":{"type":"method","name":"write","children":[],"call":["output << "," to_s "," indent "]}," REXML DTD EntityDecl to_s":{"type":"method","name":"to_s","children":[],"call":["rv << ","@middle size > ","@middle size "]}," REXML DTD EntityDecl initialize":{"type":"method","name":"initialize","children":[],"call":["md [] "," raise ","ParseException  new ","md nil? ","src match ","src match  [] ","src match  nil? "]}," REXML DTD ElementDecl initialize":{"type":"method","name":"initialize","children":[],"call":["match [] "]}," REXML DTD Parser parse_helper":{"type":"method","name":"parse_helper","children":[],"call":[]}," REXML DTD Parser parse":{"type":"method","name":"parse","children":[],"call":[]}," REXML Document build":{"type":"method","name":"build","children":[],"call":["Parsers TreeParser  new parse ","Parsers TreeParser  new "]}," REXML Document document":{"type":"method","name":"document","children":[],"call":[]}," REXML Document record_entity_expansion":{"type":"method","name":"record_entity_expansion","children":[],"call":[" raise ","@entity_expansion_count > ","Security  entity_expansion_limit "]}," REXML Document entity_expansion_text_limit":{"type":"method","name":"entity_expansion_text_limit","children":[],"call":[]}," REXML Document entity_expansion_text_limit=":{"type":"method","name":"entity_expansion_text_limit=","children":[],"call":[]}," REXML Document entity_expansion_limit":{"type":"method","name":"entity_expansion_limit","children":[],"call":[]}," REXML Document entity_expansion_limit=":{"type":"method","name":"entity_expansion_limit=","children":[],"call":[]}," REXML Document parse_stream":{"type":"method","name":"parse_stream","children":[],"call":[]}," REXML Document write":{"type":"method","name":"write","children":[],"call":["formatter write ","REXML Formatters Default  new ","REXML Formatters Pretty  new ","REXML Formatters Transitive  new "," require_relative ","indent > ","Output  new ","output kind_of? ! ","output kind_of? ","encoding != "," xml_decl encoding "," xml_decl ","ie_hack nil? ","transitive nil? ","options [] ","arguments [] ","arguments [] class == ","arguments [] class ","arguments size == ","arguments size ","REXML Formatters Default  new  write ","options []  > ","Output  new  kind_of? ! ","options []  kind_of? ! ","Output  new  kind_of? ","options []  kind_of? ","options []  != "," xml_decl options []  ","options []  nil? ","arguments []  [] "]}," REXML Document stand_alone?":{"type":"method","name":"stand_alone?","children":[],"call":[" xml_decl stand_alone? "," xml_decl "]}," REXML Document encoding":{"type":"method","name":"encoding","children":[],"call":[" xml_decl encoding "," xml_decl "]}," REXML Document version":{"type":"method","name":"version","children":[],"call":[" xml_decl version "," xml_decl "]}," REXML Document xml_decl":{"type":"method","name":"xml_decl","children":[],"call":["@children unshift [] ","@children unshift ","XMLDecl  default ","rv kind_of? ","@children [] ","@children []  kind_of? "]}," REXML Document doctype":{"type":"method","name":"doctype","children":[],"call":["item kind_of? ","@children find "]}," REXML Document root":{"type":"method","name":"root","children":[],"call":[" elements [] "," elements "]}," REXML Document add_element":{"type":"method","name":"add_element","children":[],"call":[" raise ","@elements size > ","@elements size "]}," REXML Document add":{"type":"method","name":"add","children":[],"call":[" raise ","@elements size > ","@elements size ","child parent= ","@children << ","@children []= ","insert_before_index - ","@children [] kind_of? ","@children [] ","x kind_of? ","@children find_index ","child kind_of? ","@children unshift "]}," REXML Document expanded_name":{"type":"method","name":"expanded_name","children":[],"call":[]}," REXML Document clone":{"type":"method","name":"clone","children":[],"call":["Document  new "]}," REXML Document node_type":{"type":"method","name":"node_type","children":[],"call":[]}," REXML Document initialize":{"type":"method","name":"initialize","children":[],"call":[" build ","source context ","source kind_of? ","source nil? "]}," REXML NotationDecl name":{"type":"method","name":"name","children":[],"call":[]}," REXML NotationDecl write":{"type":"method","name":"write","children":[],"call":["output << "," to_s "]}," REXML NotationDecl to_s":{"type":"method","name":"to_s","children":[],"call":["notation << ","@system inspect ","@public inspect ","c [] == ","c [] "," parent context "," parent ","reference_writer write ","ReferenceWriter  new ","@system inspe parent context t ","@publi parent context  inspe parent context t "," parent context  [] == "," parent context  [] "," parent  parent context ontext "," parent  parent context  ","referen parent context e_writer write ","ReferenceWriter  new  write ","Referen parent context eWriter  new "]}," REXML NotationDecl initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML ExternalEntity write":{"type":"method","name":"write","children":[],"call":["output << "]}," REXML ExternalEntity to_s":{"type":"method","name":"to_s","children":[],"call":[]}," REXML ExternalEntity initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML ElementDecl initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Declaration write":{"type":"method","name":"write","children":[],"call":["output << "," to_s "]}," REXML Declaration to_s":{"type":"method","name":"to_s","children":[],"call":["@string + "]}," REXML Declaration initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML DocType strip_quotes":{"type":"method","name":"strip_quotes","children":[],"call":["quoted_string [] ","quoted_string length - ","quoted_string length ","quoted_string =~ "]}," REXML DocType notation":{"type":"method","name":"notation","children":[],"call":["notation_decl name == ","notation_decl name "," notations find "," notations "]}," REXML DocType notations":{"type":"method","name":"notations","children":[],"call":["node kind_of? "," children select "," children "]}," REXML DocType system":{"type":"method","name":"system","children":[],"call":[" strip_quotes ","@uri kind_of? "]}," REXML DocType public":{"type":"method","name":"public","children":[],"call":[" strip_quotes "]}," REXML DocType add":{"type":"method","name":"add","children":[],"call":["@entities []= ","child name ","child kind_of? ","DEFAULT_ENTITIES  clone ","@entities == ","DEFAULT_ENTITIES  clone  []= ","DEFAULT_ENTITIES  clone  == "]}," REXML DocType entity":{"type":"method","name":"entity","children":[],"call":["@entities [] unnormalized ","@entities [] "]}," REXML DocType context":{"type":"method","name":"context","children":[],"call":["@parent context "]}," REXML DocType write":{"type":"method","name":"write","children":[],"call":["output << ","f write ","@children each ","@children empty? ","@uri inspect ","@long_name inspect "," indent ","REXML Formatters Default  new ","c [] == ","c [] "," context ","reference_writer write ","ReferenceWriter  new ","REXML Formatters Default  new  write ","@ context hildren ea context h ","@ context hildren empty? ","@uri inspe context t ","@long_name inspe context t ","REXML Formatters DeREXML Formatters Default  new ault  new "," context  [] == "," context  [] ","  context ontext ","reREXML Formatters Default  new erence_writer write ","referen context e_writer write ","ReferenceWriter  new  write ","ReREXML Formatters Default  new erenceWriter  new ","Referen context eWriter  new "]}," REXML DocType clone":{"type":"method","name":"clone","children":[],"call":["DocType  new "]}," REXML DocType attribute_of":{"type":"method","name":"attribute_of","children":[],"call":["att_decl [] ","child include? ","child element_name == ","child element_name ","child kind_of? "," find "]}," REXML DocType attributes_of":{"type":"method","name":"attributes_of","children":[],"call":["rv << ","Attribute  new ","child each ","child element_name == ","child element_name ","child kind_of? "," each "]}," REXML DocType node_type":{"type":"method","name":"node_type","children":[],"call":[]}," REXML DocType initialize":{"type":"method","name":"initialize","children":[],"call":["event [] ","event [] == ","parser pull ","Parsers BaseParser  new ","first kind_of? ","first [] ","first external_id ","first name ","first instance_variable_get ","parser pull  [] ","parser pull  [] == ","Parsers BaseParser  new  pull "]}," REXML Comment node_type":{"type":"method","name":"node_type","children":[],"call":[]}," REXML Comment ==":{"type":"method","name":"==","children":[],"call":["(send\n  (lvar :other) :<=>\n  (self)) == ","other <=> ","other kind_of? "]}," REXML Comment <=>":{"type":"method","name":"<=>","children":[],"call":["other to_s <=> ","other to_s "]}," REXML Comment write":{"type":"method","name":"write","children":[],"call":["output << "," indent ","Kernel  warn "]}," REXML Comment clone":{"type":"method","name":"clone","children":[],"call":["Comment  new "]}," REXML Comment initialize":{"type":"method","name":"initialize","children":[],"call":["first string ","first kind_of? "]}," REXML Child bytes":{"type":"method","name":"bytes","children":[],"call":[" to_s "," document encoding "," document "]}," REXML Child document":{"type":"method","name":"document","children":[],"call":[" parent document "," parent "," parent nil? "]}," REXML Child previous_sibling=":{"type":"method","name":"previous_sibling=","children":[],"call":[" parent insert_before "," parent "]}," REXML Child next_sibling=":{"type":"method","name":"next_sibling=","children":[],"call":[" parent insert_after "," parent "]}," REXML Child parent=":{"type":"method","name":"parent=","children":[],"call":["@parent delete ","@parent == "]}," REXML Child remove":{"type":"method","name":"remove","children":[],"call":["@parent delete ","@parent nil? "]}," REXML Child replace_with":{"type":"method","name":"replace_with","children":[],"call":["@parent replace_child "]}," REXML Child initialize":{"type":"method","name":"initialize","children":[],"call":["parent add "]}," REXML CData write":{"type":"method","name":"write","children":[],"call":["output << "," indent ","Kernel  warn "," class name "," class "]}," REXML CData value":{"type":"method","name":"value","children":[],"call":[]}," REXML CData to_s":{"type":"method","name":"to_s","children":[],"call":[]}," REXML CData clone":{"type":"method","name":"clone","children":[],"call":["CData  new "]}," REXML CData initialize":{"type":"method","name":"initialize","children":[],"call":[]}," REXML Attribute xpath":{"type":"method","name":"xpath","children":[],"call":[" expanded_name ","@element xpath ","@element x@element xpath  "]}," REXML Attribute inspect":{"type":"method","name":"inspect","children":[],"call":[" write "," +@ "]}," REXML Attribute node_type":{"type":"method","name":"node_type","children":[],"call":[]}," REXML Attribute write":{"type":"method","name":"write","children":[],"call":["output << "," to_string "]}," REXML Attribute remove":{"type":"method","name":"remove","children":[],"call":["@element attributes delete "," name ","@element attributes ","@element nil? "]}," REXML Attribute element=":{"type":"method","name":"element=","children":[],"call":["Text  check "," doctype "]}," REXML Attribute clone":{"type":"method","name":"clone","children":[],"call":["Attribute  new "]}," REXML Attribute value":{"type":"method","name":"value","children":[],"call":["Text  unnormalize "," doctype "]}," REXML Attribute to_s":{"type":"method","name":"to_s","children":[],"call":["Text  normalize "," doctype "]}," REXML Attribute doctype":{"type":"method","name":"doctype","children":[],"call":["doc doctype ","@element document ","@element document  @element document type ","@element @element document ument "]}," REXML Attribute to_string":{"type":"method","name":"to_string","children":[],"call":[" to_s gsub "," to_s ","@element context [] == ","@element context [] ","@element context ","value gsub ","value include? ","value gsub  gsub "," to_s  gsub ","value gsub  include? "," to_s  include? "]}," REXML Attribute hash":{"type":"method","name":"hash","children":[],"call":[" name hash + "," value hash "," value "," name hash "," name "]}," REXML Attribute ==":{"type":"method","name":"==","children":[],"call":["other value == "," value ","other value ","other name == "," name ","other name ","other kind_of? "]}," REXML Attribute namespace":{"type":"method","name":"namespace","children":[],"call":["@element namespace "," prefix ","arg nil? ","arg == "," prefix  nil? "," prefix  == "]}," REXML Attribute prefix":{"type":"method","name":"prefix","children":[],"call":["@element prefix ","pf == ","@element prefix  == "]}," REXML Attribute initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","first class name ","first class ","second to_s "," name= ","first kind_of? ","first element ","second kind_of? ","first value ","first expanded_name "]}," REXML AttlistDecl node_type":{"type":"method","name":"node_type","children":[],"call":[]}," REXML AttlistDecl write":{"type":"method","name":"write","children":[],"call":["out << "]}," REXML AttlistDecl each":{"type":"method","name":"each","children":[],"call":["@pairs each "]}," REXML AttlistDecl include?":{"type":"method","name":"include?","children":[],"call":["@pairs keys include? ","@pairs keys "]}," REXML AttlistDecl []":{"type":"method","name":"[]","children":[],"call":["@pairs [] "]}," REXML AttlistDecl initialize":{"type":"method","name":"initialize","children":[],"call":["source kind_of? "]}," REXML Parsers BaseParser parse_id_invalid_details":{"type":"method","name":"parse_id_invalid_details","children":[],"call":["@source match "]}," REXML Parsers BaseParser parse_id":{"type":"method","name":"parse_id","children":[],"call":[" raise ","REXML ParseException  new "," parse_id_invalid_details ","system_literal [] ","md [] ","@source match ","pubid_literal [] "," parse_id_invalid_ parse_id_invalid_details  ","system_literal [] _literal [] ","md []  [] ","@source match  [] ","pubid_literal [] _literal [] "]}," REXML Parsers BaseParser parse_name":{"type":"method","name":"parse_name","children":[],"call":["md [] "," raise ","REXML ParseException  new ","@source match ","@source match  [] "]}," REXML ReferenceWriter write":{"type":"method","name":"write","children":[],"call":["output << ","@system_literal include? ","@public_id_literal include? "]}," REXML ReferenceWriter initialize":{"type":"method","name":"initialize","children":[],"call":["context [] == ","context [] "]}," REXML XPathParser each_unnode":{"type":"method","name":"each_unnode","children":[],"call":["node raw_node ","node is_a? ","nodeset each "," to_enum "," __method__ "," block_given? "]}," REXML XPathParser normalize_compare_values":{"type":"method","name":"normalize_compare_values","children":[],"call":[" raise ","[BUG] Unexpected compare operator:  + ","b inspect ","a inspect ","operator inspect ","Functions  number ","b_type == ","a_type == ","Functions  string ","Functions  boolean "," value_type "," rFunctions  number ise "," rFunctions  string ise "," rFunctions  boolean ise ","[BUG] Unexpected compFunctions  number re operFunctions  number tor:  + ","[BUG] Unexpected compFunctions  string re operFunctions  string tor:  + ","[BUG] Unexpected compFunctions  boolean re operFunctions  boolean tor:  + ","Functions  number  inspect ","Functions  string  inspect ","Functions  boolean  inspect ","operFunctions  number tor inspect ","operFunctions  string tor inspect ","operFunctions  boolean tor inspect ","Functions  numFunctions  number er ","Functions  numFunctions  string er ","Functions  numFunctions  boolean er ","Functions  number _type == ","Functions  string _type == ","Functions  boolean _type == "," value_type  == ","Functions  Functions  number oolean ","Functions  Functions  string oolean ","Functions  Functions  boolean oolean ","Functions  booleFunctions  number n ","Functions  booleFunctions  string n ","Functions  booleFunctions  boolean n "," vFunctions  number lue_type "," vFunctions  string lue_type "," vFunctions  boolean lue_type "]}," REXML XPathParser value_type":{"type":"method","name":"value_type","children":[],"call":[" raise ","value inspect "]}," REXML DClonable dclone":{"type":"method","name":"dclone","children":[],"call":["klone << ","v dclone "," each ","klone clear "," clone "," clone  << "," clone  clear "]}," REXML Elements parent":{"type":"method","name":"parent","children":[],"call":[]}," REXML Parsers XPathParser quote_literal":{"type":"method","name":"quote_literal","children":[],"call":["literal inspect ","literal include? "]}," REXML Parsers XPathParser predicate_to_path":{"type":"method","name":"predicate_to_path","children":[],"call":["path squeeze ","path << "," quote_literal ","parsed shift "," predicate_to_path ","i > ","parsed shift each_with_index ","op to_s ","parsed [] ","parsed shift  to_s "]}," REXML Entity resolve_value":{"type":"method","name":"resolve_value","children":[],"call":["rv gsub! ","entity_reference join ","entity_value bytesize "," raise ","sum + > ","Security  entity_expansion_text_limit ","sum + ","@parent entity ","entity_reference [] ","matches each ","@value clone ","@value scan ","@value match? ","@value nil? ","@value clone  gsub! ","@parent entity  bytesize ","@value scan  each "]}," REXML Entity parent=":{"type":"method","name":"parent=","children":[],"call":[]}," REXML Attribute normalized=":{"type":"method","name":"normalized=","children":[],"call":[]}}