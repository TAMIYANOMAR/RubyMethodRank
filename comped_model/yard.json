{" YARD AuthorTag initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD DeprecatedTag initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD ReturnTag initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD ReturnTag parse_tag":{"type":"method","name":"parse_tag","children":[],"call":[]}," YARD ParamTag initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD ParamTag parse_tag":{"type":"method","name":"parse_tag","children":[],"call":[]}," YARD BaseTypeTag type":{"type":"method","name":"type","children":[],"call":[" types first "," types "]}," YARD BaseTypeTag initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD BaseTypeTag extract_name_and_text":{"type":"method","name":"extract_name_and_text","children":[],"call":[]}," YARD BaseTypeTag extract_types_and_text":{"type":"method","name":"extract_types_and_text","children":[],"call":[]}," YARD BaseTag tag_name":{"type":"method","name":"tag_name","children":[],"call":[" class tag_name "," class "," to_s split last gsub downcase "," to_s split last gsub "," to_s split last "," to_s split "," to_s "]}," YARD BaseTag initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD BaseTag parse_tag":{"type":"method","name":"parse_tag","children":[],"call":[" new "]}," YARD BaseTag inherited":{"type":"method","name":"inherited","children":[],"call":["@@tag_library []= ","subclass tag_name ","subclass tag_name empty? "]}," YARD BaseTag tag_library":{"type":"method","name":"tag_library","children":[],"call":[]}," YARD Tag type":{"type":"method","name":"type","children":[],"call":[" types first "," types "]}," YARD Tag initialize":{"type":"method","name":"initialize","children":[],"call":["tag_name to_s "]}," YARD Tag extract_types_from_text":{"type":"method","name":"extract_types_from_text","children":[],"call":["e strip ","1 split collect ","1 split ","text =~ ","text strip "]}," YARD Tag extract_name_from_text":{"type":"method","name":"extract_name_from_text","children":[],"call":["text strip split ","text strip "]}," YARD Tag parse_tag_with_types_and_name":{"type":"method","name":"parse_tag_with_types_and_name","children":[],"call":[" new "," extract_name_from_text "," extract_types_from_text "]}," YARD Tag parse_tag_with_types":{"type":"method","name":"parse_tag_with_types","children":[],"call":[" new "," extract_types_from_text "]}," YARD Tag parse_tag_with_name":{"type":"method","name":"parse_tag_with_name","children":[],"call":[" new "," extract_name_from_text "]}," YARD Tag parse_tag":{"type":"method","name":"parse_tag","children":[],"call":[" new "]}," YARD TagLibrary define_tag!":{"type":"method","name":"define_tag!","children":[],"call":[]}," YARD NameStruct initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Statement clean_tokens":{"type":"method","name":"clean_tokens","children":[],"call":["last_tk class == ","tk class ","last_tk class ","last_tk is_a? ","tk is_a? ","tokens reject "]}," YARD Statement initialize":{"type":"method","name":"initialize","children":[],"call":[" clean_tokens "]}," YARD TokenList to_s":{"type":"method","name":"to_s","children":[],"call":["(send nil :collect) join ","t text "," collect "]}," YARD StatementList next_statement":{"type":"method","name":"next_statement","children":[],"call":["Statement  new ","statement empty? ","comments compact ","level == ","tk is_a? ","tk class != ","tk class ","(const nil :EXPR_END) include? ","last_tk lex_state ","tk class == ","statement first class == ","statement first class ","statement first ","(const nil :TkSEMICOLON) include? ","open_parens == ","@@open_block_tokens include? ","last_tk lex_state == ","(const nil :TkDO) include? ","statement << ","stmt_number == ","block << ","TokenList  new ","stmt_number > ","(const nil :TkEND) include? ","(const nil :TkSPACE) include? ","comments pop ","comments first =~ ","comments first ","comments size == ","comments size ","comments << ","tk text [] ","tk text ","before_last_tk class == ","before_last_tk class ","last_tk class == ","last_tk class ","(const nil :TkRPAREN) include? ","open_parens > ","(const nil :TkLPAREN) include? ","@tokens shift ","comments compact  compact ","@tokens shift  is_a? ","@tokens shift  class != ","@tokens shift  class ","last_@tokens shift  lex_state ","@tokens shift  class == ","last_@tokens shift  lex_state == ","comments compact  pop ","comments compact  first =~ ","comments compact  first ","comments compact  size == ","comments compact  size ","comments compact  << ","@tokens shift  text [] ","@tokens shift  text ","before_last_@tokens shift  class == ","before_last_@tokens shift  class ","last_@tokens shift  class == ","last_@tokens shift  class "]}," YARD StatementList parse_statements":{"type":"method","name":"parse_statements","children":[],"call":[" << "," next_statement "]}," YARD StatementList parse_tokens":{"type":"method","name":"parse_tokens","children":[],"call":["@tokens << ","lex token ","RubyLex  new ","TokenList  new ","TokenList  new  << ","RubyLex  new  token "]}," YARD StatementList initialize":{"type":"method","name":"initialize","children":[],"call":[" parse_statements "," raise ","content class ","content inspect "," parse_tokens ","content is_a? "]}," YARD SourceParser find_handlers":{"type":"method","name":"find_handlers","children":[],"call":["sub handles? ","stmt tokens ","CodeObjectHandler  subclasses find_all ","CodeObjectHandler  subclasses "]}," YARD SourceParser top_level_parse":{"type":"method","name":"top_level_parse","children":[],"call":["handler new process ","handler new "," find_handlers each "," find_handlers ","statements each ","STDERR  puts ","e backtrace [] ","e backtrace ","e message ","stmt tokens to_s ","stmt tokens ","stmt tokens first line_no ","stmt tokens first "," file ","handler to_s "]}," YARD SourceParser parse":{"type":"method","name":"parse","children":[],"call":[" top_level_parse "," raise ","content class ","content inspect ","StatementList  new ","content read ","content respond_to? ","IO  read "]}," YARD SourceParser initialize":{"type":"method","name":"initialize","children":[],"call":["NameStruct  new ","Namespace  root "]}," YARD SourceParser parse_string":{"type":"method","name":"parse_string","children":[],"call":[]}," RubyLex read_escape":{"type":"method","name":"read_escape","children":[],"call":["res << "," read_escape ","(lvasgn :ch\n  (send nil :getc)) == "," getc "," ungetc ","(lvasgn :ch\n  (send nil :getc)) != ","ch == ","2 times ","3 times ","(lvasgn : getc \n  (send nil :getc)) == ","(lvasgn : getc \n  (send nil :getc)) != "," getc  == "]}," RubyLex identify_comment":{"type":"method","name":"identify_comment","children":[],"call":[" Token set_text "," Token ","comment << "," ungetc ","ch == "," getc "," getc  == "]}," RubyLex skip_inner_expression":{"type":"method","name":"skip_inner_expression","children":[],"call":["ch == ","nest zero? ","res << "," getc "," getc  == "]}," RubyLex identify_string":{"type":"method","name":"identify_string","children":[],"call":["(lvar :subtype) set_text "," Token ","Ltype2Token  [] ","DLtype2Token  [] ","str << "," getc "," peek =~ "," peek ","@ltype == "," read_escape ","ch == "," ungetc ","str << << "," skip_inner_expression ","@ltype != ","opener == ","nest == ","@quoted == "," getc  == "]}," RubyLex identify_number":{"type":"method","name":"identify_number","children":[],"call":[" Token set_text "," Token "," ungetc ","str << "," getc "," peek =~ "," peek "," peek !~ ","ch !~ "," peek == ","start == ","start dup ","start dup  << "," getc  !~ "," getc  == "," getc  dup "]}," RubyLex identify_quotation":{"type":"method","name":"identify_quotation","children":[],"call":[" identify_string ","PERCENT_PAREN  [] ","RubyLex  fail ","ch =~ "," getc ","PERCENT_LTYPE  [] "," getc  =~ "]}," RubyLex identify_here_document":{"type":"method","name":"identify_here_document","children":[],"call":[" Token set_text ","str dump "," Token ","Ltype2Token  [] ","@reader divert_read_from ","str << << ","str << ","l chomp ","l == ","l strip! ","l chomp! "," gets ","ch == ","reserve << "," getc "," ungetc ","quoted concat ","c =~ ","ch dup ","c != "," gets  chomp ","l  getc omp ","l  getc homp "," gets  == "," gets  strip! "," gets  chomp! ","l  getc omp! ","l  getc homp! "," getc  == "," getc h == "," get getc  "," unget getc  ","quoted  getc on getc at ","ch dup  concat "," getc  =~ "," getc  dup "," getc h dup "," getc  != "]}," RubyLex identify_identifier":{"type":"method","name":"identify_identifier","children":[],"call":[" Token set_text "," Token ","token [] =~ ","token [] ","token size - ","token size ","@lex_state == ","token concat "," getc "," peek == "," peek ","trans [] ","DEINDENT_CLAUSE  include? ","ENINDENT_CLAUSE  include? ","@lex_state != ","TkSymbol2Token  [] ","TkReading2Token  [] "," print ","RubyLex  debug? ","ch == "," ungetc ","(lvasgn :ch\n  (send nil :getc)) =~ "," peek =~ ","trans []  == ","trans []  != "," getc  == ","(lvasgn : getc \n  (send nil :getc)) =~ "]}," RubyLex identify_gvar":{"type":"method","name":"identify_gvar","children":[],"call":["tk set_text "," Token "," ungetc "," identify_identifier ","str << ","(lvasgn :ch\n  (send nil :getc)) =~ "," getc ","str << << ","(lvasgn : getc \n  (send nil :getc)) =~ "]}," RubyLex lex_int2":{"type":"method","name":"lex_int2","children":[],"call":[" p ","RubyLex  debug? "," printf ","io inspect "," identify_identifier "," peek =~ "," peek "," identify_number ","@OP def_rule "," throw ","@prev_char_no == "," proc "," Token set_text "," Token "," ungetc "," identify_gvar "," identify_quotation "," peek !~ ","@lex_state == "," getc "," peek == "," getc == ","t set_text ","@lex_state != ","tk set_text ","@OP def_rules "," identify_string "," prin identify_identifier f "," prin identify_number f "," prin Token f ","io inspec identify_identifier  ","io inspec identify_number  ","io inspec Token  "," iden identify_identifier ify_iden identify_identifier ifier "," iden identify_number ify_iden identify_number ifier "," iden Token ify_iden Token ifier "," iden identify_identifier ify_number "," iden identify_number ify_number "," iden Token ify_number ","  identify_identifier hrow ","  identify_number hrow ","  Token hrow "," Token se identify_identifier _ identify_identifier ex identify_identifier  "," Token se identify_number _ identify_number ex identify_number  "," Token se Token _ Token ex Token  "," unge identify_identifier c "," unge identify_number c "," unge Token c "," iden identify_identifier ify_gvar "," iden identify_number ify_gvar "," iden Token ify_gvar "," iden identify_identifier ify_quo identify_identifier a identify_identifier ion "," iden identify_number ify_quo identify_number a identify_number ion "," iden Token ify_quo Token a Token ion ","@lex_s identify_identifier a identify_identifier e == ","@lex_s identify_number a identify_number e == ","@lex_s Token a Token e == "," ge identify_identifier c "," ge identify_number c "," ge Token c "," ge identify_identifier c == "," ge identify_number c == "," ge Token c == "," identify_identifier  se identify_identifier _ identify_identifier ex identify_identifier  "," identify_number  se identify_number _ identify_number ex identify_number  "," Token  se Token _ Token ex Token  ","@lex_s identify_identifier a identify_identifier e != ","@lex_s identify_number a identify_number e != ","@lex_s Token a Token e != "," identify_identifier k se identify_identifier _ identify_identifier ex identify_identifier  "," identify_number k se identify_number _ identify_number ex identify_number  "," Token k se Token _ Token ex Token  "," Token  set_text "," iden identify_identifier ify_s identify_identifier ring "," iden identify_number ify_s identify_number ring "," iden Token ify_s Token ring "]}," RubyLex lex_init":{"type":"method","name":"lex_init","children":[],"call":[" lex_int2 "," Token set_text "," Token ","@OP def_rules "," identify_number "," ungetc "," peek =~ "," peek ","@OP def_rule "," throw ","@lex_state != ","@lex_state == "," catch "," proc ","op =~ ","str << "," read_escape ","ch == ","ch !~ "," getc "," identify_string ","tk ! "," identify_here_document "," print ","RubyLex  debug? ","str sub! ","str =~ ","line << ","line =~ ","@prev_char_no == "," identify_comment ","chars << ","(lvasgn :ch\n  (send nil :getc)) =~ ","SLex  new ","SLex  new  def_rules "," unget peek  ","SLex  new  def_rule "," cat getc  ","  peek at peek h "," pro peek  "," read_es peek ape "," getc  == "," peek h == "," getc  !~ "," peek h !~ "," get peek  "," Token set_text  ! "," identify_here_document  ! "," identify_here_do peek ument ","@prev_ getc ar_no == ","@prev_ peek har_no == "," identify_ peek omment "," getc ars << "," peek hars << ","(lvasgn : getc \n  (send nil :getc)) =~ ","(lvasgn : peek h\n  (send nil :get peek )) =~ "]}," RubyLex token":{"type":"method","name":"token","children":[],"call":["tk lex_state= "," lex_state "," p "," get_read ","TkError  new "," char_no "," line_no "," abort ","tk kind_of? ","@OP match "," set_token_position ","TkError  new  lex_state= ","@OP match  lex_state= ","TkError  new  kind_of? ","@OP match  kind_of? "]}," RubyLex lex":{"type":"method","name":"lex","children":[],"call":["tk nil? ","tk kind_of? ","line == "," get_read ","@continue ! ","(lvasgn :tk\n  (send nil :token)) kind_of? "," token "," token  nil? "," token  kind_of? "," get_read  == ","(lvasgn : token \n  (send nil :token)) kind_of? "]}," RubyLex peek":{"type":"method","name":"peek","children":[],"call":["@reader peek "]}," RubyLex peek_equal?":{"type":"method","name":"peek_equal?","children":[],"call":["@reader peek_equal "]}," RubyLex ungetc":{"type":"method","name":"ungetc","children":[],"call":["@reader ungetc "]}," RubyLex gets":{"type":"method","name":"gets","children":[],"call":["c == ","l concat "," getc "," getc  == ","l  getc on getc at "," get getc  "]}," RubyLex getc_of_rests":{"type":"method","name":"getc_of_rests","children":[],"call":["@reader getc_already_read "]}," RubyLex getc":{"type":"method","name":"getc","children":[],"call":["@reader getc "]}," RubyLex get_read":{"type":"method","name":"get_read","children":[],"call":["@reader get_read "]}," RubyLex char_no":{"type":"method","name":"char_no","children":[],"call":["@reader column "]}," RubyLex line_no":{"type":"method","name":"line_no","children":[],"call":["@reader line_num "]}," RubyLex initialize":{"type":"method","name":"initialize","children":[],"call":["BufferedReader  new "," lex_init "]}," RubyLex debug?":{"type":"method","name":"debug?","children":[],"call":[]}," RubyLex BufferedReader divert_read_from":{"type":"method","name":"divert_read_from","children":[],"call":["@content size ","@content []= "]}," RubyLex BufferedReader peek_equal":{"type":"method","name":"peek_equal","children":[],"call":["@content [] == ","@content [] ","str length "]}," RubyLex BufferedReader peek":{"type":"method","name":"peek","children":[],"call":["@content [] ","pos >= ","@offset + ","@offset +  >= "]}," RubyLex BufferedReader get_read":{"type":"method","name":"get_read","children":[],"call":["@content [] "]}," RubyLex BufferedReader ungetc":{"type":"method","name":"ungetc","children":[],"call":["@content [] == ","@content [] "," raise ","@offset <= "]}," RubyLex BufferedReader getc_already_read":{"type":"method","name":"getc_already_read","children":[],"call":[" getc "]}," RubyLex BufferedReader getc":{"type":"method","name":"getc","children":[],"call":["ch == ","@offset - ","@hwm < ","@content [] ","@offset >= ","@content []  == "]}," RubyLex BufferedReader column":{"type":"method","name":"column","children":[],"call":["@offset - "]}," RubyLex BufferedReader initialize":{"type":"method","name":"initialize","children":[],"call":["@content size ","@content << ","@content [] == ","@content [] ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","  * ","tab_width * - ","$` length % ","$` length ","tab_width * ","$& length ","line gsub! ","content split map ","content split ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  size ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  << ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  [] == ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  [] ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join ) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  split map ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  split "]}," RubyToken def_token":{"type":"method","name":"def_token","children":[],"call":[]}," RubyToken Token":{"type":"method","name":"Token","children":[],"call":["token new ","(send\n  (send\n    (lvar :token) :ancestors) :&\n  (array\n    (const nil :TkId)\n    (const nil :TkVal)\n    (const nil :TkOPASGN)\n    (const nil :TkUnknownChar))) empty? ","token ancestors & ","token ancestors "," Token ","tk [] ","IRB  fail ","(lvasgn :tk\n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","source [] ","token kind_of? ","token new  [] "," Token  [] ","source []  [] ","(lvasgn :token new \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","(lvasgn : Token \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","(lvasgn :source [] \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? "]}," RubyToken set_token_position":{"type":"method","name":"set_token_position","children":[],"call":[]}," RubyToken TkUnknownChar initialize":{"type":"method","name":"initialize","children":[],"call":["char_no chr "]}," RubyToken TkOPASGN initialize":{"type":"method","name":"initialize","children":[],"call":["TkReading2Token  [] ","op kind_of? ","TkReading2Token  []  kind_of? "]}," RubyToken TkOp name":{"type":"method","name":"name","children":[],"call":[" class op_name "," class "]}," RubyToken TkVal initialize":{"type":"method","name":"initialize","children":[],"call":[" set_text "]}," RubyToken TkId initialize":{"type":"method","name":"initialize","children":[],"call":[]}," RubyToken Token set_text":{"type":"method","name":"set_text","children":[],"call":[]}," RubyToken Token initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD QuickDoc format_code":{"type":"method","name":"format_code","children":[],"call":["(send\n  (send\n    (lvar :text) :split\n    (regexp\n      (str \"\\\\r?\\\\n\")\n      (regopt))) :collect) join ","(send\n  (str \" \") :*\n  (lvar :tab)) + ","line sub ","  * ","indent < ","indent > ","line [] length ","line [] ","text split collect ","text split ","line [] length  < ","line [] length  > "]}," YARD QuickDoc word_wrap":{"type":"method","name":"word_wrap","children":[],"call":["text gsub ","\n + ","length - "]}," YARD QuickDoc initialize":{"type":"method","name":"initialize","children":[],"call":[" puts ","tag text ","meth tags each ","meth tags ","meth tags empty? "," format_code ","meth source sub ","(begin\n  (lvar :block)) + + ","(begin\n  (lvar :block)) + "," # ->  + ","meth source ","tag name ","tag types join ","tag types ","tag types empty? ","(as  + + ","(as  + ",":  + "," word_wrap ","ns length + ","ns length ","meth docstring ","!! This method is deprecated + ","meth tag text ","meth tag ","meth visibility ","meth line ","meth file ","= * "," {| + + "," {| + ","(send\n  (send\n    (lvar :meth) :tags\n    (str \"yieldparam\")) :collect) join ","meth tags collect ","rvalue type ","meth path ","meth nil? ","Namespace  at ","(send\n  (send\n    (const nil :Namespace) :all) :select) sort join ","(send\n  (send\n    (const nil :Namespace) :all) :select) sort ","Namespace  at is_a? ","Namespace  all select ","Namespace  all ","name nil? ","Namespace  load ","Namespace  at  tags each ","Namespace  at  tags ","Namespace  at  tags empty? ","Namespace  at  source sub ","(begin\n  (lvar : {| + + )) + + ","(begin\n  (lvar : {| + + )) + ","Namespace  at  source ","meth path  length + ","meth path  length ","Namespace  at  docstring ","!! This Namespace  at od is deprecated + ","Namespace  at  tag text ","Namespace  at  tag ","Namespace  at  visibility ","Namespace  at  line ","Namespace  at  file ","(send\n  (send\n    (lvar :Namespace  at ) :tags\n    (str \"yieldparam\")) :collect) join ","Namespace  at  tags collect ","meth tag  type ","Namespace  at  path ","Namespace  at  nil? ","(send\n  (send\n    (cometh path t nil :Namespace) :all) :select) sort join ","(send\n  (send\n    (cometh path t nil :Namespace) :all) :select) sort "]}," YARD Namespace at":{"type":"method","name":"at","children":[],"call":[" namespace [] "," namespace "," instance at "," instance "]}," YARD Namespace add_object":{"type":"method","name":"add_object","children":[],"call":[" namespace update ","object path "," namespace ","object docstring nil? ","object docstring "," namespace [] "," instance add_object "," instance "]}," YARD Namespace initialize":{"type":"method","name":"initialize","children":[],"call":["CodeObjectWithMethods  new "]}," YARD Namespace find_from_path":{"type":"method","name":"find_from_path","children":[],"call":["object parent "," at ","object path + + ","object path + ","object path ","(str \"::\") each ","name == ","object is_a? ","object parent  parent "," at  parent "," at ect parent ","object parent  path + + "," at  path + + "," at ect path + + ","object parent  path + "," at  path + "," at ect path + ","object parent  path "," at  path "," at ect path ","object parent  is_a? "," at  is_a? "," at ect is_a? "]}," YARD Namespace save":{"type":"method","name":"save","children":[],"call":["Marshal  dump "," instance namespace "," instance ","File  open "]}," YARD Namespace load":{"type":"method","name":"load","children":[],"call":[" save ","SourceParser  parse ","path =~ ","Find  find "," instance namespace replace ","Marshal  load ","IO  read "," instance namespace "," instance ","reload ! ","File  exists? "]}," YARD Namespace each_object":{"type":"method","name":"each_object","children":[],"call":[" instance namespace each "," instance namespace "," instance "]}," YARD Namespace all":{"type":"method","name":"all","children":[],"call":[" instance namespace keys "," instance namespace "," instance "]}," YARD Namespace root":{"type":"method","name":"root","children":[],"call":[" at "]}," YARD Namespace find_or_create_namespace":{"type":"method","name":"find_or_create_namespace","children":[],"call":[" instance namespace update "," instance namespace "," instance ","ModuleObject  new ","namespace split last ","namespace split "," at "," instance namespace split last space update "," instance namespace split last space ","namespace split last space split last ","namespace split last space split "]}," YieldHandler process":{"type":"method","name":"process","children":[],"call":[" object tags << ","YARD TagLibrary  yieldparam_tag "," object tags "," object "," object parent path "," object parent ","param == ","params each "," object tags empty? ","tokens [] is_a? ","tokens [] ","index + ","params << ","tokens [] text ","(send\n  (lvar :from) :+\n  (int 1)) step ","tokens size - ","tokens size ","from + ","from is_a? ","token class == ","token class ","tokens each_with_index ","(const\n  (const nil :RubyToken) :TkSPACE) include? ","tk class "," statement tokens reject "," statement tokens "," statement ","yieldtag types << ","yieldtag types "," owner tags << ","YARD Tags Tag  new "," owner tags "," owner ","item == "," owner namespace path "," owner namespace ","item inspect ","item is_a? "," tokval_list each "," tokval_list "," statement tokens [] "," owner has_tag? "," owner is_a? ","item source "," owner docstring add_tag "," owner docstring "," s "," statement jump children each "," statement jump children "," statement jump "," statement type == "," statement type ","yieldtag types empty? ","YARD Tags Tag  new  types << ","YARD Tags Tag  new  types ","item inspect  == ","item inspect  inspect ","item inspect  is_a? ","item inspect  source ","YARD Tags Tag  new  types empty? "]}," VisibilityHandler process":{"type":"method","name":"process","children":[],"call":[" current_visibility= "," statement tokens to_s to_sym "," statement tokens to_s "," statement tokens "," statement ","o visibility= ","MethodObject  new "," scope "," namespace "," tokval_list each "," tokval_list "," statement tokens [] "," visibility= "," statement tokens size == "," statement tokens size "," statement tokens first text "," statement tokens first ","ident first ","node source ","node type == ","node type "," statement [] traverse "," statement [] "," statement type ","(lvasgn :ident\n  (send\n    (send nil :statement) :jump\n    (sym :ident))) == "," statement jump "," current_ statement tokens first text ibility= ","o  statement tokens first text ibility= ","  statement tokens first text ibility= "," statement jump  first ","(lvasgn : statement jump \n  (send\n    (send nil :statement) :jump\n    (sym : statement jump ))) == "]}," ModuleHandler process":{"type":"method","name":"process","children":[],"call":[" parse_block "," enter_namespace ","YARD ModuleObject  new "," statement comments "," statement "," object "," move_to_namespace "," statement tokens [] text "," statement tokens [] "," statement tokens "," register ","ModuleObject  new "," namespace "," statement tokens to_s [] "," statement tokens to_s "," statement [] "," statement [] source "]}," MixinHandler process":{"type":"method","name":"process","children":[],"call":[" object mixins uniq! "," object mixins "," object "," object mixins push "," eval to_s "," eval "," statement tokens [] to_s "," statement tokens [] "," statement tokens "," statement "," object is_a? "," object mixins flatten! ","mixin trim "," object mixins map! ","[  + + ","[  + "," raise "," namespace path "," namespace "," namespace mixins << "," namespace mixins ","obj type= ","obj is_a? ","Proxy  new ","mixin [] ","mixin strip! "," statement tokens [] to_s split each "," statement tokens [] to_s split "," process_mixin "," statement parameters each "," statement parameters ","mixin strip "," Proxy  new ect mixins uniq! "," Proxy  new ect mixins "," Proxy  new ect "," Proxy  new ect mixins push "," Proxy  new ect is_a? "," Proxy  new ect mixins flatten! "," Proxy  new ect mixins map! ","Proxy  new  type= ","Proxy  new  is_a? "]}," MethodHandler process":{"type":"method","name":"process","children":[],"call":[" parse_block ","obj attach_source "," parser file "," parser "," statement "," enter_namespace ","YARD MethodObject  new "," statement comments "," current_visibility ","stmt_nospace [] to_s [] ","stmt_nospace [] to_s ","stmt_nospace [] ","YARD Namespace  find_or_create_namespace ","holding_object nil? ","YARD Namespace  find_from_path "," object path "," object ","stmt_nospace [] text ","(const\n  (const nil :RubyToken) :TkCOLON2) include? ","stmt_nospace [] class "," current_scope ","t is_a? "," statement tokens reject "," statement tokens "," object is_a? ","o explicit= ","o source= ","o visibility= "," visibility "," register ","MethodObject  new "," P "," namespace ","$` == ","meth =~ "," raise ","meth gsub! "," statement tokens to_s [] "," statement tokens to_s "," scope ","o parameters= ","o signature= "," method_signature "," statement source "," statement [] "," format_args "," statement [] [] "," statement [] source "," statement [] source == "," statement type == "," statement type ","v strip ","k strip ","a split ","args map! "," tokval_list ","YARD Parser Ruby Legacy TokenList  new "," statement tokens to_s =~ ","obj docstring add_tag ","YARD Tags Tag  new ","obj docstring ","(str \"inherited\") include? ","obj docstring blank? ","mscope == "," namespace name to_s "," namespace name ","obj has_tag? ","meth == ","obj tag nil? ","obj tag ","obj tag types= ","(or\n  (send\n    (send\n      (lvar :obj) :tag\n      (sym :return)) :types)\n  (array)) empty? ","obj tag types ","meth to_s =~ ","meth to_s ","info []= ","info [] ","obj attr_info ","YARD Namespace  find_or_create_namespace  nil? ","YARD Namespace  find_from_path  nil? "," object  nil? "," statement tokens to_s []  =~ "," statement [] []  =~ "," statement tokens to_s []  gsub! "," statement [] []  gsub! ","  statement tokens to_s [] od_signature ","  statement [] [] od_signature "," format_ format_args  "," format_ tokval_list  "," format_args  map! "," tokval_list  map! "," scope  == "," statement tokens to_s []  == "," statement [] []  == "," statement tokens to_s []  to_s =~ "," statement [] []  to_s =~ "," statement tokens to_s []  to_s "," statement [] []  to_s ","obj attr_info  []= ","obj attr_info  [] ","obj attr_obj attr_info  "]}," ExceptionHandler process":{"type":"method","name":"process","children":[],"call":[" object tags << ","YARD TagLibrary  raise_tag "," object tags "," object ","tag name == ","tag name "," object tags any? ","exception_class nil? ","exception_class =~ ","tokens [] to_s [] ","tokens [] to_s ","tokens [] ","from + ","from is_a? ","token text == ","token text ","token class == ","token class ","tokens each_with_index ","(const\n  (const nil :RubyToken) :TkSPACE) include? "," statement tokens reject "," statement tokens "," statement "," owner tags << ","YARD Tags Tag  new "," owner tags "," owner "," statement tokens to_s [] "," statement tokens to_s "," owner has_tag? "," owner is_a? "," owner docstring add_tag "," owner docstring ","params first source ","params first ","params first namespace source ","params first namespace ","params first method_name == ","params first method_name ","params first call? ","params first first type != ","params first first type ","params first first ","params first ref? ","params size == ","params size "," statement parameters ","(sym :command_call) include? "," statement type ","tokens [] to_s []  nil? ","tokens [] to_s []  =~ "," statement parameters  first source "," statement parameters  first "," statement parameters  first namespace source "," statement parameters  first namespace "," statement parameters  first method_name == "," statement parameters  first method_name "," statement parameters  first call? "," statement parameters  first first type != "," statement parameters  first first type "," statement parameters  first first "," statement parameters  first ref? "," statement parameters  size == "," statement parameters  size "]}," ConstantHandler process":{"type":"method","name":"process","children":[],"call":["YARD ConstantObject  new "," statement "," object "," statement tokens to_s split "," statement tokens to_s "," statement tokens "," object is_a? "," register ","o source= ","ConstantObject  new "," namespace "," statement tokens to_s gsub split "," statement tokens to_s gsub "," owner is_a? "," owner ","o value= ","value strip "," statement [] source "," statement [] "," statement [] [] [] "," statement [] [] "," statement [] [] type == "," statement [] [] type "," statement [] type == "," statement [] type "," process_structclass ","value =~ "," process_constant "," statement [] [] == "," s "," statement [] [] [] == "," statement [] call? "," YARD ConstantObject  new ect "," YARD ConstantObject  new ect is_a? ","  statement [] [] [] space ","o  statement [] source = "," statement [] source  strip "," statement [] source  =~ "]}," CodeObjectHandler parse_block":{"type":"method","name":"parse_block","children":[],"call":[" parser parse "," statement block "," statement "," parser "]}," CodeObjectHandler move_to_namespace":{"type":"method","name":"move_to_namespace","children":[],"call":[" current_namespace object= ","YARD Namespace  find_or_create_namespace "," current_namespace ","(send\n  (send nil :object) :path) compact join gsub ","(send\n  (send nil :object) :path) compact join ","(send\n  (send nil :object) :path) compact "," object path "," object ","path join ","path pop ","namespace split ","namespace include? "," current_path pop space object= ","YARD Namespace  find_or_create_path pop space "," current_path pop space ","(send\n  (send nil :object) :path join ) compact join gsub ","(send\n  (send nil :object) :namespace split ) compact join gsub ","(send\n  (send nil :object) :path join ) compact join ","(send\n  (send nil :object) :namespace split ) compact join ","(send\n  (send nil :object) :path join ) compact ","(send\n  (send nil :object) :namespace split ) compact "," object path join  "," object namespace split  ","path join  join ","namespace split  join ","path join  pop ","namespace split  pop ","path pop space split ","path pop space include? "]}," CodeObjectHandler enter_namespace":{"type":"method","name":"enter_namespace","children":[],"call":[" current_namespace= ","obj attach_docstring "," statement comments "," statement ","obj attach_source "," statement tokens first line_no "," statement tokens first "," statement tokens "," parser file "," parser "," statement tokens to_s ","YARD NameStruct  new "," object add_child "," object ","name is_a? "," parser current_namespace "," current_ parser current_namespace = "," parser current_ parser current_namespace  "]}," CodeObjectHandler current_namespace=":{"type":"method","name":"current_namespace=","children":[],"call":[" parser current_namespace= "," parser "]}," CodeObjectHandler current_namespace":{"type":"method","name":"current_namespace","children":[],"call":[" parser current_namespace "," parser "]}," CodeObjectHandler attributes":{"type":"method","name":"attributes","children":[],"call":[" current_namespace attributes "," current_namespace "]}," CodeObjectHandler object":{"type":"method","name":"object","children":[],"call":[" current_namespace object "," current_namespace "]}," CodeObjectHandler current_scope=":{"type":"method","name":"current_scope=","children":[],"call":[" current_namespace attributes []= "," current_namespace attributes "," current_namespace "]}," CodeObjectHandler current_scope":{"type":"method","name":"current_scope","children":[],"call":[" current_namespace attributes [] "," current_namespace attributes "," current_namespace "]}," CodeObjectHandler current_visibility=":{"type":"method","name":"current_visibility=","children":[],"call":[" current_namespace attributes []= "," current_namespace attributes "," current_namespace "]}," CodeObjectHandler current_visibility":{"type":"method","name":"current_visibility","children":[],"call":[" current_namespace attributes [] "," current_namespace attributes "," current_namespace "]}," CodeObjectHandler process":{"type":"method","name":"process","children":[],"call":[]}," CodeObjectHandler initialize":{"type":"method","name":"initialize","children":[],"call":[]}," CodeObjectHandler handles?":{"type":"method","name":"handles?","children":[],"call":["@handler <= ","tokens first class ","tokens first ","tokens to_s =~ ","tokens to_s ","tokens first text == ","tokens first text "]}," CodeObjectHandler handles":{"type":"method","name":"handles","children":[],"call":[]}," CodeObjectHandler inherited":{"type":"method","name":"inherited","children":[],"call":["@@subclasses << "]}," CodeObjectHandler subclasses":{"type":"method","name":"subclasses","children":[],"call":[]}," ClassVariableHandler process":{"type":"method","name":"process","children":[],"call":["YARD ClassVariableObject  new "," object "," statement "," object is_a? "," register ","o source= ","ClassVariableObject  new "," namespace "," statement tokens to_s gsub split "," statement tokens to_s gsub "," statement tokens to_s "," statement tokens "," owner is_a? "," owner "," statement [] [] [] "," statement [] [] "," statement [] "," statement [] [] type == "," statement [] [] type "," statement [] type == "," statement [] type ","o value= ","value strip "," statement tokens to_s split "," statement [] source ","  statement [] [] [] space ","o  statement [] source = "," statement [] source  strip "]}," ClassHandler process":{"type":"method","name":"process","children":[],"call":[" parse_block "," enter_namespace ","YARD ClassObject  new "," statement comments "," statement "," object "," move_to_namespace "," current_namespace attributes []= "," current_namespace attributes "," current_namespace "," current_visibility "," current_namespace attributes [] ","class_name nil? ","words [] == ","words [] ","class_name == "," statement tokens to_s strip split "," statement tokens to_s strip "," statement tokens to_s "," statement tokens ","Namespace  find_from_path "," raise "," P "," namespace ","classname [] =~ ","classname [] ","classname == "," statement tokens to_s =~ ","o superclass type= ","o superclass ","o superclass is_a? ","o superclass= "," register ","ClassObject  new ","superclass nil? "," parse_superclass ","Proxy  === ","Proxy  new ","proxy value ","proxy value =~ ","ConstantObject  === "," statement source [] "," statement source ","(if\n  (send\n    (send nil :statement) :[]\n    (int 1))\n  (send\n    (send\n      (send nil :statement) :[]\n      (int 1)) :source_end)\n  (send\n    (send\n      (send nil :statement) :[]\n      (int 0)) :source_end)) - "," statement source_start "," statement [] source_end "," statement [] "," statement [] source "," statement [] == "," s "," statement type == "," statement type ","o docstring= "," move_to_namespace  nil? "," statement tokens to_s strip split  [] == "," statement tokens to_s strip split  [] "," move_to_namespace  == "," statement [] source  [] =~ "," statement [] source  [] "," statement [] source  == ","o  parse_superclass  type= ","o  parse_superclass  ","o  parse_superclass  is_a? ","o  parse_superclass = "," parse_superclass  nil? "," parse_ parse_superclass  ","Proxy  new  value ","Proxy  new  value =~ "]}," AttributeHandler process":{"type":"method","name":"process","children":[],"call":["obj attach_docstring ","obj attach_full_source ","obj attach_source ","method to_s include? ","method to_s ","YARD MethodObject  new "," statement comments "," statement "," object "," current_scope "," current_visibility ","(lvar :name) each "," object [] update ","name to_s "," object [] ","symbols each ","symbols pop ","symbols size == ","symbols size "," eval ","[ + + ","[ + "," statement tokens [] to_s "," statement tokens [] "," statement tokens "," statement tokens first text to_sym "," statement tokens first text "," statement tokens first "," object type == "," object type ","Logger  warning "," statement tokens to_s "," register "," namespace attributes [] [] [] "," namespace attributes [] [] "," namespace attributes [] "," scope "," namespace attributes "," namespace "," namespace attributes [] [] []= ","o docstring= "," statement comments to_s empty? "," statement comments to_s ","o signature ","o source ","type == ","MethodObject  new ","(pair\n  (sym :read)\n  (lvar :name)) each "," namespace attributes [] []= ","SymbolHash  [] "," raise "," tokval_list "," validated_attribute_names each "," validated_attribute_names ","params pop == "," s ","params pop ","params size == ","params size "," statement method_name "," statement parameters dup "," statement parameters "," statement type == "," statement type ","o scope == ","o scope ","o name == ","meth to_sym ","o name "," namespace children find "," namespace children ","o parameters= ","(lvar :name to_s ) each ","name to_s  to_s "," eval  each "," tokval_list  each "," eval  pop "," tokval_list  pop "," eval  size == "," tokval_list  size == "," eval  size "," tokval_list  size "," name to_s space attributes [] [] [] "," name to_s space attributes [] [] "," name to_s space attributes [] "," name to_s space attributes "," name to_s space "," name to_s space attributes [] [] []= ","(pair\n  (sym :read)\n  (lvar :name to_s )) each ","(pair\n  (sym :symbols pop )\n  (lvar :name)) each "," name to_s space attributes [] []= "," validated_attribute_name to_s s each "," validated_attribute_name to_s s "," statement parameters dup  pop == "," statement parameters dup  pop "," statement parameters dup  size == "," statement parameters dup  size "," statement method_name to_s  ","o name to_s  == ","o name to_s  "," name to_s space children find "," name to_s space children "]}," YARD resolve_links":{"type":"method","name":"resolve_links","children":[],"call":["t sub! ","<tt> + + ","<tt> + "," link_to_path ","t =~ "]}," YARD to_html":{"type":"method","name":"to_html","children":[],"call":[" resolve_links ","SMP  convert gsub ","SMP  convert "]}," YARD link_to_path":{"type":"method","name":"link_to_path","children":[],"call":["obj path gsub ","obj path ","obj name ","obj scope ","obj parent path gsub + ","obj parent path gsub ","obj parent path ","obj parent ","label nil? ","Namespace  at ","Namespace  find_from_path ","name [] ","from_path nil? ","name =~ ","Namespace  at  path gsub ","Namespace  find_from_path  path gsub ","Namespace  at  path ","Namespace  find_from_path  path ","Namespace  at  name ","Namespace  find_from_path  name ","Namespace  at  scope ","Namespace  find_from_path  scope ","Namespace  at  parent path gsub + ","Namespace  find_from_path  parent path gsub + ","Namespace  at  parent path gsub ","Namespace  find_from_path  parent path gsub ","Namespace  at  parent path ","Namespace  find_from_path  parent path ","Namespace  at  parent ","Namespace  find_from_path  parent "]}," YARD Formatter template_directory":{"type":"method","name":"template_directory","children":[],"call":["File  join ","File  dirname "]}," YARD Formatter format":{"type":"method","name":"format","children":[],"call":["ERB  new result "," binding ","ERB  new ","IO  read ","File  join "," template_directory ","Namespace  at ","object is_a? "," render ","@object type ","Namespace  at  is_a? ","@Namespace  at  type "]}," YARD ClassVariableObject initialize":{"type":"method","name":"initialize","children":[],"call":["obj attach_source ","obj attach_docstring ","statement comments ","obj parent [] update ","obj parent [] ","obj parent ","statement tokens to_s gsub split ","statement tokens to_s gsub ","statement tokens to_s ","statement tokens "]}," YARD ConstantObject initialize":{"type":"method","name":"initialize","children":[],"call":[" block_given? ","parent [] update ","name to_s ","parent [] ","obj attach_source ","obj attach_docstring ","statement comments "]}," YARD MethodObject initialize":{"type":"method","name":"initialize","children":[],"call":[" block_given? ","parent [] update ","name to_s ","parent [] ","(begin\n  (lvar :scope)) to_sym ","pmethods update ","parent []  update "]}," YARD ClassObject inheritance_tree":{"type":"method","name":"inheritance_tree","children":[],"call":[" full_mixins reverse + "," superclasses "," full_mixins reverse "," full_mixins "]}," YARD ClassObject superclasses":{"type":"method","name":"superclasses","children":[],"call":["(send\n  (lvar :superobject) :path) + ","superobject superclasses ","superobject path "," superclass ","superobject nil? ","Namespace  find_from_path "," path "," path == ","(send\n  (lvar :Namespace  find_from_path ) :path) + ","Namespace  find_from_path  superclasses ","Namespace  find_from_path  path ","Namespace  find_from_path  nil? "]}," YARD ClassObject inherited_methods":{"type":"method","name":"inherited_methods","children":[],"call":["inherited_methods update ","superobject send ","scope + ","(lvar :scopes) flatten each ","(lvar :scopes) flatten ","superobject path != "," path ","superobject path ","Namespace  find_from_path "," superclass ","Namespace  find_from_path  send ","Namespace  find_from_path  path != ","Namespace  find_from_path  path "]}," YARD ClassObject initialize":{"type":"method","name":"initialize","children":[],"call":[" block_given? ","obj []= "]}," YARD ModuleObject initialize":{"type":"method","name":"initialize","children":[],"call":[" block_given? "]}," YARD CodeObjectWithMethods full_mixins":{"type":"method","name":"full_mixins","children":[],"call":["Namespace  find_from_path path ","Namespace  find_from_path "," mixins collect "," mixins "]}," YARD CodeObjectWithMethods inherited_methods":{"type":"method","name":"inherited_methods","children":[],"call":["hash update ","mixin send ","scope + "," full_mixins inject "," full_mixins ","(lvar :scopes) flatten each ","(lvar :scopes) flatten "]}," YARD CodeObjectWithMethods inherited_instance_methods":{"type":"method","name":"inherited_instance_methods","children":[],"call":[" inherited_methods "]}," YARD CodeObjectWithMethods inherited_class_methods":{"type":"method","name":"inherited_class_methods","children":[],"call":[" inherited_methods "]}," YARD CodeObjectWithMethods initialize":{"type":"method","name":"initialize","children":[],"call":[" block_given? ","obj []= "]}," YARD CodeObject parse_comments":{"type":"method","name":"parse_comments","children":[],"call":["@docstring gsub! ","@docstring << << ","@docstring << ","tag_buf << ","indent >= ","line =~ ","@tags << ","TagLibrary  send ","tag_buf squeeze ","TagLibrary  respond_to? ","line == ","indent < ","line [] length ","line [] ","(send\n  (lvar :comments) :+\n  (array\n    (str \"\"))) each ","comments + ","comments first [] length ","comments first [] ","comments first ","comments split ","comments is_a? ","comments empty? ","line [] length  >= ","line [] length  < ","(send\n  (lvar :comments split ) :+\n  (array\n    (str \"\"))) each ","comments split  + ","comments split  first [] length ","comments split  first [] ","comments split  first ","comments split  split ","comments split  is_a? ","comments split  empty? "]}," YARD CodeObject format":{"type":"method","name":"format","children":[],"call":["Formatter  new format ","Formatter  new "]}," YARD CodeObject has_tag?":{"type":"method","name":"has_tag?","children":[],"call":["tag tag_name == ","tag tag_name ","@tags any? ","name to_s ","tag tag_name to_s  == ","tag tag_name to_s  ","name to_s  to_s "]}," YARD CodeObject tags":{"type":"method","name":"tags","children":[],"call":["tag tag_name == ","tag tag_name ","@tags select ","name to_s ","name nil? ","tag tag_name to_s  == ","tag tag_name to_s  ","name to_s  to_s ","name to_s  nil? "]}," YARD CodeObject tag":{"type":"method","name":"tag","children":[],"call":["tag tag_name == ","tag tag_name ","@tags find ","name to_s ","tag tag_name to_s  == ","tag tag_name to_s  ","name to_s  to_s "]}," YARD CodeObject path":{"type":"method","name":"path","children":[],"call":["(begin\n  (if\n    (and\n      (send nil :parent)\n      (send\n        (send\n          (send nil :parent) :type) :!=\n        (sym :root)))\n    (send\n      (send nil :parent) :path) nil)) join gsub ","(begin\n  (if\n    (and\n      (send nil :parent)\n      (send\n        (send\n          (send nil :parent) :type) :!=\n        (sym :root)))\n    (send\n      (send nil :parent) :path) nil)) join "," scope == "," scope "," name "," parent path "," parent "," parent type != "," parent type ","(begin\n  (if\n    (and\n      (send nil :parent)\n      (send\n        (send\n          (send nil :parent) :type) :!=\n        (sym :root)))\n    (send\n      (send nil :parent) :path) nil)) join gsub trim "]}," YARD CodeObject method_missing":{"type":"method","name":"method_missing","children":[],"call":[" [] "]}," YARD CodeObject parent=":{"type":"method","name":"parent=","children":[],"call":["Namespace  add_object ","Namespace  instance namespace delete "," path ","Namespace  instance namespace ","Namespace  instance "," parent "]}," YARD CodeObject []=":{"type":"method","name":"[]=","children":[],"call":["@attributes []= ","key to_sym "]}," YARD CodeObject []":{"type":"method","name":"[]","children":[],"call":["@attributes [] ","key to_sym "]}," YARD CodeObject attach_docstring":{"type":"method","name":"attach_docstring","children":[],"call":[" parse_comments "]}," YARD CodeObject attach_full_source":{"type":"method","name":"attach_full_source","children":[],"call":[]}," YARD CodeObject attach_source":{"type":"method","name":"attach_source","children":[],"call":[" attach_full_source ","statement tokens to_s + ","statement block to_s ","statement block ","statement tokens to_s ","statement tokens ","statement tokens first line_no ","statement tokens first ","statement is_a? "]}," YARD CodeObject to_s":{"type":"method","name":"to_s","children":[],"call":[" path "," type "," visibility ","Formatter  new format ","Formatter  new "]}," YARD CodeObject initialize":{"type":"method","name":"initialize","children":[],"call":[" block_given? "," attach_docstring "," parent= ","scope to_sym ","visibility to_sym "]}," YARD TagLibrary sorted_labels":{"type":"method","name":"sorted_labels","children":[],"call":["a last "," labels sort_by "," labels "]}," YARD RubyLex read_escape":{"type":"method","name":"read_escape","children":[],"call":["res << "," read_escape ","(lvasgn :ch\n  (send nil :getc)) == "," getc "," ungetc ","(lvasgn :ch\n  (send nil :getc)) != ","ch == ","2 times ","3 times ","(lvasgn : getc \n  (send nil :getc)) == ","(lvasgn : getc \n  (send nil :getc)) != "," getc  == "]}," YARD RubyLex identify_comment":{"type":"method","name":"identify_comment","children":[],"call":[" Token set_text "," Token ","comment << "," ungetc ","ch == "," getc "," getc  == "]}," YARD RubyLex skip_inner_expression":{"type":"method","name":"skip_inner_expression","children":[],"call":["ch == ","nest zero? ","res << "," getc "," getc  == "]}," YARD RubyLex identify_string":{"type":"method","name":"identify_string","children":[],"call":["(lvar :subtype) set_text "," Token ","Ltype2Token  [] ","DLtype2Token  [] ","str << "," getc "," peek =~ "," peek ","@ltype == "," read_escape ","ch == "," ungetc ","str << << "," skip_inner_expression ","@ltype != ","opener == ","nest == ","@quoted == "," getc  == "]}," YARD RubyLex identify_number":{"type":"method","name":"identify_number","children":[],"call":[" Token set_text "," Token "," ungetc ","str << "," getc "," peek =~ "," peek "," peek !~ ","ch !~ "," peek == ","start == ","start dup ","start dup  << "," getc  !~ "," getc  == "," getc  dup "]}," YARD RubyLex identify_quotation":{"type":"method","name":"identify_quotation","children":[],"call":[" identify_string ","PERCENT_PAREN  [] ","RubyLex  fail ","ch =~ "," getc ","PERCENT_LTYPE  [] "," getc  =~ "]}," YARD RubyLex identify_here_document":{"type":"method","name":"identify_here_document","children":[],"call":[" Token set_text ","str dump "," Token ","Ltype2Token  [] ","@reader divert_read_from ","str << << ","str << ","l chomp ","l == ","l strip! ","l chomp! "," gets ","ch == ","reserve << "," getc "," ungetc ","quoted concat ","c =~ ","ch dup ","c != "," gets  chomp ","l  getc omp ","l  getc homp "," gets  == "," gets  strip! "," gets  chomp! ","l  getc omp! ","l  getc homp! "," getc  == "," getc h == "," get getc  "," unget getc  ","quoted  getc on getc at ","ch dup  concat "," getc  =~ "," getc  dup "," getc h dup "," getc  != "]}," YARD RubyLex identify_identifier":{"type":"method","name":"identify_identifier","children":[],"call":[" Token set_text "," Token ","token [] =~ ","token [] ","token size - ","token size ","@lex_state == ","token concat "," getc "," peek == "," peek ","trans [] ","DEINDENT_CLAUSE  include? ","ENINDENT_CLAUSE  include? ","@lex_state != ","TkSymbol2Token  [] ","TkReading2Token  [] "," print ","RubyLex  debug? ","ch == "," ungetc ","(lvasgn :ch\n  (send nil :getc)) =~ "," peek =~ ","trans []  == ","trans []  != "," getc  == ","(lvasgn : getc \n  (send nil :getc)) =~ "]}," YARD RubyLex identify_gvar":{"type":"method","name":"identify_gvar","children":[],"call":["tk set_text "," Token "," ungetc "," identify_identifier ","str << ","(lvasgn :ch\n  (send nil :getc)) =~ "," getc ","str << << ","(lvasgn : getc \n  (send nil :getc)) =~ "]}," YARD RubyLex lex_int2":{"type":"method","name":"lex_int2","children":[],"call":[" p ","RubyLex  debug? "," printf ","io inspect "," identify_identifier "," peek =~ "," peek "," identify_number ","@OP def_rule "," throw ","@prev_char_no == "," proc "," Token set_text "," Token "," ungetc "," identify_gvar "," identify_quotation "," peek !~ ","@lex_state == "," getc "," peek == "," getc == ","t set_text ","@lex_state != ","tk set_text ","@OP def_rules "," identify_string "," prin identify_identifier f "," prin identify_number f "," prin Token f ","io inspec identify_identifier  ","io inspec identify_number  ","io inspec Token  "," iden identify_identifier ify_iden identify_identifier ifier "," iden identify_number ify_iden identify_number ifier "," iden Token ify_iden Token ifier "," iden identify_identifier ify_number "," iden identify_number ify_number "," iden Token ify_number ","  identify_identifier hrow ","  identify_number hrow ","  Token hrow "," Token se identify_identifier _ identify_identifier ex identify_identifier  "," Token se identify_number _ identify_number ex identify_number  "," Token se Token _ Token ex Token  "," unge identify_identifier c "," unge identify_number c "," unge Token c "," iden identify_identifier ify_gvar "," iden identify_number ify_gvar "," iden Token ify_gvar "," iden identify_identifier ify_quo identify_identifier a identify_identifier ion "," iden identify_number ify_quo identify_number a identify_number ion "," iden Token ify_quo Token a Token ion ","@lex_s identify_identifier a identify_identifier e == ","@lex_s identify_number a identify_number e == ","@lex_s Token a Token e == "," ge identify_identifier c "," ge identify_number c "," ge Token c "," ge identify_identifier c == "," ge identify_number c == "," ge Token c == "," identify_identifier  se identify_identifier _ identify_identifier ex identify_identifier  "," identify_number  se identify_number _ identify_number ex identify_number  "," Token  se Token _ Token ex Token  ","@lex_s identify_identifier a identify_identifier e != ","@lex_s identify_number a identify_number e != ","@lex_s Token a Token e != "," identify_identifier k se identify_identifier _ identify_identifier ex identify_identifier  "," identify_number k se identify_number _ identify_number ex identify_number  "," Token k se Token _ Token ex Token  "," Token  set_text "," iden identify_identifier ify_s identify_identifier ring "," iden identify_number ify_s identify_number ring "," iden Token ify_s Token ring "]}," YARD RubyLex lex_init":{"type":"method","name":"lex_init","children":[],"call":[" lex_int2 "," Token set_text "," Token ","@OP def_rules "," identify_number "," ungetc "," peek =~ "," peek ","@OP def_rule "," throw ","@lex_state != ","@lex_state == "," catch "," proc ","op =~ ","str << "," read_escape ","ch == ","ch !~ "," getc "," identify_string ","tk ! "," identify_here_document "," print ","RubyLex  debug? ","str sub! ","str =~ ","line << ","line =~ ","@prev_char_no == "," identify_comment ","chars << ","(lvasgn :ch\n  (send nil :getc)) =~ ","SLex  new ","SLex  new  def_rules "," unget peek  ","SLex  new  def_rule "," cat getc  ","  peek at peek h "," pro peek  "," read_es peek ape "," getc  == "," peek h == "," getc  !~ "," peek h !~ "," get peek  "," Token set_text  ! "," identify_here_document  ! "," identify_here_do peek ument ","@prev_ getc ar_no == ","@prev_ peek har_no == "," identify_ peek omment "," getc ars << "," peek hars << ","(lvasgn : getc \n  (send nil :getc)) =~ ","(lvasgn : peek h\n  (send nil :get peek )) =~ "]}," YARD RubyLex token":{"type":"method","name":"token","children":[],"call":["tk lex_state= "," lex_state "," p "," get_read ","TkError  new "," char_no "," line_no "," abort ","tk kind_of? ","@OP match "," set_token_position ","TkError  new  lex_state= ","@OP match  lex_state= ","TkError  new  kind_of? ","@OP match  kind_of? "]}," YARD RubyLex lex":{"type":"method","name":"lex","children":[],"call":["tk nil? ","tk kind_of? ","line == "," get_read ","@continue ! ","(lvasgn :tk\n  (send nil :token)) kind_of? "," token "," token  nil? "," token  kind_of? "," get_read  == ","(lvasgn : token \n  (send nil :token)) kind_of? "]}," YARD RubyLex peek":{"type":"method","name":"peek","children":[],"call":["@reader peek "]}," YARD RubyLex peek_equal?":{"type":"method","name":"peek_equal?","children":[],"call":["@reader peek_equal "]}," YARD RubyLex ungetc":{"type":"method","name":"ungetc","children":[],"call":["@reader ungetc "]}," YARD RubyLex gets":{"type":"method","name":"gets","children":[],"call":["c == ","l concat "," getc "," getc  == ","l  getc on getc at "," get getc  "]}," YARD RubyLex getc_of_rests":{"type":"method","name":"getc_of_rests","children":[],"call":["@reader getc_already_read "]}," YARD RubyLex getc":{"type":"method","name":"getc","children":[],"call":["@reader getc "]}," YARD RubyLex get_read":{"type":"method","name":"get_read","children":[],"call":["@reader get_read "]}," YARD RubyLex char_no":{"type":"method","name":"char_no","children":[],"call":["@reader column "]}," YARD RubyLex line_no":{"type":"method","name":"line_no","children":[],"call":["@reader line_num "]}," YARD RubyLex initialize":{"type":"method","name":"initialize","children":[],"call":["BufferedReader  new "," lex_init "]}," YARD RubyLex debug?":{"type":"method","name":"debug?","children":[],"call":[]}," YARD RubyLex BufferedReader divert_read_from":{"type":"method","name":"divert_read_from","children":[],"call":["@content size ","@content []= "]}," YARD RubyLex BufferedReader peek_equal":{"type":"method","name":"peek_equal","children":[],"call":["@content [] == ","@content [] ","str length "]}," YARD RubyLex BufferedReader peek":{"type":"method","name":"peek","children":[],"call":["@content [] ","pos >= ","@offset + ","@offset +  >= "]}," YARD RubyLex BufferedReader get_read":{"type":"method","name":"get_read","children":[],"call":["@content [] "]}," YARD RubyLex BufferedReader ungetc":{"type":"method","name":"ungetc","children":[],"call":["@content [] == ","@content [] "," raise ","@offset <= "]}," YARD RubyLex BufferedReader getc_already_read":{"type":"method","name":"getc_already_read","children":[],"call":[" getc "]}," YARD RubyLex BufferedReader getc":{"type":"method","name":"getc","children":[],"call":["ch == ","@offset - ","@hwm < ","@content [] ","@offset >= ","@content []  == "]}," YARD RubyLex BufferedReader column":{"type":"method","name":"column","children":[],"call":["@offset - "]}," YARD RubyLex BufferedReader initialize":{"type":"method","name":"initialize","children":[],"call":["@content size ","@content << ","@content [] == ","@content [] ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","  * ","tab_width * - ","$` length % ","$` length ","tab_width * ","$& length ","line gsub! ","content split map ","content split ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  size ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  << ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  [] == ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  [] ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join ) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  split map ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  split "]}," YARD RubyToken def_token":{"type":"method","name":"def_token","children":[],"call":[]}," YARD RubyToken Token":{"type":"method","name":"Token","children":[],"call":["token new ","(send\n  (send\n    (lvar :token) :ancestors) :&\n  (array\n    (const nil :TkId)\n    (const nil :TkVal)\n    (const nil :TkOPASGN)\n    (const nil :TkUnknownChar))) empty? ","token ancestors & ","token ancestors "," Token ","tk [] ","IRB  fail ","(lvasgn :tk\n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","source [] ","token kind_of? ","token new  [] "," Token  [] ","source []  [] ","(lvasgn :token new \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","(lvasgn : Token \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","(lvasgn :source [] \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? "]}," YARD RubyToken set_token_position":{"type":"method","name":"set_token_position","children":[],"call":[]}," YARD RubyToken TkUnknownChar initialize":{"type":"method","name":"initialize","children":[],"call":["char_no chr "]}," YARD RubyToken TkOPASGN initialize":{"type":"method","name":"initialize","children":[],"call":["TkReading2Token  [] ","op kind_of? ","TkReading2Token  []  kind_of? "]}," YARD RubyToken TkOp name":{"type":"method","name":"name","children":[],"call":[" class op_name "," class "]}," YARD RubyToken TkVal initialize":{"type":"method","name":"initialize","children":[],"call":[" set_text "]}," YARD RubyToken TkId initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD RubyToken Token set_text":{"type":"method","name":"set_text","children":[],"call":[]}," YARD RubyToken Token initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Logger error":{"type":"method","name":"error","children":[],"call":[" puts "]}," Logger warning":{"type":"method","name":"warning","children":[],"call":[" puts "]}," Logger notice":{"type":"method","name":"notice","children":[],"call":[" puts "," msg "]}," YARD YieldHandler process":{"type":"method","name":"process","children":[],"call":[" object tags << ","YARD TagLibrary  yieldparam_tag "," object tags "," object "," object parent path "," object parent ","param == ","params each "," object tags empty? ","tokens [] is_a? ","tokens [] ","index + ","params << ","tokens [] text ","(send\n  (lvar :from) :+\n  (int 1)) step ","tokens size - ","tokens size ","from + ","from is_a? ","token class == ","token class ","tokens each_with_index ","(const\n  (const nil :RubyToken) :TkSPACE) include? ","tk class "," statement tokens reject "," statement tokens "," statement "]}," YARD HtmlFormatter resolve_links":{"type":"method","name":"resolve_links","children":[],"call":["<tt> + + ","<tt> + "," link_to_path ","text gsub "]}," YARD HtmlFormatter to_html":{"type":"method","name":"to_html","children":[],"call":[" resolve_links ","SMP  convert gsub ","SMP  convert "]}," YARD HtmlFormatter link_to_path":{"type":"method","name":"link_to_path","children":[],"call":["obj path gsub ","obj path ","obj name ","obj scope ","(or\n  (send\n    (lvar :obj) :parent)\n  (lvar :obj)) path gsub + ","(or\n  (send\n    (lvar :obj) :parent)\n  (lvar :obj)) path gsub ","(or\n  (send\n    (lvar :obj) :parent)\n  (lvar :obj)) path ","obj parent ","label nil? ","Namespace  at ","Namespace  find_from_path ","name [] ","from_path nil? ","name =~ ","Namespace  at  path gsub ","Namespace  find_from_path  path gsub ","Namespace  at  path ","Namespace  find_from_path  path ","Namespace  at  name ","Namespace  find_from_path  name ","Namespace  at  scope ","Namespace  find_from_path  scope ","(or\n  (send\n    (lvar :Namespace  at ) :parent)\n  (lvar :Namespace  at )) path gsub + ","(or\n  (send\n    (lvar :Namespace  find_from_path ) :parent)\n  (lvar :Namespace  find_from_path )) path gsub + ","(or\n  (send\n    (lvar :Namespace  at ) :parent)\n  (lvar :Namespace  at )) path gsub ","(or\n  (send\n    (lvar :Namespace  find_from_path ) :parent)\n  (lvar :Namespace  find_from_path )) path gsub ","(or\n  (send\n    (lvar :Namespace  at ) :parent)\n  (lvar :Namespace  at )) path ","(or\n  (send\n    (lvar :Namespace  find_from_path ) :parent)\n  (lvar :Namespace  find_from_path )) path ","Namespace  at  parent ","Namespace  find_from_path  parent "]}," YARD Formatter render":{"type":"method","name":"render","children":[],"call":["STDERR  puts ","e backtrace [] map ","e backtrace [] ","e backtrace ","e message ","Erubis Eruby  new result ","Erubis Eruby  new ","(str \"<% extend \") + ","IO  read ","format to_s capitalize ","format to_s ","File  join ","template to_s "," template_directory "," binding ","@object instance_eval "]}," String trim":{"type":"method","name":"trim","children":[],"call":[" gsub "]}," YARD ModuleObject superclasses":{"type":"method","name":"superclasses","children":[],"call":[]}," YARD parse":{"type":"method","name":"parse","children":[],"call":[]}," YARD Tags Tag type":{"type":"method","name":"type","children":[],"call":[" types first "," types "]}," YARD Tags Tag initialize":{"type":"method","name":"initialize","children":[],"call":["(lvar :types) flatten compact ","(lvar :types) flatten ","tag_name to_s "]}," YARD Tags MerbdocFactory extract_types_from_text":{"type":"method","name":"extract_types_from_text","children":[],"call":["e strip ","2 split collect ","2 split ","text =~ ","text strip "]}," YARD Tags MerbdocFactory parse_tag_with_types_and_name":{"type":"method","name":"parse_tag_with_types_and_name","children":[],"call":["Tag  new "," extract_name_from_text ","name nil? "," extract_types_from_text "]}," YARD Tags MerbdocFactory parse_tag_with_types":{"type":"method","name":"parse_tag_with_types","children":[],"call":["Tag  new "," extract_types_from_text "]}," YARD Tags Library initialize":{"type":"method","name":"initialize","children":[],"call":[" factory= "]}," YARD Tags Library send_to_factory":{"type":"method","name":"send_to_factory","children":[],"call":[" raise ","@factory class_name ","@factory send ","arity == ","@factory method arity ","@factory method ","@factory respond_to? ","parse_tag + ","_ + ","meth empty? ","meth to_s ","@factory method arity  == ","@factory method @factory method arity  ","@factory meth to_s od arity ","@factory meth to_s od ","meth to_s  empty? ","meth to_s  to_s "]}," YARD Tags Library define_tag":{"type":"method","name":"define_tag","children":[],"call":["@labels update ","SymbolHash  new "," class_eval ","meth inspect ","tag inspect ","Tag  > ","meth is_a? ","@factory_methods update "," tag_method_name ","166 + ","160 + ","  tag_method_name od_name "]}," YARD Tags Library sorted_labels":{"type":"method","name":"sorted_labels","children":[],"call":["a last downcase ","a last "," labels sort_by "," labels "]}," YARD Tags Library default_factory=":{"type":"method","name":"default_factory=","children":[],"call":["factory new ","factory is_a? "]}," YARD Tags Library default_factory":{"type":"method","name":"default_factory","children":[],"call":["DefaultFactory  new "]}," YARD Tags DefaultFactory extract_title_and_desc_from_raw_text":{"type":"method","name":"extract_title_and_desc_from_raw_text","children":[],"call":["raw_text join ","raw_text shift squeeze strip ","raw_text shift squeeze ","raw_text shift ","raw_text split ","raw_text =~ ","raw_text split  join ","raw_text split  shift squeeze strip ","raw_text split  shift squeeze ","raw_text split  shift ","raw_text split  split ","raw_text split  =~ "]}," YARD Tags DefaultFactory extract_types_from_text":{"type":"method","name":"extract_types_from_text","children":[],"call":["e strip ","1 split collect ","1 split ","text =~ ","text strip "]}," YARD Tags DefaultFactory extract_name_from_text":{"type":"method","name":"extract_name_from_text","children":[],"call":["text strip split ","text strip "]}," YARD Tags DefaultFactory parse_tag_with_raw_title_and_text":{"type":"method","name":"parse_tag_with_raw_title_and_text","children":[],"call":["Tag  new "," extract_title_and_desc_from_raw_text "]}," YARD Tags DefaultFactory parse_tag_with_raw_text":{"type":"method","name":"parse_tag_with_raw_text","children":[],"call":["Tag  new "]}," YARD Tags DefaultFactory parse_tag_with_types_and_name":{"type":"method","name":"parse_tag_with_types_and_name","children":[],"call":["Tag  new "," extract_name_from_text "," extract_types_from_text "," extract_types_and_name_from_text "]}," YARD Tags DefaultFactory parse_tag_with_types":{"type":"method","name":"parse_tag_with_types","children":[],"call":["Tag  new "," extract_types_from_text "," raise "," extract_types_and_name_from_text "]}," YARD Tags DefaultFactory parse_tag_with_name":{"type":"method","name":"parse_tag_with_name","children":[],"call":["Tag  new "," extract_name_from_text "]}," YARD Tags DefaultFactory parse_tag":{"type":"method","name":"parse_tag","children":[],"call":["Tag  new ","text strip "]}," YARD Serializers StdoutSerializer word_wrap":{"type":"method","name":"word_wrap","children":[],"call":["(send\n  (back-ref :$&) :+\n  (send\n    (int 5) :chr)) gsub gsub ","(send\n  (back-ref :$&) :+\n  (send\n    (int 5) :chr)) gsub ","$& + ","5 chr ","text gsub gsub ","text gsub "]}," YARD Serializers StdoutSerializer serialize":{"type":"method","name":"serialize","children":[],"call":[" print "," word_wrap "]}," YARD Serializers StdoutSerializer initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Serializers ProcessSerializer serialize":{"type":"method","name":"serialize","children":[],"call":["io write ","IO  popen "]}," YARD Serializers ProcessSerializer initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Serializers FileSystemSerializer serialized_path":{"type":"method","name":"serialized_path","children":[],"call":["File  join ","_ + ","x [] to_s upcase ","x [] to_s ","x [] ","p gsub ","fspath map! ","fspath unshift ","object namespace path split ","object namespace path ","object namespace ","object namespace path != ","objname + "," extension "," extension empty? ","object scope to_s [] ","object scope to_s ","object scope ","object is_a? ","object name to_s ","object name ","encoded << ","%X % ","x each_byte ","object != ","YARD Registry  root ","file. + + ","file. + "," encode_path_components "," mapped_name ","object name to_s  + "," mapped_name  + "]}," YARD Serializers FileSystemSerializer serialize":{"type":"method","name":"serialize","children":[],"call":["f write ","File  open "," log debug "," log ","FileUtils  mkdir_p ","File  dirname ","File  join "," serialized_path "," basepath ","File  open! "," serialized_File  join  "," baseFile  join  "]}," YARD Serializers FileSystemSerializer initialize":{"type":"method","name":"initialize","children":[],"call":["(if\n  (send\n    (send nil :options) :has_key?\n    (sym :extension))\n  (send\n    (send nil :options) :[]\n    (sym :extension))\n  (str \"html\")) to_s "," options [] "," options "," options has_key? ","(or\n  (send\n    (send nil :options) :[]\n    (sym :basepath))\n  (str \"doc\")) to_s ","(if\n  (send\n    (send nil :options) :key?\n    (sym :extension))\n  (send\n    (send nil :options) :[]\n    (sym :extension))\n  (str \"html\")) to_s "," options key? "]}," YARD Serializers Base serialized_path":{"type":"method","name":"serialized_path","children":[],"call":[]}," YARD Serializers Base after_serialize":{"type":"method","name":"after_serialize","children":[],"call":[]}," YARD Serializers Base serialize":{"type":"method","name":"serialize","children":[],"call":[]}," YARD Serializers Base before_serialize":{"type":"method","name":"before_serialize","children":[],"call":[]}," YARD Serializers Base initialize":{"type":"method","name":"initialize","children":[],"call":["SymbolHash  new update ","SymbolHash  new "]}," YARD Registry resolve":{"type":"method","name":"resolve","children":[],"call":["CodeObjects Proxy  new "," at ","s + ","(const\n  (const nil :CodeObjects) :NSEP) each ","namespace parent ","(send\n  (lvar :namespace) :path) join ","namespace path ","namespace != "," root ","(lvar :name) each ","newname [] ","name =~ ","name to_s gsub ","name to_s ","namespace ! ","namespace == ","(const\n  (const nil :CodeObjects) :ISEP) each "," partial_resolve ","ns is_a? ","nss each ","namespace inheritance_tree ","namespace is_a? ","name [] "," P ","namespace superclass != ","namespace superclass ","namespace respond_to? ","found type == ","found type ","type nil? "," thread_local_resolver lookup_by_path "," thread_local_resolver ","namespace parent  parent "," root  parent ","name to_s space parent ","(send\n  (lvar :namespace parent ) :path) join ","(send\n  (lvar : root ) :path) join ","(send\n  (lvar :namespace) :(send\n  (lvar :namespace) :path) join ) join ","(send\n  (lvar :name to_s space) :path) join ","namespace parent  path "," root  path ","namespace (send\n  (lvar :namespace) :path) join  ","name to_s space path ","namespace parent  != "," root  != ","name to_s space != ","(lvar :name to_s ) each ","name to_s gsub  [] ","newname to_s  [] ","name to_s  =~ ","name to_s  to_s gsub ","name to_s  to_s ","namespace parent  ! "," root  ! ","name to_s space ! ","namespace parent  == "," root  == ","name to_s space == ","namespace inheritance_tree  each ","namespace parent  inheritance_tree "," root  inheritance_tree ","name to_s space inheritance_tree ","namespace parent  is_a? "," root  is_a? ","name to_s space is_a? ","name to_s  [] ","namespace parent  superclass != "," root  superclass != ","name to_s space superclass != ","namespace parent  superclass "," root  superclass ","name to_s space superclass ","namespace parent  respond_to? "," root  respond_to? ","name to_s space respond_to? "," at  type == "," partial_resolve  type == "," at  type "," partial_resolve  type "," thread_local_resolver lookup_by_(send\n  (lvar :namespace) :path) join  "]}," YARD Registry register":{"type":"method","name":"register","children":[],"call":[" namespace []= ","object path "," namespace ","object is_a? "," class objects []= "," class objects "," class ","@store []= "," thread_local_store []= "," thread_local_store "]}," YARD Registry initialize":{"type":"method","name":"initialize","children":[],"call":[" clear "]}," YARD Registry clear":{"type":"method","name":"clear","children":[],"call":["@namespace []= ","CodeObjects RootObject  new ","SymbolHash  new "," objects clear "," objects "," instance clear "," instance ","RegistryStore  new "," thread_local_store= ","SymbolHash  new  []= "]}," YARD Registry delete":{"type":"method","name":"delete","children":[],"call":[" namespace delete ","object path "," namespace "," class objects delete "," class objects "," class ","@store delete "," thread_local_store delete "," thread_local_store "]}," YARD Registry root":{"type":"method","name":"root","children":[],"call":[" namespace [] "," namespace ","@store [] "," thread_local_store [] "," thread_local_store "]}," YARD Registry at":{"type":"method","name":"at","children":[],"call":[" namespace [] "," namespace "," root ","path to_s empty? ","path to_s ","@store [] "," thread_local_store [] "," thread_local_store "]}," YARD Registry paths":{"type":"method","name":"paths","children":[],"call":["k to_s "," namespace keys map "," namespace keys "," namespace ","@store keys map ","@store keys "," thread_local_store keys map "," thread_local_store keys "," thread_local_store "]}," YARD Registry all":{"type":"method","name":"all","children":[],"call":["obj is_a? ","obj type == ","obj type ","type is_a? ","types any? ","obj != ","Registry  root ","types empty? "," namespace values select "," namespace values "," namespace ","(send\n  (send\n    (send nil :namespace) :values) :select) + "," root ","types include? ","(send\n  (send\n    (ivar :@store) :values) :select) + ","@store values select ","@store values ","(send\n  (send\n    (send nil :thread_local_store) :values) :select) + "," thread_local_store values select "," thread_local_store values "," thread_local_store "," thread_local_store values_for_type ","types each "]}," YARD Registry save":{"type":"method","name":"save","children":[],"call":["Marshal  dump ","File  open ","@store save "," thread_local_store save "," thread_local_store "]}," YARD Registry load_yardoc":{"type":"method","name":"load_yardoc","children":[],"call":[" proxy_types update "," proxy_types "," namespace update "," namespace ","Marshal  load ","IO  read ","File  exists? ","@store load "," clear "," thread_local_store load "," thread_local_store "]}," YARD Registry load":{"type":"method","name":"load","children":[],"call":[" raise "," load_yardoc ","files is_a? "," save "," namespace size > "," namespace size "," namespace ","YARD  parse ","reload ! ","File  exists? "," yardoc_file ","@store keys size > ","@store keys size ","@store keys ","reparse ! "," thread_local_store keys size > "," thread_local_store keys size "," thread_local_store keys "," thread_local_store ","File  exist? "," namespace  namespace size  > "," namespace @store keys size  > "," namespace  thread_local_store keys size  > "," namespace  namespace size  "," namespace @store keys size  "," namespace  thread_local_store keys size  ","@store keys  namespace size  > ","@store keys @store keys size  > ","@store keys  thread_local_store keys size  > ","@store keys  namespace size  ","@store keys @store keys size  ","@store keys  thread_local_store keys size  "," thread_local_store keys  namespace size  > "," thread_local_store keys @store keys size  > "," thread_local_store keys  thread_local_store keys size  > "," thread_local_store keys  namespace size  "," thread_local_store keys @store keys size  "," thread_local_store keys  thread_local_store keys size  "]}," YARD Registry method_missing":{"type":"method","name":"method_missing","children":[],"call":[" instance send "," instance "," instance respond_to? "]}," YARD Rake YardocTask define":{"type":"method","name":"define","children":[],"call":["YARD CLI Yardoc  run "," options + "," files "," options "," task "," name "," desc "," after call "," after "," after is_a? "," before call "," before "," before is_a? ","yardoc run ","yardoc options []= "," verifier ","yardoc options ","YARD CLI Yardoc  new ","yardoc parse_arguments "," Rake  application last_comment "," Rake  application ","YARD CLI Stats  run "," stats_options + "," stats_options "," stats_options empty? "," Rake  application last_description ","YARD CLI Yardoc  new  run ","YARD CLI Yardoc  new  options []= ","YARD CLI Yardoc  new  options ","YARD CLI Yardoc  new  parse_arguments "]}," YARD Rake YardocTask initialize":{"type":"method","name":"initialize","children":[],"call":[" define ","ENV  [] split ","ENV  [] "," files "," options "," block_given? "," options << "," stats_options empty? "," stats_options "]}," YARD Parser TokenList convert_token":{"type":"method","name":"convert_token","children":[],"call":["sym set_text ","tk text + ","next_tk text ","tk text ","sym lex_state= ","lex lex_state ","TkSYMBOL  new ","tk char_no ","tk line_no ","lex token ","TkSYMBEG  === ","TkSYMBOL  new  set_text ","lex token  text ","TkSYMBOL  new  lex_state= "]}," YARD Parser TokenList parse_content":{"type":"method","name":"parse_content","children":[],"call":[" << "," convert_token ","lex token ","RubyLex  new ","RubyLex  new  token "]}," YARD Parser TokenList squeeze":{"type":"method","name":"squeeze","children":[],"call":["TokenList  new ","last is_a? ","t is_a? "," map "]}," YARD Parser TokenList push":{"type":"method","name":"push","children":[],"call":[" raise ","tok class "," parse_content ","tok is_a? "," concat ","tokens each "]}," YARD Parser TokenList to_s":{"type":"method","name":"to_s","children":[],"call":["(send nil :collect) join ","t text "," collect "]}," YARD Parser TokenList initialize":{"type":"method","name":"initialize","children":[],"call":[" << "]}," YARD Parser StatementList next_statement":{"type":"method","name":"next_statement","children":[],"call":["Statement  new ","statement empty? ","comments compact ","(const nil :TkSPACE) include? ","tk class ","level == ","tk is_a? ","tk class != ","block << ","TokenList  new ","block nil? ","tk class == ","open_block first == ","open_block first ","last_ns_tk class != ","open_block last ","last_ns_tk class ","(const nil :TkNL) include? ","(const nil :EXPR_END) include? ","last_tk lex_state ","open_block last == ","(const nil :TkSEMICOLON) include? ","open_parens == ","OPEN_BLOCK_TOKENS  include? ","last_tk lex_state == ","(const nil :TkDO) include? ","statement << ","stmt_number == ","stmt_number > ","(const nil :TkEND) include? ","comments pop ","comments first =~ ","comments first ","comments size == ","comments size ","comments << ","tk text gsub ","tk text ","before_last_tk class == ","before_last_tk class ","last_tk class == ","last_tk class ","(const nil :TkCOMMENT) include? ","(const nil :TkRPAREN) include? ","(const nil :TkLPAREN) include? ","@tokens shift ","comments compact  compact ","@tokens shift  class ","@tokens shift  is_a? ","@tokens shift  class != ","TokenList  new  << ","TokenList  new  nil? ","@tokens shift  class == ","open_TokenList  new  first == ","open_TokenList  new  first ","last_ns_@tokens shift  class != ","open_TokenList  new  last ","last_ns_@tokens shift  class ","last_@tokens shift  lex_state ","open_TokenList  new  last == ","last_@tokens shift  lex_state == ","comments compact  pop ","comments compact  first =~ ","comments compact  first ","comments compact  size == ","comments compact  size ","comments compact  << ","@tokens shift  text gsub ","@tokens shift  text ","before_last_@tokens shift  class == ","before_last_@tokens shift  class ","last_@tokens shift  class == ","last_@tokens shift  class "]}," YARD Parser StatementList parse_statements":{"type":"method","name":"parse_statements","children":[],"call":[" << "," next_statement "]}," YARD Parser StatementList initialize":{"type":"method","name":"initialize","children":[],"call":[" parse_statements "," raise ","content class ","content inspect ","TokenList  new ","content is_a? ","content dup "]}," YARD Parser Statement clean_tokens":{"type":"method","name":"clean_tokens","children":[],"call":["last_tk class == ","tk class ","last_tk class ","last_tk is_a? ","tk is_a? ","tokens reject "]}," YARD Parser Statement inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (lvar :buf) :map) join ","buf map ","buf last << ","tk text ","buf last ","buf push ","tk is_a? "," tokens each "," tokens "," tokens first line_no "," tokens first "]}," YARD Parser Statement initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Parser SourceParser find_handlers":{"type":"method","name":"find_handlers","children":[],"call":["sub handles? ","stmt tokens ","Handlers Base  subclasses find_all ","Handlers Base  subclasses "]}," YARD Parser SourceParser top_level_parse":{"type":"method","name":"top_level_parse","children":[],"call":[" log error ","Stack trace: + + ","Stack trace: + ","(send\n  (send\n    (send\n      (lvar :e) :backtrace) :[]\n    (irange\n      (int 0)\n      (int 5))) :map) join ","e backtrace [] map ","e backtrace [] ","e backtrace "," log ","stmt inspect ","stmt tokens first line_no ","stmt tokens first ","stmt tokens "," file ","e message ","e class class_name ","e class ","handler to_s "," log warn ","(str \"\\tin file '\") + + ","(str \"\\tin file '\") + ","undocerr message "," raise ","handler new process ","handler new "," find_handlers each "," find_handlers ","statements each "]}," YARD Parser SourceParser parse":{"type":"method","name":"parse","children":[],"call":[" top_level_parse "," raise ","content class ","content inspect ","StatementList  new ","content read ","content respond_to? ","IO  read "," parse_in_order ","files uniq "," log enter_level "," log ","Dir  [] ","File  join ","Dir  pwd ","(send\n  (lvar :paths) :map) flatten ","paths map ","paths is_a? "," post_process "," parse_statements "," parser_type= "," parser_type_for_filename "," file "," log debug "," parser_type ","(send\n  (send\n    (array\n      (lvar :paths)) :flatten) :map) flatten ","p include? ","(lvar :paths) flatten map ","(lvar :paths) flatten "," log warn ","e message capitalize ","e message ","Registry  checksums []= ","Registry  checksums "," log info ","Registry  checksums [] == ","Registry  checksums [] ","Registry  checksum_for ","File  file? ! ","File  file? ","(send\n  (block\n    (send\n      (send\n        (array\n          (lvar :paths)) :flatten) :map)\n    (args\n      (arg :p))\n    (if\n      (send\n        (const nil :File) :directory?\n        (lvar :p))\n      (dstr\n        (begin\n          (lvar :p))\n        (str \"/**/*.{rb,c}\"))\n      (lvar :p))) :map) flatten reject ","(send\n  (block\n    (send\n      (send\n        (array\n          (lvar :paths)) :flatten) :map)\n    (args\n      (arg :p))\n    (if\n      (send\n        (const nil :File) :directory?\n        (lvar :p))\n      (dstr\n        (begin\n          (lvar :p))\n        (str \"/**/*.{rb,c}\"))\n      (lvar :p))) :map) flatten ","(send\n  (send\n    (array\n      (lvar :paths)) :flatten) :map) map ","File  directory? ","Registry  checksums has_key? "," convert_encoding ","File  read_binary ","p =~ ","excluded any? ","Regexp  new ","path to_s ","excluded map ","File  cleanpath ","@parser parse "," parser_class new "," parser_class ","paths inspect ","cb call "," class after_parse_file_callbacks each "," class after_parse_file_callbacks "," class ","cb call == "," class before_parse_file_callbacks each "," class before_parse_file_callbacks "," log backtrace "," log level >= "," log level ","f length ","Dir  [] sort_by ","(send\n  (block\n    (send\n      (send\n        (array\n          (lvar :paths)) :flatten) :map)\n    (args\n      (arg :p))\n    (if\n      (send\n        (const nil :File) :directory?\n        (lvar :p))\n      (dstr\n        (begin\n          (lvar :p))\n        (str \"/**/*.{rb,c,cc,cxx,cpp}\"))\n      (lvar :p))) :map) flatten reject ","(send\n  (block\n    (send\n      (send\n        (array\n          (lvar :paths)) :flatten) :map)\n    (args\n      (arg :p))\n    (if\n      (send\n        (const nil :File) :directory?\n        (lvar :p))\n      (dstr\n        (begin\n          (lvar :p))\n        (str \"/**/*.{rb,c,cc,cxx,cpp}\"))\n      (lvar :p))) :map) flatten ","Registry  checksums key? ","String  new ","d length ","content read  class ","IO  read  class "," convert_encoding  class ","content read  inspect ","IO  read  inspect "," convert_encoding  inspect ","content read  read ","IO  read  read "," convert_encoding  read ","content read  respond_to? ","IO  read  respond_to? "," convert_encoding  respond_to? ","Dir  []  uniq ","(send\n  (lvar :paths) :map) flatten  uniq ","(send\n  (send\n    (array\n      (lvar :paths)) :flatten) :map) flatten  uniq "," parse_StatementList  new  ","Registry  Registry  checksum_for s []= ","Registry  Registry  checksum_for s ","Registry  Registry  checksum_for s [] == ","Registry  Registry  checksum_for s [] ","Registry  Registry  checksum_for _for ","Registry  Registry  checksum_for s has_key? "," parse_statements  parse "," parser_class new  parse ","Registry  Registry  checksum_for s key? "]}," YARD Parser SourceParser initialize":{"type":"method","name":"initialize","children":[],"call":["YARD Registry  root "," parser_type= ","OpenStruct  new ","(true) include? "]}," YARD Parser SourceParser parse_in_order":{"type":"method","name":"parse_in_order","children":[],"call":["files push ","e message "," new parse "," new "," log debug "," log ","file is_a? ","file last call ","file last ","file first ","file last is_a? ","files shift "," parser_type ","x length ","files sort_by ","cb call "," after_parse_list_callbacks each "," after_parse_list_callbacks ","cb call == "," before_parse_list_callbacks each "," before_parse_list_callbacks ","files dup ","OpenStruct  new ","e context ","OrderedParser  new parse ","OrderedParser  new "," before_parse_list_callbacks any? ","files shift s push ","files shift  is_a? ","files shift  last call ","files shift  last ","files shift  first ","files shift  last is_a? ","files shift s shift ","files shift s sort_by ","files shift s dup "]}," YARD Parser SourceParser parse_string":{"type":"method","name":"parse_string","children":[],"call":[" new parse ","StringIO  new "," new "]}," YARD Parser RubyLex read_escape":{"type":"method","name":"read_escape","children":[],"call":["res << "," read_escape ","(lvasgn :ch\n  (send nil :getc)) == "," getc "," ungetc ","(lvasgn :ch\n  (send nil :getc)) != ","ch == ","2 times ","3 times ","(lvasgn : getc \n  (send nil :getc)) == ","(lvasgn : getc \n  (send nil :getc)) != "," getc  == "]}," YARD Parser RubyLex identify_comment":{"type":"method","name":"identify_comment","children":[],"call":[" Token set_text "," Token ","comment << "," ungetc ","ch == "," getc "," getc  == "]}," YARD Parser RubyLex skip_inner_expression":{"type":"method","name":"skip_inner_expression","children":[],"call":["ch == ","nest zero? ","res << "," getc "," getc  == "]}," YARD Parser RubyLex identify_string":{"type":"method","name":"identify_string","children":[],"call":["(lvar :subtype) set_text "," Token ","Ltype2Token  [] ","DLtype2Token  [] ","str << "," getc "," peek =~ "," peek ","@ltype == "," read_escape ","ch == "," ungetc ","str << << "," skip_inner_expression ","@ltype != ","opener == ","nest == ","@quoted == "," getc  == "]}," YARD Parser RubyLex identify_number":{"type":"method","name":"identify_number","children":[],"call":[" Token set_text "," Token "," ungetc ","str << "," getc "," peek =~ "," peek "," peek !~ ","ch !~ "," peek == ","start == ","start dup ","start dup  << "," getc  !~ "," getc  == "," getc  dup "]}," YARD Parser RubyLex identify_quotation":{"type":"method","name":"identify_quotation","children":[],"call":[" identify_string ","PERCENT_PAREN  [] ","ch =~ "," getc ","PERCENT_LTYPE  [] "," getc  =~ "]}," YARD Parser RubyLex identify_here_document":{"type":"method","name":"identify_here_document","children":[],"call":[" Token set_text ","str dump "," Token ","Ltype2Token  [] ","@reader divert_read_from ","str << << ","str << ","l chomp ","l == ","l strip! ","l chomp! "," gets ","ch == ","reserve << "," getc "," ungetc ","quoted concat ","c =~ ","ch dup ","c != "," gets  chomp ","l  getc omp ","l  getc homp "," gets  == "," gets  strip! "," gets  chomp! ","l  getc omp! ","l  getc homp! "," getc  == "," getc h == "," get getc  "," unget getc  ","quoted  getc on getc at ","ch dup  concat "," getc  =~ "," getc  dup "," getc h dup "," getc  != "]}," YARD Parser RubyLex identify_identifier":{"type":"method","name":"identify_identifier","children":[],"call":[" Token set_text "," Token ","token [] =~ ","token [] ","token size - ","token size ","@lex_state == ","token concat "," getc "," peek == "," peek ","trans [] ","DEINDENT_CLAUSE  include? ","ACCEPTS_COLON  include? ","ENINDENT_CLAUSE  include? ","@lex_state != ","TkSymbol2Token  [] ","TkReading2Token  [] "," print ","RubyLex  debug? ","ch == "," ungetc ","(lvasgn :ch\n  (send nil :getc)) =~ "," peek =~ ","trans []  == ","trans []  != "," getc  == ","(lvasgn : getc \n  (send nil :getc)) =~ "]}," YARD Parser RubyLex identify_gvar":{"type":"method","name":"identify_gvar","children":[],"call":["tk set_text "," Token "," ungetc "," identify_identifier ","str << ","(lvasgn :ch\n  (send nil :getc)) =~ "," getc ","str << << ","(lvasgn : getc \n  (send nil :getc)) =~ "]}," YARD Parser RubyLex lex_int2":{"type":"method","name":"lex_int2","children":[],"call":[" p ","RubyLex  debug? "," printf ","io inspect "," identify_identifier "," peek =~ "," peek "," identify_number ","@OP def_rule "," throw ","@prev_char_no == "," proc "," Token set_text "," Token "," ungetc "," identify_gvar "," identify_quotation "," peek !~ ","@lex_state == "," getc "," peek == "," getc == ","t set_text ","tk set_text ","@OP def_rules "," identify_string "," prin identify_identifier f "," prin identify_number f "," prin Token f ","io inspec identify_identifier  ","io inspec identify_number  ","io inspec Token  "," iden identify_identifier ify_iden identify_identifier ifier "," iden identify_number ify_iden identify_number ifier "," iden Token ify_iden Token ifier "," iden identify_identifier ify_number "," iden identify_number ify_number "," iden Token ify_number ","  identify_identifier hrow ","  identify_number hrow ","  Token hrow "," Token se identify_identifier _ identify_identifier ex identify_identifier  "," Token se identify_number _ identify_number ex identify_number  "," Token se Token _ Token ex Token  "," unge identify_identifier c "," unge identify_number c "," unge Token c "," iden identify_identifier ify_gvar "," iden identify_number ify_gvar "," iden Token ify_gvar "," iden identify_identifier ify_quo identify_identifier a identify_identifier ion "," iden identify_number ify_quo identify_number a identify_number ion "," iden Token ify_quo Token a Token ion ","@lex_s identify_identifier a identify_identifier e == ","@lex_s identify_number a identify_number e == ","@lex_s Token a Token e == "," ge identify_identifier c "," ge identify_number c "," ge Token c "," ge identify_identifier c == "," ge identify_number c == "," ge Token c == "," identify_identifier  se identify_identifier _ identify_identifier ex identify_identifier  "," identify_number  se identify_number _ identify_number ex identify_number  "," Token  se Token _ Token ex Token  "," identify_identifier k se identify_identifier _ identify_identifier ex identify_identifier  "," identify_number k se identify_number _ identify_number ex identify_number  "," Token k se Token _ Token ex Token  "," Token  set_text "," iden identify_identifier ify_s identify_identifier ring "," iden identify_number ify_s identify_number ring "," iden Token ify_s Token ring "]}," YARD Parser RubyLex lex_init":{"type":"method","name":"lex_init","children":[],"call":[" lex_int2 "," Token set_text "," Token ","@OP def_rules "," identify_number "," ungetc "," peek =~ "," peek ","@OP def_rule "," throw ","@lex_state != ","@lex_state == "," catch "," proc ","op =~ ","str << "," read_escape ","ch == ","ch !~ "," getc "," identify_string ","tk ! "," identify_here_document "," print ","RubyLex  debug? ","str sub! ","str =~ ","line << ","line =~ ","@prev_char_no == "," identify_comment ","chars << ","(lvasgn :ch\n  (send nil :getc)) =~ ","SLex  new ","SLex  new  def_rules "," unget peek  ","SLex  new  def_rule "," cat getc  ","  peek at peek h "," pro peek  "," read_es peek ape "," getc  == "," peek h == "," getc  !~ "," peek h !~ "," get peek  "," Token set_text  ! "," identify_here_document  ! "," identify_here_do peek ument ","@prev_ getc ar_no == ","@prev_ peek har_no == "," identify_ peek omment "," getc ars << "," peek hars << ","(lvasgn : getc \n  (send nil :getc)) =~ ","(lvasgn : peek h\n  (send nil :get peek )) =~ "]}," YARD Parser RubyLex token":{"type":"method","name":"token","children":[],"call":["tk lex_state= "," lex_state "," p "," get_read ","TkError  new "," char_no "," line_no "," abort ","tk kind_of? ","@OP match "," catch "," set_token_position ","TkError  new  lex_state= ","@OP match  lex_state= ","TkError  new  kind_of? ","@OP match  kind_of? "]}," YARD Parser RubyLex lex":{"type":"method","name":"lex","children":[],"call":["tk nil? ","tk kind_of? ","line == "," get_read ","@continue ! ","(lvasgn :tk\n  (send nil :token)) kind_of? "," token "," catch "," token  nil? "," token  kind_of? "," get_read  == ","(lvasgn : token \n  (send nil :token)) kind_of? "]}," YARD Parser RubyLex peek":{"type":"method","name":"peek","children":[],"call":["@reader peek "]}," YARD Parser RubyLex peek_equal?":{"type":"method","name":"peek_equal?","children":[],"call":["@reader peek_equal "]}," YARD Parser RubyLex ungetc":{"type":"method","name":"ungetc","children":[],"call":["@reader ungetc "]}," YARD Parser RubyLex gets":{"type":"method","name":"gets","children":[],"call":["c == ","l concat "," getc "," getc  == ","l  getc on getc at "," get getc  "]}," YARD Parser RubyLex getc_of_rests":{"type":"method","name":"getc_of_rests","children":[],"call":["@reader getc_already_read "]}," YARD Parser RubyLex getc":{"type":"method","name":"getc","children":[],"call":["@reader getc "]}," YARD Parser RubyLex get_read":{"type":"method","name":"get_read","children":[],"call":["@reader get_read "]}," YARD Parser RubyLex char_no":{"type":"method","name":"char_no","children":[],"call":["@reader column "]}," YARD Parser RubyLex line_no":{"type":"method","name":"line_no","children":[],"call":["@reader line_num "]}," YARD Parser RubyLex initialize":{"type":"method","name":"initialize","children":[],"call":["BufferedReader  new "," lex_init "]}," YARD Parser RubyLex debug?":{"type":"method","name":"debug?","children":[],"call":[]}," YARD Parser RubyLex BufferedReader divert_read_from":{"type":"method","name":"divert_read_from","children":[],"call":["@content size ","@content []= "]}," YARD Parser RubyLex BufferedReader peek_equal":{"type":"method","name":"peek_equal","children":[],"call":["@content [] == ","@content [] ","str length "]}," YARD Parser RubyLex BufferedReader peek":{"type":"method","name":"peek","children":[],"call":["@content [] ","pos >= ","@offset + ","@offset +  >= "]}," YARD Parser RubyLex BufferedReader get_read":{"type":"method","name":"get_read","children":[],"call":["@content [] "]}," YARD Parser RubyLex BufferedReader ungetc":{"type":"method","name":"ungetc","children":[],"call":["@content [] == ","@content [] "," raise ","@offset <= "]}," YARD Parser RubyLex BufferedReader getc_already_read":{"type":"method","name":"getc_already_read","children":[],"call":[" getc "]}," YARD Parser RubyLex BufferedReader getc":{"type":"method","name":"getc","children":[],"call":["ch == ","@offset - ","@hwm < ","@content [] ","@offset >= ","@content []  == "]}," YARD Parser RubyLex BufferedReader column":{"type":"method","name":"column","children":[],"call":["@offset - "]}," YARD Parser RubyLex BufferedReader initialize":{"type":"method","name":"initialize","children":[],"call":["@content size ","@content << ","@content [] == ","@content [] ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","  * ","tab_width * - ","$` length % ","$` length ","tab_width * ","$& length ","line gsub! ","content split map ","content split ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  size ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  << ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  [] == ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  [] ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join ) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  split map ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  split "]}," YARD Parser RubyToken def_token":{"type":"method","name":"def_token","children":[],"call":[]}," YARD Parser RubyToken Token":{"type":"method","name":"Token","children":[],"call":["token new ","(send\n  (send\n    (lvar :token) :ancestors) :&\n  (array\n    (const nil :TkId)\n    (const nil :TkVal)\n    (const nil :TkOPASGN)\n    (const nil :TkUnknownChar))) empty? ","token ancestors & ","token ancestors "," Token ","tk [] ","IRB  fail ","(lvasgn :tk\n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","source [] ","token kind_of? ","token new  [] "," Token  [] ","source []  [] ","(lvasgn :token new \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","(lvasgn : Token \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","(lvasgn :source [] \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? "]}," YARD Parser RubyToken set_token_position":{"type":"method","name":"set_token_position","children":[],"call":[]}," YARD Parser RubyToken TkUnknownChar initialize":{"type":"method","name":"initialize","children":[],"call":["char_no chr "]}," YARD Parser RubyToken TkOPASGN initialize":{"type":"method","name":"initialize","children":[],"call":["TkReading2Token  [] ","op kind_of? ","TkReading2Token  []  kind_of? "]}," YARD Parser RubyToken TkOp name":{"type":"method","name":"name","children":[],"call":[" class op_name "," class "]}," YARD Parser RubyToken TkVal initialize":{"type":"method","name":"initialize","children":[],"call":[" set_text "]}," YARD Parser RubyToken TkId initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Parser RubyToken Token set_text":{"type":"method","name":"set_text","children":[],"call":[]}," YARD Parser RubyToken Token initialize":{"type":"method","name":"initialize","children":[],"call":[]}," log":{"type":"method","name":"log","children":[],"call":["YARD  logger ","YARD Logger  instance "]}," YARD logger":{"type":"method","name":"logger","children":[],"call":[]}," YARD Logger enter_level":{"type":"method","name":"enter_level","children":[],"call":[" level= "," level "]}," YARD Logger debug":{"type":"method","name":"debug","children":[],"call":[" level= "]}," YARD Logger initialize":{"type":"method","name":"initialize","children":[],"call":[" level= "," formatter= "," method "," show_backtraces= ","Mutex  new "," show_progress= "," io= ","Time  now "," warned= "]}," ClassHandler parse_superclass":{"type":"method","name":"parse_superclass","children":[],"call":["superclass method_name == ","superclass method_name ","cname =~ ","superclass namespace source ","superclass namespace ","superclass method_name type == ","superclass method_name type ","superclass parameters first source ","superclass parameters first ","superclass parameters ","methname == ","superclass method_name source ","superclass source ","superclass first type == ","superclass first type ","superclass first ","superclass type "," namespace path "," namespace ","superclass first == "," s ","superclass namespace source  =~ ","superclass method_name source  == "]}," YARD Handlers Base tokval_list":{"type":"method","name":"tokval_list","children":[],"call":["(send\n  (lvar :out) :map) compact ","e flatten join ","e flatten ","e pop ","e size == ","e size ","e empty? ","out map ","parencount < ","beforeparen == ","out last << ","token text ","out last ","out last clear ","tokval != ","TkWhitespace  === ","parencount == ","(const nil :TkTRUE) include? ! ","(const nil :TkTRUE) include? ","token class ","TkKW  === ","parencount > ","beforeparen > ","out << ","out last empty? ","out last empty? ! "," tokval ","tokenlist each "," tokval  != ","  tokval  "]}," YARD Handlers Base tokval":{"type":"method","name":"tokval","children":[],"call":["token text ","Regexp  new ","token text =~ ","token text to_i ","token text to_f ","token text [] to_sym ","token text [] ","t === ","accepted_types any? ","accepted_types push ","accepted_types include? ","accepted_types empty? "]}," YARD Handlers Base load_order_warn":{"type":"method","name":"load_order_warn","children":[],"call":[" log warn "," log "," parser file "," parser ","object path ","object type "]}," YARD Handlers Base ensure_namespace_loaded!":{"type":"method","name":"ensure_namespace_loaded!","children":[],"call":[" load_order_warn ","object parent "," log warn "," log ","object namespace children << ","object namespace children ","object namespace "," log debug ","BUILTIN_ALL  include? ! ","BUILTIN_ALL  include? ","object path ","object parent is_a? ! ","object parent is_a? ","retries > "," raise "," parser file "," parser ","retries <= "," callcc ","RUBY_PLATFORM  =~ "," parser load_order_errors "]}," YARD Handlers Base scope=":{"type":"method","name":"scope=","children":[],"call":["@parser scope= "," parser scope= "," parser "]}," YARD Handlers Base scope":{"type":"method","name":"scope","children":[],"call":["@parser scope "," parser scope "," parser "]}," YARD Handlers Base visibility=":{"type":"method","name":"visibility=","children":[],"call":["@parser visibility= "," parser visibility= "," parser "]}," YARD Handlers Base visibility":{"type":"method","name":"visibility","children":[],"call":["@parser visibility "," parser visibility "," parser "]}," YARD Handlers Base namespace=":{"type":"method","name":"namespace=","children":[],"call":["@parser namespace= "," parser namespace= "," parser "]}," YARD Handlers Base namespace":{"type":"method","name":"namespace","children":[],"call":["@parser namespace "," parser namespace "," parser "]}," YARD Handlers Base owner=":{"type":"method","name":"owner=","children":[],"call":["@parser owner= "," parser owner= "," parser "]}," YARD Handlers Base owner":{"type":"method","name":"owner","children":[],"call":["@parser owner "," parser owner "," parser "]}," YARD Handlers Base parse_block":{"type":"method","name":"parse_block","children":[],"call":[" scope= "," visibility= "," owner= "," namespace "," namespace= ","opts [] "," parser parse "," statement block "," statement "," parser "," scope "," visibility ","(pair\n  (sym :namespace)\n  (nil)) update "," raise ","(pair\n  (sym :namespace)\n  (nil)) update  [] "]}," YARD Handlers Base register":{"type":"method","name":"register","children":[],"call":["objects first ","objects size == ","objects size ","object dynamic= "," owner != "," namespace "," owner "," statement ","object source ","object is_a? ","object docstring= "," statement comments "," statement tokens first line_no "," statement tokens first "," statement tokens ","object line "," parser file "," parser ","object file "," statement comments ! ","object line= ","object file= ","object is_a? ! "," block_given? "," ensure_namespace_loaded! ","objects flatten each ","objects flatten ","object add_file "," statement line ","object namespace children << ","object namespace children ","object namespace "," ensure_loaded! ","object docstring line_range= "," statement comments_range ","object docstring ","object docstring add_tag ","object namespace tags ","object has_tag? ","object namespace has_tag? ","object namespace is_a? ","Tags Library  transitive_tags each ","Tags Library  transitive_tags ","object group= "," statement group ","object namespace groups ","object docstring hash_flag= "," statement comments_hash_flag "," expand_macro "," find_or_create_macro ","Docstring  new "," register_module_function "," register_dynamic "," register_group "," register_docstring "," register_visibility "," register_source "," register_file_info "," register_ensure_loaded "]}," YARD Handlers Base process":{"type":"method","name":"process","children":[],"call":[" raise "," include ","mod send ","Module  new ","Module  new  send "]}," YARD Handlers Base initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Handlers Base handles?":{"type":"method","name":"handles?","children":[],"call":["@handler == ","tokens first class ","tokens first ","tokens to_s =~ ","tokens to_s ","tokens first text == ","tokens first text "," raise "]}," YARD Handlers Base handles":{"type":"method","name":"handles","children":[],"call":["(or-asgn\n  (ivasgn :@handlers)\n  (array)) push ","(or-asgn\n  (ivasgn :@handlers)\n  (array)) concat "]}," YARD Handlers Base inherited":{"type":"method","name":"inherited","children":[],"call":["@@subclasses << "]}," YARD Handlers Base subclasses":{"type":"method","name":"subclasses","children":[],"call":[]}," YARD Handlers Base clear_subclasses":{"type":"method","name":"clear_subclasses","children":[],"call":[]}," AliasHandler process":{"type":"method","name":"process","children":[],"call":[" namespace aliases []= "," namespace aliases "," namespace ","o signature= ","o source= ","old_obj source ","old_obj signature ","o docstring= "," statement comments "," statement ","o file= "," parser file "," parser ","o line= "," statement tokens first line_no "," statement tokens first "," statement tokens ","o scope= "," scope ","o visibility= "," visibility "," register ","MethodObject  new "," namespace child ","names [] to_sym ","names [] "," raise "," statement tokens first text ","names size != ","names size "," tokval_list "," statement tokens [] ","t gsub ","(send\n  (lvar :tokens) :[]\n  (int 0)) map ","tokens [] "," statement tokens [] to_s split "," statement tokens [] to_s ","TkALIAS  === ","o add_file "," statement line ","names << ","obj jump source ","obj jump ","obj type "," statement parameters each "," statement parameters "," statement call? ","o jump first ","o jump "," statement map "," statement type == "," statement type ","  tokval_list pace aliases []= ","  tokval_list pace aliases ","  tokval_list pace "," namespace child  source "," namespace child  signature "," statement  statement tokens [] to_s split  first line_no "," statement  statement tokens [] to_s split  first "," statement  statement tokens [] to_s split  ","  tokval_list pace child "," tokval_list  [] to_sym "," tokval_list  [] "," statement  statement tokens [] to_s split  first text "," tokval_list  size != "," tokval_list  size "," statement  statement tokens [] to_s split  [] ","(send\n  (lvar : statement tokens [] to_s split ) :[]\n  (int 0)) map "," statement tokens [] to_s split  [] "," statement  statement tokens [] to_s split  [] to_s split "," statement  statement tokens [] to_s split  [] to_s "," tokval_list  << "]}," YARD Generators VisibilityGroupGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[" G "," visibility "]}," YARD Generators VisibilityGroupGenerator initialize":{"type":"method","name":"initialize","children":[],"call":[" options [] "," options "]}," YARD Generators UMLGenerator tidy":{"type":"method","name":"tidy","children":[],"call":["(send\n  (send\n    (lvar :data) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) compact join + ","(send\n  (send\n    (lvar :data) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) compact join ","(send\n  (send\n    (lvar :data) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) compact ","line =~ ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :indent) :*\n      (int 2)))) + ","  * ","indent * ","line empty? ","line gsub! ","data split map ","data split ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :indent) :*\n      (int 2)))) +  =~ ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :indent) :*\n      (int 2)))) +  empty? ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :indent) :*\n      (int 2)))) +  gsub! "]}," YARD Generators UMLGenerator method_list":{"type":"method","name":"method_list","children":[],"call":["o name ","vissort call ","o visibility ","o scope ","(send\n  (send\n    (lvar :object) :meths\n    (hash\n      (pair\n        (sym :inherited)\n        (false))\n      (pair\n        (sym :included)\n        (false))\n      (pair\n        (sym :visibility)\n        (send\n          (send nil :options) :[]\n          (sym :visibility))))) :reject) sort_by ","o is_attribute? ","object meths reject ","object meths "," options [] "," options ","vis == "," lambda ","meths sort_by ","o is_alias? ","meths reject ","o is_attribute? ! ","meths select "," remove_overriden_meths ","(send\n  (send\n    (lvar :object) : remove_overriden_meths \n    (hash\n      (pair\n        (sym :inherited)\n        (false))\n      (pair\n        (sym :included)\n        (false))\n      (pair\n        (sym :visibility)\n        (send\n          (send nil :options) :[]\n          (sym :visibility))))) :reject) sort_by ","(send\n  (send\n    (lvar :object) :object meths \n    (hash\n      (pair\n        (sym :inherited)\n        (false))\n      (pair\n        (sym :included)\n        (false))\n      (pair\n        (sym :visibility)\n        (send\n          (send nil :options) :[]\n          (sym :visibility))))) :reject) sort_by ","object  remove_overriden_meths  reject ","object object meths  reject ","object  remove_overriden_meths  ","object object meths  "," remove_overriden_meths  sort_by ","object meths  sort_by "," remove_overriden_meths  reject ","object meths  reject "," remove_overriden_meths  select ","object meths  select "," remove_overriden_ remove_overriden_meths  "," remove_overriden_object meths  "]}," YARD Generators UMLGenerator process_objects":{"type":"method","name":"process_objects","children":[],"call":[" process_objects "," namespaces each "," namespaces ","@objects []= ","o path ","object mixins each ","object mixins ","object superclass ","object superclass path ","object is_a? ","object path "]}," YARD Generators UMLGenerator h":{"type":"method","name":"h","children":[],"call":["text to_s gsub ","text to_s "]}," YARD Generators UMLGenerator format_path":{"type":"method","name":"format_path","children":[],"call":["object path gsub ","object path "]}," YARD Generators UMLGenerator unresolved_objects":{"type":"method","name":"unresolved_objects","children":[],"call":["(send\n  (send\n    (send\n      (ivar :@direction_paths) :values) :flatten) :select) uniq ","o is_a? ","@direction_paths values flatten select ","@direction_paths values flatten ","@direction_paths values "]}," YARD Generators UMLGenerator namespaces":{"type":"method","name":"namespaces","children":[],"call":["o is_a? ","object children select ","object children "]}," YARD Generators UMLGenerator init":{"type":"method","name":"init","children":[],"call":["@objects values "," process_objects ","@objects values  values "]}," YARD Generators UMLGenerator show_dependencies?":{"type":"method","name":"show_dependencies?","children":[],"call":[" options has_key? "," options "]}," YARD Generators UMLGenerator show_full_info?":{"type":"method","name":"show_full_info?","children":[],"call":[" options has_key? "," options "]}," YARD Generators UMLGenerator unresolved":{"type":"method","name":"unresolved","children":[],"call":["(send\n  (block\n    (send\n      (ivar :@objects) :select)\n    (args\n      (arg :o))\n    (send\n      (lvar :o) :is_a?\n      (const\n        (const nil :CodeObjects) :Proxy))) :map) join ","(send\n  (ivar :@objects) :select) map ","o is_a? ","@objects select "]}," YARD Generators UMLGenerator subgraph":{"type":"method","name":"subgraph","children":[],"call":[" render "," namespaces empty? "," namespaces "]}," YARD Generators UMLGenerator header":{"type":"method","name":"header","children":[],"call":[" tidy "," render "]}," YARD Generators UMLGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[]}," YARD Generators TagsGenerator render_tags":{"type":"method","name":"render_tags","children":[],"call":[" render "," current_object ","(pair\n  (sym :name)\n  (lvar :name)) update "]}," YARD Generators TagsGenerator has_tags?":{"type":"method","name":"has_tags?","children":[],"call":["object tags size > ","object tags size ","object tags "]}," YARD Generators TagsGenerator since":{"type":"method","name":"since","children":[],"call":[" render_tags "]}," YARD Generators TagsGenerator version":{"type":"method","name":"version","children":[],"call":[" render_tags "]}," YARD Generators TagsGenerator author":{"type":"method","name":"author","children":[],"call":[" render_tags "]}," YARD Generators TagsGenerator raise":{"type":"method","name":"raise","children":[],"call":[" render_tags "]}," YARD Generators TagsGenerator return":{"type":"method","name":"return","children":[],"call":[" render_tags "]}," YARD Generators TagsGenerator yieldparam":{"type":"method","name":"yieldparam","children":[],"call":[" render_tags "]}," YARD Generators TagsGenerator param":{"type":"method","name":"param","children":[],"call":[" render_tags "]}," YARD Generators TagsGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":["sections last []= ","size - - ","size - ","sections last ","sections last reverse each_with_index ","sections last reverse ","sections last size ","object tags size == ","object tags size ","object tags ","sections last size  - - ","sections last size  - ","sections last sections last size  ","object tags sections last size  == ","object tags sections last size  "]}," YARD Generators SourceGenerator format_code":{"type":"method","name":"format_code","children":[],"call":["(send\n  (lvar :lines) :map) join ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + ","lineno to_s ","  * ","longestline - ","lineno to_s length ","object line + ","object line ","lines map ","(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s length ","(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s ","lines size ","object source split ","object source ","(send\n  (lvar :object source split ) :map) join ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :object line + ) :to_s) :length)))) + + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s length ) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :object line + ) :to_s) :length)))) + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s length ) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :object line + ) :to_s) :length)))) + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s length ) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + ","object line +  to_s ","(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s length  - ","object line +  to_s length ","object source split  map ","(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :object source split ) :size)) to_s length ","(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :object source split ) :size)) to_s ","object source split  size "]}," YARD Generators SourceGenerator format_lines":{"type":"method","name":"format_lines","children":[],"call":["(send\n  (send\n    (send\n      (lvar :object) :source) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","object line + ","object line ","object source split map ","object source split ","object source "]}," YARD Generators SourceGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":["object source "]}," YARD Generators QuickDocGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[" G "]}," YARD Generators ModuleGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[" G "]}," YARD Generators MixinsGenerator has_mixins?":{"type":"method","name":"has_mixins?","children":[],"call":["object mixins empty? ! ","object mixins empty? ","object mixins "]}," YARD Generators MixinsGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[]}," YARD Generators MethodSummaryGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[]}," YARD Generators MethodSignatureGenerator has_signature?":{"type":"method","name":"has_signature?","children":[],"call":["object signature "]}," YARD Generators MethodSignatureGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[]}," YARD Generators MethodMissingGenerator method_missing_method_inherited?":{"type":"method","name":"method_missing_method_inherited?","children":[],"call":[" method_missing_method namespace != "," current_object "," method_missing_method namespace "," method_missing_method "]}," YARD Generators MethodMissingGenerator method_missing_method":{"type":"method","name":"method_missing_method","children":[],"call":["o scope == ","o scope ","o name == ","o name "," current_object meths find "," current_object meths "," current_object "]}," YARD Generators MethodMissingGenerator has_method_missing?":{"type":"method","name":"has_method_missing?","children":[],"call":[" method_missing_method "]}," YARD Generators MethodMissingGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[" G "]}," YARD Generators MethodListingGenerator meths_opts":{"type":"method","name":"meths_opts","children":[],"call":[" visibility "," scope "]}," YARD Generators MethodListingGenerator remove_ignored_meths!":{"type":"method","name":"remove_ignored_meths!","children":[],"call":["o is_attribute? ","o is_explicit? ! ","o is_explicit? ","o is_alias? "," ignored_meths [] include? ","o name "," ignored_meths [] ","o scope "," ignored_meths ","list reject! "]}," YARD Generators MethodListingGenerator ignored_meths":{"type":"method","name":"ignored_meths","children":[],"call":[]}," YARD Generators MethodListingGenerator included_meths_by_module":{"type":"method","name":"included_meths_by_module","children":[],"call":["meths empty? "," remove_ignored_meths! ","all_meths include? ","mixin meths select ","mixin meths "," meths_opts ","mixin is_a? "," current_object mixins each "," current_object mixins "," current_object "," current_object included_meths "," visibility "," scope "," meths_opts merge "," current_object included_meths  include? "]}," YARD Generators MethodListingGenerator inherited_meths_by_class":{"type":"method","name":"inherited_meths_by_class","children":[],"call":["meths empty? "," remove_ignored_meths! ","all_meths include? ","superclass meths select ","superclass meths "," meths_opts ","superclass is_a? "," current_object inheritance_tree [] each "," current_object inheritance_tree [] "," current_object inheritance_tree "," current_object "," current_object inherited_meths "," visibility "," scope "," current_object inherited_meths  include? "]}," YARD Generators MethodListingGenerator method_list":{"type":"method","name":"method_list","children":[],"call":["m name to_s downcase ","m name to_s ","m name ","meths sort_by "," remove_ignored_meths! "," current_object meths "," meths_opts "," current_object "," current_object meths  sort_by "," remove_ignored_ current_object meths ! "," current_object  current_object meths  ","  current_object meths _opts "]}," YARD Generators MethodListingGenerator has_included_methods?":{"type":"method","name":"has_included_methods?","children":[],"call":["meths size > ","meths size "," remove_ignored_meths! ","object included_meths "," visibility "," scope ","object included_meths  size > ","object included_meths  size "," remove_ignored_object included_meths ! ","object included_object included_meths  "]}," YARD Generators MethodListingGenerator has_inherited_methods?":{"type":"method","name":"has_inherited_methods?","children":[],"call":["meths size > ","meths size "," remove_ignored_meths! ","object inherited_meths "," visibility "," scope ","object is_a? ","object inherited_meths  size > ","object inherited_meths  size "," remove_ignored_object inherited_meths ! ","object inherited_object inherited_meths  "]}," YARD Generators MethodListingGenerator has_methods?":{"type":"method","name":"has_methods?","children":[],"call":[" method_list size > "," method_list size "," method_list "]}," YARD Generators MethodListingGenerator initialize":{"type":"method","name":"initialize","children":[],"call":[" options [] "," options "]}," YARD Generators MethodGenerator has_aliases?":{"type":"method","name":"has_aliases?","children":[],"call":["object aliases empty? ! ","object aliases empty? ","object aliases "]}," YARD Generators MethodGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[" G "]}," YARD Generators MethodDetailsGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[" G "]}," YARD Generators InheritanceGenerator has_inheritance_tree?":{"type":"method","name":"has_inheritance_tree?","children":[],"call":["object inheritance_tree size > ","object inheritance_tree size ","object inheritance_tree ","object is_a? "]}," YARD Generators InheritanceGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[]}," YARD Helpers UMLHelper uml_visibility":{"type":"method","name":"uml_visibility","children":[],"call":["object visibility "]}," YARD Helpers MethodHelper format_block":{"type":"method","name":"format_block","children":[],"call":[" h ","{| + + ","{| + ","(send\n  (send\n    (lvar :object) :tags\n    (sym :yieldparam)) :map) join ","t name ","object tags map ","object tags ","object has_tag? ","params join ","object tag types ","object tag ","object tag types  join ","object tags map  join "]}," YARD Helpers MethodHelper format_return_types":{"type":"method","name":"format_return_types","children":[],"call":[" format_types ","object tag types first ","object tag types ","object tag ","object tag types empty? ! ","object tag types empty? ","object has_tag? "]}," YARD Helpers MethodHelper format_args":{"type":"method","name":"format_args","children":[],"call":[" h ","object name ","object signature [] ","Regexp  quote ","object name to_s ","object signature ","(send\n  (send\n    (lvar :object) :parameters) :map) join ","n to_s ","object parameters map ","object parameters ","object parameters empty? ","object parameters nil? ","(send\n  (lvar :params) :map) join ","params map ","params empty? ","(send\n  (send\n    (lvar :object) :tags\n    (sym :param)) :any?) ! ","t name == ","param [] [] ","param [] ","t name ","object tags any? ","object tags ","param [] [] == ","params reject! ","object has_tag? ","param [] to_s [] == ","param [] to_s [] ","param [] to_s ","n [] == ","n [] ","(send\n  (lvar :object parameters ) :map) join ","object parameters  map ","object parameters  empty? ","object parameters  reject! "]}," YARD Helpers HtmlHelper html_syntax_highlight":{"type":"method","name":"html_syntax_highlight","children":[],"call":["(send\n  (lvar :tokenlist) :map) join "," h ","s text ","s class superclass class_name sub downcase ","s class superclass class_name sub ","s class superclass class_name ","s class superclass ","s class ","s class class_name sub downcase ","s class class_name sub ","s class class_name ","tokenlist map ","Parser TokenList  new "," send "," respond_to? ","source =~ "," options [] "," options "," object source_type "," object "," parse_lang_for_codeblock "," options highlight ","(send\n  (lvar :Parser TokenList  new ) :map) join ","Parser TokenList  new  map "]}," YARD Helpers HtmlHelper url_for":{"type":"method","name":"url_for","children":[],"call":["link + ","# + "," anchor_for ","File  relative_path "," serializer serialized_path "," serializer ","fromobj namespace "," current_object is_a? ! "," current_object is_a? "," current_object ","object namespace ","object is_a? ! ","object is_a? "," urlencode "," object is_a? ! "," object is_a? "," object ","obj namespace ","obj is_a? ! ","obj is_a? "," owner "," run_verifier empty? "," run_verifier "," object == ","Registry  root ","File  relative_path  + "," serializer serialized_path obj namespace ","fromobj namespace  namespace "," current_object  namespace "," object  namespace "," owner  namespace "," current_obj namespace ect is_a? ! "," current_obj namespace ect is_a? "," current_obj namespace ect ","obj namespace ect namespace ","obj namespace ect is_a? ! ","obj namespace ect is_a? "," obj namespace ect is_a? ! "," obj namespace ect is_a? "," obj namespace ect ","obj namespace  namespace ","obj namespace  is_a? ! ","obj namespace  is_a? "," obj namespace ect == "]}," YARD Helpers HtmlHelper anchor_for":{"type":"method","name":"anchor_for","children":[],"call":[" urlencode ","object to_s ","object path ","object type ","object name ","object scope ","object name to_s gsub ","object name to_s "]}," YARD Helpers HtmlHelper link_object":{"type":"method","name":"link_object","children":[],"call":[" url_for ","object is_a? "," serializer "," h ","object path ","otitle to_s "," P "," current_object "," link_url ","Registry  resolve ","obj is_a? ","obj == ","Registry  root ","title == ","obj path "," object ","obj nil? ","obj root? ","obj type ","obj to_s "," object relative_path "," object is_a? ","otitle ! ","<span class='object_link'> + + ","<span class='object_link'> + ","(send\n  (send nil :object) :name) join ","obj name ","obj sep "," object name ","obj parent == ","obj parent ","obj scope == ","obj scope ","obj title ","obj title != ","title to_s "," log warn ","obj inspect "," log "," P  is_a? ","Registry  resolve  is_a? ","Registry  resolve ect is_a? "," P  path ","Registry  resolve  path ","Registry  resolve ect path ","o h  to_s ","ootitle to_s  to_s ","otitle to_s  to_s "," current_ P  "," current_Registry  resolve  "," current_Registry  resolve ect ","  url_for _url ","  link_url _url ","Registry  resolve  == "," h  == ","otitle to_s  == ","title to_s  == ","  P  "," Registry  resolve  "," Registry  resolve ect ","Registry  resolve  nil? ","Registry  resolve  root? ","Registry  resolve  type ","Registry  resolve  to_s ","  P  relative_path "," Registry  resolve  relative_path "," Registry  resolve ect relative_path ","  P  is_a? "," Registry  resolve  is_a? "," Registry  resolve ect is_a? ","o h  ! ","ootitle to_s  ! ","otitle to_s  ! ","<span class='object_ url_for '> + + ","<span class='object_ link_url '> + + ","<span class=' P _link'> + + ","<span class='Registry  resolve _link'> + + ","<span class='Registry  resolve ect_link'> + + ","<span class='object_ url_for '> + ","<span class='object_ link_url '> + ","<span class=' P _link'> + ","<span class='Registry  resolve _link'> + ","<span class='Registry  resolve ect_link'> + ","(send\n  (send nil : P ) :name) join ","(send\n  (send nil :Registry  resolve ) :name) join ","(send\n  (send nil :Registry  resolve ect) :name) join ","Registry  resolve  name ","Registry  resolve  sep ","  P  name "," Registry  resolve  name "," Registry  resolve ect name ","Registry  resolve  parent == ","Registry  resolve  parent ","Registry  resolve  scope == ","Registry  resolve  scope ","obj  h  ","obj otitle to_s  ","obj title to_s  ","Registry  resolve  title ","obj  h  != ","obj otitle to_s  != ","obj title to_s  != ","Registry  resolve  title != "," h  to_s ","title to_s  to_s ","Registry  resolve  inspect "]}," YARD Helpers HtmlHelper format_types":{"type":"method","name":"format_types","children":[],"call":["list join ","list empty? ","<tt> + + ","<tt> + "," h + "," linkify "," h ","type gsub ","typelist map ","typelist is_a? ","1 == "]}," YARD Helpers HtmlHelper format_object_name_list":{"type":"method","name":"format_object_name_list","children":[],"call":["(send\n  (block\n    (send\n      (lvar :objects) :sort_by)\n    (args\n      (arg :o))\n    (send\n      (send\n        (send\n          (lvar :o) :name) :to_s) :downcase)) :map) join ","<span class='name'> + + ","<span class='name'> + "," linkify ","o name ","(send\n  (lvar :objects) :sort_by) map ","o name to_s downcase ","o name to_s ","objects sort_by "]}," YARD Helpers HtmlHelper resolve_links":{"type":"method","name":"resolve_links","children":[],"call":[" <tt> + + "," <tt> + "," linkify "," log warn ","... + + ","... + ","text [] gsub ","text [] ","Regexp  quote "," log ","obj path "," current_object path "," current_object ","obj is_a? "," P ","text gsub ","(begin\n  (lvar :sp)) + + ","(begin\n  (lvar :sp)) + ","match gsub ","(str \"In file `\") + "," current_object line "," current_object file ","Registry  resolve ","sp + "," link_file ","title == ","name =~ "," link_url ","name include? ","code_tags == "," object line "," object "," object file "," object is_a? ","<tt> + + ","<tt> + ","link == ","(if\n  (send\n    (lvar :match) :[]\n    (int 1))\n  (str \"...\")\n  (str \"\")) + + ","match [] ","(if\n  (send\n    (lvar :match) :[]\n    (int 1))\n  (str \"...\")\n  (str \"\")) + ","match [] gsub ","(if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + ","$` count "," object docstring line_range first "," object docstring line_range "," object docstring ","(str \"(.+)?(\\\\{\") match ","name [] == ","name [] ","@file filename ","name + + !~ ","name + + ","name + ","title empty? ","title =~ ","name == ","CGI  unescapeHTML ","(str \"In file `\") + + + + + ","(str \"In file `\") + + + + ","match [] delete ","(str \"In file `\") + + + ","(str \"In file `\") + + ","(if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + ","  linkify ify "," P  path ","Registry  resolve  path "," current_ P ect path "," current_Registry  resolve ect path "," current_ P ect "," current_Registry  resolve ect "," P  is_a? ","Registry  resolve  is_a? ","text []  gsub ","(str \"(.+)?(\\{\") match  gsub "," current_ P ect line "," current_Registry  resolve ect line "," current_object (if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) +  "," current_object (if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) +  "," current_ P ect file "," current_Registry  resolve ect file ","  linkify _file ","CGI  unescapeHTML  =~ ","  linkify _url ","CGI  unescapeHTML  include? ","  P ect line "," Registry  resolve ect line "," object (if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) +  "," object (if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) +  ","  P ect "," Registry  resolve ect ","  P ect file "," Registry  resolve ect file ","  P ect is_a? "," Registry  resolve ect is_a? "," linkify  == ","(if\n  (send\n    (lvar :text [] ) :[]\n    (int 1))\n  (str \"...\")\n  (str \"\")) + + ","(if\n  (send\n    (lvar :(str \"(.+)?(\\{\") match ) :[]\n    (int 1))\n  (str \"...\")\n  (str \"\")) + + ","text []  [] ","(str \"(.+)?(\\{\") match  [] ","(if\n  (send\n    (lvar :text [] ) :[]\n    (int 1))\n  (str \"...\")\n  (str \"\")) + ","(if\n  (send\n    (lvar :(str \"(.+)?(\\{\") match ) :[]\n    (int 1))\n  (str \"...\")\n  (str \"\")) + ","text []  [] gsub ","(str \"(.+)?(\\{\") match  [] gsub ","(if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil : P ect) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil : P ect) :docstring) :line_range) :first)\n      (int 1)))) + ","(if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :Registry  resolve ect) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :Registry  resolve ect) :docstring) :line_range) :first)\n      (int 1)))) + ","(if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :(if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :(if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range) :first)\n      (int 1)))) + ","(if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :(if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :(if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range) :first)\n      (int 1)))) + ","  P ect docstring line_range first "," Registry  resolve ect docstring line_range first "," object docstring (if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range first "," object docstring (if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range first ","  P ect docstring line_range "," Registry  resolve ect docstring line_range "," object docstring (if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range "," object docstring (if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range ","  P ect docstring "," Registry  resolve ect docstring ","(str \"(.+)?(\\\\{\") text []  ","(str \"(.+)?(\\\\{\") (str \"(.+)?(\\{\") match  ","CGI  unescapeHTML  [] == ","CGI  unescapeHTML  [] ","@file fileCGI  unescapeHTML  ","CGI  unescapeHTML  + + !~ ","CGI  unescapeHTML  + + ","CGI  unescapeHTML  + ","CGI  unescapeHTML  == ","text []  [] delete ","(str \"(.+)?(\\{\") match  [] delete ","(if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil : P ect) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil : P ect) :docstring) :line_range) :first)\n      (int 1)))) + ","(if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :Registry  resolve ect) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :Registry  resolve ect) :docstring) :line_range) :first)\n      (int 1)))) + ","(if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :(if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :(if\n  (ivar :@file)\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range) :first)\n      (int 1)))) + ","(if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :(if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :(if\n  (and\n    (defined?\n      (ivar :@file))\n    (ivar :@file))\n  (int 1)\n  (begin\n    (if\n      (send\n        (send\n          (send nil :object) :docstring) :line_range)\n      (send\n        (send\n          (send\n            (send nil :object) :docstring) :line_range) :first)\n      (int 1)))) + _range) :first)\n      (int 1)))) + "]}," YARD Helpers HtmlHelper htmlify":{"type":"method","name":"htmlify","children":[],"call":["<pre class=\"code\"> + + ","<pre class=\"code\"> + "," html_syntax_highlight ","CGI  unescapeHTML ","html gsub "," resolve_links ","SimpleMarkup  convert "," options [] "," options "," fix_typewriter "," fix_dash_dash ","MarkupHelper SimpleMarkup  convert "," markup_class new to_html "," markup_class new "," markup_class "," load_markup_provider ","doc to_html ","doc hard_breaks= ","doc respond_to? ","SimpleMarkupHtml  instance_variable_set "," url_for "," object ","html force_encoding ","Encoding  default_external ","html encode ","text encoding ","html respond_to? "," send "," respond_to? ","markup == ","(str \"code\") compact join ","(str \"code\") compact ","(sym :text) include? "," parse_codeblocks "," send dup ","  resolve_links _syntax_highlight ","  fix_typewriter _syntax_highlight ","  fix_dash_dash _syntax_highlight "," MarkupHelper SimpleMarkup  convert _syntax_highlight ","  markup_class new to_html _syntax_highlight "," doc to_html _syntax_highlight "," html encode _syntax_highlight "," html force_encoding _syntax_highlight ","  send _syntax_highlight ","  parse_codeblocks _syntax_highlight ","  send dup _syntax_highlight "," resolve_links  gsub "," fix_typewriter  gsub "," fix_dash_dash  gsub ","MarkupHelper SimpleMarkup  convert  gsub "," markup_class new to_html  gsub ","doc to_html  gsub ","html encode  gsub ","html force_encoding  gsub "," send  gsub "," parse_codeblocks  gsub "," send dup  gsub "," markup_class new to_ resolve_links  "," markup_class new to_ fix_typewriter  "," markup_class new to_ fix_dash_dash  "," markup_class new to_MarkupHelper SimpleMarkup  convert  "," markup_class new to_ markup_class new to_html  "," markup_class new to_doc to_html  "," markup_class new to_html encode  "," markup_class new to_html force_encoding  "," markup_class new to_ send  "," markup_class new to_ parse_codeblocks  "," markup_class new to_ send dup  ","doc to_ resolve_links  ","doc to_ fix_typewriter  ","doc to_ fix_dash_dash  ","doc to_MarkupHelper SimpleMarkup  convert  ","doc to_ markup_class new to_html  ","doc to_doc to_html  ","doc to_html encode  ","doc to_html force_encoding  ","doc to_ send  ","doc to_ parse_codeblocks  ","doc to_ send dup  "," markup_class new  to_html "," markup_class new  hard_breaks= "," markup_class new  respond_to? "," resolve_links  force_encoding "," fix_typewriter  force_encoding "," fix_dash_dash  force_encoding ","MarkupHelper SimpleMarkup  convert  force_encoding "," markup_class new to_html  force_encoding ","doc to_html  force_encoding ","html encode  force_encoding ","html force_encoding  force_encoding "," send  force_encoding "," parse_codeblocks  force_encoding "," send dup  force_encoding "," resolve_links  encode "," fix_typewriter  encode "," fix_dash_dash  encode ","MarkupHelper SimpleMarkup  convert  encode "," markup_class new to_html  encode ","doc to_html  encode ","html encode  encode ","html force_encoding  encode "," send  encode "," parse_codeblocks  encode "," send dup  encode "," resolve_links  respond_to? "," fix_typewriter  respond_to? "," fix_dash_dash  respond_to? ","MarkupHelper SimpleMarkup  convert  respond_to? "," markup_class new to_html  respond_to? ","doc to_html  respond_to? ","html encode  respond_to? ","html force_encoding  respond_to? "," send  respond_to? "," parse_codeblocks  respond_to? "," send dup  respond_to? ","( html_syntax_highlight  \"code\") compact join ","( html_syntax_highlight  \"code\") compact "]}," YARD Helpers HtmlHelper urlencode":{"type":"method","name":"urlencode","children":[],"call":["CGI  escape ","text to_s ","text force_encoding ","(send\n  (lvar :text) :gsub\n  (regexp\n    (str \"%[a-z0-9]{2}|\")\n    (begin\n      (const nil :URLMATCH))\n    (regopt :i))) tr ","% + ","$& ord to_s upcase ","$& ord to_s ","$& ord ","$& size > ","$& size ","text gsub ","text encoding ","text respond_to? ","text dup ","text force_encoding  to_s ","(send\n  (lvar :text) :gsub\n  (regexp\n    (str \"%[a-z0-9]{2}|\")\n    (begin\n      (const nil :URLMATCH))\n    (regopt :i))) tr  to_s ","text dup  to_s ","text force_encoding  force_encoding ","(send\n  (lvar :text) :gsub\n  (regexp\n    (str \"%[a-z0-9]{2}|\")\n    (begin\n      (const nil :URLMATCH))\n    (regopt :i))) tr  force_encoding ","text dup  force_encoding ","text force_text encoding oding ","(send\n  (lvar :text force_encoding ) :gsub\n  (regexp\n    (str \"%[a-z0-9]{2}|\")\n    (begin\n      (const nil :URLMATCH))\n    (regopt :i))) tr ","(send\n  (lvar :(send\n  (lvar :text) :gsub\n  (regexp\n    (str \"%[a-z0-9]{2}|\")\n    (begin\n      (const nil :URLMATCH))\n    (regopt :i))) tr ) :gsub\n  (regexp\n    (str \"%[a-z0-9]{2}|\")\n    (begin\n      (const nil :URLMATCH))\n    (regopt :i))) tr ","(send\n  (lvar :text dup ) :gsub\n  (regexp\n    (str \"%[a-z0-9]{2}|\")\n    (begin\n      (const nil :URLMATCH))\n    (regopt :i))) tr ","text force_encoding  gsub ","(send\n  (lvar :text) :gsub\n  (regexp\n    (str \"%[a-z0-9]{2}|\")\n    (begin\n      (const nil :URLMATCH))\n    (regopt :i))) tr  gsub ","text dup  gsub ","text force_encoding  encoding ","(send\n  (lvar :text) :gsub\n  (regexp\n    (str \"%[a-z0-9]{2}|\")\n    (begin\n      (const nil :URLMATCH))\n    (regopt :i))) tr  encoding ","text dup  encoding ","text text encoding oding ","text force_encoding  respond_to? ","(send\n  (lvar :text) :gsub\n  (regexp\n    (str \"%[a-z0-9]{2}|\")\n    (begin\n      (const nil :URLMATCH))\n    (regopt :i))) tr  respond_to? ","text dup  respond_to? ","text force_encoding  dup ","(send\n  (lvar :text) :gsub\n  (regexp\n    (str \"%[a-z0-9]{2}|\")\n    (begin\n      (const nil :URLMATCH))\n    (regopt :i))) tr  dup ","text dup  dup "]}," YARD Helpers HtmlHelper h":{"type":"method","name":"h","children":[],"call":["CGI  escapeHTML ","text to_s "]}," YARD Helpers FilterHelper is_module?":{"type":"method","name":"is_module?","children":[],"call":["object is_a? "]}," YARD Helpers FilterHelper is_class?":{"type":"method","name":"is_class?","children":[],"call":["object is_a? "]}," YARD Helpers FilterHelper is_namespace?":{"type":"method","name":"is_namespace?","children":[],"call":["object is_a? "]}," YARD Helpers FilterHelper is_method?":{"type":"method","name":"is_method?","children":[],"call":["object is_a? ","object type == ","object type "]}," Helpers BaseHelper format_object_type":{"type":"method","name":"format_object_type","children":[],"call":["object type to_s capitalize ","object type to_s ","object type ","object is_exception? "]}," Helpers BaseHelper format_types":{"type":"method","name":"format_types","children":[],"call":["list join ","list empty? ","list nil? "]}," Helpers BaseHelper format_object_name_list":{"type":"method","name":"format_object_name_list","children":[],"call":["(send\n  (lvar :objects) :sort_by) join ","o name to_s downcase ","o name to_s ","o name ","objects sort_by "]}," Helpers BaseHelper link_url":{"type":"method","name":"link_url","children":[],"call":[]}," Helpers BaseHelper link_object":{"type":"method","name":"link_object","children":[],"call":[" P path "," P ","object path "," P title ","object title ","obj title "]}," Helpers BaseHelper linkify":{"type":"method","name":"linkify","children":[],"call":[" link_object "," link_url ","args first include? ","args first ","args first is_a? "," link_file ","args [] ","(pair\n  (sym :target)\n  (str \"_parent\")) merge "," log warn "," log "," link_include_object ","YARD Registry  resolve "," object namespace "," object "," link_include_file ","File  file? ","obj format ","opts delete "," options dup "," options ","relpath =~ ","File  relative_path ","File  expand_path ","Dir  pwd "," link_YARD Registry  resolve ect "," link_include_YARD Registry  resolve ect "," YARD Registry  resolve ect namespace "," YARD Registry  resolve ect ","YARD Registry  resolve  format "," options dup  delete ","File  relative_path  =~ "]}," Helpers BaseHelper h":{"type":"method","name":"h","children":[],"call":[]}," YARD Generators FullDocGenerator generate_readme":{"type":"method","name":"generate_readme","children":[],"call":[" serializer serialize "," render "," serializer ","File  read "," readme_file "," format == "," format "]}," YARD Generators FullDocGenerator generate_index":{"type":"method","name":"generate_index","children":[],"call":[" serializer serialize "," render "," serializer "," format == "," format "," methods_to_show ","o constants empty? ! ","o constants empty? ","o constants ","o meths empty? ! ","o meths empty? ","o meths ","o type == ","o type ","all_objects find ","o path ","ns sort_by ","all_objects select "]}," YARD Generators FullDocGenerator generate_assets":{"type":"method","name":"generate_assets","children":[],"call":[" serializer serialize ","File  read "," serializer "," find_template "," template_path ","(send nil :css_file) each "," js_app_file "," js_file "," css_syntax_file "," css_file "," format == "," format "," css_custom_file "]}," YARD Generators FullDocGenerator readme_file":{"type":"method","name":"readme_file","children":[],"call":["(send\n  (send\n    (send\n      (array\n        (send\n          (send nil :options) :[]\n          (sym :readme))) :flatten) :compact) :find) to_s ","File  exists? ","readme to_s ","(send\n  (send nil :options) :[]\n  (sym :readme)) flatten compact find ","(send\n  (send nil :options) :[]\n  (sym :readme)) flatten compact ","(send\n  (send nil :options) :[]\n  (sym :readme)) flatten "," options [] "," options "]}," YARD Generators FullDocGenerator js_app_file":{"type":"method","name":"js_app_file","children":[],"call":[]}," YARD Generators FullDocGenerator js_file":{"type":"method","name":"js_file","children":[],"call":[]}," YARD Generators FullDocGenerator css_syntax_file":{"type":"method","name":"css_syntax_file","children":[],"call":[]}," YARD Generators FullDocGenerator css_file":{"type":"method","name":"css_file","children":[],"call":[]}," YARD Generators FullDocGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[" G "]}," YARD Generators DocstringGenerator has_docstring?":{"type":"method","name":"has_docstring?","children":[],"call":[" current_object docstring empty? ! "," current_object docstring empty? "," current_object docstring "," current_object "]}," YARD Generators DocstringGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[]}," YARD Generators DeprecatedGenerator is_deprecated?":{"type":"method","name":"is_deprecated?","children":[],"call":["object tag "]}," YARD Generators DeprecatedGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[]}," YARD Generators ConstructorGenerator constructor_method_inherited?":{"type":"method","name":"constructor_method_inherited?","children":[],"call":[" constructor_method namespace != "," current_object "," constructor_method namespace "," constructor_method "]}," YARD Generators ConstructorGenerator constructor_method":{"type":"method","name":"constructor_method","children":[],"call":["o scope == ","o scope ","o name == ","o name "," current_object meths find "," current_object meths "," current_object "]}," YARD Generators ConstructorGenerator has_constructor?":{"type":"method","name":"has_constructor?","children":[],"call":[" constructor_method "]}," YARD Generators ConstructorGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[" G "]}," YARD Generators ConstantsGenerator included_constants_by_module":{"type":"method","name":"included_constants_by_module","children":[],"call":["consts empty? ","all_consts include? ","superclass constants select ","superclass constants ","superclass is_a? "," current_object mixins each "," current_object mixins "," current_object "," current_object included_constants "," current_object instance_mixins each "," current_object instance_mixins "," current_object included_constants  include? "]}," YARD Generators ConstantsGenerator inherited_constants_by_class":{"type":"method","name":"inherited_constants_by_class","children":[],"call":["consts empty? ","all_consts include? ","superclass constants select ","superclass constants ","superclass is_a? "," current_object inheritance_tree [] each "," current_object inheritance_tree [] "," current_object inheritance_tree "," current_object "," current_object inherited_constants "," current_object inherited_constants  include? "]}," YARD Generators ConstantsGenerator has_included_constants?":{"type":"method","name":"has_included_constants?","children":[],"call":["object included_constants size > ","object included_constants size ","object included_constants "]}," YARD Generators ConstantsGenerator has_inherited_constants?":{"type":"method","name":"has_inherited_constants?","children":[],"call":["object inherited_constants size > ","object inherited_constants size ","object inherited_constants ","object is_a? "]}," YARD Generators ConstantsGenerator has_constants?":{"type":"method","name":"has_constants?","children":[],"call":["object constants size > ","object constants size ","object constants "]}," YARD Generators ConstantsGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":["object is_a? "]}," YARD Generators ClassGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[" G "]}," YARD Generators Base find_template":{"type":"method","name":"find_template","children":[],"call":["File  file? ","File  join "," class template_paths each "," class template_paths "," class ","File  File  join ile? "]}," YARD Generators Base template_path":{"type":"method","name":"template_path","children":[],"call":["File  join ","file to_s "," format to_s "," format "," template to_s "," template "]}," YARD Generators Base erb":{"type":"method","name":"erb","children":[],"call":["ERB  new "]}," YARD Generators Base render":{"type":"method","name":"render","children":[],"call":[" log warn "," log "," exit "," log error ","e backtrace [] join ","e backtrace [] ","e backtrace "," class ","e message ","e class class_name ","e class "," erb result "," binding "," erb ","(str \"<% \") + ","File  read ","(send\n  (lvar :locals) :map) join ","v inspect ","k to_s == ","k to_s ","locals map "," find_template "," template_path "," generator_name ","file to_s + ","file to_s "," current_object ","object is_a? "," render_method "," template_ template_path  "]}," YARD Generators Base render_section":{"type":"method","name":"render_section","children":[],"call":[" log warn "," class "," log ","section is_a? "," render "," send "," method arity != "," method arity "," method "," respond_to? "," run_before_sections is_a? "," run_before_sections ","section generate ","sobj generate ","section new ","opts update "," options dup "," options ","section <= ","section new  generate "," options dup  update "]}," YARD Generators Base render_sections":{"type":"method","name":"render_sections","children":[],"call":["data << "," render_section "," render_sections ","sections [] ","index + ","sections [] is_a? ","section is_a? ","sections each_with_index "," sections_for "]}," YARD Generators Base before_section":{"type":"method","name":"before_section","children":[],"call":[" raise "," before_section_filters push "," before_section_filters ","args size == ","args size ","args first "]}," YARD Generators Base sections_for":{"type":"method","name":"sections_for","children":[],"call":[]}," YARD Generators Base run_before_sections":{"type":"method","name":"run_before_sections","children":[],"call":["result is_a? "," log debug ","Calling before section filter for %s%s with `%s`, result = %s % ","section inspect "," class class_name "," class "," log ","meth call ","meth arity == ","meth arity "," method ","meth is_a? ","sec == ","sec nil? "," class before_section_filters each "," class before_section_filters "," before_section ","meth call  is_a? "," before_section  is_a? ","Calling before section filter for %s%s with `%s`, meth call  = %s % ","Calling before section filter for %s%s with `%s`,  before_section  = %s % "," method  call "," method  arity == "," method  arity ","  method od "," method  is_a? "]}," YARD Generators Base run_before_generate":{"type":"method","name":"run_before_generate","children":[],"call":["result is_a? ","meth call ","meth arity == ","meth arity "," method ","meth is_a? "," class before_generate_filters each "," class before_generate_filters "," class ","meth call  is_a? "," method  call "," method  arity == "," method  arity ","  method od "," method  is_a? "]}," YARD Generators Base run_before_list":{"type":"method","name":"run_before_list","children":[],"call":["result is_a? ","meth call ","meth arity == ","meth arity "," method ","meth is_a? "," class before_list_filters each "," class before_list_filters "," class ","meth call  is_a? "," method  call "," method  arity == "," method  arity ","  method od "," method  is_a? "]}," YARD Generators Base call_verifier":{"type":"method","name":"call_verifier","children":[],"call":[" verifier call "," verifier "," verifier respond_to? "," send "," verifier is_a? "]}," YARD Generators Base generate":{"type":"method","name":"generate","children":[],"call":[" serializer after_serialize "," serializer "," ignore_serializer ! "," ignore_serializer ","output << "," serializer serialize ","objout empty? ! ","objout empty? ","objout << "," render_sections "," run_before_generate is_a? "," run_before_generate "," call_verifier is_a? "," call_verifier ","object is_a? ","list each "," serializer before_serialize ","FalseClass  === "," run_before_list ","Registry  root ","list flatten ","object is_a? ! ","list flatten  each "," run_before_list flatten  ","list flatten  flatten "]}," YARD Generators Base generator_name":{"type":"method","name":"generator_name","children":[],"call":[" class to_s split last gsub downcase "," class to_s split last gsub "," class to_s split last "," class to_s split "," class to_s "," class "]}," YARD Generators Base initialize":{"type":"method","name":"initialize","children":[],"call":[" extend "," format == "," format "," options [] "," options ","SymbolHash  [] update update ","SymbolHash  [] update ","SymbolHash  [] "]}," YARD Generators Base G":{"type":"method","name":"G","children":[],"call":["generator new "," options ","SymbolHash  [] update ","SymbolHash  [] "]}," YARD Generators Base before_list_filters":{"type":"method","name":"before_list_filters","children":[],"call":[]}," YARD Generators Base before_list":{"type":"method","name":"before_list","children":[],"call":[" before_list_filters push "," before_list_filters "]}," YARD Generators Base before_generate_filters":{"type":"method","name":"before_generate_filters","children":[],"call":[]}," YARD Generators Base before_generate":{"type":"method","name":"before_generate","children":[],"call":[" before_generate_filters push "," before_generate_filters "]}," YARD Generators Base before_section_filters":{"type":"method","name":"before_section_filters","children":[],"call":[]}," YARD Generators Base register_template_path":{"type":"method","name":"register_template_path","children":[],"call":[" template_paths unshift "," template_paths "]}," YARD Generators Base template_paths":{"type":"method","name":"template_paths","children":[],"call":[]}," YARD Generators AttributesGenerator has_attributes?":{"type":"method","name":"has_attributes?","children":[],"call":[" current_object class_attributes size + > "," current_object class_attributes size + "," current_object instance_attributes size "," current_object instance_attributes "," current_object "," current_object class_attributes size "," current_object class_attributes "]}," YARD Generators AttributesGenerator includes":{"type":"method","name":"includes","children":[],"call":[" extend "," format == "," format "]}," YARD Generators AttributesGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[]}," SymbolHash update":{"type":"method","name":"update","children":[],"call":[" []= ","hsh each ","hash each "]}," SymbolHash has_key?":{"type":"method","name":"has_key?","children":[],"call":["key to_sym "]}," SymbolHash delete":{"type":"method","name":"delete","children":[],"call":["key to_sym "]}," SymbolHash []":{"type":"method","name":"[]","children":[],"call":["key to_sym "]}," SymbolHash []=":{"type":"method","name":"[]=","children":[],"call":["value to_sym ","value instance_of? ","key to_sym "]}," SymbolHash initialize":{"type":"method","name":"initialize","children":[],"call":[]}," String camelcase":{"type":"method","name":"camelcase","children":[],"call":["1 upcase ","(send nil :gsub\n  (regexp\n    (str \"([a-z])_([a-z])\")\n    (regopt :i))) sub ","1 + ","2 upcase "," gsub ","(send\n  (block\n    (send nil :gsub\n      (regexp\n        (str \"([a-z])_([a-z])\")\n        (regopt :i)))\n    (args)\n    (send\n      (nth-ref 1) :+\n      (send\n        (nth-ref 2) :upcase))) :sub\n  (regexp\n    (str \"^(.)\")\n    (regopt))) gsub ","(send nil :gsub\n  (regexp\n    (str \"/(.?)\")\n    (regopt))) gsub ",":: + "]}," String underscore":{"type":"method","name":"underscore","children":[],"call":[" gsub downcase "," gsub "," gsub downcase gsub "]}," Module namespace":{"type":"method","name":"namespace","children":[],"call":[" name split [] join "," name split [] "," name split "," name "]}," Module class_name":{"type":"method","name":"class_name","children":[],"call":[" name split last "," name split "," name "]}," Formatter call":{"type":"method","name":"call","children":[],"call":["sev downcase "]}," File relative_path":{"type":"method","name":"relative_path","children":[],"call":[]}," YARD CodeObjects RootObject inspect":{"type":"method","name":"inspect","children":[],"call":[]}," YARD CodeObjects RootObject path":{"type":"method","name":"path","children":[],"call":[]}," P":{"type":"method","name":"P","children":[],"call":["YARD Registry  resolve ","name nil? "]}," YARD CodeObjects Proxy to_obj":{"type":"method","name":"to_obj","children":[],"call":["Registry  resolve ","(if\n  (ivar :@imethod)\n  (const nil :ISEP)\n  (str \"\")) + ","@name to_s ","@obj name ","@obj namespace ","@obj path include? ! ","@obj path include? ","@obj path ","@origname include? ","@obj name  to_s ","Registry  resolve  name ","Registry  resolve  namespace ","Registry  resolve  path include? ! ","Registry  resolve  path include? ","Registry  resolve  path "]}," YARD CodeObjects Proxy method_missing":{"type":"method","name":"method_missing","children":[],"call":[" raise "," path "," log warn "," log ","obj __send__ "," to_obj "," to_obj __send__ "," to_obj  __send__ "," to_ to_obj  "," to_ to_obj  __send__ "]}," YARD CodeObjects Proxy respond_to?":{"type":"method","name":"respond_to?","children":[],"call":["obj respond_to? "," to_obj "," to_obj respond_to? "," to_obj  respond_to? "," to_ to_obj  "," to_ to_obj  respond_to? "]}," YARD CodeObjects Proxy object_id":{"type":"method","name":"object_id","children":[],"call":["obj object_id "," to_obj "," to_obj   to_obj ect_id "," to_ to_obj  "]}," YARD CodeObjects Proxy kind_of?":{"type":"method","name":"kind_of?","children":[],"call":[" class <= "," class "]}," YARD CodeObjects Proxy instance_of?":{"type":"method","name":"instance_of?","children":[],"call":[" class == "," class "]}," YARD CodeObjects Proxy type=":{"type":"method","name":"type=","children":[],"call":["Registry  proxy_types []= ","type to_sym "," path ","Registry  proxy_types "]}," YARD CodeObjects Proxy type":{"type":"method","name":"type","children":[],"call":["Registry  proxy_types [] "," path ","Registry  proxy_types ","obj type "," to_obj "," to_obj type "," to_obj  type "," to_ to_obj  "," to_ to_obj  type "]}," YARD CodeObjects Proxy class":{"type":"method","name":"class","children":[],"call":["obj class "," to_obj "," to_obj class "," to_obj  class "," to_ to_obj  "," to_ to_obj  class "]}," YARD CodeObjects Proxy ==":{"type":"method","name":"==","children":[],"call":[" path == ","other path "," path ","other respond_to? "]}," YARD CodeObjects Proxy <=>":{"type":"method","name":"<=>","children":[],"call":[" path <=> ","other path "," path ","other respond_to? "]}," YARD CodeObjects Proxy ===":{"type":"method","name":"===","children":[],"call":[" class <= ","other class "," class ","obj === "," to_obj "," to_obj === "," to_obj  === "," to_ to_obj  "," to_ to_obj  === "]}," YARD CodeObjects Proxy is_a?":{"type":"method","name":"is_a?","children":[],"call":[" class <= "," class ","obj is_a? "," to_obj "," to_obj is_a? "," to_obj  is_a? "," to_ to_obj  "," to_ to_obj  is_a? "]}," YARD CodeObjects Proxy path":{"type":"method","name":"path","children":[],"call":[" name to_s "," name ","(if\n  (ivar :@imethod)\n  (const nil :ISEP)\n  (str \"\")) + ","@namespace == ","Registry  root ","obj path "," to_obj ","(send\n  (send nil :namespace) :path) join "," namespace path "," namespace "," name to_s =~ ","@origname =~ ","@namespace root? "," proxy_path "," to_obj path "," to_obj  path "," to_ to_obj  "," to_ to_obj  path "]}," YARD CodeObjects Proxy inspect":{"type":"method","name":"inspect","children":[],"call":[" path ","obj inspect "," to_obj "," to_obj inspect "," to_obj  inspect "," to_ to_obj  "," to_ to_obj  inspect "]}," YARD CodeObjects Proxy initialize":{"type":"method","name":"initialize","children":[],"call":["Registry  root ","@name gsub! ","@name =~ "," raise ","@namespace is_a? ","name to_sym ","Proxy  new ","$` empty? ","name include? ","name =~ ","name [] ","namespace == ","namespace ! ","@namespace value ","@namespace namespace "," type= ","@namespace value =~ ","constant mapping for  + ","type inspect ","name to_sym  gsub! ","@name []  gsub! ","name to_sym  =~ ","@name []  =~ ","Registry  root  is_a? ","Proxy  new  is_a? ","name to_sym space is_a? ","@Proxy  new  is_a? ","@Registry  root  is_a? ","@name [] space is_a? ","name []  to_sym ","name []  include? ","name []  =~ ","name []  [] ","Proxy  new  == ","Registry  root  == ","name [] space == ","Proxy  new  ! ","Registry  root  ! ","name [] space ! ","Registry  root  value ","Proxy  new  value ","name to_sym space value ","@Proxy  new  value ","@Registry  root  value ","@name [] space value ","Registry  root  namespace ","Proxy  new  namespace ","name to_sym space namespace ","@Proxy  new  Proxy  new  ","@Registry  root  Registry  root  ","@name [] space name [] space ","Registry  root  value =~ ","Proxy  new  value =~ ","name to_sym space value =~ ","@Proxy  new  value =~ ","@Registry  root  value =~ ","@name [] space value =~ "]}," CodeObjects NamespaceObject cvars":{"type":"method","name":"cvars","children":[],"call":["o is_a? "," children select "," children "]}," CodeObjects NamespaceObject included_constants":{"type":"method","name":"included_constants","children":[],"call":["o2 name == ","o name ","o2 name ","list find "," child ","mixin constants reject ","mixin constants ","mixin is_a? "," mixins reverse inject "," mixins reverse "," mixins ","mixin respond_to? "," instance_mixins reverse inject "," instance_mixins reverse "," instance_mixins "," instance_mixins inject "]}," CodeObjects NamespaceObject constants":{"type":"method","name":"constants","children":[],"call":["consts + "," included_constants ","opts [] ","o is_a? "," children select "," children ","SymbolHash  [] update ","SymbolHash  [] ","SymbolHash  [] update  [] "]}," CodeObjects NamespaceObject included_meths":{"type":"method","name":"included_meths","children":[],"call":["o2 scope == ","o scope ","o2 scope ","o2 name == ","o name ","o2 name ","list find "," child ","mixin meths reject ","mixin meths ","mixin is_a? "," mixins reverse inject "," mixins reverse "," mixins ","(send\n  (send\n    (array\n      (send\n        (lvar :opts) :[]\n        (sym :scope))) :flatten) :map) flatten ","list + ","ExtendedMethodObject  new ","arr map! ","scope == ","opts merge ","(send\n  (lvar :opts) :[]\n  (sym :scope)) flatten map ","(send\n  (lvar :opts) :[]\n  (sym :scope)) flatten ","opts [] ","SymbolHash  [] update ","SymbolHash  [] "," mixins inject ","(send\n  (send\n    (array\n      (send\n        (lvar :SymbolHash  [] update ) :[]\n        (sym :scope))) :flatten) :map) flatten ","SymbolHash  [] update  merge ","(send\n  (lvar :SymbolHash  [] update ) :[]\n  (sym :scope)) flatten map ","(send\n  (lvar :SymbolHash  [] update ) :[]\n  (sym :scope)) flatten ","SymbolHash  [] update  [] "]}," CodeObjects NamespaceObject meths":{"type":"method","name":"meths","children":[],"call":["ourmeths + "," included_meths ","opts [] ","opts [] include? ","o scope ","o visibility ","o is_a? "," children select "," children ","opts []= ","(send\n  (lvar :opts) :[]\n  (sym :scope)) flatten ","(send\n  (lvar :opts) :[]\n  (sym :visibility)) flatten ","SymbolHash  [] update ","SymbolHash  [] ","SymbolHash  [] update  [] ","SymbolHash  [] update  [] include? ","SymbolHash  [] update  []= ","(send\n  (lvar :SymbolHash  [] update ) :[]\n  (sym :scope)) flatten ","(send\n  (lvar :SymbolHash  [] update ) :[]\n  (sym :visibility)) flatten "]}," CodeObjects NamespaceObject child":{"type":"method","name":"child","children":[],"call":["obj [] != ","obj [] ","opts each "," children find "," children ","SymbolHash  [] ","o name == ","opts to_sym ","o name ","opts is_a? ! ","opts is_a? ","(if\n  (send\n    (lvar :value) :is_a?\n    (const nil :Array))\n  (send\n    (lvar :value) :include?\n    (send\n      (lvar :obj) :[]\n      (lvar :meth)))\n  (send\n    (send\n      (lvar :obj) :[]\n      (lvar :meth)) :==\n    (lvar :value))) ! ","obj [] == ","value include? ","value is_a? ","SymbolHash  []  each ","SymbolHash  []  to_sym ","SymbolHash  []  is_a? ! ","SymbolHash  []  is_a? "]}," CodeObjects NamespaceObject instance_attributes":{"type":"method","name":"instance_attributes","children":[],"call":[" attributes [] "," attributes "]}," CodeObjects NamespaceObject class_attributes":{"type":"method","name":"class_attributes","children":[],"call":[" attributes [] "," attributes "]}," CodeObjects NamespaceObject initialize":{"type":"method","name":"initialize","children":[],"call":["SymbolHash  [] ","SymbolHash  new ","CodeObjectList  new "]}," CodeObjects MethodObject sep":{"type":"method","name":"sep","children":[],"call":[" scope == "," scope "," namespace != ","YARD Registry  root "," namespace "]}," CodeObjects MethodObject name":{"type":"method","name":"name","children":[],"call":[" sep + "," to_s "," sep "," sep == ","(send\n  (begin\n    (if\n      (lvar :prefix)\n      (begin\n        (if\n          (send\n            (send nil :sep) :==\n            (const nil :ISEP))\n          (send nil :sep)\n          (str \"\")))\n      (str \"\"))) :+\n  (send\n    (super) :to_s)) to_sym ","(if\n  (lvar :prefix)\n  (begin\n    (if\n      (send\n        (send nil :sep) :==\n        (const nil :ISEP))\n      (send nil :sep)\n      (str \"\")))\n  (str \"\")) + "]}," CodeObjects MethodObject path":{"type":"method","name":"path","children":[],"call":[" sep + "," sep "," namespace path == "," namespace path "," namespace "," namespace ! "]}," CodeObjects MethodObject aliases":{"type":"method","name":"aliases","children":[],"call":["list << ","o scope == "," scope ","o scope ","aname == "," name "," namespace aliases each "," namespace aliases "," namespace "," namespace is_a? "]}," CodeObjects MethodObject is_explicit?":{"type":"method","name":"is_explicit?","children":[],"call":[" explicit "]}," CodeObjects MethodObject is_alias?":{"type":"method","name":"is_alias?","children":[],"call":[" namespace aliases has_key? "," namespace aliases "," namespace "," namespace is_a? "," namespace aliases key? "]}," CodeObjects MethodObject is_attribute?":{"type":"method","name":"is_attribute?","children":[],"call":[" namespace attributes [] has_key? "," name to_s gsub "," name to_s "," name "," namespace attributes [] "," scope "," namespace attributes "," namespace ","attr_obj [] "," name to_s =~ "," namespace attributes [] [] "," namespace is_a? ","info [] "," attr_info "," namespace attributes [] []  [] "," attr_info  [] "," attr_ attr_info  "]}," CodeObjects MethodObject visibility=":{"type":"method","name":"visibility=","children":[],"call":["v to_sym "]}," CodeObjects MethodObject scope=":{"type":"method","name":"scope=","children":[],"call":["v to_sym ","YARD Registry  register ","YARD Registry  delete ","@scope == ","other visibility= "," class new "," name "," namespace "," class ","v == ","v to_sym  == "," class new  visibility= "]}," CodeObjects MethodObject initialize":{"type":"method","name":"initialize","children":[],"call":[" scope= "," visibility= "," parameters= ","other visibility= "," class new "," class ","scope == "," class new  visibility= "]}," CodeObjects ClassObject superclass=":{"type":"method","name":"superclass=","children":[],"call":[" raise "," P ","@superclass inspect ","@superclass == ","Proxy  new "," namespace namespace "," namespace "," namespace != ","YARD Registry  root "," name == ","@superclass name "," name "," inspect ","object is_a? ","object is_a? ! "," P  inspect ","Proxy  new  inspect "," P  == ","Proxy  new  == "," P  name ","Proxy  new  name "]}," CodeObjects ClassObject inherited_constants":{"type":"method","name":"inherited_constants","children":[],"call":["o2 name == ","o name ","o2 name ","list find "," child ","superclass constants reject ","superclass constants ","superclass is_a? "," inheritance_tree [] inject "," inheritance_tree [] "," inheritance_tree "]}," CodeObjects ClassObject constants":{"type":"method","name":"constants","children":[],"call":["(lvar :opts) + "," inherited_constants ","opts [] ","SymbolHash  [] update ","SymbolHash  [] ","(lvar :SymbolHash  [] update ) + ","SymbolHash  [] update  [] "]}," CodeObjects ClassObject inherited_meths":{"type":"method","name":"inherited_meths","children":[],"call":["o2 scope == ","o scope ","o2 scope ","o2 name == ","o name ","o2 name ","list find "," child ","superclass meths reject ","superclass meths ","superclass is_a? "," inheritance_tree [] inject "," inheritance_tree [] "," inheritance_tree ","opts [] "]}," CodeObjects ClassObject meths":{"type":"method","name":"meths","children":[],"call":["(lvar :opts) + "," inherited_meths ","opts [] ","SymbolHash  [] update ","SymbolHash  [] ","o2 scope == ","o scope ","o2 scope ","o2 name == ","o name ","o2 name ","list find "," inherited_meths reject ","(lvar :SymbolHash  [] update ) + ","SymbolHash  [] update  [] "]}," CodeObjects ClassObject inheritance_tree":{"type":"method","name":"inheritance_tree","children":[],"call":[" superclass inheritance_tree "," superclass "," superclass respond_to? ","list << "," superclass == "," P "," superclass is_a? ","(self) + "," mixins ","(send\n  (lvar :list) :map) flatten ","m inheritance_tree ","m respond_to? ","list map ","(send\n  (lvar :list) :map) flatten uniq ","m == ","(self) +  << ","(send\n  (lvar :(self) + ) :map) flatten ","(self) +  map ","(send\n  (lvar :(self) + ) :map) flatten uniq "]}," CodeObjects ClassObject is_exception?":{"type":"method","name":"is_exception?","children":[],"call":["BUILTIN_EXCEPTIONS_HASH  has_key? ","o path "," inheritance_tree reverse any? "," inheritance_tree reverse "," inheritance_tree ","BUILTIN_EXCEPTIONS_HASH  key? "]}," CodeObjects ClassObject initialize":{"type":"method","name":"initialize","children":[],"call":[" superclass "," P == "," P "," is_exception? "," P path "]}," YARD CodeObjects Base format_source":{"type":"method","name":"format_source","children":[],"call":["source gsub ","source split last [] length ","source split last [] ","source split last ","source split ","source chomp! ","last [] length ","last [] ","source chomp ","source chomp  gsub ","source split source split last  [] length ","source chomp  split last [] length ","source split source split last  [] ","source chomp  split last [] ","source split source split last  ","source chomp  split last ","source chomp  split ","source chomp  chomp! ","source split last  [] length ","source split last  [] ","source chomp  chomp "]}," YARD CodeObjects Base parse_comments":{"type":"method","name":"parse_comments","children":[],"call":["@docstring gsub! ","@docstring << << ","@docstring << ","tag_name ! ","raw_buf << ","line gsub ","tag_buf << ","last_line =~ ","empty ! ","indent >= ","tag_buf dup ","line =~ "," log warn "," path "," log ","@tags << ","tagfactory send ","raw_buf join ","tagfactory method arity == ","tagfactory method arity ","tagfactory method ","tagfactory respond_to? ","Tags Library  new ","indent <= ","indent < ","comments size == ","comments size ","line [] length ","line [] ","(send\n  (lvar :comments) :+\n  (array\n    (str \"\"))) each_with_index ","comments + ","comments first [] length ","comments first [] ","comments first ","comments split ","comments is_a? ","comments empty? ","line [] length  >= ","Tags Library  new  send ","Tags Library  new  method arity == ","Tags Library  new  method arity ","Tags Library  new  method ","Tags Library  new  respond_to? ","line [] length  <= ","line [] length  < ","comments split  size == ","comments split  size ","(send\n  (lvar :comments split ) :+\n  (array\n    (str \"\"))) each_with_index ","comments split  + ","comments split  first [] length ","comments split  first [] ","comments split  first ","comments split  split ","comments split  is_a? ","comments split  empty? "]}," YARD CodeObjects Base sep":{"type":"method","name":"sep","children":[],"call":[]}," YARD CodeObjects Base has_tag?":{"type":"method","name":"has_tag?","children":[],"call":["tag tag_name to_s == ","name to_s ","tag tag_name to_s ","tag tag_name ","@tags any? ","@docstring has_tag? "," docstring has_tag? "," docstring "]}," YARD CodeObjects Base tags":{"type":"method","name":"tags","children":[],"call":["tag tag_name to_s == ","name to_s ","tag tag_name to_s ","tag tag_name ","@tags select ","name nil? ","@docstring tags "," docstring tags "," docstring "]}," YARD CodeObjects Base tag":{"type":"method","name":"tag","children":[],"call":["tag tag_name to_s == ","name to_s ","tag tag_name to_s ","tag tag_name ","@tags find ","@docstring tag "," docstring tag "," docstring "]}," YARD CodeObjects Base namespace=":{"type":"method","name":"namespace=","children":[],"call":["Registry  register ","@namespace children << ","@namespace children ","@namespace is_a? ","Registry  root ","obj == ","Registry  delete ","@namespace children delete ","reg_obj class == "," class ","reg_obj class ","Registry  at "," path ","o path == ","o path ","@namespace children delete_if ","Registry  at  class == ","Registry  at  class "]}," YARD CodeObjects Base inspect":{"type":"method","name":"inspect","children":[],"call":[" path "," type "]}," YARD CodeObjects Base path":{"type":"method","name":"path","children":[],"call":[" name to_s "," name ","(send\n  (send nil :parent) :path) join "," sep "," parent path "," parent "," parent != ","Registry  root "," parent root? ! "," parent root? "]}," YARD CodeObjects Base type":{"type":"method","name":"type","children":[],"call":[" class name split last gsub downcase to_sym "," class name split last gsub downcase "," class name split last gsub "," class name split last "," class name split "," class name "," class ","obj_name to_sym ","obj_name downcase! ","obj_name gsub! "," class name split last  to_sym "," class name split last  downcase! "," class name split last  gsub! "]}," YARD CodeObjects Base short_docstring":{"type":"method","name":"short_docstring","children":[],"call":["@short_docstring empty? "," docstring split first "," docstring split "," docstring "]}," YARD CodeObjects Base docstring=":{"type":"method","name":"docstring=","children":[],"call":[" parse_comments ","Docstring  new ","Docstring  === ","Proxy  new "," namespace ","extra empty? ","comments =~ ","@docstring_extra add_tag ","comments tags ","@docstrings clear ","Docstring  new _extra add_tag ","Proxy  new _extra add_tag ","Docstring  new  add_tag ","Docstring  new s clear ","Proxy  new s clear "]}," YARD CodeObjects Base source=":{"type":"method","name":"source=","children":[],"call":[" format_source ","statement to_s "," signature= "," line= ","statement tokens first line_no ","statement tokens first ","statement tokens ","src + ","; + ","blk [] !~ ","blk [] ","src =~ ","statement block to_s ","statement block ","statement tokens to_s ","statement is_a? ","statement source strip ","statement source ","statement first_line ","statement line ","statement respond_to? ","statement signature ","statement tokens to_s  + ","; +  [] !~ ","statement block to_s  [] !~ ","; +  [] ","statement block to_s  [] ","statement tokens to_s  =~ "]}," YARD CodeObjects Base method_missing":{"type":"method","name":"method_missing","children":[],"call":[" [] "," instance_variable_get "," []= ","meth to_s [] ","meth to_s ","meth to_s =~ ","args first "]}," YARD CodeObjects Base []=":{"type":"method","name":"[]=","children":[],"call":[" instance_variable_set "," send "," respond_to? "]}," YARD CodeObjects Base []":{"type":"method","name":"[]","children":[],"call":[" instance_variable_get "," send "," respond_to? "," instance_variable_defined? "]}," YARD CodeObjects Base ==":{"type":"method","name":"==","children":[],"call":[" path == ","other path "," path ","other is_a? "]}," YARD CodeObjects Base initialize":{"type":"method","name":"initialize","children":[],"call":[" block_given? "," namespace= ","name to_sym "," raise ","namespace is_a? ! ","namespace is_a? ","namespace != ","Docstring  new ","Docstring  new! "]}," YARD CodeObjects Base new":{"type":"method","name":"new","children":[],"call":["Registry  objects []= ","Registry  objects "," block_given? ","Registry  [] "," != ","NSEP  + ","name to_s ","(if\n  (or\n    (send\n      (send\n        (lvar :args) :first) :!)\n    (send\n      (send\n        (send\n          (lvar :args) :first) :to_sym) :==\n      (sym :instance)))\n  (const nil :ISEP)\n  (const nil :NSEP)) + ","args first to_sym == ","args first to_sym ","args first ","args first ! "," == ","keyname empty? ","namespace path ","namespace respond_to? "," new ","Proxy  new ","name =~ ","obj class != ","obj class ","Registry  objects [] ","(if\n  (and\n    (send\n      (lvar :args) :first)\n    (send\n      (send\n        (send\n          (lvar :args) :first) :to_sym) :==\n      (sym :class)))\n  (const nil :CSEP)\n  (const nil :ISEP)) + ","Registry  root ","name to_s [] ","name to_s [] == "," raise ","name to_s empty? ","existing_obj class == ","existing_obj class ","Registry  at ","obj path ","namespace value ","namespace namespace ","namespace is_a? ","namespace value =~ ","Registry  Registry  [] ects []= ","Registry  Registry  objects [] ects []= ","Registry  Registry  [] ects ","Registry  Registry  objects [] ects ","name to_s []  to_s ","name to_s  empty? ","namespace path  empty? ","keyname to_s []  empty? ","Registry  root  path ","Proxy  new  path ","name to_s [] space path ","Registry  root  respond_to? ","Proxy  new  respond_to? ","name to_s [] space respond_to? ","name to_s []  =~ ","Registry  []  class != ","Registry  objects []  class != ","Registry  []  class ","Registry  objects []  class ","Registry  Registry  [] ects [] ","Registry  Registry  objects [] ects [] ","name to_s []  to_s [] ","name to_s []  to_s [] == ","name to_s []  to_s empty? ","existing_Registry  []  class == ","existing_Registry  objects []  class == ","Registry  at  class == ","existing_Registry  []  class ","existing_Registry  objects []  class ","Registry  at  class ","Registry  []  path ","Registry  objects []  path ","Registry  root  value ","Proxy  new  value ","name to_s [] space value ","Registry  root  Registry  root  ","Proxy  new  Proxy  new  ","name to_s [] space name to_s [] space ","Registry  root  is_a? ","Proxy  new  is_a? ","name to_s [] space is_a? ","Registry  root  value =~ ","Proxy  new  value =~ ","name to_s [] space value =~ "]}," YARD CodeObjects Base dynamic?":{"type":"method","name":"dynamic?","children":[],"call":[]}," YARD CodeObjects CodeObjectList push":{"type":"method","name":"push","children":[],"call":[" raise ","value class "," include? ","value is_a? ","Proxy  new ","Proxy  new  class ","Proxy  new  is_a? "]}," YARD CodeObjects CodeObjectList initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD CLI Yardoc optparse":{"type":"method","name":"optparse","children":[],"call":[" options []= ","Serializers FileSystemSerializer  new "," options "," visibilities uniq! "," visibilities "," reload= "," files empty? "," files "," files= ","args empty? "," exit ","STDERR  << << ","STDERR  << ","STDERR  puts ","e message ","opts parse! "," puts ","opts on_tail "," log level= "," log ","opts separator ","opts on ","YARD Generator Base  register_template_path ","template to_sym ","serialopts []= "," visibilities push "," visibilities delete "," log error "," require ! "," require ","file gsub "," generate= ","YARD Registry  yardoc_file= ","opts banner= ","OptionParser  new ","SymbolHash  new "," options [] ","YARD Generators Base  register_template_path ","markup_provider to_sym ","markup to_sym "," options [] << "," raise ","File  file? ","files split each ","files split ","YARD Parser SourceParser  parser_type= "," parse_files "," add_extra_files ","Dir  glob first ","Dir  glob "," options [] uniq! ","Verifier  new ","query_expressions empty? ","YARD Templates Engine  register_template_path ","query_expressions << ","query taint "," options [] push "," options [] delete "," build_gems "," common_options ","format to_sym "," use_cache= "," excluded << "," excluded "," incremental= "," parse_options ","Encoding  default_external= ","visibilities uniq inspect ","visibilities uniq "," list= ","visibilities push ","visibilities delete "," options [] basepath= "," log warn "," options [] add_expressions "," rebuild_gems= "," build_gems= "," tag_options "," output_options "," general_options ","OptionParser  new  parse! ","OptionParser  new  on_tail ","OptionParser  new  separator ","OptionParser  new  on ","serialOptionParser  new  []= ","SymbolHash  new  []= ","OptionParser  new  banner= "]}," YARD CLI Yardoc run":{"type":"method","name":"run","children":[],"call":["Generators FullDocGenerator  new generate ","Registry  all ","Generators FullDocGenerator  new "," options "," generate ","Registry  load "," reload "," files "," optparse "," all_objects "," yardopts "," support_rdoc_document_file! ","Templates Engine  generate ","Templates Engine  render "," options merge ","objects each "," use_cache ","Registry  save ","YARD  parse "," generate_with_cache ","Registry  checksums dup ","Registry  checksums ","Registry  load_all "," incremental "," excluded "," print_list "," list "," yardopts + "," do_build_gems "," rebuild_gems "," build_gems "," parse_arguments ","Stats  new run ","Stats  new "," log enter_level "," log "," log level < "," log level "," statistics "," list ! "," copy_assets "," run_generate "," save_yardoc "," verify_markup_options ! "," verify_markup_options ","args first nil? ! ","args first nil? ","args first ","args size == ","args size "," log show_progress= "," abort "," log warned "," fail_on_warning ","Registry  lock_for_writing ","args empty? "," all_ all_objects  "," yard options merge  "," all_objects  each ","Registry  Registry  checksums dup  dup ","Registry  Registry  checksums dup  "," yard options merge  + "]}," YARD CLI Yardoc initialize":{"type":"method","name":"initialize","children":[],"call":["SymbolHash  [] "," visibilities include? ! "," visibilities include? ","gen visibility "," visibilities ","gen respond_to? "," lambda ","YARD Serializers FileSystemSerializer  new ","@options update ","SymbolHash  new ","Verifier  new ","Encoding  default_internal= ","Encoding  default_external= "," Encoding  default_internal= "," Encoding  default_external= "," Encoding  respond_to? ","@options reset_defaults ","YardocOptions  new "," Encoding  default_internal == "," Encoding  default_internal "," Encoding  default_external == "," Encoding  default_external "," Encoding  find ","SymbolHash  []  update ","SymbolHash  new  update ","YardocOptions  new  update ","SymbolHash  []  reset_defaults ","SymbolHash  new  reset_defaults ","YardocOptions  new  reset_defaults "]}," YARD CLI YardGraph optparse":{"type":"method","name":"optparse","children":[],"call":[" exit ","STDERR  << << ","STDERR  << ","STDERR  puts ","e message ","opts parse! "," puts ","opts on_tail "," log level= "," log ","opts separator "," options [] instance_eval ","file inspect "," options [] "," options "," options []= ","Serializers FileSystemSerializer  new ","opts on ","Serializers ProcessSerializer  new ","dot  + ","dotopts to_s "," options [] push "," options [] delete ","YARD Registry  yardoc_file= ","OptionParser  new ","Registry  root ","(send\n  (lvar :args) :map) compact ","Registry  at ","args map ","args first ","@serializer instance_eval "," common_options "," parse_options ","Verfier  new ","visibilities uniq inspect ","visibilities uniq ","visibilities push ","visibilities delete ","OptionParser  new  parse! ","OptionParser  new  on_tail ","OptionParser  new  separator ","OptionParser  new  on ","dotOptionParser  new  to_s ","Serializers FileSystemSerializer  new  instance_eval ","Serializers ProcessSerializer  new  instance_eval "]}," YARD CLI YardGraph run":{"type":"method","name":"run","children":[],"call":["Generators UMLGenerator  new generate ","Registry  root ","Generators UMLGenerator  new "," options ","Registry  load "," optparse "," objects ","Templates Engine  render ","(send\n  (send nil :objects) :map) join ","o format "," objects map "]}," YARD CLI YardGraph initialize":{"type":"method","name":"initialize","children":[],"call":["SymbolHash  [] ","YARD Serializers StdoutSerializer  new "]}," YARD Tags RefTagList tags":{"type":"method","name":"tags","children":[],"call":["t owner= "," owner ","t extend ","o each ","t name to_s == "," name to_s "," name ","t name to_s ","t name ","o select "," owner tags "," tag_name "," owner is_a? ","t  owner tags wner= ","  owner tags wner "," owner tags  each ","t name t owner tags _s == "," name t owner tags _s ","t name t owner tags _s "," owner tags  select ","  owner tags wner tags ","  owner tags wner is_a? "]}," YARD Tags RefTagList initialize":{"type":"method","name":"initialize","children":[],"call":["tag_name to_s "," P ","CodeObjects Proxy  === "]}," YARD Tags OverloadTag parse_signature":{"type":"method","name":"parse_signature","children":[],"call":["meth to_sym ","v strip ","k strip to_sym ","k strip ","a split ","args map! ","YARD Handlers Ruby Legacy Base  new send ","YARD Handlers Ruby Legacy Base  new ","YARD Parser Ruby Legacy TokenList  new ","meth gsub! "," signature =~ "," signature ","k strip to_s ","k strip to_s + ","a [] == ","a [] ","k size ","args map ","YARD Handlers Ruby Legacy Base  new send  map! ","YARD Handlers Ruby Legacy Base  new send  map "]}," YARD Tags OverloadTag parse_tag":{"type":"method","name":"parse_tag","children":[],"call":["Docstring  new ","text gsub! strip! ","text gsub! ","text [] length ","text [] ","@signature strip! ","raw_text split ","text strip! ","text split ","String  new "]}," YARD Tags OverloadTag method_missing":{"type":"method","name":"method_missing","children":[],"call":[" object send "," object "]}," YARD Tags OverloadTag inspect":{"type":"method","name":"inspect","children":[],"call":[" path "]}," YARD Tags OverloadTag name":{"type":"method","name":"name","children":[],"call":[" object name "," object "," object send ","@name to_s "," object scope == "," object scope "]}," YARD Tags OverloadTag type":{"type":"method","name":"type","children":[],"call":[" object type "," object "]}," YARD Tags OverloadTag object=":{"type":"method","name":"object=","children":[],"call":[" docstring object= "," docstring ","tag object= "," docstring tags each "," docstring tags "]}," YARD Tags OverloadTag has_tag?":{"type":"method","name":"has_tag?","children":[],"call":[" docstring has_tag? "," docstring "]}," YARD Tags OverloadTag tags":{"type":"method","name":"tags","children":[],"call":[" docstring tags "," docstring "]}," YARD Tags OverloadTag tag":{"type":"method","name":"tag","children":[],"call":[" docstring tag "," docstring "]}," YARD Tags OverloadTag initialize":{"type":"method","name":"initialize","children":[],"call":[" parse_signature "," parse_tag "]}," YARD Tags OptionTag initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Tags DefaultTag initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Tags DefaultFactory extract_types_and_name_from_text":{"type":"method","name":"extract_types_and_name_from_text","children":[],"call":["text [] strip ","text [] ","e + ","x strip ","list map ","text strip ","list first == ","list first ","list size == ","list size ","before strip ","before empty? ","list last << ","list last ","level >= ","before << ","level == ","c =~ ","list push ","c == ","list last [] == ","list last [] ","closing_types include? ","level > ","opening_types include? ","text split each_with_index ","text split ","range end + ","range end "," parse_types ","before empty? ! ","list == ","e strip ","list nil? "," extract_types_and_name_from_text_unstripped ","text strip  [] strip ","text strip  [] ","text strip  strip ","before strip  strip ","before strip  empty? ","before strip  << ","text strip  split each_with_index ","text strip  split ","before strip  empty? ! "," extract_types_and_name_from_text strip _unstripped "]}," YARD Tags DefaultFactory parse_tag_with_options":{"type":"method","name":"parse_tag_with_options","children":[],"call":["OptionTag  new "," parse_tag_with_types_name_and_default "," extract_name_from_text "]}," YARD Tags DefaultFactory parse_tag_with_types_name_and_default":{"type":"method","name":"parse_tag_with_types_name_and_default","children":[],"call":["DefaultTag  new "," extract_types_and_name_from_text ","text =~ "," extract_name_from_text ","TYPELIST_CLOSING_CHARS  gsub ","TYPELIST_OPENING_CHARS  gsub ","text start_with? ","TYPELIST_CLOSING_CHARS  delete ","TYPELIST_OPENING_CHARS  delete "]}," YARD Registry partial_resolve":{"type":"method","name":"partial_resolve","children":[],"call":[" at ","(send\n  (lvar :namespace) :path) join ","namespace path ","namespace != "," root ","name =~ ","s empty? ","(const\n  (const nil :CodeObjects) :NSEP) each ","# + ","namespace root? ","found type == ","found type ","type nil? ","obj type == ","obj type ","(send\n  (lvar :namespace) :(send\n  (lvar :namespace) :path) join ) join ","namespace (send\n  (lvar :namespace) :path) join  "," at  type == "," at  type "]}," YARD Parser SourceParser parse_statements":{"type":"method","name":"parse_statements","children":[],"call":[" raise ","Ruby RubyParser  parse "," file ","Ruby Legacy StatementList  new "," parser_type ","CParser  new parse ","CParser  new "]}," YARD Parser SourceParser parser_type_for_filename":{"type":"method","name":"parser_type_for_filename","children":[],"call":[" parser_type == "," parser_type ","(or\n  (send\n    (send\n      (const nil :File) :extname\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase ","File  extname [] ","File  extname ","type == "," class parser_type_for_extension "," class "," parser_ class parser_type_for_extension  == "," parser_ class parser_type_for_extension  ","(or\n  (send\n    (send\n      (const nil :File) :(or\n  (send\n    (send\n      (const nil :File) :extname\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase name\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase ","File  (or\n  (send\n    (send\n      (const nil :File) :extname\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase name [] ","File  (or\n  (send\n    (send\n      (const nil :File) :extname\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase name "," class parser_type_for_extension  == "," class parser_ class parser_type_for_extension _for_extension "," class parser_type_for_(or\n  (send\n    (send\n      (const nil :File) :extname\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase ension "]}," YARD Parser SourceParser parser_type=":{"type":"method","name":"parser_type=","children":[],"call":[" class validated_parser_type "," class "," validated_parser_type "]}," YARD Parser SourceParser post_process":{"type":"method","name":"post_process","children":[],"call":["post process ","@parser enumerator ","Handlers Processor  new ","@parser respond_to? ","Handlers Processor  new  process ","@parser @parser enumerator  "]}," YARD Parser SourceParser tokenize":{"type":"method","name":"tokenize","children":[],"call":[" raise ","Ruby RubyParser  parse tokens ","Ruby RubyParser  parse ","Ruby Legacy TokenList  new "," parser_type "," new tokenize "," new ","@parser tokenize "," parser_class new "," file "," parser_class "," parser_class new  tokenize "]}," YARD Parser SourceParser validated_parser_type":{"type":"method","name":"validated_parser_type","children":[],"call":["type == ","(const\n  (cbase) :Ripper) ! "]}," YARD Parser Ruby RubyParser freeze_tree":{"type":"method","name":"freeze_tree","children":[],"call":[" freeze_tree ","child parent= ","node children each ","node children "," root "]}," YARD Parser Ruby RubyParser insert_comments":{"type":"method","name":"insert_comments","children":[],"call":[" comments delete "," comments ","node docstring= ","comment empty? ! ","comment empty? ","@comments [] ","node line downto ","node line - ","node line ","node parent type != ","node parent type ","node parent ","node type == ","node type "," root traverse "," root ","node docstring_range= ","line - ","comment count "," @comments [] s delete "," @comments [] s ","@comments []  empty? ! ","@comments []  empty? ","@@comments [] s [] ","@comments []  count "]}," YARD Parser Ruby RubyParser on_parse_error":{"type":"method","name":"on_parse_error","children":[],"call":[" raise "," column "," lineno "," file "]}," YARD Parser Ruby RubyParser on_comment":{"type":"method","name":"on_comment","children":[],"call":["@comments []= "," lineno ","append_comment + + ","append_comment + ","@comments delete "," lineno - ","@comments [] ","comment gsub chomp ","comment gsub "," visit_ns_token "," column ","@comments_last_column == ","@append_comment + + s []= ","@comment gsub chomp s []= ","append_append_comment + +  + + ","append_comment gsub chomp  + + ","@comments []  + + ","append_append_comment + +  + ","append_comment gsub chomp  + ","@comments []  + ","@append_comment + + s delete ","@comment gsub chomp s delete ","@append_comment + + s [] ","@comment gsub chomp s [] ","append_comment + +  gsub chomp ","comment gsub chomp  gsub chomp ","append_comment + +  gsub ","comment gsub chomp  gsub ","@append_comment + + s_last_column == ","@comment gsub chomp s_last_column == "," column  == "]}," YARD Parser Ruby RubyParser on_params":{"type":"method","name":"on_params","children":[],"call":["ParameterNode  new "," charno "," lineno ","AstNode  new ","sub_arg class == ","sub_arg class ","arg map! ","arg first class == ","arg first class ","arg first ","arg class == ","arg class ","args map! "]}," YARD Parser Ruby RubyParser on_void_stmt":{"type":"method","name":"on_void_stmt","children":[],"call":["AstNode  new "," charno "," lineno "]}," YARD Parser Ruby RubyParser on_string_content":{"type":"method","name":"on_string_content","children":[],"call":["AstNode  new "," charno "," lineno "]}," YARD Parser Ruby RubyParser on_string_literal":{"type":"method","name":"on_string_literal","children":[],"call":[" visit_event_arr ","AstNode  new "]}," YARD Parser Ruby RubyParser on_qwords_new":{"type":"method","name":"on_qwords_new","children":[],"call":[" visit_event ","AstNode  new "]}," YARD Parser Ruby RubyParser on_assoclist_from_args":{"type":"method","name":"on_assoclist_from_args","children":[],"call":["args first "]}," YARD Parser Ruby RubyParser on_bare_assoc_hash":{"type":"method","name":"on_bare_assoc_hash","children":[],"call":["args first ","AstNode  new "]}," YARD Parser Ruby RubyParser on_assoc_new":{"type":"method","name":"on_assoc_new","children":[],"call":["AstNode  new "]}," YARD Parser Ruby RubyParser on_hash":{"type":"method","name":"on_hash","children":[],"call":[" visit_event ","AstNode  new "," charno "," lineno ","args first "]}," YARD Parser Ruby RubyParser on_body_stmt":{"type":"method","name":"on_body_stmt","children":[],"call":["args first ","AstNode  new ","args compact size == ","args compact size ","args compact "]}," YARD Parser Ruby RubyParser on_program":{"type":"method","name":"on_program","children":[],"call":["args first "]}," YARD Parser Ruby RubyParser add_token":{"type":"method","name":"add_token","children":[],"call":["@tokens << ","@tokens []= ",": + ","@tokens last [] == ","@tokens last [] ","@tokens last "]}," YARD Parser Ruby RubyParser visit_ns_token":{"type":"method","name":"visit_ns_token","children":[],"call":["AstNode  new "," charno - "," charno "," lineno ","data length "," add_token ","  charno arno - ","  charno arno "]}," YARD Parser Ruby RubyParser visit_event_arr":{"type":"method","name":"visit_event_arr","children":[],"call":["node line_range= ","Range  new "," lineno ","node source_range= ","@ns_charno - ","@map [] pop ","@map [] ","@map [] empty? ! ","@map [] empty? ","MAPPINGS  [] find ","MAPPINGS  [] ","node type "]}," YARD Parser Ruby RubyParser visit_event":{"type":"method","name":"visit_event","children":[],"call":["node line_range= ","Range  new "," lineno ","node source_range= ","@ns_charno - ","@map [] pop ","@map [] ","MAPPINGS  [] ","node type "]}," YARD Parser Ruby RubyParser enumerator":{"type":"method","name":"enumerator","children":[],"call":[" ast children "," ast ","@parser enumerator "]}," YARD Parser Ruby RubyParser parse":{"type":"method","name":"parse","children":[],"call":[" insert_comments "," freeze_tree ","@ast file= ","@ast full_source= ","@parser parse "]}," YARD Parser Ruby RubyParser initialize":{"type":"method","name":"initialize","children":[],"call":["RipperParser  new "]}," YARD Legacy TokenList convert_token":{"type":"method","name":"convert_token","children":[],"call":["sym set_text ","tk text + ","next_tk text ","tk text ","sym lex_state= ","lex lex_state ","TkSYMBOL  new ","tk char_no ","tk line_no ","lex token ","TkSYMBEG  === ","TkLABEL  new ","lex peek == ","lex peek ","TkIDENTIFIER  === ","TkSYMBOL  new  set_text ","TkLABEL  new  set_text ","lex token  text ","TkSYMBOL  new  lex_state= ","TkLABEL  new  lex_state= "]}," YARD Legacy TokenList parse_content":{"type":"method","name":"parse_content","children":[],"call":[" << "," convert_token ","lex token ","RubyLex  new ","tk nil? "," loop ","RubyLex  new  token ","lex token  nil? "]}," YARD Legacy TokenList squeeze":{"type":"method","name":"squeeze","children":[],"call":["TokenList  new ","last is_a? ","t is_a? "," map "]}," YARD Legacy TokenList push":{"type":"method","name":"push","children":[],"call":[" raise ","tok class "," parse_content ","tok is_a? "," concat ","tokens each "]}," YARD Legacy TokenList to_s":{"type":"method","name":"to_s","children":[],"call":["(send nil :collect) join ","t text "," collect ","(send nil :inject\n  (array)) join ","acc << ","token text ","TkBlockContents  === ","show_block ! ","TkStatementEnd  === ","full_statement ! "," inject "]}," YARD Legacy TokenList initialize":{"type":"method","name":"initialize","children":[],"call":[" << "]}," YARD Legacy StatementList peek_no_space":{"type":"method","name":"peek_no_space","children":[],"call":["@tokens [] ","@tokens first ","@tokens first class == ","@tokens first class "]}," YARD Legacy StatementList push_token":{"type":"method","name":"push_token","children":[],"call":["@statement << ","(const nil :TkNL) include? ","tk class ","@level == ","(const nil :TkCOMMENT) include? ","tk line_no ","@statement empty? "]}," YARD Legacy StatementList balances?":{"type":"method","name":"balances?","children":[],"call":["@level == ","@level > ","(const nil :TkRPAREN) include? ","tk class ","@last_ns_tk class == ","@last_ns_tk class ","OPEN_BLOCK_TOKENS  include? ","(const nil :TkLPAREN) include? ","tk class == ","@before_last_ns_tk class == ","@before_last_ns_tk class ","(const nil :TkALIAS) include? "]}," YARD Legacy StatementList process_statement_end":{"type":"method","name":"process_statement_end","children":[],"call":["@block << ","tk class == ","tk class ","TokenList  new ","@stat == "," peek_no_space class == "," peek_no_space class "," peek_no_space ","@current_block == ","@last_tk lex_state != ","@last_tk lex_state ","@last_ns_tk class != ","@last_ns_tk class ","(const nil :TkNL) include? ","(const nil :EXPR_END) include? ","(const nil :TkSEMICOLON) include? ","@statement << ","TkStatementEnd  new ","tk char_no ","tk line_no ","@level == ","(const nil :TkRBRACE) include? ","@state == ","(const nil :TkEND_OF_SCRIPT) include? ","(const nil :EXPR_DOT) include? ","TokenList  new  << "]}," YARD Legacy StatementList process_complex_block_opener":{"type":"method","name":"process_complex_block_opener","children":[],"call":["tk class ","@last_ns_tk class == ","@last_ns_tk class ","OPEN_BLOCK_TOKENS  include? "]}," YARD Legacy StatementList process_simple_block_opener":{"type":"method","name":"process_simple_block_opener","children":[],"call":["@block << ","TokenList  new ","@last_ns_tk lex_state != ","@last_ns_tk lex_state ","@last_ns_tk nil? ","(const nil :TkLBRACE) include? ","tk class ","@statement push ","tokens reverse ","TkBEGIN  === ","TkStatementEnd  new ","tk char_no ","tk line_no ","@statement << ","@statement concat ","@block nil? ","TokenList  new  << ","tokens reverse  reverse ","TokenList  new  nil? "]}," YARD Legacy StatementList process_initial_comment":{"type":"method","name":"process_initial_comment","children":[],"call":["@comments pop ","@comments first =~ ","@comments first ","@comments size == ","@comments size ","@comments << ","tk text gsub ","tk text ","@before_last_tk class == ","@before_last_tk class ","@last_tk class == ","@last_tk class ","tk class == ","tk class ","tk line_no ","@comments_last_line < ","tk line_no - ","@statement empty? ! ","@statement empty? ","(or\n  (ivar :@comments_last_line)\n  (int 0)) < ","tk line_no > ","tk line_no + ","tk text gsub split ","tk text count ","tk text =~ ","1 == ","@comments_hash_flag == ","@last_ns_tk ! ","@last_ns_tk text == ","@last_ns_tk text ","@last_ns_tk class == ","@last_ns_tk class ","@encoding_line ! ","@tokens unshift ","@comments_hash_flag nil? ","tk text start_with? ","tk line_no  < ","tk line_no +  < ","(or\n  (ivar :tk line_no )\n  (int 0)) < ","(or\n  (ivar :tk line_no + )\n  (int 0)) < ","1 ==  == ","tk text  ! ","1 ==  nil? "]}," YARD Legacy StatementList process_block_token":{"type":"method","name":"process_block_token","children":[],"call":[" process_statement_end "," balances? ","@block << ","@statement << ","TkBlockContents  new ","tk char_no ","tk line_no ","@block empty? ","(const nil :TkSPACE) include? ","tk class ","@block_num > "]}," YARD Legacy StatementList process_token":{"type":"method","name":"process_token","children":[],"call":[" process_statement_end ","@statement << ","tk class == ","tk class "," process_block_token "," balances? "," push_token "," process_complex_block_opener "," process_simple_block_opener ","(const nil :TkSPACE) include? ","@statement empty? "," process_initial_comment ","TkCOMMENT  === ","@statement empty? ! ","@first_line == ","tk line_no "," preprocess_token ","(const nil :NilClass) include? "," peek_no_space class "," peek_no_space ","@alias_values size == ","@alias_values size ","@alias_values << "]}," YARD Legacy StatementList next_statement":{"type":"method","name":"next_statement","children":[],"call":["Statement  new ","@statement empty? ! ","@statement empty? ","@comments compact ","(const nil :TkSPACE) include? ","tk class "," process_token ","@tokens shift ","@done ! ","TokenList  new ","stmt comments_range= ","@comments_line + - ","@comments_line + ","@comments size ","@statement pop ","(const nil :TkNL) include? ","@statement last class ","@statement last "," sanitize_block "," sanitize_statement_end ","stmt group= ","stmt comments_hash_flag= ","@statement first set_text ","#  + ","@comments join ","@statement first ","@statement << ","TkCOMMENT  new ","tk nil? ","TokenList  new  empty? ! ","TokenList  new  empty? ","@comments compact  compact ","@tokens shift  class ","Statement  new  comments_range= ","@comments compact _line + - ","@comments compact _line + ","@comments compact  size ","TokenList  new  pop ","TokenList  new  last class ","TokenList  new  last ","Statement  new  group= ","Statement  new  comments_hash_flag= ","TokenList  new  first set_text ","@comments compact  join ","TokenList  new  first ","TokenList  new  << ","@tokens shift  nil? "]}," YARD Legacy StatementList parse_statements":{"type":"method","name":"parse_statements","children":[],"call":[" << "," next_statement ","stmt nil? "," loop "," next_statement  nil? "]}," YARD Legacy StatementList enumerator":{"type":"method","name":"enumerator","children":[],"call":[]}," YARD Legacy StatementList initialize":{"type":"method","name":"initialize","children":[],"call":[" parse_statements "," raise ","content class ","content inspect ","TokenList  new ","content is_a? ","content dup ","content gsub ","content delete "]}," YARD Legacy Statement clean_tokens":{"type":"method","name":"clean_tokens","children":[],"call":["last_tk class == ","tk class ","last_tk class ","last_tk is_a? ","tk is_a? ","tokens reject "]}," YARD Legacy Statement line":{"type":"method","name":"line","children":[],"call":[" tokens first line_no "," tokens first "," tokens "]}," YARD Legacy Statement inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (lvar :buf) :map) join "," line ","buf map ","buf last << ","tk text ","buf last ","buf push ","tk is_a? "," tokens each "," tokens ","(send\n  (send\n    (send nil :to_s) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join "," to_s split map "," to_s split "," to_s "," line - ","(send\n  (send\n    (send nil :to_s\n      (false)) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","(send\n  ( line - var :buf) :map) join ","  line - ine ","buf  line - ast << ","buf  line - ast ","(send\n  (send\n    (send ni line -  :to_s) :sp line - it\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join "," to_s sp line - it map "," to_s sp line - it ","  line - ine - ","(send\n  (send\n    (send ni line -  :to_s\n      (fa line - se)) :sp line - it\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join "]}," YARD Legacy Statement initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Legacy RubyLex read_escape":{"type":"method","name":"read_escape","children":[],"call":["res << "," read_escape ","(lvasgn :ch\n  (send nil :getc)) == "," getc "," ungetc ","(lvasgn :ch\n  (send nil :getc)) != ","ch == ","2 times ","3 times ","String  new ","String  new  << ","(lvasgn : getc \n  (send nil :getc)) == ","(lvasgn : getc \n  (send nil :getc)) != "," getc  == "]}," YARD Legacy RubyLex identify_comment":{"type":"method","name":"identify_comment","children":[],"call":[" Token set_text "," Token ","comment << "," ungetc ","ch == "," getc ","String  new ","String  new  << "," getc  == "]}," YARD Legacy RubyLex skip_inner_expression":{"type":"method","name":"skip_inner_expression","children":[],"call":["ch == ","nest zero? ","res << "," getc ","nest == ","String  new "," getc  == ","String  new  << "]}," YARD Legacy RubyLex identify_string":{"type":"method","name":"identify_string","children":[],"call":["(lvar :subtype) set_text "," Token ","Ltype2Token  [] ","DLtype2Token  [] ","str << "," getc "," peek =~ "," peek ","@ltype == "," read_escape ","ch == "," ungetc ","str << << "," skip_inner_expression ","@ltype != ","opener == ","nest == ","@quoted == ","String  new ","String  new  << "," getc  == ","String  new  << << "]}," YARD Legacy RubyLex identify_number":{"type":"method","name":"identify_number","children":[],"call":[" Token set_text "," Token "," ungetc ","str << "," getc "," peek =~ "," peek "," peek !~ ","ch !~ "," peek == ","start == ","start dup ","start dup  << "," getc  !~ "," getc  == "," getc  dup "]}," YARD Legacy RubyLex identify_quotation":{"type":"method","name":"identify_quotation","children":[],"call":[" identify_string ","PERCENT_PAREN  [] ","ch =~ "," getc ","PERCENT_LTYPE  [] "," getc  =~ "]}," YARD Legacy RubyLex identify_here_document":{"type":"method","name":"identify_here_document","children":[],"call":[" Token set_text ","str dump "," Token ","Ltype2Token  [] ","@reader divert_read_from ","str << << ","str << ","l chomp ","l == ","l strip! ","l chomp! "," gets ","ch == ","reserve << "," getc "," ungetc ","quoted concat ","c =~ ","ch dup ","c != ","String  new ","String  new  dump ","String  new  << << ","String  new  << "," gets  chomp ","l  getc omp ","l  getc homp "," gets  == "," gets  strip! ","l String  new ip! "," gets  chomp! ","l  getc omp! ","l  getc homp! "," getc  == "," getc h == "," get getc  "," unget getc  ","quoted  getc on getc at ","ch dup  concat "," getc  =~ "," getc  dup "," getc h dup "," getc  != "]}," YARD Legacy RubyLex identify_identifier":{"type":"method","name":"identify_identifier","children":[],"call":[" Token set_text "," Token ","token [] =~ ","token [] ","token size - ","token size ","@lex_state == ","token concat "," getc "," peek == "," peek ","trans [] ","DEINDENT_CLAUSE  include? ","ACCEPTS_COLON  include? ","ENINDENT_CLAUSE  include? ","@lex_state != ","TkSymbol2Token  [] ","TkReading2Token  [] "," print ","RubyLex  debug? ","ch == "," ungetc ","(lvasgn :ch\n  (send nil :getc)) =~ "," peek =~ ","trans []  == ","trans []  != "," getc  == ","(lvasgn : getc \n  (send nil :getc)) =~ "]}," YARD Legacy RubyLex identify_gvar":{"type":"method","name":"identify_gvar","children":[],"call":["tk set_text "," Token "," ungetc "," identify_identifier ","str << ","(lvasgn :ch\n  (send nil :getc)) =~ "," getc ","str << << ","String  new ","String  new  << ","(lvasgn : getc \n  (send nil :getc)) =~ ","String  new  << << "]}," YARD Legacy RubyLex lex_int2":{"type":"method","name":"lex_int2","children":[],"call":[" p ","RubyLex  debug? "," printf ","io inspect "," identify_identifier "," peek =~ "," peek "," identify_number ","@OP def_rule "," throw ","@prev_char_no == "," proc "," Token set_text "," Token "," ungetc "," identify_gvar "," identify_quotation "," peek !~ ","@lex_state == "," getc "," peek == "," getc == ","t set_text ","tk set_text ","@OP def_rules "," identify_string ","@lex_state != "," prin identify_identifier f "," prin identify_number f "," prin Token f ","io inspec identify_identifier  ","io inspec identify_number  ","io inspec Token  "," iden identify_identifier ify_iden identify_identifier ifier "," iden identify_number ify_iden identify_number ifier "," iden Token ify_iden Token ifier "," iden identify_identifier ify_number "," iden identify_number ify_number "," iden Token ify_number ","  identify_identifier hrow ","  identify_number hrow ","  Token hrow "," Token se identify_identifier _ identify_identifier ex identify_identifier  "," Token se identify_number _ identify_number ex identify_number  "," Token se Token _ Token ex Token  "," unge identify_identifier c "," unge identify_number c "," unge Token c "," iden identify_identifier ify_gvar "," iden identify_number ify_gvar "," iden Token ify_gvar "," iden identify_identifier ify_quo identify_identifier a identify_identifier ion "," iden identify_number ify_quo identify_number a identify_number ion "," iden Token ify_quo Token a Token ion ","@lex_s identify_identifier a identify_identifier e == ","@lex_s identify_number a identify_number e == ","@lex_s Token a Token e == "," ge identify_identifier c "," ge identify_number c "," ge Token c "," ge identify_identifier c == "," ge identify_number c == "," ge Token c == "," identify_identifier  se identify_identifier _ identify_identifier ex identify_identifier  "," identify_number  se identify_number _ identify_number ex identify_number  "," Token  se Token _ Token ex Token  "," identify_identifier k se identify_identifier _ identify_identifier ex identify_identifier  "," identify_number k se identify_number _ identify_number ex identify_number  "," Token k se Token _ Token ex Token  "," Token  set_text "," iden identify_identifier ify_s identify_identifier ring "," iden identify_number ify_s identify_number ring "," iden Token ify_s Token ring ","@lex_s identify_identifier a identify_identifier e != ","@lex_s identify_number a identify_number e != ","@lex_s Token a Token e != "]}," YARD Legacy RubyLex lex_init":{"type":"method","name":"lex_init","children":[],"call":[" lex_int2 "," Token set_text "," Token ","@OP def_rules "," identify_number "," ungetc "," peek =~ "," peek ","@OP def_rule "," throw ","@lex_state != ","@lex_state == "," catch "," proc ","op =~ ","str << "," read_escape ","ch == ","ch !~ "," getc "," identify_string ","tk ! "," identify_here_document "," print ","RubyLex  debug? ","str sub! ","str =~ ","line << ","line =~ ","@prev_char_no == "," identify_comment ","chars << ","(lvasgn :ch\n  (send nil :getc)) =~ ","SLex  new ","String  new ","SLex  new  def_rules "," unget peek  ","SLex  new  def_rule "," cat getc  ","  peek at peek h "," pro peek  ","String  new  << "," read_es peek ape "," getc  == "," peek h == "," getc  !~ "," peek h !~ "," get peek  "," identify_String  new ing "," Token set_text  ! "," identify_here_document  ! "," identify_here_do peek ument ","String  new  sub! ","String  new  =~ ","@prev_ getc ar_no == ","@prev_ peek har_no == "," identify_ peek omment "," getc ars << "," peek hars << ","(lvasgn : getc \n  (send nil :getc)) =~ ","(lvasgn : peek h\n  (send nil :get peek )) =~ "]}," YARD Legacy RubyLex token":{"type":"method","name":"token","children":[],"call":["tk lex_state= "," lex_state "," p "," get_read ","TkError  new "," char_no "," line_no "," abort ","tk kind_of? ","@OP match "," catch "," set_token_position ","tk is_a? ","TkError  new  lex_state= ","@OP match  lex_state= ","TkError  new  kind_of? ","@OP match  kind_of? ","TkError  new  is_a? ","@OP match  is_a? "]}," YARD Legacy RubyLex lex":{"type":"method","name":"lex","children":[],"call":["tk nil? ","tk kind_of? ","line == "," get_read ","@continue ! ","(lvasgn :tk\n  (send nil :token)) kind_of? "," token "," catch ","tk is_a? ","(lvasgn :tk\n  (send nil :token)) is_a? "," token  nil? "," token  kind_of? "," get_read  == ","(lvasgn : token \n  (send nil :token)) kind_of? "," token  is_a? ","(lvasgn : token \n  (send nil :token)) is_a? "]}," YARD Legacy RubyLex peek":{"type":"method","name":"peek","children":[],"call":["@reader peek "]}," YARD Legacy RubyLex peek_equal?":{"type":"method","name":"peek_equal?","children":[],"call":["@reader peek_equal "]}," YARD Legacy RubyLex ungetc":{"type":"method","name":"ungetc","children":[],"call":["@reader ungetc "]}," YARD Legacy RubyLex gets":{"type":"method","name":"gets","children":[],"call":["c == ","l concat "," getc "," getc  == ","l  getc on getc at "," get getc  "]}," YARD Legacy RubyLex getc_of_rests":{"type":"method","name":"getc_of_rests","children":[],"call":["@reader getc_already_read "]}," YARD Legacy RubyLex getc":{"type":"method","name":"getc","children":[],"call":["@reader getc "]}," YARD Legacy RubyLex get_read":{"type":"method","name":"get_read","children":[],"call":["@reader get_read "]}," YARD Legacy RubyLex char_no":{"type":"method","name":"char_no","children":[],"call":["@reader column "]}," YARD Legacy RubyLex line_no":{"type":"method","name":"line_no","children":[],"call":["@reader line_num "]}," YARD Legacy RubyLex initialize":{"type":"method","name":"initialize","children":[],"call":["BufferedReader  new "," lex_init "]}," YARD Legacy RubyLex debug?":{"type":"method","name":"debug?","children":[],"call":[]}," YARD Legacy RubyLex BufferedReader divert_read_from":{"type":"method","name":"divert_read_from","children":[],"call":["@content size ","@content []= "]}," YARD Legacy RubyLex BufferedReader peek_equal":{"type":"method","name":"peek_equal","children":[],"call":["@content [] == ","@content [] ","str length "]}," YARD Legacy RubyLex BufferedReader peek":{"type":"method","name":"peek","children":[],"call":["@content [] ","pos >= ","@offset + ","@offset +  >= "]}," YARD Legacy RubyLex BufferedReader get_read":{"type":"method","name":"get_read","children":[],"call":["@content [] "]}," YARD Legacy RubyLex BufferedReader ungetc":{"type":"method","name":"ungetc","children":[],"call":["@content [] == ","@content [] "," raise ","@offset <= "]}," YARD Legacy RubyLex BufferedReader getc_already_read":{"type":"method","name":"getc_already_read","children":[],"call":[" getc "]}," YARD Legacy RubyLex BufferedReader getc":{"type":"method","name":"getc","children":[],"call":["ch == ","@offset - ","@hwm < ","@content [] ","@offset >= ","@content []  == "]}," YARD Legacy RubyLex BufferedReader column":{"type":"method","name":"column","children":[],"call":["@offset - "]}," YARD Legacy RubyLex BufferedReader initialize":{"type":"method","name":"initialize","children":[],"call":["@content size ","@content << ","@content [] == ","@content [] ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","  * ","tab_width * - ","$` length % ","$` length ","tab_width * ","$& length ","line gsub! ","content split map ","content split ","String  new ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  size ","String  new  size ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  << ","String  new  << ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  [] == ","String  new  [] == ","@(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  [] ","String  new  [] ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join ) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  split map ","(send\n  (send\n    (lvar :content) :split\n    (regexp\n      (str \"\\n\")\n      (regopt))) :map) join  split "]}," YARD Legacy RubyToken def_token":{"type":"method","name":"def_token","children":[],"call":[]}," YARD Legacy RubyToken Token":{"type":"method","name":"Token","children":[],"call":["token new ","(send\n  (send\n    (lvar :token) :ancestors) :&\n  (array\n    (const nil :TkId)\n    (const nil :TkVal)\n    (const nil :TkOPASGN)\n    (const nil :TkUnknownChar))) empty? ","token ancestors & ","token ancestors "," Token ","tk [] ","IRB  fail ","(lvasgn :tk\n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","source [] ","token kind_of? ","token is_a? "," raise ","token new  [] "," Token  [] ","source []  [] ","(lvasgn :token new \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","(lvasgn : Token \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? ","(lvasgn :source [] \n  (send\n    (lvar :source) :[]\n    (lvar :token))) nil? "]}," YARD Legacy RubyToken set_token_position":{"type":"method","name":"set_token_position","children":[],"call":[]}," YARD Legacy RubyToken TkUnknownChar initialize":{"type":"method","name":"initialize","children":[],"call":["char_no chr ","char_no > "]}," YARD Legacy RubyToken TkOPASGN initialize":{"type":"method","name":"initialize","children":[],"call":["TkReading2Token  [] ","op kind_of? ","op is_a? ","TkReading2Token  []  kind_of? ","TkReading2Token  []  is_a? "]}," YARD Legacy RubyToken TkOp name":{"type":"method","name":"name","children":[],"call":[" class op_name "," class "]}," YARD Legacy RubyToken TkVal initialize":{"type":"method","name":"initialize","children":[],"call":[" set_text "]}," YARD Legacy RubyToken TkId initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Legacy RubyToken Token set_text":{"type":"method","name":"set_text","children":[],"call":[]}," YARD Legacy RubyToken Token initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Parser Ruby ConditionalNode cmod?":{"type":"method","name":"cmod?","children":[],"call":[" type =~ "," type "]}," YARD Parser Ruby ConditionalNode else_block":{"type":"method","name":"else_block","children":[],"call":[" [] [] "," [] "," [] type == "," [] type "," cmod? ! "," cmod? "]}," YARD Parser Ruby ConditionalNode then_block":{"type":"method","name":"then_block","children":[],"call":[" [] "]}," YARD Parser Ruby ConditionalNode condition":{"type":"method","name":"condition","children":[],"call":[" first "]}," YARD Parser Ruby ConditionalNode condition?":{"type":"method","name":"condition?","children":[],"call":[]}," YARD Parser Ruby MethodCallNode call_has_paren?":{"type":"method","name":"call_has_paren?","children":[],"call":["(sym :fcall) include? "," type "]}," YARD Parser Ruby MethodCallNode index_adjust":{"type":"method","name":"index_adjust","children":[],"call":["(sym :call) include? "," type "]}," YARD Parser Ruby MethodCallNode block_param":{"type":"method","name":"block_param","children":[],"call":[" parameters last "," parameters "]}," YARD Parser Ruby MethodCallNode parameters":{"type":"method","name":"parameters","children":[],"call":["params [] ","params first "," call_has_paren? "," [] ","1 + "," index_adjust "," type == "," type ","params first  [] "," []  [] ","params first  first "," []  first "]}," YARD Parser Ruby MethodCallNode method_name":{"type":"method","name":"method_name","children":[],"call":["name jump first to_sym ","name jump first ","name jump "," [] "," index_adjust ","Array  === ","name == "," []  jump first to_sym "," []  jump first "," []  jump "," []  == "]}," YARD Parser Ruby MethodCallNode namespace":{"type":"method","name":"namespace","children":[],"call":[" first "," index_adjust > "," index_adjust "]}," YARD Parser Ruby MethodCallNode call?":{"type":"method","name":"call?","children":[],"call":[]}," YARD Parser Ruby ParameterNode block_param":{"type":"method","name":"block_param","children":[],"call":[" [] [] "," [] "]}," YARD Parser Ruby ParameterNode splat_param":{"type":"method","name":"splat_param","children":[],"call":[" [] [] "," [] "]}," YARD Parser Ruby ParameterNode optional_params":{"type":"method","name":"optional_params","children":[],"call":[" [] "," [] [] type == "," [] [] type "," [] [] ","optional empty? "," []  empty? "]}," YARD Parser Ruby ParameterNode required_end_params":{"type":"method","name":"required_end_params","children":[],"call":[" [] "]}," YARD Parser Ruby ParameterNode required_params":{"type":"method","name":"required_params","children":[],"call":[" [] "]}," YARD Parser Ruby ReferenceNode source":{"type":"method","name":"source","children":[],"call":[" split first "," split "]}," YARD Parser Ruby ReferenceNode namespace":{"type":"method","name":"namespace","children":[],"call":["Array  new "," flatten [] "," flatten "]}," YARD Parser Ruby ReferenceNode path":{"type":"method","name":"path","children":[],"call":["Array  new "," flatten "]}," YARD Parser Ruby ReferenceNode ref?":{"type":"method","name":"ref?","children":[],"call":[]}," YARD Parser Ruby AstNode reset_line_info":{"type":"method","name":"reset_line_info","children":[],"call":[" source_range= "," line_range= ","Range  new ","l source_range last ","l source_range ","f source_range first ","f source_range ","l line_range last ","l line_range ","f line_range first ","f line_range "," children last "," children "," children first "," children size > "," children size "," size == "," size "," children empty? ! "," children empty? ","  children last ine_range= "," children last  source_range  children last ast "," children last  source_range "," children first  source_range  children first irst "," children first  source_range "," children last   children last ine_range  children last ast "," children last   children last ine_range ","f  children last ine_range first "," children first  line_range  children first irst ","f  children last ine_range "," children first  line_range "," chi children last dren  children last ast "," chi children last dren "," chi children last dren first "," children  children first irst "," chi children last dren size > "," chi children last dren size "," chi children last dren empty? ! "," chi children last dren empty? "]}," YARD Parser Ruby AstNode traverse":{"type":"method","name":"traverse","children":[],"call":["nodes insert ","node children ","index + ","nodes each with_index ","nodes each ","node children reverse ","node children empty? ","nodes pop ","nodes empty? ","nodes pop s insert ","nodes pop  children ","nodes pop s each with_index ","nodes pop s each ","nodes pop  children reverse ","nodes pop  children empty? ","nodes pop s pop ","nodes pop s empty? "]}," YARD Parser Ruby AstNode inspect":{"type":"method","name":"inspect","children":[],"call":["s( + + + ","s( + + "," map join "," map ","s( + ",": + + ",": + "," type to_s "," type "," type != "]}," YARD Parser Ruby AstNode pretty_print":{"type":"method","name":"pretty_print","children":[],"call":["q pp ","q text ","q group ","q seplist ","v == ","objs pop ","options size == ","options size ","options []= "," source_range "," line_range "," docstring ","objs unshift "," type "," type != "," dup ","options << "," dup + ","options empty? "," dup +  pop "," dup +  unshift "]}," YARD Parser Ruby AstNode source":{"type":"method","name":"source","children":[],"call":[" full_source "," parent full_source [] "," source_range "," parent full_source "," parent "]}," YARD Parser Ruby AstNode full_source":{"type":"method","name":"full_source","children":[],"call":["IO  read ","File  exist? "," file "," parent full_source "," parent "]}," YARD Parser Ruby AstNode file":{"type":"method","name":"file","children":[],"call":[" parent file "," parent "]}," YARD Parser Ruby AstNode condition?":{"type":"method","name":"condition?","children":[],"call":[]}," YARD Parser Ruby AstNode call?":{"type":"method","name":"call?","children":[],"call":[]}," YARD Parser Ruby AstNode kw?":{"type":"method","name":"kw?","children":[],"call":["KEYWORDS  has_key? "," type "]}," YARD Parser Ruby AstNode literal?":{"type":"method","name":"literal?","children":[],"call":[" type =~ "," type "]}," YARD Parser Ruby AstNode ref?":{"type":"method","name":"ref?","children":[],"call":[]}," YARD Parser Ruby AstNode token?":{"type":"method","name":"token?","children":[],"call":[]}," YARD Parser Ruby AstNode children":{"type":"method","name":"children","children":[],"call":["AstNode  === "," select "]}," YARD Parser Ruby AstNode jump":{"type":"method","name":"jump","children":[],"call":["node_types include? ","child type "," traverse "]}," YARD Parser Ruby AstNode first_line":{"type":"method","name":"first_line","children":[],"call":[" full_source split [] strip "," full_source split [] "," line - "," line "," full_source split "," full_source "]}," YARD Parser Ruby AstNode line":{"type":"method","name":"line","children":[],"call":[" line_range first "," line_range "]}," YARD Parser Ruby AstNode has_line?":{"type":"method","name":"has_line?","children":[],"call":[]}," YARD Parser Ruby AstNode line_range":{"type":"method","name":"line_range","children":[],"call":[" reset_line_info "]}," YARD Parser Ruby AstNode source_range":{"type":"method","name":"source_range","children":[],"call":[" reset_line_info "]}," YARD Parser Ruby AstNode show":{"type":"method","name":"show","children":[],"call":[" first_line "," line "]}," YARD Parser Ruby AstNode ==":{"type":"method","name":"==","children":[],"call":[" type == ","ast type "," type ","other type "]}," YARD Parser Ruby AstNode initialize":{"type":"method","name":"initialize","children":[],"call":["opts [] "," source_range= "," line_range= "," type= "]}," YARD Parser Ruby AstNode node_class_for":{"type":"method","name":"node_class_for","children":[],"call":[]}," YARD Parser Ruby s":{"type":"method","name":"s","children":[],"call":["AstNode  node_class_for new ","AstNode  node_class_for ","args pop ","Hash  === ","args last ","args shift ","Symbol  === ","args first "]}," MixinHandler process_mixin":{"type":"method","name":"process_mixin","children":[],"call":[" namespace mixins << "," namespace mixins "," scope "," namespace ","Proxy  new ","obj value ","obj type= ","mixin source "," raise "," namespace path ","mixin ref? ","mixin [] "," namespace mixins unshift "," namespace mixins include? ","mixin first type == ","mixin first type ","mixin first ","rec mixins unshift ","rec mixins ","rec mixins include? ","rec nil? "," recipient ","rec mixins send "," statement method_name == "," statement method_name "," statement "," ensure_loaded! ","mixin [] == "," s ","mixin type == ","mixin type ","Proxy  new  value "," namespace  value ","Proxy  new  type= "," namespace  type= "," recipient  mixins unshift "," recipient  mixins "," recipient  mixins include? "," recipient  nil? ","  recipient ipient "," recipient  mixins send "]}," MethodHandler method_signature":{"type":"method","name":"method_signature","children":[],"call":[" statement [] jump source "," statement [] jump "," statement [] "," statement "," statement parameters source "," statement parameters "," statement parameters any? "," statement method_name "," statement  statement method_name  "]}," MethodHandler format_args":{"type":"method","name":"format_args","children":[],"call":["params << ","& + ","args block_param source ","args block_param ","a source ","args required_end_params map ","args required_end_params ","* + ","args splat_param source ","args splat_param ","a [] source ","a [] ","args optional_params map ","args optional_params ","args required_params map ","args required_params ","args jump "," statement parameters "," statement ","** + ","args keyword_param source ","args keyword_param ","args double_splat_param source ","args double_splat_param ","args named_params map ","args named_params ","args unnamed_end_params map ","args unnamed_end_params ","args unnamed_optional_params map ","args unnamed_optional_params ","args unnamed_required_params map ","args unnamed_required_params ","args args_forward ! ","args args_forward ","args jump  block_param source "," statement parameters  block_param source ","args jump  block_param "," statement parameters  block_param ","args jump  required_end_params map "," statement parameters  required_end_params map ","args jump  required_end_params "," statement parameters  required_end_params ","args jump  splat_param source "," statement parameters  splat_param source ","args jump  splat_param "," statement parameters  splat_param ","args jump  optional_params map "," statement parameters  optional_params map ","args jump  optional_params "," statement parameters  optional_params ","args jump  required_params map "," statement parameters  required_params map ","args jump  required_params "," statement parameters  required_params ","args jump  jump "," statement parameters  jump ","args jump  keyword_param source "," statement parameters  keyword_param source ","args jump  keyword_param "," statement parameters  keyword_param ","args jump  double_splat_param source "," statement parameters  double_splat_param source ","args jump  double_splat_param "," statement parameters  double_splat_param ","args jump  named_params map "," statement parameters  named_params map ","args jump  named_params "," statement parameters  named_params ","args jump  unnamed_end_params map "," statement parameters  unnamed_end_params map ","args jump  unnamed_end_params "," statement parameters  unnamed_end_params ","args jump  unnamed_optional_params map "," statement parameters  unnamed_optional_params map ","args jump  unnamed_optional_params "," statement parameters  unnamed_optional_params ","args jump  unnamed_required_params map "," statement parameters  unnamed_required_params map ","args jump  unnamed_required_params "," statement parameters  unnamed_required_params ","args jump  args jump _forward ! "," statement parameters   statement parameters _forward ! ","args jump  args jump _forward "," statement parameters   statement parameters _forward "]}," MethodConditionHandler process":{"type":"method","name":"process","children":[],"call":[" parse_block "," owner "," statement then_block "," statement "]}," ExtendHandler process_mixin":{"type":"method","name":"process_mixin","children":[],"call":[" namespace mixins << "," namespace "," namespace mixins "," scope ","mixin == "," s "," raise "," namespace is_a? "]}," ExtendHandler scope":{"type":"method","name":"scope","children":[],"call":[]}," YARD Handlers Legacy Base tokval_list":{"type":"method","name":"tokval_list","children":[],"call":["(send\n  (lvar :out) :map) compact ","e flatten join ","e flatten ","e pop ","e size == ","e size ","e empty? ","out map ","parencount < ","beforeparen == ","out last << ","token text ","out last ","out last clear ","tokval != ","TkWhitespace  === ","parencount == ","(const nil :TkTRUE) include? ! ","(const nil :TkTRUE) include? ","token class ","TkKW  === ","parencount > ","beforeparen > ","out << ","out last empty? ","out last empty? ! "," tokval ","accepted_types == ","tokenlist each ","tokval nil? ! ","tokval nil? "," tokval  != ","token text  != ","  tokval  "," token text  "," tokval  nil? ! ","token text  nil? ! "," tokval  nil? ","token text  nil? "]}," YARD Handlers Legacy Base tokval":{"type":"method","name":"tokval","children":[],"call":["token text ","Regexp  new ","token text =~ ","token text to_i ","token text to_f ","token text [] to_sym ","token text [] ","t === ","accepted_types any? ","accepted_types push ","accepted_types include? ","accepted_types empty? "]}," YARD Handlers Legacy Base parse_block":{"type":"method","name":"parse_block","children":[],"call":[" parser process "," parser ","Parser Ruby Legacy StatementList  new "," statement block "," statement "," push_state "]}," YARD Handlers Legacy Base handles?":{"type":"method","name":"handles?","children":[],"call":[]}," ClassConditionHandler parse_else_block":{"type":"method","name":"parse_else_block","children":[],"call":[" parse_block "," statement else_block "," statement "," parser process ","stmtlist new ","stmt block "," parser ","TkELSE  === ","stmt tokens first ","stmt tokens ","stmtlist new each "," statement block "," push_state "," visibility "]}," ClassConditionHandler parse_then_block":{"type":"method","name":"parse_then_block","children":[],"call":[" parse_block "," statement then_block "," statement "," visibility "]}," ClassConditionHandler parse_condition":{"type":"method","name":"parse_condition","children":[],"call":["condition ! ","condition != "," statement type == "," statement type "," statement ","var == "," s "," statement condition [] "," statement condition ","Object  instance_eval ","YARD Registry  resolve "," namespace "," statement condition [] source "," statement condition [] != "," statement condition type ","TkUNLESS  === "," statement tokens first "," statement tokens ","1 != "," statement tokens [] to_s strip "," statement tokens [] to_s "," statement tokens [] ","condition nil? ","arg source ","arg type == ","arg type "," statement condition first ","condition !  ! "," statement condition [] !=  ! ","1 !=  ! ","condition !  != "," statement condition [] !=  != ","1 !=  != "," statement condition []  == "," statement condition !  [] "," statement  statement condition [] !=  [] "," statement 1 !=  [] "," statement condition !  "," statement  statement condition [] !=  "," statement 1 !=  ","  statement condition [] source space "," arg source space "," statement condition !  [] source "," statement  statement condition [] !=  [] source "," statement 1 !=  [] source "," statement condition !  [] != "," statement  statement condition [] !=  [] != "," statement 1 !=  [] != "," statement condition !  type "," statement  statement condition [] !=  type "," statement 1 !=  type ","condition !  nil? "," statement condition [] !=  nil? ","1 !=  nil? "," statement condition first  source "," statement condition first  type == "," statement condition first  type "," statement condition !  first "," statement  statement condition [] !=  first "," statement 1 !=  first "]}," ClassConditionHandler process":{"type":"method","name":"process","children":[],"call":[" parse_else_block "," parse_then_block ","condition == "," parse_condition "," parse_condition  == "," parse_ parse_condition  "]}," YARD Handlers Ruby Base parse_block":{"type":"method","name":"parse_block","children":[],"call":[" parser process "," parser ","inner_node children ","inner_node type == ","inner_node type "," push_state "]}," YARD Handlers Ruby Base handles?":{"type":"method","name":"handles?","children":[],"call":["a_handler matches? ","a_handler == ","node source =~ ","node source ","node source == ","node type "," handlers any? "," handlers "]}," YARD Handlers Ruby Base meta_type":{"type":"method","name":"meta_type","children":[],"call":["TestNodeWrapper  new ","meth to_s + ","meth to_s ","type to_s + ","type to_s "]}," YARD Handlers Ruby Base method_call":{"type":"method","name":"method_call","children":[],"call":["MethodCallWrapper  new ","name to_s "]}," YARD Handlers Ruby TestNodeWrapper matches?":{"type":"method","name":"matches?","children":[],"call":["node send is_a? ! ","node send is_a? ","node send "," name "]}," YARD Handlers Ruby MethodCallWrapper matches?":{"type":"method","name":"matches?","children":[],"call":["node [] [] == "," name ","node [] [] ","node [] ","node [] type == ","node [] type ","node parent type == ","node parent type ","node parent ","node parent ! ","node type "," name nil? "]}," YARD Handlers Ruby HandlesExtension matches?":{"type":"method","name":"matches?","children":[],"call":[" raise "]}," YARD Handlers Ruby HandlesExtension initialize":{"type":"method","name":"initialize","children":[],"call":[]}," AttributeHandler validated_attribute_names":{"type":"method","name":"validated_attribute_names","children":[],"call":[" raise ","obj source ","obj jump source ","obj jump ","obj type ","params map "]}," YARD Handlers Processor load_handlers":{"type":"method","name":"load_handlers","children":[],"call":["@handlers_loaded []= "," parser_type "," handler_base_namespace const_get "," handler_base_namespace "," handler_base_namespace constants each "," handler_base_namespace constants ","@handlers_loaded [] ","Handlers Base  subclasses << ","Handlers Base  subclasses ","Handlers Base  subclasses include? "," handler_base_namespace  handler_base_namespace const_get _get "," handler_base_namespace  handler_base_namespace const_get ants each "," handler_base_namespace  handler_base_namespace const_get ants "]}," YARD Handlers Processor handler_base_namespace":{"type":"method","name":"handler_base_namespace","children":[],"call":[" parser_type "," class namespace_for_handler [] "," class namespace_for_handler "," class "]}," YARD Handlers Processor handler_base_class":{"type":"method","name":"handler_base_class","children":[],"call":[" handler_base_namespace const_get "," handler_base_namespace "]}," YARD Handlers Processor find_handlers":{"type":"method","name":"find_handlers","children":[],"call":["handler handles? "," owner is_a? "," owner ","handler namespace_only? "," handler_base_class > "," handler_base_class ","Base  subclasses find_all ","Base  subclasses ","handler matches_file? "," file "," handles? "]}," YARD Handlers Processor process":{"type":"method","name":"process","children":[],"call":[" log error ","Stack trace: + + ","Stack trace: + ","(send\n  (send\n    (send\n      (lvar :e) :backtrace) :[]\n    (irange\n      (int 0)\n      (int 5))) :map) join ","e backtrace [] map ","e backtrace [] ","e backtrace "," log ","stmt show ","stmt line "," file ","e message ","e class class_name ","e class ","handler to_s "," log warn ","(str \"\\tin file '\") + + ","(str \"\\tin file '\") + ","undocerr message ","missingerr object path ","missingerr object ","missingerr object type "," raise ","handler new process ","handler new "," find_handlers each "," find_handlers ","statements each_with_index "," log backtrace "," log debug "," caller last "," caller ","(dstr\n  (str \"in \")\n  (begin\n    (lvar :handler))\n  (str \": Undocumentable \")\n  (begin\n    (send\n      (lvar :undocerr) :message))\n  (str \"\\n\")) + + ","(dstr\n  (str \"in \")\n  (begin\n    (lvar :handler))\n  (str \": Undocumentable \")\n  (begin\n    (send\n      (lvar :undocerr) :message))\n  (str \"\\n\")) + "]}," YARD Handlers Processor initialize":{"type":"method","name":"initialize","children":[],"call":[" load_handlers ","YARD Registry  root ","OpenStruct  new ","parser globals ","parser parser_type ","parser file "]}," YARD Handlers Base ensure_loaded!":{"type":"method","name":"ensure_loaded!","children":[],"call":[" log debug ","object parent "," log "," raise "," parser file "," parser ","retries <= ","object is_a? "," callcc "," log warn ","RUBY_PLATFORM  =~ "," parser load_order_errors ","object == ","Registry  root ","JRuby/Rubinius do not implement Kernel#callcc and cannot  + ","object root? ","JRuby/MacRuby/Rubinius do not implement Kernel#callcc and cannot  + "," log warn_no_continuations ","Parser LoadOrderError  new "," parser parse_remaining_files ","retries > "]}," YARD Handlers Base push_state":{"type":"method","name":"push_state","children":[],"call":[" scope= "," visibility= "," owner= "," namespace "," namespace= ","opts [] "," owner "," scope "," visibility ","(pair\n  (sym :namespace)\n  (nil)) update ","(pair\n  (sym :namespace)\n  (send nil :namespace)) update ","  scope ope= ","  visibility ibility= ","(pair\n  (sym :namespace)\n  (nil)) update  [] ","(pair\n  (sym :namespace)\n  (send nil :namespace)) update  [] ","  scope ope ","  visibility ibility "]}," YARD Handlers Base namespace_only?":{"type":"method","name":"namespace_only?","children":[],"call":[]}," YARD Handlers Base namespace_only":{"type":"method","name":"namespace_only","children":[],"call":[]}," YARD Handlers Base handlers":{"type":"method","name":"handlers","children":[],"call":[]}," YARD Handlers NamespaceMissingError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Generators UMLGenerator remove_overriden_meths":{"type":"method","name":"remove_overriden_meths","children":[],"call":["sclass child ","o name ","o scope ","meth_list reject! ","CodeObjects Proxy  === ","object inheritance_tree [] each ","object inheritance_tree [] ","object inheritance_tree "]}," YARD Generators TagsGenerator tags_by_param":{"type":"method","name":"tags_by_param","children":[],"call":["(send\n  (send\n    (lvar :object) :parameters) :map) compact ","cache [] ","name [] ","p first to_s ","p first ","object parameters map ","object parameters ","cache []= ","t name to_s ","t name ","object tags each ","object tags ","(sym :param) each ","p first to_s  [] ","t p first to_s  to_s ","t p first to_s  "]}," YARD Generators TagsGenerator has_options?":{"type":"method","name":"has_options?","children":[],"call":["object has_tag? "]}," YARD Generators TagsGenerator has_params?":{"type":"method","name":"has_params?","children":[],"call":[" tags_by_param size > "," tags_by_param size "," tags_by_param ","object is_a? "]}," YARD Generators TagsGenerator yieldreturn":{"type":"method","name":"yieldreturn","children":[],"call":[" render_tags "]}," YARD Generators TagsGenerator yield":{"type":"method","name":"yield","children":[],"call":[" render_tags "]}," YARD Generators RootGenerator is_root?":{"type":"method","name":"is_root?","children":[],"call":["object == ","Registry  root "]}," YARD Generators RootGenerator has_data?":{"type":"method","name":"has_data?","children":[],"call":["object constants size > ","object constants size ","object constants ","object meths size > ","object meths size ","object meths "]}," YARD Generators RootGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[" G "]}," YARD Generators OverloadsGenerator has_overloads?":{"type":"method","name":"has_overloads?","children":[],"call":["object tags size > ","object tags size ","object tags "]}," YARD Generators OverloadsGenerator sections_for":{"type":"method","name":"sections_for","children":[],"call":[" G "]}," YARD Generators MixinsGenerator initialize":{"type":"method","name":"initialize","children":[],"call":[" options [] "," options "]}," YARD Generators MethodGenerator isnt_overload?":{"type":"method","name":"isnt_overload?","children":[],"call":["object is_a? ! ","object is_a? "]}," YARD Generators MethodGenerator source":{"type":"method","name":"source","children":[],"call":[" render_section "," G "]}," YARD Helpers MethodHelper format_code":{"type":"method","name":"format_code","children":[],"call":["(send\n  (lvar :lines) :map) join ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + ","lineno to_s ","  * ","longestline - ","lineno to_s length ","object line + ","object line ","lines map ","(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s length ","(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s ","lines size ","object source split ","object source ","(send\n  (lvar :object source split ) :map) join ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :object line + ) :to_s) :length)))) + + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s length ) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :object line + ) :to_s) :length)))) + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s length ) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :longestline) :-\n      (send\n        (send\n          (lvar :object line + ) :to_s) :length)))) + ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s length ) :-\n      (send\n        (send\n          (lvar :lineno) :to_s) :length)))) + ","object line +  to_s ","(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :lines) :size)) to_s length  - ","object line +  to_s length ","object source split  map ","(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :object source split ) :size)) to_s length ","(send\n  (send\n    (lvar :object) :line) :+\n  (send\n    (lvar :object source split ) :size)) to_s ","object source split  size "]}," YARD Helpers MethodHelper format_lines":{"type":"method","name":"format_lines","children":[],"call":["(send\n  (send\n    (send\n      (lvar :object) :source) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","object line + ","object line ","object source split map ","object source split ","object source ","object line nil? ","object source nil? "]}," YARD Helpers MarkupHelper markup_provider":{"type":"method","name":"markup_provider","children":[],"call":["@markup_cache [] [] ","@markup_cache [] ","type == ","MarkupHelper  markup_cache [] [] ","MarkupHelper  markup_cache [] ","MarkupHelper  markup_cache "]}," YARD Helpers MarkupHelper markup_class":{"type":"method","name":"markup_class","children":[],"call":["@markup_cache [] [] ","@markup_cache [] ","type == ","MarkupHelper  markup_cache [] [] ","MarkupHelper  markup_cache [] ","MarkupHelper  markup_cache "," load_markup_provider "]}," YARD Helpers MarkupHelper load_markup_provider":{"type":"method","name":"load_markup_provider","children":[],"call":[" exit ","STDERR  puts "," options [] to_s capitalize "," options [] to_s "," options [] "," options ","providers first [] ","providers first ","@markup_cache [] []= ","Kernel  const_get ","provider [] ","@markup_cache [] "," require ","provider [] to_s ","providers each ","providers empty? ","providers == ","p [] == ","p [] ","MARKUP_PROVIDERS  [] select ","MARKUP_PROVIDERS  [] ","type == ","providers select "," log error "," log "," eval ","MarkupHelper  markup_cache [] []= ",":: + ","MarkupHelper  markup_cache [] ","MarkupHelper  markup_cache ","(str \"Invalid markup type '\") + ","type to_sym ","type to_s capitalize ","type to_s "," options markup_provider ","providers nil? ","MARKUP_PROVIDERS  []  first [] ","MARKUP_PROVIDERS  []  first ","MARKUP_PROVIDERS  []  each ","MARKUP_PROVIDERS  []  empty? ","MARKUP_PROVIDERS  []  == ","MARKUP_PROVIDERS  []  select ","MARKUP_PROVIDERS  []  nil? "]}," YARD Generators Helpers HtmlSyntaxHighlightHelper html_syntax_highlight_legacy":{"type":"method","name":"html_syntax_highlight_legacy","children":[],"call":["(send\n  (lvar :tokenlist) :map) join "," h ","s text ","s class superclass class_name sub downcase ","s class superclass class_name sub ","s class superclass class_name ","s class superclass ","s class ","s class class_name sub downcase ","s class class_name sub ","s class class_name ","tokenlist map ","Parser Ruby Legacy TokenList  new ","(send\n  (lvar :Parser Ruby Legacy TokenList  new ) :map) join ","Parser Ruby Legacy TokenList  new  map "]}," YARD Generators Helpers HtmlSyntaxHighlightHelper html_syntax_highlight":{"type":"method","name":"html_syntax_highlight","children":[],"call":["output << ","(sym :tstring_end) include? ","s [] "," h ","s last ","s first ","(sym :tstring_beg) include? ","tokenlist each ","Parser Ruby RubyParser  parse tokens ","Parser Ruby RubyParser  parse ","Parser Ruby RubyParser  parse tokens  each "]}," YARD Helpers HtmlHelper url_for_file":{"type":"method","name":"url_for_file","children":[],"call":["link + + ","# + "," urlencode ","link + ","File  relative_path "," serializer serialized_path "," serializer ","fromobj namespace ","fromobj is_a? ! ","fromobj is_a? ","CodeObjects Base  === "," current_object ","file. + ","File  basename gsub ","File  basename ","filename == "," options [] "," options "," object "," options readme ","File  relative_path  + + ","File  relative_path  + ","File  relative_ serializer serialized_path  "," serializer serialized_ serializer serialized_path  "," serializer serialized_path obj namespace ","fromobj namespace  namespace "," current_object  namespace "," object  namespace "," serializer serialized_path obj is_a? ! ","fromobj namespace  is_a? ! "," current_object  is_a? ! "," object  is_a? ! "," serializer serialized_path obj is_a? ","fromobj namespace  is_a? "," current_object  is_a? "," object  is_a? ","file. +  == "]}," YARD Helpers HtmlHelper tag_attrs":{"type":"method","name":"tag_attrs","children":[],"call":["(send\n  (lvar :opts) :map) join ","v to_s inspect ","v to_s ","opts map ","(send\n  (block\n    (send\n      (lvar :opts) :sort_by)\n    (args\n      (arg :k)\n      (arg :v))\n    (send\n      (lvar :k) :to_s)) :map) join ","(send\n  (lvar :opts) :sort_by) map ","k to_s ","opts sort_by ","(send\n  (block\n    (send\n      (lvar :opts) :sort_by)\n    (args\n      (arg :k)\n      (arg :_v))\n    (send\n      (lvar :k) :to_s)) :map) join "]}," YARD Helpers HtmlHelper link_url":{"type":"method","name":"link_url","children":[],"call":[" tag_attrs ","SymbolHash  new update update ","SymbolHash  new update ","SymbolHash  new "," h ","params [] ","url =~ ","(str \"<a \") gsub ","title gsub! ","title gsub ","SymbolHash  new update update  [] ","title gsub  gsub! ","title gsub  gsub "]}," YARD Helpers HtmlHelper link_file":{"type":"method","name":"link_file","children":[],"call":[" link_url "," url_for_file ","file title "," serializer ","CodeObjects ExtraFileObject  new ","File  file? ","CodeObjects ExtraFileObject  === "," url_for_CodeObjects ExtraFileObject  new  ","CodeObjects ExtraFileObject  new  title ","File  CodeObjects ExtraFileObject  new ? "]}," YARD Helpers HtmlHelper fix_dash_dash":{"type":"method","name":"fix_dash_dash","children":[],"call":["text gsub "]}," YARD Helpers HtmlHelper fix_typewriter":{"type":"method","name":"fix_typewriter","children":[],"call":["text gsub ","<tt> + + ","<tt> + ","1 gsub ","pre_match last include? ","pre_match last ","pre_match last nil? ","pre_text scan "," h ","first_text + + + ","first_text + + ","first_text + ","pre_match last [] == ","pre_match last [] ","(send\n  (lvar :pre_text) :+\n  (lvar :first_text)) scan ","pre_text + ","pre_text scan  last include? ","(send\n  (lvar :pre_text) :+\n  (lvar :first_text)) scan  last include? ","pre_text scan  last ","(send\n  (lvar :pre_text) :+\n  (lvar :first_text)) scan  last ","pre_text scan  last nil? ","(send\n  (lvar :pre_text) :+\n  (lvar :first_text)) scan  last nil? ","pre_text scan  last [] == ","(send\n  (lvar :pre_text) :+\n  (lvar :first_text)) scan  last [] == ","pre_text scan  last [] ","(send\n  (lvar :pre_text) :+\n  (lvar :first_text)) scan  last [] "]}," Helpers BaseHelper overloads":{"type":"method","name":"overloads","children":[],"call":["method tags ","method has_tag? "]}," Helpers BaseHelper format_object_title":{"type":"method","name":"format_object_title","children":[],"call":[" format_object_type + + ","object path "," format_object_type + "," format_object_type ","object title "]}," YARD Generators FullDocGenerator methods_to_show":{"type":"method","name":"methods_to_show","children":[],"call":["object path ","meths sort_by "," options [] call is_a? "," options [] call "," options [] "," options ","meths reject! ","object is_explicit? ","more_meths select ","namespace meths ","namespace is_a? ","namespaces inject ","namespace meths  select "]}," YARD Generators FullDocGenerator markup_for":{"type":"method","name":"markup_for","children":[],"call":["markup to_sym ","@contents gsub! ","@contents =~ "," format == "," format ","File  extname downcase ","File  extname "]}," YARD Generators FullDocGenerator generate_files":{"type":"method","name":"generate_files","children":[],"call":[" serializer serialize "," render ","file + "," serializer ","File  basename ","File  read ","File  exists? "," extra_files each "," extra_files "," format == "," format ","File  basename  + "," extra_File  basename s each "," extra_File  basename s "]}," YARD Generators FullDocGenerator extra_files":{"type":"method","name":"extra_files","children":[],"call":["(send nil :readme_file) + "," options [] "," options "," readme_file "]}," YARD Generators FullDocGenerator readme_file_exists?":{"type":"method","name":"readme_file_exists?","children":[],"call":[" readme_file empty? ! "," readme_file empty? "," readme_file "]}," YARD Generators FullDocGenerator setup_options":{"type":"method","name":"setup_options","children":[],"call":[" options [] "," options ","Dir  [] "]}," YARD Generators Base render_method":{"type":"method","name":"render_method","children":[],"call":[" instance_eval "," erb src "," erb ","(str \"<% \") + ","File  read ","(send\n  (lvar :locals) :map) join ","k inspect ","locals map "," instance_eva(send\n  (lvar :locals) :map) join  "," erb  erb src  ","Fi(send\n  (lvar :locals) :map) join e  read ","(send\n  ((send\n  (lvar :locals) :map) join var :(send\n  (lvar :locals) :map) join oca(send\n  (lvar :locals) :map) join s) :map) join ","(send\n  (lvar :locals) :map) join oca(send\n  (lvar :locals) :map) join s map "]}," YARD Docstring parse_comments":{"type":"method","name":"parse_comments","children":[],"call":["docstring gsub! ","docstring << << ","docstring << ","tag_name ! ","raw_buf << ","line gsub ","tag_buf << ","last_line =~ ","empty ! ","indent >= ","tag_buf dup ","line =~ "," create_tag ","indent <= ","indent < ","comments size == ","comments size ","line [] length ","line [] ","(send\n  (lvar :comments) :+\n  (array\n    (str \"\"))) each_with_index ","comments + ","comments first [] length ","comments first [] ","comments first ","comments split ","comments is_a? ","comments empty? ","comments ! ","orig_indent == ","tag_buf join ","indent == ","parser text "," add_tag ","parser tags ","parser parse "," object ","DocstringParser  new "," class parser "," class ","parser reference ","parser raw_text ","line [] length  >= ","line [] length  <= ","line [] length  < ","comments split  size == ","comments split  size ","(send\n  (lvar :comments split ) :+\n  (array\n    (str \"\"))) each_with_index ","comments split  + ","comments split  first [] length ","comments split  first [] ","comments split  first ","comments split  split ","comments split  is_a? ","comments split  empty? ","comments split  ! ","orig_line [] length  == ","line [] length  == ","DocstringParser  new  text "," class parser  text ","DocstringParser  new  tags "," class parser  tags ","DocstringParser  new  parse "," class parser  parse "," class DocstringParser  new  "," class  class parser  ","DocstringParser  new  reference "," class parser  reference ","DocstringParser  new  raw_text "," class parser  raw_text "]}," YARD Docstring create_tag":{"type":"method","name":"create_tag","children":[],"call":[" log warn ","(str \"Invalid tag format for @\") + "," object line "," object "," object file "," log ","(str \"Unknown tag @\") + "," add_tag ","@tag_factory send ","raw_buf join ","@tag_factory method arity == ","@tag_factory method arity ","@tag_factory method ","@tag_factory respond_to? "," create_ref_tag ","tag_buf =~ ","tag_factory send ","tag_factory method arity == ","tag_factory method arity ","tag_factory method ","tag_factory respond_to? ","Tags Library  instance ","(send\n  (lvar :tag_factory) :send\n  (lvar :tag_method)\n  (lvar :tag_buf)) flatten ","@Tags Library  instance  send ","@Tags Library  instance  method arity == ","@Tags Library  instance  method arity ","@Tags Library  instance  method ","@Tags Library  instance  respond_to? ","Tags Library  instance  send ","Tags Library  instance  method arity == ","Tags Library  instance  method arity ","Tags Library  instance  method ","Tags Library  instance  respond_to? ","(send\n  (lvar :Tags Library  instance ) :send\n  (lvar :tag_method)\n  (lvar :tag_buf)) flatten "]}," YARD Docstring create_ref_tag":{"type":"method","name":"create_ref_tag","children":[],"call":["@ref_tags << ","Tags RefTagList  new "," P "," object "]}," YARD Docstring convert_ref_tags":{"type":"method","name":"convert_ref_tags","children":[],"call":["(send\n  (lvar :list) :map) flatten ","t tags ","list map ","CodeObjects Proxy  === ","t owner ","@ref_tags reject ","list map flatten "," log error ","(send\n  (ivar :@ref_tags) :map) join ","t tag_name ","@ref_tags map ","@object line ","@object file "," log ","@ref_tag_recurse_count > ","(send\n  (lvar :list map flatten ) :map) flatten ","list map flatten  map ","list map flatten  map flatten "]}," YARD Docstring blank?":{"type":"method","name":"blank?","children":[],"call":["@ref_tags empty? ","@tags empty? "," empty? ","(send\n  (send nil :tags) :any?) ! ","Tags Library  visible_tags include? ","tag tag_name to_sym ","tag tag_name ","Tags Library  visible_tags "," tags any? "," tags "]}," YARD Docstring has_tag?":{"type":"method","name":"has_tag?","children":[],"call":["tag tag_name to_s == ","name to_s ","tag tag_name to_s ","tag tag_name "," tags any? "," tags "]}," YARD Docstring tags":{"type":"method","name":"tags","children":[],"call":["tag tag_name to_s == ","name to_s ","tag tag_name to_s ","tag tag_name ","list select ","@tags + "," convert_ref_tags "," stable_sort_by ","@tags +  select "," stable_sort_by  select "]}," YARD Docstring tag":{"type":"method","name":"tag","children":[],"call":["tag tag_name to_s == ","name to_s ","tag tag_name to_s ","tag tag_name "," tags find "," tags "]}," YARD Docstring add_tag":{"type":"method","name":"add_tag","children":[],"call":[" raise ","tag class ","@ref_tags << ","@tags << ","tag object= "," object ","tags each_with_index "]}," YARD Docstring summary":{"type":"method","name":"summary","children":[],"call":["@summmary empty? "," split first "," split ","summary empty? ","@summary empty? "," [] ","index - ","next_char =~ ","num_parens == "," [] to_s ","index + "," length times "," length ","@summary !~ ","@summary empty? ! "," resolve_reference ","stripped [] ","stripped [] to_s "," gsub strip "," gsub "," gsub gsub strip "," gsub gsub ","stripped [] == ","num_parens <= "," []  empty? ","stripped []  empty? "," [] to_s  =~ ","stripped [] to_s  =~ "," []  !~ ","stripped []  !~ "," []  empty? ! ","stripped []  empty? ! "," gsub strip  [] "," gsub gsub strip  [] "," gsub strip  [] to_s "," gsub gsub strip  [] to_s "," gsub strip  [] == "," gsub gsub strip  [] == "]}," YARD Docstring initialize":{"type":"method","name":"initialize","children":[],"call":[" replace "," parse_comments ","Tags Library  new "," all= "]}," SymbolHash merge":{"type":"method","name":"merge","children":[],"call":[" dup merge! "," dup "]}," CodeObjects NamespaceObject mixins":{"type":"method","name":"mixins","children":[],"call":[" class_mixins | "," instance_mixins "," class_mixins ","scopes == "]}," CodeObjects ModuleObject inheritance_tree":{"type":"method","name":"inheritance_tree","children":[],"call":["(self) + ","(send\n  (send nil :mixins\n    (sym :instance)) :map) flatten ","m inheritance_tree ","m respond_to? "," mixins map "," mixins ","(send\n  (send nil :mixins\n    (sym :instance)\n    (sym :class)) :map) compact flatten ","(send\n  (send nil :mixins\n    (sym :instance)\n    (sym :class)) :map) compact ","m == ","(send\n  (send nil :mixins\n    (sym :instance)\n    (sym :class)) :map) compact flatten uniq "]}," CodeObjects ExtendedMethodObject method_missing":{"type":"method","name":"method_missing","children":[],"call":["@del __send__ "]}," CodeObjects ExtendedMethodObject initialize":{"type":"method","name":"initialize","children":[],"call":[]}," CodeObjects ExtendedMethodObject scope":{"type":"method","name":"scope","children":[],"call":[]}," YARD CodeObjects Base line":{"type":"method","name":"line","children":[],"call":["@files first [] ","@files first "]}," YARD CodeObjects Base file":{"type":"method","name":"file","children":[],"call":["@files first [] ","@files first "]}," YARD CodeObjects Base add_file":{"type":"method","name":"add_file","children":[],"call":["@files << ","@files unshift ","@current_file_has_comments ! ","file to_s "," raise ","file == ","file nil? "," files include? "," files "]}," YARD CodeObjects Base ===":{"type":"method","name":"===","children":[],"call":[" >= ","other class ","other is_a? "]}," YARD CLI Yardoc support_rdoc_document_file!":{"type":"method","name":"support_rdoc_document_file!","children":[],"call":["IO  read split ","IO  read ","IO  read gsub split ","IO  read gsub ","File  read gsub split ","File  read gsub ","File  read "," use_document_file "]}," YARD CLI Yardoc yardopts":{"type":"method","name":"yardopts","children":[],"call":["IO  read split ","IO  read "," options_file ","IO  read shell_split ","File  read_binary shell_split ","File  read_binary "," use_yardopts_file "]}," YARD CLI Yardoc all_objects":{"type":"method","name":"all_objects","children":[],"call":["Registry  all ","(send\n  (send\n    (const nil :Registry) :paths\n    (false)) :map) compact ","types include? ","obj type ","Registry  at ","Registry  paths map ","Registry  paths "," use_cache ","Registry  at  type "]}," YARD parse_string":{"type":"method","name":"parse_string","children":[],"call":[]}," YARD Legacy StatementList sanitize_block":{"type":"method","name":"sanitize_block","children":[],"call":["@statement []= ","TkBlockContents  === ","@statement each_with_index ","extra unshift ","@block pop ","TkSEMICOLON  === ","@block last ","(const nil :TkSPACE) include? ","@block last class "]}," YARD Legacy StatementList sanitize_statement_end":{"type":"method","name":"sanitize_statement_end","children":[],"call":["@statement insert ","index + ","extra unshift ","@statement delete_at ","index - ","(const nil :TkNL) include? ","@statement [] class ","@statement [] ","TkStatementEnd  === ","(send\n  (send\n    (ivar :@statement) :size) :-\n  (int 1)) downto ","@statement size - ","@statement size "]}," YARD Legacy Statement to_s":{"type":"method","name":"to_s","children":[],"call":["(send\n  (send nil :tokens) :map) join ","token text "," block to_s "," block ","RubyToken TkBlockContents  === "," tokens map "," tokens "]}," YARD Legacy Statement first_line":{"type":"method","name":"first_line","children":[],"call":[" to_s "," to_s split [] "," to_s split "]}," YARD Legacy RubyToken TkStatementEnd text":{"type":"method","name":"text","children":[],"call":[]}," YARD Legacy RubyToken TkBlockContents text":{"type":"method","name":"text","children":[],"call":[]}," YARD Generators TagsGenerator has_todo?":{"type":"method","name":"has_todo?","children":[],"call":["object has_tag? "]}," YARD Generators TagsGenerator with_overload":{"type":"method","name":"with_overload","children":[],"call":["(send\n  (lvar :object) :tag\n  (sym :overload)) + ","object tag "]}," YARD Generators FullDocGenerator css_custom_file":{"type":"method","name":"css_custom_file","children":[],"call":[]}," YARD Docstring line":{"type":"method","name":"line","children":[],"call":[" line_range first "," line_range "]}," YARD Docstring replace":{"type":"method","name":"replace","children":[],"call":[" parse_comments ","content join ","content is_a? ","content join  join ","content join  is_a? "]}," YARD CLI Yardoc parse_files":{"type":"method","name":"parse_files","children":[],"call":[" files << "," files "," add_extra_files ","file == ","files each "," files= "]}," YARD CLI Yardoc add_extra_files":{"type":"method","name":"add_extra_files","children":[],"call":[" options [] << "," options [] "," options "," raise ","File  file? ","files each ","(send\n  (lvar :files) :map!) flatten! ","Dir  glob ","f include? ","files map! "," log warn "," log ","CodeObjects ExtraFileObject  new "," options files << "," options files "," extra_file_valid? "]}," DocManager install_rdoc_yard":{"type":"method","name":"install_rdoc_yard","children":[],"call":[" install_yardoc ","@spec has_yardoc? "," install_rdoc_yard_orig ","@spec has_rdoc? ","@@install_rdoc_yard_orig bind call ","@@install_rdoc_yard_orig bind "]}," DocManager install_ri_yard":{"type":"method","name":"install_ri_yard","children":[],"call":[" install_ri_yard_orig ","@spec has_rdoc? ","@@install_ri_yard_orig bind call ","@@install_ri_yard_orig bind "," run_yardoc "," say ","@spec full_name "," class load_yardoc "," class ","@spec has_yardoc? ","@spec has_rdoc? == "]}," DocManager install_yardoc":{"type":"method","name":"install_yardoc","children":[],"call":[" run_yardoc "," say ","@spec full_name ","FileUtils  rm_rf ","File  join "]}," DocManager setup_rdoc":{"type":"method","name":"setup_rdoc","children":[],"call":[" class load_yardoc "," class ","@spec has_yardoc? "," class load_rdoc ","@spec has_rdoc? ","FileUtils  mkdir_p ","File  exist? "," raise ","Gem FilePermissionError  new ","File  writable? ! ","File  writable? "]}," DocManager run_yardoc":{"type":"method","name":"run_yardoc","children":[],"call":["Dir  chdir "," ui errs puts "," ui errs "," ui ","ex backtrace join ","ex backtrace ","Gem  configuration backtrace ","Gem  configuration ","args join "," alert_error ","@spec full_name "," raise ","Gem FilePermissionError  new ","File  dirname ","e message split [] strip ","e message split [] ","e message split ","e message ","YARD CLI Yardoc  run ","@spec full_gem_path ","Dir  pwd ","arg to_s ","args flatten map ","args flatten ","args << ","p + ","@spec require_paths map ","@spec require_paths ","@spec extra_rdoc_files join ","@spec extra_rdoc_files ","@spec extra_rdoc_files size > ","@spec extra_rdoc_files size ","@spec rdoc_options ","File  file? ","File  join ","@spec extra_rdoc_files empty? ","args flatten map  join ","File  File  dirname  ","args flatten map  flatten map ","args flatten map  flatten ","args flatten map  << "]}," DocManager load_yardoc":{"type":"method","name":"load_yardoc","children":[],"call":[]}," Specification has_rdoc?":{"type":"method","name":"has_rdoc?","children":[],"call":["@has_rdoc != "]}," Specification has_yardoc":{"type":"method","name":"has_yardoc","children":[],"call":["@has_rdoc == "]}," Specification has_yardoc=":{"type":"method","name":"has_yardoc=","children":[],"call":[]}," YARD Logger format_log":{"type":"method","name":"format_log","children":[],"call":["sev downcase "]}," YARD Logger instance":{"type":"method","name":"instance","children":[],"call":[]}," __p":{"type":"method","name":"__p","children":[],"call":["File  join ","path split "]}," YARD Parser Ruby RubyParser on_lambda":{"type":"method","name":"on_lambda","children":[],"call":[" visit_event_arr ","AstNode  new "]}," YARD Parser Ruby RubyParser on_label":{"type":"method","name":"on_label","children":[],"call":["AstNode  new "," charno - "," charno "," lineno ","data [] ","data length "," add_token ","  charno arno - ","  charno arno "]}," YARD load_plugins":{"type":"method","name":"load_plugins","children":[],"call":[]}," YARD Verifier parse_expression":{"type":"method","name":"parse_expression","children":[],"call":["expr gsub ","expr gsub  gsub "]}," YARD Verifier create_method_from_expressions":{"type":"method","name":"create_method_from_expressions","children":[],"call":[" instance_eval ","93 + ","(send\n  (send\n    (lvar :exprs) :flatten) :map) join "," parse_expression ","exprs flatten map ","exprs flatten ","110 + ","(send\n  (send nil :expressions) :map) join "," expressions map "," expressions ","129 + ","131 + ","132 + ","133 + ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :exprs) :flatten) :map) join s) :flatten) :map) join ","(send\n  (send\n    (lvar :(send\n  (send nil :expressions) :map) join s) :flatten) :map) join "," parse_(send\n  (send\n    (lvar :exprs) :flatten) :map) join ession "," parse_(send\n  (send nil :expressions) :map) join ession ","(send\n  (send\n    (lvar :exprs) :flatten) :map) join s flatten map ","(send\n  (send nil :expressions) :map) join s flatten map ","(send\n  (send\n    (lvar :exprs) :flatten) :map) join s flatten ","(send\n  (send nil :expressions) :map) join s flatten ","(send\n  (send nil :(send\n  (send\n    (lvar :exprs) :flatten) :map) join essions) :map) join ","(send\n  (send nil :(send\n  (send nil :expressions) :map) join essions) :map) join "," (send\n  (send\n    (lvar :exprs) :flatten) :map) join essions map "," (send\n  (send nil :expressions) :map) join essions map "," (send\n  (send\n    (lvar :exprs) :flatten) :map) join essions "," (send\n  (send nil :expressions) :map) join essions "]}," YARD Verifier unmodify_nilclass":{"type":"method","name":"unmodify_nilclass","children":[],"call":["NilClass  send ","NILCLASS_METHODS  each "," respond_to? "]}," YARD Verifier modify_nilclass":{"type":"method","name":"modify_nilclass","children":[],"call":["NilClass  send ","NILCLASS_METHODS  each "]}," YARD Verifier call":{"type":"method","name":"call","children":[],"call":[" unmodify_nilclass "," __execute "," modify_nilclass ","object is_a? "]}," YARD Verifier method_missing":{"type":"method","name":"method_missing","children":[],"call":[" object send "," object "," object respond_to? "]}," YARD Verifier initialize":{"type":"method","name":"initialize","children":[],"call":[" create_method_from_expressions ","expressions flatten "," add_expressions "]}," YARD Helpers UMLHelper tidy":{"type":"method","name":"tidy","children":[],"call":["(send\n  (send\n    (lvar :data) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) compact join + ","(send\n  (send\n    (lvar :data) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) compact join ","(send\n  (send\n    (lvar :data) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) compact ","line =~ ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :indent) :*\n      (int 2)))) + ","  * ","indent * ","line empty? ","line gsub! ","data split map ","data split ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :indent) :*\n      (int 2)))) +  =~ ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :indent) :*\n      (int 2)))) +  empty? ","(send\n  (str \" \") :*\n  (begin\n    (send\n      (lvar :indent) :*\n      (int 2)))) +  gsub! "]}," YARD Helpers UMLHelper h":{"type":"method","name":"h","children":[],"call":["text to_s gsub ","text to_s "]}," YARD Helpers UMLHelper format_path":{"type":"method","name":"format_path","children":[],"call":["object path gsub ","object path "]}," YARD Templates Helpers TextHelper signature":{"type":"method","name":"signature","children":[],"call":["title gsub ","%s%s%s %s -> %s %s % ","( + + ","( + ","extras join ","extras empty? ","extras << ","meth visibility ","meth visibility != ","attname join + ","attname join ","attname size == ","attname size ","(if\n  (send\n    (lvar :rw) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact ","rw [] ","meth namespace attributes [] [] ","meth name ","meth namespace attributes [] ","meth scope ","meth namespace attributes ","meth namespace "," format_args "," format_block ","meth namespace name to_s downcase ","meth namespace name to_s ","meth namespace name ","meth scope == ","meth tag types first ","meth tag types ","meth tag ","%s%s%s %s%s%s % ","type empty? ","type include? ","types join "," options [] "," options ","types == ","(lvar :first) join ","types size > ","types size ","first + ","types last =~ ","Regexp  quote ","types first ","types last ","types size == ","types last == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten ","t types ","meth tags map ","meth tags ","meth tag tag ","meth tag ! ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq ","(send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq ","(send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten ","rmeth tags map ","rmeth tags ","rmeth tag types ","rmeth tag ","meth object ","rmeth respond_to? ","rmeth has_tag? ! ","rmeth has_tag? "," options hide_void_return "," options default_return ","%s%s%s %s -> %s %s %  gsub ","%s%s%s %s%s%s %  gsub ","meth tag  visibility ","meth tag  visibility != ","attname join +  join + ","(if\n  (send\n    (lvar :rw) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact  join + ","attmeth name  join + ","attname join +  join ","(if\n  (send\n    (lvar :rw) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact  join ","attmeth name  join ","attname join +  size == ","(if\n  (send\n    (lvar :rw) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact  size == ","attmeth name  size == ","attname join +  size ","(if\n  (send\n    (lvar :rw) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact  size ","attmeth name  size ","(if\n  (send\n    (lvar :meth namespace attributes [] [] ) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact ","meth namespace attributes [] []  [] ","meth meth name space attributes [] [] ","meth tag  namespace attributes [] [] ","meth meth name  ","meth tag  name ","meth meth name space attributes [] ","meth tag  namespace attributes [] ","meth tag  scope ","meth meth name space attributes ","meth tag  namespace attributes ","meth meth name space ","meth tag  namespace "," format_ format_args  ","meth meth name space meth name  to_s downcase ","meth tag  namespace name to_s downcase ","meth meth name space meth name  to_s ","meth tag  namespace name to_s ","meth meth name space meth name  ","meth tag  namespace name ","meth tag  scope == ","meth tag types join s first ","meth tag (lvar :first) join s first ","meth tag first + s first ","meth tag types types first  ","meth tag (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  first ","meth tag (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  first ","meth tag (send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  first ","meth tag  tag types first ","meth tag types join s ","meth tag (lvar :first) join s ","meth tag first + s ","meth tag (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  ","meth tag (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  ","meth tag (send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  ","meth tag  tag types ","meth tag  tag ","types join  empty? ","(lvar :first) join  empty? ","first +  empty? ","types join  include? ","(lvar :first) join  include? ","first +  include? ","types join s join ","(lvar :first) join s join ","first + s join ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  join ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  join ","(send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  join ","types join s == ","(lvar :first) join s == ","first + s == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  == ","(send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  == ","(lvar :types first ) join ","types join s size > ","(lvar :first) join s size > ","first + s size > ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  size > ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  size > ","(send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  size > ","types join s size ","(lvar :first) join s size ","first + s size ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  size ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  size ","(send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  size ","types first  + ","types join s last =~ ","(lvar :first) join s last =~ ","first + s last =~ ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  last =~ ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  last =~ ","(send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  last =~ ","types join s first ","(lvar :first) join s first ","first + s first ","types types first  ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  first ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  first ","(send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  first ","types join s last ","(lvar :first) join s last ","first + s last ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  last ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  last ","(send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  last ","types join s size == ","(lvar :first) join s size == ","first + s size == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  size == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  size == ","(send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  size == ","types join s last == ","(lvar :first) join s last == ","first + s last == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  last == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  last == ","(send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  last == ","(send\n  (send\n    (lvar :meth tag ) :tags\n    (sym :return)) :map) flatten ","t types join s ","t (lvar :first) join s ","t first + s ","t (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  ","t (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  ","t (send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  ","meth tag  tags map ","meth tag  tags ","meth tag  tag tag ","meth tag  tag ! ","(send\n  (send\n    (lvar :meth tag ) :tags\n    (sym :return)) :map) flatten uniq ","(send\n  (send\n    (lvar :rmeth tag ) :tags\n    (sym :return)) :map) flatten uniq ","(send\n  (send\n    (lvar :meth object ) :tags\n    (sym :return)) :map) flatten uniq ","(send\n  (send\n    (lvar :rmeth tag ) :tags\n    (sym :return)) :map) flatten ","(send\n  (send\n    (lvar :meth object ) :tags\n    (sym :return)) :map) flatten ","rmeth tag  tags map ","meth object  tags map ","rmeth tag  tags ","meth object  tags ","rmeth tag types join s ","rmeth tag (lvar :first) join s ","rmeth tag first + s ","rmeth tag (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  ","rmeth tag (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  ","rmeth tag (send\n  (send\n    (lvar :rmeth) :tags\n    (sym :return)) :map) flatten uniq  ","rmeth tag  tag types ","meth object  tag types ","rmeth tag  tag ","meth object  tag ","meth tag  object ","rmeth tag  respond_to? ","meth object  respond_to? ","rmeth tag  has_tag? ! ","meth object  has_tag? ! ","rmeth tag  has_tag? ","meth object  has_tag? "]}," YARD Templates Helpers TextHelper hr":{"type":"method","name":"hr","children":[],"call":["sep * "]}," YARD Templates Helpers TextHelper align_right":{"type":"method","name":"align_right","children":[],"call":["spacer * + + ","spacer * + ","spacer * ","col - - ","text length ","col - ","text [] + ","text [] ","(send\n  (send\n    (lvar :col) :-\n    (int 1)) :-\n  (send\n    (lvar :text) :length)) < ","text [] +  length ","text [] +  [] + ","text [] +  [] ","(send\n  (send\n    (lvar :col) :-\n    (int 1)) :-\n  (send\n    (lvar :text [] + ) :length)) < "]}," YARD Templates Helpers TextHelper title_align_right":{"type":"method","name":"title_align_right","children":[],"call":[" align_right "]}," YARD Templates Helpers TextHelper indent":{"type":"method","name":"indent","children":[],"call":["text gsub ","  * "]}," YARD Templates Helpers TextHelper wrap":{"type":"method","name":"wrap","children":[],"call":["text gsub "]}," YARD Templates Helpers TextHelper h":{"type":"method","name":"h","children":[],"call":["out << ","line + ","text [] =~ ","text [] ","i + ","text each_with_index ","text split "," resolve_links ","String  new ","String  new  << ","text split  [] =~ "," resolve_links  [] =~ ","text split  [] "," resolve_links  [] ","text split  each_with_index "," resolve_links  each_with_index ","text split  split "," resolve_links  split "]}," YARD Templates Helpers ModuleHelper prune_method_listing":{"type":"method","name":"prune_method_listing","children":[],"call":["o is_attribute? ","CodeObjects Proxy  === ","o namespace ","list reject ","o is_alias? "," options [] include? ! "," options [] include? ","o visibility "," options [] "," options "," run_verifier "," run_verifier empty? ","o parent "," run_verifier  reject "]}," YARD Helpers MethodHelper format_constant":{"type":"method","name":"format_constant","children":[],"call":[" html_syntax_highlight ","value gsub ","sp size ","value split last [] ","value split last ","value split ","sp [] ","value split last []  size ","sp []  size ","value value split last [] lit last [] ","value sp [] lit last [] ","value value split last [] lit last ","value sp [] lit last ","value value split last [] lit ","value sp [] lit ","value split last []  [] ","sp []  [] "]}," YARD Templates Helpers HtmlSyntaxHighlightHelper html_syntax_highlight":{"type":"method","name":"html_syntax_highlight","children":[],"call":["(send\n  (lvar :tokenlist) :map) join "," h ","s text ","s class superclass class_name sub downcase ","s class superclass class_name sub ","s class superclass class_name ","s class superclass ","s class ","s class class_name sub downcase ","s class class_name sub ","s class class_name ","tokenlist map ","Parser Ruby Legacy TokenList  new "," options [] "," options ","output << ","(sym :tstring_end) include? ","s [] ","s last ","s first ","(sym :tstring_beg) include? ","tokenlist each ","Parser Ruby RubyParser  parse tokens ","Parser Ruby RubyParser  parse ","(send\n  (lvar :Parser Ruby Legacy TokenList  new ) :map) join ","(send\n  (lvar :Parser Ruby RubyParser  parse tokens ) :map) join ","Parser Ruby Legacy TokenList  new  map ","Parser Ruby RubyParser  parse tokens  map ","Parser Ruby Legacy TokenList  new  each ","Parser Ruby RubyParser  parse tokens  each "]}," YARD Helpers HtmlHelper signature":{"type":"method","name":"signature","children":[],"call":["title + "," link_url + "," link_url "," url_for ","meth type ","meth scope ","meth name ","meth is_a? ","%s (%s) <strong>%s</strong>%s %s % "," <span class=\"extras\">( + + "," <span class=\"extras\">( + ","extras join ","extras empty? ","extras << ","meth visibility ","meth visibility != ","attname join + ","attname join ","attname size == ","attname size ","(if\n  (send\n    (lvar :rw) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact ","rw [] ","meth namespace attributes [] [] ","meth namespace attributes [] ","meth namespace attributes ","meth namespace "," format_args "," format_block ","meth scope == "," format_types ","arr << ","arr empty? ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) :types)\n      (array))) :first) compact ","(or\n  (send\n    (send\n      (lvar :meth) :tag\n      (sym :return)) :types)\n  (array)) first ","meth tag types ","meth tag "," h ","meth tag types first ","%s %s<strong>%s</strong>%s %s % ","meth is_attribute? ","type empty? ","type empty? ! ","types join "," options [] "," options ","types == ","(lvar :first) join ","types size > ","types size ","first + ","types last =~ ","Regexp  quote ","types first ","types last ","types size == ","types last == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten ","t types ","meth tags map ","meth tags ","meth tag tag ","meth tags size == ","meth tags size ","meth tag ! ","meth attr_info ","meth writer? ","full_attr_name ! ","meth name to_s gsub ","meth name to_s "," signature_types "," convert_method_to_overload ","meth object ","meth respond_to? "," object ","%s<strong>%s</strong>%s %s %s % ","%s (%s) <strong>%s</strong>%s %s %  + ","%s %s<strong>%s</strong>%s %s %  + ","%s<strong>%s</strong>%s %s %s %  + "," link_ url_for  + "," link_ url_for  ","  url_for _for ","meth  format_types  ","meth  h  ","meth (lvar :first) join  ","meth first +  ","meth  signature_types  ","meth tag  type "," convert_method_to_overload  type ","meth tag  scope "," convert_method_to_overload  scope ","meth meth name  ","meth meth name to_s gsub  ","meth tag  name "," convert_method_to_overload  name ","meth tag  is_a? "," convert_method_to_overload  is_a? ","meth tag  visibility "," convert_method_to_overload  visibility ","meth tag  visibility != "," convert_method_to_overload  visibility != ","attname join +  join + ","(if\n  (send\n    (lvar :rw) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact  join + ","attmeth name  join + ","attmeth name to_s gsub  join + ","attname join +  join ","(if\n  (send\n    (lvar :rw) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact  join ","attmeth name  join ","attmeth name to_s gsub  join ","attname join +  size == ","(if\n  (send\n    (lvar :rw) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact  size == ","attmeth name  size == ","attmeth name to_s gsub  size == ","attname join +  size ","(if\n  (send\n    (lvar :rw) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact  size ","attmeth name  size ","attmeth name to_s gsub  size ","(if\n  (send\n    (lvar :meth namespace attributes [] [] ) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact ","(if\n  (send\n    (lvar :meth attr_info ) :[]\n    (sym :read))\n  (str \"read\")\n  (nil)) compact ","meth namespace attributes [] []  [] ","meth attr_info  [] ","meth meth name space attributes [] [] ","meth meth name to_s gsub space attributes [] [] ","meth tag  namespace attributes [] [] "," convert_method_to_overload  namespace attributes [] [] ","meth meth name space attributes [] ","meth meth name to_s gsub space attributes [] ","meth tag  namespace attributes [] "," convert_method_to_overload  namespace attributes [] ","meth meth name space attributes ","meth meth name to_s gsub space attributes ","meth tag  namespace attributes "," convert_method_to_overload  namespace attributes ","meth meth name space ","meth meth name to_s gsub space ","meth tag  namespace "," convert_method_to_overload  namespace "," format_ format_args  ","meth tag  scope == "," convert_method_to_overload  scope == "," format_ format_types s "," format_ h s "," format_(lvar :first) join s "," format_first + s "," format_ signature_types s "," format_(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) :types)\n      (array))) :first) compact  << ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) :types)\n      (array))) :first) compact  empty? ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) : format_types s)\n      (array))) :first) compact ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) : h s)\n      (array))) :first) compact ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) :(lvar :first) join s)\n      (array))) :first) compact ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) :first + s)\n      (array))) :first) compact ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) : signature_types s)\n      (array))) :first) compact ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) :types)\n      ((send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) :types)\n      (array))) :first) compact ay))) :first) compact ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) :types)\n      (array))) : format_types ) compact ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) :types)\n      (array))) : h ) compact ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) :(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten )\n      (array))) :first) compact ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth tag ) :tag\n          (sym :return)) :types)\n      (array))) :first) compact ","(send\n  (begin\n    (or\n      (send\n        (send\n          (lvar : convert_method_to_overload ) :tag\n          (sym :return)) :types)\n      (array))) :first) compact ","(or\n  (send\n    (send\n      (lvar :meth) :tag\n      (sym :return)) : format_types s)\n  (array)) first ","(or\n  (send\n    (send\n      (lvar :meth) :tag\n      (sym :return)) : h s)\n  (array)) first ","(or\n  (send\n    (send\n      (lvar :meth) :tag\n      (sym :return)) :(lvar :first) join s)\n  (array)) first ","(or\n  (send\n    (send\n      (lvar :meth) :tag\n      (sym :return)) :first + s)\n  (array)) first ","(or\n  (send\n    (send\n      (lvar :meth) :tag\n      (sym :return)) : signature_types s)\n  (array)) first ","(or\n  (send\n    (send\n      (lvar :meth) :tag\n      (sym :return)) :types)\n  ((send\n  (begin\n    (or\n      (send\n        (send\n          (lvar :meth) :tag\n          (sym :return)) :types)\n      (array))) :first) compact ay)) first ","(or\n  (send\n    (send\n      (lvar :meth) :tag\n      (sym :return)) :types)\n  (array))  format_types  ","(or\n  (send\n    (send\n      (lvar :meth) :tag\n      (sym :return)) :types)\n  (array))  h  ","(or\n  (send\n    (send\n      (lvar :meth) :tag\n      (sym :return)) :(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten )\n  (array)) first ","(or\n  (send\n    (send\n      (lvar :meth tag ) :tag\n      (sym :return)) :types)\n  (array)) first ","(or\n  (send\n    (send\n      (lvar : convert_method_to_overload ) :tag\n      (sym :return)) :types)\n  (array)) first ","meth tag  format_types s ","meth tag  h s ","meth tag (lvar :first) join s ","meth tag first + s ","meth tag  signature_types s ","meth tag (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  ","meth tag  tag types "," convert_method_to_overload  tag types ","meth tag  tag "," convert_method_to_overload  tag ","meth tag  format_types s first ","meth tag  h s first ","meth tag (lvar :first) join s first ","meth tag first + s first ","meth tag  signature_types s first ","meth tag types  format_types  ","meth tag types  h  ","meth tag (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  first ","meth tag  tag types first "," convert_method_to_overload  tag types first ","meth tag  is_attribute? "," convert_method_to_overload  is_attribute? "," format_types  empty? "," h  empty? ","(lvar :first) join  empty? ","first +  empty? "," signature_types  empty? "," format_types  empty? ! "," h  empty? ! ","(lvar :first) join  empty? ! ","first +  empty? ! "," signature_types  empty? ! "," format_types s join "," h s join ","(lvar :first) join s join ","first + s join "," signature_types s join ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  join "," format_types s == "," h s == ","(lvar :first) join s == ","first + s == "," signature_types s == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  == ","(lvar : format_types ) join ","(lvar : h ) join "," format_types s size > "," h s size > ","(lvar :first) join s size > ","first + s size > "," signature_types s size > ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  size > "," format_types s size "," h s size ","(lvar :first) join s size ","first + s size "," signature_types s size ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  size "," format_types  + "," h  + "," format_types s last =~ "," h s last =~ ","(lvar :first) join s last =~ ","first + s last =~ "," signature_types s last =~ ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  last =~ "," format_types s first "," h s first ","(lvar :first) join s first ","first + s first "," signature_types s first ","types  format_types  ","types  h  ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  first "," format_types s last "," h s last ","(lvar :first) join s last ","first + s last "," signature_types s last ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  last "," format_types s size == "," h s size == ","(lvar :first) join s size == ","first + s size == "," signature_types s size == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  size == "," format_types s last == "," h s last == ","(lvar :first) join s last == ","first + s last == "," signature_types s last == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  last == ","(send\n  (send\n    (lvar :meth tag ) :tags\n    (sym :return)) :map) flatten ","(send\n  (send\n    (lvar : convert_method_to_overload ) :tags\n    (sym :return)) :map) flatten ","t  format_types s ","t  h s ","t (lvar :first) join s ","t first + s ","t  signature_types s ","t (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  ","meth tag  tags map "," convert_method_to_overload  tags map ","meth tag  tags "," convert_method_to_overload  tags ","meth tag  tag tag "," convert_method_to_overload  tag tag ","meth tag  tags size == "," convert_method_to_overload  tags size == ","meth tag  tags size "," convert_method_to_overload  tags size ","meth tag  tag ! "," convert_method_to_overload  tag ! ","meth tag  attr_info "," convert_method_to_overload  attr_info ","meth tag  writer? "," convert_method_to_overload  writer? ","full_attr_meth name  ! ","full_attr_meth name to_s gsub  ! ","meth meth name  to_s gsub ","meth meth name to_s gsub  to_s gsub ","meth tag  name to_s gsub "," convert_method_to_overload  name to_s gsub ","meth meth name  to_s ","meth meth name to_s gsub  to_s ","meth tag  name to_s "," convert_method_to_overload  name to_s "," signature_ format_types s "," signature_ h s "," signature_(lvar :first) join s "," signature_first + s "," signature_ signature_types s "," signature_(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  "," convert_meth tag od_to_overload "," convert_ convert_method_to_overload od_to_overload ","meth tag  object "," convert_method_to_overload  object ","meth meth object ect ","meth tag  respond_to? "," convert_method_to_overload  respond_to? "," meth object ect "]}," YARD Helpers HtmlHelper htmlify_line":{"type":"method","name":"htmlify_line","children":[],"call":[" htmlify gsub "," htmlify ","<div class='inline'> + + ","<div class='inline'> + "]}," Helpers BaseHelper format_source":{"type":"method","name":"format_source","children":[],"call":["value gsub ","sp size ","value split last [] ","value split last ","value split ","value split last []  size ","value value split last [] lit last [] ","value value split last [] lit last ","value value split last [] lit "]}," Helpers BaseHelper run_verifier":{"type":"method","name":"run_verifier","children":[],"call":[" options [] call is_a? "," options [] call "," options [] "," options ","list reject "," options [] run "," options verifier run "," options verifier "]}," YARD Templates Engine template_module_name":{"type":"method","name":"template_module_name","children":[],"call":["Template_ + ","path to_s gsub ","path to_s "]}," YARD Templates Engine find_template_paths":{"type":"method","name":"find_template_paths","children":[],"call":["(send\n  (lvar :paths) :inject\n  (array)) uniq ","acc unshift ","File  directory? ","File  cleanpath ","File  join ","paths inject ","from_template full_paths + ","from_template full_paths "," template_paths dup "," template_paths ","(send\n  (lvar :from_template full_paths + ) :inject\n  (array)) uniq ","(send\n  (lvar : template_paths dup ) :inject\n  (array)) uniq ","from_template full_paths +  inject "," template_paths dup  inject ","from_template File  cleanpath s + ","from_template full_from_template full_paths +  + ","from_template full_ template_paths dup  + ","from_template File  cleanpath s ","from_template full_from_template full_paths +  ","from_template full_ template_paths dup  "," template_from_template full_paths +  dup "," template_ template_paths dup  dup "," template_from_template full_paths +  "," template_ template_paths dup  "]}," YARD Templates Engine set_default_options":{"type":"method","name":"set_default_options","children":[],"call":["options [] ","options [] type ","OpenStruct  new ","options object type ","options object ","options type ","o update ","o reset_defaults ","TemplateOptions  new tap ","TemplateOptions  new ","options is_a? "]}," YARD Templates Engine with_serializer":{"type":"method","name":"with_serializer","children":[],"call":["serializer after_serialize ","serializer serialize ","serializer before_serialize "," log capture "," log ","File  join ","serializer basepath ","serializer respond_to? ","serializer serialized_path "]}," YARD Templates Engine generate":{"type":"method","name":"generate","children":[],"call":[" template run "," template ","options [] ","options []= "," set_default_options ","options format ","options template ","options object= ","Registry  root ","options objects= "," set_default_options  [] "," set_default_options  []= "," set_default_ set_default_options  "," set_default_options  format "," set_default_options  template "," set_default_options  object= "," set_default_options  objects= "]}," YARD Templates Engine render":{"type":"method","name":"render","children":[],"call":["mod run "," with_serializer ","options [] ","options [] != "," template "," set_default_options ","options serializer ","options object ","options serialize != ","options serialize ","options format ","options type ","options template "," template  run "," set_default_options  [] "," set_default_options  [] != "," set_default_ set_default_options  "," set_default_options  serializer "," set_default_options  object "," set_default_options  serialize != "," set_default_options  serialize "," set_default_options  format "," set_default_options  type "," set_default_options  template "]}," YARD Templates Engine template!":{"type":"method","name":"template!","children":[],"call":["mod send "," const_set ","Module  new "," const_get "," template_module_name ","full_paths first ","full_paths is_a? "," const_set  send "," template_ const_set ule_name "," template_module_ template_module_name  "]}," YARD Templates Engine template":{"type":"method","name":"template","children":[],"call":[" template! "," raise ","full_paths empty? ","File  cleanpath gsub ","File  cleanpath "," find_template_paths ","path join ","path shift ","path first is_a? ","path first ","full_File  cleanpath gsub s empty? ","full_path join s empty? "," find_template_paths  empty? ","File  cleanFile  cleanpath gsub  gsub ","File  cleanpath join  gsub ","File  cleanFile  cleanpath gsub  ","File  cleanpath join  "," find_template_File  cleanpath gsub s "," find_template_path join s ","File  cleanpath gsub  join ","path join  join ","File  cleanpath gsub  shift ","path join  shift ","File  cleanpath gsub  first is_a? ","path join  first is_a? ","File  cleanpath gsub  first ","path join  first "]}," YARD Templates Engine register_template_path":{"type":"method","name":"register_template_path","children":[],"call":[" template_paths push "," template_paths "," template_paths include? "]}," YARD Parser Ruby RubyParser on_rescue":{"type":"method","name":"on_rescue","children":[],"call":[" visit_event ","AstNode  new "]}," YARD Parser Ruby RubyParser on_rbracket":{"type":"method","name":"on_rbracket","children":[],"call":[" visit_ns_token ","(or-asgn\n  (send\n    (ivar :@map) :[]\n    (sym :aref))\n  (array)) << "," charno "," lineno ","@map [] "]}," YARD Parser Ruby RubyParser on_aref":{"type":"method","name":"on_aref","children":[],"call":["AstNode  new ","args first line_range first ","args first line_range ","args first ","args first source_range first ","args first source_range ","@map [] pop ","@map [] "]}," ConstantHandler process_structclass":{"type":"method","name":"process_structclass","children":[],"call":["klass attributes [] [] []= ","MethodObject  new ","klass attributes [] [] ","klass attributes [] ","klass attributes ","(pair\n  (sym :read)\n  (lvar :name)) each ","klass attributes [] []= ","SymbolHash  [] "," tokval_list each "," tokval_list ","YARD Parser Ruby Legacy TokenList  new ","klass superclass= "," P "," register ","ClassObject  new "," namespace "," raise ","statement [] source ","statement [] "," parse_attributes ","statement [] parameters ","lhs [] ","lhs type == ","lhs type ","statement [] [] "," create_attributes "," extract_parameters "," create_class "," parse_block ","statement [] block [] ","statement [] block ","statement [] block nil? "," register  attributes [] [] []= "," create_class  attributes [] [] []= "," register  attributes [] [] "," create_class  attributes [] [] "," register  attributes [] "," create_class  attributes [] "," register  attributes "," create_class  attributes "," register  attributes [] []= "," create_class  attributes [] []= "," register  superclass= "," create_class  superclass= ","statement [] []  [] ","statement [] []  type == ","statement [] []  type "]}," ConstantHandler parse_attributes":{"type":"method","name":"parse_attributes","children":[],"call":["klass attributes [] [] []= ","MethodObject  new ","klass attributes [] [] ","klass attributes [] ","klass attributes ","(pair\n  (sym :read)\n  (lvar :name)) each ","klass attributes [] []= ","SymbolHash  [] ","node jump source ","node jump ","node type != ","node type ","node respond_to? ! ","node respond_to? ","attributes each "," register ","(pair\n  (sym :read)\n  (lvar :node jump source )) each "]}," ConstantHandler process_constant":{"type":"method","name":"process_constant","children":[],"call":[" register ","o value= ","value strip ","o source= ","ConstantObject  new "," namespace ","statement [] source ","statement [] ","statement [] [] [] ","statement [] [] "," raise ","obj type ","obj is_a? "," P "," ensure_loaded! ","obj parent ","obj namespace == ","obj namespace ","statement [] first source intern inspect ","statement [] first source intern ","statement [] first source ","statement [] first ","statement [] type == ","statement [] type ","o statement [] source = ","o statement [] first source intern inspect = ","statement [] source  strip ","statement [] first source intern inspect  strip "," statement [] [] [] space "," statement [] source space "," P  type "," P  is_a? "," P  parent ","obj statement [] [] [] space == ","obj statement [] source space == "," P  namespace == ","obj statement [] [] [] space ","obj statement [] source space "," P  namespace "]}," File cleanpath":{"type":"method","name":"cleanpath","children":[],"call":[]}," Insertion insertion":{"type":"method","name":"insertion","children":[],"call":["@list []= ","index + ","@list [] is_a? ","@list [] ","rel == ","@list index ","list []= ","list index ","item == "," insertion ","item dup ","item is_a? ","list each ","@list index  + ","list index  + ","@list @list index  ","@list list index  ","list @list index  ","list list index  "]}," Insertion after":{"type":"method","name":"after","children":[],"call":[" insertion "]}," Insertion before":{"type":"method","name":"before","children":[],"call":[" insertion "]}," Insertion initialize":{"type":"method","name":"initialize","children":[],"call":["Array  === "]}," Array place":{"type":"method","name":"place","children":[],"call":["Insertion  new "]}," CodeObjects ConstantObject value=":{"type":"method","name":"value=","children":[],"call":[" format_source "]}," YARD CodeObjects Base format":{"type":"method","name":"format","children":[],"call":["Templates Engine  render ","options merge! ","options merge "," type ","options [] ! ","options [] ","options merge  merge! ","options merge  merge ","options merge  [] ! ","options merge  [] "]}," YARD CodeObjects Base name":{"type":"method","name":"name","children":[],"call":["@name to_s "]}," YARD CLI Yardoc add_verifier":{"type":"method","name":"add_verifier","children":[],"call":[]}," YARD Templates Helpers HtmlSyntaxHighlightHelper html_syntax_highlight_ruby":{"type":"method","name":"html_syntax_highlight_ruby","children":[],"call":["(send\n  (lvar :tokenlist) :map) join "," h ","s text ","s class superclass class_name sub downcase ","s class superclass class_name sub ","s class superclass class_name ","s class superclass ","s class ","s class class_name sub downcase ","s class class_name sub ","s class class_name ","tokenlist map ","Parser Ruby Legacy TokenList  new ","output << ","(sym :tstring_end) include? ","s [] ","s last ","s first ","(sym :tstring_beg) include? ","tokenlist each ","Parser Ruby RubyParser  parse tokens ","Parser Ruby RubyParser  parse "," html_syntax_highlight_ruby_legacy "," html_syntax_highlight_ruby_ripper ","Parser SourceParser  parser_type == ","Parser SourceParser  parser_type ","(send\n  (lvar :Parser Ruby Legacy TokenList  new ) :map) join ","(send\n  (lvar :Parser Ruby RubyParser  parse tokens ) :map) join ","Parser Ruby Legacy TokenList  new  map ","Parser Ruby RubyParser  parse tokens  map ","Parser Ruby Legacy TokenList  new  each ","Parser Ruby RubyParser  parse tokens  each "]}," YARD Helpers HtmlHelper html_syntax_highlight_plain":{"type":"method","name":"html_syntax_highlight_plain","children":[],"call":[" h "]}," YARD Tags OverloadTag is_a?":{"type":"method","name":"is_a?","children":[],"call":[" class >= ","other class "," class "," object is_a? "," object "]}," YARD Tags Library instance":{"type":"method","name":"instance","children":[],"call":[" new "]}," YARD Serializers YardocSerializer internal_dump":{"type":"method","name":"internal_dump","children":[],"call":["object replace "," internal_dump ","object map ","Hash  [] ","(lvar :k) map ","object instance_variable_set ","object instance_variable_get ","object instance_variables each ","object instance_variables ","object dup ","object instance_variables size > ","object instance_variables size ","object is_a? ","StubProxy  new ","object path ","(send\n  (const\n    (const nil :Tags) :OverloadTag) :===\n  (lvar :object)) ! ","Tags OverloadTag  === ","first_object ! ","object instance_variables empty? ! ","object instance_variables empty? ","object dup  replace ","object dup  map ","object dup  instance_variable_set ","object dup  instance_variable_get ","object dup  instance_variables each ","object dup  instance_variables ","object dup  dup ","object dup  instance_variables size > ","object dup  instance_variables size ","object dup  is_a? ","object dup  path ","(send\n  (const\n    (const nil :Tags) :OverloadTag) :===\n  (lvar :object dup )) ! ","first_object dup  ! ","object dup  instance_variables empty? ! ","object dup  instance_variables empty? "]}," YARD Serializers YardocSerializer dump":{"type":"method","name":"dump","children":[],"call":["Marshal  dump "," internal_dump ","object is_a? "," internal_dump  is_a? "]}," YARD Serializers YardocSerializer deserialize":{"type":"method","name":"deserialize","children":[],"call":[" log debug "," log ","Marshal  load ","File  read ","File  file? ","File  join "," serialized_path "," basepath ","File  read_binary "," serialized_File  join  "," baseFile  join  "]}," YARD Serializers YardocSerializer serialize":{"type":"method","name":"serialize","children":[],"call":[" dump ","object [] ","Hash  === "]}," YARD Serializers YardocSerializer serialized_path":{"type":"method","name":"serialized_path","children":[],"call":["File  join ","(send\n  (send\n    (lvar :object) :split\n    (regexp\n      (str \"::|\\\\.|#\")\n      (regopt))) :map) join + + "," extension ","(send\n  (send\n    (lvar :object) :split\n    (regexp\n      (str \"::|\\\\.|#\")\n      (regopt))) :map) join + ","(send\n  (send\n    (lvar :object) :split\n    (regexp\n      (str \"::|\\\\.|#\")\n      (regopt))) :map) join ","encoded << ","%X % ","x each_byte ","p gsub ","object split map ","object split ","object =~ ","object to_s ","(send\n  (send\n    (lvar :object to_s ) :split\n    (regexp\n      (str \"::|\\\\.|#\")\n      (regopt))) :map) join + + ","(send\n  (send\n    (lvar :object to_s ) :split\n    (regexp\n      (str \"::|\\\\.|#\")\n      (regopt))) :map) join + ","(send\n  (send\n    (lvar :object to_s ) :split\n    (regexp\n      (str \"::|\\\\.|#\")\n      (regopt))) :map) join ","object to_s  split map ","object to_s  split ","object to_s  =~ ","object to_s  to_s "]}," YARD Serializers YardocSerializer checksums_path":{"type":"method","name":"checksums_path","children":[],"call":["File  join "," basepath "]}," YARD Serializers YardocSerializer proxy_types_path":{"type":"method","name":"proxy_types_path","children":[],"call":["File  join "," basepath "]}," YARD Serializers YardocSerializer objects_path":{"type":"method","name":"objects_path","children":[],"call":["File  join "," basepath "]}," YARD Serializers YardocSerializer initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD StubProxy method_missing":{"type":"method","name":"method_missing","children":[],"call":[" raise ","l [] == ","l [] ","(string) size ","e backtrace delete_if ","e backtrace ","@object send ","Registry  at ","Registry  at send ","args first == ","args first ","meth == "]}," YARD StubProxy initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD StubProxy _load":{"type":"method","name":"_load","children":[],"call":[]}," YARD StubProxy _dump":{"type":"method","name":"_dump","children":[],"call":[]}," YARD RegistryStore write_checksums":{"type":"method","name":"write_checksums","children":[],"call":["f puts ","@checksums each ","File  open "," checksums_path ","File  open! "]}," YARD RegistryStore write_proxy_types":{"type":"method","name":"write_proxy_types","children":[],"call":["f write ","Marshal  dump ","File  open "," proxy_types_path ","File  open! "]}," YARD RegistryStore all_disk_objects":{"type":"method","name":"all_disk_objects","children":[],"call":["File  file? ","Dir  glob select ","Dir  glob ","File  join "," objects_path "]}," YARD RegistryStore load_all":{"type":"method","name":"load_all","children":[],"call":[" log debug ","objects size "," log "," put ","obj path ","objects each ","objects << ","@serializer deserialize ","(send\n  (send nil :all_disk_objects) :sort_by) each ","x size "," all_disk_objects sort_by "," all_disk_objects ","@loaded_objects >= "," all_disk_objects sort_by each ","@serializer deserialize ects size ","@serializer deserialize  path ","@serializer deserialize ects each ","@serializer deserialize ects << ","(send\n  (send nil :all_disk_@serializer deserialize ects) :sort_by) each "," all_disk_@serializer deserialize ects sort_by "," all_disk_@serializer deserialize ects ","@loaded_@serializer deserialize ects >= "," all_disk_@serializer deserialize ects sort_by each "]}," YARD RegistryStore load_root":{"type":"method","name":"load_root","children":[],"call":["@store []= ","@serializer deserialize ","root keys size - ","root keys size ","root keys "," log debug "," log ","root is_a? ","root nil? ","@serializer deserialize  keys size - ","@serializer deserialize  keys size ","@serializer deserialize  keys ","@serializer deserialize  is_a? ","@serializer deserialize  nil? "]}," YARD RegistryStore load_checksums":{"type":"method","name":"load_checksums","children":[],"call":["Hash  [] ","line strip split ","line strip ","File  readlines map ","File  readlines "," checksums_path ","File  file? ","p delete_at ","line strip rpartition tap ","line strip rpartition "]}," YARD RegistryStore load_proxy_types":{"type":"method","name":"load_proxy_types","children":[],"call":["Marshal  load ","File  read "," proxy_types_path ","File  file? ","File  read_binary "]}," YARD RegistryStore load_yardoc_old":{"type":"method","name":"load_yardoc_old","children":[],"call":["Marshal  load ","File  read ","File  read_binary "]}," YARD RegistryStore load_yardoc":{"type":"method","name":"load_yardoc","children":[],"call":[" load_yardoc_old ","File  file? "," load_root "," load_checksums "," load_proxy_types "," all_disk_objects size "," all_disk_objects ","Registry  objects replace ","Registry  objects ","File  directory? "," load_object_types "]}," YARD RegistryStore checksums_path":{"type":"method","name":"checksums_path","children":[],"call":["@serializer checksums_path "]}," YARD RegistryStore proxy_types_path":{"type":"method","name":"proxy_types_path","children":[],"call":["@serializer proxy_types_path "]}," YARD RegistryStore objects_path":{"type":"method","name":"objects_path","children":[],"call":["@serializer objects_path "]}," YARD RegistryStore destroy":{"type":"method","name":"destroy","children":[],"call":["FileUtils  rm_rf ","File  directory? ","File  unlink ","File  file? "," file =~ "," file ","force ! "]}," YARD RegistryStore save":{"type":"method","name":"save","children":[],"call":[" write_checksums "," write_proxy_types ","@serializer serialize "," values each "," values "," destroy ","Serializers YardocSerializer  new ","file != "," keys size < "," keys size "," keys ","sdb == ","Registry  single_object_db "," write_object_types "," write_complete_lock ","sdb nil? ","Serializers YardocSerializer  new  serialize ","Registry  single_object_db  == ","Registry  single_object_db  nil? "]}," YARD RegistryStore load":{"type":"method","name":"load","children":[],"call":[" load_yardoc ","Serializers YardocSerializer  new "," initialize "]}," YARD RegistryStore root":{"type":"method","name":"root","children":[],"call":["@store [] "]}," YARD RegistryStore values":{"type":"method","name":"values","children":[],"call":["@store values "," load_all "]}," YARD RegistryStore keys":{"type":"method","name":"keys","children":[],"call":["@store keys "," load_all "]}," YARD RegistryStore delete":{"type":"method","name":"delete","children":[],"call":["@store delete ","key to_sym ","@object_types [] delete ","key to_s ","@object_types [] ","@store [] type ","@store [] "]}," YARD RegistryStore put":{"type":"method","name":"put","children":[],"call":["@store []= ","key to_sym ","key == ","@notfound delete ","@object_types [] delete ","key to_s ","@object_types [] ","@store [] type ","@store [] ","(or-asgn\n  (send\n    (ivar :@object_types) :[]\n    (send\n      (lvar :value) :type))\n  (array)) << ","value type ","@object_types []= "]}," YARD RegistryStore get":{"type":"method","name":"get","children":[],"call":[" put ","@serializer deserialize ","@loaded_objects >= ","@store [] ","key to_sym ","key == ","@notfound []= ","@notfound [] ","@loaded_@serializer deserialize ects >= ","key to_sym  to_sym ","key to_sym  == "]}," YARD RegistryStore initialize":{"type":"method","name":"initialize","children":[],"call":["CodeObjects RootObject  new ","@store [] send ","@store [] ","@store []= ","CodeObjects RootObject  allocate "]}," YARD Registry delete_from_disk":{"type":"method","name":"delete_from_disk","children":[],"call":["@store destroy "," thread_local_store destroy "," thread_local_store "]}," YARD Registry checksum_for":{"type":"method","name":"checksum_for","children":[],"call":["Digest SHA1  hexdigest "]}," YARD Registry checksums":{"type":"method","name":"checksums","children":[],"call":["@store checksums "," thread_local_store checksums "," thread_local_store "]}," YARD Registry proxy_types":{"type":"method","name":"proxy_types","children":[],"call":["@store proxy_types "," thread_local_store proxy_types "," thread_local_store "]}," YARD Registry local_yardoc_file":{"type":"method","name":"local_yardoc_file","children":[],"call":["File  exist? ","File  join ","spec full_name ","FileUtils  mkdir_p "]}," YARD Registry global_yardoc_file":{"type":"method","name":"global_yardoc_file","children":[],"call":["File  exist? ","for_writing ! ","File  writable? ","File  join ","spec full_gem_path ","spec doc_dir ","File  dirname ","File  directory? ! ","File  directory? ","spec full_gem_spec full_gem_path  ","spec full_gem_spec doc_dir  "]}," YARD Registry yardoc_file_for_gem":{"type":"method","name":"yardoc_file_for_gem","children":[],"call":[" global_yardoc_file "," local_yardoc_file ","Gem  source_index find_name first ","Gem  source_index find_name ","Gem  source_index ","for_writing ! ","File  exist? ","File  join ","spec full_gem_path ","gem =~ ","spec first ","spec empty? "," old_global_yardoc_file ","specs reverse each ","specs reverse ","specs empty? ","YARD GemIndex  find_all_by_name ","Gem  source_index find_name first  full_gem_path ","spec first  full_gem_path ","Gem  source_index find_name  full_gem_path ","spec full_gem_File  join  ","Gem  source_index find_name first  first ","spec first  first ","Gem  source_index find_name  first ","Gem  source_index find_name first  empty? ","spec first  empty? ","Gem  source_index find_name  empty? ","Gem  source_index find_name first s reverse each ","spec first s reverse each ","Gem  source_index find_name s reverse each ","YARD GemIndex  find_all_by_name  reverse each ","Gem  source_index find_name  reverse each ","Gem  source_index find_name first s reverse ","spec first s reverse ","Gem  source_index find_name s reverse ","YARD GemIndex  find_all_by_name  reverse ","Gem  source_index find_name  reverse ","Gem  source_index find_name first s empty? ","spec first s empty? ","Gem  source_index find_name s empty? ","YARD GemIndex  find_all_by_name  empty? "]}," YARD Parser CParser remove_private_comments":{"type":"method","name":"remove_private_comments","children":[],"call":["comment sub ","comment gsub ","comment sub  sub ","comment gsub  sub ","comment sub  gsub ","comment gsub  gsub "]}," YARD Parser CParser remove_commented_out_lines":{"type":"method","name":"remove_commented_out_lines","children":[],"call":["body gsub "]}," YARD Parser CParser handle_tab_width":{"type":"method","name":"handle_tab_width","children":[],"call":["(send\n  (send\n    (lvar :body) :split\n    (regexp\n      (str \"\\\\n\")\n      (regopt))) :map) join ","  * ","tab_width * - ","$` length % ","$` length ","tab_width * ","$& length ","line gsub! ","body split map ","body split "]}," YARD Parser CParser handle_ifdefs_in":{"type":"method","name":"handle_ifdefs_in","children":[],"call":["body gsub "]}," YARD Parser CParser clean_source":{"type":"method","name":"clean_source","children":[],"call":[" remove_commented_out_lines "," handle_tab_width "," handle_ifdefs_in "]}," YARD Parser CParser parse_constants":{"type":"method","name":"parse_constants","children":[],"call":[" handle_constants ","var_name == ","var_name ! ","@content scan "]}," YARD Parser CParser parse_includes":{"type":"method","name":"parse_includes","children":[],"call":["klass mixins << ","klass mixins "," P ","mod gsub ","@namespaces [] ","@content scan "," remove_var_prefix "," lookup_var ","@namespaces []  mixins << ","@namespaces []  mixins "]}," YARD Parser CParser parse_methods":{"type":"method","name":"parse_methods","children":[],"call":[" handle_method ","@content scan ","var_name == "]}," YARD Parser CParser parse_classes":{"type":"method","name":"parse_classes","children":[],"call":[" handle_class ","@content scan "]}," YARD Parser CParser parse_modules":{"type":"method","name":"parse_modules","children":[],"call":[" handle_module ","@content scan "]}," YARD Parser CParser parse_types":{"type":"method","name":"parse_types","children":[],"call":["(send\n  (send\n    (begin\n      (or\n        (lvar :types)\n        (str \"\"))) :split\n    (regexp\n      (str \",| or \")\n      (regopt))) :map) compact ","object namespace name to_s ","object namespace name ","object namespace ","t strip gsub ","t strip ","(or\n  (lvar :types)\n  (str \"\")) split map ","(or\n  (lvar :types)\n  (str \"\")) split ","types =~ "]}," YARD Parser CParser parse_callseq":{"type":"method","name":"parse_callseq","children":[],"call":["comments + + ","comments + ","overloads << ","types join ","types empty? ","signature rstrip ","signature =~ ","( + + ","( + ","signature [] join ","signature [] ","signature split ","signature sub! "," parse_types ","line split ","line sub! ","line empty? ","comments shift strip ","comments shift ","comments first =~ ","comments first ","comments []= ","comments [] =~ ","comments [] "," parse_types  join "," parse_types  empty? ","signature rstrip  rstrip ","signature split  rstrip ","signature rstrip  =~ ","signature split  =~ ","signature rstrip  [] join ","signature split  [] join ","signature rstrip  [] ","signature split  [] ","signature rstrip  split ","signature split  split ","signature rstrip  sub! ","signature split  sub! "," parse_ parse_types  ","comments shift strip  split ","comments shift strip  sub! ","comments shift strip  empty? "]}," YARD Parser CParser parse_comments":{"type":"method","name":"parse_comments","children":[],"call":["comments join "," parse_callseq ","comments shift ","comments first =~ ","comments first ","(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\\\r?\\\\n\")\n      (regopt))) :map) compact ","line gsub rstrip ","line gsub ","(or\n  (send\n    (lvar :line) :[]\n    (regexp\n      (str \"^(\\\\s+)\")\n      (regopt))\n    (int 1))\n  (str \"\")) size ","line [] ","spaces nil? ","line =~ ","line gsub! ","comments split map ","comments split "," remove_private_comments "," parse_callseq  join ","(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact  join "," remove_private_comments  join "," parse_callseq  shift ","(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact  shift "," remove_private_comments  shift "," parse_callseq  first =~ ","(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact  first =~ "," remove_private_comments  first =~ "," parse_callseq  first ","(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact  first "," remove_private_comments  first ","(send\n  (send\n    (lvar : parse_callseq ) :split\n    (regexp\n      (str \"\\\\r?\\\\n\")\n      (regopt))) :map) compact ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact ) :split\n    (regexp\n      (str \"\\\\r?\\\\n\")\n      (regopt))) :map) compact ","(send\n  (send\n    (lvar : remove_private_comments ) :split\n    (regexp\n      (str \"\\\\r?\\\\n\")\n      (regopt))) :map) compact ","(or\n  (send\n    (lvar :line) :[]\n    (regexp\n      (str \"^(\\s+)\")\n      (regopt))\n    (int 1))\n  (str \"\")) size  nil? "," parse_callseq  split map ","(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact  split map "," remove_private_comments  split map "," parse_callseq  split ","(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact  split "," remove_private_comments  split "," remove_private_ parse_callseq  "," remove_private_(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact  "," remove_private_ remove_private_comments  "]}," YARD Parser CParser find_method_body":{"type":"method","name":"find_method_body","children":[],"call":["object docstring= "," parse_comments "," find_method_body ","object source= ","(begin\n  (lvar :re)) =~ ","Regexp  escape + ","Regexp  escape "," remove_private_comments "," find_override_comment ","body_text gsub ","Regexp  quote "," parse_ find_override_comment s ","(begin\n  (lvar :Regexp  escape + )) =~ "," Regexp  escape + move_private_comments "," remove_private_ find_override_comment s "," find_override_ find_override_comment  "," find_ find_override_comment  "]}," YARD Parser CParser find_constant_docstring":{"type":"method","name":"find_constant_docstring","children":[],"call":[" parse_comments "," object ","@content =~ ","object docstring= "]}," YARD Parser CParser find_namespace_docstring":{"type":"method","name":"find_namespace_docstring","children":[],"call":["object docstring= "," parse_comments ","comments [] ","index - ","chunk =~ ","object name ","comments []= ","@content split each_with_index ","@content split ","@content =~ ","object path "," parse_comments [] s ","comments [] s [] ","comments [] s []= "]}," YARD Parser CParser handle_constants":{"type":"method","name":"handle_constants","children":[],"call":["obj docstring= ","elements last lstrip ","elements last ","1 nil? ","new_definition sub! ","new_definition gsub! ","new_definition empty? ","elements [] join ","elements [] ","comment split ","type downcase == ","type downcase "," find_constant_docstring ","CodeObjects ConstantObject  new ","@namespaces [] ","obj source_type= ","obj add_file ","obj value= ","new_value gsub ","comment scan "," ensure_loaded! "," lookup_var ","CodeObjects ConstantObject  new  docstring= ","comment split  last lstrip ","comment split  last ","elements [] join  sub! ","elements [] join  gsub! ","elements [] join  empty? ","comment split  [] join ","comment split  [] ","elements last  split "," find_constant_docstring  split ","@@namespaces [] s [] ","@ lookup_var s [] ","CodeObjects ConstantObject  new  source_type= ","CodeObjects ConstantObject  new  add_file ","CodeObjects ConstantObject  new  value= ","elements last  scan "," find_constant_docstring  scan "]}," YARD Parser CParser handle_method":{"type":"method","name":"handle_method","children":[],"call":[" find_method_body ","obj source_type= ","obj docstring add_tag ","YARD Tags Tag  new ","obj docstring ","name =~ ","obj parameters= ","obj add_file ","CodeObjects MethodObject  new "," ensure_loaded! "," P ","var_name gsub ","@namespaces [] "," remove_var_prefix "," log warn "," log ","scope == ","File  read "," lookup_var ","CodeObjects MethodObject  new  source_type= ","CodeObjects MethodObject  new  docstring add_tag ","CodeObjects MethodObject  new  docstring ","CodeObjects MethodObject  new  parameters= ","CodeObjects MethodObject  new  add_file ","@ lookup_var s [] "]}," YARD Parser CParser handle_class":{"type":"method","name":"handle_class","children":[],"call":["@namespaces []= "," find_namespace_docstring ","obj add_file ","obj superclass= ","parent gsub ","@namespaces [] ","CodeObjects ClassObject  new "," ensure_loaded! "," P ","in_module gsub ","parent == "," remove_var_prefix "," lookup_var ","@ lookup_var s []= "," find_ lookup_var _docstring ","CodeObjects ClassObject  new  add_file ","CodeObjects ClassObject  new  superclass= ","@ lookup_var s [] "]}," YARD Parser CParser handle_module":{"type":"method","name":"handle_module","children":[],"call":["@namespaces []= "," find_namespace_docstring ","obj add_file ","CodeObjects ModuleObject  new "," ensure_loaded! "," P ","in_module gsub ","@namespaces [] "," remove_var_prefix "," lookup_var ","@ lookup_var s []= "," find_ lookup_var _docstring ","CodeObjects ModuleObject  new  add_file ","@ lookup_var s [] "]}," YARD Parser CParser ensure_loaded!":{"type":"method","name":"ensure_loaded!","children":[],"call":[" raise "," log debug "," log ","retries <= ","object is_a? "," callcc "," log warn ","JRuby/Rubinius do not implement Kernel#callcc and cannot  + ","RUBY_PLATFORM  =~ ","JRuby/MacRuby/Rubinius do not implement Kernel#callcc and cannot  + "," log warn_no_continuations "]}," YARD Parser CParser parse":{"type":"method","name":"parse","children":[],"call":[" parse_includes "," parse_methods "," parse_classes "," parse_modules "," parse_constants "," parse_attributes "," parse_aliases "," parse_namespaces "]}," YARD Parser CParser initialize":{"type":"method","name":"initialize","children":[],"call":[" clean_source "]}," YARD Logger backtrace":{"type":"method","name":"backtrace","children":[],"call":[" error ","Stack trace: + + ","Stack trace: + ","(send\n  (send\n    (send\n      (lvar :exc) :backtrace) :[]\n    (irange\n      (int 0)\n      (int 5))) :map) join ","exc backtrace [] map ","exc backtrace [] ","exc backtrace ","exc message ","exc class class_name ","exc class "," show_backtraces "," send "]}," String shell_split":{"type":"method","name":"shell_split","children":[],"call":["quote << ","out last << ","out last ","char == ","out << ","state == "," strip split each "," strip split "," strip ","String  new ","String  new  << "]}," Module namespace_name":{"type":"method","name":"namespace_name","children":[],"call":[" name split [] join "," name split [] "," name split "," name "]}," Hash create":{"type":"method","name":"create","children":[],"call":[" create_186 ","obj []= ","args first each ","args first "," new ","args is_a? ","args size == ","args size ","args first is_a? "," new  []= "]}," YARD CodeObjects RootObject root?":{"type":"method","name":"root?","children":[],"call":[]}," YARD CodeObjects Proxy root?":{"type":"method","name":"root?","children":[],"call":[]}," CodeObjects MethodObject constructor?":{"type":"method","name":"constructor?","children":[],"call":[" namespace is_a? "," namespace "," scope == "," scope "," name == "," name "]}," YARD CodeObjects Base root?":{"type":"method","name":"root?","children":[],"call":[]}," YARD CLI YRI optparse":{"type":"method","name":"optparse","children":[],"call":[" exit ","STDERR  << << ","STDERR  << ","STDERR  puts ","e message ","args first ","opts parse! "," common_options ","YARD Serializers ProcessSerializer  new ","opts on ","YARD Serializers StdoutSerializer  new ","@search_paths unshift ","opts separator ","OptionParser  new "," parse_options ","opts banner= ","OptionParser  new  parse! ","OptionParser  new  on ","OptionParser  new  separator ","OptionParser  new  banner= "]}," YARD CLI YRI add_gem_paths":{"type":"method","name":"add_gem_paths","children":[],"call":["@search_paths << ","Registry  yardoc_file_for_gem ","spec name ","Gem  source_index find_name each ","Gem  source_index find_name ","Gem  source_index "," require ","@search_paths push ","@search_paths unshift ","spec name =~ ","gem_paths push ","gem_paths unshift ","yfile nil? ","YARD GemIndex  each ","YARD GemIndex  find_all_by_name each ","YARD GemIndex  find_all_by_name ","Registry  yardoc_file_for_gem  nil? "]}," YARD CLI YRI load_cache":{"type":"method","name":"load_cache","children":[],"call":["@cache []= ","line [] ","line strip split ","line strip ","File  readlines each ","File  readlines ","File  file? ","line strip split  [] ","line strip split  strip split ","line strip split  strip ","File  readline strip split s each ","File  readline strip split s "]}," YARD CLI YRI find_object":{"type":"method","name":"find_object","children":[],"call":[" cache_object ","Registry  at ","Registry  load "," log debug "," log ","@search_paths each ","@search_paths unshift ","@cache [] ","File  exist? ","Registry  yardoc_file "," try_load_object "," cache_Registry  at ect "," cache_ try_load_object ect "," try_load_Registry  at ect "," try_load_ try_load_object ect "]}," YARD CLI YRI print_object":{"type":"method","name":"print_object","children":[],"call":["object format ","YARD CodeObjects Proxy  === "," P ","(if\n  (send\n    (send\n      (lvar :object) :scope) :==\n    (sym :instance))\n  (str \"#\")\n  (str \"\")) + ","object namespace aliases [] to_s ","object namespace aliases [] ","object namespace aliases ","object namespace ","object scope == ","object scope ","object is_alias? ","object type == ","object type "]}," YARD CLI YRI cache_object":{"type":"method","name":"cache_object","children":[],"call":["file puts ","@cache each ","File  open ","@cache []= ","path == ","Registry  yardoc_file ","File  open! "]}," YARD CLI YRI run":{"type":"method","name":"run","children":[],"call":[" exit ","STDERR  puts "," print_object "," find_object ","YARD Serializers ProcessSerializer  new "," optparse "," print_usage ","@name strip empty? ","@name strip ","@name nil? ","YARD Serializers StdoutSerializer  new ","Config CONFIG  [] =~ ","Config CONFIG  [] "," Config CONFIG  [] =~ "," Config CONFIG  [] "," RbConfig CONFIG  [] =~ "," RbConfig CONFIG  [] "," print_ find_object  "," find_ find_object  "]}," YARD CLI YRI initialize":{"type":"method","name":"initialize","children":[],"call":["@search_paths uniq! "," load_cache "," add_gem_paths ","YARD ROOT  + ","Registry  yardoc_file "," add_default_paths "]}," YARD CLI Yardoc build_gems":{"type":"method","name":"build_gems","children":[],"call":[" exit ","Yardoc  run ","Registry  clear ","Registry  yardoc_file_for_gem ","spec name "," log info ","spec full_name "," log ","Dir  chdir ","spec full_gem_path "," log debug ","rebuild ! ","File  directory? ","Gem  source_index find_name each ","Gem  source_index find_name ","Gem  source_index "," require ","Dir  chRegistry  yardoc_file_for_gem  ","File  Registry  yardoc_file_for_gem ectory? "]}," YARD CLI Base common_options":{"type":"method","name":"common_options","children":[],"call":[" exit "," puts ","opts on_tail "," log show_backtraces= "," log "," log level= ","opts separator "]}," YARD RegistryStore load!":{"type":"method","name":"load!","children":[],"call":[" load_all "," load "]}," YARD Registry load_all":{"type":"method","name":"load_all","children":[],"call":["@store load_all "," thread_local_store load_all "," thread_local_store "]}," YARD Registry load!":{"type":"method","name":"load!","children":[],"call":["@store load! "," clear "," thread_local_store load! "," thread_local_store "]}," YARD CLI YRI add_default_paths":{"type":"method","name":"add_default_paths","children":[],"call":["@search_paths push ","l strip ","File  readlines map ","File  readlines ","File  file? ","@search_paths concat ","@search_File  readlines map  push ","@search_File  readlines map  concat "]}," YARD CLI Yardoc generate_with_cache":{"type":"method","name":"generate_with_cache","children":[],"call":["Templates Engine  render "," options merge "," options "," log info ","object path "," log ","changed_files include? ","object files any? ","object files "," all_objects each "," all_objects ","Registry  load_all ","changed_files << ","checksums [] != ","checksums [] ","Registry  checksums each ","Registry  checksums "]}," File open!":{"type":"method","name":"open!","children":[],"call":[]}," YARD Helpers HtmlHelper convert_method_to_overload":{"type":"method","name":"convert_method_to_overload","children":[],"call":["meth tag ","meth tag tag ","meth tags size == ","meth tags size ","meth tags ","meth tag ! "]}," YARD Helpers HtmlHelper signature_types":{"type":"method","name":"signature_types","children":[],"call":["type empty? "," format_types "," h ","type empty? ! ","types join "," options [] "," options ","types == ","(lvar :first) join ","types size > ","types size ","first + ","types last =~ ","Regexp  quote ","types first ","types last ","types size == ","types last == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten ","t types ","meth tags map ","meth tags ","meth tag types ","meth tag "," convert_method_to_overload ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq ","meth object ","meth has_tag? ! ","meth has_tag? ","meth respond_to? "," options hide_void_return "," options default_return "," format_types  empty? "," h  empty? ","(lvar :first) join  empty? ","first +  empty? "," format_ format_types s "," format_ h s "," format_(lvar :first) join s "," format_first + s "," format_(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  "," format_(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  "," format_types  empty? ! "," h  empty? ! ","(lvar :first) join  empty? ! ","first +  empty? ! "," format_types s join "," h s join ","(lvar :first) join s join ","first + s join ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  join ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  join "," format_types s == "," h s == ","(lvar :first) join s == ","first + s == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  == ","(lvar : format_types ) join ","(lvar : h ) join "," format_types s size > "," h s size > ","(lvar :first) join s size > ","first + s size > ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  size > ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  size > "," format_types s size "," h s size ","(lvar :first) join s size ","first + s size ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  size ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  size "," format_types  + "," h  + "," format_types s last =~ "," h s last =~ ","(lvar :first) join s last =~ ","first + s last =~ ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  last =~ ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  last =~ "," format_types s first "," h s first ","(lvar :first) join s first ","first + s first ","types  format_types  ","types  h  ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  first ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  first "," format_types s last "," h s last ","(lvar :first) join s last ","first + s last ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  last ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  last "," format_types s size == "," h s size == ","(lvar :first) join s size == ","first + s size == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  size == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  size == "," format_types s last == "," h s last == ","(lvar :first) join s last == ","first + s last == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  last == ","(send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  last == ","(send\n  (send\n    (lvar : convert_method_to_overload ) :tags\n    (sym :return)) :map) flatten ","(send\n  (send\n    (lvar :meth object ) :tags\n    (sym :return)) :map) flatten ","t  format_types s ","t  h s ","t (lvar :first) join s ","t first + s ","t (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  ","t (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  "," convert_method_to_overload  tags map ","meth object  tags map "," convert_method_to_overload  tags ","meth object  tags ","meth tag  format_types s ","meth tag  h s ","meth tag (lvar :first) join s ","meth tag first + s ","meth tag (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten  ","meth tag (send\n  (send\n    (lvar :meth) :tags\n    (sym :return)) :map) flatten uniq  "," convert_method_to_overload  tag types ","meth object  tag types "," convert_method_to_overload  tag ","meth object  tag "," convert_ convert_method_to_overload od_to_overload "," convert_meth object od_to_overload ","(send\n  (send\n    (lvar : convert_method_to_overload ) :tags\n    (sym :return)) :map) flatten uniq ","(send\n  (send\n    (lvar :meth object ) :tags\n    (sym :return)) :map) flatten uniq "," convert_method_to_overload  object ","meth object  object "," convert_method_to_overload  has_tag? ! ","meth object  has_tag? ! "," convert_method_to_overload  has_tag? ","meth object  has_tag? "," convert_method_to_overload  respond_to? ","meth object  respond_to? "]}," YARD Parser SourceParser convert_encoding":{"type":"method","name":"convert_encoding","children":[],"call":["content force_encoding ","content =~ ","content respond_to? ","content [] == ","content [] ","bom size ","bom force_encoding ","ENCODING_BYTE_ORDER_MARKS  each ","content encoding "]}," YARD Parser CParser remove_var_prefix":{"type":"method","name":"remove_var_prefix","children":[],"call":["var gsub "]}," File read_binary":{"type":"method","name":"read_binary","children":[],"call":[]}," CodeObjects MethodObject reader?":{"type":"method","name":"reader?","children":[],"call":["(and\n  (begin\n    (lvasgn :info\n      (send nil :attr_info)))\n  (send\n    (send\n      (lvar :info) :[]\n      (sym :read)) :==\n    (self))) ! ! ","(and\n  (begin\n    (lvasgn :info\n      (send nil :attr_info)))\n  (send\n    (send\n      (lvar :info) :[]\n      (sym :read)) :==\n    (self))) ! ","info [] == ","info [] "," attr_info ","(and\n  (begin\n    (lvasgn : attr_info \n      (send nil :attr_ attr_info )))\n  (send\n    (send\n      (lvar : attr_info ) :[]\n      (sym :read)) :==\n    (self))) ! ! ","(and\n  (begin\n    (lvasgn : attr_info \n      (send nil :attr_ attr_info )))\n  (send\n    (send\n      (lvar : attr_info ) :[]\n      (sym :read)) :==\n    (self))) ! "," attr_info  [] == "," attr_info  [] "," attr_ attr_info  "]}," CodeObjects MethodObject writer?":{"type":"method","name":"writer?","children":[],"call":["(and\n  (begin\n    (lvasgn :info\n      (send nil :attr_info)))\n  (send\n    (send\n      (lvar :info) :[]\n      (sym :write)) :==\n    (self))) ! ! ","(and\n  (begin\n    (lvasgn :info\n      (send nil :attr_info)))\n  (send\n    (send\n      (lvar :info) :[]\n      (sym :write)) :==\n    (self))) ! ","info [] == ","info [] "," attr_info ","(and\n  (begin\n    (lvasgn : attr_info \n      (send nil :attr_ attr_info )))\n  (send\n    (send\n      (lvar : attr_info ) :[]\n      (sym :write)) :==\n    (self))) ! ! ","(and\n  (begin\n    (lvasgn : attr_info \n      (send nil :attr_ attr_info )))\n  (send\n    (send\n      (lvar : attr_info ) :[]\n      (sym :write)) :==\n    (self))) ! "," attr_info  [] == "," attr_info  [] "," attr_ attr_info  "]}," CodeObjects MethodObject attr_info":{"type":"method","name":"attr_info","children":[],"call":[" namespace attributes [] [] "," name to_s gsub "," name to_s "," name "," namespace attributes [] "," scope "," namespace attributes "," namespace "," namespace is_a? "]}," YARD CodeObjects Base relative_path":{"type":"method","name":"relative_path","children":[],"call":["other gsub ","Regexp  quote "," namespace path "," namespace ","other path ","other respond_to? ","result empty? ","other sub ","common sub "," path ","common =~ ","(send nil :path) join match [] ","(send nil :path) join match ","(send nil :path) join ","other parent == "," parent ","other parent ","Registry  at ","String  === ","other [] == ","other [] ","common size ","(str \".\") include? ","common [] ","other path  gsub ","Registry  at  gsub ","other path  path ","Registry  at  path ","other path  respond_to? ","Registry  at  respond_to? ","other sub  empty? ","other path  sub ","Registry  at  sub ","common sub  sub "," path  sub ","(send nil :path) join match []  sub ","common sub  =~ "," path  =~ ","(send nil :path) join match []  =~ ","other path  parent == ","Registry  at  parent == ","other path  parent ","Registry  at  parent ","other path  [] == ","Registry  at  [] == ","other path  [] ","Registry  at  [] ","common sub  size "," path  size ","(send nil :path) join match []  size ","common sub  [] "," path  [] ","(send nil :path) join match []  [] "]}," YARD CLI Base initialize":{"type":"method","name":"initialize","children":[],"call":[" log show_backtraces= "," log "]}," YARD Helpers HtmlHelper charset":{"type":"method","name":"charset","children":[],"call":["lang downcase split last ","lang downcase split ","lang downcase ","Encoding  default_external name downcase ","Encoding  default_external name ","Encoding  default_external ","ENV  [] ","@file contents encoding to_s ","@file contents encoding ","@file contents "," Encoding  default_external name downcase "," Encoding  default_external name "," Encoding  default_external ","ENV  [] downcase split last ","ENV  [] downcase split ","ENV  [] downcase ","lang downcase split last  downcase split last ","Encoding  default_external name downcase  downcase split last ","ENV  []  downcase split last ","@file contents encoding to_s  downcase split last "," Encoding  default_external name downcase  downcase split last ","ENV  [] downcase split last  downcase split last ","lang downcase split last  downcase split ","Encoding  default_external name downcase  downcase split ","ENV  []  downcase split ","@file contents encoding to_s  downcase split "," Encoding  default_external name downcase  downcase split ","ENV  [] downcase split last  downcase split ","lang downcase split last  downcase ","Encoding  default_external name downcase  downcase ","ENV  []  downcase ","@file contents encoding to_s  downcase "," Encoding  default_external name downcase  downcase ","ENV  [] downcase split last  downcase "]}," YARD Templates ErbCache clear!":{"type":"method","name":"clear!","children":[],"call":[]}," YARD Templates ErbCache method_for":{"type":"method","name":"method_for","children":[],"call":[]}," YARD Tags DefaultFactory extract_title_and_desc_from_text":{"type":"method","name":"extract_title_and_desc_from_text","children":[],"call":["text join ","text shift squeeze strip ","text shift squeeze ","text shift ","text split ","text =~ "," raise ","text empty? ","text nil? ","text split  join ","text split  shift squeeze strip ","text split  shift squeeze ","text split  shift ","text split  split ","text split  =~ ","text split  empty? ","text split  nil? "]}," YARD Tags DefaultFactory parse_tag_with_title_and_text":{"type":"method","name":"parse_tag_with_title_and_text","children":[],"call":["Tag  new "," extract_title_and_desc_from_text "]}," YARD Parser Ruby RubyParser on_embdoc_end":{"type":"method","name":"on_embdoc_end","children":[],"call":["@comments []= "," lineno "," visit_ns_token "]}," YARD Parser Ruby RubyParser on_embdoc":{"type":"method","name":"on_embdoc","children":[],"call":["@embdoc << "," visit_ns_token "]}," YARD Parser Ruby RubyParser on_embdoc_beg":{"type":"method","name":"on_embdoc_beg","children":[],"call":[" visit_ns_token "]}," YARD Legacy Statement line_range":{"type":"method","name":"line_range","children":[],"call":[" tokens last line_no "," tokens last "," tokens "," tokens first line_no "," tokens first "]}," YARD CLI Base parse_options":{"type":"method","name":"parse_options","children":[],"call":[" log warn ","e message "," log ","opts parse! "]}," Helpers BaseHelper link_file":{"type":"method","name":"link_file","children":[],"call":["filename filename ","CodeObjects ExtraFileObject  === "]}," YARD CLI Yardoc print_list":{"type":"method","name":"print_list","children":[],"call":[" puts ","item line ","item file ","(send\n  (block\n    (send\n      (send\n        (const nil :Registry) :all) :reject)\n    (args\n      (arg :item))\n    (send\n      (send\n        (send\n          (send nil :options) :[]\n          (sym :verifier)) :call\n        (lvar :item)) :is_a?\n      (const nil :FalseClass))) :sort_by) each ","(send\n  (send\n    (const nil :Registry) :all) :reject) sort_by "," options [] call is_a? "," options [] call "," options [] "," options ","Registry  all reject ","Registry  all ","Registry  load_all ","(send\n  (send nil :run_verifier\n    (send\n      (const nil :Registry) :all)) :sort_by) each "," run_verifier sort_by "," run_verifier ","item path "," log puts "," log "]}," YARD Parser SourceParser parser_class":{"type":"method","name":"parser_class","children":[],"call":[" raise "," caller [] "," caller "," parser_type ","klass ! "," class parser_types [] "," class parser_types "," class "," class parser_types []  ! "]}," YARD Parser SourceParser parser_type_for_extension":{"type":"method","name":"parser_type_for_extension","children":[],"call":[" validated_parser_type ","type first ","extension =~ ","exts is_a? ","exts == ","exts include? "," parser_type_extensions find "," parser_type_extensions ","ext === ","(lvar :exts) flatten any? ","(lvar :exts) flatten "]}," YARD Parser SourceParser parser_type_extensions=":{"type":"method","name":"parser_type_extensions=","children":[],"call":[]}," YARD Parser SourceParser parser_type_extensions":{"type":"method","name":"parser_type_extensions","children":[],"call":[]}," YARD Parser SourceParser parser_types=":{"type":"method","name":"parser_types=","children":[],"call":[]}," YARD Parser SourceParser parser_types":{"type":"method","name":"parser_types","children":[],"call":[]}," YARD Parser SourceParser register_parser_type":{"type":"method","name":"register_parser_type","children":[],"call":[" parser_types []= ","type to_sym "," parser_types "," parser_type_extensions []= "," parser_type_extensions "," raise ","Base  > "]}," YARD Parser Ruby RipperParser freeze_tree":{"type":"method","name":"freeze_tree","children":[],"call":[" freeze_tree ","child parent= ","node children each ","node children "," root ","nodes << ","p_node children each ","p_node children ","nodes shift ","nodes empty? ","t last ","@tokens sort_by ","nodes shift  children each ","nodes shift  children "]}," YARD Parser Ruby RipperParser insert_comments":{"type":"method","name":"insert_comments","children":[],"call":[" comments delete "," comments ","node docstring_range= ","line - ","comment count ","node docstring= ","comment empty? ! ","comment empty? ","@comments [] ","(send\n  (send\n    (lvar :node) :line) :-\n  (int 2)) upto ","node line ","node line - ","node parent type != ","node parent type ","node parent ","node type == ","node type "," root traverse "," root ","node group= ","group last ","group first < ","group first ","@groups each ","node call? ","@comments_flags delete ","@comments delete ","node docstring_hash_flag= ","@comments_flags [] "," add_comment ","@comments each ","subnode line_range include? ","subnode line_range ","subnode type == ","subnode type ","node traverse ","node line_range include? ","node line_range ","@comments keys each ","@comments keys ","@comments size > ","@comments size ","node line > ","(send\n  (send\n    (send\n      (begin\n        (send\n          (send\n            (lvar :node) :line) :-\n          (int 1))) :downto\n      (send\n        (send\n          (lvar :node) :line) :-\n        (int 2))) :to_a) :+\n  (array\n    (send\n      (lvar :node) :line))) each ","(send\n  (send\n    (lvar :node) :line) :-\n  (int 1)) downto to_a + ","(send\n  (send\n    (lvar :node) :line) :-\n  (int 1)) downto to_a ","(send\n  (send\n    (lvar :node) :line) :-\n  (int 1)) downto ","node then_block ","@comments empty? ","(sym :comment) include? ","COMMENT_SKIP_NODE_TYPES  include? "," @comments [] s delete "," @comments [] s ","node then_block  docstring_range= ","@comments []  count ","node then_block  docstring= ","@comments []  empty? ! ","@comments []  empty? ","@@comments [] s [] ","(send\n  (send\n    (lvar :node then_block ) :line) :-\n  (int 2)) upto ","node then_block  line ","node then_block  line - ","node then_block  parent type != ","node then_block  parent type ","node then_block  parent ","node then_block  type == ","node then_block  type ","node then_block  group= ","node then_block  call? ","@@comments [] s_flags delete ","@@comments [] s delete ","node then_block  docstring_hash_flag= ","@@comments [] s_flags [] "," add_@comments []  ","@@comments [] s each ","subnode then_block  line_range include? ","subnode then_block  line_range ","subnode then_block  type == ","subnode then_block  type ","node then_block  traverse ","node then_block  line_range include? ","node then_block  line_range ","@@comments [] s keys each ","@@comments [] s keys ","@@comments [] s size > ","@@comments [] s size ","node then_block  line > ","(send\n  (send\n    (send\n      (begin\n        (send\n          (send\n            (lvar :node then_block ) :line) :-\n          (int 1))) :downto\n      (send\n        (send\n          (lvar :node then_block ) :line) :-\n        (int 2))) :to_a) :+\n  (array\n    (send\n      (lvar :node then_block ) :line))) each ","(send\n  (send\n    (lvar :node then_block ) :line) :-\n  (int 1)) downto to_a + ","(send\n  (send\n    (lvar :node then_block ) :line) :-\n  (int 1)) downto to_a ","(send\n  (send\n    (lvar :node then_block ) :line) :-\n  (int 1)) downto ","node then_block  then_block ","@@comments [] s empty? ","(sym :@comments [] ) include? "]}," YARD Parser Ruby RipperParser on_parse_error":{"type":"method","name":"on_parse_error","children":[],"call":[" raise "," column "," lineno "," file "]}," YARD Parser Ruby RipperParser on_embdoc_end":{"type":"method","name":"on_embdoc_end","children":[],"call":["@comments []= "," lineno "," visit_ns_token ","@comments_range []= "," charno "]}," YARD Parser Ruby RipperParser on_embdoc":{"type":"method","name":"on_embdoc","children":[],"call":["@embdoc << "," visit_ns_token "]}," YARD Parser Ruby RipperParser on_embdoc_beg":{"type":"method","name":"on_embdoc_beg","children":[],"call":[" visit_ns_token "," charno - ","text length "," charno ","String  new "]}," YARD Parser Ruby RipperParser on_comment":{"type":"method","name":"on_comment","children":[],"call":[" column ","@comments []= "," lineno ","append_comment + + ","append_comment + ","@comments delete "," lineno - ","@comments_last_column == ","@comments [] ","comment gsub chomp ","comment gsub "," visit_ns_token ","@groups unshift ","@comments_flags []= ","append_comment ! ","@comments_flags delete ","@comments_flags [] ","1 == ","comment =~ ","@encoding_line ! ","@last_ns_token size == ","@last_ns_token size ","@last_ns_token nil? ","@comments_range []= ","source_range last ","range first ","@comments_range delete "," charno - "," charno "," comment_starts_line? ","@last_ns_token empty? ","@append_comment + + s []= ","@comment gsub chomp s []= ","append_append_comment + +  + + ","append_comment gsub chomp  + + ","@comments []  + + ","append_append_comment + +  + ","append_comment gsub chomp  + ","@comments []  + ","@append_comment + + s delete ","@comment gsub chomp s delete "," column  == ","@append_comment + + s_last_column == ","@comment gsub chomp s_last_column == ","@append_comment + + s [] ","@comment gsub chomp s [] ","append_comment + +  gsub chomp ","comment gsub chomp  gsub chomp ","comment gsub  charno omp ","append_comment + +  gsub ","comment gsub chomp  gsub ","@append_comment + + s_flags []= ","@comment gsub chomp s_flags []= ","append_append_comment + +  ! ","append_comment gsub chomp  ! ","@comments []  ! ","@append_comment + + s_flags delete ","@comment gsub chomp s_flags delete ","@append_comment + + s_flags [] ","@comment gsub chomp s_flags [] ","append_comment + +  =~ ","comment gsub chomp  =~ ","@append_comment + + s_range []= ","@comment gsub chomp s_range []= ","@comments_@comments_range delete  []= ","source_@comments_range delete  last ","@comments_range delete  first ","@append_comment + + s_range delete ","@comment gsub chomp s_range delete ","@comments_@comments_range delete  delete ","  charno arno - ","  charno arno "," append_comment + + _starts_line? "," comment gsub chomp _starts_line? "]}," YARD Parser Ruby RipperParser on_label":{"type":"method","name":"on_label","children":[],"call":["AstNode  new "," charno - "," charno "," lineno ","data [] ","data length "," add_token ","  charno arno - ","  charno arno "]}," YARD Parser Ruby RipperParser on_params":{"type":"method","name":"on_params","children":[],"call":["ParameterNode  new "," charno "," lineno ","AstNode  new ","sub_arg class == ","sub_arg class ","arg map! ","arg first class == ","arg first class ","arg first ","arg class == ","arg class ","args map! ","sub_arg [] type == ","sub_arg [] type ","sub_arg [] "]}," YARD Parser Ruby RipperParser on_void_stmt":{"type":"method","name":"on_void_stmt","children":[],"call":["AstNode  new "," charno "," lineno "]}," YARD Parser Ruby RipperParser on_rescue":{"type":"method","name":"on_rescue","children":[],"call":[" visit_event ","AstNode  new "]}," YARD Parser Ruby RipperParser on_string_content":{"type":"method","name":"on_string_content","children":[],"call":["AstNode  new "," charno "," lineno ","args empty? "]}," YARD Parser Ruby RipperParser on_lambda":{"type":"method","name":"on_lambda","children":[],"call":[" visit_event_arr ","AstNode  new "]}," YARD Parser Ruby RipperParser on_string_literal":{"type":"method","name":"on_string_literal","children":[],"call":[" visit_event_arr ","AstNode  new ","node source_range= ","Range  new ","nsr last + ","nsr last ","nsr first ","node source_range ","@source [] !~ ","@source [] "," charno ","node []= ","klass new ","node line_range ","node [] type ","node [] ","node source_range last - ","node source_range last ","node source_range first + ","node source_range first ","AstNode  node_class_for ","node source_range != ","r last + ","r last ","r first - ","r first ","args [] source_range ","args [] ","args size == ","args size ","LiteralNode  new "," visit_event_aRange  new Range  new  "," visit_event_aargs [] source_range args [] source_range  "," visit_event_arr  source_range= ","node souRange  new ce_Range  new ange= ","node souargs [] source_range ce_args [] source_range ange= ","node source_range  last + ","nsRange  new  last + ","nsargs [] source_range  last + ","node source_range  last ","nsRange  new  last ","nsargs [] source_range  last ","node source_range  first ","nsRange  new  fiRange  new st ","nsargs [] source_range  fiargs [] source_range st "," visit_event_arr  source_range ","node souRange  new ce_Range  new ange ","node souargs [] source_range ce_args [] source_range ange ","@souRange  new ce [] !~ ","@souargs [] source_range ce [] !~ ","@souRange  new ce [] ","@souargs [] source_range ce [] "," chaRange  new no "," chaargs [] source_range no "," visit_event_arr  []= ","AstNode  node_class_for  new "," visit_event_arr  line_range ","node line_Range  new ange ","node line_args [] source_range ange "," visit_event_arr  [] type "," visit_event_arr  [] "," visit_event_arr  source_range last - ","node souRange  new ce_Range  new ange last - ","node souargs [] source_range ce_args [] source_range ange last - "," visit_event_arr  source_range last ","node souRange  new ce_Range  new ange last ","node souargs [] source_range ce_args [] source_range ange last "," visit_event_arr  source_range first + ","node souRange  new ce_Range  new ange fiRange  new st + ","node souargs [] source_range ce_args [] source_range ange fiargs [] source_range st + "," visit_event_arr  source_range first ","node souRange  new ce_Range  new ange fiRange  new st ","node souargs [] source_range ce_args [] source_range ange fiargs [] source_range st ","AstNode   visit_event_arr _class_for ","AstNode  node_class_foRange  new  ","AstNode  node_class_foargs [] source_range  "," visit_event_arr  source_range != ","node souRange  new ce_Range  new ange != ","node souargs [] source_range ce_args [] source_range ange != ","Range  new  last + ","args [] source_range  last + ","Range  new  last ","args [] source_range  last ","Range  new  fiRange  new st - ","args [] source_range  fiargs [] source_range st - ","Range  new  fiRange  new st ","args [] source_range  fiargs [] source_range st ","aRange  new gs [] souRange  new ce_Range  new ange ","aargs [] source_range gs [] souargs [] source_range ce_args [] source_range ange ","aRange  new gs [] ","aargs [] source_range gs [] ","aRange  new gs size == ","aargs [] source_range gs size == ","aRange  new gs size ","aargs [] source_range gs size ","LiteRange  new alNode  new ","Liteargs [] source_range alNode  new "]}," YARD Parser Ruby RipperParser on_qwords_new":{"type":"method","name":"on_qwords_new","children":[],"call":[" visit_event ","AstNode  new ","LiteralNode  new ","node line_range= ","Range  new "," lineno ","node source_range= ","sstart - ","@map [] pop ","@map [] ","@ns_charno - ","LiteralNode  new  line_range= ","LiteralNode  new  source_range= "]}," YARD Parser Ruby RipperParser on_rbracket":{"type":"method","name":"on_rbracket","children":[],"call":[" visit_ns_token ","(or-asgn\n  (send\n    (ivar :@map) :[]\n    (sym :aref))\n  (array)) << "," charno "," lineno ","@map [] "]}," YARD Parser Ruby RipperParser on_aref":{"type":"method","name":"on_aref","children":[],"call":["AstNode  new ","args first line_range first ","args first line_range ","args first ","args first source_range first ","args first source_range ","@map [] pop ","@map [] ","@map [] shift "]}," YARD Parser Ruby RipperParser on_assoclist_from_args":{"type":"method","name":"on_assoclist_from_args","children":[],"call":["args first "]}," YARD Parser Ruby RipperParser on_bare_assoc_hash":{"type":"method","name":"on_bare_assoc_hash","children":[],"call":["AstNode  new ","args first "]}," YARD Parser Ruby RipperParser on_hash":{"type":"method","name":"on_hash","children":[],"call":[" visit_event ","AstNode  new ","args first "]}," YARD Parser Ruby RipperParser on_assoc_new":{"type":"method","name":"on_assoc_new","children":[],"call":["AstNode  new "]}," YARD Parser Ruby RipperParser on_body_stmt":{"type":"method","name":"on_body_stmt","children":[],"call":["AstNode  new ","args first ","args compact size == ","args compact size ","args compact "]}," YARD Parser Ruby RipperParser on_program":{"type":"method","name":"on_program","children":[],"call":["args first "]}," YARD Parser Ruby RipperParser add_token":{"type":"method","name":"add_token","children":[],"call":["@tokens << ","@tokens []= ",": + ","@tokens last [] == ","@tokens last [] ","@tokens last ","@heredoc_tokens pop ","@heredoc_tokens size > ","@heredoc_tokens size ","token == ","@heredoc_tokens << ","@tokens pop ","@heredoc_tokens unshift ","@heredoc_state == ","data force_encoding "," file_encoding "," charno "," lineno ","@percent_ary source_range= ","Range  new ","rng last + ","data length ","rng last ","rng first ","@percent_ary source_range ","data =~ ","data !~ ","@symbol [] ","@tokens last [] + ","token to_s =~ ","token to_s ","Range  new  last + ","@percent_ary source_range  last + ","Range  new  last ","@percent_ary source_range  last ","Range  new  first ","@percent_ary source_range  first "]}," YARD Parser Ruby RipperParser visit_ns_token":{"type":"method","name":"visit_ns_token","children":[],"call":["AstNode  new "," charno - "," charno "," lineno ","data length "," add_token ","(sym :semicolon) include? ","  charno arno - ","  charno arno "]}," YARD Parser Ruby RipperParser visit_event_arr":{"type":"method","name":"visit_event_arr","children":[],"call":["node line_range= ","Range  new "," lineno ","node source_range= ","@ns_charno - ","@map [] pop ","@map [] ","@map [] empty? ! ","@map [] empty? ","MAPPINGS  [] find ","MAPPINGS  [] ","node type "]}," YARD Parser Ruby RipperParser visit_event":{"type":"method","name":"visit_event","children":[],"call":["node line_range= ","Range  new "," lineno ","node source_range= ","@ns_charno - ","@map [] pop ","@map [] ","MAPPINGS  [] ","node type ","map pop ","node block line_range= ","@tokens last [] [] ","@tokens last [] ","@tokens last ","lr first ","node block ","node block source_range= ","sr first ","node block line_range ","node block source_range ","node respond_to? ","@tokens last [] [] - ","@@map []  [] pop ","@@map []  [] ","@map []  pop ","node block line_range  first ","node block source_range  first "]}," YARD Parser Ruby RipperParser enumerator":{"type":"method","name":"enumerator","children":[],"call":[" ast children "," ast "]}," YARD Parser Ruby RipperParser parse":{"type":"method","name":"parse","children":[],"call":[" insert_comments "," freeze_tree ","@ast file= ","@ast full_source= "]}," YARD Parser Ruby RipperParser initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Parser Ruby RubyParser tokenize":{"type":"method","name":"tokenize","children":[],"call":["@parser tokens "]}," YARD Parser Ruby Legacy RubyParser enumerator":{"type":"method","name":"enumerator","children":[],"call":[]}," YARD Parser Ruby Legacy RubyParser tokenize":{"type":"method","name":"tokenize","children":[],"call":["TokenList  new "]}," YARD Parser Ruby Legacy RubyParser parse":{"type":"method","name":"parse","children":[],"call":["StatementList  new "]}," YARD Parser Ruby Legacy RubyParser initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Parser CParser tokenize":{"type":"method","name":"tokenize","children":[],"call":[" raise "]}," YARD Parser Base enumerator":{"type":"method","name":"enumerator","children":[],"call":[]}," YARD Parser Base tokenize":{"type":"method","name":"tokenize","children":[],"call":[" raise "," class "]}," YARD Parser Base parse":{"type":"method","name":"parse","children":[],"call":[" raise "," class "]}," YARD Parser Base initialize":{"type":"method","name":"initialize","children":[],"call":[" raise "]}," StructHandlerMethods create_attributes":{"type":"method","name":"create_attributes","children":[],"call":[" create_reader "," create_member_method? "," create_writer ","klass attributes [] []= ","SymbolHash  [] ","klass attributes [] ","klass attributes ","members each ","klass attributes [] [] "]}," StructHandlerMethods create_reader":{"type":"method","name":"create_reader","children":[],"call":["klass attributes [] [] []= ","klass attributes [] [] ","klass attributes [] ","klass attributes "," add_reader_tags ","o signature ","o source "," register ","MethodObject  new "]}," StructHandlerMethods create_writer":{"type":"method","name":"create_writer","children":[],"call":["klass attributes [] [] []= ","klass attributes [] [] ","klass attributes [] ","klass attributes "," add_writer_tags ","o signature ","o source ","o parameters= "," register ","MethodObject  new "]}," StructHandlerMethods create_class":{"type":"method","name":"create_class","children":[],"call":["o superclass type= ","o superclass ","o superclass is_a? ","o superclass= "," register ","ClassObject  new "," namespace "]}," StructHandlerMethods add_writer_tags":{"type":"method","name":"add_writer_tags","children":[],"call":["new_method docstring add_tag ","YARD Tags Tag  new ","new_method docstring ","new_method docstring replace ","member_tag text "," return_type_from_tag "," member_tag_for_member ","new_method add_tag "," member_tag_for_member  text ","  return_type_from_tag _from_tag ","  member_tag_for_member _for_member "]}," StructHandlerMethods add_reader_tags":{"type":"method","name":"add_reader_tags","children":[],"call":["new_method docstring add_tag ","YARD Tags Tag  new ","new_method docstring ","new_method docstring replace ","member_tag text "," return_type_from_tag "," member_tag_for_member ","new_method add_tag "," member_tag_for_member  text ","  return_type_from_tag _from_tag ","  member_tag_for_member _for_member "]}," StructHandlerMethods return_type_from_tag":{"type":"method","name":"return_type_from_tag","children":[],"call":["member_tag types "]}," StructHandlerMethods create_member_method?":{"type":"method","name":"create_member_method?","children":[],"call":[" member_tag_for_member ! "," member_tag_for_member ","type == ","(send\n  (send\n    (send\n      (lvar :klass) :tags\n      (sym :attr)) :+\n    (send\n      (lvar :klass) :tags\n      (sym :attr_reader))) :+\n  (send\n    (lvar :klass) :tags\n    (sym :attr_writer))) empty? ","klass tags + + ","klass tags ","klass tags + "]}," StructHandlerMethods member_tag_for_member":{"type":"method","name":"member_tag_for_member","children":[],"call":["tag name == ","tag name ","(send\n  (send\n    (lvar :klass) :tags\n    (lvar :specific_tag)) :+\n  (send\n    (lvar :klass) :tags\n    (sym :attr))) find ","klass tags + ","klass tags ","type == "]}," ClassHandler parse_struct_subclass":{"type":"method","name":"parse_struct_subclass","children":[],"call":[" create_attributes "," extract_parameters ","superclass_def =~ "]}," ClassHandler struct_superclass_name":{"type":"method","name":"struct_superclass_name","children":[],"call":["first [] ","first !~ ","first [] =~ ","paramstring first strip ","paramstring first ","superclass match [] split ","superclass match [] ","superclass match ","first [] [] [] ","first [] [] ","first [] size == ","first [] size ","first [] type == ","first [] type ","first type == ","first type ","superclass parameters first ","superclass parameters ","match [] split ","match [] ","superclass call? ","paramstring first strip  [] ","superclass parameters first  [] ","paramstring first strip  !~ ","superclass parameters first  !~ ","paramstring first strip  [] =~ ","superclass parameters first  [] =~ ","paramstring paramstring first strip  strip ","paramstring superclass parameters first  strip ","superclass match [] split  first strip ","match [] split  first strip ","paramstring paramstring first strip  ","paramstring superclass parameters first  ","superclass match [] split  first ","match [] split  first ","superclass superclass match  [] split ","superclass superclass match  [] ","superclass superclass match  ","paramstring first strip  [] [] [] ","superclass parameters first  [] [] [] ","paramstring first strip  [] [] ","superclass parameters first  [] [] ","paramstring first strip  [] size == ","superclass parameters first  [] size == ","paramstring first strip  [] size ","superclass parameters first  [] size ","paramstring first strip  [] type == ","superclass parameters first  [] type == ","paramstring first strip  [] type ","superclass parameters first  [] type ","paramstring first strip  type == ","superclass parameters first  type == ","paramstring first strip  type ","superclass parameters first  type ","superclass parameters paramstring first strip  ","superclass parameters superclass parameters first  ","superclass match  [] split ","superclass match  [] "]}," ClassHandler create_struct_superclass":{"type":"method","name":"create_struct_superclass","children":[],"call":[" parse_struct_subclass ","o superclass= "," register ","ClassObject  new ","superclass [] "," P ","superclass == "," parse_struct_superclass "]}," ClassHandler extract_parameters":{"type":"method","name":"extract_parameters","children":[],"call":["x strip [] ","x strip ","(send\n  (send\n    (lvar :paramstring) :split\n    (str \",\")) :select) map ","x strip [] == ","paramstring split select ","paramstring split ","superstring match [] ","superstring match ","x source strip [] ","x source strip ","x source ","members map! ","x type == ","x type ","superclass parameters select ","superclass parameters ","(send\n  (send\n    (lvar :superstring match [] ) :split\n    (str \",\")) :select) map ","superstring match []  split select ","superstring match []  split "]}," ClassHandler parse_struct_superclass":{"type":"method","name":"parse_struct_superclass","children":[],"call":[" create_attributes "," extract_parameters ","superclass parameters ","superclass call? "]}," YARD CLI YRI print_usage":{"type":"method","name":"print_usage","children":[],"call":[" puts "," log puts "," log "]}," YARD Verifier add_expressions":{"type":"method","name":"add_expressions","children":[],"call":["expressions flatten "," expressions "]}," YARD Verifier expressions=":{"type":"method","name":"expressions=","children":[],"call":[" create_method_from_expressions "]}," YARD Tags OverloadTag to_ary":{"type":"method","name":"to_ary","children":[],"call":[]}," YARD Tags OverloadTag to_a":{"type":"method","name":"to_a","children":[],"call":[]}," YARD StubProxy hash":{"type":"method","name":"hash","children":[],"call":["@path hash "]}," YARD Serializers FileSystemSerializer extension=":{"type":"method","name":"extension=","children":[],"call":[" options []= "," options "]}," YARD Serializers FileSystemSerializer basepath=":{"type":"method","name":"basepath=","children":[],"call":[" options []= "," options "]}," YARD CodeObjects RootObject hash":{"type":"method","name":"hash","children":[],"call":["root hash "]}," YARD CodeObjects RootObject equal?":{"type":"method","name":"equal?","children":[],"call":["other == "]}," YARD CodeObjects Proxy to_ary":{"type":"method","name":"to_ary","children":[],"call":[]}," YARD CodeObjects Proxy hash":{"type":"method","name":"hash","children":[],"call":[" path hash "," path "]}," YARD CodeObjects Proxy equal?":{"type":"method","name":"equal?","children":[],"call":[" path == ","other path "," path ","other respond_to? "]}," YARD CodeObjects Base hash":{"type":"method","name":"hash","children":[],"call":[" path hash "," path "]}," YARD CodeObjects Base equal?":{"type":"method","name":"equal?","children":[],"call":[" path == ","other path "," path ","other is_a? "]}," YARD CLI Yardoc add_visibility_verifier":{"type":"method","name":"add_visibility_verifier","children":[],"call":[" options [] add_expressions "," options [] "," options "," visibilities uniq inspect "," visibilities uniq "," visibilities "," options verifier add_expressions "," options verifier "]}," YARD CLI Yardoc do_build_gems":{"type":"method","name":"do_build_gems","children":[],"call":[" exit ","Yardoc  run "," log info ","spec full_name "," log ","Dir  chdir ","spec full_gem_path ","Registry  clear ","Registry  yardoc_file_for_gem ","spec name "," log debug ","rebuild ! ","File  directory? ","Gem  source_index find_name each ","Gem  source_index find_name ","Gem  source_index "," require ","Dir  chRegistry  yardoc_file_for_gem  ","File  Registry  yardoc_file_for_gem ectory? "]}," YARD CLI Yardoc parse_arguments":{"type":"method","name":"parse_arguments","children":[],"call":[" add_visibility_verifier ","Dir  glob first ","Dir  glob "," options [] "," options "," files= "," files empty? "," files "," optparse "," yardopts "," support_rdoc_document_file! "," hidden_tags ","Tags Library  visible_tags "," options []= "," files first "," options [] << ","x =~ "," files delete_if "," use_yardopts_file "," use_document_file "," send ","without > ","args index ","(str \"document\") each "," verify_markup_options ! "," verify_markup_options "," generate ","CodeObjects ExtraFileObject  new "," parse_yardopts_options "," options [] unshift uniq! "," options [] unshift ","(str \"ascii-8bit\") * "," Encoding  default_internal= "," Encoding  default_external= "," log warn "," log "," Encoding  default_internal == "," Encoding  default_internal "," options onefile "," options files unshift uniq! "," options files unshift "," options readme "," options files "," add_api_verifier "," apply_locale "," files empty? ! ","(send\n  (send\n    (const nil :Dir) :glob\n    (str \"README{,*[^~]}\")) :sort_by) first ","r index ","r count ","Dir  glob sort_by "," extra_file_valid? ","(send\n  (block\n    (send\n      (send\n        (const nil :Dir) :glob\n        (str \"README{,*[^~]}\")) :select)\n    (args\n      (arg :f))\n    (send nil :extra_file_valid?\n      (lvar :f))) :sort_by) first ","(send\n  (send\n    (const nil :Dir) :glob\n    (str \"README{,*[^~]}\")) :select) sort_by ","Dir  glob select "," options Dir  glob first  "," options (send\n  (send\n    (const nil :Dir) :glob\n    (str \"README{,*[^~]}\")) :sort_by) first  "," options (send\n  (block\n    (send\n      (send\n        (const nil :Dir) :glob\n        (str \"README{,*[^~]}\")) :select)\n    (args\n      (arg :f))\n    (send nil :extra_file_valid?\n      (lvar :f))) :sort_by) first  "]}," YARD Verifier run":{"type":"method","name":"run","children":[],"call":[" call is_a? "," call ","list reject "]}," YARD Templates Section parse_sections":{"type":"method","name":"parse_sections","children":[],"call":["sections << ","Section  new ","subsections is_a? ","args [] ","index + ","args [] is_a? ","args each_with_index ","args first ","args first is_a? ! ","args first is_a? ","args size == ","args size ","args []  is_a? ","args first  [] ","args first  [] is_a? ","args first  each_with_index ","args first  first ","args first  first is_a? ! ","args first  first is_a? ","args first  size == ","args first  size "]}," YARD Templates Section any":{"type":"method","name":"any","children":[],"call":["section any ","section empty? ","section == "," find "]}," YARD Templates Section to_a":{"type":"method","name":"to_a","children":[],"call":["list << ","s to_a "," each "," empty? "," name "]}," YARD Templates Section place":{"type":"method","name":"place","children":[],"call":[" parse_sections "]}," YARD Templates Section inspect":{"type":"method","name":"inspect","children":[],"call":[" empty? "," name inspect "," name "," name path "," name respond_to? ","  name inspect ame i name inspect spect ","  name inspect ame ","  name inspect ame path ","  name inspect ame respo name inspect d_to? "]}," YARD Templates Section unshift":{"type":"method","name":"unshift","children":[],"call":[" parse_sections "]}," YARD Templates Section push":{"type":"method","name":"push","children":[],"call":[" parse_sections "]}," YARD Templates Section ==":{"type":"method","name":"==","children":[],"call":[" name == "," name "," to_a == "," to_a "," eql? "]}," YARD Templates Section eql?":{"type":"method","name":"eql?","children":[],"call":[" name == ","other name "," name "]}," YARD Templates Section []":{"type":"method","name":"[]","children":[],"call":["o name == ","args first ","o name "," find ","args first is_a? ","obj name= "," name ","args size > ","args size "," class new "," class "]}," YARD Templates Section dup":{"type":"method","name":"dup","children":[],"call":["obj name= "," name "]}," YARD Templates Section initialize":{"type":"method","name":"initialize","children":[],"call":[" replace "," parse_sections "," name= "]}," YARD Helpers MarkupHelper markup_file_contents":{"type":"method","name":"markup_file_contents","children":[],"call":["contents =~ "]}," YARD Helpers MarkupHelper markup_for_file":{"type":"method","name":"markup_for_file","children":[],"call":[" options [] "," options ","exts include? ","MARKUP_EXTENSIONS  each ","(or\n  (send\n    (send\n      (const nil :File) :extname\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase ","File  extname [] ","File  extname ","1 to_sym ","contents =~ "," options markup ","(or\n  (send\n    (send\n      (const nil :File) :extname\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase s include? ","(or\n  (send\n    (send\n      (const nil :File) :(or\n  (send\n    (send\n      (const nil :File) :extname\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase name\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase ","File  (or\n  (send\n    (send\n      (const nil :File) :extname\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase name [] ","File  (or\n  (send\n    (send\n      (const nil :File) :extname\n      (lvar :filename)) :[]\n    (irange\n      (int 1)\n      (int -1)))\n  (str \"\")) downcase name "]}," YARD Helpers HtmlHelper link_include_object":{"type":"method","name":"link_include_object","children":[],"call":[" htmlify ","obj docstring "," insert_include "]}," YARD Helpers HtmlHelper html_markup_html":{"type":"method","name":"html_markup_html","children":[],"call":[]}," YARD Helpers HtmlHelper html_markup_text":{"type":"method","name":"html_markup_text","children":[],"call":["<pre> + + ","<pre> + "," h "," h gsub "]}," YARD Helpers HtmlHelper html_markup_rdoc":{"type":"method","name":"html_markup_rdoc","children":[],"call":[" fix_typewriter "," fix_dash_dash ","MarkupHelper SimpleMarkup  convert ","SimpleMarkupHtml  instance_variable_set "," url_for "," object "," markup_class new convert "," simple_markup_html "," markup_class new "," markup_class "," simple_markup_html instance_variable_set ","doc to_html ","doc from_path= ","doc respond_to? "," simple_markup_ fix_typewriter  "," simple_markup_ fix_dash_dash  "," simple_markup_MarkupHelper SimpleMarkup  convert  "," simple_markup_ markup_class new convert  "," simple_markup_ fix_typewriter  instance_variable_set "," simple_markup_ fix_dash_dash  instance_variable_set "," simple_markup_MarkupHelper SimpleMarkup  convert  instance_variable_set "," simple_markup_ markup_class new convert  instance_variable_set ","doc to_ fix_typewriter  ","doc to_ fix_dash_dash  ","doc to_MarkupHelper SimpleMarkup  convert  ","doc to_ markup_class new convert  "," markup_class new  to_html "," markup_class new  from_path= "," markup_class new  respond_to? "]}," YARD Helpers HtmlHelper html_markup_textile":{"type":"method","name":"html_markup_textile","children":[],"call":["doc to_html ","doc hard_breaks= ","doc respond_to? "," markup_class new "," markup_class "," markup_class new  to_html "," markup_class new  hard_breaks= "," markup_class new  respond_to? "]}," YARD Helpers HtmlHelper html_markup_markdown":{"type":"method","name":"html_markup_markdown","children":[],"call":[" markup_class new to_html "," markup_class new "," markup_class ","provider to_s == ","provider to_s ","provider new to_html ","provider new ","CommonMarker  render_html "," markup_class  to_s == "," markup_class  to_s "," markup_class  new to_html "," markup_class  new "]}," Helpers BaseHelper link_include_object":{"type":"method","name":"link_include_object","children":[],"call":["object docstring ","obj docstring "]}," Helpers BaseHelper globals":{"type":"method","name":"globals","children":[],"call":[" options [] "," options "," options globals "]}," YARD Tags Library factory_method_for":{"type":"method","name":"factory_method_for","children":[],"call":["@factory_methods [] "]}," HTTPRequest xhr?":{"type":"method","name":"xhr?","children":[],"call":["(or\n  (send\n    (self) :[]\n    (str \"X-Requested-With\"))\n  (str \"\")) downcase == ","(or\n  (send\n    (self) :[]\n    (str \"X-Requested-With\"))\n  (str \"\")) downcase "," [] ","(or\n  (send\n    (self) :[]\n    (str \"X-Requested-With\"))\n  (str \"\")) casecmp == ","(or\n  (send\n    (self) :[]\n    (str \"X-Requested-With\"))\n  (str \"\")) casecmp "]}," YARD Server WebrickServlet do_GET":{"type":"method","name":"do_GET","children":[],"call":["response []= ","headers each ","response body= ","body [] ","body is_a? ","response status= "," adapter router call "," adapter router "," adapter "]}," YARD Server WebrickServlet initialize":{"type":"method","name":"initialize","children":[],"call":[" adapter= "]}," YARD Server WebrickAdapter start":{"type":"method","name":"start","children":[],"call":["server start ","server shutdown "," trap ","server mount ","WEBrick HTTPServer  new "," server_options "," server_options []= "," server_options [] ","WEBrick HTTPServer  new  start ","WEBrick HTTPServer  new  shutdown ","WEBrick HTTPServer  new  mount "," WEBrick HTTPServer  new _options "," WEBrick HTTPServer  new _options []= "," WEBrick HTTPServer  new _options [] "]}," search":{"type":"method","name":"search","children":[],"call":[" yieldall "," erb "," options []= "," h "," options "," options breadcrumb_title= "]}," init":{"type":"method","name":"init","children":[],"call":[" sections "," T ","@list_type to_sym "," generate_file_list "," generate_method_list "," generate_class_list "," sections place after_any "," sections place "]}," YARD Server StaticCaching check_static_cache":{"type":"method","name":"check_static_cache","children":[],"call":["File  read_binary "," log debug "," log ","File  file? ","cache_path sub ","File  join "," request path sub + "," request path sub "," request path "," request "," adapter document_root "," adapter ","cache_path sub  sub ","File  join  sub "]}," YARD Server Router final_options":{"type":"method","name":"final_options","children":[],"call":[" adapter options merge ","paths join "," adapter options "," adapter ","File  cleanpath gsub ","File  cleanpath ","File  cleanpath gsub s join ","File  cleanFile  cleanpath gsub  gsub ","File  cleanFile  cleanpath gsub  "]}," YARD Server Router route_search":{"type":"method","name":"route_search","children":[],"call":["SearchCommand  new call "," request ","SearchCommand  new "," final_options ","paths empty? "]}," YARD Server Router route_list":{"type":"method","name":"route_list","children":[],"call":["cmd new call "," request ","cmd new "," final_options ","paths shift ","paths empty? ","ListCommand  new call ","ListCommand  new "]}," YARD Server Router route_index":{"type":"method","name":"route_index","children":[],"call":["LibraryIndexCommand  new call "," request ","LibraryIndexCommand  new "," adapter options merge "," adapter options "," adapter "," route_docs "," adapter libraries values first first "," adapter libraries values first "," adapter libraries values "," adapter libraries "," adapter options [] "]}," YARD Server Router route_docs":{"type":"method","name":"route_docs","children":[],"call":["cmd call "," request ","cmd new "," final_options ","paths shift ","paths first "," route_index ","library nil? ","cmd new  call ","cmd new  new "]}," YARD Server Router route":{"type":"method","name":"route","children":[],"call":[" route_search "," search_prefix "," route_list "," list_prefix "," route_docs "," docs_prefix "," parse_library_from_path ","2 gsub split ","2 gsub "," route_index ","path == ","path empty? "," request path gsub gsub "," request path gsub "," request path "," request ","path gsub gsub ","path gsub "," route_static "," static_prefix "," parse_library_from_ request path gsub gsub  "," parse_library_from_path gsub gsub  "," request path gsub gsub  == ","path gsub gsub  == "," request path gsub gsub  empty? ","path gsub gsub  empty? "," request  request path gsub gsub  gsub gsub "," request path gsub gsub  gsub gsub "," request  request path gsub gsub  gsub "," request path gsub gsub  gsub "," request  request path gsub gsub  "," request path gsub gsub  ","path gsub gsub  gsub gsub ","path gsub gsub  gsub "]}," YARD Server Router parse_library_from_path":{"type":"method","name":"parse_library_from_path","children":[],"call":["libs last ","paths shift ","l version == ","paths first ","l version ","libs find "," adapter libraries [] "," adapter libraries "," adapter ","paths dup "," adapter libraries values first first "," adapter libraries values first "," adapter libraries values "," adapter options [] "," adapter options "," request version_supplied= "," request "," adapter libraries []  last ","paths dup  shift ","paths dup  first "," adapter libraries []  find ","paths dup  dup "]}," YARD Server Router search_prefix":{"type":"method","name":"search_prefix","children":[],"call":[]}," YARD Server Router list_prefix":{"type":"method","name":"list_prefix","children":[],"call":[]}," YARD Server Router docs_prefix":{"type":"method","name":"docs_prefix","children":[],"call":[]}," YARD Server Router call":{"type":"method","name":"call","children":[],"call":["StaticFileCommand  new call ","StaticFileCommand  new "," adapter options "," adapter "," route "," check_static_cache "," request= ","RootRequestCommand  new call ","RootRequestCommand  new "]}," YARD Server Router initialize":{"type":"method","name":"initialize","children":[],"call":[" adapter= "]}," Request xhr?":{"type":"method","name":"xhr?","children":[],"call":["(or\n  (send\n    (send nil :env) :[]\n    (str \"HTTP_X_REQUESTED_WITH\"))\n  (str \"\")) downcase == ","(or\n  (send\n    (send nil :env) :[]\n    (str \"HTTP_X_REQUESTED_WITH\"))\n  (str \"\")) downcase "," env [] "," env ","(or\n  (send\n    (send nil :env) :[]\n    (str \"HTTP_X_REQUESTED_WITH\"))\n  (str \"\")) casecmp == ","(or\n  (send\n    (send nil :env) :[]\n    (str \"HTTP_X_REQUESTED_WITH\"))\n  (str \"\")) casecmp "]}," YARD Server RackAdapter start":{"type":"method","name":"start","children":[],"call":["server start ","server shutdown "," trap ","server instance_variable_set ","Rack Server  new "," server_options "," print_start_message ","RackServer  new ","Rack Server  new  start ","RackServer  new  start ","Rack Server  new  shutdown ","RackServer  new  shutdown ","Rack Server  new  instance_variable_set ","RackServer  new  instance_variable_set "," Rack Server  new _options "," RackServer  new _options "]}," YARD Server RackAdapter call":{"type":"method","name":"call","children":[],"call":[" router call "," router ","request path_info= "," unescape ","request path_info ","Rack Request  new ","ex message + + ","ex backtrace join ","ex backtrace ","ex message + ","ex message "," log backtrace "," log ","Rack Request  new  path_info= ","Rack Request  new  path_info "]}," YARD Server RackMiddleware call":{"type":"method","name":"call","children":[],"call":["@app call ","status == ","@adapter call "]}," YARD Server RackMiddleware initialize":{"type":"method","name":"initialize","children":[],"call":["RackAdapter  new ","opts [] "]}," YARD Server LibraryVersion load_source_path":{"type":"method","name":"load_source_path","children":[],"call":[" send "," respond_to? "," source "]}," YARD Server LibraryVersion source_path_for_gem":{"type":"method","name":"source_path_for_gem","children":[],"call":[" gemspec full_gem_path "," gemspec "]}," YARD Server LibraryVersion source_path_for_disk":{"type":"method","name":"source_path_for_disk","children":[],"call":["File  dirname "," yardoc_file "]}," YARD Server LibraryVersion load_yardoc_from_gem":{"type":"method","name":"load_yardoc_from_gem","children":[],"call":[" raise ","File  exist? ","File  join "," yardoc_file ","FileUtils  touch "," yardoc_file= ","Registry  yardoc_file_for_gem "," name ","CLI Gems  run "," log debug "," to_s "," log ","Thread  new ","File  directory? "," version "," require ","@@chdir_mutex synchronize "," ready? "]}," YARD Server LibraryVersion load_yardoc_from_disk":{"type":"method","name":"load_yardoc_from_disk","children":[],"call":[" raise ","CLI Yardoc  run "," yardoc_file ","Thread  new ","Dir  chdir "," source_path_for_disk ","@@chdir_mutex synchronize "," ready? "]}," YARD Server LibraryVersion gemspec":{"type":"method","name":"gemspec","children":[],"call":["Gem  source_index find_name first ","Gem  source_index find_name "," name ","Gem  source_index "," version ","YARD GemIndex  find_all_by_name last ","YARD GemIndex  find_all_by_name ","Gem  source_index find_name last "]}," YARD Server LibraryVersion prepare!":{"type":"method","name":"prepare!","children":[],"call":[" send "," respond_to? "," source "," yardoc_file "," ready? "]}," YARD Server LibraryVersion eql?":{"type":"method","name":"eql?","children":[],"call":["other yardoc_file == "," yardoc_file ","other yardoc_file ","other version == "," version ","other version ","other name == "," name ","other name ","other is_a? "]}," YARD Server LibraryVersion hash":{"type":"method","name":"hash","children":[],"call":[" to_s hash "," to_s "]}," YARD Server LibraryVersion to_s":{"type":"method","name":"to_s","children":[],"call":[" name "," version "," name to_s "]}," YARD Server LibraryVersion initialize":{"type":"method","name":"initialize","children":[],"call":[" source_path= "," load_source_path "," source= "," version= "," yardoc_file= "," name= "]}," YARD Server DocServerSerializer serialized_path":{"type":"method","name":"serialized_path","children":[],"call":[" escape_path ","File  join ","command adapter router docs_prefix ","command adapter router ","command adapter ","/ + ","command library to_s ","command library ","command single_library "," options [] "," options ","object path gsub ","object path "," escape_path + ","object type ","object name "," serialized_path ","object namespace "," serialized_path + + ","object name to_s "," serialized_path + ","object scope == ","object scope ","(lvar :object) gsub "," escape "," urlencode "," options []  adapter router docs_prefix "," options []  adapter router "," options []  adapter "," options []  library to_s "," options []  library "," options []  single_library ","object object name to_s  ","object object name to_s space ","object object name to_s  to_s "]}," YARD Server DocServerSerializer initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Server DocServerHelper router":{"type":"method","name":"router","children":[],"call":["@adapter router "]}," YARD Server DocServerHelper base_path":{"type":"method","name":"base_path","children":[],"call":["path + ","@library name ","@library to_s "," router request version_supplied "," router request "," router "]}," YARD Server DocServerHelper url_for_file":{"type":"method","name":"url_for_file","children":[],"call":["(str \"/\") + + ","(str \"/\") + ","filename sub ","@library source_path to_s ","@library source_path "," base_path "," router docs_prefix "," router ","filename filename ","filename is_a? "," abs_url ","anchor empty? ! ","anchor empty? ","filename filename  sub ","filename filename  filename filename  ","filename filename  is_a? "]}," YARD Server DocServerHelper url_for":{"type":"method","name":"url_for","children":[],"call":["String  === ","obj nil? ","File  join "," base_path "," router docs_prefix "," router "," url_for_index ","obj == "," router static_prefix "," abs_url "]}," YARD Server Commands StaticFileCommand favicon?":{"type":"method","name":"favicon?","children":[],"call":[" raise "," body= "," status= "," headers []= "," headers "," request path == "," request path "," request "]}," YARD Server Commands StaticFileCommand run":{"type":"method","name":"run","children":[],"call":[" status= "," favicon? "," body= ","File  read "," headers []= "," mime_type "," headers ",". + "," request path [] "," request path "," request ","File  exist? ","File  join ","(send\n  (array\n    (send\n      (send nil :adapter) :document_root)) :+\n  (const nil :STATIC_PATHS)) compact each ","(send\n  (array\n    (send\n      (send nil :adapter) :document_root)) :+\n  (const nil :STATIC_PATHS)) compact ","(send\n  (send nil :adapter) :document_root) + "," adapter document_root "," adapter ","File  cleanpath gsub ","File  cleanpath ","(send\n  (array\n    (send\n      (send nil :adapter) :document_root)) :+\n  (send\n    (const nil :STATIC_PATHS) :reverse)) compact each ","(send\n  (array\n    (send\n      (send nil :adapter) :document_root)) :+\n  (send\n    (const nil :STATIC_PATHS) :reverse)) compact ","STATIC_PATHS  reverse ","assets_template find_file ","Templates Engine  template "," path [] "," path "," not_found "," static_template_file? "," request File  cleanpath gsub  [] "," request File  cleanpath gsub  ","File  cleanFile  cleanpath gsub  gsub ","File  cleanFile  cleanpath gsub  ","assets_template find_File  join  ","Templates Engine  template  find_file "," File  cleanpath gsub  [] "," File  cleanpath gsub  "," static_template_File  join ? "]}," YARD Server Commands SearchCommand search_for_object":{"type":"method","name":"search_for_object","children":[],"call":[" results= ","name length to_f / "," query length to_f "," query length "," query ","name length to_f ","name length ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s ","o name ","o type == ","o type ","(send\n  (block\n    (send\n      (send\n        (const nil :Registry) :all) :select)\n    (args\n      (arg :o))\n    (send\n      (send\n        (send\n          (lvar :o) :path) :downcase) :include?\n      (send\n        (send nil :query) :downcase))) :reject) sort_by "," query =~ "," query include? ","(send\n  (send nil :query) :=~\n  (regexp\n    (str \"[#.]\")\n    (regopt))) ! ","name include? ! ","name include? "," query downcase ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s downcase ","(send\n  (send\n    (const nil :Registry) :all) :select) reject ","o path downcase include? ","o path downcase ","o path ","Registry  all select ","Registry  all ","m empty? ","(send\n  (send\n    (send nil :query) :split\n    (regexp\n      (str \"\\\\s+\")\n      (regopt))) :map) reject ","c downcase "," query split map "," query split ","(send\n  (block\n    (send\n      (send nil :run_verifier\n        (send\n          (const nil :Registry) :all)) :select)\n    (args\n      (arg :o))\n    (send\n      (send\n        (send\n          (lvar :o) :path) :downcase) :include?\n      (send\n        (send nil :query) :downcase))) :reject) sort_by ","(send\n  (send nil :run_verifier\n    (send\n      (const nil :Registry) :all)) :select) reject "," run_verifier select "," run_verifier ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s  length to_f / ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s downcase  length to_f / ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s  length to_f ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s downcase  length to_f ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s  length ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s downcase  length ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s \n    (true))\n  (send\n    (lvar :o) :(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s )) to_s ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s downcase \n    (true))\n  (send\n    (lvar :o) :(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s downcase )) to_s ","o (if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s  ","o (if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s downcase  ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s  include? ! ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s downcase  include? ! ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s  include? ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s downcase  include? ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s \n    (true))\n  (send\n    (lvar :o) :(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s )) to_s downcase ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s downcase \n    (true))\n  (send\n    (lvar :o) :(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s downcase )) to_s downcase "]}," YARD Server Commands SearchCommand serve_normal":{"type":"method","name":"serve_normal","children":[],"call":[" body= ","Templates Engine  render "," options "," options update "," results "," query "," visible_results "]}," YARD Server Commands SearchCommand serve_xhr":{"type":"method","name":"serve_xhr","children":[],"call":[" body= ","(send\n  (send nil :visible_results) :map) join ","(send\n  (begin\n    (if\n      (send\n        (send\n          (lvar :o) :type) :==\n        (sym :method))\n      (send\n        (lvar :o) :name\n        (true))\n      (send\n        (lvar :o) :name))) :to_s) join "," serializer serialized_path "," serializer ","o namespace path ","o namespace ","o namespace root? ","o path ","(if\n  (send\n    (send\n      (lvar :o) :type) :==\n    (sym :method))\n  (send\n    (lvar :o) :name\n    (true))\n  (send\n    (lvar :o) :name)) to_s ","o name ","o type == ","o type "," visible_results map "," visible_results "," headers []= "," headers "," url_for "]}," YARD Server Commands SearchCommand visible_results":{"type":"method","name":"visible_results","children":[],"call":[" results [] "," results "]}," YARD Server Commands SearchCommand run":{"type":"method","name":"run","children":[],"call":[" serve_normal "," serve_xhr "," request xhr? "," request "," search_for_object "," redirect "," serializer serialized_path "," serializer ","Registry  at "," query "," library "," single_library "," adapter router docs_prefix "," adapter router "," adapter "," query =~ "," query= "," request query [] "," request query ","Registry  load_all "," query nil? "," url_for "," abs_url "]}," YARD Server Commands ListFilesCommand items":{"type":"method","name":"items","children":[],"call":[" options [] "," options "]}," YARD Server Commands ListFilesCommand type":{"type":"method","name":"type","children":[],"call":[]}," YARD Server Commands ListMethodsCommand items":{"type":"method","name":"items","children":[],"call":[" prune_method_listing ","m name to_s ","m name ","Registry  all sort_by ","Registry  all ","Registry  load_all "]}," YARD Server Commands ListMethodsCommand type":{"type":"method","name":"type","children":[],"call":[]}," YARD Server Commands ListClassesCommand items":{"type":"method","name":"items","children":[],"call":[" run_verifier ","Registry  all ","Registry  load_all "]}," YARD Server Commands ListClassesCommand type":{"type":"method","name":"type","children":[],"call":[]}," YARD Server Commands ListCommand run":{"type":"method","name":"run","children":[],"call":[" render "," options update "," request path split last "," request path split "," request path "," request "," items "," options "," not_found "," cache ","tpl contents ","tpl send ","tpl respond_to? "," fulldoc_template "," run_verifier ","Registry  all ","Registry  load_all "," fulldoc_template  contents "," fulldoc_template  send "," fulldoc_template  respond_to? "]}," YARD Server Commands ListCommand type":{"type":"method","name":"type","children":[],"call":[" raise "]}," YARD Server Commands ListCommand items":{"type":"method","name":"items","children":[],"call":[" raise "]}," YARD Server Commands LibraryIndexCommand run":{"type":"method","name":"run","children":[],"call":[" render "," options= ","SymbolHash  new update "," adapter "," adapter libraries ","SymbolHash  new "," path empty? "," path "," options reset_defaults "," options "," options libraries= "," options adapter= ","LibraryIndexOptions  new "]}," YARD Server Commands LibraryCommand not_prepared":{"type":"method","name":"not_prepared","children":[],"call":[" render "," options update ","request path "," options "," caching= "," request path "," request "," body "," headers "," status "," headers= "," body= "," status= "]}," YARD Server Commands LibraryCommand load_yardoc":{"type":"method","name":"load_yardoc","children":[],"call":[" library yardoc_file "," library ","Registry  load_yardoc ","Registry  clear "," log debug "," log ","@@last_yardoc == "," raise ","Thread  current []= ","Thread  current ","Thread  current [] == ","Thread  current [] ","Templates ErbCache  clear! "," library ready? "," library yardoc_file  == "]}," YARD Server Commands LibraryCommand setup_yardopts":{"type":"method","name":"setup_yardopts","children":[],"call":[" options update ","yardoc options to_hash ","yardoc options "," options ","yardoc options [] unshift ","Dir  glob "," library source_path + "," library source_path "," library ","yardoc options [] ","yardoc options delete ","yardoc parse_arguments ","yardoc run "," incremental ","CLI Yardoc  new ","Dir  chdir ","@@library_chdir_lock synchronize ","yardoc send ","CLI Yardoc  new  options to_hash ","CLI Yardoc  new  options ","CLI Yardoc  new  options [] unshift ","CLI Yardoc  new  options [] ","CLI Yardoc  new  options delete ","CLI Yardoc  new  parse_arguments ","CLI Yardoc  new  run ","CLI Yardoc  new  send "]}," YARD Server Commands LibraryCommand setup_library":{"type":"method","name":"setup_library","children":[],"call":[" setup_yardopts "," load_yardoc "," library prepare! "," library "," request query [] "," request query "," request "," request xhr? "]}," YARD Server Commands LibraryCommand call":{"type":"method","name":"call","children":[],"call":[" not_prepared "," setup_library "," options= ","SymbolHash  new update "," single_library "," adapter "," library "," serializer ","SymbolHash  new "," request= "," restore_template_info "," options title= ","(str \"Documentation for \") + ","( + + ","( + "," library version "," library name "," options "," options command= "," options reset_defaults ","LibraryOptions  new "," save_default_template_info "," call_without_fork "," call_with_fork "," can_fork? "]}," YARD Server Commands LibraryCommand initialize":{"type":"method","name":"initialize","children":[],"call":[" serializer= ","DocServerSerializer  new "]}," YARD Server Commands FramesCommand run":{"type":"method","name":"run","children":[],"call":[" render "," options update "," options ","( + + ","( + "," library version "," library "," library name "," path empty? "," path "," path ! "," url_for_file "," options [] first "," options [] "," options [] first sub "," library source_path "," options [] size > "," options [] size "," object_path "," path empty? ! "," path =~ "," request path gsub "," request path "," request ","File  basename "," options [] first path "," cache ","tpl contents ","tpl generate_frameset "," fulldoc_template "," fulldoc_template  contents "," fulldoc_template  generate_frameset "]}," YARD Server Commands DisplayObjectCommand object_path":{"type":"method","name":"object_path","children":[],"call":[" path sub gsub sub sub "," path sub gsub sub "," path sub gsub "," path sub "," path "," path == "]}," YARD Server Commands DisplayObjectCommand not_found":{"type":"method","name":"not_found","children":[],"call":[" body= "," object_path "]}," YARD Server Commands DisplayObjectCommand index":{"type":"method","name":"index","children":[],"call":[" render "," options update ","Registry  all "," options ","( + + ","( + "," library version "," library "," library name "," options [] ","Registry  load_all "]}," YARD Server Commands DisplayObjectCommand run":{"type":"method","name":"run","children":[],"call":[" status= "," render "," options update "," options ","Registry  at "," object_path "," index "," path empty? "," path "," path == "," path= "," cache "," body first "," body "," router send "," router "," body= "," headers= "," url_for_file "," options readme ","DisplayFileCommand  new call "," request ","DisplayFileCommand  new "," adapter options merge ","filename sub "," library source_path to_s "," library source_path "," library "," adapter options "," adapter "," options readme filename "," not_found "," Registry  at _path ","  url_for_file _for_file "," options readme filename  sub "," options readme  options readme filename  "]}," YARD Server Commands DisplayFileCommand run":{"type":"method","name":"run","children":[],"call":[" render "," options update ","Registry  root "," options ","IO  read "," headers []= ","StaticFileCommand DefaultMimeTypes  [] ","1 downcase "," headers ","filename =~ "," raise ","File  file? ! ","File  file? ","File  cleanpath ","File  join "," path "," library source_path "," library ","CodeObjects ExtraFileObject  new "," index ","File  read_binary ","File  cleanpath  =~ ","CodeObjects ExtraFileObject  new name =~ ","File  CodeObjects ExtraFileObject  new ? ! ","File  CodeObjects ExtraFileObject  new ? "]}," YARD Server Commands Base redirect":{"type":"method","name":"redirect","children":[],"call":[" raise "," status= "," headers []= "," headers "]}," YARD Server Commands Base render":{"type":"method","name":"render","children":[],"call":[" cache ","Templates Engine  render "," options ","object format "," options merge "]}," YARD Server Commands Base cache":{"type":"method","name":"cache","children":[],"call":[" body= ","f write ","File  open "," log debug "," log ","FileUtils  mkdir_p ","File  dirname ","path sub ","File  join "," request path sub + "," request path sub "," request path "," request "," adapter document_root "," adapter "," caching "," request path_info sub + "," request path_info sub "," request path_info ","path sub  sub ","File  join  sub "," request path sub  sub + "," request File  join  sub + "," request path sub  sub "," request File  join  sub "," request path sub  "," request File  join  "," request path sub _info sub + "," request File  join _info sub + "," request path sub _info sub "," request File  join _info sub "," request path sub _info "," request File  join _info "]}," YARD Server Commands Base not_found":{"type":"method","name":"not_found","children":[],"call":[" headers []= "," headers "," body= "," request path "," request "," body empty? "," body "," headers delete "," status= "]}," YARD Server Commands Base run":{"type":"method","name":"run","children":[],"call":[" raise "]}," YARD Server Commands Base call":{"type":"method","name":"call","children":[],"call":[" body "," body is_a? "," headers "," status "," not_found "," status == "," status= "," body= ","e message ","e message != ","e class to_s ","e class "," run "," headers= ","request path [] ","request path "," path "," request= "," add_cache_control ","request path_info [] ","request path_info "]}," YARD Server Commands Base initialize":{"type":"method","name":"initialize","children":[],"call":[" command_options= "," send "," respond_to? ","opts each "]}," YARD Server Adapter start":{"type":"method","name":"start","children":[],"call":[" raise "]}," YARD Server Adapter add_library":{"type":"method","name":"add_library","children":[],"call":[" libraries [] ","library name "," libraries "]}," YARD Server Adapter initialize":{"type":"method","name":"initialize","children":[],"call":[" log debug "," document_root "," log "," options [] "," options "," libraries keys join "," libraries keys "," libraries "," class "," options []= "," router= ","(or\n  (send\n    (send nil :options) :[]\n    (sym :router))\n  (const nil :Router)) new "," document_root= "," server_options [] "," server_options "," server_options= "," options= "," libraries= "," class setup "]}," YARD Server Adapter shutdown":{"type":"method","name":"shutdown","children":[],"call":[]}," YARD Server Adapter setup":{"type":"method","name":"setup","children":[],"call":[]}," YARD Serializers FileSystemSerializer exists?":{"type":"method","name":"exists?","children":[],"call":["File  exist? ","File  join "," serialized_path "," basepath "]}," YARD Serializers Base exists?":{"type":"method","name":"exists?","children":[],"call":[]}," YARD Registry instance":{"type":"method","name":"instance","children":[],"call":[]}," YARD Registry each":{"type":"method","name":"each","children":[],"call":[" all each "," all "]}," YARD Legacy StatementList preprocess_token":{"type":"method","name":"preprocess_token","children":[],"call":["tk text ","tk is_a? "]}," YARD Legacy Statement show":{"type":"method","name":"show","children":[],"call":[" first_line "," line "]}," YARD Handlers Processor namespace_for_handler":{"type":"method","name":"namespace_for_handler","children":[],"call":[]}," YARD Handlers Processor register_handler_namespace":{"type":"method","name":"register_handler_namespace","children":[],"call":[" namespace_for_handler []= "," namespace_for_handler "]}," YARD Docstring +":{"type":"method","name":"+","children":[],"call":["Docstring  new "," object ","(send nil :all) join ","other all "," all "]}," Insertion after_any":{"type":"method","name":"after_any","children":[],"call":[" insertion "]}," Insertion before_any":{"type":"method","name":"before_any","children":[],"call":[" insertion "]}," CodeObjects MethodObject overridden_method":{"type":"method","name":"overridden_method","children":[],"call":["m scope == "," scope ","m scope ","m name == "," name ","m name ","m path != "," path ","m path ","meths find "," namespace meths "," namespace "," namespace is_a? "," namespace meths  find "," namespace  namespace meths  "]}," YARD CodeObjects Base docstring":{"type":"method","name":"docstring","children":[],"call":["value + ","@docstring docstring ","Docstring  new ","@docstring docstring + ","@docstring_extra ! ","@docstring add_tag "," translate_docstring ","Registry  locale ","@docstrings [] ","locale name ","locale is_a? ","@base_docstring resolve_reference ","locale nil? ","@docstring resolve_reference ","@docstring docstring +  docstring ","@docstring docstring +  docstring + ","@docstring docstring + _extra ! ","@docstring docstring +  add_tag ","@docstring docstring + s [] ","@docstring docstring +  resolve_reference "]}," YARD CodeObjects Base visibility":{"type":"method","name":"visibility","children":[],"call":[]}," YARD CLI YRI description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Yardoc tag_options":{"type":"method","name":"tag_options","children":[],"call":["tag to_sym ","Tags Library  transitive_tags ","opts on "," hidden_tags "," add_tag ","opts separator "]}," YARD CLI Yardoc output_options":{"type":"method","name":"output_options","children":[],"call":[" statistics= ","opts on "," options []= ","format to_sym "," options ","YARD Templates Engine  register_template_path ","template to_sym "," raise ","Encoding  default_internal= ","Encoding  default_external= ","markup_provider to_sym ","markup to_sym "," options [] basepath= "," options [] "," assets []= "," assets "," log warn "," log ","to =~ ","from =~ ","File  cleanpath ","asset split map ","asset split "," add_extra_files ","files split ","File  file? "," options [] add_expressions ","query taint "," visibilities push "," visibilities "," visibilities delete "," list= "," generate= ","opts separator ","YARD Config  options [] ","YARD Config  options "," has_markup= ","CodeObjects ExtraFileObject  new ","Encoding  respond_to? "," options format= ","File  expand_path "," options template= "," options markup_provider= "," options markup= "," options serializer basepath= "," options serializer "," options readme= "," options title= "," options verifier add_expressions "," options verifier "," options hide_void_return= "," options default_return= "," options highlight= "," options embed_mixins << "," options embed_mixins "," options onefile= "," apis push "," apis ","api == ","YARD Registry  po_dir= "," options locale= ","YARD Registry  po_dir "," hidden_apis push "," hidden_apis "," log show_progress= "," extra_file_valid? ","query respond_to? "]}," YARD CLI Yardoc general_options":{"type":"method","name":"general_options","children":[],"call":[" excluded << "," excluded ","opts on "," save_yardoc= "," use_document_file= "," use_yardopts_file= "," use_cache= ","YARD Registry  yardoc_file= "," generate= ","opts separator ","Registry  single_object_db= "," yardopts_options "," fail_on_warning= "]}," YARD CLI Yardoc add_tag":{"type":"method","name":"add_tag","children":[],"call":["tag to_sym ","Tags Library  visible_tags ","Tags Library  define_tag ","tag_data split ","tag capitalize "]}," YARD CLI Yardoc run_verifier":{"type":"method","name":"run_verifier","children":[],"call":[" options [] run "," options [] "," options "," options verifier run "," options verifier "]}," YARD CLI Yardoc copy_assets":{"type":"method","name":"copy_assets","children":[],"call":["FileUtils  cp_r "," log debug "," log ","File  join "," assets each "," assets "," options [] basepath "," options [] "," options ","File  directory? "," options serializer basepath "," options serializer ","File  direcFile  join ry? "]}," YARD CLI Yardoc run_generate":{"type":"method","name":"run_generate","children":[],"call":["Templates Engine  generate "," options "," log info ","object path "," log ","(send\n  (send\n    (lvar :object) :files) :any?) ! ","changed_files include? ","object files any? ","object files "," options [] exists? "," options [] "," options [] ! "," run_verifier reject "," run_verifier "," all_objects ","Registry  load_all "," use_cache ","changed_files << ","checksums [] != ","checksums [] ","Registry  checksums each ","Registry  checksums "," options serializer exists? "," options serializer "," options serializer ! "," log debug "]}," YARD CLI Yardoc description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Stats general_options":{"type":"method","name":"general_options","children":[],"call":[" options [] add_expressions ","query taint "," options [] "," options ","opts on "," visibilities push "," visibilities "," visibilities delete ","query respond_to? "]}," YARD CLI Stats optparse":{"type":"method","name":"optparse","children":[],"call":[" parse_files ","args empty? "," parse_options "," common_options "," tag_options "," output_options "," general_options ","opts separator ","opts banner= ","OptionParser  new ","OptionParser  new  separator ","OptionParser  new  banner= "]}," YARD CLI Stats type_statistics":{"type":"method","name":"type_statistics","children":[],"call":["undoc size ","objs size ","m docstring blank? ","m docstring ","objs find_all ","m type == ","m type "," all_objects select "," all_objects "]}," YARD CLI Stats output":{"type":"method","name":"output","children":[],"call":[" puts ","%-12s %s % ","name + ","% 5s % ","% 5s (% 5d undocumented) % ","undoc is_a? ","data is_a? ","%5s % ","%5s (% 5d undocumented) % "," log puts "," log ","% 5s %  is_a? ","%5s %  is_a? "]}," YARD CLI Stats stats_for_methods":{"type":"method","name":"stats_for_methods","children":[],"call":[" output ","undoc size ","objs size ","m overridden_method ! ","m overridden_method ","m docstring blank? ","m docstring ","objs select ","m is_explicit? ! ","m is_explicit? ","m is_alias? ","objs reject! ","m type == ","m type "," all_objects select "," all_objects ","m is_attribute? "]}," YARD CLI Stats stats_for_constants":{"type":"method","name":"stats_for_constants","children":[],"call":[" output "," type_statistics "]}," YARD CLI Stats stats_for_classes":{"type":"method","name":"stats_for_classes","children":[],"call":[" output "," type_statistics "]}," YARD CLI Stats stats_for_modules":{"type":"method","name":"stats_for_modules","children":[],"call":[" output "," type_statistics "]}," YARD CLI Stats stats_for_files":{"type":"method","name":"stats_for_files","children":[],"call":[" output ","files size ","o file "," all_objects each "," all_objects "]}," YARD CLI Stats all_objects":{"type":"method","name":"all_objects","children":[],"call":[" run_verifier ","Registry  all "]}," YARD CLI Stats print_undocumented_objects":{"type":"method","name":"print_undocumented_objects","children":[],"call":["object file "," puts ","object path ","object file != ","objects each ","(str \"%-\") % ","(send\n  (lvar :objects) :sort_by) last path length ","(send\n  (lvar :objects) :sort_by) last path ","(send\n  (lvar :objects) :sort_by) last ","o path length ","o path ","objects sort_by ","o file ","@undoc_list sort_by ","@undoc_list empty? ","@undoc_list ! ","(send\n  (lvar :object) :file) compact join ","(send\n  (lvar :object) :file) compact ","object line "," log puts "," log ","(or\n  (send\n    (lvar :object) :file)\n  (str \"-unknown-\")) compact join ","(or\n  (send\n    (lvar :object) :file)\n  (str \"-unknown-\")) compact ","o file to_s ","(send\n  (lvar :objects) :max) path length ","(send\n  (lvar :objects) :max) path ","a path length <=> ","b path length ","b path ","a path length ","a path ","objects max ","(send\n  (lvar :objects) :(send\n  (lvar :objects) :sort_by) last path length ) path length ","(send\n  (lvar :objects) :(send\n  (lvar :objects) :max) path length ) path length ","(send\n  (lvar :objects) :(send\n  (lvar :objects) :sort_by) last path length ) path ","(send\n  (lvar :objects) :(send\n  (lvar :objects) :max) path length ) path ","objects (send\n  (lvar :objects) :sort_by) last path length  ","objects (send\n  (lvar :objects) :max) path length  "]}," YARD CLI Stats print_statistics":{"type":"method","name":"print_statistics","children":[],"call":[" puts ","% 3.2f%% documented % ","(send\n  (ivar :@total) :-\n  (ivar :@undocumented)) to_f / * ","(send\n  (ivar :@total) :-\n  (ivar :@undocumented)) to_f / ","@total to_f ","(send\n  (ivar :@total) :-\n  (ivar :@undocumented)) to_f ","@total - "," send ","meths each ","meths delete ","meths include? ","STATS_ORDER  each ","(send\n  (send nil :methods) :map) grep ","m to_s "," methods map "," methods ","@total == "," log puts "," log ","@undocumented == "," methods map grep ","(send\n  (ivar :@(send\n  (ivar :@total) :-\n  (ivar :@undocumented)) to_f / * ) :-\n  (ivar :@undocumented)) to_f / * ","(send\n  (ivar :@(send\n  (ivar :@total) :-\n  (ivar :@undocumented)) to_f / * ) :-\n  (ivar :@undocumented)) to_f / ","@(send\n  (ivar :@total) :-\n  (ivar :@undocumented)) to_f / *  to_f ","(send\n  (ivar :@(send\n  (ivar :@total) :-\n  (ivar :@undocumented)) to_f / * ) :-\n  (ivar :@undocumented)) to_f ","@(send\n  (ivar :@total) :-\n  (ivar :@undocumented)) to_f / *  - ","(send\n  (send nil :methods) :map) grep  each "," methods map grep  each ","(send\n  (send nil :methods) :map) grep  delete "," methods map grep  delete ","(send\n  (send nil :methods) :map) grep  include? "," methods map grep  include? ","@(send\n  (ivar :@total) :-\n  (ivar :@undocumented)) to_f / *  == "]}," YARD CLI Stats run":{"type":"method","name":"run","children":[],"call":[" print_undocumented_objects "," print_statistics ","Registry  save "," use_cache "," save_yardoc ","YARD  parse "," excluded "," files ","Registry  checksums dup ","Registry  checksums ","Registry  load! "," parse "," parse_arguments "," abort "," log warned "," log "," fail_on_warning ","Registry  Registry  checksums dup  dup ","Registry  Registry  checksums dup  "]}," YARD CLI Stats description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Stats initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD CLI Server optparse":{"type":"method","name":"optparse","children":[],"call":[" options []= "," options "," libraries size > "," libraries size "," libraries "," add_libraries ","File  basename ","Dir  pwd ","Yardoc  run "," log info "," log "," log enter_level ","File  exist? ! ","File  exist? "," libraries empty? ","args empty? "," parse_options "," common_options "," server_options []= "," server_options ","opts on "," adapter= "," eval ","adapter downcase == ","adapter downcase ","File  expand_path ","port to_i ","opts separator "," add_gems "," exit "," log error "," require ! "," require ","file gsub ","opts banner= ","OptionParser  new "," scripts << "," scripts "," template_paths << "," template_paths "," add_gems_from_gemfile "," generate_doc_for_first_time ","libver yardoc_file "," libraries values first first "," libraries values first "," libraries values ","host to_s ","libver ready? ! ","libver ready? ","adapter casecmp == ","adapter casecmp ","OptionParser  new  on ","OptionParser  new  separator ","OptionParser  new  banner= "," libraries values first first  yardoc_file "," libraries values first first  ready? ! "," libraries values first first  ready? "]}," YARD CLI Server add_gems":{"type":"method","name":"add_gems","children":[],"call":[" libraries [] << ","YARD Server LibraryVersion  new ","spec version to_s ","spec version ","spec name "," libraries [] "," libraries ","Gem  source_index find_name each ","Gem  source_index find_name ","Gem  source_index "," require ","YARD GemIndex  each ","YARD GemIndex  find_all_by_name each ","YARD GemIndex  find_all_by_name "]}," YARD CLI Server add_libraries":{"type":"method","name":"add_libraries","children":[],"call":[" log warn "," log "," libraries [] << ","YARD Server LibraryVersion  new "," libraries [] "," libraries ","File  exist? ","args [] ","index + ","(erange\n  (int 0)\n  (send\n    (lvar :args) :size)) step ","args size ","File  expand_path ","dir inspect ","libver source_path= ","libver source_path ","libver yardoc_file= ","libver yardoc_file ","File  join "," create_library_version_if_yardopts_exist ","Dir  pwd ","args []  inspect "," create_library_version_if_yardopts_exist  source_path= "," create_library_version_if_yardopts_exist  source_path ","libver File  expand_path _file= "," create_library_version_if_yardopts_exist  yardoc_file= ","libver File  expand_path _file "," create_library_version_if_yardopts_exist  yardoc_file "," create_args [] _version_if_yardopts_exist ","Dir  Dir  pwd  "]}," YARD CLI Server select_adapter":{"type":"method","name":"select_adapter","children":[],"call":[" adapter= "," require "," adapter "]}," YARD CLI Server run":{"type":"method","name":"run","children":[],"call":[" adapter new start "," adapter new "," server_options "," options "," libraries "," adapter "," select_adapter "," optparse "," server_options= "," options= ","SymbolHash  new update ","SymbolHash  new "," libraries= "," load_template_paths "," load_scripts "," select_adapter setup "," template_paths= "," scripts= "]}," YARD CLI Server description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Help run":{"type":"method","name":"run","children":[],"call":["CommandParser  run "," puts ","args first ","cmd run ","CommandParser  commands [] ","args first to_sym ","CommandParser  commands "," log puts "," log ","CommandParser  commands []  run "]}," YARD CLI Help description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Graph optparse":{"type":"method","name":"optparse","children":[],"call":["Registry  root ","(send\n  (lvar :args) :map) compact ","Registry  at ","args map ","args first ","Verifier  new ","visibilities uniq inspect ","visibilities uniq "," parse_options "," common_options ","@serializer instance_eval ","file inspect ","Serializers FileSystemSerializer  new ","opts on ","Serializers ProcessSerializer  new ","dot  + ","dotopts to_s ","opts separator ","visibilities push ","visibilities delete "," options []= "," options ","YARD Registry  yardoc_file= ","OptionParser  new "," options verifier= "," options serializer instance_eval "," options serializer "," options serializer= ","Registry  load ","Serializers FileSystemSerializer  new  instance_eval ","Serializers ProcessSerializer  new  instance_eval ","OptionParser  new  on ","dotOptionParser  new  to_s ","OptionParser  new  separator "]}," YARD CLI Graph run":{"type":"method","name":"run","children":[],"call":["Templates Engine  render ","(send\n  (send nil :objects) :map) join ","o format "," options "," objects map "," objects "," optparse ","Registry  load "," options update "," options merge "," parse_arguments "]}," YARD CLI Graph description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Graph initialize":{"type":"method","name":"initialize","children":[],"call":["SymbolHash  [] ","YARD Serializers StdoutSerializer  new "," options serializer= "," options "," options reset_defaults ","GraphOptions  new "]}," YARD CLI Gems optparse":{"type":"method","name":"optparse","children":[],"call":[" add_gems "," parse_options "," common_options ","YARD Parser SourceParser  parser_type= ","opts on ","opts separator "," description ","opts banner= ","OptionParser  new ","Gem  source_index find_name ","Gem  source_index ","@gems empty? "," log error "," log ","args empty? ! ","args empty? ","YARD GemIndex  all ","YARD GemIndex  find_all_by_name ","OptionParser  new  on ","OptionParser  new  separator ","OptionParser  new  banner= "]}," YARD CLI Gems add_gems":{"type":"method","name":"add_gems","children":[],"call":["specs empty? ","Gem  source_index find_name ","Gem  source_index ","gems each_slice "," log warn "," log ","gems [] ","index + ","0 step ","gems size - ","gems size ","YARD GemIndex  find_all_by_name ","Gem  source_index find_name  empty? ","YARD GemIndex  find_all_by_name  empty? ","gems [] s each_slice ","gems [] s [] ","gems [] s size - ","gems [] s size "]}," YARD CLI Gems build_gems":{"type":"method","name":"build_gems","children":[],"call":["Yardoc  run "," log info ","spec full_name "," log ","Dir  chdir ","spec full_gem_path ","Registry  clear ","File  directory? ","Registry  yardoc_file_for_gem ","spec name "," log debug ","@rebuild ! ","spec version ","@gems each "," require ","Dir  chRegistry  yardoc_file_for_gem  ","File  Registry  yardoc_file_for_gem ectory? "]}," YARD CLI Gems run":{"type":"method","name":"run","children":[],"call":[" build_gems ","Gem  source_index find_name ","Gem  source_index ","@gems empty? "," optparse "," require "]}," YARD CLI Gems description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Gems initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD CLI Diff optparse":{"type":"method","name":"optparse","children":[],"call":[" exit "," puts ","opts banner ","args size == ","args size "," parse_options "," common_options ","opts on ","opts separator ","opts banner= ","OptionParser  new "," log puts "," log ","@verifier add_expressions ","OptionParser  new  banner ","OptionParser  new  on ","OptionParser  new  separator ","OptionParser  new  banner= "]}," YARD CLI Diff cleanup":{"type":"method","name":"cleanup","children":[],"call":["FileUtils  rm_rf "," log info "," log ","File  join ","Dir  tmpdir ","Dir  tmpFile  join  "]}," YARD CLI Diff require_rubygems":{"type":"method","name":"require_rubygems","children":[],"call":[" raise "," log error "," log "," require "]}," YARD CLI Diff expand_gem":{"type":"method","name":"expand_gem","children":[],"call":["pkg extract_entry ","pkg each ","Gem Package  open ","FileUtils  mkdir_p "," log info "," log ","File  join ","Dir  tmpdir ","Gem Package  send ","out fsync ","out write ","entry read ","File  open ","File  dirname ","entry full_name ","entry header mode ","entry header ","tar each ","Gem Package TarReader  new ","Zlib GzipReader  wrap ","pkg full_name == ","pkg full_name ","reader each "," require ","Gem VERSION  >= ","Dir  File  join  ","entry header entry header mode  ","Gem Package TarReader  new  each "]}," YARD CLI Diff generate_yardoc":{"type":"method","name":"generate_yardoc","children":[],"call":["Dir  chdir ","Yardoc  run "," log enter_level "," log ","Dir  pwd "]}," YARD CLI Diff expand_and_parse":{"type":"method","name":"expand_and_parse","children":[],"call":[" cleanup "," generate_yardoc "," expand_gem "]}," YARD CLI Diff load_gem_data":{"type":"method","name":"load_gem_data","children":[],"call":[" expand_and_parse "," open "," log info "," log ","File  open ","File  exist? ","gemfile =~ ","Dir  chdir ","Gems  run ","spec version to_s ","spec version ","spec name ","Dir  pwd "," log enter_level ","Registry  load_all ","Registry  load_yardoc ","Registry  yardoc_file_for_gem ","spec full_name == ","spec full_name ","Gem  source_index find_name find ","Gem  source_index find_name ","Gem  source_index ","gemfile sub ","File  directory? ","(send\n  (const nil :File) :join\n  (lvar :gemfile)\n  (str \".yardoc\")) each ","File  join ","Registry  clear "," require_rubygems ","YARD GemIndex  each find ","YARD GemIndex  each ","OpenURI  open_uri ","YARD GemIndex  find_all_by_name find ","YARD GemIndex  find_all_by_name ","Registry  load_Registry  yardoc_file_for_gem  ","Registry  Registry  yardoc_file_for_gem _file_for_gem ","(send\n  (const nil :File) :join\n  (lvar :gemfile)\n  (str \".Registry  yardoc_file_for_gem \")) each "]}," YARD CLI Diff run":{"type":"method","name":"run","children":[],"call":[" puts "," print ","   + ","object =~ ","Regexp  quote ","@list_all ! ","objects sort each ","objects sort ","name + ","objects empty? ","(array\n  (str \"Added objects\")\n  (send\n    (send\n      (lvar :registry) :[]\n      (int 1)) :-\n    (send\n      (lvar :registry) :[]\n      (int 0)))) each ","registry [] - ","registry [] ","registry size != ","registry size ","(send\n  (send nil :optparse\n    (splat\n      (lvar :args))) :map) compact "," log error "," log ","o path ","Registry  all map ","Registry  all "," log info "," load_gem_data "," optparse map "," optparse "," load_git_commit "," log puts "," log print "," + + + ","object line ","object file "," + + ","object path "," + ","object parent == ","object parent ","(send\n  (lvar :objects) :sort_by) each ","objects sort_by ","@modified == ","short == ","(array\n  (str \"Added objects\")\n  (str \"A\")\n  (send nil :added_objects\n    (splat\n      (lvar :registry)))) each "," removed_objects "," modified_objects "," added_objects "," all_objects ","objects sort_by each ","(array\n  (str \"Added objects\")\n  (send\n    (send\n      (lvar :(send\n  (send nil :optparse\n    (splat\n      (lvar :args))) :map) compact ) :[]\n      (int 1)) :-\n    (send\n      (lvar :(send\n  (send nil :optparse\n    (splat\n      (lvar :args))) :map) compact ) :[]\n      (int 0)))) each ","(send\n  (send nil :optparse\n    (splat\n      (lvar :args))) :map) compact  [] - ","(send\n  (send nil :optparse\n    (splat\n      (lvar :args))) :map) compact  [] ","(send\n  (send nil :optparse\n    (splat\n      (lvar :args))) :map) compact  size != ","(send\n  (send nil :optparse\n    (splat\n      (lvar :args))) :map) compact  size ","(array\n  (str \"Added objects\")\n  (str \"A\")\n  (send nil :added_objects\n    (splat\n      (lvar :(send\n  (send nil :optparse\n    (splat\n      (lvar :args))) :map) compact )))) each "]}," YARD CLI Diff description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Diff initialize":{"type":"method","name":"initialize","children":[],"call":[" log show_backtraces= "," log "," require_rubygems ","Dir  pwd ","Verifier  new "]}," YARD CLI CommandParser list_commands":{"type":"method","name":"list_commands","children":[],"call":[" puts ","%-8s %s % ","command description "," commands [] new "," commands [] "," commands ","(send\n  (send\n    (send nil :commands) :keys) :sort_by) each ","k to_s "," commands keys sort_by "," commands keys "," log puts "," log "," commands keys sort_by each "," commands [] new  description ","  commands [] new s [] new ","  commands [] new s [] ","  commands [] new s ","(send\n  (send\n    (send nil : commands [] new s) :keys) :sort_by) each ","  commands [] new s keys sort_by ","  commands [] new s keys ","  commands [] new s keys sort_by each "]}," YARD CLI CommandParser commands":{"type":"method","name":"commands","children":[],"call":[" class commands "," class "]}," YARD CLI CommandParser run":{"type":"method","name":"run","children":[],"call":[" list_commands "," commands [] run "," commands [] "," commands "," commands has_key? ","args shift ","args first to_sym ","args first "," class default_command "," class ","args first =~ ","args size == ","args size ","args == "," commands key? ","args empty? "]}," YARD CLI CommandParser initialize":{"type":"method","name":"initialize","children":[],"call":[" log show_backtraces= "," log "]}," YARD CLI Command parse_options":{"type":"method","name":"parse_options","children":[],"call":[" log warn ","e message "," log ","opts parse! ","args shift ","args first [] != ","args first [] ","args first ","err message "," unrecognized_option "]}," YARD CLI Command common_options":{"type":"method","name":"common_options","children":[],"call":[" exit "," puts ","opts on_tail "," log show_backtraces= "," log "," log level= ","YARD Parser SourceParser  parser_type= ","opts on "," log error "," require ","file gsub ","opts separator "," load_script "," log puts "]}," YARD CLI Command description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Command run":{"type":"method","name":"run","children":[],"call":[]}," YARD Server RackAdapter print_start_message":{"type":"method","name":"print_start_message","children":[],"call":[" puts ","opts [] ","server server class_name ","server server ","server server to_s == ","server server to_s ","server default_options merge ","server options ","server default_options "," log puts "," log ","server default_options merge  [] "]}," YARD CodeObjects Proxy name":{"type":"method","name":"name","children":[],"call":["(if\n  (ivar :@imethod)\n  (const nil :ISEP)\n  (str \"\")) + ","@name to_s "]}," YARD Server register_static_path":{"type":"method","name":"register_static_path","children":[],"call":[]}," YARD Parser CParser find_override_comment":{"type":"method","name":"find_override_comment","children":[],"call":["content =~ ","object parent path ","object parent ","Regexp  escape ","object name to_s ","object name ","name == ","object Regexp  escape  to_s ","object Regexp  escape  ","Regexp  escape  == "]}," StructHandlerMethods members_from_tags":{"type":"method","name":"members_from_tags","children":[],"call":["(send\n  (lvar :tags) :map) uniq ","t name ","tags map ","klass tags + + ","klass tags ","klass tags + ","tags map uniq ","(send\n  (lvar :klass tags + + ) :map) uniq ","klass tags + +  map ","klass klass tags + +  + + ","klass klass tags + +  ","klass klass tags + +  + ","klass tags + +  map uniq "]}," ConstantHandler extract_parameters":{"type":"method","name":"extract_parameters","children":[],"call":["m to_s ","members map "," tokval_list ","YARD Parser Ruby Legacy TokenList  new ","x source strip [] ","x source strip ","x source ","members map! ","x type == ","x type ","superclass parameters select ","superclass parameters "," tokval_list  map "," tokval_list  map! "]}," YARD Handlers Base matches_file?":{"type":"method","name":"matches_file?","children":[],"call":["filename =~ ","File  basename == ","File  basename ","@in_files any? "]}," YARD Handlers Base in_file":{"type":"method","name":"in_file","children":[],"call":["(or-asgn\n  (ivasgn :@in_files)\n  (array)) << "]}," YARD Config arguments":{"type":"method","name":"arguments","children":[],"call":[]}," YARD Config with_yardopts":{"type":"method","name":"with_yardopts","children":[],"call":[]}," YARD Config translate_plugin_name":{"type":"method","name":"translate_plugin_name","children":[],"call":[]}," YARD Config read_config_file":{"type":"method","name":"read_config_file","children":[],"call":[]}," YARD Config translate_plugin_names":{"type":"method","name":"translate_plugin_names","children":[],"call":[]}," YARD Config add_ignored_plugins_file":{"type":"method","name":"add_ignored_plugins_file","children":[],"call":[]}," YARD Config load_plugin_failed":{"type":"method","name":"load_plugin_failed","children":[],"call":[]}," YARD Config load_commandline_plugins":{"type":"method","name":"load_commandline_plugins","children":[],"call":[]}," YARD Config load_autoload_plugins":{"type":"method","name":"load_autoload_plugins","children":[],"call":[]}," YARD Config load_gem_plugins":{"type":"method","name":"load_gem_plugins","children":[],"call":[]}," YARD Config load_plugin":{"type":"method","name":"load_plugin","children":[],"call":[]}," YARD Config load_plugins":{"type":"method","name":"load_plugins","children":[],"call":[]}," YARD Config save":{"type":"method","name":"save","children":[],"call":[]}," YARD Config load":{"type":"method","name":"load","children":[],"call":[]}," YARD CLI Yardoc verify_markup_options":{"type":"method","name":"verify_markup_options","children":[],"call":["obj load_markup_provider ","obj extend ","Struct  new new "," options ","Struct  new "," options []= "," log warn ","Could not load default RDoc formatter,  + "," log ","has_markup ! ","result ! "," log enter_level "," log level "," options [] "," has_markup ! "," has_markup ","markup != ","obj markup_for_file ","file filename ","file attributes [] ","file attributes "," options [] each "," options markup= "," options files each "," options files ","Struct  new new  load_markup_provider ","Struct  new new  extend ","obj load_markup_provider  ! ","Struct  new new  markup_for_file "]}," YARD CLI Server load_template_paths":{"type":"method","name":"load_template_paths","children":[],"call":[" template_paths ","Templates Engine  template_paths ","YARD Config  options [] ","YARD Config  options "]}," YARD CLI Server load_scripts":{"type":"method","name":"load_scripts","children":[],"call":[" load_script "," scripts each "," scripts "]}," YARD CLI Config optparse":{"type":"method","name":"optparse","children":[],"call":[" values= ","args size >= ","args size "," key= ","args shift to_sym ","args shift "," parse_options "," common_options "," reset= ","opts on ","opts separator ","opts banner= ","OptionParser  new "," as_list= "," append= "," gem_install_cmd= "," gem_install_cmd != "," gem_install_cmd ","OptionParser  new  on ","OptionParser  new  separator ","OptionParser  new  banner= "]}," YARD CLI Config encode_value":{"type":"method","name":"encode_value","children":[],"call":["value to_i "]}," YARD CLI Config encode_values":{"type":"method","name":"encode_values","children":[],"call":[" encode_value "," values map "," values "," values first "," values size == "," values size "," as_list ! "," as_list "]}," YARD CLI Config list_configuration":{"type":"method","name":"list_configuration","children":[],"call":[" puts ","YAML  dump sub gsub ","YAML  dump sub ","YAML  dump ","YARD Config  options "," require "," log debug "," log "," log puts "]}," YARD CLI Config view_item":{"type":"method","name":"view_item","children":[],"call":[" puts ","YARD Config  options [] inspect ","YARD Config  options [] "," key ","YARD Config  options "," log debug "," log "," log puts "]}," YARD CLI Config modify_item":{"type":"method","name":"modify_item","children":[],"call":["YARD Config  save ","YARD Config  options []= "," encode_values "," key ","YARD Config  options "," log debug "," values inspect "," values "," log ","YARD Config DEFAULT_CONFIG_OPTIONS  [] "," reset ","(lvar :current_items) flatten + ","(lvar :items) flatten ","(lvar :current_items) flatten "," append ","YARD Config  options [] ","(lvar :current_(lvar :current_items) flatten + ) flatten + ","(lvar :current_ encode_values ) flatten + ","(lvar :YARD Config  options [] ) flatten + ","(lvar :(lvar :current_items) flatten + ) flatten ","(lvar : encode_values ) flatten ","(lvar :current_(lvar :current_items) flatten + ) flatten ","(lvar :current_ encode_values ) flatten ","(lvar :YARD Config  options [] ) flatten "]}," YARD CLI Config run":{"type":"method","name":"run","children":[],"call":[" list_configuration "," view_item "," modify_item "," values size > "," values size "," values "," reset "," key "," optparse "," values empty? ! "," values empty? "," configure_gemrc "," gem_install_cmd "]}," YARD CLI Config description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Config initialize":{"type":"method","name":"initialize","children":[],"call":[" reset= "," values= "," key= "," as_list= "," append= "," gem_install_cmd= "]}," YARD CLI Command load_script":{"type":"method","name":"load_script","children":[],"call":[" exit "," log error "," log "," require ","file gsub ","YARD Config  options [] ","YARD Config  options "," load "]}," YARD Helpers MarkupHelper clear_markup_cache":{"type":"method","name":"clear_markup_cache","children":[],"call":[" markup_cache= "]}," YARD Parser Ruby RipperParser on_const_path_ref":{"type":"method","name":"on_const_path_ref","children":[],"call":["klass new "," charno "," lineno ","AstNode  node_class_for ","ReferenceNode  new ","AstNode  node_class_for  new "]}," YARD Parser Ruby RipperParser on_top_const_ref":{"type":"method","name":"on_top_const_ref","children":[],"call":["mapping push ","node line_range= ","Range  new ","args last line_range last ","args last line_range ","args last ","node source_range= ","args last source_range last ","args last source_range ","mapping pop ","mapping last [] + == "," charno ","mapping last [] + ","mapping last [] ","mapping last ","@map [] ","MAPPINGS  [] ","AstNode  node_class_for new ","AstNode  node_class_for ","@map []  push ","AstNode  node_class_for new  line_range= ","AstNode  node_class_for new  source_range= ","@map []  pop ","@map []  last [] + == ","@map []  last [] + ","@map []  last [] ","@map []  last ","AstNode  AstNode  node_class_for new _class_for new ","AstNode  AstNode  node_class_for new _class_for "]}," YARD Templates Helpers HtmlSyntaxHighlightHelper html_syntax_highlight_ruby_legacy":{"type":"method","name":"html_syntax_highlight_ruby_legacy","children":[],"call":["(send\n  (lvar :tokenlist) :map) join "," h ","s text ","s class superclass class_name sub downcase ","s class superclass class_name sub ","s class superclass class_name ","s class superclass ","s class ","s class class_name sub downcase ","s class class_name sub ","s class class_name ","tokenlist map ","Parser Ruby Legacy TokenList  new ","(send\n  (lvar :Parser Ruby Legacy TokenList  new ) :map) join ","Parser Ruby Legacy TokenList  new  map "]}," YARD Templates Helpers HtmlSyntaxHighlightHelper html_syntax_highlight_ruby_ripper":{"type":"method","name":"html_syntax_highlight_ruby_ripper","children":[],"call":[" h ","output << ","(sym :tstring_end) include? ","s [] ","s last ","s first ","(sym :tstring_beg) include? ","tokenlist each ","Parser Ruby RubyParser  parse tokens ","Parser Ruby RubyParser  parse "," raise ","source empty? ! ","source empty? ","tokenlist empty? "," link_object ","s first == "," clean_token_object ","resolver each ","String  new ","Parser Ruby TokenResolver  new "," object ","source =~ ","String  new  << ","Parser Ruby RubyParser  parse tokens  each ","Parser Ruby RubyParser  parse tokens  empty? "," clean_ clean_token_object ect ","Parser Ruby TokenResolver  new  each "]}," YARD Helpers HtmlHelper simple_markup_html":{"type":"method","name":"simple_markup_html","children":[],"call":["SM ToHtml  new ","RDoc Markup ToHtml  new ","Thread  current [] ","Thread  current "," require "]}," Helpers BaseHelper link_include_file":{"type":"method","name":"link_include_file","children":[],"call":["File  read "]}," YARD Registry thread_local_store=":{"type":"method","name":"thread_local_store=","children":[],"call":["Thread  current []= ","Thread  current "]}," YARD Registry thread_local_store":{"type":"method","name":"thread_local_store","children":[],"call":[" clear ","Thread  current [] ","Thread  current "]}," YARD Registry single_object_db":{"type":"method","name":"single_object_db","children":[],"call":["Thread  current [] ","Thread  current "]}," YARD Registry single_object_db=":{"type":"method","name":"single_object_db=","children":[],"call":["Thread  current []= ","Thread  current "]}," YARD Registry yardoc_file":{"type":"method","name":"yardoc_file","children":[],"call":["Thread  current [] ","Thread  current "]}," YARD Registry yardoc_file=":{"type":"method","name":"yardoc_file=","children":[],"call":["Thread  current []= ","Thread  current "]}," YARD Parser Ruby RubyParser encoding_line":{"type":"method","name":"encoding_line","children":[],"call":["@parser encoding_line "]}," YARD Parser Ruby RubyParser shebang_line":{"type":"method","name":"shebang_line","children":[],"call":["@parser shebang_line "]}," YARD Parser Ruby Legacy RubyParser shebang_line":{"type":"method","name":"shebang_line","children":[],"call":["@parse shebang_line "]}," YARD Parser Ruby Legacy RubyParser encoding_line":{"type":"method","name":"encoding_line","children":[],"call":["@parse encoding_line "]}," YARD Parser Ruby KeywordNode kw?":{"type":"method","name":"kw?","children":[],"call":[]}," YARD Parser Ruby LiteralNode literal?":{"type":"method","name":"literal?","children":[],"call":[]}," PrivateConstantHandler privatize_constant":{"type":"method","name":"privatize_constant","children":[],"call":[" raise ","node [] ","node source ","const visibility= "," ensure_loaded! ","Proxy  new "," namespace ","node jump ","node [] type == ","node [] type ","node type == ","node type ","node literal? ","node jump  [] ","node jump  source ","Proxy  new  visibility= ","node jump  jump ","node jump  [] type == ","node jump  [] type ","node jump  type == ","node jump  type ","node jump  literal? "]}," YARD Docstring hash_flag=":{"type":"method","name":"hash_flag=","children":[],"call":["v == ","v nil? "]}," YARD CodeObjects Base visibility=":{"type":"method","name":"visibility=","children":[],"call":["v to_sym "]}," YARD Templates Helpers Markup RDocMarkupToHtml accept_paragraph":{"type":"method","name":"accept_paragraph","children":[],"call":["(send\n  (send\n    (lvar :par) :text) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ! ","(send\n  (send\n    (lvar :par) :text) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ","par text =~ ","par text ","(send\n  (lvar :text) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ! ","(send\n  (lvar :text) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ","text =~ ","par txt ","par respond_to? ","args last ","(send\n  (send\n    (lvar :par) :par text ) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ! ","(send\n  (send\n    (lvar :par) :par txt ) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ! ","(send\n  (send\n    (lvar :args last ) :text) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ! ","(send\n  (send\n    (lvar :par) :par text ) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ","(send\n  (send\n    (lvar :par) :par txt ) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ","(send\n  (send\n    (lvar :args last ) :text) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ","par par text  =~ ","par par txt  =~ ","args last  text =~ ","par par text  ","par par txt  ","args last  text ","(send\n  (lvar :par text ) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ! ","(send\n  (lvar :par txt ) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ! ","(send\n  (lvar :par text ) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ","(send\n  (lvar :par txt ) :=~\n  (regexp\n    (str \"\\\\{(https?:|mailto:|link:|www\\\\.)\")\n    (regopt))) ! ","par text  =~ ","par txt  =~ ","args last  txt ","args last  respond_to? "]}," YARD Templates Helpers Markup RDocMarkupToHtml handle_special_HYPERLINK":{"type":"method","name":"handle_special_HYPERLINK","children":[],"call":["special text "]}," YARD Templates Helpers Markup RDocMarkup fix_dash_dash":{"type":"method","name":"fix_dash_dash","children":[],"call":["text gsub "]}," YARD Templates Helpers Markup RDocMarkup fix_typewriter":{"type":"method","name":"fix_typewriter","children":[],"call":["first_text + + + ","first_text + + ","CGI  escapeHTML ","first_text + ","pre_match last [] == ","pre_match last [] ","pre_match last ","pre_match last nil? ","(send\n  (lvar :pre_text) :+\n  (lvar :first_text)) scan ","pre_text + ","text gsub ","code_tags == ","(send\n  (lvar :pre_text) :+\n  (lvar :first_text)) scan  last [] == ","(send\n  (lvar :pre_text) :+\n  (lvar :first_text)) scan  last [] ","(send\n  (lvar :pre_text) :+\n  (lvar :first_text)) scan  last ","(send\n  (lvar :pre_text) :+\n  (lvar :first_text)) scan  last nil? "]}," YARD Templates Helpers Markup RDocMarkup to_html":{"type":"method","name":"to_html","children":[],"call":[" fix_typewriter "," fix_dash_dash ","@markup convert ","formatter from_path= "," from_path ","RDocMarkupToHtml  new ","@@markup convert ","@@formatter from_path= ","@@mutex synchronize ","RDocMarkupToHtml  new  from_path= ","@@RDocMarkupToHtml  new  from_path= "]}," YARD Templates Helpers Markup RDocMarkup initialize":{"type":"method","name":"initialize","children":[],"call":["MARKUP  new ","Mutex  new ","RDocMarkupToHtml  new ","@@mutex synchronize "]}," YARD Helpers HtmlHelper html_markup_none":{"type":"method","name":"html_markup_none","children":[],"call":[" h gsub "," h "]}," Specification _dump_with_rdoc":{"type":"method","name":"_dump_with_rdoc","children":[],"call":["dmp []= "," _dump_without_rdoc ","dmp [] == ","dmp [] "," _dump_without_rdoc  []= "," _dump_without_rdoc  [] == "," _dump_without_rdoc  [] "]}," YARD Logger show_backtraces":{"type":"method","name":"show_backtraces","children":[],"call":[" level == "," level "]}," YARD Helpers HtmlHelper link_include_file":{"type":"method","name":"link_include_file","children":[],"call":[" htmlify "," options [] "," options ","file attributes [] ","file attributes ","file contents "," markup_for_file ","file filename ","CodeObjects ExtraFileObject  new ","file is_a? "," options markup "," insert_include ","CodeObjects ExtraFileObject  new  attributes [] ","CodeObjects ExtraFileObject  new  attributes ","CodeObjects ExtraFileObject  new  contents "," markup_for_CodeObjects ExtraFileObject  new  ","CodeObjects ExtraFileObject  new  CodeObjects ExtraFileObject  new name ","CodeObjects ExtraFileObject  new  is_a? "]}," YARD Helpers HtmlHelper html_markup_ruby":{"type":"method","name":"html_markup_ruby","children":[],"call":["<pre class=\"code\"> + + ","<pre class=\"code\"> + "," html_syntax_highlight ","<pre class=\"code ruby\"> + + ","<pre class=\"code ruby\"> + "]}," asset":{"type":"method","name":"asset","children":[],"call":[]}," stylesheets":{"type":"method","name":"stylesheets","children":[],"call":[" + "]}," javascripts":{"type":"method","name":"javascripts","children":[],"call":[" + "]}," SourceIndex dump":{"type":"method","name":"dump","children":[],"call":["Marshal  dump "]}," SourceIndex ==":{"type":"method","name":"==","children":[],"call":["@gems == ","other gems "," class === "," class "]}," SourceIndex outdated":{"type":"method","name":"outdated","children":[],"call":["outdateds << ","local name ","local version < ","local version ","remotes sort last ","remotes sort ","remotes map ","fetcher find_matching ","Gem SpecFetcher  fetcher ","Gem Dependency  new "," latest_specs each "," latest_specs ","fetcher find_matching  sort last ","fetcher find_matching  sort ","fetcher find_matching  map ","Gem SpecFetcher  fetcher  find_matching ","Gem SpecFetcher  Gem SpecFetcher  fetcher  "," remotes sort last _specs each "," remotes sort last _specs "]}," SourceIndex refresh!":{"type":"method","name":"refresh!","children":[],"call":[" load_gems_in "," raise ","@spec_dirs nil? "]}," SourceIndex search":{"type":"method","name":"search","children":[],"call":["s sort_obj ","specs sort_by ","Gem Platform  match ","spec platform ","specs select ","requirement satisfied_by? ","spec version ","spec name =~ ","spec name "," all_gems values select "," all_gems values "," all_gems ","Gem Requirement  create ","Gem Requirement  === ","Gem Requirement  default ","Regexp  escape ","gem_pattern name ","gem_pattern name empty? ","Regexp  === ","gem_pattern requirement "," warn ","gem_pattern class ","Gem  location_of_caller join ","Gem  location_of_caller ","Gem Dependency  === ","Gem Requirement  create  satisfied_by? ","gem_pattern requirement  satisfied_by? ","gem_pattern name  name ","gem_pattern name  name empty? ","gem_pattern Gem Requirement  create  ","gem_pattern gem_pattern requirement  ","gem_pattern name  requirement ","gem_pattern name  class "]}," SourceIndex find_name":{"type":"method","name":"find_name","children":[],"call":[" search ","Gem Dependency  new "]}," SourceIndex size":{"type":"method","name":"size","children":[],"call":["@gems size "]}," SourceIndex gem_signature":{"type":"method","name":"gem_signature","children":[],"call":["Digest SHA256  new hexdigest to_s ","Digest SHA256  new hexdigest ","@gems [] to_yaml ","@gems [] ","Digest SHA256  new "," require "]}," SourceIndex index_signature":{"type":"method","name":"index_signature","children":[],"call":["Digest SHA256  new hexdigest to_s ","Digest SHA256  new hexdigest ","@gems keys sort join ","@gems keys sort ","@gems keys ","Digest SHA256  new "," require "]}," SourceIndex specification":{"type":"method","name":"specification","children":[],"call":["@gems [] "]}," SourceIndex each":{"type":"method","name":"each","children":[],"call":["@gems each "]}," SourceIndex remove_spec":{"type":"method","name":"remove_spec","children":[],"call":["@gems delete "]}," SourceIndex add_specs":{"type":"method","name":"add_specs","children":[],"call":[" add_spec ","gem_specs each "]}," SourceIndex add_spec":{"type":"method","name":"add_spec","children":[],"call":["@gems []= "]}," SourceIndex released_specs":{"type":"method","name":"released_specs","children":[],"call":[" released_gems values "," released_gems "]}," SourceIndex prerelease_specs":{"type":"method","name":"prerelease_specs","children":[],"call":[" prerelease_gems values "," prerelease_gems "]}," SourceIndex latest_specs":{"type":"method","name":"latest_specs","children":[],"call":["result values flatten ","result values ","result [] << ","result [] ","result_spec platform == ","spec platform ","result_spec platform ","result [] delete_if ","spec platform != ","latest []= ","result [] clear ","spec platform == ","curr_ver > ","prev_ver nil? ","latest [] platform != ","latest [] platform ","latest [] ","curr_ver >= ","curr_ver prerelease? ","include_prerelease ! ","latest [] version ","latest key? ","spec version ","spec name "," sort each "," sort ","h []= ","Hash  new ","spec version  > ","latest [] version  nil? ","spec version  >= ","spec version  prerelease? ","spec spec name  "]}," SourceIndex load_gems_in":{"type":"method","name":"load_gems_in","children":[],"call":[" add_spec ","Gem Specification  load ","spec_files each ","Dir  glob ","File  join ","spec_dirs reverse_each ","@gems clear ","Dir  glob  each "]}," SourceIndex released_gems":{"type":"method","name":"released_gems","children":[],"call":["gem version prerelease? ","gem version ","@gems reject "]}," SourceIndex prerelease_gems":{"type":"method","name":"prerelease_gems","children":[],"call":["gem version prerelease? ! ","gem version prerelease? ","gem version ","@gems reject "]}," SourceIndex all_gems":{"type":"method","name":"all_gems","children":[],"call":[]}," SourceIndex initialize":{"type":"method","name":"initialize","children":[],"call":[" add_spec ","specifications each "]}," SourceIndex load_specification":{"type":"method","name":"load_specification","children":[],"call":["Gem Specification  load "]}," SourceIndex from_gems_in":{"type":"method","name":"from_gems_in","children":[],"call":["source_index refresh! ","source_index spec_dirs= "," new "," new  refresh! "," new  spec_dirs= "]}," SourceIndex installed_spec_directories":{"type":"method","name":"installed_spec_directories","children":[],"call":["File  join ","Gem  path collect ","Gem  path "]}," SourceIndex from_installed_gems":{"type":"method","name":"from_installed_gems","children":[],"call":[" from_gems_in "," installed_spec_directories ","deprecated empty? "]}," Gem source_index":{"type":"method","name":"source_index","children":[],"call":["SourceIndex  from_installed_gems "]}," YARD Parser SourceParser after_parse_file_callbacks":{"type":"method","name":"after_parse_file_callbacks","children":[],"call":[]}," YARD Parser SourceParser before_parse_file_callbacks":{"type":"method","name":"before_parse_file_callbacks","children":[],"call":[]}," YARD Parser SourceParser after_parse_list_callbacks":{"type":"method","name":"after_parse_list_callbacks","children":[],"call":[]}," YARD Parser SourceParser before_parse_list_callbacks":{"type":"method","name":"before_parse_list_callbacks","children":[],"call":[]}," YARD Parser SourceParser after_parse_file":{"type":"method","name":"after_parse_file","children":[],"call":[" after_parse_file_callbacks << "," after_parse_file_callbacks "]}," YARD Parser SourceParser before_parse_file":{"type":"method","name":"before_parse_file","children":[],"call":[" before_parse_file_callbacks << "," before_parse_file_callbacks "]}," YARD Parser SourceParser after_parse_list":{"type":"method","name":"after_parse_list","children":[],"call":[" after_parse_list_callbacks << "," after_parse_list_callbacks "]}," YARD Parser SourceParser before_parse_list":{"type":"method","name":"before_parse_list","children":[],"call":[" before_parse_list_callbacks << "," before_parse_list_callbacks "]}," YARD Parser Ruby RipperParser on_qwords_add":{"type":"method","name":"on_qwords_add","children":[],"call":["list push ","list line_range= "," lineno ","list line_range first ","list line_range ","list source_range= ","list source_range first ","list source_range ","@ns_charno - ","@source [] == ","@source [] "]}," YARD Handlers Ruby MacroHandlerMethods attribute_readable?":{"type":"method","name":"attribute_readable?","children":[],"call":["types join =~ ","types join ","@docstring tag types ","@docstring tag ","@docstring tag types  join =~ ","@docstring tag types  join ","@docstring tag @docstring tag types  "]}," YARD Handlers Ruby MacroHandlerMethods attribute_writable?":{"type":"method","name":"attribute_writable?","children":[],"call":["types join include? ","types join ","@docstring tag types ","@docstring tag ","@docstring tag types  join include? ","@docstring tag types  join ","@docstring tag @docstring tag types  "]}," YARD Handlers Ruby MacroHandlerMethods method_signature":{"type":"method","name":"method_signature","children":[],"call":["name =~ "," call_params first "," call_params "," method_name "," attribute_readable? ! "," attribute_readable? ","@docstring tag text ","@docstring tag ","@docstring tag signature ","@docstring tag name "," method_name  =~ ","@docstring tag text  =~ ","@docstring tag signature  =~ ","@docstring tag name  =~ "," method_ method_name  "," method_@docstring tag text  "," method_@docstring tag signature  "," method_@docstring tag name  ","@docstring tag  method_name  ","@docstring tag @docstring tag text  ","@docstring tag @docstring tag signature  ","@docstring tag @docstring tag name  "]}," YARD Handlers Ruby MacroHandlerMethods method_name":{"type":"method","name":"method_name","children":[],"call":["name + "," attribute_readable? ! "," attribute_readable? ","@docstring tag ","name =~ "," call_params first "," call_params ","@docstring add_tag ","Tags OverloadTag  new ","tag_name == ","tag send to_s ","tag send ","tag == ","(sym :method) each ","name +  + ","tag send to_s  + ","@docstring @docstring tag  ","name +  =~ ","tag send to_s  =~ ","@docstring add_@docstring tag  ","tag_name +  == ","tag_tag send to_s  == ","@docstring tag _name == ","@docstring tag  send to_s ","@docstring tag  send ","@docstring tag  == "]}," YARD Handlers Ruby MacroHandlerMethods create_attribute_data":{"type":"method","name":"create_attribute_data","children":[],"call":[" namespace attributes [] [] []= "," namespace attributes [] [] "," namespace attributes [] ","object scope "," namespace attributes "," namespace ","writer dynamic= ","writer visibility= ","object visibility ","writer signature= ","object name "," register ","MethodObject  new ","object name to_s + ","object name to_s ","object name to_s [] == ","object name to_s [] "," attribute_writable? "," attribute_readable? ","SymbolHash  [] ","object name to_s sub "," ensure_loaded! ","object docstring tag ","object docstring ","MethodObject  new  dynamic= ","MethodObject  new  visibility= ","MethodObject  new  signature= "]}," YARD Handlers Ruby MacroHandlerMethods sanitize_visibility":{"type":"method","name":"sanitize_visibility","children":[],"call":[" visibility ","vis to_sym ","(str \"public\") include? ","@docstring tag text ","@docstring tag "," @docstring tag text ibility ","@docstring tag text  to_sym "]}," YARD Handlers Ruby MacroHandlerMethods sanitize_scope":{"type":"method","name":"sanitize_scope","children":[],"call":[" scope ","tmp_scope to_sym ","(str \"class\") include? ","@docstring tag text ","@docstring tag ","@docstring tag text  to_sym "]}," YARD Handlers Ruby MacroHandlerMethods expand_macro":{"type":"method","name":"expand_macro","children":[],"call":["tag object= ","tag respond_to? ","object docstring tags each ","object docstring tags ","object docstring ","object docstring= "]}," YARD Handlers Ruby MacroHandlerMethods expanded_macro_or_docstring":{"type":"method","name":"expanded_macro_or_docstring","children":[],"call":["Docstring  new ","MacroObject  apply_macro "," statement source "," statement ","(send\n  (array\n    (send nil :caller_method)) :+\n  (send nil :call_params)) compact ","(send nil :caller_method) + "," call_params "," caller_method ","(send\n  (array\n    (send nil :caller_method)) :+\n  (send nil :c(send\n  (array\n    (send nil :caller_method)) :+\n  (send nil :call_params)) compact )) compact "," c(send\n  (array\n    (send nil :caller_method)) :+\n  (send nil :call_params)) compact  "]}," YARD Handlers Ruby MacroHandlerMethods find_or_create_macro":{"type":"method","name":"find_or_create_macro","children":[],"call":["obj == ","macro method_object namespace ","macro method_object "," namespace inheritance_tree each "," namespace inheritance_tree "," namespace ","(or\n  (send\n    (send\n      (send nil :globals) :__attached_macros) :[]\n    (send nil :caller_method))\n  (array)) each "," globals __attached_macros [] "," caller_method "," globals __attached_macros "," globals ","(send\n  (send\n    (send nil :namespace) :inheritance_tree) :+\n  (array\n    (send nil :P\n      (str \"Object\")))) each "," namespace inheritance_tree + "," P "]}," YARD Handlers Legacy Base caller_method":{"type":"method","name":"caller_method","children":[],"call":[" statement tokens first text "," statement tokens first "," statement tokens "," statement "," statement tokens first is_a? "," extract_method_details first "," extract_method_details "]}," YARD Handlers Legacy Base call_params":{"type":"method","name":"call_params","children":[],"call":["value to_s "," tokval_list map "," tokval_list "," statement tokens [] "," statement tokens "," statement ","param first "," extract_method_details last map "," extract_method_details last "," extract_method_details "," statement tokens first is_a? "," statement tokens first "," statement  statement tokens []  [] "," statement  statement tokens []  "," statement  statement tokens []  first is_a? "," statement  statement tokens []  first "]}," YARD Handlers Ruby Base caller_method":{"type":"method","name":"caller_method","children":[],"call":[" statement [] jump source "," statement [] jump "," statement [] "," statement "," statement type == "," statement type "," statement method_name to_s "," statement method_name "," statement call? "," statement def? "]}," YARD Handlers Ruby Base call_params":{"type":"method","name":"call_params","children":[],"call":["param jump source ","param jump "," statement parameters map "," statement parameters "," statement "," statement respond_to? ","(send\n  (send\n    (send\n      (send nil :statement) :parameters\n      (false)) :compact) :map) flatten ","n jump source ","n jump ","param map ","param type == ","param type "," statement parameters compact map "," statement parameters compact "]}," YARD Handlers Base expand_macro":{"type":"method","name":"expand_macro","children":[],"call":["object docstring= ","Docstring  new ","MacroObject  apply_macro "," statement source "," statement ","object docstring ","(send\n  (array\n    (send nil :caller_method)) :+\n  (send nil :call_params)) compact ","(send nil :caller_method) + "," call_params "," caller_method ","(send\n  (array\n    (send nil :caller_method)) :+\n  (send nil :c(send\n  (array\n    (send nil :caller_method)) :+\n  (send nil :call_params)) compact )) compact "," c(send\n  (array\n    (send nil :caller_method)) :+\n  (send nil :call_params)) compact  "]}," YARD Handlers Base find_or_create_macro":{"type":"method","name":"find_or_create_macro","children":[],"call":[" globals __attached_macros [] "," globals __attached_macros "," globals ","macro attached? ","object name to_s ","object name ","macro method_object= ","object scope == ","object scope ","object is_a? "," caller_method ","MacroObject  find_or_create "," P "," namespace "," raise "," log warn "," statement line "," statement "," parser file "," parser ","object path "," log ","macro_tag name ","docstring tag ","object_or_docstring docstring ","object_or_docstring is_a? "," globals __attached_MacroObject  find_or_create s [] "," globals __attached_MacroObject  find_or_create s ","MacroObject  find_or_create  attached? ","MacroObject  find_or_create  method_object= ","MacroObject  find_or_create _tag name ","docstring tag  name "]}," YARD Handlers Base caller_method":{"type":"method","name":"caller_method","children":[],"call":[" raise "]}," YARD Handlers Base call_params":{"type":"method","name":"call_params","children":[],"call":[" raise "]}," YARD Handlers Base extra_state":{"type":"method","name":"extra_state","children":[],"call":[" parser extra_state "," parser "]}," YARD Handlers Base globals":{"type":"method","name":"globals","children":[],"call":[" parser globals "," parser "]}," YARD Docstring delete_tag_if":{"type":"method","name":"delete_tag_if","children":[],"call":["@ref_tags delete_if ","@tags delete_if "]}," YARD Docstring delete_tags":{"type":"method","name":"delete_tags","children":[],"call":["tag tag_name to_s == ","name to_s ","tag tag_name to_s ","tag tag_name "," delete_tag_if "]}," YARD Docstring to_raw":{"type":"method","name":"to_raw","children":[],"call":["(send\n  (array\n    (send nil :strip)\n    (send\n      (lvar :tag_data) :join\n      (str \"\\n\"))) :reject) compact join ","(send\n  (array\n    (send nil :strip)\n    (send\n      (lvar :tag_data) :join\n      (str \"\\n\"))) :reject) compact ","l empty? ","(send nil :strip) reject ","tag_data join "," strip ","  + ","tag text strip gsub ","tag text strip ","tag text ","tag name ","tag name to_s "," [ + + "," [ + ","tag types join ","tag types ","@ + ","tag tag_name ","\n + ","tag docstring all gsub ","tag docstring all ","tag docstring ","tag docstring blank? ","tag signature ","(send\n  (send nil :tags) :sort_by) map ","t tag_name "," tags sort_by "," tags ","tag pair text strip gsub ","tag pair text strip ","tag pair text ","tag pair "," ( + + "," ( + ","tag pair defaults join ","tag pair defaults ","tag pair name to_s ","tag pair name ","tag pair types join ","tag pair types ","\n   + ","(send nil :strip) reject compact join ","(send nil :strip) reject compact "," tags sort_by map "," tags map "]}," YARD Docstring dup":{"type":"method","name":"dup","children":[],"call":["obj instance_variable_set ","val dup "," instance_variable_get ","(str \"all\") each "," resolve_reference "," instance_variable_defined? "," instance_variable_get  dup "]}," YARD CodeObjects MacroObject expand":{"type":"method","name":"expand","children":[],"call":[" class expand "," macro_data "," class ","params join ","call_params [] ","call_params size ","last to_i ","first to_i ","first == ","$& [] ","macro_data gsub ","macro_data all ","macro_data is_a? "," macro_data all  ","call_params []  join ","call_call_params []  [] ","call_call_params []  size ","macro_data all  gsub ","macro_data all  all ","macro_data all  is_a? "]}," YARD CodeObjects MacroObject sep":{"type":"method","name":"sep","children":[],"call":[]}," YARD CodeObjects MacroObject path":{"type":"method","name":"path","children":[],"call":[".macro. + "," name to_s "," name "]}," YARD CodeObjects MacroObject attached?":{"type":"method","name":"attached?","children":[],"call":[" method_object "]}," YARD CodeObjects MacroObject nonmacro_data":{"type":"method","name":"nonmacro_data","children":[],"call":["new_docstring to_raw ","new_docstring delete_tags ","docstring dup ","text strip empty? ","text strip ","text ! ","docstring tag text ","docstring tag "," new_macro? ","docstring dup  to_raw ","docstring dup  delete_tags ","docstring tag text  strip empty? ","docstring tag text  strip ","docstring tag text  ! ","docstring tag docstring tag text  "]}," YARD CodeObjects MacroObject macro_data":{"type":"method","name":"macro_data","children":[],"call":["new_docstring to_raw strip ","new_docstring to_raw ","tag_text strip empty? ","tag_text strip ","tag_text ! ","docstring tag text ","docstring tag ","new_docstring delete_tags ","docstring dup ","docstring dup  to_raw strip ","docstring dup  to_raw ","docstring tag text  strip empty? ","docstring tag text  strip ","docstring tag text  ! ","docstring dup  delete_tags "]}," YARD CodeObjects MacroObject macro_name":{"type":"method","name":"macro_name","children":[],"call":["docstring tag name ","docstring tag "]}," YARD CodeObjects MacroObject attached_macro?":{"type":"method","name":"attached_macro?","children":[],"call":["docstring tag types include? ","docstring tag types ","docstring tag ","docstring tag types nil? ","method_object nil? "]}," YARD CodeObjects MacroObject new_macro?":{"type":"method","name":"new_macro?","children":[],"call":["docstring all =~ ","docstring all ","types include? ","docstring tag types ","docstring tag ","docstring tag types  include? ","docstring tag docstring tag types  "]}," YARD CodeObjects MacroObject apply_macro":{"type":"method","name":"apply_macro","children":[],"call":["data join strip ","data join ","data << "," nonmacro_data "," expand "," macro_data "," new_macro? ","macro ! ","macro expand ","Docstring  new ","Docstring  === "," apply "]}," YARD CodeObjects MacroObject apply":{"type":"method","name":"apply","children":[],"call":[" apply_macro "," find_or_create ","parser parse to_docstring to_raw ","parser parse to_docstring ","parser parse ","handler statement= ","OpenStruct  new ","handler caller_method= ","call_params first ","handler call_params= ","call_params [] ","DocstringParser  new ","docstring all ","Docstring  === ","Docstring  parser "," apply_ find_or_create  ","DocstringParser  new  parse to_docstring to_raw ","Docstring  parser  parse to_docstring to_raw ","parser parse to_docstring all  to_raw ","DocstringParser  new  parse to_docstring ","Docstring  parser  parse to_docstring ","parser parse to_docstring all  ","DocstringParser  new  parse ","Docstring  parser  parse ","OpenStruct  new  statement= ","OpenStruct  new  caller_method= ","OpenStruct  new  call_params= ","docstring all  all ","Docstring  DocstringParser  new  ","Docstring  Docstring  parser  "]}," YARD CodeObjects MacroObject find_or_create":{"type":"method","name":"find_or_create","children":[],"call":[" find "," create "," macro_data "," attached_macro? "," new_macro? "," macro_name ","docstring tag ","Docstring  new ","Docstring  === "," name ","  find _data "," attached_ find ? "," new_ find ? "," macro_ macro_name  ","  find _name ","Docstring  new  tag ","  macro_name  "]}," YARD CodeObjects MacroObject find":{"type":"method","name":"find","children":[],"call":["Registry  at ",".macro. + ","macro_name to_s "]}," YARD CodeObjects MacroObject create":{"type":"method","name":"create","children":[],"call":["obj method_object= ","obj macro_data= "," new "," new  method_ new ect= "," new  macro_data= "]}," CodeObjects ExtraFileObject parse_contents":{"type":"method","name":"parse_contents","children":[],"call":["data force_encoding ","data respond_to? "," contents= "," log warn ","e message "," filename "," log ","e message =~ "," attributes [] "," attributes "," contents force_encoding "," contents "," contents respond_to? ","data join ","data [] ","cut_index > "," attributes []= ","index == ","data each_with_index ","data split ","contents force_encoding ","contents respond_to? "," translate "," raise ","data []  force_encoding ","data split  force_encoding "," translate  force_encoding ","data []  respond_to? ","data split  respond_to? "," translate  respond_to? "," data join = "," data join  force_encoding "," data join  "," data join  respond_to? ","data []  join ","data split  join "," translate  join ","data []  [] ","data split  [] "," translate  [] ","data []  each_with_index ","data split  each_with_index "," translate  each_with_index ","data []  split ","data split  split "," translate  split ","data join  force_encoding ","data join  respond_to? "]}," CodeObjects ExtraFileObject hash":{"type":"method","name":"hash","children":[],"call":[" filename hash "," filename "]}," CodeObjects ExtraFileObject ==":{"type":"method","name":"==","children":[],"call":["other filename == "," filename ","other filename "," class === "," class "]}," CodeObjects ExtraFileObject type":{"type":"method","name":"type","children":[],"call":[]}," CodeObjects ExtraFileObject inspect":{"type":"method","name":"inspect","children":[],"call":[" attributes inspect "," attributes "," filename "," type "]}," CodeObjects ExtraFileObject title":{"type":"method","name":"title","children":[],"call":[" name "," attributes [] "," attributes "]}," CodeObjects ExtraFileObject initialize":{"type":"method","name":"initialize","children":[],"call":[" parse_contents ","File  read "," attributes= ","SymbolHash  new "," name= ","File  basename gsub ","File  basename "," filename= "," ensure_parsed "]}," YARD CLI Yardoc yardopts_options":{"type":"method","name":"yardopts_options","children":[],"call":[" use_document_file= ","opts on "," use_yardopts_file= ","use_yardopts != "," options_file= ","use_yardopts is_a? "]}," YARD CLI Yardoc parse_yardopts_options":{"type":"method","name":"parse_yardopts_options","children":[],"call":["args shift ","args first [] != ","args first [] ","args first ","args [] ","idx + ","args index ","err args first ","err args ","opts parse "," yardopts_options ","OptionParser  new ","opts base long clear ","opts base long ","opts base ","args []  shift ","args []  first [] != ","args []  first [] ","args []  first ","args []  [] ","args index  + ","args []  index ","err args []  first ","err args []  ","OptionParser  new  parse "," yardOptionParser  new _options ","OptionParser  new  base long clear ","OptionParser  new  base long ","OptionParser  new  base "]}," YARD CLI List run":{"type":"method","name":"run","children":[],"call":["Yardoc  run "," puts ","args include? "," log puts "," log "]}," YARD CLI List description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Diff load_git_commit":{"type":"method","name":"load_git_commit","children":[],"call":[" cleanup ","Dir  chdir "," generate_yardoc "," log info ","git says:  + ","(str \"git reset --hard \") chomp "," log ","FileUtils  cp_r ","FileUtils  mkdir_p ","File  join ","Dir  tmpdir ","git_commit + ","commit gsub ","Registry  clear ","Dir  File  join  "]}," YARD Logger warn_no_continuations":{"type":"method","name":"warn_no_continuations","children":[],"call":[" warn ","JRuby/MacRuby/Rubinius do not implement Kernel#callcc and cannot  + "]}," YARD Parser LoadOrderError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Parser Ruby RipperParser on_lbracket":{"type":"method","name":"on_lbracket","children":[],"call":[" visit_ns_token ","(or-asgn\n  (send\n    (ivar :@map) :[]\n    (sym :lbracket))\n  (array)) << "," charno "," lineno ","@map [] "]}," YARD Parser Ruby RipperParser on_array":{"type":"method","name":"on_array","children":[],"call":["node line_range= ","other line_range ","node source_range= ","other source_range ","Range  new "," lineno ","@ns_charno - ","map pop ","map empty? ! ","map empty? ","@map [] ","MAPPINGS  [] ","node type ","AstNode  node_class_for new ","AstNode  node_class_for ","other line_range begin ","other source_range begin ","AstNode  node_class_for new  line_range= ","AstNode  node_class_for new  source_range= ","@map []  pop ","@map []  empty? ! ","@map []  empty? ","@@map []  [] ","AstNode  node_class_for new  type ","AstNode  AstNode  node_class_for new _class_for new ","AstNode  AstNode  node_class_for new _class_for "]}," YARD Parser Ruby RipperParser on_unary":{"type":"method","name":"on_unary","children":[],"call":["node line_range= ","Range  new "," lineno ","node source_range= ","@ns_charno - ","AstNode  node_class_for new ","AstNode  node_class_for ","map pop ","@map [] ","op to_s [] ","op to_s ","AstNode  node_class_for new  line_range= ","AstNode  node_class_for new  source_range= ","AstNode  AstNode  node_class_for new _class_for new ","AstNode  AstNode  node_class_for new _class_for ","@map []  pop ","@@map []  [] "]}," YARD Parser CParser parse_attributes":{"type":"method","name":"parse_attributes","children":[],"call":[" handle_attribute ","var_name == ","@content scan "]}," YARD Parser CParser handle_attribute":{"type":"method","name":"handle_attribute","children":[],"call":["obj namespace attributes [] [] []= ","obj namespace attributes [] [] ","obj namespace attributes [] ","obj namespace attributes ","obj namespace ","SymbolHash  [] "," ensure_loaded! "," handle_method ","values [] > ","values [] ","(pair\n  (sym :read)\n  (lvar :name)) each ","write to_i ","read to_i "," handle_method  namespace attributes [] [] []= "," handle_method  namespace attributes [] [] "," handle_method  namespace attributes [] "," handle_method  namespace attributes "," handle_method  namespace "]}," YARD Helpers HtmlHelper html_markup_pre":{"type":"method","name":"html_markup_pre","children":[],"call":["<pre> + + ","<pre> + "," h "]}," YARD Helpers HtmlHelper html_markup_textile_strict":{"type":"method","name":"html_markup_textile_strict","children":[],"call":[" markup_class new to_html "," markup_class new "," markup_class "]}," YARD Parser CParser parse_aliases":{"type":"method","name":"parse_aliases","children":[],"call":[" handle_alias ","var_name == ","@content scan "]}," YARD Parser CParser handle_alias":{"type":"method","name":"handle_alias","children":[],"call":["namespace aliases []= ","namespace aliases ","new_obj signature= ","new_obj docstring object= ","new_obj docstring ","new_obj docstring= ","old_obj docstring ","new_obj source= ","old_obj source ","old_obj signature ","o source_type= ","o add_file ","o scope= ","o visibility= ","YARD CodeObjects MethodObject  new ","namespace child ","old_name to_sym ","new_name to_sym "," ensure_loaded! "," P "," remove_var_prefix "," lookup_var "," P  aliases []= "," lookup_var  aliases []= "," P  aliases "," lookup_var  aliases ","namespace child  docstring ","namespace child  source ","namespace child  signature "," P  child "," lookup_var  child "]}," YARD CodeObjects Base to_ary":{"type":"method","name":"to_ary","children":[],"call":[]}," YARD Helpers HtmlHelper parse_codeblocks":{"type":"method","name":"parse_codeblocks","children":[],"call":["(str \"code\") compact join ","(str \"code\") compact "," html_syntax_highlight ","CGI  unescapeHTML "," options [] "," options "," object source_type "," object "," parse_lang_for_codeblock ","html gsub "," options highlight "," detect_lang_in_codeblock_attributes "]}," YARD Helpers HtmlHelper parse_lang_for_codeblock":{"type":"method","name":"parse_lang_for_codeblock","children":[],"call":["source =~ "]}," YARD Parser Ruby RipperParser on_aref_field":{"type":"method","name":"on_aref_field","children":[],"call":["AstNode  new "," charno "," lineno ","@map [] pop ","@map [] "]}," YARD Parser CParser parse_namespaces":{"type":"method","name":"parse_namespaces","children":[],"call":[" handle_namespace ","@content scan "]}," YARD Parser CParser handle_class_lookup":{"type":"method","name":"handle_class_lookup","children":[],"call":["@namespaces []= "," P "]}," YARD Parser CParser handle_namespace":{"type":"method","name":"handle_namespace","children":[],"call":[" handle_class "," handle_class_lookup "," handle_module "]}," YARD Parser CParser lookup_var":{"type":"method","name":"lookup_var","children":[],"call":[" P "," remove_var_prefix ","@namespaces [] "]}," YARD Templates TemplateOptions embed_mixins_match?":{"type":"method","name":"embed_mixins_match?","children":[],"call":["re match ","matchstr to_s ","mixin name ","mixin path ","embed_mixin include? ","Regexp  quote gsub ","Regexp  quote "," embed_mixins any? "," embed_mixins ","mixin is_a? ","mixin == "," object ","mixin name  to_s ","mixin path  to_s "]}," YARD Templates TemplateOptions no_highlight=":{"type":"method","name":"no_highlight=","children":[],"call":[" highlight= ","value ! "]}," YARD Templates TemplateOptions no_highlight":{"type":"method","name":"no_highlight","children":[],"call":[" highlight ! "," highlight "]}," YARD Helpers HtmlHelper url_for_index":{"type":"method","name":"url_for_index","children":[],"call":[" url_for_file "]}," YARD Helpers HtmlHelper url_for_main":{"type":"method","name":"url_for_main","children":[],"call":[" url_for_file "]}," YARD Helpers HtmlHelper url_for_frameset":{"type":"method","name":"url_for_frameset","children":[],"call":[" url_for_file "]}," YARD Helpers HtmlHelper url_for_list":{"type":"method","name":"url_for_list","children":[],"call":[" url_for_file "]}," Helpers BaseHelper owner":{"type":"method","name":"owner","children":[],"call":[" object namespace "," object "]}," YARD Tags Library directive_create":{"type":"method","name":"directive_create","children":[],"call":[" send "," class directive_method_name "," class "," send_to_factory "," class factory_method_for "," class directive_ class directive_method_name od_name "," class directive_ class factory_method_for od_name "," class factory_ class directive_method_name od_for "," class factory_ class factory_method_for od_for "]}," YARD Tags Library has_directive?":{"type":"method","name":"has_directive?","children":[],"call":[" respond_to? "," class directive_method_name "," class "]}," YARD Tags Library tag_create":{"type":"method","name":"tag_create","children":[],"call":[" send "," class tag_method_name "," class "]}," YARD Tags Library has_tag?":{"type":"method","name":"has_tag?","children":[],"call":[" respond_to? "," class tag_method_name "," class "]}," YARD Tags Library directive_call":{"type":"method","name":"directive_call","children":[],"call":["meth call ","meth new ","meth <= "," class factory_method_for_directive ","tag tag_name "," class ","meth new  call "," class factory_method_for_directive  call ","meth new  new "," class factory_method_for_directive  new ","meth new  <= "," class factory_method_for_directive  <= "," class factory_meth new od_for_directive "," class factory_ class factory_method_for_directive od_for_directive "]}," YARD Tags Library tag_or_directive_method_name":{"type":"method","name":"tag_or_directive_method_name","children":[],"call":["tag_name to_s gsub ","tag_name to_s ","tag_name to_s tr "]}," YARD Tags Library directive_method_name":{"type":"method","name":"directive_method_name","children":[],"call":[" tag_or_directive_method_name "]}," YARD Tags Library tag_method_name":{"type":"method","name":"tag_method_name","children":[],"call":[" tag_or_directive_method_name "]}," YARD Tags Library define_directive":{"type":"method","name":"define_directive","children":[],"call":["@directive_factory_classes update ","SymbolHash  new ","@factory_methods update "," class_eval ","directive_class nil? "," directive_method_name ","  directive_method_name od_name "]}," YARD Tags Library factory_method_for_directive":{"type":"method","name":"factory_method_for_directive","children":[],"call":["@directive_factory_classes [] "]}," YARD Tags VisibilityDirective call":{"type":"method","name":"call","children":[],"call":[" parser state visibility= "," tag text to_sym "," tag text "," tag "," parser state "," parser "," object visibility= "," object "," object is_a? ","(str \"public\") include? "," handler visibility= "," handler "," parser state inside_directive ! "," parser state inside_directive "," inside_directive? ! "," inside_directive? "]}," YARD Tags ScopeDirective call":{"type":"method","name":"call","children":[],"call":[" parser state scope= "," tag text to_sym "," tag text "," tag "," parser state "," parser "," object scope= "," object "," object is_a? ","(str \"class\") include? "," handler scope= "," handler "," inside_directive? ! "," inside_directive? "]}," YARD Tags ParseDirective call":{"type":"method","name":"call","children":[],"call":["src_parser parse ","StringIO  new "," tag text "," tag ","src_parser file= "," handler parser file "," handler parser "," handler ","Parser SourceParser  new "," handler globals "," handler parser process ","pobj enumerator ","pobj parse ","pclass new ","Parser SourceParser  parser_types [] "," handler parser parser_type ","Parser SourceParser  parser_types ","lang == "," tag types first to_sym "," tag types first "," tag types ","Parser SourceParser  new  parse ","Parser SourceParser  new  file= ","pclass new  enumerator ","pclass new  parse ","Parser SourceParser  parser_types []  new "," tag types first to_sym  == "]}," YARD Tags AttributeDirective readable?":{"type":"method","name":"readable?","children":[],"call":[" tag types join =~ "," tag types join "," tag types "," tag "," tag types ! "]}," YARD Tags AttributeDirective writable?":{"type":"method","name":"writable?","children":[],"call":[" tag types join include? "," tag types join "," tag types "," tag "," tag types ! "]}," YARD Tags AttributeDirective create_attribute_data":{"type":"method","name":"create_attribute_data","children":[],"call":["attrs [] []= ","attrs [] "," handler register_file_info "," handler ","writer parameters= ","writer group= ","object group ","writer source= ","object source ","writer dynamic= ","object dynamic ","writer visibility= ","object visibility ","writer signature= ","object name ","CodeObjects MethodObject  new ","object scope ","object name to_s + ","object name to_s ","object namespace ","object name to_s [] == ","object name to_s [] "," writable? "," readable? ","SymbolHash  [] ","object namespace attributes [] ","object namespace attributes ","object name to_s sub ","writer docstring= ","object base_docstring ","object namespace attributes []  [] []= ","object namespace attributes []  [] ","CodeObjects MethodObject  new  parameters= ","CodeObjects MethodObject  new  group= ","CodeObjects MethodObject  new  source= ","CodeObjects MethodObject  new  dynamic= ","CodeObjects MethodObject  new  visibility= ","CodeObjects MethodObject  new  signature= ","CodeObjects MethodObject  new  docstring= "]}," YARD Tags AttributeDirective method_signature":{"type":"method","name":"method_signature","children":[],"call":[" method_name "," readable? "]}," YARD Tags AttributeDirective method_name":{"type":"method","name":"method_name","children":[],"call":[" readable? "," handler call_params first "," handler call_params "," handler "," sanitized_tag_signature "]}," YARD Tags AttributeDirective after_parse":{"type":"method","name":"after_parse","children":[],"call":[" create_attribute_data "," create_object "," use_indented_text "," handler "]}," YARD Tags MethodDirective create_object":{"type":"method","name":"create_object","children":[],"call":[" handler register_module_function "," handler ","obj docstring= ","Docstring  new! "," parser raw_text "," parser "," parser tags "," parser text ","obj signature= "," method_signature "," handler register_group "," handler register_visibility "," handler register_source "," handler register_file_info ","CodeObjects MethodObject  new "," handler namespace "," object ","CodeObjects NamespaceObject  === "," handler visibility "," parser state visibility "," parser state "," handler scope "," parser state scope "," method_name ","obj parameters= ","OverloadTag  new parameters ","OverloadTag  new "," parser reference "," parser object= "," parser post_process "," parser object ","CodeObjects MethodObject  new  docstring= ","CodeObjects MethodObject  new  signature= "," handler  method_name space "," CodeObjects MethodObject  new ect "," method_ method_name  ","CodeObjects MethodObject  new  parameters= "," parser CodeObjects MethodObject  new ect= "," parser CodeObjects MethodObject  new ect "]}," YARD Tags MethodDirective use_indented_text":{"type":"method","name":"use_indented_text","children":[],"call":[" parser parse "," tag text "," tag "," parser "," parser= ","DocstringParser  new "," parser library "," parser object "," parser handler "," tag text empty? "," parser class new "," parser class "," parser state inside_directive= "," parser state "," parser  parser object  "," parser  parser handler  "]}," YARD Tags MethodDirective sanitized_tag_signature":{"type":"method","name":"sanitized_tag_signature","children":[],"call":[" tag name "," tag "," parser state scope= "," parser state "," parser "," tag name =~ "]}," YARD Tags MethodDirective method_signature":{"type":"method","name":"method_signature","children":[],"call":[" method_name "," sanitized_tag_signature "]}," YARD Tags MethodDirective method_name":{"type":"method","name":"method_name","children":[],"call":[" handler call_params first "," handler call_params "," handler ","sig [] ","sig =~ "," sanitized_tag_signature "," sanitized_tag_signature  [] "," sanitized_tag_signature  =~ "," sanitized_tag_ sanitized_tag_signature nature "]}," YARD Tags MethodDirective after_parse":{"type":"method","name":"after_parse","children":[],"call":[" create_object "," use_indented_text "," handler "]}," YARD Tags MethodDirective call":{"type":"method","name":"call","children":[],"call":[]}," YARD Tags MacroDirective warn":{"type":"method","name":"warn","children":[],"call":[" log warn ","Invalid/missing macro name for  + "," handler statement line "," handler statement "," handler "," handler parser file "," handler parser "," object path "," object "," log "]}," YARD Tags MacroDirective find_or_create":{"type":"method","name":"find_or_create","children":[],"call":["macro macro_data ","CodeObjects MacroObject  find "," tag name "," tag ","CodeObjects MacroObject  create "," tag text "," anonymous? "," P "," handler caller_method "," handler "," handler namespace "," object "," attach? "," new? "," log warn "," handler statement line "," handler statement "," handler parser file "," handler parser "," object path "," log "," object is_a? ","Attaching macros to non-methods is unsupported, ignoring:  + ","CodeObjects MacroObject  find  CodeObjects MacroObject  find _data ","CodeObjects MacroObject  create  CodeObjects MacroObject  create _data ","  P ect ","  object ect ","  P ect path ","  object ect path ","  P ect is_a? ","  object ect is_a? ","Attaching CodeObjects MacroObject  find s to non-methods is unsupported, ignoring:  + ","Attaching CodeObjects MacroObject  create s to non-methods is unsupported, ignoring:  + "]}," YARD Tags MacroDirective expand":{"type":"method","name":"expand","children":[],"call":["CodeObjects MacroObject  expand ","(send\n  (array\n    (lvar :caller_method)) :+\n  (lvar :call_params)) compact ","(lvar :caller_method) + "," handler statement source "," handler statement "," handler "," handler caller_method "," handler call_params "," handler statement source empty? "," handler ! "," new? "," anonymous? ! "," anonymous? "," class_method? "," attach? ","(send\n  (array\n    (lvar :caller_method)) :+\n  (lvar :c(send\n  (array\n    (lvar :caller_method)) :+\n  (lvar :call_params)) compact )) compact ","(send\n  (array\n    (lvar : handler caller_method )) :+\n  (lvar :call_params)) compact ","(send\n  (array\n    (lvar :caller_method)) :+\n  (lvar : handler call_params )) compact ","(lvar : handler caller_method ) + "," handler  handler caller_method  "," handler c(send\n  (array\n    (lvar :caller_method)) :+\n  (lvar :call_params)) compact  "," handler  handler call_params  "]}," YARD Tags MacroDirective anonymous?":{"type":"method","name":"anonymous?","children":[],"call":[" tag name empty? "," tag name "," tag "," tag name nil? "]}," YARD Tags MacroDirective class_method?":{"type":"method","name":"class_method?","children":[],"call":[" object scope == "," object scope "," object "," object is_a? "]}," YARD Tags MacroDirective attach?":{"type":"method","name":"attach?","children":[],"call":[" tag types include? "," tag types "," tag "," class_method? "," new? "]}," YARD Tags MacroDirective new?":{"type":"method","name":"new?","children":[],"call":[" tag text strip empty? ! "," tag text strip empty? "," tag text strip "," tag text "," tag "," tag types include? "," tag types "]}," YARD Tags MacroDirective call":{"type":"method","name":"call","children":[],"call":[" expanded_text= "," expand "," warn "," find_or_create "," raise "," tag text to_s empty? "," tag text to_s "," tag text "," tag "," tag name nil? "," tag name "]}," YARD Tags GroupDirective call":{"type":"method","name":"call","children":[],"call":[" handler extra_state group= "," tag text "," tag "," handler extra_state "," handler "]}," YARD Tags EndGroupDirective call":{"type":"method","name":"call","children":[],"call":[" handler extra_state group= "," handler extra_state "," handler "]}," YARD Tags Directive after_parse":{"type":"method","name":"after_parse","children":[],"call":[]}," YARD Tags Directive call":{"type":"method","name":"call","children":[],"call":[" raise "]}," YARD Tags Directive initialize":{"type":"method","name":"initialize","children":[],"call":[" expanded_text= "," parser= "," tag= "]}," YARD Tags Directive handler":{"type":"method","name":"handler","children":[],"call":[" parser handler "," parser "]}," YARD Tags Directive object":{"type":"method","name":"object","children":[],"call":[" parser object "," parser "]}," YARD Tags DefaultFactory extract_types_and_name_from_text_unstripped":{"type":"method","name":"extract_types_and_name_from_text_unstripped","children":[],"call":["text [] ","e + ","list first == ","list first ","list size == ","list size ","before empty? ","list last << ","list last ","level >= ","before empty? ! ","level == ","c =~ ","before << ","list == ","list push ","c == ","list last [] == ","list last [] ","closing_types include? ","level > ","opening_types include? ","text split each_with_index ","text split ","last_seen == ","$& length + ","$& length ","c + ","text [] =~ ","i + ","i < ","text length ","String  new ","String  new  empty? ","String  new  empty? ! ","text []  =~ ","String  new  << ","text []  == ","text [] losing_types intext [] lude? ","opening_types intext [] lude? ","text split eatext [] h_with_index ","text []  + "]}," YARD Tags DefaultFactory parse_tag_with_types_and_title":{"type":"method","name":"parse_tag_with_types_and_title","children":[],"call":["Tag  new "," extract_title_and_desc_from_text "," extract_types_and_name_from_text_unstripped "]}," YARD Server DocServerHelper url_for_index":{"type":"method","name":"url_for_index","children":[],"call":["File  join "," base_path "," router docs_prefix "," router "," abs_url "]}," YARD Server DocServerHelper url_for_main":{"type":"method","name":"url_for_main","children":[],"call":[" url_for_index "," url_for_file "," options readme "," options ","File  join "," options command path "," options command "," base_path "," router docs_prefix "," router "," options command path empty? ! "," options command path empty? "," options frames "]}," YARD Server DocServerHelper url_for_frameset":{"type":"method","name":"url_for_frameset","children":[],"call":["File  join "," base_path "," router docs_prefix "," router ","url gsub "," url_for "," object "," url_for_file "," options file "," options ","url gsub  gsub "," url_for  gsub "," url_for_file  gsub "," url gsub _for ","  url_for _for ","  url_for_file _for "," url gsub _for_file ","  url_for _for_file ","  url_for_file _for_file "]}," YARD Server DocServerHelper url_for_list":{"type":"method","name":"url_for_list","children":[],"call":["File  join ","type to_s "," base_path "," router list_prefix "," router "," abs_url "]}," YARD Server Commands SearchCommand url_for":{"type":"method","name":"url_for","children":[],"call":["File  join "," serializer serialized_path "," serializer "," base_path "," router docs_prefix "," router "," abs_url "]}," YARD Server Commands LibraryCommand fulldoc_template":{"type":"method","name":"fulldoc_template","children":[{"type":"method","name":"init","children":[],"asgn":[],"call":[]},{"type":"method","name":"asset","children":[],"asgn":[null],"call":[]}],"call":[" attr_reader ","obj send "," options ","obj class= ","Object  new extend ","Object  new ","Templates Engine  template "," options format "," options template "," define_method ","Object  new extend  send ","Object  new extend  class= "]}," YARD Server Commands LibraryCommand restore_template_info":{"type":"method","name":"restore_template_info","children":[],"call":["Templates Template  extra_includes= ","Templates Engine  template_paths= "]}," YARD Server Commands LibraryCommand save_default_template_info":{"type":"method","name":"save_default_template_info","children":[],"call":["Templates Template  extra_includes dup ","Templates Template  extra_includes ","Templates Engine  template_paths dup ","Templates Engine  template_paths "]}," YARD Server Commands LibraryOptions each":{"type":"method","name":"each","children":[],"call":[" serializer "," single_library "," library "," adapter "]}," YARD Server Commands LibraryOptions serializer":{"type":"method","name":"serializer","children":[],"call":["@command serializer "]}," YARD Server Commands LibraryOptions single_library":{"type":"method","name":"single_library","children":[],"call":["@command single_library "]}," YARD Server Commands LibraryOptions library":{"type":"method","name":"library","children":[],"call":["@command library "]}," YARD Server Commands LibraryOptions adapter":{"type":"method","name":"adapter","children":[],"call":["@command adapter "]}," YARD Serializers YardocSerializer object_types_path":{"type":"method","name":"object_types_path","children":[],"call":["File  join "," basepath "]}," YARD Serializers FileSystemSerializer encode_path_components":{"type":"method","name":"encode_path_components","children":[],"call":["encoded << ","%X % ","x each_byte ","p gsub ","components map! ","String  new ","String  new  << "]}," YARD RegistryStore write_object_types":{"type":"method","name":"write_object_types","children":[],"call":["f write ","Marshal  dump ","File  open! "," object_types_path "]}," YARD RegistryStore load_object_types":{"type":"method","name":"load_object_types","children":[],"call":["(or-asgn\n  (send\n    (ivar :@object_types) :[]\n    (send\n      (lvar :object) :type))\n  (array)) << ","object path ","@object_types [] ","object type "," values each "," values ","Marshal  load ","File  read_binary "," object_types_path ","File  file? ","(or-asgn\n  (send\n    (ivar :Marshal  load ) :[]\n    (send\n      (lvar :object) :type))\n  (array)) << ","Marshal  load  [] "]}," YARD RegistryStore object_types_path":{"type":"method","name":"object_types_path","children":[],"call":["@serializer object_types_path "]}," YARD RegistryStore values_for_type":{"type":"method","name":"values_for_type","children":[],"call":["@store [] ","t to_sym "," paths_for_type map "," paths_for_type "," load_all "]}," YARD RegistryStore paths_for_type":{"type":"method","name":"paths_for_type","children":[],"call":["@object_types [] "," load_all "]}," YARD Parser OrderedParser parse":{"type":"method","name":"parse","children":[],"call":["SourceParser  new parse ","SourceParser  new ","SourceParser  parser_type "," log debug "," log "," files shift "," files "," log capture "," files empty? ","  files shift s shift ","  files shift s ","  files shift s empty? "]}," YARD Parser OrderedParser initialize":{"type":"method","name":"initialize","children":[],"call":["@global_state ordered_parser= ","files dup "]}," YARD Parser Ruby RipperParser add_comment":{"type":"method","name":"add_comment","children":[],"call":["@comments_flags delete ","@comments_range delete ","@comments delete ","node docstring_range= ","node docstring_hash_flag= ","@comments_flags [] ","node docstring= ","node parent= ","parent_node unfreeze ","parent_node insert ","parent_node index ","before_node parent ","before_node unfreeze ","before_node push ","CommentNode  new ","node nil? ","line - ","comment count ","@comments_range [] ","@comments [] ","@@comments [] s_flags delete ","@@comments [] s_range delete ","@@comments [] s delete ","CommentNode  new  docstring_range= ","CommentNode  new  docstring_hash_flag= ","@@comments [] s_flags [] ","CommentNode  new  docstring= ","CommentNode  new  parent= ","before_node parent  unfreeze ","parent_CommentNode  new  unfreeze ","before_node parent  insert ","parent_CommentNode  new  insert ","before_node parent  index ","parent_CommentNode  new  index ","before_CommentNode  new  parent ","before_CommentNode  new  unfreeze ","before_CommentNode  new  push ","CommentNode  new  nil? ","@comments []  count ","@@comments [] s_range [] ","@@comments [] s [] "]}," YARD Parser Ruby RipperParser file_encoding":{"type":"method","name":"file_encoding","children":[],"call":["match captures last ","match captures ","@encoding_line match ","Encoding  default_internal ","@encoding_line match  captures last ","@encoding_line match  captures ","@encoding_line @encoding_line match  "]}," YARD Parser Ruby CommentNode first_line":{"type":"method","name":"first_line","children":[],"call":[]}," YARD Parser Ruby CommentNode source":{"type":"method","name":"source","children":[],"call":[]}," YARD Parser Ruby CommentNode docstring=":{"type":"method","name":"docstring=","children":[],"call":[]}," YARD Parser Ruby CommentNode docstring":{"type":"method","name":"docstring","children":[],"call":[" first "]}," YARD Parser Ruby LoopNode block":{"type":"method","name":"block","children":[],"call":[" last "]}," YARD Parser Ruby LoopNode condition":{"type":"method","name":"condition","children":[],"call":[" first "," s "," [] "," type == "," type "]}," YARD Parser Ruby LoopNode loop?":{"type":"method","name":"loop?","children":[],"call":[]}," YARD Parser Ruby ModuleNode block":{"type":"method","name":"block","children":[],"call":[" last "]}," YARD Parser Ruby ModuleNode module_name":{"type":"method","name":"module_name","children":[],"call":[" first "]}," YARD Parser Ruby ClassNode block":{"type":"method","name":"block","children":[],"call":[" last "]}," YARD Parser Ruby ClassNode superclass":{"type":"method","name":"superclass","children":[],"call":[" [] "," type == "," type "]}," YARD Parser Ruby ClassNode class_name":{"type":"method","name":"class_name","children":[],"call":[" first "]}," YARD Parser Ruby MethodDefinitionNode index_adjust":{"type":"method","name":"index_adjust","children":[],"call":[" type == "," type "]}," YARD Parser Ruby MethodDefinitionNode parameters":{"type":"method","name":"parameters","children":[],"call":["params [] ","params type == ","params type "," [] ","1 + "," index_adjust ","params []  [] "," []  [] ","params []  type == "," []  type == ","params []  type "," []  type "]}," YARD Parser Ruby MethodDefinitionNode method_name":{"type":"method","name":"method_name","children":[],"call":["name jump first to_sym ","name jump first ","name jump "," [] "," index_adjust "," []  jump first to_sym "," []  jump first "," []  jump "]}," YARD Parser Ruby MethodDefinitionNode namespace":{"type":"method","name":"namespace","children":[],"call":[" first "," index_adjust > "," index_adjust "]}," YARD Parser Ruby MethodDefinitionNode def?":{"type":"method","name":"def?","children":[],"call":[]}," YARD Parser Ruby MethodDefinitionNode kw?":{"type":"method","name":"kw?","children":[],"call":[]}," YARD Parser Ruby MethodCallNode block":{"type":"method","name":"block","children":[],"call":[" last "," last type == "," last type "]}," YARD Parser Ruby AstNode unfreeze":{"type":"method","name":"unfreeze","children":[],"call":[]}," YARD Parser Ruby AstNode block?":{"type":"method","name":"block?","children":[],"call":[" condition? "," respond_to? "]}," YARD Parser Ruby AstNode loop?":{"type":"method","name":"loop?","children":[],"call":[]}," YARD Parser Ruby AstNode def?":{"type":"method","name":"def?","children":[],"call":[]}," YARD Parser C Comment comments":{"type":"method","name":"comments","children":[],"call":[]}," YARD Parser C Comment initialize":{"type":"method","name":"initialize","children":[],"call":[" parse_comments "]}," YARD Parser C Statement show":{"type":"method","name":"show","children":[],"call":[" first_line "," line "]}," YARD Parser C Statement first_line":{"type":"method","name":"first_line","children":[],"call":[" source split first "," source split "," source "]}," YARD Parser C Statement comments_range":{"type":"method","name":"comments_range","children":[],"call":[" comments line_range "," comments "]}," YARD Parser C Statement line_range":{"type":"method","name":"line_range","children":[],"call":[" line + "," source count "," source "," line "]}," YARD Parser C Statement initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Parser C CommentParser remove_private_comments":{"type":"method","name":"remove_private_comments","children":[],"call":["comment sub ","comment gsub ","comment sub  sub ","comment gsub  sub ","comment sub  gsub ","comment gsub  gsub "]}," YARD Parser C CommentParser parse_types":{"type":"method","name":"parse_types","children":[],"call":["(send\n  (send\n    (begin\n      (or\n        (lvar :types)\n        (str \"\"))) :split\n    (regexp\n      (str \",| or \")\n      (regopt))) :map) compact ","t strip gsub ","t strip ","(or\n  (lvar :types)\n  (str \"\")) split map ","(or\n  (lvar :types)\n  (str \"\")) split ","types =~ "]}," YARD Parser C CommentParser parse_callseq":{"type":"method","name":"parse_callseq","children":[],"call":["comments + + ","comments + ","overloads << ","types join ","types empty? ","signature rstrip ","signature =~ ","( + + ","( + ","signature [] join ","signature [] ","signature split ","signature sub! "," parse_types ","line split ","line sub! ","line empty? ","comments shift strip ","comments shift ","comments first =~ ","comments first ","comments []= ","comments [] =~ ","comments [] "," parse_types  join "," parse_types  empty? ","signature rstrip  rstrip ","signature split  rstrip ","signature rstrip  =~ ","signature split  =~ ","signature rstrip  [] join ","signature split  [] join ","signature rstrip  [] ","signature split  [] ","signature rstrip  split ","signature split  split ","signature rstrip  sub! ","signature split  sub! "," parse_ parse_types  ","comments shift strip  split ","comments shift strip  sub! ","comments shift strip  empty? "]}," YARD Parser C CommentParser parse_overrides":{"type":"method","name":"parse_overrides","children":[],"call":["(send\n  (lvar :comments) :map) compact ","@overrides << ","type to_sym ","line scan first ","line scan ","comments map "]}," YARD Parser C CommentParser parse_comments":{"type":"method","name":"parse_comments","children":[],"call":["comments join "," parse_callseq "," parse_overrides ","(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\\\r?\\\\n\")\n      (regopt))) :map) compact ","line gsub rstrip ","line gsub ","(or\n  (send\n    (lvar :line) :[]\n    (regexp\n      (str \"^(\\\\s+)\")\n      (regopt))\n    (int 1))\n  (str \"\")) size ","line [] ","spaces nil? ","line =~ ","line gsub! ","comments split map ","comments split "," remove_private_comments "," parse_callseq  join "," parse_overrides  join ","(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact  join "," remove_private_comments  join ","(send\n  (send\n    (lvar : parse_callseq ) :split\n    (regexp\n      (str \"\\\\r?\\\\n\")\n      (regopt))) :map) compact ","(send\n  (send\n    (lvar : parse_overrides ) :split\n    (regexp\n      (str \"\\\\r?\\\\n\")\n      (regopt))) :map) compact ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact ) :split\n    (regexp\n      (str \"\\\\r?\\\\n\")\n      (regopt))) :map) compact ","(send\n  (send\n    (lvar : remove_private_comments ) :split\n    (regexp\n      (str \"\\\\r?\\\\n\")\n      (regopt))) :map) compact ","(or\n  (send\n    (lvar :line) :[]\n    (regexp\n      (str \"^(\\s+)\")\n      (regopt))\n    (int 1))\n  (str \"\")) size  nil? "," parse_callseq  split map "," parse_overrides  split map ","(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact  split map "," remove_private_comments  split map "," parse_callseq  split "," parse_overrides  split ","(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact  split "," remove_private_comments  split "," remove_private_ parse_callseq  "," remove_private_ parse_overrides  "," remove_private_(send\n  (send\n    (lvar :comments) :split\n    (regexp\n      (str \"\\r?\\n\")\n      (regopt))) :map) compact  "," remove_private_ remove_private_comments  "]}," YARD Parser C CParser nextchar":{"type":"method","name":"nextchar","children":[],"call":["@content [] ","@index + "]}," YARD Parser C CParser prevchar":{"type":"method","name":"prevchar","children":[],"call":["@content [] ","@index - "]}," YARD Parser C CParser char":{"type":"method","name":"char","children":[],"call":["@content [] "]}," YARD Parser C CParser nextline":{"type":"method","name":"nextline","children":[],"call":[]}," YARD Parser C CParser advance_loop":{"type":"method","name":"advance_loop","children":[],"call":["@index <= ","@content size "]}," YARD Parser C CParser back":{"type":"method","name":"back","children":[],"call":[]}," YARD Parser C CParser advance":{"type":"method","name":"advance","children":[],"call":[]}," YARD Parser C CParser attach_comment":{"type":"method","name":"attach_comment","children":[],"call":["@last_comment statement= ","statement comments= ","statement statement= ","@last_statement comments= ","@last_statement line == ","statement line ","@last_statement line ","Comment  === "]}," YARD Parser C CParser consume_until":{"type":"method","name":"consume_until","children":[],"call":["@content [] ","brace_level <= ","bracket_level <= ","chr =~ ","chr == ","chr !~ "," advance "," consume_comment "," consume_directive "," consume_quote "," char "," consume_whitespace "," advance_loop ","end_char is_a? "," char  =~ "," char  == "," char  !~ "]}," YARD Parser C CParser consume_comment":{"type":"method","name":"consume_comment","children":[],"call":[" advance ","@statements << "," attach_comment ","stmt type= ","Comment  new ","comment [] "," char == "," char ","comment << "," nextline ","type == "," advance_loop "," nextchar == "," nextchar ","String  new "," attach_String  new  ","Comment  new  type= ","String  new  [] ","String  new  << "]}," YARD Parser C CParser consume_whitespace":{"type":"method","name":"consume_whitespace","children":[],"call":[" advance "," char =~ "," char "," nextline "," char == "," advance_loop "]}," YARD Parser C CParser strip_non_statement_data":{"type":"method","name":"strip_non_statement_data","children":[],"call":[" consume_comment "," consume_directive "," consume_whitespace "," char ","start == "," loop "]}," YARD Parser C CParser consume_body_statements":{"type":"method","name":"consume_body_statements","children":[],"call":["stmts << "," attach_comment ","BodyStatement  new ","src !~ ","@content [] "," prevchar == "," prevchar ","brace_level <= "," prevchar empty? "," consume_until "," strip_non_statement_data "," loop ","BodyStatement  new s << ","@content []  !~ "]}," YARD Parser C CParser consume_toplevel_statement":{"type":"method","name":"consume_toplevel_statement","children":[],"call":["statement declaration= ","statement block= ","statement source= ","@content [] "," consume_until ","decl =~ "," consume_body_statements "," prevchar == "," prevchar "," attach_comment ","@statements << ","ToplevelStatement  new "," struct ","ToplevelStatement  new  declaration= ","statement  consume_until aration= ","ToplevelStatement  new  block= ","ToplevelStatement  new  source= "," consume_until  =~ "," consume_body_ToplevelStatement  new s ","@ToplevelStatement  new s << "]}," YARD Parser C CParser consume_directive":{"type":"method","name":"consume_directive","children":[],"call":[" advance "," char == "," char "," nextline "," advance_loop "," nextchar =~ "," nextchar "]}," YARD Parser C CParser consume_quote":{"type":"method","name":"consume_quote","children":[],"call":[" advance "," nextline "," char "," advance_loop "]}," YARD Parser C CParser parse_toplevel":{"type":"method","name":"parse_toplevel","children":[],"call":[" consume_toplevel_statement "," consume_whitespace "," consume_comment "," consume_directive "," consume_quote "," char "," advance_loop "," advance "]}," YARD Parser C CParser tokenize":{"type":"method","name":"tokenize","children":[],"call":[" raise "]}," YARD Parser C CParser enumerator":{"type":"method","name":"enumerator","children":[],"call":[]}," YARD Parser C CParser parse":{"type":"method","name":"parse","children":[],"call":[" enumerator "," parse_toplevel "]}," YARD Parser C CParser initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Options tap":{"type":"method","name":"tap","children":[],"call":[]}," YARD Options delete":{"type":"method","name":"delete","children":[],"call":[" remove_instance_variable "," instance_variable_defined? "," [] "]}," YARD Options reset_defaults":{"type":"method","name":"reset_defaults","children":[],"call":[" []= ","value call ","Proc  === ","names_set []= ","names_set [] ","defaults each ","klass instance_variable_get "," class ancestors each "," class ancestors "," class ","klass instance_variable_defined? ","klass instance_variable_get  each "]}," YARD Options method_missing":{"type":"method","name":"method_missing","children":[],"call":[" instance_variable_get "," log debug "," class "," log ","args size == ","args size "," instance_variable_set ","args first ","meth to_s =~ ","meth to_s "," instance_variable_defined? ","args empty? "]}," YARD Options ==":{"type":"method","name":"==","children":[],"call":[" to_hash == "," to_hash ","other to_hash "]}," YARD Options inspect":{"type":"method","name":"inspect","children":[],"call":[" to_hash inspect "," to_hash "," class "]}," YARD Options each":{"type":"method","name":"each","children":[],"call":[" send ","name to_sym ","ivar to_s sub ","ivar to_s "," instance_variables each "," instance_variables ","ivar to_s sub  to_sym "]}," YARD Options to_hash":{"type":"method","name":"to_hash","children":[],"call":["opts []= "," send ","name to_sym ","ivar to_s sub ","ivar to_s "," instance_variables each "," instance_variables ","ivar to_s sub  to_sym "]}," YARD Options merge":{"type":"method","name":"merge","children":[],"call":[" dup update "," dup "]}," YARD Options update":{"type":"method","name":"update","children":[],"call":[" []= ","opts each ","opts to_hash ","Options  === ","opts to_hash  each ","opts to_hash  to_hash "]}," YARD Options []=":{"type":"method","name":"[]=","children":[],"call":[" send "]}," YARD Options []":{"type":"method","name":"[]","children":[],"call":[" send "]}," YARD Options default_attr":{"type":"method","name":"default_attr","children":[],"call":[]}," YARD I18n Text extract_messages":{"type":"method","name":"extract_messages","children":[],"call":["paragraph rstrip ","paragraph empty? ","paragraph << ","line chomp empty? ","line chomp ","line_no == ","@input each_line ","@options [] ","part [] "," parse ","part []  == "]}," YARD I18n Text initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD I18n PotGenerator extract_paragraphs":{"type":"method","name":"extract_paragraphs","children":[],"call":[" raise ","message [] << ","file filename ","message [] "," add_message ","paragraph rstrip ","text extract_messages ","Text  new ","File  open ","message add_location "," register_message ","message add_comment "," add_message  [] << "," register_message  [] << "," add_message  [] "," register_message  [] "," add_ add_message  "," add_ register_message  ","text extract_ add_message s ","text extract_ register_message s ","Text  new  extract_messages "," add_message  add_location "," register_message  add_location "," register_ add_message  "," register_ register_message  "," add_message  add_comment "," register_message  add_comment "]}," YARD I18n PotGenerator extract_tag_text":{"type":"method","name":"extract_tag_text","children":[],"call":["message [] << ","message [] ","tag_label << ","tag name ","tag types join ","tag types ","tag tag_name ","tag object files each ","tag object files ","tag object "," add_message ","tag text ","tag text empty? ","tag text nil? ","message add_comment ","message add_location "," register_message ","String  new "," add_message  [] << "," register_message  [] << "," add_message  [] "," register_message  [] ","String  new  << "," add_ add_message  "," add_ register_message  "," add_message  add_comment "," register_message  add_comment "," add_message  add_location "," register_message  add_location "," register_ add_message  "," register_ register_message  "]}," YARD I18n PotGenerator extract_tag_name":{"type":"method","name":"extract_tag_name","children":[],"call":["message [] << ","message [] ","tag_label << ","tag types join ","tag types ","tag tag_name ","tag object files each ","tag object files ","tag object "," add_message ","tag name ","tag name empty? ","tag name is_a? ","tag name nil? ","message add_comment ","message add_location "," register_message ","String  new "," add_message  [] << "," register_message  [] << "," add_message  [] "," register_message  [] ","String  new  << "," add_ add_message  "," add_ register_message  "," add_message  add_comment "," register_message  add_comment "," add_message  add_location "," register_message  add_location "," register_ add_message  "," register_ register_message  "]}," YARD I18n PotGenerator extract_tag_documents":{"type":"method","name":"extract_tag_documents","children":[],"call":[" extract_tag_text "," extract_tag_name "," extract_documents ","Tags OverloadTag  === "]}," YARD I18n PotGenerator extract_documents":{"type":"method","name":"extract_documents","children":[],"call":[" extract_tag_documents ","docstring tags each ","docstring tags "," raise ","message [] << ","object path ","message [] ","object path empty? ","(or\n  (send\n    (lvar :docstring) :line)\n  (lvar :line)) + ","docstring line ","object files each ","object files "," add_message ","paragraph rstrip ","text extract_messages ","Text  new ","StringIO  new ","docstring empty? ","object docstring ","object group "," extract_documents ","object children each ","object children ","@extracted_objects []= ","@extracted_objects has_key? ","message add_comment ","message add_location "," register_message ","@extracted_objects key? ","object docstring  tags each ","object docstring  tags "," add_message  [] << "," register_message  [] << "," add_message  [] "," register_message  [] ","(or\n  (send\n    (lvar :object docstring ) :line)\n  (lvar :line)) + ","object docstring  line "," add_ add_message  "," add_ register_message  ","text extract_ add_message s ","text extract_ register_message s ","Text  new  extract_messages ","object docstring  empty? ","object object docstring  "," add_message  add_comment "," register_message  add_comment "," add_message  add_location "," register_message  add_location "," register_ add_message  "," register_ register_message  "]}," YARD I18n PotGenerator add_message":{"type":"method","name":"add_message","children":[],"call":["@messages [] "]}," YARD I18n PotGenerator escape_message":{"type":"method","name":"escape_message","children":[],"call":["message gsub "]}," YARD I18n PotGenerator generate_message":{"type":"method","name":"generate_message","children":[],"call":["pot << ","escaped_message gsub "," escape_message ","options [] uniq each ","options [] uniq ","options [] ","comment empty? ","options [] compact uniq each ","options [] compact uniq ","options [] compact ","escaped_message_id gsub "," escape_message_id ","message id ","message locations sort each ","message locations sort ","message locations ","message comments sort each ","message comments sort ","message comments ","escaped_message gsub  gsub "," escape_message  gsub ","escaped_message gsub _id gsub "," escape_message _id gsub ","escaped_message_id gsub  gsub "," escape_message_id  gsub "]}," YARD I18n PotGenerator header":{"type":"method","name":"header","children":[],"call":[" generate_pot_creation_date_value "]}," YARD I18n PotGenerator generate":{"type":"method","name":"generate","children":[],"call":[" generate_message ","sorted_messages each ","sorted_locations first ","(or\n  (send\n    (lvar :options) :[]\n    (sym :locations))\n  (array)) sort_by ","options [] ","@messages sort_by "," header ","message locations sort_by ","message locations ","message locations sort ","String  new ","message locations sort  first "]}," YARD I18n PotGenerator parse_files":{"type":"method","name":"parse_files","children":[],"call":[" extract_paragraphs ","files each "]}," YARD I18n PotGenerator parse_objects":{"type":"method","name":"parse_objects","children":[],"call":[" extract_documents ","objects each "]}," YARD I18n PotGenerator initialize":{"type":"method","name":"initialize","children":[],"call":["Messages  new "]}," YARD Handlers Legacy Base extract_method_details":{"type":"method","name":"extract_method_details","children":[],"call":["meth =~ ","v strip ","k strip ","a split ","args map! "," tokval_list ","Parser Ruby Legacy TokenList  new ","meth gsub! "," statement tokens to_s =~ "," statement tokens to_s "," statement tokens "," statement "," tokval_list  map! "]}," YARD Handlers Ruby DSLHandlerMethods find_attached_macro":{"type":"method","name":"find_attached_macro","children":[],"call":["obj == ","macro method_object namespace ","macro method_object ","(send\n  (send\n    (send nil :namespace) :inheritance_tree) :+\n  (array\n    (send nil :P\n      (str \"Object\")))) each "," namespace inheritance_tree + "," P "," namespace inheritance_tree "," namespace ","macro method_object name to_s == "," caller_method to_s "," caller_method ","macro method_object name to_s ","macro method_object name ","Registry  all each ","Registry  all ","(send\n  (send\n    (send nil :namespace) :inheritance_tree\n    (true)) :+\n  (array\n    (send nil :P\n      (str \"Object\")))) each "," macro_name_matches "]}," YARD Handlers Ruby DSLHandlerMethods method_signature":{"type":"method","name":"method_signature","children":[],"call":[" method_name "]}," YARD Handlers Ruby DSLHandlerMethods method_name":{"type":"method","name":"method_name","children":[],"call":[" raise ","name =~ "," call_params first "," call_params "]}," YARD Handlers Ruby DSLHandlerMethods implicit_docstring?":{"type":"method","name":"implicit_docstring?","children":[],"call":["@docstring =~ ","tags any? "]}," YARD Handlers Ruby DSLHandlerMethods register_docstring":{"type":"method","name":"register_docstring","children":[],"call":[]}," YARD Handlers Ruby DSLHandlerMethods handle_comments":{"type":"method","name":"handle_comments","children":[],"call":[" register ","object signature= "," method_signature ","MethodObject  new "," scope "," method_name "," namespace "," register_docstring ","@docstring =~ "," implicit_docstring? ! "," implicit_docstring? "," statement comments_hash_flag ! "," statement comments_hash_flag "," statement ","\n + ","macro expand "," statement source "," call_params "," caller_method "," find_attached_macro ","@docstring join ","@docstring is_a? "," statement comments ","IGNORE_METHODS  [] ","txt match ","attaching ! ","o signature= ","MethodObject  new  signature= ","@docstring join  =~ "," find_attached_macro  expand "," find_attached_ find_attached_macro  ","@docstring join  join ","@docstring join  is_a? ","macro expand  match "]}," YARD Handlers Processor handles?":{"type":"method","name":"handles?","children":[],"call":["handler handles? ","(int -1) include? ","handler method arity ","handler method ","handler method arity == ","handler matches_file? "," file "]}," YARD Handlers Processor parse_remaining_files":{"type":"method","name":"parse_remaining_files","children":[],"call":[" log debug "," log "," globals ordered_parser parse "," globals ordered_parser "," globals "]}," YARD Handlers C HandlerMethods find_method_body":{"type":"method","name":"find_method_body","children":[],"call":[" register_docstring "," statement "," statement comments source "," statement comments "," statement comments source =~ ","in_file ! ","override_comment source ","object name to_s == ","object name to_s ","object name ","object path == ","object path ","just_method_name == ","name gsub ","override_comment file == ","override_comment file "," override_comments each "," override_comments ","src_stmt comments source ","src_stmt comments ","src_stmt comments source empty? ","src_stmt comments nil? "," register_source "," register_file_info ","src_stmt line ","src_stmt file "," symbols [] "," symbols "," process_file "," statement file ","path == ","name sub ","name =~ "," record_parameters "," override_comments any? ","in_ statement file  ! ","object name gsub  to_s == ","object name gsub  to_s ","object name gsub  ","object object name to_s  == ","object object path  == ","object object name to_s  ","object object path  ","name gsub  == ","just_method_name gsub  == ","name gsub  gsub ","override_comment  statement file  == ","override_comment  statement file  "," symbols []  comments source "," symbols []  comments "," symbols []  comments source empty? "," symbols []  comments nil? "," register_ statement file _info "," symbols []  line "," symbols []  file ","src_stmt  statement file  "," process_ statement file  "," statement  statement file  ","object name to_s  == ","object path  == ","name gsub  sub ","name gsub  =~ "]}," YARD Handlers C HandlerMethods find_constant_docstring":{"type":"method","name":"find_constant_docstring","children":[],"call":[" register_docstring ","object value= ","new_value gsub ","comment scan "," statement comments "," statement "," statement comments source "," statement comments source =~ ","comment nil? ","override_comment source ","object name to_s == ","object name to_s ","object name ","object path == ","object path ","name gsub ","override_comment file == "," statement file ","override_comment file "," override_comments each "," override_comments "," statement comments source  scan ","override_comment source  scan "," statement  statement comments source s "," statement override_comment source s "," statement  statement comments source s source "," statement override_comment source s source "," statement  statement comments source s source =~ "," statement override_comment source s source =~ "," statement comments source  nil? ","override_comment source  nil? ","override_ statement comments source  source ","override_override_comment source  source ","override_ statement comments source  file == ","override_override_comment source  file == ","override_ statement comments source  file ","override_override_comment source  file "," override_ statement comments source s each "," override_override_comment source s each "," override_ statement comments source s "," override_override_comment source s "]}," YARD Handlers C HandlerMethods handle_constants":{"type":"method","name":"handle_constants","children":[],"call":[" find_constant_docstring "," register_file_info "," statement line "," statement "," statement file ","obj value= ","obj source_type= "," register ","ConstantObject  new "," namespace_for_variable ","type == ","type =~ ","  namespace_for_variable _for_variable "]}," YARD Handlers C HandlerMethods handle_alias":{"type":"method","name":"handle_alias","children":[],"call":["namespace aliases []= ","namespace aliases ","new_obj signature= ","new_obj docstring object= ","new_obj docstring ","new_obj docstring= ","old_obj docstring ","new_obj source= ","old_obj source ","old_obj signature "," register_file_info "," statement line "," statement "," statement file "," register_visibility "," visibility "," register ","MethodObject  new ","namespace child ","old_name to_sym ","new_name to_sym "," namespace_for_variable ","namespace nil? "," namespace_for_variable  aliases []= "," namespace_for_variable  aliases ","namespace child  docstring ","namespace child  source ","namespace child  signature "," namespace_for_variable  child ","  namespace_for_variable _for_variable "," namespace_for_variable  nil? "]}," YARD Handlers C HandlerMethods handle_attribute":{"type":"method","name":"handle_attribute","children":[],"call":["obj namespace attributes [] [] []= ","obj namespace attributes [] [] ","obj namespace attributes [] ","obj namespace attributes ","obj namespace ","SymbolHash  [] "," handle_method ","values [] > ","values [] ","(pair\n  (sym :read)\n  (lvar :name)) each ","write to_i ","read to_i "," register_file_info "," statement line "," statement "," statement file "," handle_method  namespace attributes [] [] []= "," handle_method  namespace attributes [] [] "," handle_method  namespace attributes [] "," handle_method  namespace attributes "," handle_method  namespace "]}," YARD Handlers C HandlerMethods handle_method":{"type":"method","name":"handle_method","children":[],"call":["obj docstring add_tag ","Tags Tag  new ","obj docstring ","name =~ "," find_method_body "," register_visibility "," register ","MethodObject  new ","namespace nil? "," namespace_for_variable ","obj add_tag ","obj explicit= "," namespaces []= ","YARD CodeObjects ModuleObject  new "," namespaces ","YARD CodeObjects BUILTIN_MODULES  include? ","var_name =~ ","YARD CodeObjects ClassObject  new ","YARD CodeObjects BUILTIN_CLASSES  include? ","namespace is_a? "," add_predicate_return_tag "," namespace_for_variable  nil? "," namespaces []=  nil? ","  namespace_for_variable _for_variable ","  namespaces []= _for_variable ","  namespace_for_variable s []= ","  namespaces []= s []= ","  namespace_for_variable s ","  namespaces []= s "," namespace_for_variable  is_a? "," namespaces []=  is_a? "]}," YARD Handlers C HandlerMethods handle_module":{"type":"method","name":"handle_module","children":[],"call":[" register_file_info "," statement line "," statement "," statement file "," namespaces []= "," namespaces "," register ","ModuleObject  new ","Registry  root "," namespace_for_variable "," raise ","(str \"module \") + ","namespace nil? "," ensure_variable_defined! "," Registry  root s []= ","  namespace_for_variable s []= ","  ensure_variable_defined! s []= "," Registry  root s ","  namespace_for_variable s ","  ensure_variable_defined! s "," Registry  root _for_variable ","  namespace_for_variable _for_variable ","  ensure_variable_defined! _for_variable ","Registry  root  nil? "," namespace_for_variable  nil? "," ensure_variable_defined!  nil? "]}," YARD Handlers C HandlerMethods handle_class":{"type":"method","name":"handle_class","children":[],"call":[" register_file_info "," statement line "," statement "," statement file "," namespaces []= "," namespaces ","obj superclass= ","obj superclass type= ","obj superclass ","parent_class path ","parent_class is_a? "," namespace_for_variable "," register ","ClassObject  new ","Registry  root ","parent == "," raise ","(str \"class \") + ","namespace nil? "," ensure_variable_defined! "," Registry  root s []= ","  namespace_for_variable s []= ","  ensure_variable_defined! s []= "," Registry  root s ","  namespace_for_variable s ","  ensure_variable_defined! s "," namespace_for_variable  path "," namespace_for_variable  is_a? "," Registry  root _for_variable ","  namespace_for_variable _for_variable ","  ensure_variable_defined! _for_variable ","Registry  root  nil? "," namespace_for_variable  nil? "," ensure_variable_defined!  nil? "]}," YARD Handlers C Base remove_var_prefix":{"type":"method","name":"remove_var_prefix","children":[],"call":["var gsub "]}," YARD Handlers C Base process_file":{"type":"method","name":"process_file","children":[],"call":[" log warn "," log "," parser process ","Parser C CParser  new parse ","Parser C CParser  new ","File  read "," parser "," globals ordered_parser files delete "," globals ordered_parser files "," globals ordered_parser "," globals "," log debug "," processed_files []= "," processed_files "," processed_files [] ","File  cleanpath ","File  relative_path "," statement file "," statement "," globals ordered_parser File  cleanpath s delete "," globals ordered_parser File  cleanpath s "," processed_File  cleanpath s []= "," processed_File  cleanpath s "," processed_File  cleanpath s [] "," statement File  cleanpath  "]}," YARD Handlers C Base parse_block":{"type":"method","name":"parse_block","children":[],"call":[" parser process "," statement block "," statement "," parser "," push_state "," statement block empty? "," statement block ! "]}," YARD Handlers C Base processed_files":{"type":"method","name":"processed_files","children":[],"call":[" globals cruby_processed_files "," globals "]}," YARD Handlers C Base namespaces":{"type":"method","name":"namespaces","children":[],"call":[" globals cruby_namespaces "," globals "]}," YARD Handlers C Base namespace_for_variable":{"type":"method","name":"namespace_for_variable","children":[],"call":[" P ","var empty? "," remove_var_prefix "," namespaces [] "," namespaces ","ERROR_CLASS_NAMES  [] "," remove_var_prefix  empty? "," remove_ remove_var_prefix _prefix "," ERROR_CLASS_NAMES  [] spaces [] "," ERROR_CLASS_NAMES  [] spaces "]}," YARD Handlers C Base override_comments":{"type":"method","name":"override_comments","children":[],"call":[" globals cruby_override_comments "," globals "]}," YARD Handlers C Base symbols":{"type":"method","name":"symbols","children":[],"call":[" globals cruby_symbols "," globals "]}," YARD Handlers C Base register_visibility":{"type":"method","name":"register_visibility","children":[],"call":[]}," YARD Handlers C Base register_source":{"type":"method","name":"register_source","children":[],"call":[]}," YARD Handlers C Base register_file_info":{"type":"method","name":"register_file_info","children":[],"call":[]}," YARD Handlers C Base register_docstring":{"type":"method","name":"register_docstring","children":[],"call":[]}," YARD Handlers C Base statement_class":{"type":"method","name":"statement_class","children":[],"call":[]}," YARD Handlers C Base handles?":{"type":"method","name":"handles?","children":[],"call":[]}," YARD Handlers Base register_dynamic":{"type":"method","name":"register_dynamic","children":[],"call":["object dynamic= "," owner != "," namespace "," owner "]}," YARD Handlers Base register_module_function":{"type":"method","name":"register_module_function","children":[],"call":["modobj visibility= ","object copy_to ","MethodObject  new ","object name ","object namespace ","object module_function? ","object is_a? ","MethodObject  new  visibility= "]}," YARD Handlers Base register_visibility":{"type":"method","name":"register_visibility","children":[],"call":["object visibility= ","object respond_to? ","object is_a? "]}," YARD Handlers Base register_source":{"type":"method","name":"register_source","children":[],"call":["object source_type= ","object source ","object is_a? "]}," YARD Handlers Base register_transitive_tags":{"type":"method","name":"register_transitive_tags","children":[],"call":["object docstring add_tag ","object namespace tags ","object namespace ","object docstring ","object has_tag? ","object namespace has_tag? ","object namespace is_a? ","Tags Library  transitive_tags each ","Tags Library  transitive_tags ","object add_tag ","object namespace is_a? ! "]}," YARD Handlers Base register_group":{"type":"method","name":"register_group","children":[],"call":["object group= ","object namespace groups ","object namespace ","object namespace is_a? "]}," YARD Handlers Base register_docstring":{"type":"method","name":"register_docstring","children":[],"call":[" register_transitive_tags ","object docstring line_range= ","stmt comments_range ","object docstring ","object docstring hash_flag= ","stmt comments_hash_flag ","object docstring= ","parser to_docstring ","parser parse ","DocstringParser  new ","docstring join ","Array  === ","Docstring  parser ","object docstring join  line_range= ","object docstring join  ","object docstring join  hash_flag= ","object docstring join = ","DocstringParser  new  to_docstring ","Docstring  parser  to_docstring ","parser to_docstring join  ","DocstringParser  new  parse ","Docstring  parser  parse ","docstring join  join ","Docstring  DocstringParser  new  ","Docstring  Docstring  parser  "]}," YARD Handlers Base register_file_info":{"type":"method","name":"register_file_info","children":[],"call":["object add_file "]}," YARD Handlers Base register_ensure_loaded":{"type":"method","name":"register_ensure_loaded","children":[],"call":["object namespace children << ","object namespace children ","object namespace "," ensure_loaded! "]}," YARD DocstringParser call_after_parse_callbacks":{"type":"method","name":"call_after_parse_callbacks","children":[],"call":["cb call "," class after_parse_callbacks each "," class after_parse_callbacks "," class "]}," YARD DocstringParser tag_is_directive?":{"type":"method","name":"tag_is_directive?","children":[],"call":["list include? "]}," YARD DocstringParser call_directives_after_parse":{"type":"method","name":"call_directives_after_parse","children":[],"call":["dir after_parse "," directives each "," directives "]}," YARD DocstringParser create_directive":{"type":"method","name":"create_directive","children":[],"call":[" log warn ","(str \"Invalid directive format for @!\") + "," object line "," object "," object file "," log ","(str \"Unknown directive @!\") + ","@directives << ","dir is_a? "," library directive_create "," library "," library has_directive? ","(str \"Invalid  library directive_create ective format for @!\") + ","(str \"Unknown  library directive_create ective @!\") + ","@ library directive_create ectives << "," library directive_create  is_a? "," library  library directive_create ective_create "," library has_ library directive_create ective? "]}," YARD DocstringParser create_ref_tag":{"type":"method","name":"create_ref_tag","children":[],"call":["@tags << ","Tags RefTagList  new "," P "," object "]}," YARD DocstringParser create_tag":{"type":"method","name":"create_tag","children":[],"call":[" log warn ","(str \"Invalid tag format for @\") + "," object line "," object "," object file "," log ","(str \"Unknown tag @\") + ","(send\n  (send nil :library) :tag_create\n  (lvar :tag_name)\n  (lvar :tag_buf)) flatten "," library tag_create "," library "," library has_tag? "," create_ref_tag ","tag_buf =~ "]}," YARD DocstringParser parse_content":{"type":"method","name":"parse_content","children":[],"call":["docstring << << ","docstring << ","tag_name ! ","tag_buf << ","line gsub ","last_line =~ ","orig_indent == ","empty ! ","indent >= ","line =~ "," create_tag "," parse_content chomp "," parse_content ","directive expanded_text "," create_directive "," tag_is_directive? ","tag_buf join ","indent <= ","indent == ","indent < ","content size == ","content size ","line [] length ","line [] ","(send\n  (lvar :content) :+\n  (array\n    (str \"\"))) each_with_index ","content + ","content first [] length ","content first [] ","content first ","content empty? ","content ! ","content split ","content is_a? ","String  new ","String  new  << << ","String  new  << ","tag_tag_buf join  << ","orig_line [] length  == ","orig_content first [] length  == ","line [] length  >= ","content first [] length  >= "," parse_content split  chomp "," parse_content split  "," create_directive  expanded_text "," create_ create_directive  "," tag_is_ create_directive ? ","tag_tag_buf join  join ","line [] length  <= ","content first [] length  <= ","line [] length  == ","content first [] length  == ","line [] length  < ","content first [] length  < ","content split  size == ","content split  size ","(send\n  (lvar :content split ) :+\n  (array\n    (str \"\"))) each_with_index ","content split  + ","content split  first [] length ","content split  first [] ","content split  first ","content split  empty? ","content split  ! ","content split  split ","content split  is_a? "]}," YARD DocstringParser to_docstring":{"type":"method","name":"to_docstring","children":[],"call":["Docstring  new! "," raw_text "," object "," tags "," text "," reference "]}," YARD DocstringParser parse":{"type":"method","name":"parse","children":[],"call":[" call_after_parse_callbacks "," call_directives_after_parse ","text gsub "," parse_content "," detect_reference "," post_process ","text strip "," parse_content  gsub "," parse_content  strip "]}," YARD DocstringParser initialize":{"type":"method","name":"initialize","children":[],"call":["OpenStruct  new "]}," YARD DocstringParser after_parse_callbacks":{"type":"method","name":"after_parse_callbacks","children":[],"call":[]}," YARD DocstringParser after_parse":{"type":"method","name":"after_parse","children":[],"call":[]}," YARD Docstring new!":{"type":"method","name":"new!","children":[],"call":[]}," YARD Config load_commandline_safemode":{"type":"method","name":"load_commandline_safemode","children":[],"call":[]}," CodeObjects MethodObject copyable_attributes":{"type":"method","name":"copyable_attributes","children":[],"call":[" - "]}," CodeObjects MethodObject module_function?":{"type":"method","name":"module_function?","children":[],"call":[]}," YARD CodeObjects Base copyable_attributes":{"type":"method","name":"copyable_attributes","children":[],"call":["ivar to_s [] ","ivar to_s "," instance_variables map "," instance_variables "]}," YARD CodeObjects Base copy_to":{"type":"method","name":"copy_to","children":[],"call":["other docstring= "," docstring to_raw "," docstring ","other instance_variable_set "," instance_variable_get "," copyable_attributes each "," copyable_attributes ","@base_docstring to_raw ","@docstring to_raw "]}," YARD CLI YRI try_load_object":{"type":"method","name":"try_load_object","children":[],"call":[" cache_object ","Registry  at "," cache_Registry  at ect "]}," YARD CLI Server add_gems_from_gemfile":{"type":"method","name":"add_gems_from_gemfile","children":[],"call":[" log error "," log "," log warn ","YARD Server LibraryVersion  new ","spec version to_s ","spec version ","spec name "," libraries [] "," libraries ","Bundler LockfileParser  new specs each ","Bundler LockfileParser  new specs ","Bundler LockfileParser  new ","File  read ","File  exists? "," require ","File  exist? "]}," YARD CLI Server initialize":{"type":"method","name":"initialize","children":[],"call":[" server_options= "," options= ","SymbolHash  new update ","SymbolHash  new "," libraries= "," template_paths= "," scripts= "]}," YARD CLI I18n generate_pot":{"type":"method","name":"generate_pot","children":[],"call":["generator generate ","generator parse_files "," options files "," options ","generator parse_objects "," run_verifier "," all_objects ","YARD I18n PotGenerator  new ","YARD I18n PotGenerator  new  generate ","YARD I18n PotGenerator  new  parse_files ","generator parse_ run_verifier  ","YARD I18n PotGenerator  new  parse_objects "," all_ run_verifier  "]}," YARD CLI I18n general_options":{"type":"method","name":"general_options","children":[],"call":["opts separator ","opts top list clear ","opts top list ","opts top ","opts banner= "]}," YARD CLI I18n run":{"type":"method","name":"run","children":[],"call":["serializer serialize "," generate_pot ","relative_base_path to_s ","pot_file_basename to_s ","serializer basepath= ","pot_file_dir_path to_s ","Pathname  pwd relative_path_from ","Pathname  pwd ","pot_file_path split ","Pathname  new expand_path ","Pathname  new ","serializer basepath "," options serializer "," options ","YARD  parse "," excluded "," files "," parse_arguments ","args first nil? ! ","args first nil? ","args first ","args size == ","args size ","args empty? "," options serializer  serialize ","Pathname  pwd relative_path_from  to_s "," options serializer  basepath= ","Pathname  new expand_path  split "," options serializer  basepath "," options  options serializer  "]}," YARD CLI I18n description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI I18n initialize":{"type":"method","name":"initialize","children":[],"call":["@options serializer basepath= ","@options serializer "]}," YARD I18n PotGenerator register_message":{"type":"method","name":"register_message","children":[],"call":["@messages register "]}," YARD I18n PotGenerator escape_message_id":{"type":"method","name":"escape_message_id","children":[],"call":["message_id gsub "]}," YARD I18n Messages ==":{"type":"method","name":"==","children":[],"call":["@messages == ","other messages ","other is_a? "," class "]}," YARD I18n Messages register":{"type":"method","name":"register","children":[],"call":["Message  new ","@messages [] "]}," YARD I18n Messages []":{"type":"method","name":"[]","children":[],"call":["@messages [] "]}," YARD I18n Messages each":{"type":"method","name":"each","children":[],"call":["@messages each_value "]}," YARD I18n Messages initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD I18n Message ==":{"type":"method","name":"==","children":[],"call":["@comments == ","other comments ","@locations == ","other locations ","@id == ","other id ","other is_a? "," class "]}," YARD I18n Message add_comment":{"type":"method","name":"add_comment","children":[],"call":["@comments << ","comment nil? "]}," YARD I18n Message add_location":{"type":"method","name":"add_location","children":[],"call":["@locations << "]}," YARD I18n Message initialize":{"type":"method","name":"initialize","children":[],"call":["Set  new "]}," YARD Docstring parser":{"type":"method","name":"parser","children":[],"call":[" default_parser new "," default_parser "]}," YARD CLI Yardoc add_api_verifier":{"type":"method","name":"add_api_verifier","children":[],"call":[" options verifier add_expressions "," options verifier "," options "," apis uniq inspect "," apis uniq "," apis "," apis delete "," apis empty? ","expr empty? ","exprs join ","exprs << ","exprs size > ","exprs size "," hidden_apis uniq inspect "," hidden_apis uniq "," hidden_apis "," hidden_apis size > "," hidden_apis size "," apis size > "," apis size ","exprs empty? ! ","exprs empty? "," hidden_apis empty? "," options verifier add_exprs join essions ","exprs join  empty? ","exprs join s join ","exprs join s << ","exprs join s size > ","exprs join s size ","exprs join s empty? ! ","exprs join s empty? "]}," YARD Logger puts":{"type":"method","name":"puts","children":[],"call":[" << "," print "]}," YARD Logger clear_progress":{"type":"method","name":"clear_progress","children":[],"call":[" << "," show_progress "," print_no_newline "]}," YARD Logger progress":{"type":"method","name":"progress","children":[],"call":[" progress ","msg + ","@progress_msg == ","@mutex synchronize "," sleep ","Thread  new ","PROGRESS_INDICATORS  size "," << ","PROGRESS_INDICATORS  [] + ","PROGRESS_INDICATORS  [] "," show_progress "," send "," print ","Time  now ","Time  now - > ","Time  now - "]}," YARD Logger capture":{"type":"method","name":"capture","children":[],"call":[" clear_progress "," progress "]}," YARD Logger show_progress":{"type":"method","name":"show_progress","children":[],"call":[" level > "," level "," io tty? "," io ","YARD  windows? ","YARD  ruby18? "]}," YARD I18n Text emit_paragraph_event":{"type":"method","name":"emit_paragraph_event","children":[],"call":["paragraph_part []= "," emit_empty_line_event ","match_data [] ","match_data pre_match ","(str \"(\\\\s*)\\\\z\") match ","(str \"(\\s*)\\z\") match  [] ","(str \"(\\s*)\\z\") match  pre_match "]}," YARD I18n Text emit_empty_line_event":{"type":"method","name":"emit_empty_line_event","children":[],"call":[]}," YARD I18n Text emit_attribute_event":{"type":"method","name":"emit_attribute_event","children":[],"call":["match_data [] "]}," YARD I18n Text emit_markup_event":{"type":"method","name":"emit_markup_event","children":[],"call":[]}," YARD I18n Text parse":{"type":"method","name":"parse","children":[],"call":[" emit_paragraph_event ","paragraph empty? ","paragraph << "," emit_empty_line_event ","line strip empty? ","line strip "," emit_attribute_event ","Regexp  last_match "," emit_markup_event ","line_no == ","@input each_line ","@options [] ","String  new "," emit_String  new _event ","String  new  empty? ","String  new  << "]}," YARD I18n Text translate":{"type":"method","name":"translate","children":[],"call":[" raise "," type ","translated_text << ","part [] ","locale translate "," parse ","String  new ","String  new  << "]}," YARD I18n Locale translate":{"type":"method","name":"translate","children":[],"call":["@messages [] "]}," YARD I18n Locale load":{"type":"method","name":"load","children":[],"call":["@messages merge! ","parser parse_file ","GetText MoFile  new ","parser report_warning= ","GetText PoParser  new ","File  exist? ","File  join "," log warn "," log "," require ","@name nil? ","po_parser parse ","POParser  new ","POParser  available? ","GetText PoParser  new  parse_file ","GetText PoParser  new  report_warning= ","po_GetText PoParser  new  parse ","POParser  new  parse "]}," YARD I18n Locale initialize":{"type":"method","name":"initialize","children":[],"call":[]}," OverrideCommentHandler register_file_info":{"type":"method","name":"register_file_info","children":[],"call":[]}," OverrideCommentHandler register_docstring":{"type":"method","name":"register_docstring","children":[],"call":[]}," YARD CodeObjects Proxy proxy_path":{"type":"method","name":"proxy_path","children":[],"call":["(send\n  (send nil :namespace) :path) join "," name to_s "," name "," namespace path "," namespace "," name to_s =~ ","@origname =~ ","(if\n  (ivar :@imethod)\n  (const nil :ISEP)\n  (str \"\")) + ","@namespace root? "]}," YARD Server Commands LibraryOptions serialize":{"type":"method","name":"serialize","children":[],"call":[]}," YARD ruby19?":{"type":"method","name":"ruby19?","children":[],"call":[]}," YARD ruby18?":{"type":"method","name":"ruby18?","children":[],"call":[]}," YARD windows?":{"type":"method","name":"windows?","children":[],"call":[]}," YARD RegistryStore load_locale":{"type":"method","name":"load_locale","children":[],"call":["locale load ","Registry  po_dir ","I18n Locale  new ","I18n Locale  new  load "]}," YARD RegistryStore locale":{"type":"method","name":"locale","children":[],"call":[" load_locale ","@locales [] "]}," YARD Registry po_dir":{"type":"method","name":"po_dir","children":[],"call":["Thread  current [] ","Thread  current "]}," YARD Registry po_dir=":{"type":"method","name":"po_dir=","children":[],"call":["Thread  current []= ","Thread  current "]}," YARD Registry locale":{"type":"method","name":"locale","children":[],"call":[" thread_local_store locale "," thread_local_store "]}," YARD Logger clear_line":{"type":"method","name":"clear_line","children":[],"call":[" print_no_newline "]}," YARD Logger add":{"type":"method","name":"add","children":[],"call":[" clear_line "]}," YARD Logger print":{"type":"method","name":"print","children":[],"call":[" print_no_newline "," clear_line "]}," CodeObjects ExtraFileObject translate":{"type":"method","name":"translate","children":[],"call":["text translate ","YARD Registry  locale "," locale ","YARD I18n Text  new ","YARD I18n Text  new  translate "]}," CodeObjects ExtraFileObject ensure_parsed":{"type":"method","name":"ensure_parsed","children":[],"call":[" parse_contents ","File  read "]}," CodeObjects ExtraFileObject locale=":{"type":"method","name":"locale=","children":[],"call":[]}," CodeObjects ExtraFileObject contents=":{"type":"method","name":"contents=","children":[],"call":[]}," CodeObjects ExtraFileObject contents":{"type":"method","name":"contents","children":[],"call":[" ensure_parsed "]}," CodeObjects ExtraFileObject attributes":{"type":"method","name":"attributes","children":[],"call":[" ensure_parsed "]}," YARD CLI YardoptsCommand support_rdoc_document_file!":{"type":"method","name":"support_rdoc_document_file!","children":[],"call":["File  read gsub split ","File  read gsub ","File  read "," use_document_file "]}," YARD CLI YardoptsCommand parse_yardopts":{"type":"method","name":"parse_yardopts","children":[],"call":[" optparse "," yardopts "," use_yardopts_file "]}," YARD CLI YardoptsCommand parse_rdoc_document_file":{"type":"method","name":"parse_rdoc_document_file","children":[],"call":[" optparse "," support_rdoc_document_file! "," use_document_file "]}," YARD CLI YardoptsCommand parse_yardopts_options":{"type":"method","name":"parse_yardopts_options","children":[],"call":["args shift ","args first [] != ","args first [] ","args first ","args [] ","idx + ","args index ","err args first ","err args ","opts parse "," yardopts_options ","opts base long clear ","opts base long ","opts base ","OptionParser  new ","args []  shift ","args []  first [] != ","args []  first [] ","args []  first ","args []  [] ","args index  + ","args []  index ","err args []  first ","err args []  ","OptionParser  new  parse "," yardOptionParser  new _options ","OptionParser  new  base long clear ","OptionParser  new  base long ","OptionParser  new  base "]}," YARD CLI YardoptsCommand yardopts":{"type":"method","name":"yardopts","children":[],"call":["File  read_binary shell_split ","File  read_binary "," use_yardopts_file "]}," YARD CLI YardoptsCommand yardopts_options":{"type":"method","name":"yardopts_options","children":[],"call":[" use_document_file= ","opts on "," use_yardopts_file= ","use_yardopts != "," options_file= ","use_yardopts is_a? "]}," YARD CLI YardoptsCommand parse_arguments":{"type":"method","name":"parse_arguments","children":[],"call":[" optparse "," parse_yardopts "," parse_rdoc_document_file "," parse_yardopts_options "]}," YARD CLI YardoptsCommand initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD CLI Yardoc apply_locale":{"type":"method","name":"apply_locale","children":[],"call":["file locale= "," options locale "," options "," options files each "," options files ","YARD I18n Locale  default= "]}," YARD CLI Server extract_db_from_options_file":{"type":"method","name":"extract_db_from_options_file","children":[],"call":["args shift ","args first [] != ","args first [] ","args first ","opts parse! ","opts on ","OptionParser  new ","YARD Registry  yardoc_file ","File  read_binary shell_split ","File  read_binary ","File  read_binary shell_split  shift ","File  read_binary shell_split  first [] != ","File  read_binary shell_split  first [] ","File  read_binary shell_split  first ","OptionParser  new  parse! ","OptionParser  new  on "]}," YARD CLI Server generate_doc_for_first_time":{"type":"method","name":"generate_doc_for_first_time","children":[],"call":["Yardoc  run ","Dir  chdir ","libver source_path "," log info "," log ","libver yardoc_file sub ","Regexp  quote ","Dir  pwd ","libver yardoc_file "," log enter_level ","libver libver yardoc_file sub  sub ","libver libver yardoc_file sub  "]}," YARD CLI Server create_library_version_if_yardopts_exist":{"type":"method","name":"create_library_version_if_yardopts_exist","children":[],"call":["libver source_path= ","YARD Server LibraryVersion  new ","File  expand_path "," extract_db_from_options_file ","File  exist? ","File  join ","YARD Server LibraryVersion  new  source_path= "," extract_File  expand_path _from_options_file "," extract_db_from_File  join  "]}," YARD CLI Graph unrecognized_option":{"type":"method","name":"unrecognized_option","children":[],"call":[]}," YARD CLI Diff removed_objects":{"type":"method","name":"removed_objects","children":[],"call":["o2 path == ","o path ","o2 path ","registry2 find ","registry1 reject "]}," YARD CLI Diff modified_objects":{"type":"method","name":"modified_objects","children":[],"call":["(send\n  (lvar :registry1) :select) compact ","o value != ","obj value ","o value ","obj == ","registry2 find ","o source != ","obj source ","o source ","registry1 select "]}," YARD CLI Diff added_objects":{"type":"method","name":"added_objects","children":[],"call":["o2 path == ","o path ","o2 path ","registry1 find ","registry2 reject "]}," YARD CLI Diff all_objects":{"type":"method","name":"all_objects","children":[],"call":["@verifier run ","Registry  all ","@verifier expressions empty? ","@verifier expressions "]}," YARD CLI Command unrecognized_option":{"type":"method","name":"unrecognized_option","children":[],"call":[" log warn ","err message "," log "]}," YARD I18n Locale default=":{"type":"method","name":"default=","children":[],"call":[]}," YARD I18n Locale default":{"type":"method","name":"default","children":[],"call":[]}," YARD Handlers Base abort!":{"type":"method","name":"abort!","children":[],"call":[" raise "]}," YARD DocstringParser detect_reference":{"type":"method","name":"detect_reference","children":[],"call":["CodeObjects Proxy  new "," namespace ","content =~ "]}," YARD DocstringParser namespace":{"type":"method","name":"namespace","children":[],"call":[" object namespace "," object "]}," YARD Docstring resolve_reference":{"type":"method","name":"resolve_reference","children":[],"call":[" add_tag "," all= ","(send\n  (send\n    (lvar :reference) :docstring) :all) join ","reference docstring all ","reference docstring ","reference docstring tags ","CodeObjects Proxy  === ","@unresolved_reference nil? "," loop ","(ivar :@unresolved_reference) nil? "]}," YARD Docstring to_s":{"type":"method","name":"to_s","children":[],"call":[" resolve_reference "]}," YARD CodeObjects Base translate_docstring":{"type":"method","name":"translate_docstring","children":[],"call":["docstring add_tag ","@base_docstring tags ","Docstring  new ","text translate ","I18n Text  new ","locale nil? ","@base_docstring resolve_reference ","@docstring tags ","@docstring resolve_reference ","localized_tag text= ","I18n Text  new translate ","tag text ","tag clone ","tag is_a? ","@docstring tags each ","Docstring  new  add_tag ","@base_Docstring  new  tags ","I18n Text  new  translate ","@base_Docstring  new  resolve_reference ","@Docstring  new  tags ","@Docstring  new  resolve_reference ","localized_tag I18n Text  new = ","tag clone  text= ","tag I18n Text  new  ","@Docstring  new  tags each "]}," YARD CodeObjects Base add_tag":{"type":"method","name":"add_tag","children":[],"call":["@base_docstring add_tag ","@docstrings clear ","@docstring add_tag "]}," YARD CodeObjects Base title":{"type":"method","name":"title","children":[],"call":[" path "]}," YARD CodeObjects Base base_docstring":{"type":"method","name":"base_docstring","children":[],"call":[]}," YARD Templates Helpers Markup RDocMarkupToHtml initialize":{"type":"method","name":"initialize","children":[],"call":["RDoc Options  new ","options pipe= ","RDoc Options  new  pipe= "]}," YARD ruby2?":{"type":"method","name":"ruby2?","children":[],"call":[]}," YARD Parser Ruby ParameterNode keyword_param":{"type":"method","name":"keyword_param","children":[],"call":[" [] ","YARD  ruby2? "]}," YARD Templates Helpers Markup RDocMarkdown fix_typewriter":{"type":"method","name":"fix_typewriter","children":[],"call":[]}," YARD Templates Helpers Markup RDocMarkdown initialize":{"type":"method","name":"initialize","children":[],"call":["RDoc Markdown  new parse ","RDoc Markdown  new "]}," YARD Helpers HtmlHelper html_markup_asciidoc":{"type":"method","name":"html_markup_asciidoc","children":[],"call":[" markup_class render "," markup_class "," markup_class convert "]}," YARD Logger io=":{"type":"method","name":"io=","children":[],"call":[]}," YARD Logger io":{"type":"method","name":"io","children":[],"call":[]}," YARD CodeObjects RootObject title":{"type":"method","name":"title","children":[],"call":[]}," YARD CLI MarkupTypes run":{"type":"method","name":"run","children":[],"call":[" log puts "," log ","(send\n  (send\n    (lvar :exts) :[]\n    (lvar :name)) :map) join ","exts [] map ","exts [] ","libs join ","libs size > ","libs size ","(send\n  (lvar :providers) :map) compact ","p [] ","providers map ","(send\n  (lvar :types) :sort_by) each ","name to_s ","types sort_by ","libs empty? ","(send\n  (lvar :providers) :map) compact  join ","(send\n  (lvar :providers) :map) compact  size > ","(send\n  (lvar :providers) :map) compact  size ","(send\n  (lvar :providers) :map) compact  empty? "]}," YARD CLI MarkupTypes description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Display parse_arguments":{"type":"method","name":"parse_arguments","children":[],"call":[" verify_markup_options ","o nil? ","@objects any? ","Registry  at ","args map ","Registry  load "," parse_options "," output_options "," general_options ","opts banner= ","OptionParser  new ","OptionParser  new  banner= "]}," YARD CLI Display run":{"type":"method","name":"run","children":[],"call":[" log puts ","obj format "," options "," log ","@objects each "," parse_arguments "," wrap_layout "," format_objects "]}," YARD CLI Display initialize":{"type":"method","name":"initialize","children":[],"call":[" options format= "," options "]}," YARD CLI Display description":{"type":"method","name":"description","children":[],"call":[]}," YARD CLI Display output_options":{"type":"method","name":"output_options","children":[],"call":["opts on "]}," YARD CLI Display wrap_layout":{"type":"method","name":"wrap_layout","children":[],"call":["Templates Engine  template run ","Templates Engine  template "," options format "," options "," options template "," options merge ","@objects first "]}," YARD CLI Display format_objects":{"type":"method","name":"format_objects","children":[],"call":["(send\n  (ivar :@objects) :inject\n  (array)) join ","arr push ","obj format "," options ","@objects inject "]}," YARD Parser C CParser struct":{"type":"method","name":"struct","children":[],"call":[]}," YARD I18n POParser parse":{"type":"method","name":"parse","children":[],"call":["parser parse_file ","parser report_warning= ","GetText MO  new ","GetText POParser  new ","GetText MoFile  new ","GetText PoParser  new ","GetText POParser  new  parse_file ","GetText PoParser  new  parse_file ","GetText POParser  new  report_warning= ","GetText PoParser  new  report_warning= "]}," YARD I18n POParser available?":{"type":"method","name":"available?","children":[],"call":["@@gettext_version nil? ! ","@@gettext_version nil? "]}," YARD Server DocServerSerializer urlencode":{"type":"method","name":"urlencode","children":[],"call":[" escape ","name dup force_encoding ","name dup ","name respond_to? ","CGI  escape ","Templates Helpers HtmlHelper  urlencode ","name dup force_encoding  dup force_encoding ","name dup force_encoding  dup ","name dup force_encoding  respond_to? "]}," YARD I18n PotGenerator generate_pot_creation_date_value":{"type":"method","name":"generate_pot_creation_date_value","children":[],"call":[" current_time strftime "," current_time "]}," YARD I18n PotGenerator current_time":{"type":"method","name":"current_time","children":[],"call":["Time  now "]}," PrivateClassMethodHandler privatize_class_method":{"type":"method","name":"privatize_class_method","children":[],"call":[" raise ","node [] ","node source ","method visibility= "," ensure_loaded! ","Proxy  new ","node [] [] [] ","node [] [] "," namespace ","node literal? ","method respond_to? "," parser parse_remaining_files "," parser ","Proxy  new  visibility= ","Proxy  new  respond_to? "]}," YARD Templates Template with_section":{"type":"method","name":"with_section","children":[],"call":[" section= "," section ","  section ion= ","  section ion "]}," YARD Templates Template add_options":{"type":"method","name":"add_options","children":[],"call":[" options= "," block_given? "," options merge "," options ","opts nil? "]}," YARD Templates Template set_ivars":{"type":"method","name":"set_ivars","children":[],"call":[" instance_variable_set "," options each "," options "]}," YARD Templates Template cache_filename":{"type":"method","name":"cache_filename","children":[],"call":[" class find_file "," erb_file_for "," class ","@cache_filename [] ","section to_sym "]}," YARD Templates Template cache":{"type":"method","name":"cache","children":[],"call":["@cache []= ","IO  read ","section to_sym "," raise "," class path "," class ","@cache_filename []= "," cache_filename ","@cache [] ","@cache_ cache_filename name []= "," cache_ cache_filename name "]}," YARD Templates Template render_section":{"type":"method","name":"render_section","children":[],"call":["section run "," options ","section is_a? "," erb "," send "," respond_to? ","section name ","section name  run ","section name  is_a? ","section name  name "]}," YARD Templates Template erb_with":{"type":"method","name":"erb_with","children":[],"call":["erb filename= ","ERB  new "," options format == "," options format "," options ","ERB  instance_method parameters assoc ","ERB  instance_method parameters ","ERB  instance_method ","ERB  new  filename= "]}," YARD Templates Template erb_file_for":{"type":"method","name":"erb_file_for","children":[],"call":[]}," YARD Templates Template inspect":{"type":"method","name":"inspect","children":[],"call":[" section name "," section "," class path "," class "]}," YARD Templates Template options=":{"type":"method","name":"options=","children":[],"call":[" set_ivars "]}," YARD Templates Template superb":{"type":"method","name":"superb","children":[],"call":[" send "," erb_with ","IO  read ","ErbCache  method_for "," class find_nth_file "," erb_file_for "," class "]}," YARD Templates Template file":{"type":"method","name":"file","children":[],"call":["data gsub! ","IO  read "," class find_nth_file "," class "," raise "," class path "," class find_file ","IO  read  gsub! "," class find_nth_ class find_file  "," class find_ class find_file  "]}," YARD Templates Template erb":{"type":"method","name":"erb","children":[],"call":[" send "," erb_with "," cache_filename "," cache ","ErbCache  method_for "]}," YARD Templates Template yieldall":{"type":"method","name":"yieldall","children":[],"call":[" run "," section "," with_section "]}," YARD Templates Template run":{"type":"method","name":"run","children":[],"call":["out << "," run "," section ","args first "," with_section "," render_section "," section= ","sects each "," add_options ","Section  new ","sects is_a? ","sects [] ","start_at > ","sects nil? ","String  new ","String  new  << ","Section  new  each ","sects []  each ","Section  new  is_a? ","sects []  is_a? ","Section  new  [] ","sects []  [] ","Section  new  nil? ","sects []  nil? "]}," YARD Templates Template init":{"type":"method","name":"init","children":[],"call":[]}," YARD Templates Template sections":{"type":"method","name":"sections","children":[],"call":["Section  new ","args size > ","args size ","args empty? "]}," YARD Templates Template T":{"type":"method","name":"T","children":[],"call":[" class T "," class ","path push "," options format "," options ","path unshift "," options template "]}," YARD Templates Template initialize":{"type":"method","name":"initialize","children":[],"call":[" init ","Template  include_extra "," options "," add_options ","opts_class new ","opts_class == ","opts class ","opts class  new ","opts class  == "]}," YARD Templates Template ClassMethods load_setup_rb":{"type":"method","name":"load_setup_rb","children":[],"call":[" module_eval ","File  read taint ","File  read ","File  file? ","File  join "," full_path ","setup_code taint ","setup_code respond_to? ","File  read  taint ","File  read  respond_to? "]}," YARD Templates Template ClassMethods include_inherited":{"type":"method","name":"include_inherited","children":[],"call":[" include ","Engine  template! "," path ","full_paths reverse each ","full_paths reverse "]}," YARD Templates Template ClassMethods include_parent":{"type":"method","name":"include_parent","children":[],"call":[" include ","Engine  template! "," full_path gsub "," full_path ","Engine  template ","pc join ","pc pop ","pc size > ","pc size "," path to_s split "," path to_s "," path ","pc join  join "," path to_s split  join ","pc join  pop "," path to_s split  pop ","pc join  size > "," path to_s split  size > ","pc join  size "," path to_s split  size "]}," YARD Templates Template ClassMethods S":{"type":"method","name":"S","children":[],"call":["Section  new "]}," YARD Templates Template ClassMethods T":{"type":"method","name":"T","children":[],"call":["Engine  template "]}," YARD Templates Template ClassMethods run":{"type":"method","name":"run","children":[],"call":[" new run "," new "]}," YARD Templates Template ClassMethods new":{"type":"method","name":"new","children":[],"call":["obj send ","obj class= ","Object  new extend ","Object  new ","Object  new extend  send ","Object  new extend  class= "]}," YARD Templates Template ClassMethods is_a?":{"type":"method","name":"is_a?","children":[],"call":["klass == "]}," YARD Templates Template ClassMethods find_nth_file":{"type":"method","name":"find_nth_file","children":[],"call":["index == ","File  file? ","File  join "," full_paths each "," full_paths ","File  File  join ? "]}," YARD Templates Template ClassMethods find_file":{"type":"method","name":"find_file","children":[],"call":[" find_nth_file "]}," YARD Templates Template ClassMethods initialize":{"type":"method","name":"initialize","children":[],"call":[" load_setup_rb "," include_parent "," include_inherited "," full_path= "," path= ","full_paths shift "," full_paths shift = ","full_paths shift s shift "]}," YARD Templates Template ClassMethods reset_full_paths":{"type":"method","name":"reset_full_paths","children":[],"call":[]}," YARD Templates Template ClassMethods full_paths":{"type":"method","name":"full_paths","children":[],"call":["mod full_paths ","mod respond_to? "," included_modules inject "," full_path "," included_modules "," included_modules == "," reset_full_paths "]}," YARD Templates Template include_extra":{"type":"method","name":"include_extra","children":[],"call":["template extend ","mod is_a? ","mod call "," extra_includes each "," extra_includes ","mod call  is_a? ","mod call  call "]}," YARD Templates Template included":{"type":"method","name":"included","children":[],"call":["klass extend "]}," YARD Parser Ruby RipperParser comment_starts_line?":{"type":"method","name":"comment_starts_line?","children":[],"call":["ch != ","ch == ","@source [] ","(send\n  (lvar :charno) :-\n  (int 1)) downto ","charno - ","@source []  != ","@source []  == ","(send\n  (lvar :@source [] arno) :-\n  (int 1)) downto ","@source [] arno - "]}," YARD Parser Ruby ParameterNode double_splat_param":{"type":"method","name":"double_splat_param","children":[],"call":[" [] ","YARD  ruby2? ","node last ","node type == ","node type ","(lvasgn :node\n  (send\n    (self) :[]\n    (int -2))) is_a? "," [] type == "," [] type "," [] is_a? "," []  last "," []  type == "," []  type ","(lvasgn : [] \n  (send\n    (self) :[]\n    (int -2))) is_a? "]}," YARD Parser Ruby ParameterNode unnamed_end_params":{"type":"method","name":"unnamed_end_params","children":[],"call":[" [] "]}," YARD Parser Ruby ParameterNode named_params":{"type":"method","name":"named_params","children":[],"call":[" [] "," [] [] type == "," [] [] type "," [] [] ","YARD  ruby2? "]}," YARD Parser Ruby ParameterNode unnamed_optional_params":{"type":"method","name":"unnamed_optional_params","children":[],"call":["params empty? "," [] "," [] [] type == "," [] [] type "," [] [] "]}," YARD Parser Ruby ParameterNode unnamed_required_params":{"type":"method","name":"unnamed_required_params","children":[],"call":[" [] "]}," YARD CLI YardocOptions file=":{"type":"method","name":"file=","children":[],"call":[]}," YARD Serializers FileSystemSerializer mapped_name":{"type":"method","name":"mapped_name","children":[],"call":["object name to_s ","object name ","map [] ","@name_map [] ","object path downcase ","object path "," build_filename_map ","@name_map ! ","@name_map []  [] ","@name_@name_map []  [] "," build_filename_@name_map []  ","@name_@name_map []  ! "]}," YARD Serializers FileSystemSerializer build_filename_map":{"type":"method","name":"build_filename_map","children":[],"call":["@name_map [] []= ","object name ","@name_map [] ","_ * ","size > ","@name_map [] size ","object path downcase ","object path ","object parent path + + ","object name to_s downcase ","object name to_s ","object parent path + ","object parent path ","object parent ","object parent type != ","object parent type ","YARD Registry  all each ","YARD Registry  all ","@name_map [] size  > ","@name_map [] @name_map [] size  "]}," YARD Handlers Ruby PrivateConstantHandler privatize_constant":{"type":"method","name":"privatize_constant","children":[],"call":[" raise ","node [] ","node source ","const visibility= "," ensure_loaded! ","Proxy  new "," namespace ","node jump ","node [] type == ","node [] type ","node type == ","node type ","node literal? ","node jump  [] ","node jump  source ","Proxy  new  visibility= ","node jump  jump ","node jump  [] type == ","node jump  [] type ","node jump  type == ","node jump  type ","node jump  literal? "]}," DecoratorHandlerMethods process_decorator_parameter":{"type":"method","name":"process_decorator_parameter","children":[],"call":["name to_sym ","block call "," block_given? ","method add_tag ","tags each ","method docstring= "," statement docstring "," statement ","method tags ","method respond_to? ","method docstring empty? ","method docstring ","node def? ","YARD Tags Tag  new "," statement jump jump source "," statement jump jump "," statement jump ","method source= "," statement source ","YARD CodeObjects Proxy  new ","(if\n  (send\n    (lvar :scope) :==\n    (sym :instance))\n  (str \"#\")\n  (str \".\")) + ","name to_s ","scope == "," namespace ","node jump source ","node jump ","node jump method_name source ","node jump method_name "," process_decorator_parameter ","node decorators map ","node decorators ","node respond_to? ","node call? ","opts fetch "," raise ","name nil? ","node jump source  to_sym ","node jump method_name source  to_sym ","YARD CodeObjects Proxy  new  add_tag ","method tags  each ","YARD CodeObjects Proxy  new  docstring= ","method method tags  ","YARD CodeObjects Proxy  new  tags ","YARD CodeObjects Proxy  new  respond_to? ","YARD CodeObjects Proxy  new  docstring empty? ","YARD CodeObjects Proxy  new  docstring ","YARD CodeObjects Proxy  new  source= ","(if\n  (send\n    (lvar :opts fetch ) :==\n    (sym :instance))\n  (str \"#\")\n  (str \".\")) + ","node jump source  to_s ","node jump method_name source  to_s ","opts fetch  == "," node jump source space "," node jump method_name source space ","node jump YARD CodeObjects Proxy  new _name source ","node jump method_node jump source  source ","node jump method_node jump method_name source  source ","node jump YARD CodeObjects Proxy  new _name ","node jump method_node jump source  ","node jump method_node jump method_name source  ","node jump source  nil? ","node jump method_name source  nil? "]}," DecoratorHandlerMethods process_decorator":{"type":"method","name":"process_decorator","children":[],"call":["h [] ","decorated_methods map "," statement define_singleton_method "," statement ","(send\n  (lvar :selected_nodes) :map) flatten "," process_decorator_parameter ","selected_nodes map ","nodes first == ","nodes first ","nodes count == ","nodes count ","nodes empty? "," parse_block ","param def? ","param call? ","all_nodes each ","p is_a? "," statement parameters select "," statement parameters ","nodes pop ","nodes last is_a? ","nodes last ","nodes first nil? ","(send\n  (lvar :selected_nodes) :map) flatten  map "]}," YARD Handlers C HandlerMethods record_parameters":{"type":"method","name":"record_parameters","children":[],"call":["object parameters= ","s [] ","params drop map ","params drop ","params [] =~ ","params [] ","$~ [] split ","$~ [] ","src source =~ ","src source ","$~ [] split  drop map ","$~ [] split  drop ","$~ [] split  [] =~ ","$~ [] split  [] "]}," YARD Handlers C Base ensure_variable_defined!":{"type":"method","name":"ensure_variable_defined!","children":[],"call":[" raise "," parser parse_remaining_files "," parser "," log debug "," parser file "," log ","retries <= ","object is_a? "," namespace_for_variable "," loop ","retries > "," namespace_for_variable  is_a? "]}," YARD Templates Helpers TextHelper resolve_links":{"type":"method","name":"resolve_links","children":[],"call":[" linkify ","name [] == ","name [] ","match [] ","text gsub "]}," YARD Helpers HtmlHelper insert_include":{"type":"method","name":"insert_include","children":[],"call":[" htmlify gsub "," htmlify "]}," YARD Server Router route_static":{"type":"method","name":"route_static","children":[],"call":["StaticFileCommand  new call "," request ","StaticFileCommand  new "," final_options "]}," YARD Server Router static_prefix":{"type":"method","name":"static_prefix","children":[],"call":[]}," YARD Server Commands RootRequestCommand favicon?":{"type":"method","name":"favicon?","children":[],"call":[" raise "," body= "," status= "," headers []= "," headers "," request path == "," request path "," request "]}," YARD Server Commands RootRequestCommand run":{"type":"method","name":"run","children":[],"call":[" status= "," body= "," request path "," request "," favicon? "," not_found "," static_template_file? "]}," YARD RubygemsHook setup":{"type":"method","name":"setup","children":[],"call":["FileUtils  mkdir_p "," raise ","File  writable? ","File  exist? "," class load_yard "," class "]}," YARD RubygemsHook generate":{"type":"method","name":"generate","children":[],"call":[" install_yard ","File  exist? ! ","File  exist? "," install_yri "," setup ","@spec default_gem? "]}," YARD RubygemsHook install_yri":{"type":"method","name":"install_yri","children":[],"call":[" run_yardoc "," say ","@spec full_name ","FileUtils  rm_rf "]}," YARD RubygemsHook install_yard":{"type":"method","name":"install_yard","children":[],"call":[" run_yardoc "," say ","@spec full_name ","FileUtils  rm_rf "]}," YARD RubygemsHook run_yardoc":{"type":"method","name":"run_yardoc","children":[],"call":[" ui errs puts "," ui errs "," ui ","ex backtrace join ","ex backtrace ","Gem  configuration backtrace ","Gem  configuration ","args join "," alert_error ","@spec full_name "," raise ","Gem FilePermissionError  new ","File  dirname ","e message split [] strip ","e message split [] ","e message split ","e message ","YARD CLI Yardoc  run ","Dir  chdir ","@spec full_gem_path ","arg to_s ","args flatten map ","args flatten ","@spec extra_rdoc_files ","args << ","@spec extra_rdoc_files size > ","@spec extra_rdoc_files size ","@spec require_paths ","File  file? ","File  join ","Gem  configuration really_verbose ","@spec extra_rdoc_files empty? ","args flatten map  join ","File  File  dirname  ","args flatten map  flatten map ","args flatten map  flatten ","args flatten map  << "]}," YARD RubygemsHook initialize":{"type":"method","name":"initialize","children":[],"call":["spec doc_dir "]}," YARD RubygemsHook load_yard":{"type":"method","name":"load_yard","children":[],"call":[]}," YARD RubygemsHook generation_hook":{"type":"method","name":"generation_hook","children":[],"call":[]}," YARD RegistryResolver collect_namespaces":{"type":"method","name":"collect_namespaces","children":[],"call":[" P ","object superclass != ","object superclass ","object respond_to? ","object inheritance_tree ","object ! "]}," YARD RegistryResolver lookup_path_inherited":{"type":"method","name":"lookup_path_inherited","children":[],"call":["type == ","cur_obj type ","type nil? "," types_for_separator ","@registry at ","ns path + + ","ns path + ","search_sep to_s ","ns path ","(send\n  (array\n    (lvar :last_sep)) :|\n  (lvar :search_seps)) compact each ","(send\n  (array\n    (lvar :last_sep)) :|\n  (lvar :search_seps)) compact ","(lvar :last_sep) | "," separators ","last_sep nil? ","ns type == ","ns type ","search_seps empty? "," separators_for_type ","scopes each ","ns is_a? "," collect_namespaces each "," collect_namespaces ","last_obj is_a? ! ","last_obj is_a? ","parsed_end ! ","last_obj ! ","pos == ","path length ","(begin\n  (lvar :part)) length ","path scan each ","path scan "," separators_match ","path =~ "," split_on_separators_match "," starts_with_separator_match ","sep length ","part length ","(send\n  (array\n    (lvar :last_sep)) :|\n  (lvar : separators )) compact each ","(send\n  (array\n    (lvar :last_sep)) :|\n  (lvar : separators )) compact "," separators  empty? ","pos ==  ! "]}," YARD RegistryResolver lookup_path_direct":{"type":"method","name":"lookup_path_direct","children":[],"call":[" validate ","@registry at ","namespace path + + ","namespace path + ","namespace path "," separators each "," separators ","path =~ "," separators_match ","namespace root? "," starts_with_separator_match "]}," YARD RegistryResolver validate":{"type":"method","name":"validate","children":[],"call":["obj type == ","obj type ","type ! "]}," YARD RegistryResolver lookup_by_path":{"type":"method","name":"lookup_by_path","children":[],"call":["CodeObjects Proxy  new ","namespace parent "," lookup_path_inherited "," lookup_path_direct ","resolved ! ","@registry root ","path =~ "," default_separator ","namespace is_a? ","namespace ! ","namespace == ","opts [] ","path to_s ","resolved is_a? ","lexical_lookup > "," starts_with_default_separator_match ","namespace parent  parent ","@registry root  parent ","opts []  parent "," lookup_path to_s _inherited "," lookup_path to_s _direct "," lookup_path_direct  ! ","path to_s  =~ ","namespace parent  is_a? ","@registry root  is_a? ","opts []  is_a? ","namespace parent  ! ","@registry root  ! ","opts []  ! ","namespace parent  == ","@registry root  == ","opts []  == ","path to_s  to_s "," lookup_path_direct  is_a? "]}," YARD RegistryResolver initialize":{"type":"method","name":"initialize","children":[],"call":["YARD CodeObjects  const_get ","YARD CodeObjects  constants map ","YARD CodeObjects  constants "]}," YARD Registry thread_local_resolver":{"type":"method","name":"thread_local_resolver","children":[],"call":["RegistryResolver  new ","Thread  current [] ","Thread  current "]}," YARD Registry old_global_yardoc_file":{"type":"method","name":"old_global_yardoc_file","children":[],"call":["File  exist? ","for_writing ! ","File  writable? ","File  join ","spec full_gem_path ","spec full_gem_spec full_gem_path  "]}," YARD Parser Ruby RipperParser on_sp":{"type":"method","name":"on_sp","children":[],"call":["tok length "," add_token "]}," YARD Parser Ruby RubyParser frozen_string_line":{"type":"method","name":"frozen_string_line","children":[],"call":["@parser frozen_string_line "]}," YARD Handlers Ruby DSLHandlerMethods macro_name_matches":{"type":"method","name":"macro_name_matches","children":[],"call":["obj name to_s == "," caller_method to_s "," caller_method ","obj name to_s ","obj name ","objs any? ","objs push ","objs first aliases ","objs first ","objs first respond_to? ","objs first type != ","objs first type ","macro method_object ","objs concat "]}," YARD DocstringParser post_process":{"type":"method","name":"post_process","children":[],"call":[" call_after_parse_callbacks "]}," YARD CodeObjects NamespaceMapper map_match":{"type":"method","name":"map_match","children":[],"call":["(send\n  (send\n    (ivar :@map) :keys) :map) join ","Regexp  quote ","@map keys map ","@map keys ","(send\n  (send\n    (send nil :map) :keys) :map) join "," map keys map "," map keys "," map "]}," YARD CodeObjects NamespaceMapper invalidate":{"type":"method","name":"invalidate","children":[],"call":["(or\n  (ivar :@invalidation_callbacks)\n  (array)) each "]}," YARD CodeObjects NamespaceMapper rev_map":{"type":"method","name":"rev_map","children":[],"call":[]}," YARD CodeObjects NamespaceMapper map":{"type":"method","name":"map","children":[],"call":[]}," YARD CodeObjects NamespaceMapper separators_for_type":{"type":"method","name":"separators_for_type","children":[],"call":["NamespaceMapper  rev_map [] ","NamespaceMapper  rev_map "]}," YARD CodeObjects NamespaceMapper types_for_separator":{"type":"method","name":"types_for_separator","children":[],"call":["NamespaceMapper  map [] ","NamespaceMapper  map "]}," YARD CodeObjects NamespaceMapper separators_match":{"type":"method","name":"separators_match","children":[],"call":["NamespaceMapper  map_match "]}," YARD CodeObjects NamespaceMapper separators":{"type":"method","name":"separators","children":[],"call":["NamespaceMapper  map keys ","NamespaceMapper  map "]}," YARD CodeObjects NamespaceMapper default_separator":{"type":"method","name":"default_separator","children":[],"call":["NamespaceMapper  default_separator ","NamespaceMapper  default_separator= ","Regexp  quote ","NamespaceMapper  invalidate "]}," YARD CodeObjects NamespaceMapper clear_separators":{"type":"method","name":"clear_separators","children":[],"call":["NamespaceMapper  rev_map= ","NamespaceMapper  map= ","NamespaceMapper  invalidate "]}," YARD CodeObjects NamespaceMapper register_separator":{"type":"method","name":"register_separator","children":[],"call":["NamespaceMapper  map [] ","NamespaceMapper  map ","NamespaceMapper  rev_map [] << ","NamespaceMapper  rev_map [] ","NamespaceMapper  rev_map ","valid_types each ","NamespaceMapper  invalidate "]}," YARD CLI Stats stats_for_attributes":{"type":"method","name":"stats_for_attributes","children":[],"call":[" output ","undoc size ","objs size ","m docstring blank? ","m docstring ","objs select ","m name to_s gsub ","m name to_s ","m name ","objs uniq! ","m is_attribute? ","m type == ","m type "," all_objects select "," all_objects "]}," YARD Templates Helpers HtmlSyntaxHighlightHelper clean_token_object":{"type":"method","name":"clean_token_object","children":[],"call":[" run_verifier first "," run_verifier "," prune_method_listing first "," prune_method_listing ","token_obj is_a? ","token_obj == "," object "," run_verifier first  is_a? "," prune_method_listing first  is_a? "," run_verifier first  == "," prune_method_listing first  == "]}," YARD Helpers HtmlHelper mtime":{"type":"method","name":"mtime","children":[],"call":[]}," YARD Helpers HtmlHelper html_markup_org":{"type":"method","name":"html_markup_org","children":[],"call":[" markup_class new to_html "," markup_class new "," markup_class "]}," YARD Tags TypesExplainer Parser parse":{"type":"method","name":"parse","children":[],"call":[" raise ","@scanner peek ","types << ","Type  new ","name nil? ","HashCollectionType  new "," parse ","klass new ","token_type == ","@scanner pos ","@scanner scan ","@scanner eos? ","match nil? ","TOKENS  each "," loop ","Type  new s << ","HashCollectionType  new s << ","klass new s << ","token_Type  new  == ","token_HashCollectionType  new  == ","token_klass new  == ","@scanner scan _type == "]}," YARD Tags TypesExplainer Parser initialize":{"type":"method","name":"initialize","children":[],"call":["StringScanner  new "]}," YARD Tags TypesExplainer HashCollectionType to_s":{"type":"method","name":"to_s","children":[],"call":["(str \"a\") + + + + ","(str \"a\") + + + "," list_join ","t to_s "," value_types map "," value_types ","(str \"a\") + + ","(str \"a\") + "," key_types map "," key_types "," name "," name [] =~ "," name [] "]}," YARD Tags TypesExplainer HashCollectionType initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Tags TypesExplainer FixedCollectionType to_s":{"type":"method","name":"to_s","children":[],"call":["(str \"a\") + + ","(str \"a\") + "," types map join "," types map "," types "," name "," name [] =~ "," name [] "]}," YARD Tags TypesExplainer CollectionType to_s":{"type":"method","name":"to_s","children":[],"call":["(str \"a\") + + ","(str \"a\") + "," list_join ","t to_s "," types map "," types "," name "," name [] =~ "," name [] "]}," YARD Tags TypesExplainer CollectionType initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Tags TypesExplainer Type list_join":{"type":"method","name":"list_join","children":[],"call":["acc << ","index == ","list size - ","list size ","index < ","el to_s ","list inject ","String  new "]}," YARD Tags TypesExplainer Type to_s":{"type":"method","name":"to_s","children":[],"call":[" name "," name [] =~ "," name [] ","(str \"a\") + "," name [] == "]}," YARD Tags TypesExplainer Type initialize":{"type":"method","name":"initialize","children":[],"call":[]}," YARD Tags TypesExplainer explain!":{"type":"method","name":"explain!","children":[],"call":[]}," YARD Tags TypesExplainer explain":{"type":"method","name":"explain","children":[],"call":[]}," YARD Tags Tag explain_types":{"type":"method","name":"explain_types","children":[],"call":["TypesExplainer  explain "," types "," types empty? "," types ! "]}," YARD Server LibraryVersion serializer":{"type":"method","name":"serializer","children":[],"call":["Serializers YardocSerializer  new "," yardoc_file "," yardoc_file nil? "]}," YARD Server LibraryVersion load_yardoc_file":{"type":"method","name":"load_yardoc_file","children":[],"call":[" send "," respond_to? "," source "]}," YARD Server LibraryVersion yardoc_file_for_gem":{"type":"method","name":"yardoc_file_for_gem","children":[],"call":["Registry  yardoc_file_for_gem "," name "," version "," require "]}," YARD Server LibraryVersion ready?":{"type":"method","name":"ready?","children":[],"call":[" serializer complete? "," serializer "," yardoc_file nil? "," yardoc_file "]}," YARD Server LibraryVersion source_path":{"type":"method","name":"source_path","children":[],"call":[" load_source_path "]}," YARD Server LibraryVersion yardoc_file":{"type":"method","name":"yardoc_file","children":[],"call":[" load_yardoc_file "]}," YARD Server DocServerHelper mtime_url":{"type":"method","name":"mtime_url","children":[],"call":["url + "," mtime "," url_for "," url_for  + "," m mtime  ","  url_for _for "]}," YARD Server DocServerHelper mtime":{"type":"method","name":"mtime","children":[],"call":["File  mtime to_i ","File  mtime ","YARD Server Commands StaticFileHelpers  find_file ","YARD Server Commands StaticFileHelpers  find_YARD Server Commands StaticFileHelpers  find_file  "]}," YARD Server DocServerHelper abs_url":{"type":"method","name":"abs_url","children":[],"call":["File  join "," router request script_name "," router request "," router "]}," YARD Server Commands StaticFileHelpers find_file":{"type":"method","name":"find_file","children":[],"call":["assets_template find_file ","Templates Engine  template ","File  exist? "," p ","File  join ","(send\n  (array\n    (send\n      (lvar :adapter) :document_root)) :+\n  (send\n    (lvar :static_paths) :reverse)) compact each ","(send\n  (array\n    (send\n      (lvar :adapter) :document_root)) :+\n  (send\n    (lvar :static_paths) :reverse)) compact ","(send\n  (lvar :adapter) :document_root) + ","static_paths reverse ","adapter document_root ","Templates Engine  template  find_file ","assets_template find_File  join  "]}," YARD Server Commands StaticFileHelpers static_template_file?":{"type":"method","name":"static_template_file?","children":[],"call":[" raise "," body= ","File  read "," headers []= "," mime_type "," headers ",". + "," path [] "," path "," find_file "," adapter ","assets_template find_file ","File  exist? ","File  join ","(send\n  (array\n    (send\n      (send nil :adapter) :document_root)) :+\n  (send\n    (lvar :static_paths) :reverse)) compact each ","(send\n  (array\n    (send\n      (send nil :adapter) :document_root)) :+\n  (send\n    (lvar :static_paths) :reverse)) compact ","(send\n  (send nil :adapter) :document_root) + ","static_paths reverse "," adapter document_root ","Templates Engine  template "," find_ find_file  "," find_File  join  ","assets_template find_ find_file  ","assets_template find_File  join  ","Templates Engine  template  find_file "]}," YARD Server Commands StaticFileHelpers favicon?":{"type":"method","name":"favicon?","children":[],"call":[" raise "," body= "," status= "," headers []= "," headers "," request path == "," request path "," request "]}," YARD Server Commands LibraryCommand can_fork?":{"type":"method","name":"can_fork?","children":[],"call":[" use_fork "]}," YARD Server Commands LibraryCommand call_with_fork":{"type":"method","name":"call_with_fork","children":[],"call":["Marshal  load ","reader read ","writer close ","writer print ","Marshal  dump "," call_without_fork ","reader close "," log debug ","request path ","Process  pid "," log "," fork ","IO  pipe "]}," YARD Server Commands LibraryCommand call_without_fork":{"type":"method","name":"call_without_fork","children":[],"call":[" not_prepared "," options title= ","(str \"Documentation for \") + ","( + + ","( + "," library version "," library "," library name "," options "," setup_library "," options command= "," options reset_defaults "," options= ","LibraryOptions  new "," request= "]}," YARD Server Commands Base add_cache_control":{"type":"method","name":"add_cache_control","children":[],"call":[" headers []= "," headers "," request query_string to_i == "," request query_string to_i "," request query_string "," request "," headers [] "]}," YARD Serializers YardocSerializer locked_for_writing?":{"type":"method","name":"locked_for_writing?","children":[],"call":["File  exist? "," processing_path "]}," YARD Serializers YardocSerializer lock_for_writing":{"type":"method","name":"lock_for_writing","children":[],"call":["File  unlink "," processing_path ","File  exist? ","File  open! "]}," YARD Serializers YardocSerializer complete?":{"type":"method","name":"complete?","children":[],"call":[" locked_for_writing? ! "," locked_for_writing? ","File  exist? "," complete_lock_path "]}," YARD Serializers YardocSerializer processing_path":{"type":"method","name":"processing_path","children":[],"call":["File  join "," basepath "]}," YARD Serializers YardocSerializer complete_lock_path":{"type":"method","name":"complete_lock_path","children":[],"call":["File  join "," basepath "]}," YARD RubygemsHook remove":{"type":"method","name":"remove","children":[],"call":[" uninstall_yard "," uninstall_yri "]}," YARD RubygemsHook uninstall_yri":{"type":"method","name":"uninstall_yri","children":[],"call":["FileUtils  rm_rf "," raise ","File  writable? ","File  exist? "]}," YARD RubygemsHook uninstall_yard":{"type":"method","name":"uninstall_yard","children":[],"call":["FileUtils  rm_rf "," raise ","File  writable? ","File  exist? "]}," YARD RubygemsHook removal_hook":{"type":"method","name":"removal_hook","children":[],"call":[]}," YARD RegistryStore write_complete_lock":{"type":"method","name":"write_complete_lock","children":[],"call":["File  open! ","@serializer complete_lock_path "]}," YARD RegistryStore locked_for_writing?":{"type":"method","name":"locked_for_writing?","children":[],"call":["Serializers YardocSerializer  new locked_for_writing? ","Serializers YardocSerializer  new "]}," YARD RegistryStore lock_for_writing":{"type":"method","name":"lock_for_writing","children":[],"call":["Serializers YardocSerializer  new lock_for_writing ","Serializers YardocSerializer  new "]}," YARD Registry locked_for_writing?":{"type":"method","name":"locked_for_writing?","children":[],"call":[" thread_local_store locked_for_writing? "," thread_local_store "]}," YARD Registry lock_for_writing":{"type":"method","name":"lock_for_writing","children":[],"call":[" thread_local_store lock_for_writing "," thread_local_store "]}," YARD Parser Ruby TokenResolver object_resolved_types":{"type":"method","name":"object_resolved_types","children":[],"call":["resolved_types << ","Registry  resolve ","obj parent ","type == ","type sub ","tag types each ","tag types ","tag types nil? ","tags each ","(send\n  (send\n    (lvar :obj) :tags\n    (sym :overload)) :map) flatten ","o tags ","obj tags map ","obj tags ","obj is_a? ","resolved_type sub s << ","type sub  == ","type sub  sub ","tag type sub s each ","tag type sub s ","tag type sub s nil? ","obj tags  each ","(send\n  (send\n    (lvar :obj) :obj tags \n    (sym :overload)) :map) flatten ","o obj tags  ","obj obj tags  map ","obj obj tags  "]}," YARD Parser Ruby TokenResolver lookup":{"type":"method","name":"lookup","children":[],"call":[" object= "," next_object= "," object ","obj nil? ","Registry  resolve ","name == ","types any? ","(if\n  (lvar :type)\n  (send\n    (lvar :type) :path)\n  (str \"\")) + "," last_sep to_s "," last_sep ","type path ","toktype == ","types empty? "," object_resolved_types "," separators include? "," separators "," Registry  resolve ect= "," next_Registry  resolve ect= "," Registry  resolve ect ","Registry  resolve  nil? "," object_resolved_types  any? "," object_resolved_types  empty? "," Registry  resolve ect_resolved_types "," object_resolved_ object_resolved_types  "]}," YARD Parser Ruby TokenResolver pop_state":{"type":"method","name":"pop_state","children":[],"call":["@states pop "]}," YARD Parser Ruby TokenResolver push_state":{"type":"method","name":"push_state","children":[],"call":["@states push "]}," YARD Parser Ruby TokenResolver state_attr":{"type":"method","name":"state_attr","children":[],"call":[]}," YARD Parser Ruby TokenResolver each":{"type":"method","name":"each","children":[],"call":[" skip_group= "," object nil? "," object "," next_object= "," object= "," next_object "," pop_state "," push_state "," last_sep= ","CodeObjects  types_for_separator ","token [] "," lookup ","(sym :const) include? "," skip_group ","@tokens each "]}," YARD Parser Ruby TokenResolver initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","source empty? ! ","source empty? ","@tokens empty? ","RubyParser  parse tokens ","RubyParser  parse ","RubyParser  parse tokens  empty? "]}," YARD Logger warn":{"type":"method","name":"warn","children":[],"call":[" warned= "]}," YARD GemIndex all":{"type":"method","name":"all","children":[],"call":[" each to_a "," each "]}," YARD GemIndex each":{"type":"method","name":"each","children":[],"call":["Gem  source_index find_name each ","Gem  source_index find_name ","Gem  source_index ","Gem Specification  each ","Gem Specification  respond_to? "]}," YARD GemIndex find_all_by_name":{"type":"method","name":"find_all_by_name","children":[],"call":["Gem  source_index find_name ","Gem  source_index ","Gem Specification  find_all_by_name ","Gem Specification  respond_to? "]}," SymbolHash key?":{"type":"method","name":"key?","children":[],"call":["key to_sym "]}," YARD CLI Config configure_gemrc":{"type":"method","name":"configure_gemrc","children":[],"call":[" log puts ","Gem  configuration path ","Gem  configuration "," log ","Gem  configuration write ","Gem  configuration []= ","conf join "," gem_install_cmd ","c =~ ","conf delete_if ","conf split ","cmd != ","conf empty? ","Gem  configuration [] ","(str \"install\") find "," require ","Gem  conf join iguration path ","Gem  conf split iguration path ","Gem  conf join iguration ","Gem  conf split iguration ","Gem  conf join iguration write ","Gem  conf split iguration write ","Gem  conf join iguration []= ","Gem  conf split iguration []= ","conf join  join ","conf split  join ","conf join  delete_if ","conf split  delete_if ","conf join  split ","conf split  split ","conf join  empty? ","conf split  empty? ","Gem  conf join iguration [] ","Gem  conf split iguration [] "]}," YARD CLI Yardoc extra_file_valid?":{"type":"method","name":"extra_file_valid?","children":[],"call":[" log warn "," log ","File  file? ! ","File  file? ","file =~ "]}," YARD Docstring stable_sort_by":{"type":"method","name":"stable_sort_by","children":[],"call":["(send\n  (send\n    (lvar :list) :each_with_index) :sort_by) map ","list each_with_index sort_by ","list each_with_index "]}," Handlers Common MethodHandler add_predicate_return_tag":{"type":"method","name":"add_predicate_return_tag","children":[],"call":["obj add_tag ","YARD Tags Tag  new ","overload tag ","obj tags any? ","obj tags ","obj tag nil? ","obj tag ","obj tag types= ","(or\n  (send\n    (send\n      (lvar :obj) :tag\n      (sym :return)) :types)\n  (array)) empty? ","obj tag types "]}," YARD Parser Ruby RipperParser on_dyna_symbol":{"type":"method","name":"on_dyna_symbol","children":[],"call":["AstNode  new "," lineno ","sym source_range end + ","sym source_range end ","sym source_range ","sym source_range begin - ","sym source_range begin ","sym source_range size == ","sym source_range size ","sym source_range to_a size == ","sym source_range to_a size ","sym source_range to_a "]}," YARD Helpers HtmlHelper detect_lang_in_codeblock_attributes":{"type":"method","name":"detect_lang_in_codeblock_attributes","children":[],"call":[]}," YARD RegistryResolver invalidate_memoized_matchers":{"type":"method","name":"invalidate_memoized_matchers","children":[],"call":[]}," YARD RegistryResolver split_on_separators_match":{"type":"method","name":"split_on_separators_match","children":[],"call":[" separators_match "]}," YARD RegistryResolver starts_with_separator_match":{"type":"method","name":"starts_with_separator_match","children":[],"call":[" separators_match "]}," YARD RegistryResolver starts_with_default_separator_match":{"type":"method","name":"starts_with_default_separator_match","children":[],"call":[" default_separator "]}," YARD RegistryResolver default_separator":{"type":"method","name":"default_separator","children":[],"call":[]}," YARD RegistryResolver clear_separators":{"type":"method","name":"clear_separators","children":[],"call":[" invalidate_memoized_matchers "]}," YARD RegistryResolver register_separator":{"type":"method","name":"register_separator","children":[],"call":[" invalidate_memoized_matchers "]}," IRB SLex Node match_io":{"type":"method","name":"match_io","children":[],"call":["@postproc call ","D_DETAIL  printf ","@preproc call ","@preproc nil? ","io ungetc ","op inspect ","DOUT  exec_if ","node match_io ","op + ","@Tree [] ","ch nil? ","io getc_of_rests ","ch == ","io getc ","op == ","@Tree []  match_io ","node matio getc_of_rests _io ","node matio getc _io ","io getc_of_rests  nil? ","io getc  nil? ","io getc_of_rests  == ","io getc  == "]}," IRB SLex Node match":{"type":"method","name":"match","children":[],"call":["@postproc call ","DOUT  printf ","@preproc call ","@preproc nil? ","chrs unshift ","op inspect ","node match ","op + ","@Tree [] ","chrs shift ","chrs empty? ","D_DETAIL  print ","chrs shift rs unshift ","@Tree []  match ","node matchrs shift  ","chrs shift rs shift ","chrs shift rs empty? "]}," IRB SLex Node create_subnode":{"type":"method","name":"create_subnode","children":[],"call":["@Tree []= ","node create_subnode ","Node  new ","chrs empty? ","node postproc= ","node preproc= ","D_WARN  puts "," raise ","DebugLogger  pp ","node postproc ","@Tree [] ","chrs shift ","D_DEBUG  puts ","D_DETAIL  pp "," node ","Node  new  create_subNode  new  ","@Tree []  create_sub@Tree []  ","chrs shift rs empty? ","Node  new  postproc= ","@Tree []  postproc= ","Node  new  preproc= ","@Tree []  preproc= ","Node  new  postproc ","@Tree []  postproc ","chrs shift rs shift "," Node  new  "," @Tree []  "]}," IRB SLex Node search":{"type":"method","name":"search","children":[],"call":[" raise "," create_subnode ","chrs unshift ","node search ","@Tree [] ","chrs shift ","chrs empty? "," create_sub@Tree []  ","chrs shift rs unshift ","@Tree []  search ","node searchrs shift  ","chrs shift rs shift ","chrs shift rs empty? "]}," IRB SLex Node initialize":{"type":"method","name":"initialize","children":[],"call":[]}," IRB SLex inspect":{"type":"method","name":"inspect","children":[],"call":[" format ","@head inspect "]}," IRB SLex match":{"type":"method","name":"match","children":[],"call":["D_DETAIL  printf ","token inspect ","D_DETAIL  exec_if ","@head match ","@head match_io "," match ","token split "]}," IRB SLex create":{"type":"method","name":"create","children":[],"call":["@head create_subnode ","token split "]}," IRB SLex search":{"type":"method","name":"search","children":[],"call":["@head search ","token split "]}," IRB SLex postproc":{"type":"method","name":"postproc","children":[],"call":["node postproc= "," proc "," search "," search  postproc= "]}," IRB SLex preproc":{"type":"method","name":"preproc","children":[],"call":["node preproc= "," search "," search  preproc= "]}," IRB SLex def_rules":{"type":"method","name":"def_rules","children":[],"call":[" def_rule "," block_given? "]}," IRB SLex def_rule":{"type":"method","name":"def_rule","children":[],"call":[" create "," block_given? ","D_DETAIL  pp "]}," IRB SLex initialize":{"type":"method","name":"initialize","children":[],"call":["Node  new "]}," YARD Parser Ruby MethodDefinitionNode signature":{"type":"method","name":"signature","children":[],"call":[" method_name ","params source gsub ","params source ","params type == ","params type ","params first "," [] ","1 + "," index_adjust "," []  source gsub "," []  source "," []  type == "," []  type "," []  first "]}," MixinHandler recipient":{"type":"method","name":"recipient","children":[],"call":[" namespace ","Proxy  new "," statement namespace source "," statement namespace "," statement "," statement [] [] type == "," statement [] [] type "," statement [] [] "," statement [] "," statement [] [] != "," s "," statement [] type == "," statement [] type "," statement [] source "]}," YARD CodeObjects NamespaceMapper on_invalidate":{"type":"method","name":"on_invalidate","children":[],"call":["(or-asgn\n  (ivasgn :@invalidation_callbacks)\n  (array)) push "]}," YARD CodeObjects NamespaceMapper unregister_separator_by_type":{"type":"method","name":"unregister_separator_by_type","children":[],"call":["NamespaceMapper  invalidate ","NamespaceMapper  rev_map delete ","NamespaceMapper  rev_map ","NamespaceMapper  map delete ","NamespaceMapper  map ","seps each ","NamespaceMapper  rev_map [] ","NamespaceMapper  rev_map []  each "]}," YARD ruby3?":{"type":"method","name":"ruby3?","children":[],"call":[]}," YARD Tags Directive inside_directive?":{"type":"method","name":"inside_directive?","children":[],"call":["d tag text empty? ","d tag text ","d tag ","d is_a? "," parser directives any? "," parser directives "," parser "," parser state inside_directive "," parser state "]}," ModuleFunctionHandler make_module_function":{"type":"method","name":"make_module_function","children":[],"call":["class_method visibility= ","instance_method copy_to ","MethodObject  new ","instance_method name ","MethodObject  new  visibility= "]}," YARD ruby31?":{"type":"method","name":"ruby31?","children":[],"call":[]}," YARD Parser Ruby ParameterNode args_forward":{"type":"method","name":"args_forward","children":[],"call":[" [] type == "," [] type "," [] ","YARD  ruby31? "]}," YARD Server RackRefinements xhr?":{"type":"method","name":"xhr?","children":[],"call":["(or\n  (send\n    (send nil :env) :[]\n    (str \"HTTP_X_REQUESTED_WITH\"))\n  (str \"\")) casecmp == ","(or\n  (send\n    (send nil :env) :[]\n    (str \"HTTP_X_REQUESTED_WITH\"))\n  (str \"\")) casecmp "," env [] "," env "]}," Server HTTPUtils escape8bit":{"type":"method","name":"escape8bit","children":[],"call":[" _escape "]}," Server HTTPUtils escape_path":{"type":"method","name":"escape_path","children":[],"call":["result << << "," _escape ","i [] ","result << ","str scan each ","str scan "]}," Server HTTPUtils unescape_form":{"type":"method","name":"unescape_form","children":[],"call":[" _unescape ","str gsub "]}," Server HTTPUtils escape_form":{"type":"method","name":"escape_form","children":[],"call":["ret gsub! "," _escape "," _escape  gsub! "]}," Server HTTPUtils unescape":{"type":"method","name":"unescape","children":[],"call":[" _unescape "]}," Server HTTPUtils escape":{"type":"method","name":"escape","children":[],"call":[" _escape "]}," Server HTTPUtils _unescape":{"type":"method","name":"_unescape","children":[],"call":["1 hex chr ","1 hex ","str gsub! ","str b ","str b  gsub! ","str b  b "]}," Server HTTPUtils _escape":{"type":"method","name":"_escape","children":[],"call":["str force_encoding ","%%%02X % ","1 ord ","str gsub! ","str b ","str b  force_encoding ","str b  gsub! ","str b  b "]}," Server HTTPUtils _make_regex!":{"type":"method","name":"_make_regex!","children":[],"call":["Regexp  escape "]}," Server HTTPUtils _make_regex":{"type":"method","name":"_make_regex","children":[],"call":["Regexp  escape "]}," Server HTTPUtils parse_form_data":{"type":"method","name":"parse_form_data","children":[],"call":["data << ","FormData  new ","form_data []= ","form_data [] append_data ","form_data [] ","form_data has_key? ","data name ","data chop! ","boundary_regexp =~ ","io each_line ","Hash  new ","Regexp  quote ","FormData  new  << ","form_FormData  new  []= ","Hash  new  []= ","form_FormData  new  [] append_FormData  new  ","Hash  new  [] append_data ","form_FormData  new  [] ","Hash  new  [] ","form_FormData  new  has_key? ","form_data has_data name ? ","Hash  new  has_key? ","FormData  new  name ","FormData  new  chop! "]}," Server HTTPUtils parse_query":{"type":"method","name":"parse_query","children":[],"call":["query []= ","query [] append_data ","query [] ","query has_key? ","val name= ","FormData  new "," unescape_form ","val to_s ","x split ","x empty? ","str split each ","str split ","Hash  new ","Hash  new  []= ","Hash  new  [] append_data ","Hash  new  [] ","query has_ unescape_form ? ","Hash  new  has_key? ","FormData  new  name= "," unescape_form  name= ","FormData  new  to_s "," unescape_form  to_s "]}," Server HTTPUtils FormData to_s":{"type":"method","name":"to_s","children":[],"call":["String  new "]}," Server HTTPUtils FormData list":{"type":"method","name":"list","children":[],"call":["ret << ","data to_s "," each_data "]}," Server HTTPUtils FormData each_data":{"type":"method","name":"each_data","children":[],"call":["tmp next_data ","tmp tmp next_data  "]}," Server HTTPUtils FormData append_data":{"type":"method","name":"append_data","children":[],"call":["tmp next_data ","tmp next_data= ","tmp next_data  next_data ","tmp next_data  next_data= "]}," Server HTTPUtils FormData <<":{"type":"method","name":"<<","children":[],"call":["@raw_header << "," [] ","HTTPUtils  parse_header ","@raw_header join ","str == "]}," Server HTTPUtils FormData []":{"type":"method","name":"[]","children":[],"call":["@header [] join ","@header [] ","key [] downcase ","key [] "]}," Server HTTPUtils FormData initialize":{"type":"method","name":"initialize","children":[],"call":[" class new "," class ","args empty? ","args shift "]}," Server HTTPUtils quote":{"type":"method","name":"quote","children":[],"call":["\" << << ","\" << ","str gsub "]}," Server HTTPUtils dequote":{"type":"method","name":"dequote","children":[],"call":["ret gsub! ","str dup ","str dup  gsub! "]}," Server HTTPUtils parse_qvalues":{"type":"method","name":"parse_qvalues","children":[],"call":["tmp collect! ","q -@ ","tmp sort_by ","tmp push ","(or\n  (send\n    (lvar :m) :[]\n    (int 2))\n  (int 1)) to_f ","m [] ","(str \"^([^\\\\s,]+?)(?:;\\\\s*q=(\\\\d+(?:\\\\.\\\\d+)?))?$\") match ","parts each ","value split ","t(str \"^([^\\s,]+?)(?:;\\s*q=(\\d+(?:\\.\\d+)?))?$\") match p collect! ","(or\n  (send\n    (lvar :m) :[]\n    (int 2))\n  (int 1)) to_f  -@ ","t(str \"^([^\\s,]+?)(?:;\\s*q=(\\d+(?:\\.\\d+)?))?$\") match p sort_by ","t(str \"^([^\\s,]+?)(?:;\\s*q=(\\d+(?:\\.\\d+)?))?$\") match p push ","(or\n  (send\n    (lvar :(str \"^([^\\s,]+?)(?:;\\s*q=(\\d+(?:\\.\\d+)?))?$\") match ) :[]\n    (int 2))\n  (int 1)) to_f ","(str \"^([^\\s,]+?)(?:;\\s*q=(\\d+(?:\\.\\d+)?))?$\") match  [] ","(str \"^([^\\\\s,]+?)(?:;\\\\s*(or\n  (send\n    (lvar :m) :[]\n    (int 2))\n  (int 1)) to_f =(\\\\d+(?:\\\\.\\\\d+)?))?$\") match ","(str \"^([^\\\\s,]+?)(?:;\\\\s*q=(\\\\d+(?:\\\\.\\\\d+)?))?$\") (str \"^([^\\s,]+?)(?:;\\s*q=(\\d+(?:\\.\\d+)?))?$\") match atch ","value split  each ","m [] ue split "]}," Server HTTPUtils parse_range_header":{"type":"method","name":"parse_range_header","children":[],"call":["(send\n  (nth-ref 1) :to_i) -@ ","1 to_i ","2 to_i ","byte_range_set collect "," split_header_value "," split_header_value  collect "]}," Server HTTPUtils split_header_value":{"type":"method","name":"split_header_value","children":[],"call":["str scan flatten ","str scan "]}," Server HTTPUtils parse_header":{"type":"method","name":"parse_header","children":[],"call":["values each ","header each "," raise ","header [] [] << << ","header [] [] << ","header [] [] ","header [] ","header [] << ","header []= ","header has_key? ","field downcase! ","raw each_line ","Hash  new "," freeze ","Hash  new  each ","Hash  new  [] [] << << ","Hash  new  [] [] << ","Hash  new  [] [] ","Hash  new  [] ","Hash  new  [] << ","Hash  new  []= ","Hash  new  has_key? "]}," Server HTTPUtils mime_type":{"type":"method","name":"mime_type","children":[],"call":["mime_tab [] ","1 downcase "]}," Server HTTPUtils load_mime_types":{"type":"method","name":"load_mime_types","children":[],"call":["hash []= ","ext0 split each ","ext0 split ","ext0 empty? ","line split ","line chomp! ","io each ","Hash  new "," open ","Hash  new  []= "]}," Server HTTPUtils normalize_path":{"type":"method","name":"normalize_path","children":[],"call":[" raise ","ret sub! ","ret gsub! ","path dup ","path [] != ","path [] ","path dup  sub! ","path dup  gsub! "]}}