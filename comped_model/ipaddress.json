{" IPAddress":{"type":"method","name":"IPAddress","children":[],"call":["IPAddress IPv6  new ","IPAddress IPv4  new ","IPAddress IPv6 Mapped  new ","IPAddress  parse "]}," IPAddress Prefix128 to_u128":{"type":"method","name":"to_u128","children":[],"call":[" eval "," bits "," bits to_i "]}," IPAddress Prefix128 bits":{"type":"method","name":"bits","children":[],"call":["1 * + ","0 * ","128 - ","1 * "]}," IPAddress Prefix128 initialize":{"type":"method","name":"initialize","children":[],"call":["num to_i "," raise ","(irange\n  (int 1)\n  (int 128)) include? ","(irange\n  (int 0)\n  (int 128)) include? "]}," IPAddress Prefix32 parse_netmask":{"type":"method","name":"parse_netmask","children":[],"call":[]}," IPAddress Prefix32 hostmask":{"type":"method","name":"hostmask","children":[],"call":["(send\n  (send nil :to_u32) :~) pack unpack join ","(send\n  (send nil :to_u32) :~) pack unpack ","(send\n  (send nil :to_u32) :~) pack "," to_u32 ~ "," to_u32 "]}," IPAddress Prefix32 []":{"type":"method","name":"[]","children":[],"call":[" octets [] "," octets "]}," IPAddress Prefix32 to_u32":{"type":"method","name":"to_u32","children":[],"call":["(send nil :bits) pack unpack first ","(send nil :bits) pack unpack ","(send nil :bits) pack "," bits ","(send\n  (const nil :IN4MASK) :>>\n  (send nil :host_prefix)) << "," host_prefix ","IN4MASK  >> "]}," IPAddress Prefix32 octets":{"type":"method","name":"octets","children":[],"call":["i to_i "," to_ip split map "," to_ip split "," to_ip "]}," IPAddress Prefix32 to_ip":{"type":"method","name":"to_ip","children":[],"call":["(send nil :bits) pack unpack join ","(send nil :bits) pack unpack ","(send nil :bits) pack "," bits "]}," IPAddress Prefix32 bits":{"type":"method","name":"bits","children":[],"call":["1 * + ","0 * ","32 - ","1 * "," to_u32 to_s "," to_u32 ","%.32b % "]}," IPAddress Prefix32 initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","(irange\n  (int 1)\n  (int 32)) include? ","(irange\n  (int 0)\n  (int 32)) include? "]}," IPAddress Prefix <=>":{"type":"method","name":"<=>","children":[],"call":["@prefix <=> ","oth to_i "]}," IPAddress Prefix to_i":{"type":"method","name":"to_i","children":[],"call":[]}," IPAddress Prefix to_s":{"type":"method","name":"to_s","children":[],"call":[]}," IPAddress Prefix initialize":{"type":"method","name":"initialize","children":[],"call":["num to_i "]}," IPAddress Mapped mapped?":{"type":"method","name":"mapped?","children":[],"call":[]}," IPAddress Mapped to_s":{"type":"method","name":"to_s","children":[],"call":["@ipv4 address "]}," IPAddress Mapped initialize":{"type":"method","name":"initialize","children":[],"call":["@ipv4 to_ipv6 ","IPAddress IPv4  extract ","str split ","IPAddress IPv4  parse_u32 ","(send\n  (send\n    (lvar :groups) :[]\n    (int -2)) :<<\n  (int 16)) + ","groups [] ","groups [] << ","IPAddress IPv6  groups ","string =~ ","IPAddress IPv4  extract  to_ipv6 ","IPAddress IPv4  parse_u32  to_ipv6 ","(send\n  (send\n    (lvar :IPAddress IPv6  groups ) :[]\n    (int -2)) :<<\n  (int 16)) + ","IPAddress IPv6  groups  [] ","IPAddress IPv6  groups  [] << ","IPAddress IPv6  IPAddress IPv6  groups  "]}," IPAddress Loopback initialize":{"type":"method","name":"initialize","children":[],"call":[" compress_address ","Prefix128  new ","Array  new push ","Array  new ","(send\n  (str \"0000:\") :*\n  (int 7)) + ","0000: * "]}," IPAddress Unspecified initialize":{"type":"method","name":"initialize","children":[],"call":[" compress_address ","Prefix128  new ","Array  new ","(send\n  (str \"0000:\") :*\n  (int 8)) chop ","0000: * "]}," IPAddress IPv6 compress_address":{"type":"method","name":"compress_address","children":[],"call":["str sub ","str sub! "," loop ","(send\n  (ivar :@groups) :map) join ","i to_s ","@groups map ","(send\n  (ivar :@groups) :map) join  sub ","(send\n  (ivar :@groups) :map) join  sub! "]}," IPAddress IPv6 parse_hex":{"type":"method","name":"parse_hex","children":[],"call":[]}," IPAddress IPv6 parse_u128":{"type":"method","name":"parse_u128","children":[],"call":[]}," IPAddress IPv6 parse_data":{"type":"method","name":"parse_data","children":[],"call":[]}," IPAddress IPv6 groups":{"type":"method","name":"groups","children":[],"call":[]}," IPAddress IPv6 literal":{"type":"method","name":"literal","children":[],"call":["@address gsub + ","@address gsub "]}," IPAddress IPv6 compress":{"type":"method","name":"compress","children":[],"call":[]}," IPAddress IPv6 expand":{"type":"method","name":"expand","children":[],"call":[]}," IPAddress IPv6 bits":{"type":"method","name":"bits","children":[],"call":[" data unpack first "," data unpack "," data "]}," IPAddress IPv6 mapped?":{"type":"method","name":"mapped?","children":[],"call":[" to_u128 >> == "," to_u128 >> "," to_u128 "]}," IPAddress IPv6 loopback?":{"type":"method","name":"loopback?","children":[],"call":["@compressed == ","@prefix == "]}," IPAddress IPv6 unspecified?":{"type":"method","name":"unspecified?","children":[],"call":["@compressed == ","@prefix == "]}," IPAddress IPv6 compressed":{"type":"method","name":"compressed","children":[],"call":[]}," IPAddress IPv6 hexs":{"type":"method","name":"hexs","children":[],"call":["@address split "]}," IPAddress IPv6 data":{"type":"method","name":"data","children":[],"call":["@groups pack "]}," IPAddress IPv6 to_hex":{"type":"method","name":"to_hex","children":[],"call":[" hexs join "," hexs "]}," IPAddress IPv6 []":{"type":"method","name":"[]","children":[],"call":["@groups [] "]}," IPAddress IPv6 network?":{"type":"method","name":"network?","children":[],"call":[" to_u128 | == ","@prefix to_u128 "," to_u128 | "," to_u128 "]}," IPAddress IPv6 to_i":{"type":"method","name":"to_i","children":[],"call":[" to_hex hex "," to_hex "]}," IPAddress IPv6 to_s":{"type":"method","name":"to_s","children":[],"call":[" compressed "]}," IPAddress IPv6 to_string":{"type":"method","name":"to_string","children":[],"call":[]}," IPAddress IPv6 prefix=":{"type":"method","name":"prefix=","children":[],"call":["Prefix128  new "]}," IPAddress IPv6 prefix":{"type":"method","name":"prefix","children":[],"call":[]}," IPAddress IPv6 address":{"type":"method","name":"address","children":[],"call":[]}," IPAddress IPv6 initialize":{"type":"method","name":"initialize","children":[],"call":["Prefix128  new "," raise ","ip inspect "," compress_address ","IN6FORMAT  % "," class groups "," class ","IPAddress  valid_ipv6? ","str split ","str =~ "]}," IPAddress IPv4 sum_first_found":{"type":"method","name":"sum_first_found","children":[],"call":["dup reverse ","dup []= ","i + ","a size == ","a size ","(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten ","IPAddress IPv4  summarize ","dup [] ","dup each_with_index ","arr dup reverse ","arr dup ","(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten "," class summarize "," class ","arr dup reverse  reverse ","arr dup reverse  []= ","(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten  size == ","(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten  size == ","(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten  size ","(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten  size ","(send\n  (const\n    (const nil :IPAddress) :IPv4) :summ(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rize\n  (lv(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :obj)\n  (send\n    (lv(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :dup) :[]\n    (send\n      (lv(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :i) :+\n      (int 1)))) fl(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten tten ","(send\n  (const\n    (const nil :IPAddress) :IPv4) :summ(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rize\n  (lv(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :obj)\n  (send\n    (lv(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :dup) :[]\n    (send\n      (lv(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :i) :+\n      (int 1)))) fl(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten tten ","(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :arr dup reverse ) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten ","IPAddress IPv4  summ(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rize ","IPAddress IPv4  summ(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rize ","arr dup reverse  [] ","dup e(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten ch_with_index ","dup e(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten ch_with_index ","arr dup reverse  each_with_index ","(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rr dup reverse ","(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rr dup reverse ","arr arr dup reverse  reverse ","(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rr dup ","(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rr dup ","arr arr dup reverse  ","(send\n  (send\n    (self) :cl(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten ss) :summ(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rize\n  (lv(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :obj)\n  (send\n    (lv(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :dup) :[]\n    (send\n      (lv(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :i) :+\n      (int 1)))) fl(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten tten ","(send\n  (send\n    (self) :cl(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten ss) :summ(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rize\n  (lv(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :obj)\n  (send\n    (lv(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :dup) :[]\n    (send\n      (lv(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten r :i) :+\n      (int 1)))) fl(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten tten ","(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :arr dup reverse ) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten "," cl(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten ss summ(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rize "," cl(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten ss summ(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten rize "," cl(send\n  (const\n    (const nil :IPAddress) :IPv4) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten ss "," cl(send\n  (send\n    (self) :class) :summarize\n  (lvar :obj)\n  (send\n    (lvar :dup) :[]\n    (send\n      (lvar :i) :+\n      (int 1)))) flatten ss "]}," IPAddress IPv4 calculate_subnets":{"type":"method","name":"calculate_subnets","children":[],"call":[" sum_first_found ","networks size == ","networks size ","networks << ","IPAddress IPv4  parse_u32 "," network_u32 + "," network_u32 ","i * ","2 ** ","32 - ","(irange\n  (int 0)\n  (send\n    (lvar :po2) :-\n    (int 1))) each ","po2 - ","Array  new ","@prefix to_i + ","Math  log2 to_i ","Math  log2 ","@prefix to_i ","subnets closest_power_of_2 ","@prefix + "," sum_first_found  size == ","Array  new  size == "," sum_first_found  size ","Array  new  size "," sum_first_found  << ","Array  new  << ","(irange\n  (int 0)\n  (send\n    (lvar :subnets closest_power_of_2 ) :-\n    (int 1))) each ","subnets closest_power_of_2  - "]}," IPAddress IPv4 prefix_from_ip":{"type":"method","name":"prefix_from_ip","children":[],"call":["bits =~ ","CLASSFUL  each "," bits_from_address ","Prefix32  new "," bits_from_address  =~ ","  bits_from_address _from_address "]}," IPAddress IPv4 bits_from_address":{"type":"method","name":"bits_from_address","children":[],"call":["(send\n  (send\n    (lvar :ip) :split\n    (str \".\")) :map) pack unpack first ","(send\n  (send\n    (lvar :ip) :split\n    (str \".\")) :map) pack unpack ","(send\n  (send\n    (lvar :ip) :split\n    (str \".\")) :map) pack ","i to_i ","ip split map ","ip split "]}," IPAddress IPv4 summarize":{"type":"method","name":"summarize","children":[],"call":[]}," IPAddress IPv4 extract":{"type":"method","name":"extract","children":[],"call":[]}," IPAddress IPv4 parse_data":{"type":"method","name":"parse_data","children":[],"call":[]}," IPAddress IPv4 parse_u32":{"type":"method","name":"parse_u32","children":[],"call":[]}," IPAddress IPv4 to_ipv6":{"type":"method","name":"to_ipv6","children":[],"call":["%.4x:%.4x % ","(send nil :to_u32) pack unpack ","(send nil :to_u32) pack "," to_u32 "]}," IPAddress IPv4 c?":{"type":"method","name":"c?","children":[],"call":["CLASSFUL  index === "," bits ","CLASSFUL  index ","CLASSFUL  key === ","CLASSFUL  key "]}," IPAddress IPv4 b?":{"type":"method","name":"b?","children":[],"call":["CLASSFUL  index === "," bits ","CLASSFUL  index ","CLASSFUL  key === ","CLASSFUL  key "]}," IPAddress IPv4 a?":{"type":"method","name":"a?","children":[],"call":["CLASSFUL  index === "," bits ","CLASSFUL  index ","CLASSFUL  key === ","CLASSFUL  key "]}," IPAddress IPv4 +":{"type":"method","name":"+","children":[],"call":[" class summarize "," class "," aggregate ","i network ","(self) sort map ","(self) sort "]}," IPAddress IPv4 -":{"type":"method","name":"-","children":[],"call":["(send\n  (send nil :to_u32) :-\n  (send\n    (lvar :oth) :to_u32)) abs "," to_u32 - ","oth to_u32 "," to_u32 "]}," IPAddress IPv4 supernet":{"type":"method","name":"supernet","children":[],"call":[" class new network "," class new ","@address + "," class "," raise ","new_prefix >= ","@prefix to_i ","new_prefix < "]}," IPAddress IPv4 subnet":{"type":"method","name":"subnet","children":[],"call":[" calculate_subnets "," raise ","(irange\n  (int 1)\n  (begin\n    (send\n      (int 2) :**\n      (begin\n        (send\n          (int 32) :-\n          (send\n            (send nil :prefix) :to_i)))))) include? ","2 ** ","32 - "," prefix to_i "," prefix ","(irange\n  (int 1)\n  (begin\n    (send\n      (int 2) :**\n      (send\n        (ivar :@prefix) :host_prefix)))) include? ","@prefix host_prefix "," class parse_u32 "," network_u32 + ","i * "," network_u32 "," class ","Array  new ","subprefix - ","@prefix to_i ","(irange\n  (begin\n    (send\n      (ivar :@prefix) :to_i))\n  (int 32)) include? "]}," IPAddress IPv4 reverse":{"type":"method","name":"reverse","children":[],"call":["@octets reverse join + ","@octets reverse join ","@octets reverse "]}," IPAddress IPv4 include?":{"type":"method","name":"include?","children":[],"call":[" network_u32 == "," class new network_u32 "," class new ","oth address + ","oth address "," class "," network_u32 ","@prefix <= ","oth prefix ","oth to_u32 & ","@prefix to_u32 ","oth to_u32 "]}," IPAddress IPv4 broadcast_u32":{"type":"method","name":"broadcast_u32","children":[],"call":["(send\n  (send nil :to_u32) :|\n  (send\n    (send\n      (ivar :@prefix) :to_u32) :~)) pack unpack first ","(send\n  (send nil :to_u32) :|\n  (send\n    (send\n      (ivar :@prefix) :to_u32) :~)) pack unpack ","(send\n  (send nil :to_u32) :|\n  (send\n    (send\n      (ivar :@prefix) :to_u32) :~)) pack "," to_u32 | ","@prefix to_u32 ~ ","@prefix to_u32 "," to_u32 "," network_u32 + - "," network_u32 + "," size "," network_u32 "]}," IPAddress IPv4 network_u32":{"type":"method","name":"network_u32","children":[],"call":[" to_u32 & ","@prefix to_u32 "," to_u32 ","@u32 & "]}," IPAddress IPv4 hosts":{"type":"method","name":"hosts","children":[],"call":[" to_a [] "," to_a "]}," IPAddress IPv4 size":{"type":"method","name":"size","children":[],"call":[" broadcast_u32 - + "," broadcast_u32 - "," network_u32 "," broadcast_u32 ","2 ** ","@prefix host_prefix "]}," IPAddress IPv4 <=>":{"type":"method","name":"<=>","children":[],"call":[" prefix > ","oth prefix "," prefix "," prefix < "," to_u32 < ","oth to_u32 "," to_u32 "," to_u32 > "," to_u32 <=> "," prefix <=> "," to_u32 == "]}," IPAddress IPv4 each":{"type":"method","name":"each","children":[],"call":[" class parse_u32 "," class ","(irange\n  (send nil :network_u32)\n  (send nil :broadcast_u32)) each "," broadcast_u32 "," network_u32 "]}," IPAddress IPv4 each_host":{"type":"method","name":"each_host","children":[],"call":[" hosts each "," hosts "," class parse_u32 "," class ","(irange\n  (send\n    (send nil :network_u32) :+\n    (int 1))\n  (send\n    (send nil :broadcast_u32) :-\n    (int 1))) each "," broadcast_u32 - "," broadcast_u32 "," network_u32 + "," network_u32 "]}," IPAddress IPv4 last":{"type":"method","name":"last","children":[],"call":[" class parse_u32 "," broadcast_u32 - "," broadcast_u32 "," class "," prefix == "," prefix "," prefix <= "]}," IPAddress IPv4 first":{"type":"method","name":"first","children":[],"call":[" class parse_u32 "," network_u32 + "," network_u32 "," class "," prefix == "," prefix "," prefix <= "]}," IPAddress IPv4 network":{"type":"method","name":"network","children":[],"call":[" class parse_u32 "," network_u32 "," class "]}," IPAddress IPv4 network?":{"type":"method","name":"network?","children":[],"call":[" to_u32 | == ","@prefix to_u32 "," to_u32 | "," to_u32 ","@u32 | == ","@u32 | ","@prefix < "]}," IPAddress IPv4 broadcast":{"type":"method","name":"broadcast","children":[],"call":[" class parse_u32 "," broadcast_u32 "," class "," prefix == "," prefix "," prefix <= "]}," IPAddress IPv4 bits":{"type":"method","name":"bits","children":[],"call":[" data unpack first "," data unpack "," data "]}," IPAddress IPv4 []":{"type":"method","name":"[]","children":[],"call":["@octets [] "]}," IPAddress IPv4 data":{"type":"method","name":"data","children":[],"call":["@octets pack ","(ivar :@u32) pack "]}," IPAddress IPv4 to_u32":{"type":"method","name":"to_u32","children":[],"call":[" data unpack first "," data unpack "," data "]}," IPAddress IPv4 netmask=":{"type":"method","name":"netmask=","children":[],"call":["Prefix32  parse_netmask "]}," IPAddress IPv4 netmask":{"type":"method","name":"netmask","children":[],"call":["@prefix to_ip "]}," IPAddress IPv4 to_s":{"type":"method","name":"to_s","children":[],"call":[]}," IPAddress IPv4 octets":{"type":"method","name":"octets","children":[],"call":[]}," IPAddress IPv4 prefix=":{"type":"method","name":"prefix=","children":[],"call":["Prefix32  new "]}," IPAddress IPv4 prefix":{"type":"method","name":"prefix","children":[],"call":[]}," IPAddress IPv4 address":{"type":"method","name":"address","children":[],"call":[]}," IPAddress IPv4 initialize":{"type":"method","name":"initialize","children":[],"call":["i to_i ","@address split map ","@address split "," prefix_from_ip "," raise ","Prefix32  parse_netmask ","IPAddress  valid_ipv4_netmask? ","Prefix32  new ","netmask to_i ","netmask =~ ","netmask strip! ","ip inspect ","ip strip ","IPAddress  valid_ipv4? ","str split ","(send\n  (send\n    (ivar :@octets) :[]\n    (int 0)) :<<\n  (int 24)) + + + ","@octets [] ","(send\n  (send\n    (ivar :@octets) :[]\n    (int 0)) :<<\n  (int 24)) + + ","@octets [] << ","(send\n  (send\n    (ivar :@octets) :[]\n    (int 0)) :<<\n  (int 24)) + ","ip strip  split map ","ip strip  split "]}," IPAddress valid_ipv6?":{"type":"method","name":"valid_ipv6?","children":[],"call":[]}," IPAddress valid_ipv4_netmask?":{"type":"method","name":"valid_ipv4_netmask?","children":[],"call":[]}," IPAddress valid_ipv4?":{"type":"method","name":"valid_ipv4?","children":[],"call":[]}," IPAddress valid?":{"type":"method","name":"valid?","children":[],"call":[]}," Integer closest_power_of_2":{"type":"method","name":"closest_power_of_2","children":[],"call":["i power_of_2? "," upto "]}," Integer power_of_2?":{"type":"method","name":"power_of_2?","children":[],"call":["Math  log2 to_i == ","Math  log2 ","Math  log2 to_i "]}," log2":{"type":"method","name":"log2","children":[],"call":[" log / "," log "]}," IPAddress deprecate":{"type":"method","name":"deprecate","children":[],"call":[]}," IPAddress parse":{"type":"method","name":"parse","children":[],"call":[]}," IPAddress Prefix -":{"type":"method","name":"-","children":[],"call":["(send\n  (send\n    (self) :prefix) :-\n  (send\n    (lvar :oth) :prefix)) abs "," prefix - ","oth prefix "," prefix ","oth is_a? "]}," IPAddress Prefix +":{"type":"method","name":"+","children":[],"call":[" prefix + ","oth prefix "," prefix ","oth is_a? "]}," IPAddress Mapped to_string":{"type":"method","name":"to_string","children":[],"call":["@ipv4 address "]}," IPAddress IPv6 reverse":{"type":"method","name":"reverse","children":[],"call":["(send\n  (send\n    (send nil :to_hex) :reverse) :gsub\n  (regexp\n    (str \".\")\n    (regopt))) + ","c + "," to_hex reverse gsub "," to_hex reverse "," to_hex "]}," IPAddress IPv6 to_string_uncompressed":{"type":"method","name":"to_string_uncompressed","children":[],"call":[]}," IPAddress IPv4 aggregate":{"type":"method","name":"aggregate","children":[],"call":["(send\n  (send\n    (lvar :arr2) :-\n    (array\n      (send\n        (lvar :ip2) :to_string))) :-\n  (lvar :arr1)) empty? ","arr2 - - ","arr2 - ","ip2 to_string ","i to_string ","snet subnet map ","snet subnet ","2 ** ","ip2 prefix - ","snet prefix ","ip2 prefix ","ip1 subnet map ","ip1 subnet ","ip1 prefix ","ip1 supernet ","ip1 prefix - ","ip1 include? ","(send\n  (send\n    (lvar :ip1) :size) :+\n  (send\n    (lvar :ip2) :size)) == ","snet size ","ip1 size + ","ip2 size ","ip1 size ","snet include_all? ","ip1 supernet  subnet map ","ip1 supernet  subnet ","ip1 supernet  prefix ","ip1 supernet  size ","ip1 supernet  include_all? "]}," IPAddress IPv4 to_string":{"type":"method","name":"to_string","children":[],"call":[]}," IPAddress Prefix32 host_prefix":{"type":"method","name":"host_prefix","children":[],"call":["32 - "]}," IPAddress IPv6 include?":{"type":"method","name":"include?","children":[],"call":[" network_u128 == "," class new network_u128 "," class new ","oth address + ","oth address "," class "," network_u128 ","@prefix <= ","oth prefix "]}," IPAddress IPv6 network_u128":{"type":"method","name":"network_u128","children":[],"call":[" to_u128 & ","@prefix to_u128 "," to_u128 "]}," IPAddress IPv4 parse_classful":{"type":"method","name":"parse_classful","children":[],"call":[]}," IPAddress IPv4 private?":{"type":"method","name":"private?","children":[],"call":["i include? ","(send\n  (send\n    (self) :class) :new\n  (str \"10.0.0.0/8\")) any? "," class new "," class "]}," IPAddress IPv4 u32":{"type":"method","name":"u32","children":[],"call":[]}," IPAddress ipv6?":{"type":"method","name":"ipv6?","children":[],"call":[" kind_of? "]}," IPAddress ipv4?":{"type":"method","name":"ipv4?","children":[],"call":[" kind_of? "]}," IPAddress IPv4 include_all?":{"type":"method","name":"include_all?","children":[],"call":[" include? ","others all? "]}," Math log2":{"type":"method","name":"log2","children":[],"call":[]}," IPAddress Prefix128 host_prefix":{"type":"method","name":"host_prefix","children":[],"call":["128 - "]}," IPAddress IPv6 network":{"type":"method","name":"network","children":[],"call":[" class parse_u128 "," network_u128 "," class "]}," IPAddress IPv6 <=>":{"type":"method","name":"<=>","children":[],"call":[" to_u128 <=> ","oth to_u128 "," to_u128 "," prefix <=> ","oth prefix "," prefix "," to_u128 == "]}," IPAddress IPv6 each":{"type":"method","name":"each","children":[],"call":[" class parse_u128 "," class ","(irange\n  (send nil :network_u128)\n  (send nil :broadcast_u128)) each "," broadcast_u128 "," network_u128 "]}," IPAddress IPv6 size":{"type":"method","name":"size","children":[],"call":["2 ** ","@prefix host_prefix "]}," IPAddress IPv6 broadcast_u128":{"type":"method","name":"broadcast_u128","children":[],"call":[" network_u128 + - "," network_u128 + "," size "," network_u128 "]}," IPAddress IPv4 newprefix":{"type":"method","name":"newprefix","children":[],"call":["@prefix + ","(lvasgn :a\n  (send\n    (send\n      (const nil :Math) :log2\n      (lvar :i)) :to_i)) == ","Math  log2 ","Math  log2 to_i ","num upto ","Math  log2 ceil ","(lvMath  log2 to_i sgn :Math  log2 to_i \n  (send\n    (send\n      (const nil :MMath  log2 to_i th) :log2\n      (lvMath  log2 to_i r :i)) :to_i)) == ","MMath  log2 to_i th  log2 ","MMath  log2 to_i th  log2 to_i ","MMath  log2 to_i th  log2 ceil "]}," IPAddress IPv4 split":{"type":"method","name":"split","children":[],"call":[" sum_first_found ","networks size == ","networks size "," subnet "," newprefix "," raise ","(irange\n  (int 1)\n  (begin\n    (send\n      (int 2) :**\n      (send\n        (ivar :@prefix) :host_prefix)))) include? ","2 ** ","@prefix host_prefix "," sum_first_found  size == "," subnet  size == "," sum_first_found  size "," subnet  size "]}," IPAddress ntoa":{"type":"method","name":"ntoa","children":[],"call":[]}," IPAddress mongoize":{"type":"method","name":"mongoize","children":[],"call":["IPAddress  mongoize "]}," IPAddress evolve":{"type":"method","name":"evolve","children":[],"call":[]}," IPAddress demongoize":{"type":"method","name":"demongoize","children":[],"call":[]}," IPAddress IPv6 []=":{"type":"method","name":"[]=","children":[],"call":[" initialize "," prefix ","IN6FORMAT  % ","@groups []= "]}," IPAddress IPv4 to":{"type":"method","name":"to","children":[],"call":["IPAddress  ntoa ","Range  new map ","Range  new ","e to_u32 ","IPv4  new ","e is_a? ","IPAddrIPv4  new ss  ntoa ","RangIPv4  new   nIPv4  new w map ","RangIPv4  new   nIPv4  new w ","IPv4  new  to_u32 ","IPv4  nIPv4  new w ","IPv4  new  is_a? "]}," IPAddress IPv4 loopback?":{"type":"method","name":"loopback?","children":[],"call":["i include? ","(send\n  (send\n    (self) :class) :new\n  (str \"127.0.0.0/8\")) any? "," class new "," class "]}," IPAddress IPv4 multicast?":{"type":"method","name":"multicast?","children":[],"call":["i include? ","(send\n  (send\n    (self) :class) :new\n  (str \"224.0.0.0/4\")) any? "," class new "," class "]}," IPAddress IPv4 []=":{"type":"method","name":"[]=","children":[],"call":[" initialize "," prefix ","@octets join ","@octets []= ","value to_i "]}," IPAddress IPv4 hex":{"type":"method","name":"hex","children":[],"call":["%.4x%.4x % ","(send nil :to_u32) pack unpack ","(send nil :to_u32) pack "," to_u32 "]}}