{" ActionView Base render_template":{"type":"method","name":"render_template","children":[],"call":[" render_template_old ","template nil? ! ","template nil? "]}," ActionView Base read_template_file":{"type":"method","name":"read_template_file","children":[],"call":[" read_template_file_old ","extension =~ "]}," ActionView Base render_file":{"type":"method","name":"render_file","children":[],"call":[" haml_old_render_file ","File  basename "]}," Haml Template set_precompiled":{"type":"method","name":"set_precompiled","children":[],"call":["@@precompiled_templates []= ","File  mtime to_i ","File  mtime "]}," Haml Template get_precompiled":{"type":"method","name":"get_precompiled","children":[],"call":["precompiled_on == ","File  mtime to_i ","File  mtime ","@@precompiled_templates [] "]}," Haml Template render":{"type":"method","name":"render","children":[],"call":["yield_proc call ","engine to_html "," instance_variable_get ","name first "," proc ","@view instance_eval "," set_precompiled ","engine precompiled ","Haml Engine  new ","File  read ","options [] "," get_precompiled ","@view haml_inline ","options []= ","locals merge! ","@@options dup ","@view instance_variable_set "," instance_variable_set ","assigns each ","@view assigns dup ","@view assigns ","@view instance_variable_get "," evaluate_assigns ","Haml Engine  new  to_html ","Haml Engine  new  precompiled ","@@options dup  [] ","@@options dup  []= ","@@@@options dup  dup ","@view assigns dup  each ","@view @view assigns dup  dup ","@view @view assigns dup  "," evaluate_@view assigns dup  "]}," Haml Template initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml Template options=":{"type":"method","name":"options=","children":[],"call":[]}," Haml Template options":{"type":"method","name":"options","children":[],"call":[]}," Haml Helpers capture_haml_with_buffer":{"type":"method","name":"capture_haml_with_buffer","children":[],"call":["result to_s ","line [] ","captured map ","min_tabs > ","line index ","captured each ","local_buffer slice! ","block call ","local_buffer length ","local_buffer slice!  map ","min_line index  > ","local_buffer slice!  each "]}," Haml Helpers bind_proc":{"type":"method","name":"bind_proc","children":[],"call":["proc call "," proc ","_hamlout buffer "," buffer "," buffer  buffer "]}," Haml Helpers buffer":{"type":"method","name":"buffer","children":[],"call":["@haml_stack [] "]}," Haml Helpers action_view":{"type":"method","name":"action_view","children":[],"call":[]}," Haml Helpers capture_haml":{"type":"method","name":"capture_haml","children":[],"call":[" capture_haml_with_buffer "," buffer buffer "," buffer "," haml_buffer buffer "," haml_buffer "," haml_buffer capture_position= ","(send\n  (lvar :captured) :map) join ","line [] ","captured map ","min_tabs > ","line length ","line index ","captured each "," haml_buffer buffer slice! split "," haml_buffer buffer slice! ","block call "," haml_buffer buffer length "," with_haml_buffer "," eval ","block binding ","result to_s ","captured split "," haml_buffer options [] "," haml_buffer options ","x == ","captured split reject ","line slice "," prettify ","captured nil? ","value is_a? ","value != ","captured == ","captured delete "," haml_buffer capture_ haml_buffer buffer length = ","(send\n  (lvar : haml_buffer buffer slice! split ) :map) join ","(send\n  (lvar : haml_buffer buffer slice! ) :map) join ","(send\n  (lvar :captured split ) :map) join "," haml_buffer buffer slice! split  map "," haml_buffer buffer slice!  map ","captured split  map ","min_line index  > "," haml_buffer buffer slice! split  each "," haml_buffer buffer slice!  each ","captured split  each "," haml_buffer buffer slice! split  split "," haml_buffer buffer slice!  split ","captured split  split "," haml_buffer buffer slice! split  split reject "," haml_buffer buffer slice!  split reject ","captured split  split reject "," haml_buffer buffer slice! split  nil? "," haml_buffer buffer slice!  nil? ","captured split  nil? ","block call  is_a? ","block call  != "," haml_buffer buffer slice! split  == "," haml_buffer buffer slice!  == ","captured split  == "," haml_buffer buffer slice! split  delete "," haml_buffer buffer slice!  delete ","captured split  delete "]}," Haml Helpers succeed":{"type":"method","name":"succeed","children":[],"call":[" capture_haml chomp "," capture_haml "]}," Haml Helpers precede":{"type":"method","name":"precede","children":[],"call":[" capture_haml chomp "," capture_haml "]}," Haml Helpers surround":{"type":"method","name":"surround","children":[],"call":["output chomp "," capture_haml "," capture_haml  chomp "]}," Haml Helpers tab_down":{"type":"method","name":"tab_down","children":[],"call":[" buffer tabulation "," buffer "," haml_buffer tabulation "," haml_buffer "]}," Haml Helpers tab_up":{"type":"method","name":"tab_up","children":[],"call":[" buffer tabulation "," buffer "," haml_buffer tabulation "," haml_buffer "]}," Haml Helpers list_of":{"type":"method","name":"list_of","children":[],"call":["to_return join ","result strip! ","result strip ","result gsub! ","result count > ","result count "," capture_haml ","array collect ","enum collect ","result gsub ","  << ","(send\n  (lvar :opts) :map) join ","opts map ","opts empty? ","(send\n  (lvar :enum) :collect) join ","ret << ","ret empty? ","enum each_with_object ","s << ","opts each_with_object ","(send\n  (lvar :enum) :map) join ","enum map "," capture_haml  strip! ","result strip  strip! ","result gsub  strip! "," capture_haml  strip ","result strip  strip ","result gsub  strip "," capture_haml  gsub! ","result strip  gsub! ","result gsub  gsub! "," capture_haml  count > ","result strip  count > ","result gsub  count > "," capture_haml  count ","result strip  count ","result gsub  count "," capture_haml  gsub ","result strip  gsub ","result gsub  gsub "]}," Haml Helpers flatten":{"type":"method","name":"flatten","children":[],"call":["input gsub gsub ","input gsub "]}," Haml Helpers action_view?":{"type":"method","name":"action_view?","children":[],"call":[]}," Haml Helpers ActionViewMods form_tag":{"type":"method","name":"form_tag","children":[],"call":[" old_form_tag "," tab_down ","oldproc call "," tab_up "," concat "," bind_proc "," block_given? "," is_haml? "," old_form_tag + "]}," Haml Helpers ActionViewMods concat":{"type":"method","name":"concat","children":[],"call":[" buffer buffer concat "," buffer buffer "," buffer "," old_concat "," is_haml? "]}," Haml Helpers ActionViewMods included":{"type":"method","name":"included","children":[],"call":[]}," Haml Engine push_and_tabulate":{"type":"method","name":"push_and_tabulate","children":[],"call":["@to_close_stack push "]}," Haml Engine count_soft_tabs":{"type":"method","name":"count_soft_tabs","children":[],"call":["spaces / ","line index "," raise ","SyntaxError  new ","line [] == ","line [] ","line strip empty? ","line strip ","line index  / "]}," Haml Engine start_flat":{"type":"method","name":"start_flat","children":[],"call":["@template_tabs * "," push_and_tabulate ","@to_close_stack push "]}," Haml Engine render_doctype":{"type":"method","name":"render_doctype","children":[],"call":[" push_text ","version == ","line scan [] ","line scan ","@options [] ","line split [] ","line split ","line [] == ","line [] ","line [] lstrip downcase ","line [] lstrip "," raise ","SyntaxError  new ","line [] lstrip downcase  scan [] ","line [] lstrip downcase  scan ","line [] lstrip downcase  split [] ","line [] lstrip downcase  split ","line [] lstrip downcase  [] == ","line [] lstrip downcase  [] ","line [] lstrip downcase  [] lstrip downcase ","line [] lstrip downcase  [] lstrip "]}," Haml Engine render_comment":{"type":"method","name":"render_comment","children":[],"call":[" close "," push_text "," push_and_tabulate ","conditional nil? ! ","conditional nil? "," push_silent ","conditional inspect ","content empty? ! ","content empty? ","content strip ","line scan [] ","line scan "," raise ","SyntaxError  new ","content strip! ","content strip  empty? ! ","content strip  empty? ","content strip  strip ","content strip  strip! "]}," Haml Engine render_div":{"type":"method","name":"render_div","children":[],"call":[" render_tag ","%div + "]}," Haml Engine render_tag":{"type":"method","name":"render_tag","children":[],"call":[" start_flat "," close "," push_text "," push_script "," push_and_tabulate "," push_silent ","flattened inspect ","attributes inspect ","value_exists inspect ","atomic inspect ","tag_name inspect ","value empty? ! ","value empty? ","action == ","value strip ","value to_s ","line scan "," raise ","SyntaxError  new ","value_exists ! "," warn ","(const\n  (const nil :Test) :Unit) ! ","@options [] ","attributes_hash nil? ","object_ref nil? ","attributes_hash [] ","open_tag dump "," prerender_tag ","flattened ! ","attributes_hash == ","object_ref == ","Buffer  one_liner? ","parse ! ","@options [] include? ","@block_opened ! ","Buffer  merge_attrs "," parse_class_and_id ",".# include? ","attributes empty? ! ","attributes empty? "," parse_literal_hash ","value [] strip dump gsub ","value [] strip dump ","value [] strip ","value [] ","value first == ","value first ","value to_s strip ","value [] == ","attributes =~ "," parse_class_and_id  inspect ","value empty? !  inspect ","value strip _exists inspect ","value to_s _exists inspect ","value [] strip dump gsub _exists inspect ","value to_s strip _exists inspect ","value strip  empty? ! ","value to_s  empty? ! ","value [] strip dump gsub  empty? ! ","value to_s strip  empty? ! ","value strip  empty? ","value to_s  empty? ","value [] strip dump gsub  empty? ","value to_s strip  empty? ","value strip  strip ","value to_s  strip ","value [] strip dump gsub  strip ","value to_s strip  strip ","value strip  to_s ","value to_s  to_s ","value [] strip dump gsub  to_s ","value to_s strip  to_s ","value empty? !  ! ","value strip _exists ! ","value to_s _exists ! ","value [] strip dump gsub _exists ! ","value to_s strip _exists ! "," parse_class_and_id _hash nil? "," parse_class_and_id _hash [] "," prerender_tag  dump "," parse_class_and_id _hash == "," parse_class_and_id  empty? ! "," parse_class_and_id  empty? ","value strip  [] strip dump gsub ","value to_s  [] strip dump gsub ","value [] strip dump gsub  [] strip dump gsub ","value to_s strip  [] strip dump gsub ","value strip  [] strip dump ","value to_s  [] strip dump ","value [] strip dump gsub  [] strip dump ","value to_s strip  [] strip dump ","value strip  [] strip ","value to_s  [] strip ","value [] strip dump gsub  [] strip ","value to_s strip  [] strip ","value strip  [] ","value to_s  [] ","value [] strip dump gsub  [] ","value to_s strip  [] ","value strip  first == ","value to_s  first == ","value [] strip dump gsub  first == ","value to_s strip  first == ","value strip  first ","value to_s  first ","value [] strip dump gsub  first ","value to_s strip  first ","value strip  to_s strip ","value to_s  to_s strip ","value [] strip dump gsub  to_s strip ","value to_s strip  to_s strip ","value strip  [] == ","value to_s  [] == ","value [] strip dump gsub  [] == ","value to_s strip  [] == "," parse_class_and_id  =~ "]}," Haml Engine close_loud":{"type":"method","name":"close_loud","children":[],"call":["@precompiled << "," push_silent "]}," Haml Engine close_flat":{"type":"method","name":"close_flat","children":[],"call":[" push_silent "," close "]}," Haml Engine close_comment":{"type":"method","name":"close_comment","children":[],"call":[" push_silent "]}," Haml Engine close_block":{"type":"method","name":"close_block","children":[],"call":[" push_silent "]}," Haml Engine close_tag":{"type":"method","name":"close_tag","children":[],"call":["@precompiled << ","tag dump "]}," Haml Engine close":{"type":"method","name":"close","children":[],"call":[" close_loud "," close_flat "," close_tag "," close_comment "," close_block ","@to_close_stack pop "," close_filtered "," close_haml_comment "]}," Haml Engine push_flat_script":{"type":"method","name":"push_flat_script","children":[],"call":[" push_script "," start_flat ","text empty? "," raise ","SyntaxError  new "]}," Haml Engine push_script":{"type":"method","name":"push_script","children":[],"call":["@precompiled << "," push_and_tabulate "," push_silent "," options [] "," options "]}," Haml Engine push_flat":{"type":"method","name":"push_flat","children":[],"call":["@precompiled << ","tabulation > ","text dump ","spaces - ","@filter_buffer << ","  * ","spaces -  > "]}," Haml Engine push_text":{"type":"method","name":"push_text","children":[],"call":["@precompiled << ","text dump "]}," Haml Engine push_silent":{"type":"method","name":"push_silent","children":[],"call":["@precompiled << ","index + ","@options [] "," options [] "," options "]}," Haml Engine compile":{"type":"method","name":"compile","children":[],"call":["@haml_stack pop ","@scope_object instance_eval "," raise ","e backtrace unshift ","e backtrace ","line_marker scan [] to_i ","line_marker scan [] ","line_marker scan ","@precompiled split [] grep [] ","@precompiled split [] grep ","@precompiled split [] ","@precompiled split ","compile_error [] to_i ","compile_error [] ","@scope_object haml_lineno ","@scope_object haml_filename ","@scope_object methods include? ","@scope_object methods ","e message scan [] ","e message scan ","e message ","@scope_object _haml_render "," attr ","@haml_stack push ","Array  new ","@scope_object extend ","e add_backtrace_entry ","@options [] "," include ","@scope_object send "," options [] "," options ","CompiledTemplates  module_eval ","@scope_object respond_to? ","@@method_names [] ","@scope_object class instance_eval ","@scope_object class ","@precompiled split [] grep []  scan [] to_i ","@precompiled split [] grep []  scan [] ","@precompiled split [] grep []  scan ","e message scan []  [] to_i ","e message scan []  [] ","@scope_object haml_line_marker scan [] to_i  ","@scope_object haml_@scope_object haml_lineno  ","@@@@method_names [] s [] "]}," Haml Engine is_multiline?":{"type":"method","name":"is_multiline?","children":[],"call":["line [] == ","line [] ","line length > ","line length "]}," Haml Engine handle_multiline":{"type":"method","name":"handle_multiline","children":[],"call":[" process_line ","count > ","line empty? "," process_indent ","line [] ","MULTILINE_STARTERS  include? "," is_multiline? "]}," Haml Engine mid_block_keyword?":{"type":"method","name":"mid_block_keyword?","children":[],"call":["MID_BLOCK_KEYWORDS  include? ","line [] split [] ","line [] split ","line [] ","line [] == ","line length > ","line length "]}," Haml Engine process_line":{"type":"method","name":"process_line","children":[],"call":[" push_text ","line [] "," render_doctype ","line [] == "," push_and_tabulate "," mid_block_keyword? ! "," mid_block_keyword? "," push_silent ","sub_line [] == ","sub_line [] "," push_flat_script "," push_script "," render_comment "," render_tag "," render_div "," push_plain "," start_filtered "," options [] [] "," options [] "," options ","line [] downcase "," warn ","sub_line [] strip dump gsub ","sub_line [] strip dump ","sub_line [] strip ","index + ","line [] split [] == ","line [] split [] ","line [] split ","mbk ! "," start_haml_comment "," unescape_interpolation ","name to_s ","line []  [] == ","line []  [] ","line []  [] strip dump gsub ","line []  [] strip dump ","line []  [] strip "," mid_block_keyword?  ! ","line [] downcase  to_s "]}," Haml Engine process_indent":{"type":"method","name":"process_indent","children":[],"call":[" close "," mid_block_keyword? ","offset == ","to_close - - ","to_close - ","to_close times ","@template_tabs - ","@template_tabs > ","count <= ","to_close - -  == ","@template_tabs -  - - ","@template_tabs -  - ","@template_tabs -  times "]}," Haml Engine do_precompile":{"type":"method","name":"do_precompile","children":[],"call":[" push_silent "," close ","@template_tabs times "," process_line ","line_empty ! "," push_flat ","@flat_spaces != "," process_indent ","old_line empty? ","suppress_render ! "," handle_multiline ","tabs > ","line strip "," count_soft_tabs ","(send\n  (ivar :@template) :+\n  (str \"\\n\\n\")) each_with_index ","@template + ","line empty? ! ","line empty? ","(send\n  (ivar :@template) :+\n  (str \"\\n-#\")) each_with_index "," raise ","SyntaxError  new ","tabs - > ","tabs - ","@flat_spaces == ","old_spaces != ","old_tabs * ","flat ! ","uline rstrip ","line lstrip [] ","line lstrip ","(send\n  (ivar :@template) :+\n  (str \"\\n-#\\n-#\")) each_with_index ","@haml_comment ! ","supported_local_assigns []= ","@options [] each ","@options [] ","@@supported_local_assigns []= "," assign_method_name "," options [] "," options ","line lstrip chomp "," process_line strip  "," process_uline rstrip  ","old_line empty?  ! ","line strip _empty ! ","uline rstrip _empty ! "," push_@flat_spaces !=  ","@@flat_spaces != _spaces != ","old_line strip  empty? ","old_uline rstrip  empty? "," handle_multiline  ! "," handle_multiline strip  "," handle_multiuline rstrip  ","line strip  strip ","uline rstrip  strip ","line strip  empty? ! ","uline rstrip  empty? ! ","line strip  empty? ","uline rstrip  empty? ","@@flat_spaces != _spaces == ","@flat_spaces !=  ! ","uline strip  rstrip ","uuline rstrip  rstrip ","line lstrip []  rstrip ","line lstrip chomp  rstrip ","line strip  lstrip [] ","uline rstrip  lstrip [] ","line strip  lstrip ","uline rstrip  lstrip "," assign_ assign_method_name  ","line strip  lstrip chomp ","uline rstrip  lstrip chomp "]}," Haml Engine to_html":{"type":"method","name":"to_html","children":[],"call":["@buffer buffer "," compile "," class send "," class ","local_assigns each ","@scope_object instance_eval ","@options [] ","Haml Buffer  new ","Haml Buffer  new  buffer ","@options []  each "]}," Haml Engine initialize":{"type":"method","name":"initialize","children":[],"call":[" do_precompile ","String  new ","@precompiled nil? ","@options [] ","(pair\n  (sym :suppress_eval)\n  (false)) merge ","template strip "," raise ","e add_backtrace_entry ","@options rec_merge! ","@options [] []= ","NOT_LOADED  include? ! ","NOT_LOADED  include? ","@options [] merge! ","@options [] rec_merge! ","options [] ","(send\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :locals)) :keys) :all?) ! ","supported_assigns include? ","@options [] keys all? ","@options [] keys ","@@supported_local_assigns [] ","@@method_names [] ","l_options [] ","$! backtrace unshift ","$! backtrace "," precompile "," warn ","@index + + - ","@index + + ","@index + ","$! line_offset ","template rstrip ","@options [] inspect ","(sym :xhtml) include? ","@options merge! ","e backtrace unshift ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (ivar :@index)) + - ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (ivar :@index)) + ","e line + ","e line ","e backtrace ","SyntaxError  new ","(or\n  (nth-ref 1)\n  (str \"\")) count ","@template =~ ","template rstrip + ","(send\n  (lvar :template) :rstrip) split + ","(send\n  (lvar :template) :rstrip) split ","@options []= ","@options [] name ","@options [] is_a? ","Encoding  default_internal "," ruby1_8? ","v nil? ","options reject ","Haml Error  new "," check_encoding ","@options [] name == ","template encoding "," check_haml_encoding "," compile "," parse ","@options [] == "," set_up_encoding ","@compiler compile ","@parser parse ","Compiler  new ","Parser  new "," initialize_encoding ","Options  new ","@options compiler_class new ","@options compiler_class ","@options parser_class new ","@options parser_class ","@temple_engine compile ","TempleEngine  new ","(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge! ","o delete ","Options  defaults dup tap ","Options  defaults dup ","Options  defaults ","String  new  nil? ","@options []  nil? ","(pair\n  (sym :suppress_eval)\n  (false)) merge  [] ","Options  new  [] ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] ","(pair\n  (sym :suppress_eval)\n  (false)) merge  rec_merge! ","Options  new  rec_merge! ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  rec_merge! ","(pair\n  (sym :suppress_eval)\n  (false)) merge  [] []= ","Options  new  [] []= ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] []= ","(pair\n  (sym :suppress_eval)\n  (false)) merge  [] merge! ","Options  new  [] merge! ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] merge! ","(pair\n  (sym :suppress_eval)\n  (false)) merge  [] rec_merge! ","Options  new  [] rec_merge! ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] rec_merge! ","(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] ","(send\n  (send\n    (send\n      (ivar :(pair\n  (sym :suppress_eval)\n  (false)) merge ) :[]\n      (sym :locals)) :keys) :all?) ! ","(send\n  (send\n    (send\n      (ivar :Options  new ) :[]\n      (sym :locals)) :keys) :all?) ! ","(send\n  (send\n    (send\n      (ivar :@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge! ) :[]\n      (sym :locals)) :keys) :all?) ! ","@@supported_local_assigns []  include? ","(pair\n  (sym :suppress_eval)\n  (false)) merge  [] keys all? ","Options  new  [] keys all? ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] keys all? ","(pair\n  (sym :suppress_eval)\n  (false)) merge  [] keys ","Options  new  [] keys ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] keys ","l_(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] ","(pair\n  (sym :suppress_eval)\n  (false)) merge  [] inspect ","Options  new  [] inspect ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] inspect ","(pair\n  (sym :suppress_eval)\n  (false)) merge  merge! ","Options  new  merge! ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  merge! ","template strip  =~ ","template rstrip  =~ ","template rstrip +  =~ ","(send\n  (lvar :template) :rstrip) split +  =~ ","(pair\n  (sym :suppress_eval)\n  (false)) merge  []= ","Options  new  []= ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  []= ","(pair\n  (sym :suppress_eval)\n  (false)) merge  [] name ","Options  new  [] name ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] name ","(pair\n  (sym :suppress_eval)\n  (false)) merge  [] is_a? ","Options  new  [] is_a? ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] is_a? ","(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  reject ","(pair\n  (sym :suppress_eval)\n  (false)) merge  [] name == ","Options  new  [] name == ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] name == ","(pair\n  (sym :suppress_eval)\n  (false)) merge  [] == ","Options  new  [] == ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  [] == ","Compiler  new  compile ","@options compiler_class new  compile ","Parser  new  parse ","@options parser_class new  parse ","(pair\n  (sym :suppress_eval)\n  (false)) merge  compiler_class new ","Options  new  compiler_class new ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  compiler_class new ","(pair\n  (sym :suppress_eval)\n  (false)) merge  compiler_class ","Options  new  compiler_class ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  compiler_class ","(pair\n  (sym :suppress_eval)\n  (false)) merge  parser_class new ","Options  new  parser_class new ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  parser_class new ","(pair\n  (sym :suppress_eval)\n  (false)) merge  parser_class ","Options  new  parser_class ","@(send\n  (send\n    (send\n      (const nil :Options) :defaults) :dup) :tap) merge!  parser_class ","TempleEngine  new  compile "]}," NilClass <=>":{"type":"method","name":"<=>","children":[],"call":["other nil? "]}," String <=>":{"type":"method","name":"<=>","children":[],"call":[" old_comp ","other is_a? "]}," Haml Buffer find_and_flatten":{"type":"method","name":"find_and_flatten","children":[],"call":["input gsub ","Haml Helpers  flatten ","input scan ","input to_s ","input gsub  gsub ","input to_s  gsub ","input gsub  scan ","input to_s  scan ","input gsub  to_s ","input to_s  to_s "]}," Haml Buffer one_liner?":{"type":"method","name":"one_liner?","children":[],"call":["value scan empty? ","value scan ","value length <= ","value length "]}," Haml Buffer build_attributes":{"type":"method","name":"build_attributes","children":[],"call":["result sort join ","result sort ","v gsub ","v include? ","@options [] ","v to_s ","v nil? ","attributes collect ","v empty? ","result compact sort join ","result compact sort ","result compact ","v gsub  gsub ","v to_s  gsub ","v gsub  include? ","v to_s  include? ","v gsub  to_s ","v to_s  to_s ","v gsub  nil? ","v to_s  nil? ","v gsub  empty? ","v to_s  empty? "]}," Haml Buffer parse_object_ref":{"type":"method","name":"parse_object_ref","children":[],"call":["ref id ","ref class to_s underscore ","ref class to_s ","ref class ","ref nil? ","ref [] "," underscore ","ref haml_object_ref ","ref respond_to? ","key join ","key nil? ","ref to_key ","class freeze ","id freeze ","ref []  id ","ref []  class to_s underscore ","ref []  class to_s ","ref []  class ","ref []  nil? ","ref []  [] ","ref []  haml_object_ref []  ","ref []  respond_to? ","ref to_key  join ","ref to_key  nil? ","ref []  to_key ","ref to_ref to_key  "]}," Haml Buffer parse_class_and_id":{"type":"method","name":"parse_class_and_id","children":[],"call":["attributes []= ","attributes [] ","list scan "]}," Haml Buffer tabs":{"type":"method","name":"tabs","children":[],"call":["   * ","count + ","@@tab_cache [] ","(send\n  (lvar :count) :+\n  (ivar :@tabulation)) max "]}," Haml Buffer stop_flat":{"type":"method","name":"stop_flat","children":[],"call":[" buffer concat "," buffer "]}," Haml Buffer close_comment":{"type":"method","name":"close_comment","children":[],"call":[" push_text ","@buffer << "]}," Haml Buffer open_comment":{"type":"method","name":"open_comment","children":[],"call":["@buffer << ","conditional to_s "," tabs ","conditional << "]}," Haml Buffer close_tag":{"type":"method","name":"close_tag","children":[],"call":[" push_text ","@buffer << "]}," Haml Buffer open_tag":{"type":"method","name":"open_tag","children":[],"call":["@buffer << "," build_attributes "," tabs ","attributes merge! "," parse_class_and_id ","class_id empty? ","class_id nil? "," parse_object_ref ","attributes [] "," class merge_attrs "," class ","attributes_hash []= ","attributes_hash delete ","key to_s ","attributes_hash keys each ","attributes_hash keys ","@real_tabs + ","Buffer  one_liner? ","Precompiler  build_attributes ","@options [] ","attributes_hashes each ","atomic ! ","@buffer << << "," html? ","> + "," /> + "," xhtml? ","h []= ","old inject "," to_hash ","k to_s ","old map ","Compiler  build_attributes "," build_Precompiler  build_attributes  "," build_Compiler  build_attributes  ","Precompiler  build_attributes  merge! ","Compiler  build_attributes  merge! ","Precompiler  build_attributes  [] ","Compiler  build_attributes  [] ","Precompiler  build_attributes _hash []= ","Compiler  build_attributes _hash []= ","Precompiler  build_attributes _hash delete ","Compiler  build_attributes _hash delete ","Precompiler  build_attributes _hash keys each ","Compiler  build_attributes _hash keys each ","Precompiler  build_attributes _hash keys ","Compiler  build_attributes _hash keys ","Precompiler  build_Precompiler  build_attributes  ","Precompiler  build_Compiler  build_attributes  ","Precompiler  build_attributes _hashes each ","Compiler  build_attributes _hashes each ","Compiler  build_Precompiler  build_attributes  ","Compiler  build_Compiler  build_attributes  "]}," Haml Buffer push_script":{"type":"method","name":"push_script","children":[],"call":[" push_text ","result gsub "," tabs ","result [] ","result [] == ","result to_s ","result nil? "," find_and_flatten ","Haml Helpers  find_and_preserve ","@buffer << ","tabulation - ","Buffer  one_liner? ","nuke_inner_whitespace ! "," tabs + ","\n + ","@options [] ! ","@options [] ","in_tag ! ","@tabulation > ","has_newline ! ","result include? "," html_escape ","result to_s rstrip "," options [] "," options ","Haml Helpers  preserve ","result lstrip ","result gsub  gsub ","result []  gsub ","result to_s  gsub "," find_and_flatten  gsub ","Haml Helpers  find_and_preserve  gsub "," tabs +  gsub "," html_escape  gsub ","result to_s rstrip  gsub ","Haml Helpers  preserve  gsub ","result lstrip  gsub ","result gsub  [] ","result []  [] ","result to_s  [] "," find_and_flatten  [] ","Haml Helpers  find_and_preserve  [] "," tabs +  [] "," html_escape  [] ","result to_s rstrip  [] ","Haml Helpers  preserve  [] ","result lstrip  [] ","result gsub  [] == ","result []  [] == ","result to_s  [] == "," find_and_flatten  [] == ","Haml Helpers  find_and_preserve  [] == "," tabs +  [] == "," html_escape  [] == ","result to_s rstrip  [] == ","Haml Helpers  preserve  [] == ","result lstrip  [] == ","result gsub  to_s ","result []  to_s ","result to_s  to_s "," find_and_flatten  to_s ","Haml Helpers  find_and_preserve  to_s "," tabs +  to_s "," html_escape  to_s ","result to_s rstrip  to_s ","Haml Helpers  preserve  to_s ","result lstrip  to_s ","result gsub  nil? ","result []  nil? ","result to_s  nil? "," find_and_flatten  nil? ","Haml Helpers  find_and_preserve  nil? "," tabs +  nil? "," html_escape  nil? ","result to_s rstrip  nil? ","Haml Helpers  preserve  nil? ","result lstrip  nil? ","result include?  ! ","result gsub  include? ","result []  include? ","result to_s  include? "," find_and_flatten  include? ","Haml Helpers  find_and_preserve  include? "," tabs +  include? "," html_escape  include? ","result to_s rstrip  include? ","Haml Helpers  preserve  include? ","result lstrip  include? ","result gsub  to_s rstrip ","result []  to_s rstrip ","result to_s  to_s rstrip "," find_and_flatten  to_s rstrip ","Haml Helpers  find_and_preserve  to_s rstrip "," tabs +  to_s rstrip "," html_escape  to_s rstrip ","result to_s rstrip  to_s rstrip ","Haml Helpers  preserve  to_s rstrip ","result lstrip  to_s rstrip ","result gsub  lstrip ","result []  lstrip ","result to_s  lstrip "," find_and_flatten  lstrip ","Haml Helpers  find_and_preserve  lstrip "," tabs +  lstrip "," html_escape  lstrip ","result to_s rstrip  lstrip ","Haml Helpers  preserve  lstrip ","result lstrip  lstrip "]}," Haml Buffer push_text":{"type":"method","name":"push_text","children":[],"call":["@buffer << "," tabs "," one_liner? "," flatten ","text + ","  * ","Buffer  one_liner? ","text gsub! ","   * ","@tabulation > ","text sub! ","@options [] ! ","@options [] "]}," Haml Buffer initialize":{"type":"method","name":"initialize","children":[],"call":["options [] == ","options [] ","(pair\n  (sym :attr_wrapper)\n  (str \"'\")) merge "," encode ","Encoding  find "," ruby1_8? ","@options [] join ","@options [] "," new_encoded_string ","@options merge ","options empty? ","Options  buffer_defaults ","(pair\n  (sym :attr_wrapper)\n  (str \"'\")) merge  [] join ","@options merge  [] join ","Options  buffer_defaults  [] join ","(pair\n  (sym :attr_wrapper)\n  (str \"'\")) merge  [] ","@options merge  [] ","Options  buffer_defaults  [] ","(pair\n  (sym :attr_wrapper)\n  (str \"'\")) merge  merge ","@options merge  merge ","Options  buffer_defaults  merge "]}," Base is_haml?":{"type":"method","name":"is_haml?","children":[],"call":[]}," Haml Helpers is_haml?":{"type":"method","name":"is_haml?","children":[],"call":["@haml_stack size > ","@haml_stack size ","@haml_buffer active? ","@haml_buffer nil? ! ","@haml_buffer nil? "]}," Tree ValueNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree RuleNode to_s":{"type":"method","name":"to_s","children":[],"call":["to_return << ","sub to_s ","tabs + ","sub_rules each ","@style == ","attributes join gsub rstrip ","attributes join gsub ","attributes join ","  * ","spaces - ","tabs * ","attributes empty? ","sub_rules << ","attributes << ","child is_a? "," children each "," children "," rule ","(send\n  (send\n    (lvar :super_rules) :split\n    (regexp\n      (str \",\\\\s*\")\n      (regopt))) :collect!) join ","(send\n  (send\n    (send\n      (self) :rule) :split\n    (regexp\n      (str \",\\\\s*\")\n      (regopt))) :collect!) join "," rule split collect! "," rule split ","super_rules split collect! ","super_rules split "," raise ","Sass SyntaxError  new "," line "," rule include? ","(send\n  (send\n    (send\n      (self) :rule) :split\n    (regexp\n      (str \",\\\\s*\")\n      (regopt))) :collect) join ","r gsub ","r include? "," rule split collect "," check_multiline_rule ","sub continued? ","@style != ","(send\n  (str \"  \") :*\n  (begin\n    (send\n      (lvar :tabs) :-\n      (int 1)))) + + ","(send\n  (str \"  \") :*\n  (begin\n    (send\n      (lvar :tabs) :-\n      (int 1)))) + ","   * ","tabs - "," continued? ","\n + ","(send\n  (lvar :attributes) :map) join ","a to_s ","attributes map ","attributes empty? ! ","(send\n  (send\n    (lvar :super_rules) :split\n    (regexp\n      (str \",\\\\s*\")\n      (regopt))) :collect!) join + ","total_indent + ","(send\n  (send\n    (self) :rules) :map) join ","per_rule_indent + ","r gsub gsub rstrip ","r gsub gsub "," rules map "," rules ","(sym :nested) include? "," rules any? ","(send\n  (send\n    (lvar :super_rules) :split\n    (str \",\\n\")) :map) join ","(send\n  (send\n    (send\n      (lvar :super_line) :strip) :split\n    (lvar :rule_split)) :map) join ","rule_indent + ","(send\n  (send\n    (send\n      (lvar :line) :gsub\n      (regexp\n        (str \",$\")\n        (regopt))\n      (str \"\")) :split\n    (lvar :rule_split)) :map) join ","rule gsub ","rule include? ","line gsub split map ","line gsub split ","line gsub ","super_line strip split map ","super_line strip split ","super_line strip ","super_rules split map "," style != "," style ","properties empty? "," style == ","(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (send\n        (lvar :tabs) :+\n        (int 1)))) :select) join ","a length > ","a length ","(send\n  (lvar :properties) :map) select ","properties map ","(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (int 1))) :select) join "," filename ","Pathname  new relative_path_from to_s ","Pathname  new relative_path_from ","Pathname  new ","File  dirname ","@options [] ","properties empty? ! ","properties << ","child invisible? ","(send\n  (lvar :resolved_rules) :map) join ","line join ","resolved_rules map "," resolve_parent_refs ","attributes join gsub rstrip  join gsub rstrip ","(send\n  (lvar :attributes) :map) join  join gsub rstrip ","attributes join gsub rstrip  join gsub ","(send\n  (lvar :attributes) :map) join  join gsub ","attributes join gsub rstrip  join ","(send\n  (lvar :attributes) :map) join  join ","  *  - ","   *  - ","attributes join gsub rstrip  empty? ","(send\n  (lvar :attributes) :map) join  empty? ","attributes join gsub rstrip  << ","(send\n  (lvar :attributes) :map) join  << ","(send\n  (lvar :attributes join gsub rstrip ) :map) join ","(send\n  (lvar :(send\n  (lvar :attributes) :map) join ) :map) join ","attributes join gsub rstrip  map ","(send\n  (lvar :attributes) :map) join  map ","attributes join gsub rstrip  empty? ! ","(send\n  (lvar :attributes) :map) join  empty? ! ","per_   *  + ","   *  + ","(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (send\n        (lvar :tabs) :+\n        (int 1)))) :select) join  empty? ","(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (int 1))) :select) join  empty? ","(send\n  (block\n    (send\n      (lvar :(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (send\n        (lvar :tabs) :+\n        (int 1)))) :select) join ) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (send\n        (lvar :tabs) :+\n        (int 1)))) :select) join ","(send\n  (block\n    (send\n      (lvar :(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (int 1))) :select) join ) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (send\n        (lvar :tabs) :+\n        (int 1)))) :select) join ","(send\n  (lvar :(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (send\n        (lvar :tabs) :+\n        (int 1)))) :select) join ) :map) select ","(send\n  (lvar :(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (int 1))) :select) join ) :map) select ","(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (send\n        (lvar :tabs) :+\n        (int 1)))) :select) join  map ","(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (int 1))) :select) join  map ","(send\n  (block\n    (send\n      (lvar :(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (send\n        (lvar :tabs) :+\n        (int 1)))) :select) join ) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (int 1))) :select) join ","(send\n  (block\n    (send\n      (lvar :(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (int 1))) :select) join ) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (int 1))) :select) join ","(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (send\n        (lvar :tabs) :+\n        (int 1)))) :select) join  empty? ! ","(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (int 1))) :select) join  empty? ! ","(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (send\n        (lvar :tabs) :+\n        (int 1)))) :select) join  << ","(send\n  (block\n    (send\n      (lvar :properties) :map)\n    (args\n      (arg :a))\n    (send\n      (lvar :a) :to_s\n      (int 1))) :select) join  << ","(send\n  (lvar : resolve_parent_refs ) :map) join "," resolve_parent_refs  map "]}," Sass Tree Node to_s":{"type":"method","name":"to_s","children":[],"call":["result [] ","child to_s "," raise ","SyntaxError  new ","child line ","child is_a? "," children each "," children ","String  new ","result + ","@style == ","result << ","(begin\n  (send\n    (lvar :child) :to_s\n    (int 1))) + "," check_multiline_rule ","child continued? ","e add_metadata "," line "," filename ","result empty? ","result rstrip! ","child_str + "," style == "," style ","child invisible? ","Sass SyntaxError  new ","Properties aren't allowed at the root of a document. + ","child pseudo_class_selector_message ","e modify_backtrace "," _to_s ","String  new  [] ","String  new  + ","String  new  << ","String  new  empty? ","String  new  rstrip! ","child to_s  + ","child pseudo_class_selector_Properties aren't allowed at the root of a document. +  "]}," Sass Tree Node <<":{"type":"method","name":"<<","children":[],"call":["@children << "," raise ","Sass SyntaxError  new ","child line "," invalid_child? "," has_children= "," check_child! ","child nil? "," << ","child each ","child is_a? "]}," Sass Tree Node initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree AttrNode declaration":{"type":"method","name":"declaration","children":[],"call":[" value "," name "]}," Tree AttrNode to_s":{"type":"method","name":"to_s","children":[],"call":[" value "," raise ","Sass SyntaxError  new "," declaration dump "," declaration "," value length < "," value length ","to_return [] ","to_return << ","@style == ","kid to_s "," children each "," children ","String  new "," children size > "," children size "," name "," value [] == "," value [] "," name [] == "," name [] "," children empty? "," value empty? ! "," value empty? ","to_return << << ","   * ","tabs - ","String  new  [] ","String  new  << ","String  new  << << "]}," Tree AttrNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," ActionController Base process":{"type":"method","name":"process","children":[],"call":[" sass_old_process ","Sass Plugin  update_stylesheets ","Sass Plugin  options [] ","Sass Plugin  options ","Sass Plugin  checked_for_updates ! ","Sass Plugin  checked_for_updates "," check call "," check ","Sass Plugin  check_for_updates "]}," Sass Plugin stylesheet_needs_update?":{"type":"method","name":"stylesheet_needs_update?","children":[],"call":["(send\n  (send\n    (const nil :File) :mtime\n    (send nil :template_filename\n      (lvar :name))) :-\n  (int 2)) > ","File  mtime "," css_filename ","File  mtime - "," template_filename ","File  exists? ! ","File  exists? "," dependencies any? "," dependency_updated? "," dependencies ","File  mtime > "," exact_stylesheet_needs_update? ","StalenessChecker  stylesheet_needs_update? ","(send\n  (send\n    (const nil :File) :mtime\n    (send nil : template_filename name\n      (lvar :name))) :-\n  (int 2)) > ","  css_filename name ","  template_filename name "]}," Sass Plugin css_filename":{"type":"method","name":"css_filename","children":[],"call":["@@options [] "," options [] "," options ","(begin\n  (lvar :path)) gsub "]}," Sass Plugin template_filename":{"type":"method","name":"template_filename","children":[],"call":["@@options [] "," options [] "," options "]}," Sass Plugin update_stylesheets":{"type":"method","name":"update_stylesheets","children":[],"call":["file print ","File  open ","Dir  mkdir ","l_options [] ","File  exist? ","e backtrace join ","e backtrace ","e_string << ","min + + ","min + ","File  read rstrip split [] each_with_index ","File  read rstrip split [] ","e sass_line + ","e sass_line ","File  read rstrip split ","File  read rstrip ","File  read ","e sass_filename ","(send\n  (send\n    (lvar :e) :sass_line) :-\n  (int 5)) max ","e sass_line - ","File  exists? ","e is_a? ","e message ","e class ","RAILS_ENV  != ","engine render ","Engine  new ","l_options []= ","@@options dup "," template_filename ","File  delete "," css_filename "," stylesheet_needs_update? "," options [] "," options ","File  basename [] ","File  basename ","Dir  [] each ","Dir  [] "," options [] + ","dirs each ","dirs << ","dirs [] ","name split [] each ","name split [] ","name split ","(or\n  (send\n    (lvar :l_options) :[]\n    (sym :load_paths))\n  (array)) + ","file sub [] ","file sub ","Dir  glob entries each ","Dir  glob entries ","Dir  glob ","File  join "," exception_string "," load_paths "," forbid_update? ! "," forbid_update? "," engine_options "," update_stylesheet ","template_location + ","Dir  glob each "," template_locations zip each "," template_locations zip "," css_locations "," template_locations ","template_location sub "," run_not_updating_stylesheet ","staleness_checker stylesheet_needs_update? ","StalenessChecker  new ","individual_files each "," run_updating_stylesheets "," template_location_array each "," template_location_array ","Dir  glob sort each ","Dir  glob sort ","@@options dup  [] ","(send\n  (send\n    (lvar :e) :sass_line) :-\n  (int 5)) max  + + ","(send\n  (send\n    (lvar :e) :sass_line) :-\n  (int 5)) max  + ","e sass_ template_filename  ","e sass_fileFile  basename []  ","e sass_filefile sub []  ","e sass_filefile sub  ","Engine  new  render ","@@options dup  []= "," template_ template_filename  "," template_fileFile  basename []  "," template_filefile sub []  "," template_filefile sub  "," css_ template_filename  ","  css_filename _filename "," css_fileFile  basename []  "," css_filefile sub []  "," css_filefile sub  ","File  baseFile  basename []  [] ","File  basefile sub []  [] ","File  basefile sub  [] ","File  baseFile  basename []  ","File  basefile sub []  ","File  basefile sub  ","File  basename []  split [] each ","file sub []  split [] each ","file sub  split [] each ","File  basename []  split [] ","file sub []  split [] ","file sub  split [] ","File  basename []  split ","file sub []  split ","file sub  split ","(or\n  (send\n    (lvar :@@options dup ) :[]\n    (sym :load_paths))\n  (array)) + "," Engine  new _options ","  css_filename _locations ","StalenessChecker  new  stylesheet_needs_update? "]}," Sass Plugin options=":{"type":"method","name":"options=","children":[],"call":["@@options merge! ","@options merge! "]}," Sass Plugin options":{"type":"method","name":"options","children":[],"call":[]}," Sass SyntaxError to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Sass SyntaxError add_backtrace_entry":{"type":"method","name":"add_backtrace_entry","children":[],"call":[" backtrace unshift "," backtrace "]}," Sass SyntaxError initialize":{"type":"method","name":"initialize","children":[],"call":[" add_backtrace "]}," Sass Engine parse_constant":{"type":"method","name":"parse_constant","children":[],"call":["@constants []= ","Sass Constant  parse "," raise ","SyntaxError  new ","line scan [] ","line scan ","@constants [] ","op == ","@Sass Constant  parse s []= ","@Sass Constant  parse s [] "]}," Sass Engine parse_attribute":{"type":"method","name":"parse_attribute","children":[],"call":["Tree AttrNode  new ","@options [] ","Sass Constant  parse to_s ","Sass Constant  parse ","eq [] == ","eq [] "," raise ","SyntaxError  new ","value nil? ","name nil? ","line scan [] ","line scan ","eq strip [] == ","eq strip [] ","eq strip ","attribute_regx == ","@options [] == ","Sass Constant  parse to_s  nil? "]}," Sass Engine parse_line":{"type":"method","name":"parse_line","children":[],"call":["Tree RuleNode  new ","@options [] "," parse_constant "," parse_attribute ","line [] ","line =~ "," parse_directive "," parse_comment "," parse_mixin_include "," parse_mixin_definition ","line [] == ","line [] nil? ","line [] != ","line text "," parse_property ","line text =~ ","line text [] == ","line text [] ","line text [] nil? "," parse_variable ","line text [] != ","3 empty? ","@options [] == "," parse_property_or_rule "," parse_interp "," raise ","SyntaxError  new ","value nil? ","name nil? ","line text scan [] ","line text scan "]}," Sass Engine has_children?":{"type":"method","name":"has_children?","children":[],"call":["next_line [] > ","next_line [] ","@lines [] ","next_line []= ","next_line [] == ","next_line nil? ! ","next_line nil? ","@lines []  [] > ","@lines []  [] ","@lines []  []= ","@lines []  [] == ","@lines []  nil? ! ","@lines []  nil? "]}," Sass Engine build_tree":{"type":"method","name":"build_tree","children":[],"call":[" has_children? ","node << ","child line= "," raise ","SyntaxError  new ","child nil? "," build_tree "," parse_line ","@lines [] ","child is_a? ","child == "," raw_next_line ","node is_a? ","node == "," validate_and_append_child ","node children= ","child children ","node add_rules ","child is_a? ! ","@lines [] nil? ","node continued? ","node line= ","@line + ","node first is_a? ","node first "," append_children ","line children ","node lines= ","node filename= ","line filename ","line index "," Array each "," Array ","  has_children? ? "," parse_line  << ","line index s [] "," parse_line  is_a? "," parse_line  == "," parse_line  children= "," parse_line  add_rules ","line index s [] nil? "," parse_line  continued? "," parse_line  line= ","line index  + "," parse_line  first is_a? "," parse_line  first "," parse_line  lines= "," parse_line  filename= "]}," Sass Engine count_tabs":{"type":"method","name":"count_tabs","children":[],"call":["spaces / "," raise ","SyntaxError  new ","line [] == ","line [] ","spaces % == ","spaces % ","line index ","line strip empty? ","line strip ","(str \"A tab character was used for indentation. Sass must be indented using two spaces.\\n\") strip ","(begin\n  (lvar :spaces)) strip ","spaces == ","line index  / ","line index  % == ","line index  % ","(str \"A tab character was used for indentation. Sass must be indented using two line index .\\n\") strip ","(begin\n  (lvar :line index )) strip ","line index  == "]}," Sass Engine split_lines":{"type":"method","name":"split_lines","children":[],"call":["@lines << ","line strip "," raise ","SyntaxError  new ","tabs - > ","tabs - "," count_tabs ","line [] == ","line [] ","index + ","@template each_with_index ","tabs == ","tabs * ","tabs > ","old_tabs nil? "," warn ","@line - ","context << ","@options [] ","index + s << "," count_tabs  - > "," count_tabs  - "," count_ count_tabs  "," count_tabs  == "," count_tabs  * "," count_tabs  > ","old_ count_tabs  nil? ","index +  - "]}," Sass Engine render":{"type":"method","name":"render","children":[],"call":[" raise ","err add_backtrace_entry ","@options [] ","root to_s ","root << ","child line= "," build_tree ","@lines [] ","Tree Node  new "," split_lines ","err sass_filename "," render_to_tree to_s "," render_to_tree "," to_tree render "," to_tree "," _to_tree render "," _to_tree ","Haml Util  silence_haml_warnings "," _render ","Tree Node  new  to_s ","Tree Node  new  << "]}," Sass Engine initialize":{"type":"method","name":"initialize","children":[],"call":["template split ","(pair\n  (sym :style)\n  (sym :nested)) merge! ","@options []= ","@options [] ","DEFAULT_OPTIONS  merge ","v nil? ","options reject ","(pair\n  (sym :style)\n  (sym :nested)) merge!  []= ","DEFAULT_OPTIONS  merge  []= ","(pair\n  (sym :style)\n  (sym :nested)) merge!  [] ","DEFAULT_OPTIONS  merge  [] "]}," Sass Constant insert_constant":{"type":"method","name":"insert_constant","children":[],"call":[" raise ","SyntaxError  new ","constants [] ","value [] ","value [] == "]}," Sass Constant operationalize":{"type":"method","name":"operationalize","children":[],"call":[" operationalize ","value [] ","FIRST_ORDER  include? ","SECOND_ORDER  include? ","Operation  new ","length == "," raise ","SyntaxError  new ","Literal  parse "," insert_constant ","value is_a? ","value length ","value length == ","Sass Constant Number  new ","value [] == "," get_constant ","Sass Constant Nil  new ","value []  [] ","value length  == ","value []  is_a? ","value []  length ","value value length  ","value []  length == ","value value length  == ","value []  [] == "]}," Sass Constant parenthesize_helper":{"type":"method","name":"parenthesize_helper","children":[],"call":["i + ","to_return push ","value [] ","to_return << "," parenthesize_helper ","token == ","token != ","i < ","value [] == "," raise ","Sass  SyntaxError ","value [] nil? ","to_return [] ","Sass SyntaxError  new ","value [] is_a? ","i +  + "," parenthesi + ze_helper ","value []  == ","value []  != ","i +  < "," rai + se ","value [] ni + l? ","value [] i + s_a? "]}," Sass Constant parenthesize":{"type":"method","name":"parenthesize","children":[],"call":[" parenthesize_helper [] "," parenthesize_helper ","value length ","to_return first ","to_return << ","value shift ","value first "," raise ","Sass SyntaxError  new ","value first is_a? ","value first nil? "," parenthesize ","token != ","value shift  != "]}," Sass Constant tokenize":{"type":"method","name":"tokenize","children":[],"call":["reset_str call "," raise ","Sass SyntaxError  new ","value dump ","str << ","byte chr ","to_return << ","(and\n  (lvar :negative_okay)\n  (send\n    (lvar :symbol) :==\n    (sym :minus))) ! ","symbol == ","last == ","last is_a? ! ","last is_a? ","symbol nil? ","SYMBOLS  [] ","WHITESPACE  include? ","is_string ! ","byte == ","to_return [] ","value each_byte ","str empty? ","Proc  new ","symbol != ","str empty? ! "," each_char ","reset_reset_str call  call ","reset_str call  << ","(and\n  (lvar :negative_okay)\n  (send\n    (lvar :SYMBOLS  [] ) :==\n    (sym :minus))) ! ","SYMBOLS  []  == ","to_return []  == ","to_return []  is_a? ! ","to_return []  is_a? ","SYMBOLS  []  nil? ","is_reset_str call ing ! ","is_string !  ! ","reset_str call  empty? ","SYMBOLS  []  != ","reset_str call  empty? ! "]}," Sass Constant parse":{"type":"method","name":"parse","children":[],"call":[" raise ","e sass_line= ","value dump ","e instance_eval ","e message == ","e message "," operationalize to_s "," operationalize "," parenthesize "," tokenize "]}," Constant String to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Constant String plus":{"type":"method","name":"plus","children":[],"call":["Sass Constant String  from_value "," to_s + ","other to_s "," to_s "]}," Constant String parse":{"type":"method","name":"parse","children":[],"call":[]}," Constant Operation perform":{"type":"method","name":"perform","children":[],"call":[" raise ","Sass SyntaxError  new ","e name to_s == ","@operator to_s ","e name to_s ","e name ","literal1 send ","@operand2 perform ","@operand1 perform ","@operand1 perform  send "]}," Constant Operation to_s":{"type":"method","name":"to_s","children":[],"call":[" perform to_s "," perform "]}," Constant Operation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Constant Number operate":{"type":"method","name":"operate","children":[],"call":["Number  from_value "," value send ","other value "," value "," raise ","Sass SyntaxError  new ","other unit "," unit ","other unit == "," unit nil? ","other unit nil? ","other  unit  ","other other unit  ","  unit  "," other unit  ","other  unit  == ","other other unit  == ","  unit  nil? "," other unit  nil? ","other  unit  nil? ","other other unit  nil? "]}," Constant Number from_value":{"type":"method","name":"from_value","children":[],"call":[]}," Constant Number to_s":{"type":"method","name":"to_s","children":[],"call":["value to_i ","value % == ","value % ","value to_i  to_i ","value to_i  % == ","value to_i  % "]}," Constant Number mod":{"type":"method","name":"mod","children":[],"call":[" raise ","NoMethodError  new "," operate ","other is_a? "]}," Constant Number div":{"type":"method","name":"div","children":[],"call":[" raise ","NoMethodError  new "," operate ","other is_a? "]}," Constant Number times":{"type":"method","name":"times","children":[],"call":[" raise ","NoMethodError  new ","other times ","other is_a? "," operate "]}," Constant Number minus":{"type":"method","name":"minus","children":[],"call":[" raise ","NoMethodError  new "," operate ","other is_a? "]}," Constant Number plus":{"type":"method","name":"plus","children":[],"call":["Sass Constant String  from_value "," to_s + ","other to_s "," to_s ","other plus ","other is_a? "," operate "]}," Constant Number parse":{"type":"method","name":"parse","children":[],"call":["unit empty? ","(begin\n  (lvar :first)) to_f ","second to_i ","first empty? ","value scan [] ","value scan "]}," Literal from_value":{"type":"method","name":"from_value","children":[],"call":[]}," Literal filter_value":{"type":"method","name":"filter_value","children":[],"call":[]}," Literal concat":{"type":"method","name":"concat","children":[],"call":["Sass Constant String  from_value ","other to_s "," to_s "]}," Literal perform":{"type":"method","name":"perform","children":[],"call":[]}," Literal initialize":{"type":"method","name":"initialize","children":[],"call":[" parse "]}," Literal parse":{"type":"method","name":"parse","children":[],"call":[]}," Constant Color piecewise":{"type":"method","name":"piecewise","children":[],"call":["Color  from_value ","rgb []= ","(send\n  (array\n    (lvar :res)\n    (int 255)) :min) max ","(lvar :res) min ","@value [] send ","other_val [] ","@value [] ","other value ","other is_a? ","(send\n  (array\n    (lvar :@value [] send )\n    (int 255)) :min) max ","(lvar :@value [] send ) min ","other value  [] "]}," Constant Color filter_value":{"type":"method","name":"filter_value","children":[],"call":[]}," Constant Color to_s":{"type":"method","name":"to_s","children":[],"call":["num to_s rjust ","num to_s ","@value map "]}," Constant Color mod":{"type":"method","name":"mod","children":[],"call":[" piecewise "," raise ","NoMethodError  new ","other is_a? "]}," Constant Color div":{"type":"method","name":"div","children":[],"call":[" piecewise "," raise ","NoMethodError  new ","other is_a? "]}," Constant Color times":{"type":"method","name":"times","children":[],"call":[" piecewise "," raise ","NoMethodError  new ","other is_a? "]}," Constant Color minus":{"type":"method","name":"minus","children":[],"call":[" piecewise "," raise ","NoMethodError  new ","other is_a? "]}," Constant Color plus":{"type":"method","name":"plus","children":[],"call":[" piecewise ","Sass Constant String  from_value "," to_s + ","other to_s "," to_s ","other is_a? "]}," Constant Color parse":{"type":"method","name":"parse","children":[],"call":["num ljust to_i ","num ljust ","value scan [] map ","value scan [] ","value scan ","(send\n  (begin\n    (irange\n      (int 0)\n      (int 2))) :map) reverse ","color >> & ","color >> ","n << ","(irange\n  (int 0)\n  (int 2)) map ","HTML4_COLORS  [] ","value downcase ","value =~ ","HTML4_COLORS  []  >> & ","HTML4_COLORS  []  >> "]}," ActionView Base is_haml?":{"type":"method","name":"is_haml?","children":[],"call":[]}," Haml Helpers preserve":{"type":"method","name":"preserve","children":[],"call":["input gsub gsub ","input gsub "," preserve "," capture_haml ","input chomp gsub gsub ","input chomp gsub ","input chomp ","input to_s chomp gsub gsub ","input to_s chomp gsub ","input to_s chomp ","input to_s ","s delete! ","s gsub! ","Helpers  preserve ","input ginput to_s chomp ub ginput to_s chomp ub ","input ginput to_s chomp ub "," preinput to_s chomp erve ","input chomp ginput to_s chomp ub ginput to_s chomp ub ","input chomp ginput to_s chomp ub ","input to_input to_s chomp  chomp ginput to_s chomp ub ginput to_s chomp ub ","input to_input to_s chomp  chomp ginput to_s chomp ub ","input to_input to_s chomp  chomp ","input to_input to_s chomp  ","input to_s chomp  delete! ","input to_s chomp  ginput to_s chomp ub! ","Helperinput to_s chomp   preinput to_s chomp erve "]}," Haml Helpers find_and_preserve":{"type":"method","name":"find_and_preserve","children":[],"call":["input gsub "," preserve ","input scan ","input to_s "," find_and_preserve "," capture_haml ","tags map join ","tags map ","Regexp  method ","input to_s gsub ","s =~ ","s << ","Regexp  escape ","s empty? ","tags each_with_object ","(send\n  (lvar :tags) :map) join ","input gsub  gsub ","input to_s  gsub ","input gsub  scan ","input to_s  scan ","input gsub  to_s ","input to_s  to_s ","(send\n  (lvar :tags) :map) join  map join ","(send\n  (lvar :tags) :map) join  map ","input gsub  to_s gsub ","input to_s  to_s gsub ","(send\n  (lvar :tags) :map) join  each_with_object ","(send\n  (lvar :(send\n  (lvar :tags) :map) join ) :map) join "]}," Haml Helpers ActionViewMods generate_content_class_names":{"type":"method","name":"generate_content_class_names","children":[],"call":[" controller controller_name + + "," controller action_name "," controller "," controller controller_name + "," controller controller_name "]}," Haml Helpers ActionViewMods form_for":{"type":"method","name":"form_for","children":[],"call":[" concat "," is_haml? "," block_given? "," old_form_for "," tab_down ","oldproc call "," tab_up "," bind_proc "]}," Haml Filters Markdown render":{"type":"method","name":"render","children":[],"call":[" to_html ","@engine to_html ","@engine is_a? "," RedCloth  new to_html "," RedCloth  new "," BlueCloth  new to_html "," BlueCloth  new ","@required == ","engine new to_html ","engine new "]}," Haml Filters Textile render":{"type":"method","name":"render","children":[],"call":[" to_html ","@engine to_html "," RedCloth  new to_html "," RedCloth  new "]}," Haml Filters Preserve render":{"type":"method","name":"render","children":[],"call":["Haml Helpers  preserve "]}," Haml Filters Preserve initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml Filters Ruby render":{"type":"method","name":"render","children":[],"call":["old_stdout read ","old_stdout pos= ","Object  new instance_eval ","Object  new ","StringIO  new "]}," Haml Filters Ruby initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml Filters Plain render":{"type":"method","name":"render","children":[],"call":[]}," Haml Filters Plain initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml Exec HTML2Haml process_result":{"type":"method","name":"process_result","children":[],"call":["output write "," Hpricot to_haml "," Hpricot ","@options [] "," Haml HTML  new render "," Haml HTML  new ","@options [] != ","@module_opts [] ","input path =~ ","input path ","input respond_to? "," handle_load_error "," raise ","(begin\n  (if\n    (send\n      (lvar :e) :is_a?\n      (const\n        (const\n          (cbase) :Haml) :SyntaxError))\n    (str \"Syntax error\")\n    (str \"Error\"))) + ","e message "," get_line ","e is_a? "," require "," exit ","$stderr puts ","dep empty? ","dep nil? ","err message scan [] ","err message scan ","err message ","@options []  write ","@options []  path =~ ","@options []  path ","@options []  respond_to? ","err message scan []  empty? ","err message scan []  nil? "]}," Haml Exec HTML2Haml set_opts":{"type":"method","name":"set_opts","children":[],"call":["opts banner= ","@module_opts []= ","opts on ","@options []= ","Encoding  default_internal= ","internal empty? ! ","internal empty? ","Encoding  default_external= ","external empty? ! ","external empty? ","encoding split ","RUBY_VERSION  < "]}," Haml Exec Haml process_result":{"type":"method","name":"process_result","children":[],"call":["output close ","output is_a? ","output write "," Haml Engine  new to_html "," Haml Engine  new ","input close ","input is_a? ","input read ","@options [] "," raise ","e message "," get_line ","engine to_html "," puts ","= * ","engine precompiled "," require ","@options [] each ","$LOAD_PATH << ","@options [] []= "," pp ","engine parser root ","engine parser "," exit ","error message split [] ","error message split ","error message "," validate_ruby ","parser call "," Haml Parser  new "," Haml Options  new ","parser parse ","error message split first ","@options []  close ","@options []  is_a? ","@options []  write ","@options []  read "," Haml Engine  new  to_html "," Haml Engine  new  precompiled "," Haml Engine  new  parser root ","engine  Haml Parser  new  root "," Haml Engine  new  parser ","engine  Haml Parser  new  "," validate_ruby  message split [] "," validate_ruby  message split "," validate_ruby  message "," Haml Parser  new  call "," Haml Parser  new  parse "," validate_ruby  message split first "]}," Haml Exec Haml initialize":{"type":"method","name":"initialize","children":[],"call":["@options []= "]}," Haml Exec Sass process_result":{"type":"method","name":"process_result","children":[],"call":["output close ","output is_a? ","output write "," Sass Engine  new render "," Sass Engine  new ","input close ","input is_a? ","input read ","@options [] "," raise ","e message "," get_line ","tree render "," Sass Engine  new to_tree "," Sass Files  tree_for ","input path ","@options [] ! "," Sass Repl  new run "," Sass Repl  new "," require ","e sass_backtrace_str ","input path =~ "," watch_or_update "," interactive ","@options []= ","@args first split ","@args first ","@args size == ","@args size ","@args first include? "," split_colon_path "," colon_path? ","@options [] [] ","@options []  close ","@options []  is_a? ","@options []  write ","@options []  read "," Sass Engine  new to_tree  render "," Sass Files  tree_for  render "," Sass Engine  new to_ Sass Engine  new to_tree  "," Sass Engine  new to_ Sass Files  tree_for  "," Sass Files   Sass Engine  new to_tree _for "," Sass Files   Sass Files  tree_for _for ","@options []  path ","@options []  path =~ ","@args first split  first split "," split_colon_path  first split ","@args first split  first "," split_colon_path  first ","@args first split  size == "," split_colon_path  size == ","@args first split  size "," split_colon_path  size ","@args first split  first include? "," split_colon_path  first include? "]}," Haml Exec Sass initialize":{"type":"method","name":"initialize","children":[],"call":["@options [] []= ","(str \".\") + ","(or\n  (send\n    (const nil :ENV) :[]\n    (str \"SASSPATH\"))\n  (str \"\")) split ","ENV  [] ","@options [] "]}," Haml Exec HamlSass process_result":{"type":"method","name":"process_result","children":[],"call":[" require ","File  dirname + ","@name downcase ","File  dirname ","@options [] []= ","@options [] "]}," Haml Exec HamlSass set_opts":{"type":"method","name":"set_opts","children":[],"call":["opts banner= ","@name downcase "," exit "," puts ","file puts ","File  open ","File  join ","Dir  mkdir ","File  exists? ","opts on ","@options []= ","StringIO  new ","file << ","File  read ","File  dirname + ","File  dirname "," require ","FileUtils  rm_rf "," gets !~ "," gets "," print ","f grep "," f ","env grep ","Dir  mkFile  join  ","File  File  join name + ","File  File  join name ","File  join  grep "]}," Haml Exec Generic process_result":{"type":"method","name":"process_result","children":[],"call":["@options []= ","File  open ","output is_a? ","input is_a? "," exit "," puts ","File  exists? ! ","File  exists? ","ARGV  [] ","@options [] "," open_file ","@args [] ","args shift ","@args dup ","File  open  is_a? ","@options []  is_a? ","@@args dup  [] ","@args dup  shift ","@@args dup  dup "]}," Haml Exec Generic set_opts":{"type":"method","name":"set_opts","children":[],"call":[" exit "," puts ","Haml  + ","File  read ","File  dirname + ","File  dirname ","opts on_tail ","@options []= ","opts on "," Haml  version [] "," Haml  version ","RbConfig CONFIG  [] =~ ","RbConfig CONFIG  [] "," Haml Util  windows? "]}," Haml Exec Generic to_s":{"type":"method","name":"to_s","children":[],"call":["@opts to_s "]}," Haml Exec Generic parse!":{"type":"method","name":"parse!","children":[],"call":[" process_result ","@opts parse! ","OptionParser  new "," method to_proc "," method "," exit "," puts ","e backtrace [] each ","e backtrace [] ","e backtrace ","@options [] ","e message ","e class ","e backtrace [] scan [] ","e backtrace [] scan "," raise ","e is_a? ","$stderr puts ","$stderr print "," get_line "," parse ","e class == ","OptionParser  new  parse! "," get_e backtrace [] scan []  "]}," Haml Exec Generic initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml Error add_backtrace_entry":{"type":"method","name":"add_backtrace_entry","children":[],"call":[" backtrace unshift "," backtrace "]}," Hash rec_merge":{"type":"method","name":"rec_merge","children":[],"call":["toret rec_merge! "," clone "," clone  rec_merge! "]}," Hash rec_merge!":{"type":"method","name":"rec_merge!","children":[],"call":[" []= ","myval rec_merge! ","myval is_a? ","value is_a? "," [] ","other each "," []  rec_merge! "," []  is_a? "]}," Haml Engine start_filtered":{"type":"method","name":"start_filtered","children":[],"call":["String  new ","@template_tabs * "," push_and_tabulate "," raise ","SyntaxError  new "]}," Haml Engine close_filtered":{"type":"method","name":"close_filtered","children":[],"call":[" push_text ","filtered rstrip gsub ","   * ","filtered rstrip "," push_silent ","filtered dump ","filter == ","filter new render ","filter new "," raise ","HamlError  new ","filter is_a? ","filter new render  rstrip gsub ","filter new render  rstrip ","filter new render  dump "]}," Haml Engine push_plain":{"type":"method","name":"push_plain","children":[],"call":[" push_text "," raise ","SyntaxError  new "]}," Haml Engine render":{"type":"method","name":"render","children":[],"call":["@buffer buffer "," compile "," class send "," class ","local_assigns each ","@scope_object instance_eval ","@options [] ","Haml Buffer  new ","buffer buffer ","@haml_stack pop ","scope_object instance_eval "," eval ","@haml_stack push ","Array  new "," extend "," set_locals ","locals merge "," binding "," block_given? ","scope is_a? "," options_for_buffer ","(or\n  (send\n    (ivar :@options) :[]\n    (sym :locals))\n  (hash)) merge ","buffer upper ","scope instance_variable_get "," precompiled "," precompiled + + "," precompiled_method_return_value "," precompiled + ","scope instance_variable_defined? ","@compiler precompiled_with_return_value ","@options for_buffer "," raise ","e message ","scope_object instance_variable_set ","@options line ","@options filename ","scope_object extend ","@temple_engine precompiled_with_return_value ","Haml Buffer  new  buffer ","@Haml Buffer  new  Haml Buffer  new  ","@options []  each ","@ eval  instance_eval ","Haml Buffer  new  Haml Buffer  new  "," eval  instance_eval "," set_(or\n  (send\n    (ivar :@options) :[]\n    (sym :locals))\n  (hash)) merge  ","(or\n  (send\n    (ivar :@options) :[]\n    (sym :locals))\n  (hash)) merge  merge "," options_for_Haml Buffer  new  ","(or\n  (send\n    (ivar :@options) :[]\n    (sym :(or\n  (send\n    (ivar :@options) :[]\n    (sym :locals))\n  (hash)) merge ))\n  (hash)) merge ","Haml Buffer  new  upper ","@options for_Haml Buffer  new  "," eval  instance_variable_set "," eval  extend "]}," ActionView Helpers generate_content_class_names":{"type":"method","name":"generate_content_class_names","children":[],"call":[" controller controller_name + + "," controller action_name "," controller "," controller controller_name + "," controller controller_name "]}," ActionView Helpers FormHelper form_for_with_haml":{"type":"method","name":"form_for_with_haml","children":[],"call":[" concat "," is_haml? "," block_given? "," form_for_without_haml "," tab_down ","oldproc call "," tab_up "," bind_proc "," haml_bind_proc "," haml_indent ","res << "," with_tabs "," proc ","Haml Helpers ErrorReturn  new "," block_is_haml? "," form_for_without_haml  << "]}," ActionView Helpers FormTagHelper form_tag_with_haml":{"type":"method","name":"form_tag_with_haml","children":[],"call":[" concat "," is_haml? "," block_given? "," form_tag_without_haml + "," form_tag_without_haml "," tab_down ","oldproc call "," tab_up "," bind_proc "," haml_bind_proc "," haml_indent ","res << "," with_tabs ","Haml Helpers ErrorReturn  new "," block_is_haml? "," form_tag_without_haml << "," form_tag_without_haml +  << "," form_tag_without_haml <<  << "]}," ActionView Helpers TextHelper concat_with_haml":{"type":"method","name":"concat_with_haml","children":[],"call":[" concat_without_haml "," buffer buffer concat "," buffer buffer "," buffer "," is_haml? "," haml_buffer buffer concat "," haml_buffer buffer "," haml_buffer "," haml_xss_html_escape "]}," ActionView Base render_with_haml":{"type":"method","name":"render_with_haml","children":[],"call":[" render_without_haml "," is_haml? "," non_haml ","(and\n  (and\n    (send\n      (lvar :options) :is_a?\n      (const nil :Hash))\n    (send\n      (lvar :options) :[]\n      (sym :layout)))\n  (send nil :block_given?)) ! "," block_given? ","options [] ","options is_a? ","args first ","(and\n  (and\n    (send\n      (lvar :args first ) :is_a?\n      (const nil :Hash))\n    (send\n      (lvar :args first ) :[]\n      (sym :layout)))\n  (send nil :block_given?)) ! ","args first  [] ","args first  is_a? "]}," Tree ValueNode to_s":{"type":"method","name":"to_s","children":[],"call":[" value "]}," Sass Tree Node invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":[]}," Tree CommentNode to_s":{"type":"method","name":"to_s","children":[],"call":[" children join "," children "," children empty? "," value ","@style == ","str << ","   * ","tabs - ","spaces + + + ","spaces + + ","content join "," style == "," style ","spaces + ","content last gsub! ","content last ","content first gsub! ","content first ","(if\n  (send\n    (lvar :l) :empty?)\n  (str \"\")\n  (str \" \")) + ","l empty? ","content map! "," value split + ","l text "," lines map "," lines "," value split "," invisible? ","content empty? ","   *  + + + ","   *  + + ","   *  + "]}," Tree CommentNode initialize":{"type":"method","name":"initialize","children":[],"call":["value [] strip ","value [] "," normalize_indentation "]}," Tree AttrNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? ! ","child is_a? "]}," Sass Engine find_file_to_import":{"type":"method","name":"find_file_to_import","children":[],"call":["filename + "," raise ","SyntaxError  new ","new_filename nil? ","File  readable? ","File  join + ","File  join ","@options [] each ","@options [] ","filename [] == ","filename [] ","filename []  + ","new_filename []  nil? ","filename []  [] == ","filename []  [] "]}," Sass Engine import":{"type":"method","name":"import","children":[],"call":["engine constants ","nodes << ","child filename= ","root children each ","root children "," raise ","err add_backtrace_entry ","engine render_to_tree ","engine constants merge! ","Sass Engine  new ","file read ","new_options []= ","@options dup ","File  open ","Tree ValueNode  new ","@options [] ","filename =~ "," find_file_to_import ","files split each ","files split ","SyntaxError  new ","e message "," class find_file_to_import "," class ","engine mixins ","engine mixins merge! ","Tree DirectiveNode  new ","(send\n  (send\n    (lvar :files) :split\n    (regexp\n      (str \",\\\\s*\")\n      (regopt))) :map) flatten ","Tree FileNode  new ","Sass Files  find_file_to_import "," import_paths ","files split map ","Sass Engine  new  constants ","child  find_file_to_import = ","child  class find_file_to_import = ","child Sass Files  find_file_to_import = ","engine render_to_tree  children each ","engine render_to_tree  children ","Sass Engine  new  render_to_tree ","Sass Engine  new  constants merge! ","@options dup  []= "," find_file_to_import  =~ "," class find_file_to_import  =~ ","Sass Files  find_file_to_import  =~ ","Sass Engine  new  mixins ","Sass Engine  new  mixins merge! "]}," Sass Engine parse_directive":{"type":"method","name":"parse_directive","children":[],"call":[" raise ","SyntaxError  new ","(str \"@\") dump "," import ","line [] split ","line [] ","Tree DirectiveNode  new ","@options [] ","value !~ ","directive == ","line text ","Tree DebugNode  new "," parse_script ","line offset + ","line text index to_i ","line text index ","line offset ","@line + ","line children empty? ","line children ","Tree IfNode  new ","Tree WhileNode  new "," parse_else "," parse_for ","directive size + + ","directive size + ","whitespace size ","directive size ","line text [] split ","line text [] ","Tree ImportNode  new ","value split map ","value split ","Tree WarnNode  new ","Tree ExtendNode  new "," parse_interp "," parse_mixin_include "," parse_mixin_definition ","f =~ ","match post_match strip [] != ","match post_match strip [] ","match post_match strip ","match post_match ","match post_match strip empty? ! ","match post_match strip empty? ","value match "," parse_import ","Tree CharsetNode  new ","value [] ","line line offset +  + ","line directive size + +  + ","line line offset +  ","line directive size + +  "]}," Sass Engine parse_comment":{"type":"method","name":"parse_comment","children":[],"call":["Tree RuleNode  new ","@options [] ","Tree CommentNode  new ","line [] == ","line [] "," parse_interp "," format_comment_text "]}," Sass Engine raw_next_line":{"type":"method","name":"raw_next_line","children":[],"call":["index + ","@lines [] [] ","@lines [] "]}," Sass Engine render_to_tree":{"type":"method","name":"render_to_tree","children":[],"call":["root << ","child each ","child is_a? ","child line= "," build_tree ","@lines [] ","Tree Node  new ","@options [] "," split_lines ","@lines clear ","old_index + ","Tree Node  new  << "]}," Sass Engine constants":{"type":"method","name":"constants","children":[],"call":[]}," Sass CSS sort_rules":{"type":"method","name":"sort_rules","children":[],"call":["prev_rule_values << ","child rule ","prev_rules << ","root children delete ","root children ","prev_rules [] << ","prev_rules [] ","child rule slice! ","joined_prev_values size ","prev_rules empty? ","prev_rule_values pop ","prev_rules pop ","child rule =~ ","Regexp  escape ","prev_rule_values join ","child is_a? ","root children each ","c2 is_a? ","(or\n  (send\n    (lvar :c1) :is_a?\n    (const\n      (const nil :Tree) :RuleNode))\n  (send\n    (lvar :c2) :is_a?\n    (const\n      (const nil :Tree) :RuleNode))) ! ","c1 is_a? ","c1 rule <=> ","c2 rule ","c1 rule ","root children sort! ","prev_rule_values join  size "]}," Sass CSS assert_match":{"type":"method","name":"assert_match","children":[],"call":[" whitespace "," raise ","Exception  new ","@template scan ! ","@template scan ","re inspect ","re source ","re source == ","Regexp  escape ","@template string [] count ","@template string [] ","@template pos ","@template string ","was inspect ","after inspect ","line + ","@template rest size >= ","@template rest size ","@template rest ","@template rest [] ","... + ","pos >= ","pos - ","@template @template pos  ","@template rest []  inspect ","... +  inspect ","@template string []  inspect ","@template string [] count  + ","@template pos  >= ","@template pos  - "]}," Sass CSS whitespace":{"type":"method","name":"whitespace","children":[],"call":["space + "," whitespace ","@template scan_until ","@template scan "]}," Sass CSS attributes":{"type":"method","name":"attributes","children":[],"call":[" assert_match ","rule << ","Tree AttrNode  new ","value << << "," whitespace ","value << ","@template [] ","@template scan "]}," Sass CSS rules":{"type":"method","name":"rules","children":[],"call":[" attributes "," whitespace ","root << ","Tree RuleNode  new ","rules join ","@template scan ","rules << ","@template [] "," rule "," att rule ibutes "," rule oot << ","T rule ee RuleNode  new "," rule ules join "," rule ules << ","  rule ule "]}," Sass CSS directives":{"type":"method","name":"directives","children":[],"call":["root << ","Tree ValueNode  new ","value =~ ","name == "," whitespace "," assert_match ","@template scan ","@template scan  =~ ","@template scan  == "]}," Sass CSS build_tree":{"type":"method","name":"build_tree","children":[],"call":[" sort_rules "," rules "," directives "," whitespace ","Tree Node  new "," fold_commas "," flatten_rules "," nest_rules "," expand_commas "," remove_parent_refs "," parent_ref_rules ","Sass SCSS CssParser  new parse ","Sass SCSS CssParser  new "]}," Sass CSS render":{"type":"method","name":"render","children":[],"call":[" raise ","err backtrace unshift ","err backtrace ","@template string [] split size ","@template string [] split ","@template string [] ","@template pos ","@template string "," build_tree to_sass "," build_tree "," build_tree to_sass lstrip "," build_tree to_sass strip + "," build_tree to_sass strip ","err modify_backtrace ","@options [] "," build_tree send strip + "," build_tree send strip "," build_tree send ","Sass SyntaxError  new ","Haml Util  check_encoding "," check_encoding! "]}," Sass CSS initialize":{"type":"method","name":"initialize","children":[],"call":["StringScanner  new ","template read ","template is_a? ","@options []= ","@options [] == ","@options [] ","options dup ","template read  read ","template read  is_a? ","options dup  []= ","options dup  [] == ","options dup  [] "]}," Sass Tree AttrNode to_sass":{"type":"method","name":"to_sass","children":[],"call":[" value "," name ","   * ","opts [] "]}," Sass Tree RuleNode to_sass":{"type":"method","name":"to_sass","children":[],"call":["str << ","child to_sass ","tabs + "," children each "," children "," rule ","   * ","c is_a? "," children any? "," rules first "," rules ","\\ + ","name [] == ","name [] ","\\ +  [] == "," rules first  [] == ","\\ +  [] "," rules first  [] "]}," Sass Tree ValueNode to_sass":{"type":"method","name":"to_sass","children":[],"call":[" value "]}," Sass Tree Node to_sass":{"type":"method","name":"to_sass","children":[],"call":["result << ","child to_sass "," children each "," children ","   * "," to_src "]}," Haml HTML match_to_html":{"type":"method","name":"match_to_html","children":[],"call":["CGI  escapeHTML ","string gsub! "]}," Haml HTML haml_tag_silent":{"type":"method","name":"haml_tag_silent","children":[],"call":[]}," Haml HTML haml_tag_loud":{"type":"method","name":"haml_tag_loud","children":[],"call":[]}," Haml HTML Elem to_haml":{"type":"method","name":"to_haml","children":[],"call":["child to_haml ","tabs + "," children each "," children "," children length == "," children length "," attributes inspect "," attributes "," attributes length > "," attributes length "," attributes delete "," attributes [] split each "," attributes [] split "," attributes [] "," name "," attributes include? "," name == ","output + ","HTML  send "," innerHTML "," name [] "," name [] == ","HTML  options [] ","HTML  options "," tabulate "," haml_attributes "," remove_attribute ","CGI  unescapeHTML ","(or\n  (send\n    (self) :children)\n  (array)) inject "," static_classname? "," static_id? "," inner_text "," send ","options [] "," attr_hash length > "," attr_hash length "," attr_hash "," attr_hash [] split each "," attr_hash [] split "," attr_hash [] "," render_children ","child to_haml lstrip ","child name == ","child name ","child is_a? ","output + + "," innerText gsub "," innerText "," parent name == "," parent name "," parent "," parent is_a? ","(str \"pre\") include? ","text lstrip gsub ","text lstrip ","text chomp include? ","text chomp ","child to_s include? ! ","child to_s include? ","child to_s "," children first "," children size == "," children size ","output << "," etag ! "," etag "," empty? "," set_attribute ","leftover join ","leftover empty? "," haml_css_attr? "," attr_hash [] split reject "," attr_hash [] split any? "," method "," next content slice! dump "," next content slice! "," next content "," next "," previous previous nil? "," previous previous "," previous "," previous content =~ "," previous content "," previous text? "," previous nil? "," next content =~ "," next text? ","(send\n  (send\n    (send\n      (const nil :CGI) :unescapeHTML\n      (send nil :inner_text)) :split\n    (str \"\\n\")) :map) join ","line strip ","line strip empty? ","CGI  unescapeHTML split map ","CGI  unescapeHTML split ","(send\n  (lvar :lines) :map) join ","lines map ","lines << ","(send\n  (send\n    (send\n      (send nil :next_sibling) :inner_text) :split\n    (str \"\\n\")) :reject) size > ","(send\n  (send\n    (send\n      (send nil :next_sibling) :inner_text) :split\n    (str \"\\n\")) :reject) size ","s strip empty? ","s strip "," next_sibling inner_text split reject "," next_sibling inner_text split "," next_sibling inner_text "," next_sibling "," next_sibling name == "," next_sibling name "," next_sibling is_a? ","(str \"%\") % ","length -@ ","lines map! ","(send\n  (lvar :lines) :map) max + ","(send\n  (lvar :lines) :map) max ","s size ","s gsub! ","lines [] each ","lines [] ","indent_str count + ","8 * ","indent_str count ","lines last [] ","lines last ","lines size > ","lines size ","lines first gsub! ","lines first ","(send\n  (send\n    (send\n      (const nil :CGI) :unescapeHTML\n      (send nil :inner_text)) :split\n    (str \"\\n\")) :map) reject ","s rstrip "," to_haml_filter ","(send\n  (send\n    (send nil :attr_hash) :keys) :-\n  (array\n    (str \"type\"))) empty? "," attr_hash keys - "," attr_hash keys "," attr_hash [] == "," attr_hash [] nil? "," converted_to_haml "," children first  to_haml ","  children first ren each ","  children first ren ","  children first ren length == "," children (send\n  (lvar :lines) :map) max +  == ","  children first ren length "," children (send\n  (lvar :lines) :map) max +  "," attributes (send\n  (lvar :lines) :map) max +  > "," attributes (send\n  (lvar :lines) :map) max +  "," tabulate  + ","(or\n  (send\n    (self) : children first ren)\n  (array)) inject "," inner_child to_haml  "," attr_hash (send\n  (lvar :lines) :map) max +  > "," attr_hash (send\n  (lvar :lines) :map) max +  "," render_ children first ren "," children first  to_haml lstrip "," children first  name == "," children first  name "," children first  is_a? "," tabulate  + + ","child to_haml  lstrip gsub ","child to_haml  lstrip ","child to_haml  chomp include? ","child to_haml  chomp "," children first  to_s include? ! "," children first  to_s include? "," children first  to_s ","  children first ren first ","  children first ren size == ","  children first ren size "," tabulate  << "," previous child to_haml ? "," next child to_haml ? ","(send\n  (send\n    (send\n      (const nil :CGI) :unescapeHTML\n      (send nil :inner_child to_haml )) :split\n    (str \"\\n\")) :map) join ","(send\n  (send\n    (send\n      (send nil :next_sibling) :inner_child to_haml ) :split\n    (str \"\\n\")) :reject) size > ","(send\n  (send\n    (send\n      (send nil :next_sibling) :inner_child to_haml ) :split\n    (str \"\\n\")) :reject) size "," next_sibling inner_child to_haml  split reject "," next_sibling inner_child to_haml  split "," next_sibling inner_child to_haml  ","(send\n  (lvar :lines) :map) max +  -@ ","lines last []  count + ","lines last []  count ","(send\n  (send\n    (send\n      (const nil :CGI) :unescapeHTML\n      (send nil :inner_child to_haml )) :split\n    (str \"\\n\")) :map) reject "]}," Haml HTML Comment to_haml":{"type":"method","name":"to_haml","children":[],"call":[" parse_text ","tabs + "," content "," tabulate ","content strip ","content include? ","content =~ ","  content  "," content  strip "," content  include? "," content  =~ "]}," Haml HTML DocType to_haml":{"type":"method","name":"to_haml","children":[],"call":[" tabulate ","strictness []= ","strictness [] - ","strictness [] ","strictness empty? ","strictness == ","version empty? ","version == ","type == ","a downcase ","attrs map "," raise ","Exception  new ","attrs == "," public_id scan [] "," public_id scan "," public_id ","strictness capitalize ","version capitalize "," public_id nil? ","Haml SyntaxError  new "," public_id scan []  map "," public_id scan []  == "]}," Haml HTML XMLDecl to_haml":{"type":"method","name":"to_haml","children":[],"call":[" tabulate "]}," Haml HTML Doc to_haml":{"type":"method","name":"to_haml","children":[],"call":["child to_haml "," children each "," children ","s << ","c to_haml ","(or\n  (send nil :children)\n  (array)) inject "]}," Haml HTML options":{"type":"method","name":"options","children":[],"call":[]}," Haml HTML Node parse_text":{"type":"method","name":"parse_text","children":[],"call":["(send\n  (lvar :lines) :map) join ","Haml Engine SPECIAL_CHARACTERS  include? ","line [] "," tabulate ","line strip! ","lines map ","text split ","String  new ","text empty? ","text strip! ","text gsub! "," parse_text_with_interpolation "," uninterp ","(send\n  (lvar :text split ) :map) join ","text split  map "]}," Haml HTML Node tabulate":{"type":"method","name":"tabulate","children":[],"call":["   * "]}," Haml HTML Node to_haml":{"type":"method","name":"to_haml","children":[],"call":[" parse_text "," to_s "," parse_text_with_interpolation ","node next_node ","node converted_to_haml= ","text << "," uninterp ","node to_s ","node next_node is_a? ","text << << << ","text << << ","CGI  unescapeHTML gsub strip ","CGI  unescapeHTML gsub ","CGI  unescapeHTML ","node inner_text ","node name == ","node name ","node is_a? "," next_node "," to_s strip empty? "," to_s strip "," converted_to_haml "," parse_ uninterp  "," parse_ uninterp _with_interpolation ","node next_node  next_node next_node  "," next_node  next_ next_node  ","node next_node  converted_to_haml= "," next_node  converted_to_haml= "," uninterp  << ","node next_node  to_s "," next_node  to_s ","node next_node  next_node next_node  is_a? "," next_node  next_ next_node  is_a? "," uninterp  << << << "," uninterp  << << ","node next_node  inner_text "," next_node  inner_text ","node inner_ uninterp  ","node next_node  name == "," next_node  name == ","node next_node  name "," next_node  name ","node next_node  is_a? "," next_node  is_a? "," next_node next_node  "," next_ next_node  "]}," Haml HTML render":{"type":"method","name":"render","children":[],"call":["@template to_haml "]}," Haml HTML initialize":{"type":"method","name":"initialize","children":[],"call":[" Hpricot "," match_to_html ","@@options [] ","template read ","template is_a? ","method call "," method ","Hpricot  method ","template gsub ","@options [] ","ERB  compile "," require "," raise ","Haml Error  new ","Haml Util  check_encoding ","opts []= ","opts dup ","DEPRECATED_FORMATS  include? ","opts [] ","template read  read ","ERB  compile  read ","template read  is_a? ","ERB  compile  is_a? "," method  call ","Hpricot  method  call ","  method  "," Hpricot  method  ","Hpricot   method  ","Hpricot  Hpricot  method  ","template read  gsub ","ERB  compile  gsub ","opts dup  []= ","opts dup  dup ","opts dup  [] "]}," Haml Helpers open":{"type":"method","name":"open","children":[],"call":[" puts "," tab_down ","block call "," tab_up "," buffer build_attributes "," buffer ","attributes is_a? ","text empty? ","Haml Precompiler  build_attributes "," buffer options [] "," buffer options ","block nil? ","text nil? "," haml_tag "," warn "]}," Haml Helpers puts":{"type":"method","name":"puts","children":[],"call":[" buffer buffer << << << "," buffer buffer << << ","text to_s "," buffer buffer << ","   * "," buffer tabulation "," buffer "," buffer buffer "," haml_buffer buffer << << << "," haml_buffer buffer << << "," haml_buffer buffer << "," haml_buffer tabulation "," haml_buffer "," haml_buffer buffer "," haml_concat "," warn "]}," Haml Helpers html_attrs":{"type":"method","name":"html_attrs","children":[],"call":[" haml_buffer options [] == "," haml_buffer options [] "," haml_buffer options "," haml_buffer "]}," ActionView Helpers CaptureHelper capture_erb_with_buffer_with_haml":{"type":"method","name":"capture_erb_with_buffer_with_haml","children":[],"call":[" capture_erb_with_buffer_without_haml "," capture_haml_with_buffer "," is_haml? "," capture_haml "]}," Haml Helpers ActionViewExtensions page_class":{"type":"method","name":"page_class","children":[],"call":[" controller controller_name + + "," controller action_name "," controller "," controller controller_name + "," controller controller_name "]}," Haml Exec CSS2Sass process_result":{"type":"method","name":"process_result","children":[],"call":["output write "," Sass CSS  new render "," Sass CSS  new ","@options [] ","@options []  write "]}," Haml Exec CSS2Sass set_opts":{"type":"method","name":"set_opts","children":[],"call":["opts banner= ","@module_opts []= ","opts on ","opts on_tail "]}," Haml Exec CSS2Sass initialize":{"type":"method","name":"initialize","children":[],"call":[" require "]}," Haml Exec HTML2Haml initialize":{"type":"method","name":"initialize","children":[],"call":[" exit "," puts ","err message scan [] ","err message scan ","err message "," require ","$stderr puts "," raise ","dep empty? ","dep nil? ","@options [] ","err message scan []  empty? ","err message scan []  nil? "]}," Haml Engine unescape_interpolation":{"type":"method","name":"unescape_interpolation","children":[],"call":["substr gsub ","str dump gsub gsub ","str dump gsub ","str dump "]}," Haml Engine prerender_tag":{"type":"method","name":"prerender_tag","children":[],"call":[" build_attributes "]}," Haml Engine build_attributes":{"type":"method","name":"build_attributes","children":[],"call":["result sort join ","result sort ","v gsub ","v include? ","@options [] ","v empty? ","v nil? ","v to_s ","attributes collect ","@options [] == ","v gsub  gsub ","v to_s  gsub ","v gsub  include? ","v to_s  include? ","v gsub  empty? ","v to_s  empty? ","v gsub  nil? ","v to_s  nil? ","v gsub  to_s ","v to_s  to_s "]}," Haml Engine parse_literal_hash":{"type":"method","name":"parse_literal_hash","children":[],"call":["attributes []= ","(lvasgn :value\n  (send nil :parse_literal_value\n    (lvar :value))) nil? "," parse_literal_value ","(lvasgn :key\n  (send nil :parse_literal_value\n    (lvar :key))) nil? ","attrib split ","inner [] split each ","inner [] split ","inner [] ","text scan [] ","text scan ","(lvasgn : parse_literal_value \n  (send nil :parse_literal_ parse_literal_value \n    (lvar : parse_literal_value ))) nil? "," parse_literal_ parse_literal_value  ","(lvasgn :key\n  (send nil :parse_literal_ parse_literal_value \n    (lvar :key))) nil? ","(lvasgn : parse_literal_value \n  (send nil :parse_literal_value\n    (lvar : parse_literal_value ))) nil? ","text scan []  [] split each ","text scan []  [] split ","text scan []  [] "]}," Haml Engine parse_literal_value":{"type":"method","name":"parse_literal_value","children":[],"call":["text match "]}," Haml Engine parse_class_and_id":{"type":"method","name":"parse_class_and_id","children":[],"call":["attributes []= ","attributes [] ","list scan "]}," Haml Engine close_haml_comment":{"type":"method","name":"close_haml_comment","children":[],"call":[]}," Haml Engine start_haml_comment":{"type":"method","name":"start_haml_comment","children":[],"call":[" push_and_tabulate "]}," Haml Engine assign_method_name":{"type":"method","name":"assign_method_name","children":[],"call":["@@method_names []= ","(str \"_render_haml_\") intern "]}," Haml Engine precompiled":{"type":"method","name":"precompiled","children":[],"call":["$stderr puts ","@precompiled encode ","Encoding  find ","@options [] "," ruby1_8? ","@precompiled force_encoding ","encoding == ","@precompiled force_Encoding  find  ","Encoding  find  == "]}," Haml Buffer underscore":{"type":"method","name":"underscore","children":[],"call":["camel_cased_word to_s gsub gsub gsub tr downcase ","camel_cased_word to_s gsub gsub gsub tr ","camel_cased_word to_s gsub gsub gsub ","camel_cased_word to_s gsub gsub ","camel_cased_word to_s gsub ","camel_cased_word to_s ","word downcase! ","word tr! ","word gsub! ","camel_cased_word to_s dup ","camel_cased_camel_cased_word to_s dup  to_s gsub gsub gsub tr downcase ","camel_cased_camel_cased_word to_s dup  to_s gsub gsub gsub tr ","camel_cased_camel_cased_word to_s dup  to_s gsub gsub gsub ","camel_cased_camel_cased_word to_s dup  to_s gsub gsub ","camel_cased_camel_cased_word to_s dup  to_s gsub ","camel_cased_camel_cased_word to_s dup  to_s ","camel_cased_word to_s dup  downcase! ","camel_cased_word to_s dup  tr! ","camel_cased_word to_s dup  gsub! ","camel_cased_camel_cased_word to_s dup  to_s dup "]}," Haml Buffer merge_attrs":{"type":"method","name":"merge_attrs","children":[],"call":[]}," Haml Buffer open_prerendered_tag":{"type":"method","name":"open_prerendered_tag","children":[],"call":["@buffer << "," tabs "]}," Haml Buffer tabulation=":{"type":"method","name":"tabulation=","children":[],"call":["val > ","val - ","val -  > ","val -  - "]}," Haml Buffer tabulation":{"type":"method","name":"tabulation","children":[],"call":["@real_tabs + "]}," MerbHandler process_with_sass":{"type":"method","name":"process_with_sass","children":[],"call":[" process_without_sass ","Sass Plugin  update_stylesheets ","Sass Plugin  options [] ","Sass Plugin  options ","Sass Plugin  checked_for_updates ! ","Sass Plugin  checked_for_updates ","Sass Plugin  check_for_updates "]}," Tree RuleNode continued?":{"type":"method","name":"continued?","children":[],"call":[" rule [] == "," rule [] "," rule ","@rules last [] == ","@rules last [] ","@rules last ","last [] == ","last [] ","last is_a? ","@rule last ","@rules @rule last  [] == ","@rules @rule last  [] ","@rules @rule last  ","@rule last  [] == ","@rule last  [] ","@rule last  is_a? ","@rule @rule last  "]}," Sass Tree Node check_multiline_rule":{"type":"method","name":"check_multiline_rule","children":[],"call":[" raise ","SyntaxError  new ","rule line ","rule children empty? ","rule children "]}," Tree DirectiveNode to_s":{"type":"method","name":"to_s","children":[],"call":["result rstrip + ","(if\n  (send\n    (ivar :@style) :==\n    (sym :expanded))\n  (str \"\\n\")\n  (str \" \")) + ","@style == ","result rstrip ","result << ","child to_s + ","child to_s ","tabs + ","child is_a? ","rendered lstrip! ","result []= "," check_multiline_rule ","child continued? "," children each "," children ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) + "," value ","   * ","tabs - "," value + "," children empty? ","(if\n  (send\n    (send nil :style) :==\n    (sym :expanded))\n  (str \"\\n\")\n  (str \" \")) + "," style == "," style ","child invisible? ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  rstrip + ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  rstrip ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  << ","child to_s  lstrip! ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  []= "]}," Sass Plugin dependencies":{"type":"method","name":"dependencies","children":[],"call":["(send\n  (send\n    (send\n      (const nil :File) :readlines\n      (lvar :filename)) :grep\n    (regexp\n      (str \"^@import \")\n      (regopt))) :map) flatten grep ","(send\n  (send\n    (send\n      (const nil :File) :readlines\n      (lvar :filename)) :grep\n    (regexp\n      (str \"^@import \")\n      (regopt))) :map) flatten ","Sass Engine  find_file_to_import "," load_paths ","inc strip ","line [] split map ","line [] split ","line [] ","File  readlines grep map ","File  readlines grep ","File  readlines ","Sass Files  find_file_to_import ","(send\n  (const nil :File) :dirname\n  (lvar :filename)) + ","File  dirname ","(send\n  (block\n    (send\n      (send\n        (const nil :Files) :tree_for\n        (lvar :filename)\n        (send nil :engine_options)) :select)\n    (args\n      (arg :n))\n    (send\n      (lvar :n) :is_a?\n      (const\n        (const nil :Tree) :ImportNode))) :map) compact ","n full_filename ","n full_filename =~ ","(send\n  (send\n    (const nil :Files) :tree_for\n    (lvar :filename)\n    (send nil :engine_options)) :select) map ","n is_a? ","Files  tree_for select ","Files  tree_for "," engine_options "]}," Sass Plugin dependency_updated?":{"type":"method","name":"dependency_updated?","children":[],"call":[" dependencies any? "," dependency_updated? "," dependencies ","File  mtime > ","File  mtime "," lambda "]}," Sass Plugin forbid_update?":{"type":"method","name":"forbid_update?","children":[],"call":["name [] == ","name [] ","name sub [] == ","name sub [] ","name sub "]}," Sass Plugin exception_string":{"type":"method","name":"exception_string","children":[],"call":["e backtrace join ","e backtrace ","e_string << ","min + + ","min + ","File  read rstrip split [] each_with_index ","File  read rstrip split [] ","e sass_line + ","e sass_line ","File  read rstrip split ","File  read rstrip ","File  read ","e sass_filename ","(send\n  (send\n    (lvar :e) :sass_line) :-\n  (int 5)) max ","e sass_line - ","File  exists? ","e is_a? ","e message ","e class "," options [] "," options ","e_string gsub gsub ","e_string gsub ","(send\n  (send\n    (lvar :e) :sass_line) :-\n  (int 5)) max  + + ","(send\n  (send\n    (lvar :e) :sass_line) :-\n  (int 5)) max  + "]}," Sass Plugin load_paths":{"type":"method","name":"load_paths","children":[],"call":["(or\n  (send\n    (send nil :options) :[]\n    (sym :load_paths))\n  (array)) + "," options [] "," options ","(or\n  (send\n    (lvar :opts) :[]\n    (sym :load_paths))\n  (array)) + ","opts [] "," template_locations "]}," Sass Engine find_full_path":{"type":"method","name":"find_full_path","children":[],"call":[]}," Sass CSS fold_commas":{"type":"method","name":"fold_commas","children":[],"call":["root children compact! ","root children "," fold_commas ","prev_rule rule << ","child rule ","prev_rule rule ","prev_rule children == ","child children ","prev_rule children ","Tree RuleNode  === ","root children map! ","child is_a? ","prev_rule rules first << ","child rules first ","child rules ","prev_rule rules first ","prev_rule rules ","prev_rule rule first << ","child rule first ","prev_rule rule first "]}," Sass CSS flatten_rule":{"type":"method","name":"flatten_rule","children":[],"call":[" flatten_rules ","rule children= ","child children ","rule rule= ","child rule ","rule rule ","rule children first ","rule children ","rule children first is_a? ","rule children size == ","rule children size ","child rule gsub ","child rule [] == ","child rule [] ","rule rules= ","child rules first ","child rules ","rule rules first ","rule rules ","child rules first gsub ","child rules first [] == ","child rules first [] ","child rule first ","rule rule first ","child rule first gsub ","child rule first [] == ","child rule first [] ","rule rule children first ren= ","rule children first  rule children first ren ","rule children first  rule ","rule rule children first ren first ","rule rule children first ren ","rule rule children first ren first is_a? ","rule rule children first ren size == ","rule rule children first ren size ","rule children first  rule gsub ","rule children first  rule [] == ","rule children first  rule [] ","rule children first  rules first ","rule children first  rules ","rule children first  rules first gsub ","rule children first  rules first [] == ","rule children first  rules first [] ","rule children first  rule first ","rule children first  rule first gsub ","rule children first  rule first [] == ","rule children first  rule first [] "]}," Sass CSS flatten_rules":{"type":"method","name":"flatten_rules","children":[],"call":[" flatten_rule ","child is_a? ","root children each ","root children "," flatten_rules "]}," Sass CSS nest_rules":{"type":"method","name":"nest_rules","children":[],"call":["rules values ","root children "," nest_rules ","rules values each ","child children ","rules [] children ","rules [] ","rules [] << ","child rule= ","Tree RuleNode  new ","child rule split ","child rule ","root children delete ","(send\n  (send\n    (lvar :root) :children) :select) each ","Tree RuleNode  === ","root children select ","OrderedHash  new ","OrderedHash  new  values "," nest_OrderedHash  new  ","OrderedHash  new  values each ","OrderedHash  new  [] children ","OrderedHash  new  [] ","OrderedHash  new  [] << "]}," Sass CSS expand_commas":{"type":"method","name":"expand_commas","children":[],"call":["root children flatten! ","root children ","node children= ","child children ","Tree RuleNode  new ","child rule split map ","child rule split ","child rule ","child rule include? ","Tree RuleNode  === ","root children map! ","rule strip ","child rules first split map ","child rules first split ","child rules first ","child rules ","child rules first include? ","child rule first split map ","child rule first split ","child rule first "," expand_commas ","child is_a? ","child rule first include? ","Tree RuleNode  new  children= "]}," Sass OrderedHash values":{"type":"method","name":"values","children":[],"call":[" map "]}," Sass OrderedHash each":{"type":"method","name":"each","children":[],"call":["node value ","node key ","node next ","@first value ","@first key ","node next  value ","node next  key ","node next  next "]}," Sass OrderedHash []=":{"type":"method","name":"[]=","children":[],"call":["@hash []= ","@last next= ","@first nil? ","Node  new ","node prev= ","old prev next= ","old next ","old prev ","@hash [] ","Node  new  prev= ","@hash []  prev next= ","@hash []  next ","@hash []  prev "]}," Sass OrderedHash []":{"type":"method","name":"[]","children":[],"call":["@hash [] value ","@hash [] "]}," Sass OrderedHash initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Constant get_constant":{"type":"method","name":"get_constant","children":[],"call":[" raise ","SyntaxError  new ","constants [] "]}," Constant String funcall":{"type":"method","name":"funcall","children":[],"call":["Sass Constant String  from_value ","other to_s "," to_s "]}," Haml init_rails":{"type":"method","name":"init_rails","children":[],"call":[]}," Haml Template compile":{"type":"method","name":"compile","children":[],"call":["Haml Engine  new send ","Haml Engine  new ","Haml Template  options dup ","Haml Template  options ","Haml Template  Haml Template  options dup  dup ","Haml Template  Haml Template  options dup  "]}," Haml Template line_offset":{"type":"method","name":"line_offset","children":[],"call":[" class line_offset "," class "]}," ActionView Base compile_haml":{"type":"method","name":"compile_haml","children":[],"call":["@@compile_time []= ","Time  now "," raise ","TemplateError  new "," logger debug ","e backtrace join ","e backtrace "," logger ","Haml Engine  new def_method ","Haml Engine  new ","options []= ","Haml Template  options dup ","Haml Template  options ","@@template_args []= ","h []= ","locals_keys inject ","@@template_args [] keys | ","@@template_args [] keys ","@@template_args [] ","local_assigns keys "," assign_method_name ","ActionView TemplateError  new "," view_paths first "," view_paths "," extract_base_path_from ","Haml Util  to_hash ","locals_keys map ","Haml Template  options dup  []= ","Haml Template  Haml Template  options dup  dup ","Haml Template  Haml Template  options dup  ","@@template_args [] keys |  inject ","local_assigns keys _keys inject ","@@template_args [] keys |  map ","local_assigns keys _keys map "]}," ActionView Base compile_template_with_haml":{"type":"method","name":"compile_template_with_haml","children":[],"call":[" compile_template_without_haml "," compile_haml ","extension to_s == ","extension to_s "]}," ActionView Base delegate_template_exists_with_haml":{"type":"method","name":"delegate_template_exists_with_haml","children":[],"call":[" template_exists? "]}," Haml Precompiler newline":{"type":"method","name":"newline","children":[],"call":["@precompiled << "]}," Haml Precompiler flat?":{"type":"method","name":"flat?","children":[],"call":["@flat_spaces != "]}," Haml Precompiler push_and_tabulate":{"type":"method","name":"push_and_tabulate","children":[],"call":["@to_close_stack push "]}," Haml Precompiler count_soft_tabs":{"type":"method","name":"count_soft_tabs","children":[],"call":["spaces / "," raise ","SyntaxError  new ","line strip empty? ","line strip ","line [] == ","line [] ","line index ","(str \"A tab character was used for indentation. Haml must be indented using two spaces.\\n\") strip ","@next_line index ","line index  / ","(str \"A tab character was used for indentation. Haml must be indented using two line index .\\n\") strip "]}," Haml Precompiler balance_brackets":{"type":"method","name":"balance_brackets","children":[],"call":[" raise ","SyntaxError  new ","str [] ","count == ","scanner matched [] == ","scanner matched [] ","scanner matched ","str << ","scanner scan "]}," Haml Precompiler unescape_interpolation":{"type":"method","name":"unescape_interpolation","children":[],"call":["str + ","scan rest ","str << "," eval "," balance_brackets ","scan matched [] ","scan matched ","scan scan ","StringScanner  new ","str dump "," balance [] [] "," balance [] "," balance ","#{ + + ","#{ + ","\" + + ","\" + ","escapes % == ","escapes % ","-3 - ","(send\n  (send\n    (send\n      (lvar :scan) :[]\n      (int 2)) :size) :-\n  (int 1)) / ","scan [] size - ","scan [] size ","scan [] ","res + ","res << ","Haml Shared  handle_interpolation ","StringScanner  new  rest ","StringScanner  new  matched [] ","StringScanner  new  matched ","StringScanner  new  StringScanner  new  ","(send\n  (send\n    (send\n      (lvar :scan) :[]\n      (int 2)) :size) :-\n  (int 1)) /  % == ","(send\n  (send\n    (send\n      (lvar :scan) :[]\n      (int 2)) :size) :-\n  (int 1)) /  % ","(send\n  (send\n    (send\n      (lvar :StringScanner  new ) :[]\n      (int 2)) :size) :-\n  (int 1)) / ","StringScanner  new  [] size - ","StringScanner  new  [] size ","StringScanner  new  [] "]}," Haml Precompiler start_filtered":{"type":"method","name":"start_filtered","children":[],"call":["String  new ","@template_tabs * "," push_and_tabulate "," raise ","HamlError  new ","filter == "," options [] [] "," options [] "," options ","SyntaxError  new ","Error  new ","Filters  defined [] ","Filters  defined ","name =~ ","@indentation * "," options [] []  == ","Filters  defined []  == "]}," Haml Precompiler text_for_doctype":{"type":"method","name":"text_for_doctype","children":[],"call":["version == ","text scan [] ","text scan ","text split [] ","text split ","@options [] ","text [] == ","text [] ","text [] lstrip downcase ","text [] lstrip "," html4? "," xhtml? "," html5? "," html? ","text index == ","text index ","text [] lstrip downcase  scan [] ","text [] lstrip downcase  scan ","text [] lstrip downcase  split [] ","text [] lstrip downcase  split ","text [] lstrip downcase  [] == ","text [] lstrip downcase  [] ","text [] lstrip downcase  [] lstrip downcase ","text [] lstrip downcase  [] lstrip ","text [] lstrip downcase  index == ","text [] lstrip downcase  index "]}," Haml Precompiler render_doctype":{"type":"method","name":"render_doctype","children":[],"call":[" push_text "," text_for_doctype "," raise ","SyntaxError  new ","@next_line index "," block_opened? "," text_for_ text_for_doctype  "]}," Haml Precompiler render_comment":{"type":"method","name":"render_comment","children":[],"call":[" close "," push_text ","content empty? "," push_and_tabulate ","conditional nil? ! ","conditional nil? ","Buffer  one_liner? ","content empty? ! "," raise ","SyntaxError  new ","conditional << ","content strip! ","line scan [] ","line scan ","line empty? ","line empty? ! ","line strip! "," balance ","line [] == ","line [] ","@next_line index "," block_opened? "]}," Haml Precompiler render_div":{"type":"method","name":"render_div","children":[],"call":[" render_tag ","%div + "]}," Haml Precompiler render_tag":{"type":"method","name":"render_tag","children":[],"call":[" push_script "," flush_merged_text "," push_and_tabulate ","value empty? "," push_silent ","attributes inspect ","(send\n  (send\n    (lvar :value) :empty?) :!) inspect ","value empty? ! ","atomic inspect ","tag_name inspect ",",  + ","value dump "," push_merged_text ","open_tag << "," prerender_tag ","parse ! ","Buffer  one_liner? ","flattened ! ","attributes_hash nil? ","object_ref == ","@options [] include? ","@options [] ","@block_opened ! "," raise ","SyntaxError  new ","Buffer  merge_attrs "," parse_class_and_id "," parse_static_hash ","object_ref nil? "," unescape_interpolation ","value [] strip ","value [] ","value [] == ","attributes =~ ","attributes_hash [] ","value to_s strip ","value to_s ","line scan [] ","line scan "," parse_tag "," concat_merged_text ","(str \"</\") + ","(send\n  (array\n    (lvar :tag_name)\n    (lvar :self_closing)\n    (send\n      (ivar :@block_opened) :!)\n    (lvar :preserve_tag)\n    (lvar :escape_html)\n    (lvar :attributes)\n    (lvar :nuke_outer_whitespace)\n    (lvar :nuke_inner_whitespace)) :map) join ","v inspect ","(lvar :tag_name) map ","nuke_outer_whitespace ! ","self_closing ! ","preserve_script ! ","(and\n  (and\n    (send\n      (ivar :@block_opened) :!)\n    (send\n      (lvar :value) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ! ","(and\n  (and\n    (send\n      (ivar :@block_opened) :!)\n    (send\n      (lvar :value) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ","action != ","action == "," xhtml? "," options [] include? "," options [] "," options "," rstrip_buffer! ","@next_line index "," options [] ! ","(send\n  (array\n    (lvar :tag_name)\n    (lvar :self_closing)\n    (send\n      (send nil :block_opened?) :!)\n    (lvar :preserve_tag)\n    (lvar :escape_html)\n    (lvar :attributes)\n    (lvar :nuke_outer_whitespace)\n    (lvar :nuke_inner_whitespace)) :map) join "," block_opened? ! "," block_opened? ","attributes_hashes join ","attributes_hashes first ","attributes_hashes size == ","attributes_hashes size ","attributes_hashes empty? ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ","last_line - ","(send\n  (lvar :attributes_hashes) :map!) compact! ","syntax == ","attributes_hashes map! "," contains_interpolation? "," unescape_interpolation  empty? ","value to_s strip  empty? ","value [] strip  empty? "," parse_class_and_id  inspect ","(send\n  (send\n    (lvar : unescape_interpolation ) :empty?) :!) inspect ","(send\n  (send\n    (lvar :value to_s strip ) :empty?) :!) inspect ","(send\n  (send\n    (lvar :value [] strip ) :empty?) :!) inspect "," unescape_interpolation  empty? ! ","value to_s strip  empty? ! ","value [] strip  empty? ! "," unescape_interpolation  dump ","value to_s strip  dump ","value [] strip  dump "," prerender_tag  << ",",  +  nil? ","attributes_hash []  nil? "," parse_class_and_id _hash nil? "," unescape_interpolation  [] strip ","value to_s strip  [] strip ","value [] strip  [] strip "," unescape_interpolation  [] ","value to_s strip  [] ","value [] strip  [] "," unescape_interpolation  [] == ","value to_s strip  [] == ","value [] strip  [] == "," parse_class_and_id  =~ ",",  +  [] ","attributes_hash []  [] "," parse_class_and_id _hash [] "," unescape_interpolation  to_s strip ","value to_s strip  to_s strip ","value [] strip  to_s strip "," unescape_interpolation  to_s ","value to_s strip  to_s ","value [] strip  to_s ","(send\n  (array\n    (lvar :tag_name)\n    (lvar :self_closing)\n    (send\n      (ivar :@block_opened) :!)\n    (lvar :preserve_tag)\n    (lvar :escape_html)\n    (lvar : parse_class_and_id )\n    (lvar :nuke_outer_whitespace)\n    (lvar :nuke_inner_whitespace)) :map) join ","(send\n  (array\n    (lvar :tag_name)\n    (lvar : xhtml? )\n    (send\n      (ivar :@block_opened) :!)\n    (lvar :preserve_tag)\n    (lvar :escape_html)\n    (lvar :attributes)\n    (lvar :nuke_outer_whitespace)\n    (lvar :nuke_inner_whitespace)) :map) join ","(send\n  (array\n    (lvar :tag_name)\n    (lvar :self_closing)\n    (send\n      (ivar :@block_opened) :!)\n    (lvar : options [] include? )\n    (lvar :escape_html)\n    (lvar :attributes)\n    (lvar :nuke_outer_whitespace)\n    (lvar :nuke_inner_whitespace)) :map) join "," xhtml?  ! ","(and\n  (and\n    (send\n      (ivar :@block_opened) :!)\n    (send\n      (lvar : unescape_interpolation ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ! ","(and\n  (and\n    (send\n      (ivar :@block_opened) :!)\n    (send\n      (lvar :value to_s strip ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ! ","(and\n  (and\n    (send\n      (ivar :@block_opened) :!)\n    (send\n      (lvar :value [] strip ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ! ","(and\n  (and\n    (send\n      (ivar :@block_opened) :!)\n    (send\n      (lvar : unescape_interpolation ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ","(and\n  (and\n    (send\n      (ivar :@block_opened) :!)\n    (send\n      (lvar :value to_s strip ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ","(and\n  (and\n    (send\n      (ivar :@block_opened) :!)\n    (send\n      (lvar :value [] strip ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ","(send\n  (array\n    (lvar :tag_name)\n    (lvar :self_closing)\n    (send\n      (send nil :block_opened?) :!)\n    (lvar :preserve_tag)\n    (lvar :escape_html)\n    (lvar : parse_class_and_id )\n    (lvar :nuke_outer_whitespace)\n    (lvar :nuke_inner_whitespace)) :map) join ","(send\n  (array\n    (lvar :tag_name)\n    (lvar : xhtml? )\n    (send\n      (send nil :block_opened?) :!)\n    (lvar :preserve_tag)\n    (lvar :escape_html)\n    (lvar :attributes)\n    (lvar :nuke_outer_whitespace)\n    (lvar :nuke_inner_whitespace)) :map) join ","(send\n  (array\n    (lvar :tag_name)\n    (lvar :self_closing)\n    (send\n      (send nil :block_opened?) :!)\n    (lvar : options [] include? )\n    (lvar :escape_html)\n    (lvar :attributes)\n    (lvar :nuke_outer_whitespace)\n    (lvar :nuke_inner_whitespace)) :map) join ",",  + es join ","attributes_hash [] es join "," parse_class_and_id _hashes join ",",  + es first ","attributes_hash [] es first "," parse_class_and_id _hashes first ",",  + es size == ","attributes_hash [] es size == "," parse_class_and_id _hashes size == ",",  + es size ","attributes_hash [] es size "," parse_class_and_id _hashes size ",",  + es empty? ","attributes_hash [] es empty? "," parse_class_and_id _hashes empty? ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar : unescape_interpolation ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value to_s strip ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value [] strip ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar : unescape_interpolation ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value to_s strip ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value [] strip ) :empty?))\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :autoclose)) :include?\n    (lvar :tag_name))) ! ","(send\n  (lvar :,  + es) :map!) compact! ","(send\n  (lvar :attributes_hash [] es) :map!) compact! ","(send\n  (lvar : parse_class_and_id _hashes) :map!) compact! ",",  + es map! ","attributes_hash [] es map! "," parse_class_and_id _hashes map! "]}," Haml Precompiler prerender_tag":{"type":"method","name":"prerender_tag","children":[],"call":["Precompiler  build_attributes ","@options [] "," xhtml? "," html? "]}," Haml Precompiler build_attributes":{"type":"method","name":"build_attributes","children":[],"call":[]}," Haml Precompiler parse_static_hash":{"type":"method","name":"parse_static_hash","children":[],"call":["attributes []= ","value nil? ","key nil? "," parse_literal_value ","attrib split ","text split each ","text split ","scanner scan "," eval to_s "," eval ","scanner eos? ","StringScanner  new "," newline ","text count times ","text count "," parse_literal_value  nil? ","scanner scan  nil? "," parse_literal_ parse_literal_value  "," parse_literal_scanner scan  ","StringScanner  new  scan ","StringScanner  new  eos? "]}," Haml Precompiler parse_literal_value":{"type":"method","name":"parse_literal_value","children":[],"call":["text match "]}," Haml Precompiler parse_class_and_id":{"type":"method","name":"parse_class_and_id","children":[],"call":["attributes []= ","attributes [] ","list scan "]}," Haml Precompiler close_haml_comment":{"type":"method","name":"close_haml_comment","children":[],"call":[]}," Haml Precompiler close_filtered":{"type":"method","name":"close_filtered","children":[],"call":[" push_text ","filtered rstrip gsub ","   * ","filtered rstrip "," push_silent ","filtered dump ","filter == ","filter new render ","filter new ","filter internal_compile ","filter new render  rstrip gsub ","filter new render  rstrip ","filter new render  dump "]}," Haml Precompiler close_loud":{"type":"method","name":"close_loud","children":[],"call":["@precompiled << "," push_silent "," concat_merged_text "]}," Haml Precompiler close_comment":{"type":"method","name":"close_comment","children":[],"call":[" push_text "]}," Haml Precompiler close_block":{"type":"method","name":"close_block","children":[],"call":[" push_silent "]}," Haml Precompiler close_tag":{"type":"method","name":"close_tag","children":[],"call":[" push_text "," push_merged_text ","nuke_inner_whitespace ! ","(str \"</\") + "," rstrip_buffer! "]}," Haml Precompiler close":{"type":"method","name":"close","children":[],"call":[" close_haml_comment "," close_filtered "," close_loud "," close_tag "," close_comment "," close_block ","@to_close_stack pop "," close_nil "," send "]}," Haml Precompiler start_haml_comment":{"type":"method","name":"start_haml_comment","children":[],"call":[" push_and_tabulate "," block_opened? "]}," Haml Precompiler push_flat_script":{"type":"method","name":"push_flat_script","children":[],"call":[" push_script "," raise ","SyntaxError  new ","text empty? "," flush_merged_text ","options merge "]}," Haml Precompiler push_script":{"type":"method","name":"push_script","children":[],"call":["@precompiled << "," push_and_tabulate ","close_tag inspect ","flattened inspect "," newline "," push_silent "," options [] "," options "," flush_merged_text ","(send\n  (array\n    (lvar :preserve_script)\n    (lvar :in_tag)\n    (lvar :preserve_tag)\n    (lvar :escape_html)\n    (lvar :nuke_inner_whitespace)) :map) join ","a inspect ","(lvar :preserve_script) map "," newline_now "," raise ","SyntaxError  new ","text empty? "," push_merged_text ","(or\n  (or\n    (send\n      (lvar :opts) :[]\n      (sym :in_tag))\n    (send\n      (lvar :opts) :[]\n      (sym :nuke_inner_whitespace)))\n  (send\n    (ivar :@options) :[]\n    (sym :ugly))) ! ","@options [] ","opts [] "," concat_merged_text ","@to_merge << "," block_opened? "," static_method_name ","(or\n  (or\n    (send\n      (lvar :opts) :[]\n      (sym :preserve_script))\n    (send\n      (lvar :opts) :[]\n      (sym :preserve_tag)))\n  (send\n    (lvar :opts) :[]\n    (sym :escape_html))) ! ","args << << ","args << "," block_opened? ! ","name to_sym ","args map! ","opts []= ","opts [] nil? ","(send\n  (array\n    (lvar :preserve_script)\n    (lvar :in_tag)\n    (lvar :preserve_tag)\n    (lvar :escape_html)\n    (lvar :nuke_inner_whitespace)) :map) join  << << ","(send\n  (array\n    (lvar :preserve_script)\n    (lvar :in_tag)\n    (lvar :preserve_tag)\n    (lvar :escape_html)\n    (lvar :nuke_inner_whitespace)) :map) join  << ","(send\n  (array\n    (lvar :preserve_script)\n    (lvar :in_tag)\n    (lvar :preserve_tag)\n    (lvar :escape_html)\n    (lvar :nuke_inner_whitespace)) :map) join  map! "]}," Haml Precompiler push_flat":{"type":"method","name":"push_flat","children":[],"call":["@filter_buffer << ","line unstripped ","  * ","tabulation > ","line spaces - ","line spaces ","@options [] ","text gsub! ","line full dup ","line full ","line spaces -  > ","line full dup  gsub! "]}," Haml Precompiler push_plain":{"type":"method","name":"push_plain","children":[],"call":[" push_text "," raise ","SyntaxError  new ","@next_line index "," push_script "," unescape_interpolation "," contains_interpolation? "," block_opened? ","options [] "]}," Haml Precompiler flush_merged_text":{"type":"method","name":"flush_merged_text","children":[],"call":["@precompiled << ","@tab_change != ","@merged_text dump ","@merged_text empty? ","@dont_tab_up_next_text inspect ","@options [] "," raise ","SyntaxError  new ","str << ","(str \"_hamlout.adjust_tabs(\") + ","@options [] ! ","mtabs != ","mtabs + ","val inspect [] ","val inspect ","@to_merge inject ","@to_merge empty? ","(str \"_hamlout.adjust_tabs(\") +  inspect [] ","(str \"_hamlout.adjust_tabs(\") +  inspect "]}," Haml Precompiler push_text":{"type":"method","name":"push_text","children":[],"call":[" push_merged_text "]}," Haml Precompiler push_merged_text":{"type":"method","name":"push_merged_text","children":[],"call":["@merged_text << ","   * ","@options [] ","indent ! ","@to_merge << "]}," Haml Precompiler push_silent":{"type":"method","name":"push_silent","children":[],"call":["@precompiled << "," options [] "," options "," flush_merged_text "]}," Haml Precompiler is_multiline?":{"type":"method","name":"is_multiline?","children":[],"call":["text [] == ","text [] ","text length > ","text length "]}," Haml Precompiler handle_multiline":{"type":"method","name":"handle_multiline","children":[],"call":[" process_line ","line tabs > ","@multiline tabs ","line tabs ","@multiline index ","@multiline text ","line text empty? ! ","line text empty? ","line text "," process_indent ","Line  new ","line index ","text [] ","MULTILINE_STARTERS  include? "," is_multiline? ","@multiline text << "," resolve_newlines "," un_next_line "," newline ","line text << ","new_line strip [] ","new_line strip ","new_line strip empty? ","new_line == "," raw_next_line first "," raw_next_line ","line text slice! ","Line  new  tabs ","Line  new  index ","Line  new  text ","@multiline line text  ","line line text  empty? ! ","line line text  empty? ","line line text  ","line text  [] ","Line  new  text << ","@multiline line text  << ","line line text  << "," raw_next_line first  strip [] "," raw_next_line first  strip "," raw_next_line first  strip empty? "," raw_next_line first  == ","line line text  slice! "]}," Haml Precompiler mid_block_keyword?":{"type":"method","name":"mid_block_keyword?","children":[],"call":["MID_BLOCK_KEYWORDS  include? ","text [] split [] ","text [] split ","text [] ","text [] == ","text length > ","text length ","MID_BLOCK_KEYWORD_REGEX  =~ "]}," Haml Precompiler process_line":{"type":"method","name":"process_line","children":[],"call":[" push_plain ","text [] "," render_doctype ","text [] == "," start_filtered ","text [] downcase "," push_and_tabulate ","text [] split [] == ","text [] split [] ","text [] split "," mid_block_keyword? ! "," mid_block_keyword? "," newline "," push_silent "," start_haml_comment "," push_flat_script "," push_script "," unescape_interpolation ","text [] strip "," render_comment "," render_tag "," render_div ","index + "," newline_now "," options [] "," options "," raise ","SyntaxError  new ","(str \"You don't need to use \\\"- end\\\" in Haml. Use indentation instead:\\n\") rstrip ","text [] strip == "," block_opened? ","text =~ ","@to_close_stack first << ","@to_close_stack first "," block_opened? ! "]}," Haml Precompiler process_indent":{"type":"method","name":"process_indent","children":[],"call":[" close "," mid_block_keyword? ","line text ","to_close - - == ","to_close - - ","to_close - ","to_close times ","@template_tabs - ","line tabs ","@template_tabs > ","line tabs <= ","@template_tabs -  - - == ","@template_tabs -  - - ","@template_tabs -  - ","@template_tabs -  times "]}," Haml Precompiler precompile":{"type":"method","name":"precompile","children":[],"call":[" flush_merged_text "," close ","@to_close_stack empty? "," newline "," raise ","SyntaxError  new ","line tabs - > ","line tabs - ","old_line tabs ","line tabs "," flat? ! "," flat? "," process_line ","line text empty? ! ","line text empty? ","line text ","line tabs > ","old_line index ","old_line text ","old_line text empty? ","old_line spaces != ","old_line tabs * ","old_line spaces "," push_flat "," process_indent ","old_line text nil? "," handle_multiline ","old_line spaces= ","old_line unstripped= ","old_line text= "," count_soft_tabs ","line tabs= ","line spaces= ","Line  new ","text lstrip chomp ","text lstrip ","text strip ","(send\n  (ivar :@template) :+\n  (str \"\\n-#\")) split each_with_index ","(send\n  (ivar :@template) :+\n  (str \"\\n-#\")) split ","@template + ","(send\n  (ivar :@template) :+\n  (str \"\\n-#\\n-#\")) split each_with_index ","(send\n  (ivar :@template) :+\n  (str \"\\n-#\\n-#\")) split ","2 + - ","2 + ","(begin\n  (send\n    (lvar :line) :spaces)) strip ","line spaces "," resolve_newlines ","1 + - ","1 + ","(begin\n  (send\n    (lvar :old_line) :spaces)) strip ","old_line spaces == ","old_line text empty? ! ","line index ","@template split each_with_index ","@template split ","@next_line eod? ","@next_line index ","@next_line tabs - ","@line tabs ","@next_line tabs ","@next_line tabs - > ","@line index ","@line text ","@line text empty? "," next_line ","@line tabs != "," newLine  new  ","Line  new  tabs - > ","Line  new  tabs - ","old_Line  new  tabs ","Line  new  tabs "," process_Line  new  ","Line  new  text empty? ! ","Line  new  text empty? ","Line  new  text ","Line  new  tabs > ","old_Line  new  index ","Line  new  index ","old_Line  new  text ","old_Line  new  text empty? ","old_Line  new  spaces != ","Line  new  spaces != ","old_Line  new  tabs * ","Line  new  tabs * ","old_Line  new  spaces ","Line  new  spaces ","old_Line  new  text nil? ","Line  new  text nil? "," handle_multiLine  new  ","old_Line  new  spaces= ","Line  new  spaces= ","old_Line  new  unstripped= ","Line  new  unstripped= ","old_Line  new  text= ","Line  new  text= ","Line  new  tabs= ","(begin\n  (send\n    (lvar :Line  new ) :spaces)) strip "," resolve_newLine  new s ","(begin\n  (send\n    (lvar :old_Line  new ) :spaces)) strip ","old_Line  new  spaces == ","Line  new  spaces == ","old_Line  new  text empty? ! ","@next_Line  new  eod? ","@next_Line  new  index ","@next_Line  new  tabs - ","@Line  new  tabs "," next_line  tabs ","@next_Line  new  tabs ","@next_Line  new  tabs - > ","@Line  new  index "," next_line  index ","@Line  new  text "," next_line  text ","@Line  new  text empty? "," next_line  text empty? "," next_Line  new  ","@Line  new  tabs != "," next_line  tabs != "]}," Haml Precompiler locals_code":{"type":"method","name":"locals_code","children":[],"call":["(send\n  (lvar :names) :map) join + ","(send\n  (lvar :names) :map) join ","name to_s inspect ","name to_s ","name to_sym inspect ","name to_sym ","names map ","names keys ","Hash  == ","(send\n  (lvar :names keys ) :map) join + ","(send\n  (lvar :names keys ) :map) join ","names keys  map ","names keys  keys "]}," Haml Precompiler precompiled_with_ambles":{"type":"method","name":"precompiled_with_ambles","children":[],"call":["preamble + + + ","preamble + + ","preamble + "," locals_code ","(str \"@haml_is_haml = false\\n\") gsub ","(str \"extend Haml::Helpers\\n\") gsub "," options_for_buffer inspect "," options_for_buffer ","(str \"@haml_buffer = @haml_buffer.upper\\n\") gsub "," precompiled ","(str \"extend Haml::Helpers\\n\") gsub  + + + ","(str \"extend Haml::Helpers\\n\") gsub  + + ","(str \"extend Haml::Helpers\\n\") gsub  + "]}," Haml HTML Elem haml_attributes":{"type":"method","name":"haml_attributes","children":[],"call":["attrs join ","value inspect ","name inspect ","name index "," attributes map "," attributes "," dynamic_attributes [] "," dynamic_attributes "," dynamic_attribute? "," attr_hash map "," attr_hash "," attr_hash sort map "," attr_hash sort ","options [] "," haml_attribute_pair ","value inspect  inspect "," dynamic_attributes []  inspect ","name inspect  inspect ","name inspect  index "]}," Haml Helpers init_haml_helpers":{"type":"method","name":"init_haml_helpers","children":[],"call":["Haml Buffer  new ","Haml Engine  new send ","Haml Engine  new "," haml_buffer ","Options  new for_buffer ","Options  new "]}," Haml Filters Markdown initialize":{"type":"method","name":"initialize","children":[],"call":[" RedCloth  new "," BlueCloth  new ","@required == "]}," Haml Filters RedCloth render":{"type":"method","name":"render","children":[],"call":["@engine to_html "," RedCloth  new to_html "," RedCloth  new "]}," Haml Filters RedCloth initialize":{"type":"method","name":"initialize","children":[],"call":[" RedCloth  new "]}," Haml Filters LazyLoaded initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","HamlError  new ","(send\n  (lvar :reqs) :map) join ","reqs map ","reqs first ","reqs size == ","reqs size "," class to_s gsub "," class to_s "," class "," require ","reqs [] ","reqs [] each "]}," Haml Exec Sass set_opts":{"type":"method","name":"set_opts","children":[],"call":["@options [] []= ","name to_sym ","@options [] ","opts on "," path ","@options [] [] << ","@options [] [] ","@options []= ","Encoding  default_external= "," Haml Util  ruby1_8? "," require "]}," Haml Exec HamlSass initialize":{"type":"method","name":"initialize","children":[],"call":["@options []= "]}," Haml Exec Generic open_file":{"type":"method","name":"open_file","children":[],"call":["File  open ","filename nil? ","flag == ","@options [] "]}," Haml Exec Generic get_line":{"type":"method","name":"get_line","children":[],"call":["exception backtrace [] scan [] ","exception backtrace [] scan ","exception backtrace [] ","exception backtrace ","exception message scan [] ","exception message scan ","exception message ","exception is_a? ","exception backtrace [] scan first first ","exception backtrace [] scan first ","exception message scan first first ","exception message scan first ","(or\n  (send\n    (send\n      (send\n        (send\n          (lvar :exception) :backtrace) :[]\n        (int 0)) :scan\n      (regexp\n        (str \":(\\\\d+)\")\n        (regopt))) :first)\n  (array\n    (str \"??\"))) first ","(or\n  (send\n    (send\n      (send\n        (lvar :exception) :message) :scan\n      (regexp\n        (str \":(\\\\d+)\")\n        (regopt))) :first)\n  (array\n    (str \"??\"))) first "]}," Haml Engine options_for_buffer":{"type":"method","name":"options_for_buffer","children":[],"call":["@options [] ","@options for_buffer "]}," Haml Engine set_locals":{"type":"method","name":"set_locals","children":[],"call":[" eval ","(send\n  (send\n    (lvar :locals) :keys) :map) join ","k inspect ","locals keys map ","locals keys ","scope_object send ","scope_object instance_variable_set "]}," Haml Engine def_method":{"type":"method","name":"def_method","children":[],"call":["object send ","@options [] "," precompiled_with_ambles ","object is_a? "," compiler precompiled_with_ambles "," compiler ","@options line ","@options filename ","@temple_engine precompiled_with_ambles "]}," Haml Engine render_proc":{"type":"method","name":"render_proc","children":[],"call":[" eval ","@options [] ","Proc.new { |*_haml_locals| _haml_locals = _haml_locals[0] || {}; + + ","Proc.new { |*_haml_locals| _haml_locals = _haml_locals[0] || {}; + "," precompiled_with_ambles "," binding ","scope_object instance_eval ","scope is_a? "," compiler precompiled_with_ambles "," compiler "," raise ","e message ","@options line ","@options filename ","Proc.new { |*_haml_locals| _haml_locals = _haml_locals[0] || {}; << << ","Proc.new { |*_haml_locals| _haml_locals = _haml_locals[0] || {}; << ","@temple_engine precompiled_with_ambles "," eval  instance_eval "]}," Haml Template compilable?":{"type":"method","name":"compilable?","children":[],"call":[]}," Sass Plugin checked_for_updates":{"type":"method","name":"checked_for_updates","children":[],"call":[]}," Application call_with_sass":{"type":"method","name":"call_with_sass","children":[],"call":[" call_without_sass ","Sass Plugin  update_stylesheets ","Sass Plugin  options [] ","Sass Plugin  options ","Sass Plugin  checked_for_updates ! ","Sass Plugin  checked_for_updates ","Sass Plugin  check_for_updates "]}," Haml Template read_template_file":{"type":"method","name":"read_template_file","children":[],"call":["File  read "]}," Haml Template cache_fragment":{"type":"method","name":"cache_fragment","children":[],"call":[" eval ","block binding ","@view fragment_for "]}," Haml Precompiler balance":{"type":"method","name":"balance","children":[],"call":[" raise ","SyntaxError  new ","scanner rest ","str strip ","count == ","scanner matched [] == ","scanner matched [] ","scanner matched ","str << ","scanner scan ","Regexp  new ","finish chr ","start chr ","StringScanner  new ","scanner is_a? ","Haml Shared  balance ","StringScanner  new  rest ","scanner Haml Shared  balance t ","StringScanner  new  matched [] == ","StringScanner  new  matched [] ","StringScanner  new  matched ","StringScanner  new  scan ","StringScanner  new  is_a? "]}," Haml Precompiler parse_tag":{"type":"method","name":"parse_tag","children":[],"call":["value to_s strip ","value to_s ","rest scan [] ","rest scan "," balance ","rest [] == ","rest [] ","attributes_hash [] ","attributes_hash length - ","attributes_hash length ","StringScanner  new "," raise ","SyntaxError  new ","line scan [] ","line scan ","nuke_whitespace include? "," parse_attributes ","attributes_hash nil? ","attributes_hashes << "," parse_new_attributes "," parse_old_attributes ","value to_s strip  to_s strip ","value to_s strip  to_s ","attributes_hash []  [] ","attributes_hash []  length - ","attributes_hash []  length ","attributes_hash []  nil? ","attributes_hash [] es << "]}," Haml Helpers haml_bind_proc":{"type":"method","name":"haml_bind_proc","children":[],"call":["proc call "," proc ","_hamlout buffer "," haml_buffer ","_erbout to_s "," haml_buffer  buffer ","_hamlout buffer  to_s "]}," Haml Helpers haml_buffer":{"type":"method","name":"haml_buffer","children":[],"call":["@haml_stack [] "]}," Haml Helpers haml_tag":{"type":"method","name":"haml_tag","children":[],"call":[" puts "," tab_down ","block call "," tab_up ","text empty? ","Haml Precompiler  build_attributes "," haml_buffer options [] "," haml_buffer options "," haml_buffer ","block nil? ","text nil? ","attributes is_a? "," haml_buffer options [] include? "," haml_buffer html? ","name to_s ","tag << << ","tag << "," capture_haml strip "," capture_haml ","flags include? "," raise ","Error  new ","text to_s ","rest shift ","flags << ","rest first is_a? ","rest first "," haml_concat ","rest shift to_s ","(const nil :Symbol) any? ","ErrorReturn  new ","text include? "," merge_name_and_attributes ","key to_s ","Haml Util  map_keys ","Haml Compiler  build_attributes ","attrs []= ","attrs delete ","attrs keys each ","attrs keys ","attrs empty? ","Error  message "," haml_buffer options [] == "," haml_internal_concat_raw "," haml_internal_concat ","Haml AttributeBuilder  build_attributes ","rest shift  empty? ","rest shift to_s  empty? ","text to_s  empty? ","Haml Precompiler  build_Haml Precompiler  build_attributes  ","Haml Precompiler  build_Haml Compiler  build_attributes  ","Haml Precompiler  build_Haml AttributeBuilder  build_attributes  ","rest shift  nil? ","rest shift to_s  nil? ","text to_s  nil? ","Haml Precompiler  build_attributes  is_a? ","Haml Compiler  build_attributes  is_a? ","Haml AttributeBuilder  build_attributes  is_a? ","name to_s  to_s ","rest shift  to_s ","rest shift to_s  to_s ","text to_s  to_s ","rest shift  include? ","rest shift to_s  include? ","text to_s  include? "," merge_name_and_Haml Precompiler  build_attributes  "," merge_name_and_Haml Compiler  build_attributes  "," merge_name_and_Haml AttributeBuilder  build_attributes  "," merge_name to_s _and_attributes ","Haml Compiler  build_Haml Precompiler  build_attributes  ","Haml Compiler  build_Haml Compiler  build_attributes  ","Haml Compiler  build_Haml AttributeBuilder  build_attributes  ","Haml AttributeBuilder  build_Haml Precompiler  build_attributes  ","Haml AttributeBuilder  build_Haml Compiler  build_attributes  ","Haml AttributeBuilder  build_Haml AttributeBuilder  build_attributes  "]}," Tree RuleNode add_rules":{"type":"method","name":"add_rules","children":[],"call":["node rules "," rule "," rule= "," rules ","Haml Util  strip_string_array ","Haml Util  merge_adjacent_strings ","@rule + + ","node rule ","@rule + ","Haml Util  strip_string_array  + + ","Haml Util  strip_string_array  + "]}," Tree RuleNode rules":{"type":"method","name":"rules","children":[],"call":[" Array "," rule "]}," Sass Engine parse_mixin_include":{"type":"method","name":"parse_mixin_include","children":[],"call":["@mixins [] "," raise ","SyntaxError  new ","@mixins has_key? ","line [] ","Tree MixinNode  new "," parse_script ","line offset + ","line text index ","line text ","line offset ","args map ","a empty? ","args each ","args nil? ","name nil? ","@line + ","line children empty? ","line children "," parse_mixin_arguments ","line text scan first ","line text scan ","Script Parser  new parse_mixin_include_arglist ","Script Parser  new ","arg_string strip ","line offset + - ","arg_string size ","line text size ","line line offset + -  + ","line line offset + -  "," parse_mixin_arguments  map ","Script Parser  new parse_mixin_include_arglist  map "," parse_mixin_arguments  each ","Script Parser  new parse_mixin_include_arglist  each "," parse_mixin_arguments  nil? ","Script Parser  new parse_mixin_include_arglist  nil? ","line line offset + -  + - "]}," Sass Engine parse_mixin_definition":{"type":"method","name":"parse_mixin_definition","children":[],"call":["@lines [] "," validate_and_append_child ","@mixins [] "," build_tree ","tabs > ","line nil? ! ","line nil? ","@mixins []= ","line [] ","line [] strip ","Tree MixinDefNode  new ","arg [] "," parse_script ","line offset + ","line text index ","line text ","line offset "," raise ","SyntaxError  new ","default ! ","arg =~ ","arg split ","arg [] == ","arg == ","arg empty? ","args map! ","line text [] ","args nil? ","name nil? "," parse_mixin_arguments ","line text scan first ","line text scan ","Script Parser  new parse_mixin_definition_arglist ","Script Parser  new ","arg_string strip ","line offset + - ","arg_string size ","line text size ","line line offset + -  + ","line line offset + -  "," parse_script  ! "," parse_mixin_arguments  map! ","Script Parser  new parse_mixin_definition_arglist  map! "," parse_mixin_arguments  nil? ","Script Parser  new parse_mixin_definition_arglist  nil? ","line line offset + -  + - "]}," Sass Engine validate_and_append_child":{"type":"method","name":"validate_and_append_child","children":[],"call":["parent << "," raise ","SyntaxError  new ","c is_a? ","child each "," validate_and_append_child ","line index "]}," Sass Engine mixins":{"type":"method","name":"mixins","children":[],"call":[]}," Sass CSS remove_parent_refs":{"type":"method","name":"remove_parent_refs","children":[],"call":[" remove_parent_refs ","child rule gsub! ","child rule ","child is_a? ","root children each ","root children ","child rules first gsub! ","child rules first ","child rules ","child rule first gsub! ","child rule first "]}," Sass CSS parent_ref_rules":{"type":"method","name":"parent_ref_rules","children":[],"call":["rules values ","root children "," parent_ref_rules ","rules values each ","child children ","rules [] children ","rules [] ","rules [] << ","child rule= ","& + ","Tree RuleNode  new ","child rule scan first ","child rule scan ","child rule ","root children delete ","(send\n  (send\n    (lvar :root) :children) :select) each ","Tree RuleNode  === ","root children select ","OrderedHash  new ","root children each ","current_rule children ","current_rule << ","child rules= ","root << ","current_rule rules first != ","current_rule rules first ","current_rule rules ","current_rule nil? ","child rules first scan first ","child rules first scan ","child rules first ","child rules ","root children uniq! ","root children compact! ","current_rule rule first != ","current_rule rule first ","current_rule rule ","child rule first scan first ","child rule first scan ","child rule first ","child is_a? ","root children map! ","OrderedHash  new  values "," parent_ref_OrderedHash  new  ","OrderedHash  new  values each ","OrderedHash  new  [] children ","OrderedHash  new  [] ","OrderedHash  new  [] << ","Tree RuleNode  new  children ","Tree RuleNode  new  << ","child OrderedHash  new = ","current_rule OrderedHash  new  first != ","Tree RuleNode  new  rules first != ","current_rule OrderedHash  new  first ","Tree RuleNode  new  rules first ","current_rule OrderedHash  new  ","Tree RuleNode  new  rules ","Tree RuleNode  new  nil? ","child OrderedHash  new  first scan first ","child OrderedHash  new  first scan ","child OrderedHash  new  first ","child OrderedHash  new  ","Tree RuleNode  new  rule first != ","Tree RuleNode  new  rule first ","Tree RuleNode  new  rule "]}," Sass OrderedHash initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["other instance_variable_get clone ","other instance_variable_get "]}," Haml scope":{"type":"method","name":"scope","children":[],"call":[]}," Haml version":{"type":"method","name":"version","children":[],"call":[]}," Base compile_template":{"type":"method","name":"compile_template","children":[],"call":["@@compile_time []= ","Time  now "," raise ","ActionView TemplateError  new "," view_paths first "," view_paths "," extract_base_path_from ","e backtrace [] gsub! ","e backtrace [] ","e backtrace ","e is_a? "," logger debug ","e backtrace join "," logger ","CompiledTemplates  module_eval ","line_offset -@ ","file_name blank? ","@@template_args [] size + ","handler line_offset ","@@template_args [] size ","@@template_args [] "," create_template_source ","local_assigns keys "," assign_method_name ","@@template_args [] size +  -@ ","handler @@template_args [] size +  "]}," Haml Plugin cache_fragment":{"type":"method","name":"cache_fragment","children":[],"call":[" eval ","block binding ","@view fragment_for "]}," Haml Plugin compile":{"type":"method","name":"compile","children":[],"call":["Haml Engine  new send ","Haml Engine  new ","template source ","options []= ","template filename ","template respond_to? ","Haml Template  options dup ","Haml Template  options ","template identifier ","template mime_type ","Haml Engine  new compiler precompiled_with_ambles ","Haml Engine  new compiler ","template type ","ActionPack VERSION MAJOR  >= ","template inspect ","template short_identifier "," class annotate_rendered_view_with_filenames "," class ","template template source  ","Haml Template  options dup  []= ","Haml Template  Haml Template  options dup  dup ","Haml Template  Haml Template  options dup  ","template template inspect ifier ","template template short_identifier ifier ","template short_template inspect ifier ","template short_template short_identifier ifier "]}," Haml Precompiler rstrip_buffer!":{"type":"method","name":"rstrip_buffer!","children":[],"call":["@merged_text rstrip! "," push_silent ","@merged_text empty? "," raise ","SyntaxError  new ","last [] gsub! ","last [] "," rstrip_buffer! ","@to_merge pop ","last [] empty? ","last [] rstrip! ","last first ","@to_merge last ","@to_merge empty? ","@to_merge last  [] gsub! ","@to_merge last  [] ","@to_merge last  [] empty? ","@to_merge last  [] rstrip! ","@to_merge last  first ","@to_merge @to_merge last  "]}," Haml Precompiler resolve_newlines":{"type":"method","name":"resolve_newlines","children":[],"call":["@precompiled << ","\n * ","@newlines > "]}," Haml Precompiler newline_now":{"type":"method","name":"newline_now","children":[],"call":["@precompiled << "]}," Haml Precompiler contains_interpolation?":{"type":"method","name":"contains_interpolation?","children":[],"call":["str include? "]}," Haml Precompiler parse_attributes":{"type":"method","name":"parse_attributes","children":[],"call":["attributes_hash [] "," balance ","StringScanner  new ","attributes_hash []  [] "]}," Haml Precompiler concat_merged_text":{"type":"method","name":"concat_merged_text","children":[],"call":["@merged_text << ","@to_merge << "]}," Object is_haml?":{"type":"method","name":"is_haml?","children":[],"call":[]}," Haml Helpers escape_once":{"type":"method","name":"escape_once","children":[],"call":["HTML_ESCAPE  [] ","text to_s gsub ","text to_s ","Haml Util  silence_warnings ","Regexp  new ","pattern force_encoding ","text encoding ","RUBY_VERSION  >= ","text gsub! ","text gsub ","text to_s  to_s gsub ","text to_s  to_s ","text to_s  encoding ","text to_s  gsub! ","text to_s  gsub "]}," Haml Helpers html_escape":{"type":"method","name":"html_escape","children":[],"call":["HTML_ESCAPE  [] ","text to_s gsub ","text to_s ","Haml Util  silence_warnings ","Regexp  new ","pattern force_encoding ","text encoding ","RUBY_VERSION  >= ","text gsub ","ERB Util  html_escape ","CGI  escapeHTML ","text to_s  to_s gsub ","text to_s  to_s ","text to_s  encoding ","text to_s  gsub "]}," Haml Helpers non_haml":{"type":"method","name":"non_haml","children":[],"call":["@haml_buffer active= ","@haml_buffer active? "]}," ActionView Helpers InstanceTag is_haml?":{"type":"method","name":"is_haml?","children":[],"call":["@template_object send "]}," ActionView Helpers InstanceTag haml_buffer":{"type":"method","name":"haml_buffer","children":[],"call":["@template_object send "]}," ActionView Helpers TagHelper content_tag_with_haml":{"type":"method","name":"content_tag_with_haml","children":[],"call":["Haml Helpers  preserve "," haml_buffer options [] include? ","name to_s "," haml_buffer options [] "," haml_buffer options "," haml_buffer "," is_haml? "," content_tag_without_haml "," returning "," preserve "," block_is_haml? "," block_given? "," haml_buffer options fetch include? "," haml_buffer options fetch "," haml_buffer fix_textareas! html_safe "," haml_buffer fix_textareas! ","Haml Helpers   haml_buffer options [] include?  ","Haml Helpers   haml_buffer options fetch include?  "," Haml Helpers  preserve _tag_without_haml ","  content_tag_without_haml _tag_without_haml ","  haml_buffer fix_textareas! html_safe _tag_without_haml ","  haml_buffer options [] include?  ","  haml_buffer options fetch include?  "]}," ActionView Helpers CaptureHelper capture_with_haml":{"type":"method","name":"capture_with_haml","children":[],"call":[" capture_without_haml "," capture_haml "," is_haml? "," eval "," block_is_haml? ","Haml Helpers  block_is_haml? ","ActionView NonConcattingString  new ","value is_a? ","buffer empty? ","buffer empty? ! ","block binding "]}," Haml Filters ERB compile":{"type":"method","name":"compile","children":[],"call":["precompiler send "," ERB  new src sub gsub "," ERB  new src sub "," ERB  new src "," ERB  new ","precompiler options [] ","precompiler options "," ERB  new src sub sub gsub "," ERB  new src sub sub ","RealERB  new src sub sub ","RealERB  new src sub ","RealERB  new src ","RealERB  new ","compiler send ","compiler options [] ","compiler options "," ERB  new  ERB  new src sub gsub  sub gsub "," ERB  new  ERB  new src sub sub gsub  sub gsub "," ERB  new  ERB  new src sub sub  sub gsub "," ERB  new RealERB  new src sub sub  sub gsub "," ERB  new  ERB  new src sub gsub  sub "," ERB  new  ERB  new src sub sub gsub  sub "," ERB  new  ERB  new src sub sub  sub "," ERB  new RealERB  new src sub sub  sub "," ERB  new  ERB  new src sub gsub  "," ERB  new  ERB  new src sub sub gsub  "," ERB  new  ERB  new src sub sub  "," ERB  new RealERB  new src sub sub  "," ERB  new  ERB  new src sub gsub  sub sub gsub "," ERB  new  ERB  new src sub sub gsub  sub sub gsub "," ERB  new  ERB  new src sub sub  sub sub gsub "," ERB  new RealERB  new src sub sub  sub sub gsub "," ERB  new  ERB  new src sub gsub  sub sub "," ERB  new  ERB  new src sub sub gsub  sub sub "," ERB  new  ERB  new src sub sub  sub sub "," ERB  new RealERB  new src sub sub  sub sub ","RealERB  new  ERB  new src sub gsub  sub sub ","RealERB  new  ERB  new src sub sub gsub  sub sub ","RealERB  new  ERB  new src sub sub  sub sub ","RealERB  new RealERB  new src sub sub  sub sub ","RealERB  new  ERB  new src sub gsub  sub ","RealERB  new  ERB  new src sub sub gsub  sub ","RealERB  new  ERB  new src sub sub  sub ","RealERB  new RealERB  new src sub sub  sub ","RealERB  new  ERB  new src sub gsub  ","RealERB  new  ERB  new src sub sub gsub  ","RealERB  new  ERB  new src sub sub  ","RealERB  new RealERB  new src sub sub  "]}," Haml Filters Sass render":{"type":"method","name":"render","children":[],"call":[" Sass Engine  new render "," Sass Engine  new "," Sass Plugin  engine_options "]}," Haml Filters Ruby compile":{"type":"method","name":"compile","children":[],"call":[" push_silent ","(str \"            _haml_old_stdout = $stdout\\n\") gsub ","precompiler instance_eval ","precompiler options [] ","precompiler options ","(str \"            _haml_old_stdout = $stdout\\n\") gsub + + ","(str \"            _haml_old_stdout, $stdout = $stdout, _haml_old_stdout\\n\") gsub ","(str \"            _haml_old_stdout = $stdout\\n\") gsub + ","compiler instance_eval ","compiler options [] ","compiler options ","(str \"            begin\\n\") gsub + + ","(str \"            ensure\\n\") gsub ","(str \"            begin\\n\") gsub + ","(str \"            begin\\n\") gsub ","(str \"            begin\\n\") tr + + ","(str \"            ensure\\n\") tr ","(str \"            begin\\n\") tr + ","(str \"            begin\\n\") tr ","node value [] ","node value "]}," Haml Filters Escaped render":{"type":"method","name":"render","children":[],"call":["Haml Helpers  html_escape "]}," Haml Filters Cdata render":{"type":"method","name":"render","children":[],"call":["(send\n  (str \"\\n\") :+\n  (lvar :text)) rstrip gsub ","(send\n  (str \"\\n\") :+\n  (lvar :text)) rstrip ","\n + ","text gsub! ","text rstrip! ","(str \"\\n\") gsub ","text rstrip "]}," Haml Filters Javascript render":{"type":"method","name":"render","children":[],"call":["text rstrip gsub ","text rstrip "]}," Haml Filters Base resolve_lazy_requires":{"type":"method","name":"resolve_lazy_requires","children":[],"call":[" raise ","Error  new ","(send\n  (ivar :@lazy_requires) :map) join ","@lazy_requires map ","@lazy_requires first ","@lazy_requires size == ","@lazy_requires size "," class to_s gsub "," class to_s "," class "," require ","@lazy_requires [] ","@lazy_requires [] each "," name match [] "," name match "," name "]}," Haml Filters Base lazy_require":{"type":"method","name":"lazy_require","children":[],"call":[]}," Haml Filters Base compile":{"type":"method","name":"compile","children":[],"call":[" push_text ","rendered rstrip ","rendered rstrip gsub ","   * "," options [] ! "," options [] "," options ","Haml Helpers  find_and_preserve ","precompiler options [] ","precompiler options ","filter render "," push_script "," unescape_interpolation ","filter inspect "," contains_interpolation? ","precompiler instance_eval "," resolve_lazy_requires ","filter render_with_options "," newline "," resolve_newlines ","(send\n  (send\n    (lvar :text) :count\n    (str \"\\n\")) :-\n  (int 1)) times ","text count - ","text count ","(str \"find_and_preserve(\") strip ","text gsub! "," unescape_interpolation gsub ","(send\n  (str \"\\\\\") :*\n  (begin\n    (send\n      (lvar :escapes) :-\n      (int 1)))) + ","\\ * ","escapes - ","escapes % == ","escapes % ","1 size ","compiler options [] ","compiler options ","(str \"find_and_preserve(\") rstrip ","\n + ","text sub ","compiler instance_eval ","rendered gsub! ","rendered rstrip! ","text to_s ","escape nil? "," push_ unescape_interpolation gsub  "," push_\n +  ","Haml Helpers  find_and_preserve  rstrip ","Haml Helpers  find_and_preserve  rstrip gsub "," un options [] _interpolation ","(send\n  (send\n    (lvar : unescape_interpolation gsub ) :count\n    (str \"\\n\")) :-\n  (int 1)) times ","(send\n  (send\n    (lvar :\n + ) :count\n    (str \"\\n\")) :-\n  (int 1)) times "," unescape_interpolation gsub  count - ","\n +  count - "," unescape_interpolation gsub  count ","\n +  count "," unescape_interpolation gsub  gsub! ","\n +  gsub! "," un options [] _interpolation gsub ","(send\n  (str \"\\\\\") :*\n  (begin\n    (send\n      (lvar :1 size ) :-\n      (int 1)))) + ","(send\n  (str \"\\\\\") :*\n  (begin\n    (send\n      (lvar : options [] s) :-\n      (int 1)))) + ","1 size  - "," options [] s - ","1 size  % == "," options [] s % == ","1 size  % "," options [] s % "," unescape_interpolation gsub  sub ","\n +  sub ","Haml Helpers  find_and_preserve  gsub! ","Haml Helpers  find_and_preserve  rstrip! "," unescape_interpolation gsub  to_s ","\n +  to_s "," options []  nil? "]}," Haml Filters Base internal_compile":{"type":"method","name":"internal_compile","children":[],"call":[" compile "," resolve_lazy_requires "]}," Haml Filters Base render":{"type":"method","name":"render","children":[],"call":[" raise ","Error  new "," inspect "]}," Haml Filters Base included":{"type":"method","name":"included","children":[],"call":[]}," Haml Filters defined":{"type":"method","name":"defined","children":[],"call":[]}," Haml Exec Haml set_opts":{"type":"method","name":"set_opts","children":[],"call":["@options [] []= ","@options [] ","opts on ","name to_sym ","name to_sym == ","@options []= ","@options [] << ","Encoding  default_internal= ","internal empty? ! ","internal empty? ","Encoding  default_external= ","external empty? ! ","external empty? ","encoding split "," Haml Util  ruby1_8? ","StringIO  new "," require ","opts banner= ","RUBY_VERSION  < ","list split "]}," Haml Error initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml Engine html5?":{"type":"method","name":"html5?","children":[],"call":["@options [] == ","@options [] "]}," Haml Engine html4?":{"type":"method","name":"html4?","children":[],"call":["@options [] == ","@options [] "]}," Haml Engine html?":{"type":"method","name":"html?","children":[],"call":[" html5? "," html4? "]}," Haml Engine xhtml?":{"type":"method","name":"xhtml?","children":[],"call":[" html? ! "," html? "]}," Haml Buffer active?":{"type":"method","name":"active?","children":[],"call":[]}," Haml Buffer toplevel?":{"type":"method","name":"toplevel?","children":[],"call":[" upper nil? "," upper "]}," Haml Buffer html5?":{"type":"method","name":"html5?","children":[],"call":["@options [] == ","@options [] "]}," Haml Buffer html4?":{"type":"method","name":"html4?","children":[],"call":["@options [] == ","@options [] "]}," Haml Buffer html?":{"type":"method","name":"html?","children":[],"call":[" html5? "," html4? "]}," Haml Buffer xhtml?":{"type":"method","name":"xhtml?","children":[],"call":[" html? ! "," html? "]}," Constant Nil to_s":{"type":"method","name":"to_s","children":[],"call":[]}," ActionView Base set_output_buffer_with_haml":{"type":"method","name":"set_output_buffer_with_haml","children":[],"call":[" set_output_buffer_without_haml "," haml_buffer buffer= "," haml_buffer "," is_haml? ","String  new ","new is_a? ","Haml Util  rails_xss_safe? ","Haml Util  rails_safe_buffer_class ","new_buffer is_a? ","String  String  new  ","String  new  is_a? ","String  new _buffer is_a? "]}," ActionView Base output_buffer_with_haml":{"type":"method","name":"output_buffer_with_haml","children":[],"call":[" output_buffer_without_haml "," haml_buffer buffer "," haml_buffer "," is_haml? "]}," Tree ValueNode ==":{"type":"method","name":"==","children":[],"call":[" value == ","other value "," value "," class == ","other class "," class "]}," Tree RuleNode ==":{"type":"method","name":"==","children":[],"call":[" rules == ","other rules "," rules "," class == ","other class "," class "," rule == ","other rule "," rule "]}," Sass Tree Node ==":{"type":"method","name":"==","children":[],"call":["other children == "," children ","other children "," class == ","other class "," class "]}," Tree AttrNode ==":{"type":"method","name":"==","children":[],"call":[" name == ","other name "," name "," class == ","other class "," class "]}," Sass Plugin engine_options":{"type":"method","name":"engine_options","children":[],"call":["opts []= "," load_paths "," options dup merge "," options dup "," options "," options dup merge  []= "]}," Sass CSS rule":{"type":"method","name":"rule","children":[],"call":[" attributes ","Tree RuleNode  new "," assert_match "," rules "," whitespace ","@template scan ","Tree DirectiveNode  new ","rule [] == ","rule [] ","rule strip! "," properties ","rule << ","@template match? ","rule empty? ","token nil? "," loop "," @template scan s ","@template scan  [] == ","@template scan  [] ","@template scan  strip! ","@template scan  << ","@template scan  empty? ","@template scan  nil? "]}," Sass Tree DirectiveNode to_sass":{"type":"method","name":"to_sass","children":[],"call":["c to_sass ","tabs + "," children map "," children "," value ","   * "]}," Haml Version scope":{"type":"method","name":"scope","children":[],"call":["File  expand_path ","File  join ","File  dirname "]}," Haml Version version":{"type":"method","name":"version","children":[],"call":["@@version [] << ","rev [] ","@@version [] ","rev [] == ","@@version []= ","File  read strip ","File  read "," scope ","rev =~ ","File  exists? ","rev == ","rev nil? ","rev !~ ","(send\n  (array\n    (sym :major)\n    (sym :minor)\n    (sym :teeny)) :map) compact join ","(send\n  (array\n    (sym :major)\n    (sym :minor)\n    (sym :teeny)) :map) compact ","(sym :major) map ","numbers [] ","n to_i ","File  read strip split map ","File  read strip split ","@@version [] << << ","@@version [] dup "," revision_number ","numbers join ","numbers [] is_a? ","n =~ ","File  read strip  [] "," revision_number  [] ","File  read strip  [] == "," revision_number  [] == ","File  read strip  =~ "," revision_number  =~ ","File  read strip  == "," revision_number  == ","File  read strip  nil? "," revision_number  nil? ","File  read strip  !~ "," revision_number  !~ "," File  read strip ision_number ","  revision_number ision_number "]}," Haml Util each_char":{"type":"method","name":"each_char","children":[],"call":["str each_char ","str each_byte "," ruby1_8? "]}," Haml Util has?":{"type":"method","name":"has?","children":[],"call":["klass send include? ","method to_sym ","method to_s "," ruby1_8? ","klass send "]}," Haml Util ruby1_8?":{"type":"method","name":"ruby1_8?","children":[],"call":["Haml Util RUBY_VERSION  [] < ","Haml Util RUBY_VERSION  [] ","Haml Util RUBY_VERSION  [] == "," ironruby? "]}," Haml Precompiler close_nil":{"type":"method","name":"close_nil","children":[],"call":[]}," Haml HTML Elem static_classname?":{"type":"method","name":"static_classname?","children":[],"call":[" static_attribute? "]}," Haml HTML Elem static_id?":{"type":"method","name":"static_id?","children":[],"call":[" static_attribute? "," haml_css_attr? "," attr_hash [] "," attr_hash "]}," Haml HTML Elem dynamic_attribute?":{"type":"method","name":"dynamic_attribute?","children":[],"call":[" dynamic_attributes key? "," dynamic_attributes ","HTML  options [] ","HTML  options ","options [] "]}," Haml HTML Elem static_attribute?":{"type":"method","name":"static_attribute?","children":[],"call":[" dynamic_attribute? ! "," dynamic_attribute? "," attributes [] "," attributes "," attr_hash [] "," attr_hash "]}," Haml HTML Elem dynamic_attributes":{"type":"method","name":"dynamic_attributes","children":[],"call":["dynamic []= ","ruby_value == ","$' empty? ","$` empty? ","value gsub ","value empty? "," attributes inject "," attributes ","Haml Util  map_hash ","CGI  unescapeHTML "," attr_hash ","Hash  [] "," attr_hash map "]}," Haml HTML CData to_haml":{"type":"method","name":"to_haml","children":[],"call":[" parse_text ","tabs + "," content "," tabulate "," parse_text_with_interpolation "," erb_to_interpolation ","  parse_text_with_interpolation  "]}," Haml Helpers with_haml_buffer":{"type":"method","name":"with_haml_buffer","children":[],"call":["old_buffer active= ","@haml_buffer active= ","old_buffer active? ","@haml_buffer active? "]}," Haml Helpers block_is_haml?":{"type":"method","name":"block_is_haml?","children":[],"call":[" eval ","block binding "]}," Haml Helpers haml_indent":{"type":"method","name":"haml_indent","children":[],"call":["   * "," haml_buffer tabulation "," haml_buffer "]}," Haml Helpers haml_concat":{"type":"method","name":"haml_concat","children":[],"call":[" haml_buffer buffer << << << "," haml_buffer buffer << << ","text to_s "," haml_buffer buffer << "," haml_indent "," haml_buffer buffer "," haml_buffer ","   * "," haml_buffer tabulation ","ErrorReturn  new ","text to_s gsub ","\n + "," haml_indent == "," haml_buffer options [] "," haml_buffer options "," haml_internal_concat "]}," Haml Helpers ErrorReturn inspect":{"type":"method","name":"inspect","children":[],"call":["@message inspect "]}," Haml Helpers ErrorReturn to_s":{"type":"method","name":"to_s","children":[],"call":[" raise ","Haml Error  new ","1 to_i - ","1 to_i ","e backtrace first gsub! ","e backtrace first ","e backtrace ","e backtrace shift ","e backtrace first =~ "]}," Haml Helpers ErrorReturn initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml Filters Maruku render":{"type":"method","name":"render","children":[],"call":[" Maruku  new to_html "," Maruku  new ","Maruku  new to_html ","Maruku  new "]}," Haml Filters Javascript render_with_options":{"type":"method","name":"render_with_options","children":[],"call":["text rstrip gsub ","text rstrip ","options [] ","options [] == ","str << ","text gsub! ","text rstrip  rstrip gsub ","text rstrip  rstrip ","text rstrip  gsub! "]}," Haml Filters Base render_with_options":{"type":"method","name":"render_with_options","children":[],"call":[" render "]}," Haml Buffer rstrip!":{"type":"method","name":"rstrip!","children":[],"call":[" buffer << "," buffer slice! rstrip "," buffer slice! "," capture_position "," buffer "," buffer rstrip! "," capture_position nil? "]}," Tree WhileNode _perform":{"type":"method","name":"_perform","children":[],"call":[" perform_children ","@expr perform to_bool ","@expr perform ","Sass Environment  new "]}," Tree WhileNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree VariableNode _perform":{"type":"method","name":"_perform","children":[],"call":["environment set_var ","@expr perform ","@guarded ! ","environment var nil? ","environment var ","Sass Script String  new ","val value ","val is_a? ","@expr context == ","@expr context ","environment var nil? ! ","Sass Script String  new  Sass Script String  new ue ","@expr perform  @expr perform ue ","Sass Script String  new  is_a? ","@expr perform  is_a? "]}," Sass Tree VariableNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree RuleNode parse_selector":{"type":"method","name":"parse_selector","children":[],"call":["r empty? ","r is_a? ","Haml Util  merge_adjacent_strings reject ","Haml Util  merge_adjacent_strings ","rules map! ","rules last << ","scanner scan ","rules last ","scanner rest? ","rules last << << ","rules << ","StringScanner  new "," warn ","rules last last =~ ","rules last last ","rules last empty? ","scanner matched include? ","scanner matched ","StringScanner  new  scan ","StringScanner  new  rest? ","StringScanner  new  matched include? ","StringScanner  new  matched "]}," Tree RuleNode resolve_parent_refs":{"type":"method","name":"resolve_parent_refs","children":[],"call":["new_rules last << ","(send\n  (lvar :rule) :map) join ","segment == ","rule map ","new_rules last ","rule include? ","line each ","super_line each ","new_rules << ","@parsed_rules each ","super_rules each ","(send\n  (lvar :line) :map) compact ","rule join "," raise ","Sass SyntaxError  new "," line ","line map ","@parsed_rules map ","super_rules nil? ","rule first slice! ","rule first ","rule first [] == ","rule first [] ","rule first is_a? "]}," Tree RuleNode perform!":{"type":"method","name":"perform!","children":[],"call":[" parse_selector "," interpolate ","@rules map ","Sass SCSS StaticParser  new parse_selector "," filename ","Sass SCSS StaticParser  new "," line "," run_interp "]}," Tree RuleNode initialize":{"type":"method","name":"initialize","children":[],"call":["Haml Util  strip_string_array ","Haml Util  merge_adjacent_strings "]}," Tree PropNode declaration":{"type":"method","name":"declaration","children":[],"call":[" value "," name ","@prop_syntax == ","(if\n  (send\n    (ivar :@prop_syntax) :==\n    (sym :new))\n  (dstr\n    (begin\n      (send nil :name))\n    (str \": \")\n    (begin\n      (send nil :value)))\n  (dstr\n    (str \":\")\n    (begin\n      (send nil :name))\n    (str \" \")\n    (begin\n      (send nil :value)))) strip ","(begin\n  (send\n    (str \"  \") :*\n    (lvar :tabs))) rstrip "," class val_to_sass "," class ","   * ","fmt == ","opts [] "," raise ","Sass SyntaxError  new ","name [] == ","name [] ","(send\n  (send\n    (self) :name) :map) join ","n to_sass ","n is_a? "," name map ","(send\n  (ivar :@prop_syntax) :==\n  (sym :new)) strip "," resolved_value "," resolved_name "," (send\n  (send\n    (self) :name) :map) join  ","(if\n  (send\n    (ivar :@prop_syntax) :==\n    (sym :new))\n  (dstr\n    (begin\n      (send nil :(send\n  (send\n    (self) :name) :map) join ))\n    (str \": \")\n    (begin\n      (send nil :value)))\n  (dstr\n    (str \":\")\n    (begin\n      (send nil :(send\n  (send\n    (self) :name) :map) join ))\n    (str \" \")\n    (begin\n      (send nil :value)))) strip ","(send\n  (send\n    (self) :name) :map) join  [] == ","(send\n  (send\n    (self) :name) :map) join  [] ","(send\n  (send\n    (self) :(send\n  (send\n    (self) :name) :map) join ) :map) join "," (send\n  (send\n    (self) :name) :map) join  map "," resolved_(send\n  (send\n    (self) :name) :map) join  "]}," Tree PropNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? ! ","child is_a? "]}," Tree PropNode perform!":{"type":"method","name":"perform!","children":[],"call":["@value perform to_s ","@value perform "," interpolate ","@value is_a? ","val to_s ","val value ","val is_a? ","@value context == ","@value context "," run_interp ","@value perform to_s  perform to_s "," interpolate  perform to_s ","@@value perform ue perform to_s ","@value perform to_s  perform "," interpolate  perform ","@@value perform ue perform ","@value perform to_s  is_a? "," interpolate  is_a? ","@@value perform ue is_a? ","@value perform  to_s ","@value perform  @value perform ue ","@value perform  is_a? ","@value perform to_s  context == "," interpolate  context == ","@@value perform ue context == ","@value perform to_s  context "," interpolate  context ","@@value perform ue context "]}," Tree PropNode to_s":{"type":"method","name":"to_s","children":[],"call":["to_return [] "," style == "," style ","to_return << << ","to_return << ","kid to_s ","kid invisible? "," children each "," children "," value "," value empty? ! "," value empty? ","   * ","tabs - "," raise ","Sass SyntaxError  new "," declaration dump "," declaration "," children empty? "," name "," value [] == "," value [] ","@prop_syntax == ","@options [] == ","@options [] ","(str \"Invalid property: \") + "," pseudo_class_selector_message "," pseudo_class_selector_(str \"Invalid property: \") +  "]}," Tree PropNode ==":{"type":"method","name":"==","children":[],"call":[" value == ","other value "," value "," name == ","other name "," name "," class == ","other class "," class "]}," Tree PropNode initialize":{"type":"method","name":"initialize","children":[],"call":["Haml Util  strip_string_array ","Haml Util  merge_adjacent_strings "]}," Sass Tree Node balance":{"type":"method","name":"balance","children":[],"call":[" raise ","Sass SyntaxError  new "," line ","Haml Shared  balance "]}," Sass Tree Node interpolate":{"type":"method","name":"interpolate","children":[],"call":["res + ","res << ","Script Parser  new parse_interpolated perform to_s ","Script Parser  new parse_interpolated perform ","Script Parser  new parse_interpolated ","Script Parser  new "," filename ","scan pos - ","scan matched_size ","scan pos "," line ","\\ * ","(int 0) max ","escapes - ","res << << ","escapes % == ","escapes % ","scan matched [] ","-2 - ","scan matched ","scan [] size ","scan [] ","Haml Shared  handle_interpolation ","scan [] size  - ","scan [] size  % == ","scan [] size  % "]}," Sass Tree Node perform_children":{"type":"method","name":"perform_children","children":[],"call":["(send\n  (send nil :children) :map) flatten ","c perform "," children map "," children "]}," Sass Tree Node perform!":{"type":"method","name":"perform!","children":[],"call":[" children= "," perform_children ","Environment  new "," check_child! "," children each "," children "]}," Sass Tree Node _perform":{"type":"method","name":"_perform","children":[],"call":["node perform! "," dup "," dup  perform! "]}," Sass Tree Node style":{"type":"method","name":"style","children":[],"call":["@options [] "]}," Sass Tree Node perform":{"type":"method","name":"perform","children":[],"call":["e add_metadata "," line "," filename "," _perform ","environment options= "," class == "," class "," raise ","e modify_backtrace "]}," Sass Tree Node invisible?":{"type":"method","name":"invisible?","children":[],"call":[]}," Sass Tree Node render":{"type":"method","name":"render","children":[],"call":[" perform to_s "," perform ","Environment  new "," perform cssize to_s "," perform cssize ","result to_s ","result do_extend ","extends empty? ","Haml Util SubsetMap  new ","result do_extend  to_s "," perform cssize  to_s ","result do_extend  do_extend "," perform cssize  do_extend ","Haml Util SubsetMap  new  empty? "]}," Sass Tree Node last":{"type":"method","name":"last","children":[],"call":[" children last "," children "]}," Sass Tree Node filename":{"type":"method","name":"filename","children":[],"call":["@options [] "]}," Sass Tree Node options=":{"type":"method","name":"options=","children":[],"call":["c options= "," children each "," children "]}," Tree MixinNode _perform":{"type":"method","name":"_perform","children":[],"call":["(send\n  (send\n    (lvar :mixin) :tree) :map) flatten ","c perform ","mixin tree map ","mixin tree "," raise ","Sass SyntaxError  new ","env var ","env set_local_var ","default perform ","value perform ","mixin args zip inject ","Sass Environment  new ","mixin environment ","mixin args zip ","mixin args ","(str \"Mixin \") gsub ","@args size == ","@args size ","mixin args size != ","mixin args size ","mixin args size < ","environment mixin ","var inspect ","var name ","(send\n  (send\n    (lvar :environment mixin ) :tree) :map) flatten ","environment mixin  tree map ","environment mixin  tree ","environment mixin  args zip inject ","environment mixin  environment ","environment mixin  args zip ","environment mixin  args ","environment mixin  args size != ","environment mixin  args size ","environment mixin  args size < ","environment environment mixin  "]}," Tree MixinNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree MixinDefNode _perform":{"type":"method","name":"_perform","children":[],"call":["environment set_mixin ","Sass Mixin  new "," children "]}," Sass Tree MixinDefNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree IfNode _perform":{"type":"method","name":"_perform","children":[],"call":["@else perform "," perform_children ","@expr perform to_bool ","@expr perform ","@expr nil? ","Sass Environment  new "]}," Tree IfNode options=":{"type":"method","name":"options=","children":[],"call":[" else options= "," else "]}," Tree IfNode add_else":{"type":"method","name":"add_else","children":[],"call":["@last_else else= "]}," Tree IfNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree ForNode _perform":{"type":"method","name":"_perform","children":[],"call":[" perform_children ","environment set_local_var ","Sass Script Number  new ","from denominator_units ","from numerator_units ","range each ","Sass Environment  new ","Range  new ","to to_i ","from to_i ","to coerce ","to assert_int! ","from assert_int! ","@to perform ","@from perform ","Sass Environment  new  set_local_var ","from denominato coerce r_units ","from denomina@to perform r_units ","@from perform  denominator_units ","from numerato coerce r_units ","from numera@to perform r_units ","@from perform  numerator_units ","Range  new  each ","to coerce  to coerce _i ","@to perform  @to perform _i ","from to coerce _i ","from @to perform _i ","@from perform  to_i ","to coerce  coerce ","@to perform  coerce ","to coerce  assert_int! ","@to perform  assert_int! ","@from perform  assert_int! ","@to coerce  perform ","@@to perform  perform ","@@from perform  perform "]}," Tree ForNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree FileNode perform!":{"type":"method","name":"perform!","children":[],"call":[" raise ","e add_backtrace_entry "," children= "," perform_children ","Sass Files  tree_for children ","Sass Files  tree_for "," filename "]}," Sass Tree FileNode invisible?":{"type":"method","name":"invisible?","children":[],"call":[" to_s empty? "," to_s "]}," Sass Tree FileNode to_s":{"type":"method","name":"to_s","children":[],"call":[" raise ","e add_backtrace_entry "," strip "," style == "," style "]}," Sass Tree FileNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree DirectiveNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree DebugNode _perform":{"type":"method","name":"_perform","children":[],"call":["STDERR  puts "," line "," filename ","@expr perform ","$stderr puts ","res value ","res is_a? ","@expr perform  value ","res value  value ","@expr perform  is_a? ","res value  is_a? "]}," Sass Tree DebugNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree CommentNode _perform":{"type":"method","name":"_perform","children":[],"call":[]}," Tree CommentNode invisible?":{"type":"method","name":"invisible?","children":[],"call":[" style == "," style "]}," Tree CommentNode ==":{"type":"method","name":"==","children":[],"call":[" lines == ","other lines "," lines "," silent == ","other silent "," silent "," value == ","other value "," value "," class == ","other class "," class "]}," Sass Script parse":{"type":"method","name":"parse","children":[],"call":[]}," Sass Script resolve":{"type":"method","name":"resolve","children":[],"call":[]}," Sass Script Variable perform":{"type":"method","name":"perform","children":[],"call":[" raise ","SyntaxError  new "," name ","environment var "]}," Sass Script Variable inspect":{"type":"method","name":"inspect","children":[],"call":[" name "," dasherize "," name == "]}," Sass Script Variable initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script UnaryOperation perform":{"type":"method","name":"perform","children":[],"call":[" raise ","Sass SyntaxError  new ","e name to_s == ","operator to_s ","e name to_s ","e name ","literal send ","@operand perform ","@operand perform  send "]}," Script UnaryOperation inspect":{"type":"method","name":"inspect","children":[],"call":["@operand inspect ","@operator inspect "]}," Script UnaryOperation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Script Parser try_tok":{"type":"method","name":"try_tok","children":[],"call":["@lexer next ","names include? ","peeked type ","@lexer peek ","@lexer peek  type "]}," Sass Script Parser assert_tok":{"type":"method","name":"assert_tok","children":[],"call":[" raise ","Sass SyntaxError  new ","@lexer peek type ","@lexer peek ","@lexer done? ","names join "," try_tok ","@lexer expected! ","(send\n  (lvar :names) :map) join ","Lexer TOKEN_NAMES  [] ","names map ","Sass Syn try_tok axError  new ","@lexer peek  try_tok ype ","  try_tok ry_ try_tok ok ","@lexer expec try_tok ed! "]}," Sass Script Parser assert_expr":{"type":"method","name":"assert_expr","children":[],"call":[" raise ","Sass SyntaxError  new ","@lexer peek type ","@lexer peek ","@lexer done? "," send ","@lexer expected! ","EXPR_NAMES  [] "," rais send  ","Sass SyntaxError  n send w ","@l send x send r p send  send k typ send  ","@l send x send r p send  send k ","@l send x send r don send ? "," s send nd ","@l send x send r  send xp send ct send d! "]}," Sass Script Parser literal":{"type":"method","name":"literal","children":[],"call":["t value "," try_tok "," try_tok  value ","  try_tok ry_ try_tok ok "]}," Sass Script Parser string":{"type":"method","name":"string","children":[],"call":["Operation  new ","first value "," assert_expr "," parse_interpolated "," try_tok "," literal ","interp line= ","StringInterpolation  new ","@lexer line "," number ","op line= "," node "," try_tok  value "," parse_StringInterpolation  new olated ","StringInterpolation  new  line= ","interp @lexer line = ","@lexer @lexer line  ","op @lexer line = ","Operation  new  line= "]}," Sass Script Parser variable":{"type":"method","name":"variable","children":[],"call":["Variable  new ","c value "," string "," try_tok "," node "," try_tok  value "]}," Sass Script Parser paren":{"type":"method","name":"paren","children":[],"call":[" assert_tok "," assert_expr "," variable "," try_tok "," ass assert_expr rt_tok "," ass assert_expr rt_ assert_expr xpr "," variabl assert_expr  "]}," Sass Script Parser arglist":{"type":"method","name":"arglist","children":[],"call":[" arglist "," try_tok "," concat "," interpolation "," assert_expr "," int concat rpolation "," int interpolation rpolation "," ass concat rt_ concat xpr "," ass interpolation rt_ interpolation xpr "]}," Sass Script Parser funcall":{"type":"method","name":"funcall","children":[],"call":["Script String  new ","name value "," warn ","name offset ","name line ","Script Funcall  new "," assert_tok "," arglist "," try_tok "," paren "," node ","tok value "," fn_arglist "," raw ","Color  new ","Color HTML4_COLORS  [] ","@lexer next ","@stop_at include? ","@lexer peek value ","@lexer peek ","@lexer peek type == ","@lexer peek type "," try_tok  value ","@lexer next  value "," try_tok  offset ","@lexer next  offset "," try_tok  line ","@lexer next  line "," assert_ try_tok  "," try_ try_tok  "]}," Sass Script Parser concat":{"type":"method","name":"concat","children":[],"call":["Operation  new "," or_expr "," node ","OpOperation  new ration  nOperation  new w ","Op or_expr ration  n or_expr w ","Op node ration  n node w "," or_Operation  new xpr "," or_ or_expr xpr "," or_ node xpr "," nodOperation  new  "," nod or_expr  "," nod node  "]}," Sass Script Parser unary":{"type":"method","name":"unary","children":[],"call":[" class_eval "]}," Sass Script Parser production":{"type":"method","name":"production","children":[],"call":[" class_eval ","sub inspect ","(send\n  (lvar :ops) :map) join ","o inspect ","ops map ","name inspect ","ops inspect "]}," Sass Script Parser parse":{"type":"method","name":"parse","children":[],"call":[" raise ","Sass SyntaxError  new ","@lexer peek type ","@lexer peek ","@lexer done? "," assert_expr "," assert_done ","e modify_backtrace ","@options [] ","@lexer line ","expr options= "," assert_ assert_expr  "," assert_expr  options= "]}," Sass Script Parser parse_interpolated":{"type":"method","name":"parse_interpolated","children":[],"call":[" assert_tok "," assert_expr "," raise ","e modify_backtrace ","@options [] ","@lexer line ","expr options= "," assert_ assert_expr  "," assert_expr  options= "]}," Sass Script Parser initialize":{"type":"method","name":"initialize","children":[],"call":["Lexer  new "," lexer_class new "," lexer_class "]}," Script Operation perform":{"type":"method","name":"perform","children":[],"call":[" raise ","Sass SyntaxError  new ","e name to_s == ","@operator to_s ","e name to_s ","e name ","literal1 send ","@operand2 perform ","@operand1 perform ","@operand1 perform  send "]}," Script Operation inspect":{"type":"method","name":"inspect","children":[],"call":["@operand2 inspect ","@operand1 inspect ","@operator inspect "]}," Script Operation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script Number sans_common_units":{"type":"method","name":"sans_common_units","children":[],"call":["(send\n  (lvar :units1) :map) compact ","units2 delete_at ","units2 index ","units1 map ","units2 dup ","units2 dup  delete_at ","units2 dup  index ","units2 dup  dup "]}," Script Number convertable?":{"type":"method","name":"convertable?","children":[],"call":[" Array all? ","CONVERTABLE_UNITS  method "," Array "]}," Script Number conversion_factor":{"type":"method","name":"conversion_factor","children":[],"call":["1.0 / "," conversion_factor ","res nil? ","CONVERSION_TABLE  [] [] ","CONVERTABLE_UNITS  [] ","CONVERSION_TABLE  [] ","CONVERSION_TABLE  [] []  nil? "]}," Script Number normalize!":{"type":"method","name":"normalize!","children":[],"call":["@numerator_units delete_at ","@numerator_units index ","@denominator_units delete_at "," conversion_factor ","@numerator_units detect "," method "," convertable? ","@denominator_units each_with_index "," sans_common_units "," denominator_units "," numerator_units "," unitless? ","@n@numerator_units detect merator_@numerator_units detect nits delete_at ","@n@numerator_units detect merator_@numerator_units detect nits index ","@denominator_@numerator_units detect nits delete_at ","@n@numerator_units detect merator_@numerator_units detect nits detect ","@denominator_@numerator_units detect nits each_with_index "," sans_common_@numerator_units detect nits "," denominator_@numerator_units detect nits "," n@numerator_units detect merator_@numerator_units detect nits "," @numerator_units detect nitless? "]}," Script Number unit_str":{"type":"method","name":"unit_str","children":[],"call":["rv << "," denominator_units join "," denominator_units "," denominator_units any? "," numerator_units join "," numerator_units "," denominator_units sort join "," denominator_units sort "," numerator_units sort join "," numerator_units sort "," numerator_units join  << "," numerator_units sort join  << "]}," Script Number compute_units":{"type":"method","name":"compute_units","children":[],"call":["this denominator_units ","this numerator_units ","this denominator_units + ","other numerator_units ","this numerator_units + ","other denominator_units "]}," Script Number coercion_factor":{"type":"method","name":"coercion_factor","children":[],"call":["m * "," conversion_factor ","p [] ","from_units zip inject ","from_units zip "," raise ","Sass UnitConversionError  new ","to_units join ","from_units join "," convertable? ! "," convertable? ","from_units | ","from_units size != ","to_units size ","from_units size "," sans_common_units "]}," Script Number operate":{"type":"method","name":"operate","children":[],"call":["Bool  new ","Number  new "," compute_units ","result is_a? ","value send ","other value ","this value ","this value to_f ","/ == ","other coerce "," denominator_units "," numerator_units ","this coerce ","other denominator_units ","other numerator_units "," unitless? ","(sym :+) include? ","value send  is_a? ","this value  send ","this value to_f  send ","other this value  ","other this value to_f  ","other coerce  value ","this this value  ","this this value to_f  ","this coerce  value ","this this value  to_f ","this this value to_f  to_f ","this coerce  value to_f ","other coerce  coerce ","this coerce  coerce ","other coerce  denominator_units ","other coerce  numerator_units "]}," Script Number coerce":{"type":"method","name":"coerce","children":[],"call":["Number  new "," value * / "," coercion_factor "," denominator_units "," value * "," numerator_units "," value "," unitless? "]}," Script Number legal_units?":{"type":"method","name":"legal_units?","children":[],"call":[" denominator_units empty? "," denominator_units "," numerator_units size == "," numerator_units size "," numerator_units "," numerator_units empty? "]}," Script Number unitless?":{"type":"method","name":"unitless?","children":[],"call":[" denominator_units empty? "," denominator_units "," numerator_units empty? "," numerator_units "]}," Script Number int?":{"type":"method","name":"int?","children":[],"call":[" value % == "," value % "," value "]}," Script Number to_i":{"type":"method","name":"to_i","children":[],"call":[" value "," int? "]}," Script Number inspect":{"type":"method","name":"inspect","children":[],"call":[" unit_str ","(send\n  (send\n    (self) :value) :*\n  (const nil :PRECISION)) round / ","(send\n  (send\n    (self) :value) :*\n  (const nil :PRECISION)) round "," value * "," value "," value to_i "," int? "," value nan? "," value infinite? "," value is_a? "," class round "," class ","(send\n  (send\n    (self) : value ) :*\n  (const nil :PRECISION)) round / ","(send\n  (send\n    (self) : value ) :*\n  (const nil :PRECISION)) round ","  value  * ","  value  ","  value  to_i ","  value  nan? ","  value  infinite? ","  value  is_a? "]}," Script Number to_s":{"type":"method","name":"to_s","children":[],"call":[" inspect "," raise ","Sass SyntaxError  new "," legal_units? "," original "]}," Script Number lte":{"type":"method","name":"lte","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Script Number lt":{"type":"method","name":"lt","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Script Number gte":{"type":"method","name":"gte","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Script Number gt":{"type":"method","name":"gt","children":[],"call":[" operate "," raise ","NoMethodError  new ","other is_a? "]}," Script Number eq":{"type":"method","name":"eq","children":[],"call":["Sass Script Bool  new ","this value == ","other value ","this value ","other coerce "," denominator_units "," numerator_units ","this coerce ","other denominator_units ","other numerator_units "," unitless? ","other is_a? ","this coerce  value == ","other coerce  value ","this coerce  value ","other coerce  coerce ","this coerce  coerce ","other coerce  denominator_units ","other coerce  numerator_units ","other coerce  is_a? "]}," Script Number mod":{"type":"method","name":"mod","children":[],"call":[" raise ","NoMethodError  new "," operate ","Sass UnitConversionError  new ","other inspect ","other unitless? ","other is_a? "]}," Script Number div":{"type":"method","name":"div","children":[],"call":[" operate ","other is_a? ","res original= ","other original "," original "," context != "," context "," operate  original= "]}," Script Number times":{"type":"method","name":"times","children":[],"call":[" raise ","NoMethodError  new ","other times ","other is_a? "," operate "]}," Script Number unary_minus":{"type":"method","name":"unary_minus","children":[],"call":["Number  new "," denominator_units "," numerator_units "," value -@ "," value "]}," Script Number minus":{"type":"method","name":"minus","children":[],"call":[" operate ","other is_a? "]}," Script Number plus":{"type":"method","name":"plus","children":[],"call":["other plus ","other is_a? "," operate "]}," Script Number initialize":{"type":"method","name":"initialize","children":[],"call":[" normalize! "]}," Script Node perform":{"type":"method","name":"perform","children":[],"call":[" raise ","NotImplementedError  new ","e modify_backtrace "," line "," _perform "]}," Script Literal assert_int!":{"type":"method","name":"assert_int!","children":[],"call":[" to_i "]}," Script Literal to_i":{"type":"method","name":"to_i","children":[],"call":[" raise ","Sass SyntaxError  new "," inspect "]}," Script Literal ==":{"type":"method","name":"==","children":[],"call":[" eq to_bool "," eq "]}," Script Literal to_bool":{"type":"method","name":"to_bool","children":[],"call":[]}," Script Literal inspect":{"type":"method","name":"inspect","children":[],"call":[" value inspect "," value "]}," Script Literal unary_div":{"type":"method","name":"unary_div","children":[],"call":["Sass Script String  new "," to_s "]}," Script Literal unary_minus":{"type":"method","name":"unary_minus","children":[],"call":["Sass Script String  new "," to_s "]}," Script Literal div":{"type":"method","name":"div","children":[],"call":["Sass Script String  new ","other to_s "," to_s "]}," Script Literal minus":{"type":"method","name":"minus","children":[],"call":["Sass Script String  new ","other to_s "," to_s "]}," Script Literal plus":{"type":"method","name":"plus","children":[],"call":["Sass Script String  new "," to_s + ","other to_s "," to_s ","other type ","other value ","other is_a? "]}," Script Literal comma":{"type":"method","name":"comma","children":[],"call":["Sass Script String  new ","other to_s "," to_s "," options [] == "," options [] "," options "]}," Script Literal concat":{"type":"method","name":"concat","children":[],"call":["Sass Script String  new ","other to_s "," to_s "]}," Script Literal unary_not":{"type":"method","name":"unary_not","children":[],"call":["Sass Script Bool  new "," to_bool ! "," to_bool "]}," Script Literal neq":{"type":"method","name":"neq","children":[],"call":["Sass Script Bool  new "," eq to_bool ! "," eq to_bool "," eq "]}," Script Literal eq":{"type":"method","name":"eq","children":[],"call":["Sass Script Bool  new "," value == ","other value "," value "," class == ","other class "," class "]}," Script Literal or":{"type":"method","name":"or","children":[],"call":[" to_bool "]}," Script Literal and":{"type":"method","name":"and","children":[],"call":[" to_bool "]}," Script Literal perform":{"type":"method","name":"perform","children":[],"call":[]}," Script Literal initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Script Lexer after_interpolation?":{"type":"method","name":"after_interpolation?","children":[],"call":["@prev type == ","@prev type "]}," Sass Script Lexer last_match_position":{"type":"method","name":"last_match_position","children":[],"call":[" current_position - ","@scanner matched_size "," current_position "]}," Sass Script Lexer current_position":{"type":"method","name":"current_position","children":[],"call":["@offset + + ","@offset + ","@scanner pos "]}," Sass Script Lexer op":{"type":"method","name":"op","children":[],"call":["OPERATORS  [] ","@scanner scan ","REGULAR_EXPRESSIONS  [] "," warn "," last_match_position ","(sym :bool) include? ","@prev type ","prev_chr !~ ","op == ","@scanner string [] chr ","@scanner string [] ","@scanner pos - ","@scanner pos ","@scanner string ","@interpolation_stack << "," scan ","@scanner string [] chr  !~ ","@scanner scan  == "," scan  == "]}," Sass Script Lexer bool":{"type":"method","name":"bool","children":[],"call":["Script Bool  new ","s == ","@scanner scan ","REGULAR_EXPRESSIONS  [] "," scan ","@scanner scan  == "," scan  == ","@@scanner scan canner @scanner scan can ","@ scan canner  scan can "," @scanner scan can ","  scan can "]}," Sass Script Lexer color":{"type":"method","name":"color","children":[],"call":["Script Color  new ","num ljust to_i ","num ljust ","(send\n  (begin\n    (irange\n      (int 1)\n      (int 3))) :map) map ","@scanner [] ","(irange\n  (int 1)\n  (int 3)) map ","Color HTML4_COLORS  [] ","@scanner [] downcase ","@scanner scan ","REGULAR_EXPRESSIONS  [] ","s scan first map ","s scan first ","s scan "," scan "," raise ","Sass SyntaxError  new ","s size == ","s size ","(str \"Colors must have either three or six digits: '\") rstrip ","num lju scan t to_i ","num lju scan t ","( scan end\n  (begin\n    (irange\n      (int 1)\n      (int 3))) :map) map ","@ scan canner [] ","@ scan canner [] downca scan e ","@ scan canner  scan can "," scan   scan can fir scan t map "," scan   scan can fir scan t "," scan   scan can ","  scan can "," rai scan e ","Sa scan  scan  SyntaxError  new "," scan   scan ize == "," scan   scan ize ","( scan tr \"Color scan  mu scan t have either three or  scan ix digit scan : '\") r scan trip "]}," Sass Script Lexer number":{"type":"method","name":"number","children":[],"call":["Script Number  new "," Array ","@scanner [] ","value -@ ","@scanner [] to_i ","@scanner [] to_f ","@scanner scan ","REGULAR_EXPRESSIONS  [] "," scan ","value -@  -@ ","@scanner [] to_i  -@ ","@scanner [] to_f  -@ "]}," Sass Script Lexer begin_interpolation":{"type":"method","name":"begin_interpolation","children":[],"call":["@scanner scan "]}," Sass Script Lexer string":{"type":"method","name":"string","children":[],"call":["Script String  new ","@scanner [] gsub gsub ","@scanner [] gsub ","@scanner [] ","@scanner scan ","REGULAR_EXPRESSIONS  [] ","@scanner [] == ","re == ","@interpolation_stack << ","@scanner pos "," scan ","STRING_REGULAR_EXPRESSIONS  [] ","@scanner [] empty? "]}," Sass Script Lexer ident":{"type":"method","name":"ident","children":[],"call":["s gsub ","@scanner scan ","REGULAR_EXPRESSIONS  [] ","@scanner [] "," scan ","@scanner scan  g@scanner scan ub "," scan  g scan ub ","@@scanner scan canner @scanner scan can ","@ scan canner  scan can ","@@scanner scan canner [] ","@ scan canner [] "," @scanner scan can ","  scan can "]}," Sass Script Lexer variable":{"type":"method","name":"variable","children":[],"call":["@scanner [] ","@scanner scan ","REGULAR_EXPRESSIONS  [] "," _variable "]}," Sass Script Lexer token":{"type":"method","name":"token","children":[],"call":[" ident "," op "," bool "," color "," number "," string "," variable "," after_interpolation? "," ident_op "," special_fun "," raw ","@interpolation_stack pop "]}," Sass Script Lexer whitespace":{"type":"method","name":"whitespace","children":[],"call":["@scanner scan ","REGULAR_EXPRESSIONS  [] "," scan "]}," Sass Script Lexer read_token":{"type":"method","name":"read_token","children":[],"call":["Token  new "," last_match_position ","value last ","value first "," raise ","SyntaxError  new "," current_position ","@scanner string "," token "," done? ","@scanner pos - ","@scanner pos "," current_position - ","val line= ","val is_a? ","@scanner matched_size ","value last line= ","value last is_a? "," token  last "," token  first "," token  last line= "," token  last is_a? "]}," Sass Script Lexer done?":{"type":"method","name":"done?","children":[],"call":["@tok nil? ","@scanner eos? "," whitespace "," after_interpolation? ","@interpolation_stack last "]}," Sass Script Lexer peek":{"type":"method","name":"peek","children":[],"call":[" read_token "]}," Sass Script Lexer next":{"type":"method","name":"next","children":[],"call":[" read_token "]}," Sass Script Lexer initialize":{"type":"method","name":"initialize","children":[],"call":["StringScanner  new ","str is_a? "]}," Script Functions hue_to_rgb":{"type":"method","name":"hue_to_rgb","children":[],"call":["m1 + ","(send\n  (lvar :m2) :-\n  (lvar :m1)) * * ","(send\n  (lvar :m2) :-\n  (lvar :m1)) * ","2.0 / - ","2.0 / ","m2 - ","h * < ","h * ","h > ","h < "]}," Script Functions numeric_transformation":{"type":"method","name":"numeric_transformation","children":[],"call":["Sass Script Number  new ","value denominator_units ","value numerator_units ","value value "," raise ","Sass SyntaxError  new "," caller first scan first first "," caller first scan first "," caller first scan "," caller first "," caller ","value is_a? "," assert_type "]}," Script Functions abs":{"type":"method","name":"abs","children":[],"call":["n abs "," numeric_transformation "]}," Script Functions floor":{"type":"method","name":"floor","children":[],"call":["n floor "," numeric_transformation "]}," Script Functions ceil":{"type":"method","name":"ceil","children":[],"call":["n ceil "," numeric_transformation "]}," Script Functions round":{"type":"method","name":"round","children":[],"call":["n round "," numeric_transformation "]}," Script Functions percentage":{"type":"method","name":"percentage","children":[],"call":["Sass Script Number  new ","value value * ","value value "," raise ","ArgumentError  new ","value unitless? ","value is_a? ","value inspect "]}," Script Functions hsl":{"type":"method","name":"hsl","children":[],"call":["Color  new ","(send\n  (lvar :c) :*\n  (int 255)) round ","c * ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :m2)\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map "," hue_to_rgb ","h - ","1.0 / ","h + ","l * - ","l * ","l + - ","l + ","s + ","l <= ","(send\n  (lvar :h) :%\n  (int 360)) / ","h % "," raise ","ArgumentError  new ","l > ","l < ","s > ","s < ","a value ","(lvar :hue) map "," assert_type "," hsla ","Number  new ","(send nil :hue_to_rgb\n  (lvar :l * - )\n  (lvar :m2)\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :l + - )\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :l * )\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :(send\n  (lvar :h) :%\n  (int 360)) / ue_to_rgb\n  (lvar :m1)\n  (lvar :m2)\n  (send\n    (lvar :(send\n  (lvar :h) :%\n  (int 360)) / ) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map "," (send\n  (lvar :h) :%\n  (int 360)) / ue_to_rgb ","(send\n  (lvar :h) :%\n  (int 360)) /  - ","(send\n  (lvar :h) :%\n  (int 360)) /  + ","(send\n  (lvar :(send\n  (lvar :h) :%\n  (int 360)) / ) :%\n  (int 360)) / ","(send\n  (lvar :h) :%\n  (int 360)) /  % ","(lvar :(send\n  (lvar :h) :%\n  (int 360)) / ue) map "," (send\n  (lvar :h) :%\n  (int 360)) / sla "]}," Script Functions rgb":{"type":"method","name":"rgb","children":[],"call":["Color  new ","blue value ","green value ","red value "," raise ","ArgumentError  new ","v >= ","v <= ","(send\n  (lvar :red) :value) each ","v > ","v < ","(irange\n  (int 0)\n  (int 255)) include? ","v * / ","v * ","(irange\n  (int 0)\n  (int 100)) include? ","c denominator_units empty? ","c denominator_units ","c numerator_units == ","c numerator_units ","c value ","(lvar :red) map "," assert_type ","blue c value alue ","green c value alue ","red c value alue ","c value  >= ","c value  <= ","(send\n  (lc value ar :red) :c value alue) each ","c value  > ","c value  < ","c value  * / ","c value  * ","c c value alue ","(lc value ar :red) map "]}," Script Functions EvaluationContext initialize":{"type":"method","name":"initialize","children":[],"call":[" include "]}," Sass Script Funcall perform":{"type":"method","name":"perform","children":[],"call":[" raise ","Sass SyntaxError  new "," name ","e message ","e backtrace first =~ ","e backtrace first ","e backtrace ","Functions EvaluationContext  new send ","Functions EvaluationContext  new ","environment options ","Script String  new ","(send\n  (lvar :args) :map) join ","a perform ","args map "," name !~ ","Haml Util  has? "," args map "," args ","t =~ ","e backtrace any? "]}," Sass Script Funcall inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :args) :map) join ","a inspect "," args map "," args "," name "]}," Sass Script Funcall initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script Color piecewise":{"type":"method","name":"piecewise","children":[],"call":["Color  new ","rgb []= ","(send\n  (array\n    (lvar :res)\n    (int 255)) :min) max ","(lvar :res) min ","@value [] send ","other_val [] ","@value [] "," raise ","Sass SyntaxError  new ","other unitless? ! ","other unitless? ","other value ","other is_a? ","result []= "," rgb [] send ","other rgb [] ","other rgb "," rgb [] "," rgb "," with ","result [] ","other alpha != "," alpha ","other alpha ","other_num ! ","(send\n  (array\n    (lvar :@value [] send )\n    (int 255)) :min) max ","(send\n  (array\n    (lvar : rgb [] send )\n    (int 255)) :min) max ","(lvar :@value [] send ) min ","(lvar : rgb [] send ) min ","other value  [] ","@value [] send ult []= "," rgb [] send ult []= ","@value [] send ult [] "," rgb [] send ult [] ","other is_a?  ! "]}," Script Color to_s":{"type":"method","name":"to_s","children":[],"call":["num to_s rjust ","num to_s ","@value map ","HTML4_COLORS_REVERSE  [] "," rgb map "," rgb "," hex_str "," smallest "," options [] == "," options [] "," options "," rgba_str "," alpha? "]}," Script Color mod":{"type":"method","name":"mod","children":[],"call":[" raise ","NoMethodError  new "," piecewise ","other is_a? "]}," Script Color div":{"type":"method","name":"div","children":[],"call":[" piecewise ","other is_a? "]}," Script Color times":{"type":"method","name":"times","children":[],"call":[" raise ","NoMethodError  new "," piecewise ","other is_a? "]}," Script Color minus":{"type":"method","name":"minus","children":[],"call":[" piecewise ","other is_a? "]}," Script Color plus":{"type":"method","name":"plus","children":[],"call":[" piecewise ","other is_a? "]}," Script Color initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","Sass SyntaxError  new ","c > ","c < ","rgb any? ","c to_i ","rgb map ","rgb freeze ","(irange\n  (int 0)\n  (int 1)) include? ","@attrs [] ","k to_s capitalize ","k to_s ","(irange\n  (int 0)\n  (int 100)) include? ","@attrs []= ","@attrs [] - > ","@attrs [] - ","@attrs [] - < ","@attrs [] > ","@attrs [] < ","@attrs [] nil? ","(sym :saturation) each ","(irange\n  (int 0)\n  (int 255)) include? ","@attrs [] to_i ","(sym :red) each ","ArgumentError  new ","rgb size != ","rgb size ","rgb empty? ! ","rgb empty? ","hsl size != ","hsl size ","hsl empty? ! ","hsl empty? ","allow_both_rgb_and_hsl ! ","(sym :red) & ","attrs keys ","(sym :hue) & ","v nil? ","attrs reject ","attrs [] to_f ","attrs [] ","attrs [] map ","(irange\n  (int 3)\n  (int 4)) include? ","attrs size ","attrs is_a? ","(sym :red) &  any? ","(sym :red) &  map ","(sym :red) &  freeze ","(sym :red) &  size != ","(sym :red) &  size ","(sym :red) &  empty? ! ","(sym :red) &  empty? ","(sym :hue) &  size != ","(sym :hue) &  size ","(sym :hue) &  empty? ! ","(sym :hue) &  empty? ","allow_both_(sym :red) & _and_hsl ! ","allow_both_rgb_and_(sym :hue) &  ! "]}," Script Bool to_s":{"type":"method","name":"to_s","children":[],"call":["@value to_s "]}," Sass Repl parse_input":{"type":"method","name":"parse_input","children":[],"call":[" puts ","e backtrace each ","e backtrace ","@options [] ","e message "," p ","Script Parser  parse perform ","Script Parser  parse ","environment var ","environment set_var ","val perform ","text size - ","3 size ","text size ","2 == ","3 == ","Script Parser  parse  perform "]}," Sass Repl run":{"type":"method","name":"run","children":[],"call":[" parse_input ","Readline HISTORY  << "," puts ","Readline  readline "," loop ","environment set_var ","Script String  new ","Environment  new ","Environment  new  set_var "]}," Sass Repl initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Plugin exact_stylesheet_needs_update?":{"type":"method","name":"exact_stylesheet_needs_update?","children":[],"call":[" dependencies any? "," dependency_updated? "," dependencies ","File  mtime > ","File  mtime ","File  exists? "]}," Sass Plugin css_locations":{"type":"method","name":"css_locations","children":[],"call":[" options [] "," options ","l last "," options [] to_a map "," options [] to_a "," options [] is_a? ! "," options [] is_a? "," template_location_array to_a map "," template_location_array to_a "," template_location_array "]}," Sass Plugin template_locations":{"type":"method","name":"template_locations","children":[],"call":["l first ","location to_a map ","location to_a ","location is_a? ","File  join "," options [] "," options "," template_location_array to_a map "," template_location_array to_a "," template_location_array "]}," Sass Plugin mkpath":{"type":"method","name":"mkpath","children":[],"call":["Dir  mkdir ","File  exist? ","dirs each ","dirs << ","File  join ","dirs [] ","name split [] each ","name split [] ","name split "]}," Sass Plugin update_stylesheet":{"type":"method","name":"update_stylesheet","children":[],"call":["file print ","File  open "," mkpath "," exception_string ","Sass Files  tree_for render ","Sass Files  tree_for "," engine_options "," template_filename ","File  delete ","File  exists? "," css_filename "," raise "," options [] "," options ","RbConfig CONFIG  [] =~ ","RbConfig CONFIG  [] "," run_updating_stylesheet ","Sass SyntaxError  exception_to_css "," run_compilation_error ","FileUtils  mkdir_p "," run_creating_directory ","File  dirname ","Haml Util  windows? ","file set_encoding ","result encoding ","Haml Util  ruby1_8? "," template_ template_filename  "," css_ template_filename  ","  css_filename _filename ","Sass SyntaxError  exception_to_ css_filename  ","FileUtils  mkFile  dirname _p "," run_creating_File  dirname ectory ","File  File  dirname name ","Sass SyntaxError  exception_to_css  encoding ","Sass Files  tree_for render  encoding "]}," Sass Files find_full_path":{"type":"method","name":"find_full_path","children":[],"call":["File  readable? ","File  join ","(lvar :partial_name) each ","load_paths each ","Pathname  new absolute? ","Pathname  new ","File  basename ","File  dirname ","(lvar :File  join ) each "]}," Sass Files try_to_write_sassc":{"type":"method","name":"try_to_write_sassc","children":[],"call":["f write ","Marshal  dump ","File  open ","FileUtils  mkdir_p ","File  dirname ","File  writable? ! ","File  writable? ","File  exists? ","options [] "]}," Sass Files try_to_read_sassc":{"type":"method","name":"try_to_read_sassc","children":[],"call":[" warn ","Marshal  load ","f read ","f readline strip == ","f readline strip ","f readline ","File  open ","File  readable? ","Haml Util  haml_warn "]}," Sass Files sassc_filename":{"type":"method","name":"sassc_filename","children":[],"call":["File  join ","File  basename + ","File  basename ","Digest SHA1  hexdigest ","File  dirname ","File  expand_path ","options [] "]}," Sass Files find_file_to_import":{"type":"method","name":"find_file_to_import","children":[],"call":[" raise ","SyntaxError  new ","filename + "," find_full_path ","filename [] == ","filename [] "," warn ","message << << ","load_paths join ","message << ","load_paths first ","load_paths size == ","load_paths size ","Haml Util  haml_warn ","load_paths each ","load_paths uniq ","(str \".sass\") include? ","filename []  + ","filename []  [] == ","filename []  [] ","load_paths uniq  join ","load_paths uniq  first ","load_paths uniq  size == ","load_paths uniq  size ","load_paths uniq  each ","load_paths uniq  uniq "]}," Sass Files tree_for":{"type":"method","name":"tree_for","children":[],"call":[" try_to_write_sassc ","options [] "," raise ","err add_backtrace_entry ","engine to_tree ","Sass Engine  new ","options merge ","root options= "," try_to_read_sassc ","Digest SHA1  hexdigest "," sassc_filename ","File  read ","Sass Engine DEFAULT_OPTIONS  merge ","filename =~ ","(pair\n  (sym :syntax)\n  (sym :sass)) merge ","(pair\n  (sym :syntax)\n  (sym :scss)) merge ","default_options merge! ","default_options delete ","Sass Engine DEFAULT_OPTIONS  dup ","Sass Engine DEFAULT_OPTIONS  merge  [] ","options merge  [] ","(pair\n  (sym :syntax)\n  (sym :sass)) merge  [] ","(pair\n  (sym :syntax)\n  (sym :scss)) merge  [] ","default_options merge!  [] ","Sass Engine  new  to_tree ","Sass Engine DEFAULT_OPTIONS  merge  merge ","options merge  merge ","(pair\n  (sym :syntax)\n  (sym :sass)) merge  merge ","(pair\n  (sym :syntax)\n  (sym :scss)) merge  merge ","default_options merge!  merge ","engine to_tree  options= "," try_to_read_sassc  options= ","root Sass Engine DEFAULT_OPTIONS  merge = ","root options merge = ","root (pair\n  (sym :syntax)\n  (sym :sass)) merge = ","root (pair\n  (sym :syntax)\n  (sym :scss)) merge = ","root default_options merge! = ","default_Sass Engine DEFAULT_OPTIONS  merge  merge! ","default_options merge  merge! ","default_(pair\n  (sym :syntax)\n  (sym :sass)) merge  merge! ","default_(pair\n  (sym :syntax)\n  (sym :scss)) merge  merge! ","default_default_options merge!  merge! ","Sass Engine DEFAULT_OPTIONS  dup  merge! ","default_Sass Engine DEFAULT_OPTIONS  merge  delete ","default_options merge  delete ","default_(pair\n  (sym :syntax)\n  (sym :sass)) merge  delete ","default_(pair\n  (sym :syntax)\n  (sym :scss)) merge  delete ","default_default_options merge!  delete ","Sass Engine DEFAULT_OPTIONS  dup  delete "]}," Sass SyntaxError add_metadata":{"type":"method","name":"add_metadata","children":[],"call":[" raise "," add_backtrace_entry "," sass_filename "," sass_line "]}," Sass Environment inherited_hash":{"type":"method","name":"inherited_hash","children":[],"call":[" class_eval ","44 + ","90 + ","102 + "]}," Sass Environment options":{"type":"method","name":"options","children":[],"call":[" parent options "," parent "]}," Sass Environment initialize":{"type":"method","name":"initialize","children":[],"call":[" set_var ","Script String  new ","Set  new "]}," Sass Engine import_paths":{"type":"method","name":"import_paths","children":[],"call":["paths unshift ","File  dirname ","@options [] ","(or\n  (send\n    (ivar :@options) :[]\n    (sym :load_paths))\n  (array)) dup ","(or\n  (send\n    (ivar :@options) :[]\n    (sym :load_paths))\n  (array)) dup  unshift ","(or\n  (send\n    (ivar :@options) :[]\n    (sym :load_(or\n  (send\n    (ivar :@options) :[]\n    (sym :load_paths))\n  (array)) dup ))\n  (array)) dup "]}," Sass Engine parse_script":{"type":"method","name":"parse_script","children":[],"call":["Script  parse ","@options [] ","options [] "]}," Sass Engine parse_mixin_arguments":{"type":"method","name":"parse_mixin_arguments","children":[],"call":["a strip ","arg_string split map ","arg_string split ","arg_string [] ","arg_string [] == ","arg_string empty? ","arg_string strip ","arg_string []  split map ","arg_string strip  split map ","arg_string []  split ","arg_string strip  split ","arg_string []  [] ","arg_string strip  [] ","arg_string []  [] == ","arg_string strip  [] == ","arg_string []  empty? ","arg_string strip  empty? ","arg_string []  strip ","arg_string strip  strip "]}," Sass Engine parse_else":{"type":"method","name":"parse_else","children":[],"call":["previous add_else "," append_children ","line children ","Tree IfNode  new "," parse_script ","line offset + ","line text index ","line text ","line offset "," raise ","SyntaxError  new ","text !~ ","previous is_a? ","parent last ","parent children last ","parent children ","parent last  add_else ","parent children last  add_else ","parent last  is_a? ","parent children last  is_a? "]}," Sass Engine parse_for":{"type":"method","name":"parse_for","children":[],"call":["Tree ForNode  new ","to_name == ","var [] "," parse_script ","line offset + ","line text index ","line text ","line offset "," raise ","SyntaxError  new ","var =~ ","text !~ ","var nil? ","text scan first ","text scan ","Script  var_warning ","@options [] ","line offset + + ","! + ","var slice! == ","var slice! ","line line offset + +  + ","line line offset + +  ","line line offset + +  + + "]}," Sass Engine parse_variable":{"type":"method","name":"parse_variable","children":[],"call":["Tree VariableNode  new ","op == "," parse_script ","line offset + ","line text index ","line text ","line offset "," raise ","SyntaxError  new ","@line + ","line children empty? ","line children ","line text scan [] ","line text scan ","Script  equals_warning ","@options [] ","expr to_sass ","expr context= ","op =~ ","Script  var_warning ","line text [] == ","line text [] "," parse_script  to_sass "," parse_script  context= "]}," Sass Engine parse_property":{"type":"method","name":"parse_property","children":[],"call":["Tree PropNode  new ","property_regx == "," parse_script ","line offset + ","line text index ","line text ","line offset ","eq strip [] == ","eq strip [] ","eq strip "," raise ","SyntaxError  new ","value nil? ","name nil? ","line text scan [] ","line text scan "," parse_interp ","Script  equals_warning ","@options [] ","Sass Tree PropNode  val_to_sass ","expr context= ","Sass Script String  new ","value strip empty? ","value strip "," parse_script  context= ","Sass Script String  new  context= "]}," Sass Engine append_children":{"type":"method","name":"append_children","children":[],"call":[" raise ","SyntaxError  new ","continued_rule line "," validate_and_append_child ","continued_rule children= ","child children ","continued_rule add_rules ","child is_a? ","child line ","child children empty? ","child continued? "," build_tree ","children each "," check_for_no_children ","continued_comment value << << ","child value ","continued_comment value << ","continued_comment value ","child line == ","continued_comment line + + ","continued_comment line + ","continued_comment value count ","continued_comment line ","child silent "," validate_and_append_ build_tree  ","continued_rule  build_tree ren= "," build_tree   build_tree ren "," build_tree  is_a? "," build_tree  line "," build_tree   build_tree ren empty? "," build_tree  continued? "," build_tree ren each "," check_for_no_ build_tree ren "," build_tree  value "," build_tree  line == "," build_tree  silent "]}," Sass Engine tree":{"type":"method","name":"tree","children":[],"call":["nodes << "," tree ","nodes last children= ","nodes last "," raise ","SyntaxError  new ","line index ","line tabs - ","line tabs ","line tabs > ","base + ","line tabs >= ","arr [] ","arr [] tabs ","arr [] nil? ","arr []  index ","arr []  tabs - ","arr []  tabs ","arr []  tabs > ","arr [] tabs  + ","arr []  tabs >= "]}," Sass Engine tabulate":{"type":"method","name":"tabulate","children":[],"call":["lines << ","Line  new ","@options [] ","tab_str size ","line strip "," raise ","SyntaxError  new ","(str \"Inconsistent indentation: \") strip gsub ","(str \"Inconsistent indentation: \") strip ","Haml Shared  human_indentation ","tab_str * != ","tab_str * ","line_tab_str scan size ","line_tab_str scan ","lines last text << << ","lines last text << ","lines last text ","lines last ","line =~ ","lines last tabs + ","lines last tabs ","lines last comment? ","tab_str nil? ","tab_str nil? ! ","tab_str include? ","line_tab_str empty? ","line [] ","line strip empty? ","string gsub scan each_with_index ","string gsub scan ","string gsub "," try_comment ","line []  scan size ","line []  scan ","line []  empty? "]}," Sass Engine to_tree":{"type":"method","name":"to_tree","children":[],"call":["e add_metadata ","@options [] ","root options= "," append_children "," tree first "," tree "," tabulate ","Tree Node  new "," _to_tree ","Haml Util  silence_haml_warnings "," raise ","e sass_template= ","e modify_backtrace ","Tree RootNode  new ","Sass SCSS Parser  new parse ","Sass SCSS Parser  new ","@options [] == ","Sass SyntaxError  new "," check_encoding ","Tree Node  new  options= ","Tree RootNode  new  options= ","Sass SCSS Parser  new parse  options= "]}," Sass Engine Line comment?":{"type":"method","name":"comment?","children":[],"call":[" text [] == "," text [] "," text "]}," Sass CSS properties":{"type":"method","name":"properties","children":[],"call":[" assert_match ","rule << ","Tree PropNode  new ","value << << "," whitespace ","value << ","@template [] ","@template scan "]}," Sass Tree PropNode to_sass":{"type":"method","name":"to_sass","children":[],"call":[" value ","opts [] "," name ","   * "]}," Haml Util static_method_name":{"type":"method","name":"static_method_name","children":[],"call":["(send\n  (lvar :vars) :map) join ","v ! ! ","v ! ","vars map "]}," Haml Util def_static_method":{"type":"method","name":"def_static_method","children":[],"call":["klass class_eval ","ERB  new result ","ERB  new ","args join "," static_method_name ","set include? ","vars map "," binding ","StaticConditionalContext  new instance_eval ","StaticConditionalContext  new "," powerset each "," powerset ","vars pop ","info [] "," caller_info ","(or\n  (and\n    (defined?\n      (const\n        (const nil :Erubis) :TinyEruby))\n    (const\n      (const nil :Erubis) :TinyEruby))\n  (const nil :ERB)) new result ","(or\n  (and\n    (defined?\n      (const\n        (const nil :Erubis) :TinyEruby))\n    (const\n      (const nil :Erubis) :TinyEruby))\n  (const nil :ERB)) new "," caller_info  [] "," caller_ caller_info  "]}," Haml Util StaticConditionalContext method_missing":{"type":"method","name":"method_missing","children":[],"call":["@set include? ","block nil? ","args empty? "]}," Haml Util StaticConditionalContext initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml Util enum_with_index":{"type":"method","name":"enum_with_index","children":[],"call":["enum each_with_index ","enum enum_with_index "," ruby1_8? "]}," Haml Util merge_adjacent_strings":{"type":"method","name":"merge_adjacent_strings","children":[],"call":["a << ","a last << ","a last ","a last is_a? ","e is_a? ","enum inject ","e dup ","arr inject ","arr size < ","arr size "]}," Haml Util powerset":{"type":"method","name":"powerset","children":[],"call":["new_powerset << ","subset + ","powerset each ","Set  new ","arr inject ","(send\n  (const nil :Set) :new) to_set ","Set  new  << "]}," Haml Util map_hash":{"type":"method","name":"map_hash","children":[],"call":[" to_hash ","hash map "]}," Haml Util map_vals":{"type":"method","name":"map_vals","children":[],"call":[" to_hash ","hash map "]}," Haml Util map_keys":{"type":"method","name":"map_keys","children":[],"call":[" to_hash ","hash map "]}," Haml Util to_hash":{"type":"method","name":"to_hash","children":[],"call":["h []= ","arr compact inject ","arr compact ","Hash  [] "]}," Haml Util scope":{"type":"method","name":"scope","children":[],"call":["File  join ","File  dirname ","File  expand_path "]}," Haml Shared human_indentation":{"type":"method","name":"human_indentation","children":[],"call":["indentation length ","indentation length == ","indentation inspect + ","indentation inspect ","indentation include? ! ","indentation include? "]}," Haml Shared balance":{"type":"method","name":"balance","children":[],"call":["scanner rest ","str strip ","count == ","scanner matched [] == ","scanner matched [] ","scanner matched ","str << ","scanner scan ","Regexp  new ","finish chr ","start chr ","StringScanner  new ","scanner is_a? ","StringScanner  new  rest ","StringScanner  new  matched [] == ","StringScanner  new  matched [] ","StringScanner  new  matched ","StringScanner  new  scan ","StringScanner  new  is_a? "]}," Haml Shared handle_interpolation":{"type":"method","name":"handle_interpolation","children":[],"call":["scan rest ","scan scan ","StringScanner  new ","StringScanner  new  rest ","StringScanner  new  StringScanner  new  "]}," Haml Precompiler block_opened?":{"type":"method","name":"block_opened?","children":[],"call":["@next_line tabs > ","@line tabs ","@next_line tabs "," flat? ! "," flat? "]}," Haml Precompiler un_next_line":{"type":"method","name":"un_next_line","children":[],"call":["@template unshift "]}," Haml Precompiler closes_flat?":{"type":"method","name":"closes_flat?","children":[],"call":["line full !~ ","line full ","line text empty? ! ","line text empty? ","line text "]}," Haml Precompiler next_line":{"type":"method","name":"next_line","children":[],"call":[" handle_multiline "," next_line "," newline ","line text empty? ","line text ","line full =~ ","@line full [] ","@line full ","line full ","@line text [] == ","@line text [] ","@line text "," closes_flat? ! "," closes_flat? "," flat? ","@line tabs ","Line  new ","text lstrip chomp ","text lstrip ","text strip ","text == "," raw_next_line "," handle_multiLine  new  "," next_Line  new  "," newLine  new  ","Line  new  text empty? ","Line  new  text ","Line  new  full =~ ","@Line  new  full [] ","@Line  new  full ","Line  new  full ","@Line  new  text [] == ","@Line  new  text [] ","@Line  new  text ","@Line  new  tabs "," raw_next_Line  new  "]}," Haml Precompiler raw_next_line":{"type":"method","name":"raw_next_line","children":[],"call":["@template shift "]}," Haml Precompiler parse_new_attribute":{"type":"method","name":"parse_new_attribute","children":[],"call":["\" + + ","\" + ","(send\n  (lvar :content) :map) join ","v inspect [] ","v inspect ","t == ","content map ","content first [] ","content first ","content size == ","content size ","content << "," balance first [] "," balance first "," balance ","scanner [] == ","scanner [] ","scanner [] gsub ","scanner scan "," loop ","(send\n  (lscanner scan  :content) :map) join "]}," Haml Precompiler parse_new_attributes":{"type":"method","name":"parse_new_attributes","children":[],"call":["scanner rest ","dynamic_attributes == ","dynamic_attributes << ","dynamic_attributes << << << << ","dynamic_attributes << << << ","dynamic_attributes << << ","name inspect ","static_attributes []= ","type == ","attributes each ","scanner scan "," next_line ","line << << ","@next_line text ","line << ","scanner eos? ","attributes []= "," raise ","Haml SyntaxError  new ","last_line - ","text inspect ","(or\n  (send\n    (const\n      (const nil :Haml) :Shared) :balance\n    (lvar :line)\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line))) first ","Haml Shared  balance ","name == ","(masgn\n  (mlhs\n    (lvasgn :name)\n    (lvasgn :value))\n  (send nil :parse_new_attribute\n    (lvar :scanner))) first nil? ","(masgn\n  (mlhs\n    (lvasgn :name)\n    (lvasgn :value))\n  (send nil :parse_new_attribute\n    (lvar :scanner))) first "," parse_new_attribute ","StringScanner  new ","line dup ","name nil? "," loop ","StringScanner  new  rest ","StringScanner  new  scan "," next_line dup  ","line dup  << << ","@next_line (or\n  (send\n    (const\n      (const nil :Haml) :Shared) :balance\n    (lvar :line)\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line))) first  ","@next_line dup  text ","line dup  << ","StringScanner  new  eos? ","last_line dup  - ","(or\n  (send\n    (const\n      (const nil :Haml) :Shared) :balance\n    (lvar :line)\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line))) first  inspect ","(or\n  (send\n    (const\n      (const nil :Haml) :Shared) :balance\n    (lvar :line dup )\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line dup ))) first ","(masgn\n  (mlhs\n    (lvasgn :name)\n    (lvasgn :value))\n  (send nil :parse_new_attribute\n    (lvar :StringScanner  new ))) first nil? ","(masgn\n  (mlhs\n    (lvasgn :name)\n    (lvasgn :value))\n  (send nil :parse_new_attribute\n    (lvar :StringScanner  new ))) first ","line dup  dup "]}," Haml Precompiler parse_old_attributes":{"type":"method","name":"parse_old_attributes","children":[],"call":["attributes_hash [] "," raise "," next_line ","line << << ","@next_line text ","line << ","e message == ","e message ","line strip [] == ","line strip [] ","line strip "," balance ","line dup ","attributes_hash []  [] "," next_line dup  ","line dup  << << ","@next_line dup  text ","line dup  << ","line dup  strip [] == ","line dup  strip [] ","line dup  strip ","line dup  dup "]}," Haml Precompiler close_script":{"type":"method","name":"close_script","children":[],"call":[" push_silent "]}," Haml Precompiler close_element":{"type":"method","name":"close_element","children":[],"call":[" push_merged_text ","nuke_inner_whitespace ! ","(str \"</\") + "," rstrip_buffer! "]}," Haml Precompiler Line tabs":{"type":"method","name":"tabs","children":[],"call":[" raise ","SyntaxError  new ","line index ","(str \"Inconsistent indentation: \") strip gsub ","(str \"Inconsistent indentation: \") strip ","Haml Shared  human_indentation ","whitespace =~ ","@indentation * "," flat? ","whitespace == ","whitespace length / ","@indentation length ","whitespace length ","@indentation include? ","@indentation nil? ","(lvasgn :whitespace\n  (send\n    (send\n      (lvar :line) :full) :[]\n    (regexp\n      (str \"^\\\\s+\")\n      (regopt)))) ! ","line full [] ","line full ","line text empty? ","line text "," precompiler instance_eval "," precompiler ","line full []  =~ ","line full []  == ","line full []  length / ","line full []  length ","(lvasgn :line full [] \n  (send\n    (send\n      (lvar :line) :full) :[]\n    (regexp\n      (str \"^\\\\s+\")\n      (regopt)))) ! "]}," Haml HTML Elem haml_tag_silent":{"type":"method","name":"haml_tag_silent","children":[],"call":["(send\n  (send\n    (lvar :text) :split\n    (str \"\\n\")) :map) join ","line strip ","text split map ","text split "]}," Haml HTML Elem haml_tag_loud":{"type":"method","name":"haml_tag_loud","children":[],"call":["text gsub strip ","text gsub "]}," Haml Buffer adjust_tabs":{"type":"method","name":"adjust_tabs","children":[],"call":[]}," Sass Tree ImportNode import":{"type":"method","name":"import","children":[],"call":["full_filename =~ "," raise ","SyntaxError  new "," line ","e message ","Sass Files  find_file_to_import "," import_paths ","Sass Files  find_file_to_import  =~ "]}," Sass Tree ImportNode import_paths":{"type":"method","name":"import_paths","children":[],"call":["paths unshift ","File  dirname ","@options [] ","(or\n  (send\n    (ivar :@options) :[]\n    (sym :load_paths))\n  (array)) dup ","(or\n  (send\n    (ivar :@options) :[]\n    (sym :load_paths))\n  (array)) dup  unshift ","(or\n  (send\n    (ivar :@options) :[]\n    (sym :load_(or\n  (send\n    (ivar :@options) :[]\n    (sym :load_paths))\n  (array)) dup ))\n  (array)) dup "]}," Sass Tree ImportNode perform!":{"type":"method","name":"perform!","children":[],"call":[" raise ","e add_backtrace_entry "," children= "," perform_children ","Sass Files  tree_for children ","Sass Files  tree_for "," import ","environment pop_frame ","e add_backtrace ","e modify_backtrace "," full_filename ","root children ","root template ","environment push_frame ","options delete ","@options dup ","  import  ","Sass Files  tree_for  children ","Sass Files  tree_for  template ","@options dup  delete ","@@options dup  dup "]}," Sass Tree ImportNode invisible?":{"type":"method","name":"invisible?","children":[],"call":[" to_s empty? "," to_s "]}," Sass Tree ImportNode to_s":{"type":"method","name":"to_s","children":[],"call":[" raise ","e add_backtrace_entry "," strip "," style == "," style "]}," Sass Tree ImportNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Script Parser assert_done":{"type":"method","name":"assert_done","children":[],"call":[" raise ","Sass SyntaxError  new ","@lexer peek type ","@lexer peek ","@lexer done? ","@lexer expected! ","EXPR_NAMES  [] "]}," Sass Script Parser defn_arglist":{"type":"method","name":"defn_arglist","children":[],"call":[" defn_arglist "," try_tok "," raise ","SyntaxError  new ","var inspect "," assert_expr ","Script Variable  new ","c value ","Script  equals_warning ","@options [] ","val to_sass ","val options= ","val context= ","tok type == ","tok type ","@lexer offset + ","@lexer offset ","@lexer line ","Script Variable  new  inspect ","var inspe try_tok t ","S try_tok ript Variable  new ","c  assert_expr ue "," try_tok  value ","S try_tok ript  equals_warning "," assert_expr  to_sass "," assert_expr  options= "," assert_expr  context= ","val  try_tok ontext= ","@lexer @lexer offset +  + ","@lexer @lexer offset +  ","@lexer @lexer line  "]}," Sass Script Parser parse_mixin_definition_arglist":{"type":"method","name":"parse_mixin_definition_arglist","children":[],"call":[" assert_done "," assert_tok "," defn_arglist "," try_tok "," raise ","e modify_backtrace ","@options [] ","@lexer line ","v options= ","k options= ","args each "," defn_arglist! "," defn_arglist!  each "]}," Sass Script Parser parse_mixin_include_arglist":{"type":"method","name":"parse_mixin_include_arglist","children":[],"call":[" assert_done "," assert_tok "," arglist "," try_tok "," raise ","e modify_backtrace ","@options [] ","@lexer line ","a options= ","args each "]}," Sass Engine check_for_no_children":{"type":"method","name":"check_for_no_children","children":[],"call":[" warn ","warning strip ","node rules join ","node rules ","node line ","node rules first inspect ","node rules first ","node rules size == ","node rules size ","node children empty? ","node children ","node is_a? ","node filename ","Haml Util  haml_warn ","(str \"WARNING on line \") strip "]}," Haml Util assert_html_safe!":{"type":"method","name":"assert_html_safe!","children":[],"call":[" raise ","Haml Error  new ","text inspect ","text to_s html_safe? ! ","text to_s html_safe? ","text to_s "," rails_xss_safe? "]}," Haml Util rails_xss_safe?":{"type":"method","name":"rails_xss_safe?","children":[],"call":[]}," Haml Template try_enabling_xss_integration":{"type":"method","name":"try_enabling_xss_integration","children":[{"type":"method","name":"rails_xss_safe?","children":[],"asgn":[],"call":[]},{"type":"method","name":"precompiled_method_return_value_with_haml_xss","children":[],"asgn":[],"call":[" precompiled_method_return_value_without_haml_xss "]}],"call":[" alias_method "," precompiled_method_return_value_without_haml_xss ","Haml Precompiler  module_eval ","Haml Helpers  send "," require ","Haml Util  module_eval ","Haml Template  options []= ","Haml Template  options ","ActionView Base  xss_safe? ","ActionView Base  respond_to? ","Haml Util  has? ","Haml Compiler  module_eval "]}," Haml Helpers XssMods haml_xss_html_escape":{"type":"method","name":"haml_xss_html_escape","children":[],"call":[" html_escape "," haml_buffer options [] "," haml_buffer options "," haml_buffer ","Haml Util  rails_xss_safe? "]}," Haml Helpers XssMods escape_once_with_haml_xss":{"type":"method","name":"escape_once_with_haml_xss","children":[],"call":[" escape_once_without_haml_xss html_safe! "," escape_once_without_haml_xss ","Haml Util  html_safe "]}," Haml Helpers XssMods haml_tag_with_haml_xss":{"type":"method","name":"haml_tag_with_haml_xss","children":[],"call":[" haml_tag_without_haml_xss "," with_raw_haml_concat ","rest unshift "," haml_xss_html_escape ","rest shift to_s ","rest shift ","rest first is_a? ","rest first ","(const nil :Symbol) any? ","name to_s "," haml_xss_html_escape  to_s "]}," Haml Helpers XssMods haml_indent_with_haml_xss":{"type":"method","name":"haml_indent_with_haml_xss","children":[],"call":[" haml_indent_without_haml_xss html_safe! "," haml_indent_without_haml_xss ","Haml Util  html_safe "]}," Haml Helpers XssMods haml_concat_with_haml_xss":{"type":"method","name":"haml_concat_with_haml_xss","children":[],"call":[" haml_concat_without_haml_xss "," haml_xss_html_escape "," instance_variable_defined? ","ErrorReturn  new "," haml_internal_concat "," haml_internal_concat_raw "]}," Haml Helpers XssMods capture_haml_with_haml_xss":{"type":"method","name":"capture_haml_with_haml_xss","children":[],"call":[" capture_haml_without_haml_xss html_safe! "," capture_haml_without_haml_xss ","Haml Util  html_safe "]}," Haml Helpers XssMods succeed_with_haml_xss":{"type":"method","name":"succeed_with_haml_xss","children":[],"call":[" succeed_without_haml_xss html_safe! "," succeed_without_haml_xss "," haml_xss_html_escape ","Haml Util  html_safe "]}," Haml Helpers XssMods precede_with_haml_xss":{"type":"method","name":"precede_with_haml_xss","children":[],"call":[" precede_without_haml_xss html_safe! "," precede_without_haml_xss "," haml_xss_html_escape ","Haml Util  html_safe "]}," Haml Helpers XssMods surround_with_haml_xss":{"type":"method","name":"surround_with_haml_xss","children":[],"call":[" surround_without_haml_xss html_safe! "," surround_without_haml_xss "," haml_xss_html_escape ","Haml Util  html_safe "]}," Haml Helpers XssMods list_of_with_haml_xss":{"type":"method","name":"list_of_with_haml_xss","children":[],"call":[" list_of_without_haml_xss html_safe! "," list_of_without_haml_xss ","Haml Util  html_safe "]}," Haml Helpers XssMods preserve_with_haml_xss":{"type":"method","name":"preserve_with_haml_xss","children":[],"call":[" preserve_without_haml_xss html_safe! "," preserve_without_haml_xss ","Haml Util  html_safe "]}," Haml Helpers XssMods find_and_preserve_with_haml_xss":{"type":"method","name":"find_and_preserve_with_haml_xss","children":[],"call":[" find_and_preserve_without_haml_xss html_safe! "," find_and_preserve_without_haml_xss ","Haml Util  html_safe "]}," Haml Helpers XssMods html_escape_with_haml_xss":{"type":"method","name":"html_escape_with_haml_xss","children":[],"call":[" html_escape_without_haml_xss html_safe! "," html_escape_without_haml_xss ","text html_safe? ","str html_safe? ","text to_s ","Haml Util  html_safe ","text to_s  html_safe? "]}," Haml Helpers XssMods included":{"type":"method","name":"included","children":[],"call":[]}," Haml Helpers ActionViewExtensions with_raw_haml_concat":{"type":"method","name":"with_raw_haml_concat","children":[],"call":[" instance_variable_defined? "]}," Tree PropNode pseudo_class_selector_message":{"type":"method","name":"pseudo_class_selector_message","children":[],"call":[" declaration "," declaration dump "," value empty? ! "," value empty? "," value ","@prop_syntax == "," value value empty? ! "," value value empty? "," value value "," value is_a? ! "," value is_a? "," resolved_value empty? ! "," resolved_value empty? "," resolved_value "]}," Haml Util rails_root":{"type":"method","name":"rails_root","children":[],"call":["RAILS_ROOT  to_s ","Rails  root to_s ","Rails  root "," raise "," Rails  root to_s "," Rails  root "]}," Sass Plugin check_for_updates":{"type":"method","name":"check_for_updates","children":[],"call":[" update_stylesheets ","Sass Plugin  options [] ","Sass Plugin  options ","Sass Plugin  checked_for_updates ! ","Sass Plugin  checked_for_updates "]}," Haml HTML Node attr_hash":{"type":"method","name":"attr_hash","children":[],"call":[" attributes to_hash "," attributes "]}," Script Functions EvaluationContext assert_type":{"type":"method","name":"assert_type","children":[],"call":[" raise ","ArgumentError  new ","type to_s downcase ","type to_s ","value inspect ","value is_a? ","Sass Script  const_get "]}," Script Color rgb":{"type":"method","name":"rgb","children":[],"call":["(send nil :red) freeze "," blue "," green "," red "]}," Script Color value":{"type":"method","name":"value","children":[],"call":[" rgb "," warn ","Haml Util  haml_warn "]}," Sass Plugin Rack disable_native_plugin!":{"type":"method","name":"disable_native_plugin!","children":[],"call":[]}," Sass Plugin Rack call":{"type":"method","name":"call","children":[],"call":["@app call ","Sass Plugin  check_for_updates "]}," Sass Plugin Rack initialize":{"type":"method","name":"initialize","children":[],"call":[" class disable_native_plugin! "," class "]}," Haml Util silence_warnings":{"type":"method","name":"silence_warnings","children":[],"call":["StringIO  new "]}," Script Color with":{"type":"method","name":"with","children":[],"call":["Color  new "," rgb [] "," rgb ","attrs [] "," alpha ","@attrs merge "," send ","(sym :red) each ","(sym :hue) each "," raise ","ArgumentError  new ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ! ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ","(sym :red) & ","attrs keys ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ! ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :attrs) :keys)) empty? ","(sym :hue) & ","v nil? ","attrs reject "," (send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :attrs) :keys)) empty? !  [] "," (send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :attrs) :keys)) empty? !  ","@attrs merge  [] ","@@attrs merge  merge ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ! ","(send\n  (array\n    (sym :red)\n    (sym :green)\n    (sym :blue)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ","@attrs merge  keys ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ! ","(send\n  (array\n    (sym :hue)\n    (sym :saturation)\n    (sym :lightness)) :&\n  (send\n    (lvar :@attrs merge ) :keys)) empty? ","@attrs merge  reject "]}," Haml Util av_template_class":{"type":"method","name":"av_template_class","children":[],"call":["ActionView Template  const_get ","name to_s ","ActionView  const_get ","ActionView  const_defined? ","ActionView Template  const_defined? "]}," Sass Engine try_comment":{"type":"method","name":"try_comment","children":[],"call":["last text << << ","last text << ","last text "," raise ","SyntaxError  new ","(str \"Inconsistent indentation:\\n\") strip gsub ","(str \"Inconsistent indentation:\\n\") strip ","Haml Shared  human_indentation ","line [] ","line =~ ","last comment? "]}," Haml Util rails_safe_buffer_class":{"type":"method","name":"rails_safe_buffer_class","children":[],"call":[]}," Haml Util html_safe":{"type":"method","name":"html_safe","children":[],"call":["text html_safe! ","text html_safe "]}," Haml Util rails_env":{"type":"method","name":"rails_env","children":[],"call":["RAILS_ENV  to_s ","Rails  env to_s ","Rails  env ","Rails  root "," Rails  env to_s "," Rails  env "]}," ActionView Helpers TextHelper safe_concat_with_haml":{"type":"method","name":"safe_concat_with_haml","children":[],"call":[" concat_without_haml "," haml_buffer buffer concat "," haml_buffer buffer "," haml_buffer "," is_haml? "," safe_concat_without_haml "]}," ActionView Helpers TextHelper safe_concat_with_haml_xss":{"type":"method","name":"safe_concat_with_haml_xss","children":[],"call":[" safe_concat_without_haml_xss "," haml_buffer buffer concat "," haml_buffer buffer "," haml_buffer "," is_haml? "]}," ActionView Helpers TextHelper concat_with_haml_xss":{"type":"method","name":"concat_with_haml_xss","children":[],"call":[" concat_without_haml_xss "," haml_buffer buffer concat "," haml_xss_html_escape "," haml_buffer buffer "," haml_buffer "," is_haml? "]}," ActionView Helpers FormTagHelper form_tag_with_haml_xss":{"type":"method","name":"form_tag_with_haml_xss","children":[],"call":["Haml Util  html_safe "," form_tag_without_haml_xss "," block_given? "]}," Haml Version revision_number":{"type":"method","name":"revision_number","children":[],"call":["ref == ","l strip split ","l strip ","f each ","File  open ","File  exists? ","File  read strip ","File  read "," scope ","rev =~ ","rev == ","File  read strip  =~ ","File  read strip  == "]}," Haml Util ap_geq_3?":{"type":"method","name":"ap_geq_3?","children":[],"call":["(and\n  (defined?\n    (const\n      (const\n        (const nil :ActionPack) :VERSION) :TINY))\n  (send\n    (const\n      (const\n        (const nil :ActionPack) :VERSION) :TINY) :==\n    (str \"0.beta\"))) ! ","ActionPack VERSION TINY  == ","version >= "," ap_geq? "]}," Haml Helpers with_tabs":{"type":"method","name":"with_tabs","children":[],"call":[" haml_buffer tabulation= "," haml_buffer "," haml_buffer tabulation "]}," ActionView Helpers FormHelper form_for_with_haml_xss":{"type":"method","name":"form_for_with_haml_xss","children":[],"call":["Haml Util  html_safe "," form_for_without_haml_xss ","res is_a? "," form_for_without_haml_xss  is_a? "]}," ActionView Helpers CaptureHelper with_output_buffer_with_haml_xss":{"type":"method","name":"with_output_buffer_with_haml_xss","children":[],"call":["Haml Util  html_safe "," with_output_buffer_without_haml_xss ","res map "," with_output_buffer_without_haml_xss  map "]}," Haml Buffer append_if_string=":{"type":"method","name":"append_if_string=","children":[],"call":[" buffer << "," buffer ","ActiveSupport Deprecation  warn "," caller ","value is_a? ! ","value is_a? "]}," Haml Precompiler push_silent_with_haml_block_deprecation":{"type":"method","name":"push_silent_with_haml_block_deprecation","children":[],"call":[" push_silent_without_haml_block_deprecation ","text =~ "," mid_block_keyword? ! "," mid_block_keyword? "," block_opened? "]}," ActionView Helpers InstanceTag content_tag":{"type":"method","name":"content_tag","children":[],"call":[" content_tag_with_haml "," error_wrapping "," object errors on "," object errors "," object "," object errors respond_to? "," object respond_to? "," method arity == "," method arity "," method "," respond_to? "]}," Haml Util ap_geq_3_beta_3?":{"type":"method","name":"ap_geq_3_beta_3?","children":[],"call":["1 to_i >= ","1 to_i ","ActionPack VERSION BUILD  =~ ","ActionPack VERSION TINY  >= ","ActionPack VERSION TINY  is_a? ","version >= "]}," Util rails_xss_safe?":{"type":"method","name":"rails_xss_safe?","children":[],"call":[]}," Tree WhileNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Tree WhileNode to_src":{"type":"method","name":"to_src","children":[],"call":["(begin\n  (send\n    (str \"  \") :*\n    (lvar :tabs))) + "," children_to_src ","@expr to_sass ","   * "]}," Sass Tree WarnNode _perform":{"type":"method","name":"_perform","children":[],"call":["environment pop_frame ","Haml Util  haml_warn ","msg << ","entry [] ","msg << << ","i == ","environment stack reverse each_with_index ","environment stack reverse ","environment stack ","res value ","res is_a? ","@expr perform ","environment push_frame "," line "," filename ","res value  value ","@expr perform  value ","res value  is_a? ","@expr perform  is_a? "]}," Sass Tree WarnNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi ","@expr to_sass ","   * "]}," Sass Tree WarnNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Tree VariableNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi ","@expr to_sass "," dasherize ","   * "]}," Tree RuleNode debug_info_rule":{"type":"method","name":"debug_info_rule","children":[],"call":["node options= ","@options merge ","node << ","rule << ","prop resolved_value= ","Sass SCSS RX  escape_ident ","v to_s ","prop resolved_name= ","PropNode  new ","rule resolved_rules= ","Sass Selector CommaSequence  new ","Sass Selector Sequence  new ","Sass Selector SimpleSequence  new ","Sass Selector Element  new ","k to_s gsub ","k to_s ","RuleNode  new ","(send\n  (send nil :debug_info) :map) sort each ","(send\n  (send nil :debug_info) :map) sort "," debug_info map "," debug_info ","DirectiveNode  new ","DirectiveNode  new  options= ","DirectiveNode  new  << ","RuleNode  new  << ","PropNode  new  resolved_value= ","PropNode  new  resolved_name= ","RuleNode  new  resolved_RuleNode  new s= "]}," Tree RuleNode debug_info":{"type":"method","name":"debug_info","children":[],"call":[" line ","file:// + ","URI  escape ","File  expand_path "," filename "]}," Tree RuleNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Tree RuleNode cssize!":{"type":"method","name":"cssize!","children":[],"call":[" resolved_rules= ","@parsed_rules resolve_parent_refs ","parent resolved_rules "," resolve_parent_refs "]}," Tree RuleNode _cssize":{"type":"method","name":"_cssize","children":[],"call":["rules last group_end= ","rules last ","rules empty? ","rules unshift ","r tabs ","rules each "," style == "," style ","node children= ","props empty? ","c invisible? ","c is_a? ","node children reject ","node children ","node children select "]}," Tree RuleNode _to_s":{"type":"method","name":"_to_s","children":[],"call":["to_return << "," group_end ","\n + "," style == "," style ","(send\n  (send nil :children) :map) join ","a to_s ","tabs + "," children map "," children "," filename ","Pathname  new relative_path_from to_s ","Pathname  new relative_path_from ","Pathname  new ","File  dirname ","@options [] "," line ","to_return << << "," debug_info_rule to_s "," debug_info_rule "," style != ","   * ","tabs - ","total_indent + ","(send\n  (send\n    (send\n      (block\n        (send\n          (send\n            (send nil :resolved_rules) :members) :map)\n        (args\n          (arg :seq))\n        (send\n          (send\n            (lvar :seq) :to_a) :join)) :join\n      (lvar :rule_separator)) :split\n    (str \"\\n\")) :map) join ","per_rule_indent + ","line strip ","(send\n  (send\n    (send nil :resolved_rules) :members) :map) join split map ","(send\n  (send\n    (send nil :resolved_rules) :members) :map) join split ","(send\n  (send\n    (send nil :resolved_rules) :members) :map) join ","seq to_a join ","seq to_a "," resolved_rules members map "," resolved_rules members "," resolved_rules ","(sym :nested) include? "," tabs ","(send\n  (send\n    (send\n      (send nil :resolved_rules) :join\n      (lvar :rule_separator)) :split\n    (str \"\\n\")) :map) join "," resolved_rules join split map "," resolved_rules join split "," resolved_rules join ","(send\n  (send\n    (send\n      (block\n        (send\n          (send\n            (send nil :resolved_rules) :members) :map)\n        (args\n          (arg :seq))\n        (send\n          (send\n            (send\n              (lvar :seq) :to_a) :join) :gsub\n          (regexp\n            (str \"([^,])\\\\n\")\n            (regopt :m))\n          (if\n            (send\n              (send nil :style) :==\n              (sym :compressed))\n            (str \"\\\\1 \")\n            (str \"\\\\1\\n\")))) :join\n      (lvar :rule_separator)) :split\n    (str \"\\n\")) :map) join ","seq to_a join gsub ","tabs +  + ","tabs +  - ","per_   *  + "," tabs +  "]}," Tree RuleNode do_extend":{"type":"method","name":"do_extend","children":[],"call":["node resolved_rules= "," resolved_rules do_extend "," resolved_rules "," dup "," dup  resolved_rules= "]}," Tree RuleNode to_scss":{"type":"method","name":"to_scss","children":[],"call":["res << << << ","res << << ","   * ","res << ","res slice! "," children last silent "," children last "," children "," children last is_a? ","name + "," children_to_src "," selector_to_scss "," rule ","(send\n  (send nil :rule) :map) join gsub ","(send\n  (send nil :rule) :map) join ","r to_sass ","r is_a? "," rule map ","name +  << << << ","name +  << << ","name +  << ","name +  slice! "," selector_to_scss  + ","(send\n  (send nil :rule) :map) join gsub  + "]}," Tree RuleNode to_sass":{"type":"method","name":"to_sass","children":[],"call":["name gsub + "," children_to_src ","name gsub ","   * ","\\ + ","name [] == ","name [] "," selector_to_sass "," rule ","(send\n  (send nil :rule) :map) join ","r to_sass ","1 + ","r gsub ","r is_a? "," rule map ","\\ +  gsub + "," selector_to_sass  gsub + ","(send\n  (send nil :rule) :map) join  gsub + ","\\ +  gsub "," selector_to_sass  gsub ","(send\n  (send nil :rule) :map) join  gsub ","\\ +  [] == "," selector_to_sass  [] == ","(send\n  (send nil :rule) :map) join  [] == ","\\ +  [] "," selector_to_sass  [] ","(send\n  (send nil :rule) :map) join  [] "]}," Sass Tree RootNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["Properties aren't allowed at the root of a document. + ","child pseudo_class_selector_message ","child is_a? "]}," Sass Tree RootNode _to_s":{"type":"method","name":"_to_s","children":[],"call":["result + ","result empty? ","result rstrip! ","result << ","child_str + "," style == "," style ","child to_s ","child invisible? "," children each "," children ","String  new ","(str \"@charset \\\"\") encode + ","(str \"@charset \\\"\") encode ","result encoding ","result encoding name ","result encode ","Encoding  find ","encoding << ","encoding =~ "," children first name "," children first "," children first is_a? ","result ascii_only? ","Haml Util  ruby1_8? ","String  new  + ","(str \"@charset \\\"\") encode +  + ","result encode  + ","String  new  empty? ","(str \"@charset \\\"\") encode +  empty? ","result encode  empty? ","String  new  rstrip! ","(str \"@charset \\\"\") encode +  rstrip! ","result encode  rstrip! ","String  new  << ","(str \"@charset \\\"\") encode +  << ","result encode  << ","child to_s  + ","String  new  encoding ","(str \"@charset \\\"\") encode +  encoding ","result encode  encoding ","result  children first name  ","String  new  encoding name ","(str \"@charset \\\"\") encode +  encoding name ","result encode  encoding name ","result  children first name  name ","String  new  encode ","(str \"@charset \\\"\") encode +  encode ","result encode  encode "," children first name  << "," children first name  =~ ","String  new  ascii_only? ","(str \"@charset \\\"\") encode +  ascii_only? ","result encode  ascii_only? "]}," Sass Tree RootNode to_src":{"type":"method","name":"to_src","children":[],"call":["(send\n  (send\n    (const\n      (const nil :Haml) :Util) :enum_cons\n    (send\n      (send nil :children) :+\n      (array\n        (nil)))\n    (int 2)) :map) join rstrip + ","(send\n  (send\n    (const\n      (const nil :Haml) :Util) :enum_cons\n    (send\n      (send nil :children) :+\n      (array\n        (nil)))\n    (int 2)) :map) join rstrip ","(send\n  (send\n    (const\n      (const nil :Haml) :Util) :enum_cons\n    (send\n      (send nil :children) :+\n      (array\n        (nil)))\n    (int 2)) :map) join ","child send + ","child line + == ","nxt line ","child line + ","child line ","nxt is_a? ","child is_a? ","child line + + == ","child line + + ","child value count ","child value ","child send ","Haml Util  enum_cons map ","Haml Util  enum_cons "," children + "," children "]}," Sass Tree RootNode to_scss":{"type":"method","name":"to_scss","children":[],"call":[" to_src "]}," Sass Tree RootNode to_sass":{"type":"method","name":"to_sass","children":[],"call":[" to_src "]}," Sass Tree RootNode perform!":{"type":"method","name":"perform!","children":[],"call":["environment options= ","environment options empty? ","environment options ","environment options nil? "]}," Sass Tree RootNode cssize":{"type":"method","name":"cssize","children":[],"call":[" raise ","e sass_template= ","e sass_template "]}," Sass Tree RootNode perform":{"type":"method","name":"perform","children":[],"call":[" raise ","e sass_template= ","environment options= ","environment options empty? ","environment options ","environment options nil? ","e sass_template "]}," Sass Tree RootNode render":{"type":"method","name":"render","children":[],"call":["result to_s ","result do_extend ","extends empty? "," perform cssize "," perform ","Environment  new ","result do_extend  to_s ","result do_extend  do_extend "]}," Sass Tree RootNode to_s":{"type":"method","name":"to_s","children":[],"call":[" raise ","e sass_template= ","e sass_template "]}," Sass Tree RootNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree PropNode val_to_sass_div":{"type":"method","name":"val_to_sass_div","children":[],"call":["Sass Script String  new ","node to_sass ","node operand2 original ! ","node operand2 original ","node operand2 ","node operand1 original ! ","node operand1 original ","node operand1 ","node context == ","node context ","node operand2 is_a? ","node operand1 is_a? ","node operator == ","node operator ","node is_a? "]}," Tree PropNode val_to_sass_concat":{"type":"method","name":"val_to_sass_concat","children":[],"call":["Sass Script Operation  new ","node operator "," val_to_sass_concat ","node operand2 "," val_to_sass_div ","node operand1 ","node operator == ","node is_a? "]}," Tree PropNode val_to_sass_comma":{"type":"method","name":"val_to_sass_comma","children":[],"call":["Sass Script Operation  new ","node operator "," val_to_sass_comma ","node operand2 "," val_to_sass_concat ","node operand1 ","node operator == ","node is_a? "]}," Tree PropNode val_to_sass":{"type":"method","name":"val_to_sass","children":[],"call":[" val_to_sass_comma to_sass "," val_to_sass_comma ","value to_sass ","value context == ","value context "]}," Tree PropNode check!":{"type":"method","name":"check!","children":[],"call":[" raise ","Sass SyntaxError  new ","(str \"Invalid property: \") + "," pseudo_class_selector_message "," declaration dump "," declaration "," resolved_value empty? "," resolved_value ","@prop_syntax == ","@options [] == ","@options [] "]}," Tree PropNode cssize!":{"type":"method","name":"cssize!","children":[],"call":[" tabs= ","parent tabs + ","parent resolved_value empty? ","parent resolved_value ","parent tabs "," style == "," style "," resolved_name= "," resolved_name ","parent resolved_name "]}," Tree PropNode _cssize":{"type":"method","name":"_cssize","children":[],"call":["result unshift ","node send ","node children empty? ","node children ","node resolved_value empty? ! ","node resolved_value empty? ","node resolved_value ","node children dup ","node children dup  unshift "]}," Tree PropNode _to_s":{"type":"method","name":"_to_s","children":[],"call":["   * + + + + + "," style == "," style ","   * + + + + "," resolved_value ","   * + + + ","   * + + ","   * + "," resolved_name ","   * ","tabs - + "," tabs ","tabs - "]}," Tree PropNode to_src":{"type":"method","name":"to_src","children":[],"call":["res + + + ","res + + "," semi ","res + "," children_to_src rstrip "," children_to_src "," children empty? "," children "," declaration ","res rstrip + ","res rstrip "," class val_to_sass "," value "," class ","   * ","fmt == ","opts [] ","(send\n  (send\n    (self) :name) :map) join ","n to_sass ","n is_a? "," name map "," name ","res rstrip + + + ","res rstrip + + "," raise ","Sass SyntaxError  new ","name [] == ","name [] "," declaration  + + + "," declaration  + + "," declaration  + "," declaration  rstrip + "," declaration  rstrip ","(send\n  (send\n    (self) :(send\n  (send\n    (self) :name) :map) join ) :map) join "," (send\n  (send\n    (self) :name) :map) join  map "," (send\n  (send\n    (self) :name) :map) join  "," declaration  rstrip + + + "," declaration  rstrip + + ","(send\n  (send\n    (self) :name) :map) join  [] == ","(send\n  (send\n    (self) :name) :map) join  [] "]}," Sass Tree Node semi":{"type":"method","name":"semi","children":[],"call":["fmt == "]}," Sass Tree Node dasherize":{"type":"method","name":"dasherize","children":[],"call":["s gsub ","opts [] "]}," Sass Tree Node selector_to_scss":{"type":"method","name":"selector_to_scss","children":[],"call":["(send\n  (lvar :sel) :map) join gsub ","   * ","(send\n  (lvar :sel) :map) join ","r to_sass ","r is_a? ","sel map "]}," Sass Tree Node selector_to_sass":{"type":"method","name":"selector_to_sass","children":[],"call":["(send\n  (lvar :sel) :map) join ","r to_sass ","1 + ","r gsub ","r is_a? ","sel map "]}," Sass Tree Node selector_to_src":{"type":"method","name":"selector_to_src","children":[],"call":[" selector_to_scss "," selector_to_sass ","fmt == "]}," Sass Tree Node children_to_src":{"type":"method","name":"children_to_src","children":[],"call":["(if\n  (send\n    (lvar :fmt) :==\n    (sym :sass))\n  (str \"\\n\")\n  (str \" {\\n\")) + + ","fmt == ","(if\n  (send\n    (lvar :fmt) :==\n    (sym :sass))\n  (str \"\\n\")\n  (str \" {\\n\")) + ","(send\n  (send nil :children) :map) join rstrip ","(send\n  (send nil :children) :map) join ","c send ","tabs + "," children map "," children "," children empty? "]}," Sass Tree Node to_src":{"type":"method","name":"to_src","children":[],"call":[" raise ","NotImplementedError  new "]}," Sass Tree Node run_interp":{"type":"method","name":"run_interp","children":[],"call":["(send\n  (lvar :text) :map) join strip ","(send\n  (lvar :text) :map) join ","val to_s ","val value ","val is_a? ","r perform ","r is_a? ","text map ","r perform  to_s ","r perform  r perform ue ","r perform  is_a? "]}," Sass Tree Node cssize!":{"type":"method","name":"cssize!","children":[],"call":[" children= ","(send\n  (send nil :children) :map) flatten ","c cssize "," children map "," children "]}," Sass Tree Node _cssize":{"type":"method","name":"_cssize","children":[],"call":["node cssize! "," dup "," dup  cssize! "]}," Sass Tree Node _to_s":{"type":"method","name":"_to_s","children":[],"call":[" raise ","NotImplementedError  new "]}," Sass Tree Node to_scss":{"type":"method","name":"to_scss","children":[],"call":[" to_src "]}," Sass Tree Node each":{"type":"method","name":"each","children":[],"call":["c each "," children each "," children "]}," Sass Tree Node cssize":{"type":"method","name":"cssize","children":[],"call":[" raise ","e modify_backtrace "," line "," filename "," _cssize ","parent class == "," class ","parent class "]}," Sass Tree Node do_extend":{"type":"method","name":"do_extend","children":[],"call":[" raise ","e modify_backtrace "," line "," filename ","node children= ","c do_extend "," children map "," children "," dup "," dup  children= "]}," Sass Tree Node check_child!":{"type":"method","name":"check_child!","children":[],"call":[" raise ","Sass SyntaxError  new ","child line "," invalid_child? "]}," Sass Tree Node children=":{"type":"method","name":"children=","children":[],"call":["children empty? ! ","children empty? "," has_children "]}," Tree MixinNode perform!":{"type":"method","name":"perform!","children":[],"call":["original_env pop_frame "," raise ","e add_backtrace ","e modify_backtrace "," children= ","(send\n  (send\n    (lvar :mixin) :tree) :map) flatten ","c perform ","mixin tree map ","mixin tree ","Sass SyntaxError  new ","var inspect ","env var ","var name ","env set_local_var ","Sass Script String  new ","val value ","val is_a? ","default context == ","default context ","default perform ","value perform ","mixin args zip inject ","Sass Environment  new ","mixin environment ","mixin args zip ","mixin args ","(str \"Mixin \") gsub ","@args size == ","@args size ","mixin args size != ","mixin args size ","mixin args size < ","environment mixin ","original_env prepare_frame ","original_env push_frame "," line "," filename "," handle_include_loop! ","environment mixins_in_use include? ","environment mixins_in_use ","(send\n  (send\n    (lvar :environment mixin ) :tree) :map) flatten ","environment mixin  tree map ","environment mixin  tree ","Sass Script String  new  Sass Script String  new ue ","default perform  default perform ue ","Sass Script String  new  is_a? ","default perform  is_a? ","Sass Script String  new ue perform ","default perform ue perform ","environment mixin  args zip inject ","environment mixin  environment ","environment mixin  args zip ","environment mixin  args ","environment mixin  args size != ","environment mixin  args size ","environment mixin  args size < ","environment environment mixin  ","environment environment mixin s_in_use include? ","environment environment mixin s_in_use "]}," Tree MixinNode _cssize":{"type":"method","name":"_cssize","children":[],"call":[" raise ","e add_backtrace "," line "," filename ","e modify_backtrace ","(send\n  (send nil :children) :map) flatten ","c cssize ","parent check_child! "," children map "," children "]}," Tree MixinNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi "," dasherize ","fmt == ","   * ","( + + ","( + ","(send\n  (ivar :@args) :map) join ","a to_sass ","@args map ","@args empty? ","(send\n  (ivar :@( + + ) :map) join ","@( + +  map ","@( + +  empty? "]}," Tree MixinNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Tree MixinNode cssize":{"type":"method","name":"cssize","children":[],"call":[" _cssize "]}," Tree MixinNode options=":{"type":"method","name":"options=","children":[],"call":["a context= ","@args each ","opts [] "]}," Sass Tree MixinDefNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Sass Tree MixinDefNode to_src":{"type":"method","name":"to_src","children":[],"call":["(begin\n  (send\n    (str \"  \") :*\n    (lvar :tabs))) + "," children_to_src "," dasherize ","fmt == ","   * ","( + + ","( + ","(send\n  (ivar :@args) :map) join ","v to_sass ","d to_sass ","@args map ","@args empty? ","(send\n  (ivar :@( + + ) :map) join ","@( + +  map ","@( + +  empty? "]}," Sass Tree ImportNode _perform":{"type":"method","name":"_perform","children":[],"call":["DirectiveNode  new "," full_filename "," full_filename =~ "]}," Sass Tree ImportNode _cssize":{"type":"method","name":"_cssize","children":[],"call":[" raise ","e add_backtrace ","e modify_backtrace "," children first filename "," children first "," children "]}," Sass Tree ImportNode cssize":{"type":"method","name":"cssize","children":[],"call":[" first "]}," Sass Tree ImportNode to_scss":{"type":"method","name":"to_scss","children":[],"call":["   * "]}," Sass Tree ImportNode to_sass":{"type":"method","name":"to_sass","children":[],"call":["   * "]}," Sass Tree ImportNode full_filename":{"type":"method","name":"full_filename","children":[],"call":[" import "]}," Tree IfNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Tree IfNode to_src":{"type":"method","name":"to_src","children":[],"call":["str << ","@else send "," children_to_src ","@expr to_sass ","   * ","is_else ! "]}," Tree ForNode invalid_child?":{"type":"method","name":"invalid_child?","children":[],"call":["child is_a? "]}," Tree ForNode to_src":{"type":"method","name":"to_src","children":[],"call":["(begin\n  (send\n    (str \"  \") :*\n    (lvar :tabs))) + "," children_to_src ","@to to_sass ","@from to_sass "," dasherize ","   * "]}," Tree ExtendNode perform!":{"type":"method","name":"perform!","children":[],"call":["Sass SCSS CssParser  new parse_selector "," filename ","Sass SCSS CssParser  new "," line "," run_interp "]}," Tree ExtendNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi "," selector_to_src lstrip "," selector_to_src ","   * "]}," Tree ExtendNode cssize":{"type":"method","name":"cssize","children":[],"call":["extends []= "," raise ","Sass SyntaxError  new ","seq members last is_a? ! ","seq members last is_a? ","seq members last ","seq members ","parent resolved_rules members each ","parent resolved_rules members ","parent resolved_rules ","sseq members ","seq to_a join ","seq to_a ","sseq is_a? ! ","sseq is_a? ","seq members first ","seq members size > ","seq members size ","@resolved_selector members each ","@resolved_selector members ","seq members first  members ","seq members first  is_a? ! ","seq members first  is_a? ","@resolved_sseq members ector members each ","@resolved_sseq members ector members "]}," Tree ExtendNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Tree DirectiveNode _to_s":{"type":"method","name":"_to_s","children":[],"call":["result rstrip + ","(if\n  (send\n    (send nil :style) :==\n    (sym :expanded))\n  (str \"\\n\")\n  (str \" \")) + "," style == "," style ","result rstrip ","result << ","child to_s + ","child to_s ","tabs + ","child is_a? ","rendered rstrip + ","rendered rstrip ","rendered lstrip ","child to_s dup ","result []= ","child invisible? "," children each "," children ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) + "," value ","   * ","tabs - "," value + "," children empty? "," has_children ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  rstrip + ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  rstrip ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  << ","rendered lstrip  rstrip + ","child to_s dup  rstrip + ","rendered lstrip  rstrip ","child to_s dup  rstrip ","rendered lstrip  lstrip ","child to_s dup  lstrip ","(begin\n  (send\n    (str \"  \") :*\n    (begin\n      (send\n        (lvar :tabs) :-\n        (int 1))))) +  []= "]}," Tree DirectiveNode to_src":{"type":"method","name":"to_src","children":[],"call":["res + + ","res + "," children_to_src "," semi "," has_children "," value ","   * "," children empty? "," children "]}," Sass Tree DebugNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi ","@expr to_sass ","   * "]}," Tree CommentNode normalize_indentation":{"type":"method","name":"normalize_indentation","children":[],"call":["str gsub ","(send\n  (send\n    (lvar :str) :split\n    (str \"\\n\")) :inject\n  (send\n    (send\n      (lvar :str) :[]\n      (regexp\n        (str \"^[ \\\\t]*\")\n        (regopt))) :split\n    (str \"\"))) join ","arr + ","a != ","line [] split zip inject ","line [] split zip ","line [] split ","line [] ","str split inject ","str [] split ","str [] ","str split "]}," Tree CommentNode _to_s":{"type":"method","name":"_to_s","children":[],"call":["content gsub! "," style == "," style "," value gsub "," value ","   * ","(send\n  (send\n    (lvar :tabs) :-\n    (int 1)) :-\n  (send\n    (send\n      (send nil :value) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","tabs - - "," value [] size "," value [] ","tabs - "," invisible? "," value gsub  gsub! "]}," Tree CommentNode to_scss":{"type":"method","name":"to_scss","children":[],"call":["(send nil :silent) gsub + ","(send nil :silent) gsub "," value "," value gsub gsub "," value gsub "," silent ","   * ","(send\n  (lvar :tabs) :-\n  (send\n    (send\n      (send nil :value) :[]\n      (regexp\n        (str \"^ *\")\n        (regopt))) :size)) max ","tabs - "," value [] size "," value [] "]}," Tree CommentNode to_sass":{"type":"method","name":"to_sass","children":[],"call":["content rstrip + ","content rstrip ","content gsub! ","   * "," silent ","content gsub ","  * ","spaces >= ","(send\n  (send\n    (lvar :content) :scan\n    (regexp\n      (str \"\\\\n( *)\")\n      (regopt))) :map) min ","s first size ","s first ","content scan map ","content scan ","content include? ","content sub! ","content =~ "," value gsub rstrip "," value gsub "," value "," value gsub rstrip  rstrip + "," value gsub rstrip  rstrip "," value gsub rstrip  gsub! "," value gsub rstrip  gsub ","(send\n  (send\n    (lvar :content) :scan\n    (regexp\n      (str \"\\n( *)\")\n      (regopt))) :map) min  >= ","(send\n  (send\n    (lvar : value gsub rstrip ) :scan\n    (regexp\n      (str \"\\\\n( *)\")\n      (regopt))) :map) min "," value gsub rstrip  scan map "," value gsub rstrip  scan "," value gsub rstrip  include? "," value gsub rstrip  sub! "," value gsub rstrip  =~ "]}," Sass Selector Negation to_a":{"type":"method","name":"to_a","children":[],"call":["(str \":not(\") + + ","(str \":not(\") + ","@selector to_a "]}," Sass Selector Negation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Pseudo unify":{"type":"method","name":"unify","children":[],"call":["sel arg != "," arg ","sel arg ","sel name != "," name ","sel name ","sel type == ","sel type ","sel is_a? ","sels any? "," type == "," type "]}," Sass Selector Pseudo to_a":{"type":"method","name":"to_a","children":[],"call":["(send\n  (lvar :res) :<<\n  (str \"(\")) concat << ","(send\n  (lvar :res) :<<\n  (str \"(\")) concat ","Haml Util  strip_string_array ","res << ","(if\n  (send\n    (ivar :@type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) + ","@type == ","(send\n  (lvar :(if\n  (send\n    (ivar :@type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) + ) :<<\n  (str \"(\")) concat << ","(send\n  (lvar :(if\n  (send\n    (ivar :@type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) + ) :<<\n  (str \"(\")) concat ","(if\n  (send\n    (ivar :@type) :==\n    (sym :class))\n  (str \":\")\n  (str \"::\")) +  << "]}," Sass Selector Pseudo initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Attribute to_a":{"type":"method","name":"to_a","children":[],"call":["res << ","(send\n  (lvar :res) :<<\n  (ivar :@operator)) concat ","res concat ","res concat << "]}," Sass Selector Attribute initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Interpolation unify":{"type":"method","name":"unify","children":[],"call":[" raise ","Sass SyntaxError  new "]}," Sass Selector Interpolation to_a":{"type":"method","name":"to_a","children":[],"call":[]}," Sass Selector Interpolation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Element unify":{"type":"method","name":"unify","children":[],"call":["(send\n  (const nil :Element) :new\n  (send nil :name)\n  (lvar :ns)) + ","sels [] ","Element  new "," name "," unify_namespaces ","sels first namespace ","sels first "," namespace ","(self) + "," name == ","sels first name "]}," Sass Selector Element to_a":{"type":"method","name":"to_a","children":[],"call":["@namespace + + ","@namespace + "]}," Sass Selector Element initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Universal unify":{"type":"method","name":"unify","children":[],"call":["(if\n  (send\n    (lvar :name) :==\n    (sym :universal))\n  (send\n    (const nil :Universal) :new\n    (lvar :ns))\n  (send\n    (const nil :Element) :new\n    (lvar :name)\n    (lvar :ns))) + ","sels [] ","Element  new ","Universal  new ","name == "," unify_namespaces ","sels first namespace ","sels first "," namespace ","sels empty? ","(self) + "," namespace == "," namespace nil? ","sels first name "]}," Sass Selector Universal to_a":{"type":"method","name":"to_a","children":[],"call":["@namespace + "]}," Sass Selector Universal initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Id unify":{"type":"method","name":"unify","children":[],"call":[" name != ","sel2 name "," name ","sel2 is_a? ","sels any? "]}," Sass Selector Id to_a":{"type":"method","name":"to_a","children":[],"call":[]}," Sass Selector Id initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Class to_a":{"type":"method","name":"to_a","children":[],"call":[]}," Sass Selector Class initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Parent unify":{"type":"method","name":"unify","children":[],"call":[" raise ","Sass SyntaxError  new "]}," Sass Selector Parent to_a":{"type":"method","name":"to_a","children":[],"call":[]}," Sass Selector SimpleSequence _eql?":{"type":"method","name":"_eql?","children":[],"call":["Haml Util  set_eql? "," rest ","other rest ","other base eql? "," base ","other base "]}," Sass Selector SimpleSequence _hash":{"type":"method","name":"_hash","children":[],"call":["(send nil :base) hash ","Haml Util  set_hash "," rest "," base "]}," Sass Selector SimpleSequence inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :members) :map) join ","m inspect "," members map "," members "]}," Sass Selector SimpleSequence to_a":{"type":"method","name":"to_a","children":[],"call":["(send\n  (ivar :@members) :map) flatten ","sel to_a ","@members map "]}," Sass Selector SimpleSequence superselector?":{"type":"method","name":"superselector?","children":[],"call":[" rest subset? ","sseq rest "," rest "," base eql? ","sseq base "," base "," base nil? "]}," Sass Selector SimpleSequence unify":{"type":"method","name":"unify","children":[],"call":["SimpleSequence  new ","sel unify "," members inject "," members "]}," Sass Selector SimpleSequence do_extend":{"type":"method","name":"do_extend","children":[],"call":["(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","seq do_extend ","seen + ","seen include? ","Sequence  new ","(send\n  (send\n    (lvar :extends) :get\n    (send\n      (send nil :members) :to_set)) :map) compact map ","(send\n  (send\n    (lvar :extends) :get\n    (send\n      (send nil :members) :to_set)) :map) compact ","seq members [] + ","seq members [] ","seq members ","seq members last unify ","seq members last "," members - "," members ","extends get map ","extends get "," members to_set "," handle_extend_loop ","(send\n  (lvar :seqs) :map) concat ","(send\n  (lvar :seqs) :map) flatten uniq ","(send\n  (lvar :seqs) :map) flatten ","supers shift ","seq do_extend [] ","supers unshift ","seqs map ","(send\n  (block\n    (send\n      (send\n        (block\n          (send\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)) :map)\n          (args\n            (arg :seq)\n            (arg :sels))\n          (begin\n            (lvasgn :self_without_sel\n              (send\n                (send\n                  (self) :members) :-\n                (lvar :sels)))\n            (if\n              (lvasgn :unified\n                (send\n                  (send\n                    (send\n                      (lvar :seq) :members) :last) :unify\n                  (lvar :self_without_sel))) nil\n              (next))\n            (array\n              (lvar :sels)\n              (send\n                (send\n                  (send\n                    (lvar :seq) :members) :[]\n                  (erange\n                    (int 0)\n                    (int -1))) :+\n                (array\n                  (lvar :unified)))))) :compact) :map)\n    (args\n      (arg :sels)\n      (arg :seq))\n    (array\n      (lvar :sels)\n      (send\n        (const nil :Sequence) :new\n        (lvar :seq)))) :map) flatten uniq ","(send\n  (block\n    (send\n      (send\n        (block\n          (send\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)) :map)\n          (args\n            (arg :seq)\n            (arg :sels))\n          (begin\n            (lvasgn :self_without_sel\n              (send\n                (send\n                  (self) :members) :-\n                (lvar :sels)))\n            (if\n              (lvasgn :unified\n                (send\n                  (send\n                    (send\n                      (lvar :seq) :members) :last) :unify\n                  (lvar :self_without_sel))) nil\n              (next))\n            (array\n              (lvar :sels)\n              (send\n                (send\n                  (send\n                    (lvar :seq) :members) :[]\n                  (erange\n                    (int 0)\n                    (int -1))) :+\n                (array\n                  (lvar :unified)))))) :compact) :map)\n    (args\n      (arg :sels)\n      (arg :seq))\n    (array\n      (lvar :sels)\n      (send\n        (const nil :Sequence) :new\n        (lvar :seq)))) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) map ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :Sequence  new ) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :seq members last unify )))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten uniq ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :Sequence  new ) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :seq members last unify )))))) :compact) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) flatten ","Sequence  new  do_extend ","Sequence  new  members [] + ","Sequence  new  members [] ","Sequence  new  members ","Sequence  new  members last unify ","Sequence  new  members last ","(send\n  (lvar :Sequence  new s) :map) concat ","(send\n  (lvar :seq do_extend ) :map) concat ","(send\n  (lvar :Sequence  new s) :map) flatten uniq ","(send\n  (lvar :seq do_extend ) :map) flatten uniq ","(send\n  (lvar :Sequence  new s) :map) flatten ","(send\n  (lvar :seq do_extend ) :map) flatten ","Sequence  new  do_extend [] ","Sequence  new s map ","seq do_extend  map ","(send\n  (block\n    (send\n      (send\n        (block\n          (send\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)) :map)\n          (args\n            (arg :Sequence  new )\n            (arg :sels))\n          (begin\n            (lvasgn :self_without_sel\n              (send\n                (send\n                  (self) :members) :-\n                (lvar :sels)))\n            (if\n              (lvasgn :unified\n                (send\n                  (send\n                    (send\n                      (lvar :Sequence  new ) :members) :last) :unify\n                  (lvar :self_without_sel))) nil\n              (next))\n            (array\n              (lvar :sels)\n              (send\n                (send\n                  (send\n                    (lvar :Sequence  new ) :members) :[]\n                  (erange\n                    (int 0)\n                    (int -1))) :+\n                (array\n                  (lvar :unified)))))) :compact) :map)\n    (args\n      (arg :sels)\n      (arg :Sequence  new ))\n    (array\n      (lvar :sels)\n      (send\n        (const nil :Sequence) :new\n        (lvar :Sequence  new )))) :map) flatten uniq ","(send\n  (block\n    (send\n      (send\n        (block\n          (send\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)) :map)\n          (args\n            (arg :seq)\n            (arg :sels))\n          (begin\n            (lvasgn :self_without_sel\n              (send\n                (send\n                  (self) :members) :-\n                (lvar :sels)))\n            (if\n              (lvasgn :seq members last unify \n                (send\n                  (send\n                    (send\n                      (lvar :seq) :members) :last) :unify\n                  (lvar :self_without_sel))) nil\n              (next))\n            (array\n              (lvar :sels)\n              (send\n                (send\n                  (send\n                    (lvar :seq) :members) :[]\n                  (erange\n                    (int 0)\n                    (int -1))) :+\n                (array\n                  (lvar :seq members last unify )))))) :compact) :map)\n    (args\n      (arg :sels)\n      (arg :seq))\n    (array\n      (lvar :sels)\n      (send\n        (const nil :Sequence) :new\n        (lvar :seq)))) :map) flatten uniq ","(send\n  (block\n    (send\n      (send\n        (block\n          (send\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)) :map)\n          (args\n            (arg :seq)\n            (arg :sels))\n          (begin\n            (lvasgn : members - \n              (send\n                (send\n                  (self) :members) :-\n                (lvar :sels)))\n            (if\n              (lvasgn :unified\n                (send\n                  (send\n                    (send\n                      (lvar :seq) :members) :last) :unify\n                  (lvar : members - ))) nil\n              (next))\n            (array\n              (lvar :sels)\n              (send\n                (send\n                  (send\n                    (lvar :seq) :members) :[]\n                  (erange\n                    (int 0)\n                    (int -1))) :+\n                (array\n                  (lvar :unified)))))) :compact) :map)\n    (args\n      (arg :sels)\n      (arg :seq))\n    (array\n      (lvar :sels)\n      (send\n        (const nil :Sequence) :new\n        (lvar :seq)))) :map) flatten uniq ","(send\n  (block\n    (send\n      (send\n        (block\n          (send\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)) :map)\n          (args\n            (arg :Sequence  new )\n            (arg :sels))\n          (begin\n            (lvasgn :self_without_sel\n              (send\n                (send\n                  (self) :members) :-\n                (lvar :sels)))\n            (if\n              (lvasgn :unified\n                (send\n                  (send\n                    (send\n                      (lvar :Sequence  new ) :members) :last) :unify\n                  (lvar :self_without_sel))) nil\n              (next))\n            (array\n              (lvar :sels)\n              (send\n                (send\n                  (send\n                    (lvar :Sequence  new ) :members) :[]\n                  (erange\n                    (int 0)\n                    (int -1))) :+\n                (array\n                  (lvar :unified)))))) :compact) :map)\n    (args\n      (arg :sels)\n      (arg :Sequence  new ))\n    (array\n      (lvar :sels)\n      (send\n        (const nil :Sequence) :new\n        (lvar :Sequence  new )))) :map) flatten ","(send\n  (block\n    (send\n      (send\n        (block\n          (send\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)) :map)\n          (args\n            (arg :seq)\n            (arg :sels))\n          (begin\n            (lvasgn :self_without_sel\n              (send\n                (send\n                  (self) :members) :-\n                (lvar :sels)))\n            (if\n              (lvasgn :seq members last unify \n                (send\n                  (send\n                    (send\n                      (lvar :seq) :members) :last) :unify\n                  (lvar :self_without_sel))) nil\n              (next))\n            (array\n              (lvar :sels)\n              (send\n                (send\n                  (send\n                    (lvar :seq) :members) :[]\n                  (erange\n                    (int 0)\n                    (int -1))) :+\n                (array\n                  (lvar :seq members last unify )))))) :compact) :map)\n    (args\n      (arg :sels)\n      (arg :seq))\n    (array\n      (lvar :sels)\n      (send\n        (const nil :Sequence) :new\n        (lvar :seq)))) :map) flatten ","(send\n  (block\n    (send\n      (send\n        (block\n          (send\n            (send\n              (lvar :extends) :get\n              (send\n                (send nil :members) :to_set)) :map)\n          (args\n            (arg :seq)\n            (arg :sels))\n          (begin\n            (lvasgn : members - \n              (send\n                (send\n                  (self) :members) :-\n                (lvar :sels)))\n            (if\n              (lvasgn :unified\n                (send\n                  (send\n                    (send\n                      (lvar :seq) :members) :last) :unify\n                  (lvar : members - ))) nil\n              (next))\n            (array\n              (lvar :sels)\n              (send\n                (send\n                  (send\n                    (lvar :seq) :members) :[]\n                  (erange\n                    (int 0)\n                    (int -1))) :+\n                (array\n                  (lvar :unified)))))) :compact) :map)\n    (args\n      (arg :sels)\n      (arg :seq))\n    (array\n      (lvar :sels)\n      (send\n        (const nil :Sequence) :new\n        (lvar :seq)))) :map) flatten ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :Sequence  new )\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :Sequence  new ) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :Sequence  new ) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) map ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn :self_without_sel\n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :seq members last unify \n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar :self_without_sel))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :seq members last unify )))))) :compact) :map) map ","(send\n  (send\n    (block\n      (send\n        (send\n          (lvar :extends) :get\n          (send\n            (send nil :members) :to_set)) :map)\n      (args\n        (arg :seq)\n        (arg :sels))\n      (begin\n        (lvasgn : members - \n          (send\n            (send\n              (self) :members) :-\n            (lvar :sels)))\n        (if\n          (lvasgn :unified\n            (send\n              (send\n                (send\n                  (lvar :seq) :members) :last) :unify\n              (lvar : members - ))) nil\n          (next))\n        (array\n          (lvar :sels)\n          (send\n            (send\n              (send\n                (lvar :seq) :members) :[]\n              (erange\n                (int 0)\n                (int -1))) :+\n            (array\n              (lvar :unified)))))) :compact) :map) map "]}," Sass Selector SimpleSequence resolve_parent_refs":{"type":"method","name":"resolve_parent_refs","children":[],"call":["super_seq members [] + ","SimpleSequence  new ","super_seq members last members + ","@members [] ","super_seq members last members ","super_seq members last ","super_seq members ","super_seq members [] "," raise ","Sass SyntaxError  new ","Invalid parent selector:  + ","super_seq to_a join ","super_seq to_a ","super_seq members last is_a? ","@members size == ","@members size ","@members first is_a? ","@members first "]}," Sass Selector SimpleSequence initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector SimpleSequence rest":{"type":"method","name":"rest","children":[],"call":["Set  new "," members "," members [] "," base "]}," Sass Selector SimpleSequence base":{"type":"method","name":"base","children":[],"call":[" members first "," members "," members first is_a? "]}," Sass Selector Simple unify_namespaces":{"type":"method","name":"unify_namespaces","children":[],"call":["ns2 == ","ns1 == ","ns2 nil? ","ns1 nil? "]}," Sass Selector Simple unify":{"type":"method","name":"unify","children":[],"call":["sels [] + + ","sels [] ","sels [] + ","sels + ","sel is_a? ","sels_with_ix find ","sels last type == ","sels last type ","sels last "," is_a? ","Haml Util  enum_with_index "," eql? ","sels any? ","sels last is_a? ","Haml Util  enum_with_index  find "]}," Sass Selector Simple eql?":{"type":"method","name":"eql?","children":[],"call":["other to_a eql? "," to_a ","other to_a ","other hash == "," hash ","other hash ","other class == "," class ","other class "]}," Sass Selector Simple hash":{"type":"method","name":"hash","children":[],"call":[" to_a hash "," to_a "]}," Sass Selector Simple inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :to_a) :map) join ","e to_sass ","e is_a? "," to_a map "," to_a "]}," Sass Selector Simple to_a":{"type":"method","name":"to_a","children":[],"call":[" raise ","NotImplementedError  new "]}," Sass Selector Sequence _eql?":{"type":"method","name":"_eql?","children":[],"call":["(send\n  (send\n    (lvar :other) :members) :reject) eql? ","m == "," members reject "," members ","other members reject ","other members "]}," Sass Selector Sequence _hash":{"type":"method","name":"_hash","children":[],"call":["(send\n  (send nil :members) :reject) hash ","m == "," members reject "," members "]}," Sass Selector Sequence subweave_superselector?":{"type":"method","name":"subweave_superselector?","children":[],"call":["sseq1 first superselector? ","sseq2 first ","sseq1 first "," subweave_superselector? ","sseq2 [] ","sseq2 size == ","sseq2 size ","sseq2 [] == ","sseq2 size > ","sseq1 [] ","sseq1 size == ","sseq1 size ","sseq2 [] != ","sseq1 [] == ","sseq1 size > "]}," Sass Selector Sequence group_selectors":{"type":"method","name":"group_selectors","children":[],"call":["newseq << ","head << ","tail shift ","tail first is_a? ","tail first ","head last is_a? ","head last ","tail empty? ! ","tail empty? ","seq dup ","seq dup  shift ","seq dup  first is_a? ","seq dup  first ","seq dup  empty? ! ","seq dup  empty? "]}," Sass Selector Sequence chunks":{"type":"method","name":"chunks","children":[],"call":["chunk2 + ","chunk1 + ","chunk2 empty? ","chunk1 empty? ","chunk2 << ","seq2 shift ","chunk1 << ","seq1 shift "]}," Sass Selector Sequence subweave":{"type":"method","name":"subweave","children":[],"call":["p flatten ","Haml Util  paths map ","Haml Util  paths ","c empty? ","diff reject! ","diff << ","s empty? "," chunks ","seq2 shift ","seq1 shift ","diff << << ","lcs shift "," subweave_superselector? ","lcs first ","s first ","lcs empty? ","s2 first is_a? ","s2 first ","s1 first is_a? ","s1 first ","s1 == ","Haml Util  lcs "," group_selectors ","seq2 empty? ","seq1 empty? ","res << ","sseq2 + "," subweave each "," subweave ","unified + ","sseq1 + "," unify_heads "," subweave map ","sseq1 eql? "," seq_split ","cache [] "," group_selectors  shift "," group_selectors  empty? ","s group_selectors  + ","s group_selectors  eql? "]}," Sass Selector Sequence weave":{"type":"method","name":"weave","children":[],"call":["afters empty? ","Haml Util  flatten ","seqs + "," subweave map "," subweave ","befores map ","last_current unshift ","current pop ","current last is_a? ","current last ","last_current first is_a? ","last_current first ","current empty? ! ","current empty? ","afters shift dup ","afters shift ","path dup ","(send\n  (lvar :befores) :map) flatten ","path dup  empty? ","Haml Util  flatten  map ","(send\n  (lvar :befores) :map) flatten  map ","last_afters shift dup  unshift ","afters shift dup  pop ","afters shift dup  last is_a? ","afters shift dup  last ","last_afters shift dup  first is_a? ","last_afters shift dup  first ","afters shift dup  empty? ! ","afters shift dup  empty? ","path dup  shift dup ","path dup  shift ","(send\n  (lvar :Haml Util  flatten ) :map) flatten ","(send\n  (lvar :(send\n  (lvar :befores) :map) flatten ) :map) flatten "]}," Sass Selector Sequence inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :members) :map) join ","m inspect "," members map "," members "]}," Sass Selector Sequence to_a":{"type":"method","name":"to_a","children":[],"call":["ary flatten compact ","ary flatten ","Haml Util  substitute ","Haml Util  intersperse ","seq_or_op to_a ","seq_or_op is_a? ","@members map ","Haml Util  substitute  flatten compact ","Haml Util  intersperse  flatten compact ","Haml Util  substitute  flatten ","Haml Util  intersperse  flatten "]}," Sass Selector Sequence superselector?":{"type":"method","name":"superselector?","children":[],"call":[" members last superselector? "," members last "," members "," members size == "," members size "]}," Sass Selector Sequence do_extend":{"type":"method","name":"do_extend","children":[],"call":["Sequence  new ","Haml Util  flatten map ","Haml Util  flatten "," weave ","paths map ","Haml Util  paths ","choices unshift ","seq superselector? ","extended any? ","seq members ","extended map ","sseq_or_op do_extend ","sseq_or_op is_a? "," members map "," members ","(send\n  (send\n    (const\n      (const nil :Haml) :Util) :paths\n    (block\n      (send\n        (send nil :members) :map)\n      (args\n        (arg :sseq_or_op))\n      (begin\n        (if\n          (send\n            (lvar :sseq_or_op) :is_a?\n            (const nil :SimpleSequence)) nil\n          (next\n            (array\n              (array\n                (lvar :sseq_or_op)))))\n        (array\n          (array\n            (lvar :sseq_or_op))\n          (splat\n            (block\n              (send\n                (send\n                  (lvar :sseq_or_op) :do_extend\n                  (lvar :extends)\n                  (lvar :supers)) :map)\n              (args\n                (arg :seq))\n              (send\n                (lvar :seq) :members))))))) :map) flatten map ","(send\n  (send\n    (const\n      (const nil :Haml) :Util) :paths\n    (block\n      (send\n        (send nil :members) :map)\n      (args\n        (arg :sseq_or_op))\n      (begin\n        (if\n          (send\n            (lvar :sseq_or_op) :is_a?\n            (const nil :SimpleSequence)) nil\n          (next\n            (array\n              (array\n                (lvar :sseq_or_op)))))\n        (array\n          (array\n            (lvar :sseq_or_op))\n          (splat\n            (block\n              (send\n                (send\n                  (lvar :sseq_or_op) :do_extend\n                  (lvar :extends)\n                  (lvar :supers)) :map)\n              (args\n                (arg :seq))\n              (send\n                (lvar :seq) :members))))))) :map) flatten ","Haml Util  paths map ","sseq_or_op do_extend map ","Haml Util  paths  map ","Haml Util  Haml Util  paths  ","sseq_or_op do_extend  any? ","sseq_or_op do_extend  map ","(send\n  (send\n    (const\n      (const nil :Haml) :Util) :Haml Util  paths \n    (block\n      (send\n        (send nil :members) :map)\n      (args\n        (arg :sseq_or_op))\n      (begin\n        (if\n          (send\n            (lvar :sseq_or_op) :is_a?\n            (const nil :SimpleSequence)) nil\n          (next\n            (array\n              (array\n                (lvar :sseq_or_op)))))\n        (array\n          (array\n            (lvar :sseq_or_op))\n          (splat\n            (block\n              (send\n                (send\n                  (lvar :sseq_or_op) :do_extend\n                  (lvar :extends)\n                  (lvar :supers)) :map)\n              (args\n                (arg :seq))\n              (send\n                (lvar :seq) :members))))))) :map) flatten map ","(send\n  (send\n    (const\n      (const nil :Haml) :Util) :Haml Util  paths \n    (block\n      (send\n        (send nil :members) :map)\n      (args\n        (arg :sseq_or_op))\n      (begin\n        (if\n          (send\n            (lvar :sseq_or_op) :is_a?\n            (const nil :SimpleSequence)) nil\n          (next\n            (array\n              (array\n                (lvar :sseq_or_op)))))\n        (array\n          (array\n            (lvar :sseq_or_op))\n          (splat\n            (block\n              (send\n                (send\n                  (lvar :sseq_or_op) :do_extend\n                  (lvar :extends)\n                  (lvar :supers)) :map)\n              (args\n                (arg :seq))\n              (send\n                (lvar :seq) :members))))))) :map) flatten ","Haml Util  Haml Util  paths  map "]}," Sass Selector Sequence resolve_parent_refs":{"type":"method","name":"resolve_parent_refs","children":[],"call":["Sequence  new ","(send\n  (lvar :members) :map) flatten ","seq_or_op resolve_parent_refs ","seq_or_op is_a? ","members map ","members << ","SimpleSequence  new ","Parent  new ","seq_or_op members first is_a? ","seq_or_op members first ","seq_or_op members ","members any? ","members slice! ","members first == ","members first "]}," Sass Selector Sequence initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector Sequence filename=":{"type":"method","name":"filename=","children":[],"call":["m filename= ","m is_a? "," members each "," members "]}," Sass Selector Sequence line=":{"type":"method","name":"line=","children":[],"call":["m line= ","m is_a? "," members each "," members "]}," Sass Selector CommaSequence _eql?":{"type":"method","name":"_eql?","children":[],"call":["other members eql? "," members ","other members ","other class == "," class ","other class "]}," Sass Selector CommaSequence _hash":{"type":"method","name":"_hash","children":[],"call":[" members hash "," members "]}," Sass Selector CommaSequence inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (send nil :members) :map) join ","m inspect "," members map "," members "]}," Sass Selector CommaSequence do_extend":{"type":"method","name":"do_extend","children":[],"call":["CommaSequence  new ","(send\n  (send nil :members) :map) flatten ","seq do_extend "," members map "," members "]}," Sass Selector CommaSequence resolve_parent_refs":{"type":"method","name":"resolve_parent_refs","children":[],"call":["CommaSequence  new ","(send\n  (send\n    (lvar :super_cseq) :members) :map) flatten ","seq resolve_parent_refs ","@members map ","super_cseq members map ","super_cseq members "," raise ","Sass SyntaxError  new ","ssel is_a? ","sel_or_op members any? ","sel_or_op members ","sel_or_op is_a? ","sel members any? ","sel members ","@members any? ","super_cseq nil? "]}," Sass Selector CommaSequence initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector AbstractSequence eql?":{"type":"method","name":"eql?","children":[],"call":[" _eql? ","other hash == "," hash ","other hash ","other class == "," class ","other class "]}," Sass Selector AbstractSequence hash":{"type":"method","name":"hash","children":[],"call":[" _hash "]}," Sass Selector AbstractSequence filename=":{"type":"method","name":"filename=","children":[],"call":["m filename= "," members each "," members "]}," Sass Selector AbstractSequence line=":{"type":"method","name":"line=","children":[],"call":["m line= "," members each "," members "]}," Sass SCSS StaticParser special_directive":{"type":"method","name":"special_directive","children":[],"call":["name == ","(str \"media\") include? "]}," Sass SCSS StaticParser use_css_import?":{"type":"method","name":"use_css_import?","children":[],"call":[]}," Sass SCSS StaticParser interp_ident":{"type":"method","name":"interp_ident","children":[],"call":[" tok "]}," Sass SCSS StaticParser interp_string":{"type":"method","name":"interp_string","children":[],"call":[" tok "]}," Sass SCSS StaticParser interpolation":{"type":"method","name":"interpolation","children":[],"call":[]}," Sass SCSS StaticParser script_value":{"type":"method","name":"script_value","children":[],"call":[]}," Sass SCSS StaticParser variable":{"type":"method","name":"variable","children":[],"call":[]}," Sass SCSS StaticParser parse_selector":{"type":"method","name":"parse_selector","children":[],"call":["seq filename= ","seq line= ","Selector CommaSequence  new "," expected ","@scanner eos? ","selectors []= ","Selector Sequence  new ","(str \"\\n\") + ","selectors last members ","selectors last ","ws include? ","selectors << "," expr! "," ss "," str "," tok "," init_scanner! ","Selector CommaSequence  new  filename= "," expr!  filename= ","Selector CommaSequence  new  line= "," expr!  line= "]}," Sass SCSS ScriptParser assert_done":{"type":"method","name":"assert_done","children":[],"call":["@lexer unpeek! "]}," Sass SCSS ScriptParser lexer_class":{"type":"method","name":"lexer_class","children":[],"call":["klass send ","Class  new ","Class  new  send "]}," Sass SCSS ScriptLexer variable":{"type":"method","name":"variable","children":[],"call":[" _variable "," scan "]}," Sass SCSS RX quote":{"type":"method","name":"quote","children":[],"call":[]}," Sass SCSS RX escape_char":{"type":"method","name":"escape_char","children":[],"call":[]}," Sass SCSS RX escape_ident":{"type":"method","name":"escape_ident","children":[],"call":[]}," Sass SCSS Parser tok":{"type":"method","name":"tok","children":[],"call":["s << ","@strs each ","rx != ","@strs empty? ! ","@strs empty? ","res count ","@scanner scan ","@scanner scan  count "]}," Sass SCSS Parser expected":{"type":"method","name":"expected","children":[],"call":[" class expected "," class "]}," Sass SCSS Parser tok!":{"type":"method","name":"tok!","children":[],"call":[" expected ","rx inspect ","string inspect ","rx source == ","Regexp  escape ","rx source ","rx source gsub ","TOK_NAMES  [] "," tok "," expec tok ed ","rx inspec tok  ","rx source gsub  inspect ","s tok ring inspec tok  ","  tok ok "]}," Sass SCSS Parser expr!":{"type":"method","name":"expr!","children":[],"call":[" expected ","name to_s ","EXPR_NAMES  [] "," send ","  send xp send ct send d ","nam send  to_s "," s send nd "]}," Sass SCSS Parser tok?":{"type":"method","name":"tok?","children":[],"call":["@scanner match? "]}," Sass SCSS Parser merge":{"type":"method","name":"merge","children":[],"call":["Haml Util  merge_adjacent_strings ","(lvar :arr) flatten "]}," Sass SCSS Parser sass_script":{"type":"method","name":"sass_script","children":[],"call":["parser line ","parser send "," class sass_script_parser new ","@scanner pos - ","@scanner string [] rindex ","@scanner string [] ","@scanner pos ","@scanner string "," class sass_script_parser "," class "," class sass_script_parser new  line "," class sass_script_parser new  send "," class sass_script_ class sass_script_parser new  new "," class sass_script_ class sass_script_parser new  "]}," Sass SCSS Parser sass_script_parser":{"type":"method","name":"sass_script_parser","children":[],"call":[]}," Sass SCSS Parser node":{"type":"method","name":"node","children":[],"call":["node line= "]}," Sass SCSS Parser str?":{"type":"method","name":"str?","children":[],"call":["@strs pop ","@strs last ","@strs push "]}," Sass SCSS Parser str":{"type":"method","name":"str","children":[],"call":["@strs pop ","@strs last ","@strs push "]}," Sass SCSS Parser interp_name":{"type":"method","name":"interp_name","children":[],"call":[" interp_ident "]}," Sass SCSS Parser interp_ident":{"type":"method","name":"interp_ident","children":[],"call":["res << "," interpolation "," tok "]}," Sass SCSS Parser _interp_string":{"type":"method","name":"_interp_string","children":[],"call":["res << << "," tok ","res << "," expr! ","res last slice! ","res last ","@scanner pos ","@scanner [] == ","@scanner [] ","Sass Script Lexer STRING_REGULAR_EXPRESSIONS  [] ","@scanner [] empty? "]}," Sass SCSS Parser interp_string":{"type":"method","name":"interp_string","children":[],"call":[" _interp_string "]}," Sass SCSS Parser interpolation":{"type":"method","name":"interpolation","children":[],"call":[" sass_script "," tok "]}," Sass SCSS Parser function":{"type":"method","name":"function","children":[],"call":[" tok! "," expr "," ss "," str ","Haml Shared  balance ","name == "," tok "," tok  == "]}," Sass SCSS Parser term":{"type":"method","name":"term","children":[],"call":[" expr! "," tok "," unary_operator "," interpolation "," interp_string "," function "," unary_ unary_operator erator "]}," Sass SCSS Parser expr":{"type":"method","name":"expr","children":[],"call":["res << << << "," ss "," str ","res << << ","res << "," term "," operator "," s term r ","  term erm "," opera term or ","  operator perat operator r "]}," Sass SCSS Parser nested_properties!":{"type":"method","name":"nested_properties!","children":[],"call":[" block "," raise ","Sass SyntaxError  new "]}," Sass SCSS Parser plain_value":{"type":"method","name":"plain_value","children":[],"call":["expression << "," tok "," expr "," tok? ! "," tok? ","(send nil :str) empty? ! ","(send nil :str) empty? "," ss "," str "," expr  << "]}," Sass SCSS Parser value!":{"type":"method","name":"value!","children":[],"call":[" sass_script ","Sass Script String  new ","val strip "," tok "," tok? "," tok? ! ","(send nil :str) empty? ! ","(send nil :str) empty? "," ss "," str "," tok  strip "]}," Sass SCSS Parser declaration":{"type":"method","name":"declaration","children":[],"call":[" nested_properties! "," node ","Sass Tree PropNode  new ","name flatten compact ","name flatten "," tok? "," ss "," value! "," tok! ","name << "," tok ","name is_a? "," interp_ident "," expr! "," str ","s !~ "," expected_property_separator "," property ","(lvar :s) + ","s != "," ne tok ted_propertie tok ! ","  node  ","Sa tok  tok  Tree PropNode  new "," interp_ident  flatten compact "," property  flatten compact ","(lvar :s) +  flatten compact "," interp_ident  flatten "," property  flatten ","(lvar :s) +  flatten ","  tok  tok  "," interp_ident  << "," property  << ","(lvar :s) +  << "," interp_ident  is_a? "," property  is_a? ","(lvar :s) +  is_a? ","name i tok _a? ","  tok tr "," tok  !~ "," expected_property_ tok eparator ","(lvar : tok ) + "," tok  != "]}," Sass SCSS Parser negation":{"type":"method","name":"negation","children":[],"call":["Selector Negation  new "," tok! "," expr! "," attrib "," class_selector "," id_selector "," element_name "," ss "," tok ","res << "," class_expr "," str ","Selector SelectorPseudoClass  new ","name [] "," selector_comma_sequence "," class_ selector_comma_sequence ector "," id_ selector_comma_sequence ector ","  selector_comma_sequence ector_comma_sequence "]}," Sass SCSS Parser pseudo_expr":{"type":"method","name":"pseudo_expr","children":[],"call":["res << << "," ss "," str ","res << "," interpolation "," tok "," interp_string "]}," Sass SCSS Parser pseudo":{"type":"method","name":"pseudo","children":[],"call":["Selector Pseudo  new "," merge ","s == "," tok! "," expr! "," ss "," tok "," functional_pseudo ","res << << << << ","res << << << ","res << << "," str ","res << ","Selector P tok eudo  new "," tok  == ","  tok  tok  "," functional_p tok eudo ","re tok  << << << << ","re tok  << << << ","re tok  << << ","  tok tr ","re tok  << "]}," Sass SCSS Parser attrib_name!":{"type":"method","name":"attrib_name!","children":[],"call":[" expr! "," tok! "," tok "," interp_ident "]}," Sass SCSS Parser attrib":{"type":"method","name":"attrib","children":[],"call":["Selector Attribute  new "," merge "," tok "," ss "," expr! "," attrib_name! ","res << "," tok! ","res << << << << "," str ","res << << << ","res << << "]}," Sass SCSS Parser interpolation_selector":{"type":"method","name":"interpolation_selector","children":[],"call":["Selector Interpolation  new "," interpolation "]}," Sass SCSS Parser element_name":{"type":"method","name":"element_name","children":[],"call":["Selector Element  new "," merge ","Selector Universal  new ","name == "," tok! "," interp_ident "," tok "," tok? ","name << << ","name << "]}," Sass SCSS Parser id_selector":{"type":"method","name":"id_selector","children":[],"call":["Selector Id  new "," merge "," expr! "," tok "]}," Sass SCSS Parser class_selector":{"type":"method","name":"class_selector","children":[],"call":["Selector Class  new "," merge "," expr! "," tok "]}," Sass SCSS Parser parent_selector":{"type":"method","name":"parent_selector","children":[],"call":["Selector Parent  new "," tok "]}," Sass SCSS Parser simple_selector_sequence":{"type":"method","name":"simple_selector_sequence","children":[],"call":["Selector SimpleSequence  new "," raise ","e message << << ","e message << ","e message "," expected "," tok? ","res << ","Selector Universal  new "," tok "," interpolation_selector "," pseudo "," negation "," attrib "," class_selector "," id_selector "," element_name "," expr "," parent_selector "," interpolation "," class_expr "]}," Sass SCSS Parser combinator":{"type":"method","name":"combinator","children":[],"call":[" tok "," whitespace "," str? "]}," Sass SCSS Parser _selector":{"type":"method","name":"_selector","children":[],"call":["Selector Sequence  new ","res compact ","res << ","(send nil :str) include? "," ss "," str "," simple_selector_sequence "," combinator "]}," Sass SCSS Parser selector":{"type":"method","name":"selector","children":[],"call":["sel to_a "," _selector ","res concat "," simple_selector_sequence ","res << "," combinator ","(lvar :comb) + "," _selector  to_a "," _ _selector ector ","(lvar :comb) +  concat "," simple_ _selector ector_sequence "," simple_selector_ simple_selector_sequence uence ","(lvar :comb) +  << ","  combinator inator ","(l combinator ar :comb) + ","(lvar : combinator ) + "]}," Sass SCSS Parser selector_sequence":{"type":"method","name":"selector_sequence","children":[],"call":["rules concat "," expr! ","rules << << "," ss "," str ","rules << "," tok "," selector ","  tok ector "]}," Sass SCSS Parser declaration_or_ruleset":{"type":"method","name":"declaration_or_ruleset","children":[],"call":[" raise "," ruleset ","@scanner pos= "," tok! "," tok? ","decl has_children "," declaration ","@scanner pos ","@scanner @scanner pos = "," declaration  has_children ","  declaration aration ","@scanner @scanner pos  "]}," Sass SCSS Parser block_child":{"type":"method","name":"block_child","children":[],"call":[" declaration_or_ruleset "," directive "," variable "," ruleset ","context == "]}," Sass SCSS Parser block_contents":{"type":"method","name":"block_contents","children":[],"call":["node << "," block_child "," ss_comments "," block_given? ","child has_children "," tok "," has_children? "," block_ block_child  "," block_child  has_ block_child ren "," has_ block_child ren? "]}," Sass SCSS Parser block":{"type":"method","name":"block","children":[],"call":[" tok! "," block_contents ","node has_children= "]}," Sass SCSS Parser ruleset":{"type":"method","name":"ruleset","children":[],"call":[" block "," node ","Sass Tree RuleNode  new ","rules flatten compact ","rules flatten "," selector_sequence ","rules concat "," expr! ","rules << << "," ss "," str ","rules << "," tok "," selector "," selector_sequence  flatten compact "," selector_sequence  flatten "," selector_sequence  concat "," selector_sequence  << << "," selector_sequence  << "]}," Sass SCSS Parser unary_operator":{"type":"method","name":"unary_operator","children":[],"call":[" tok "]}," Sass SCSS Parser operator":{"type":"method","name":"operator","children":[],"call":[" ss "," tok "," str "]}," Sass SCSS Parser variable":{"type":"method","name":"variable","children":[],"call":[" node ","Sass Tree VariableNode  new "," tok "," sass_script "," ss "," tok! "]}," Sass SCSS Parser media_expr":{"type":"method","name":"media_expr","children":[],"call":[" ss "," tok! "," expr! "," tok "]}," Sass SCSS Parser media_query":{"type":"method","name":"media_query","children":[],"call":[" ss "," expr! "," tok "," media_expr ! "," media_expr "," tok ! "," tok! "]}," Sass SCSS Parser media_query_list":{"type":"method","name":"media_query_list","children":[],"call":[" ss "," expr! "," tok "," media_query "]}," Sass SCSS Parser media_directive":{"type":"method","name":"media_directive","children":[],"call":[" block "," node ","Sass Tree DirectiveNode  new ","(send nil :str) strip "," media_query_list "," str "]}," Sass SCSS Parser use_css_import?":{"type":"method","name":"use_css_import?","children":[],"call":[]}," Sass SCSS Parser import_directive":{"type":"method","name":"import_directive","children":[],"call":[" node ","Sass Tree ImportNode  new ","path strip ","Sass Tree DirectiveNode  new ","(str \"@import \") strip "," use_css_import? ","media strip empty? ! ","media strip empty? ","media strip ","(send nil :str) strip "," media_query_list "," str "," ss ","@scanner [] "," tok! "," tok ","path =~ "," tok ! ","values << "," expr! "," loop ","(send nil :str) strip  strip empty? ! ","(send nil :str) strip  strip empty? ","(send nil :str) strip  strip "," (send nil :str) strip _query_list "]}," Sass SCSS Parser extend_directive":{"type":"method","name":"extend_directive","children":[],"call":[" node ","Sass Tree ExtendNode  new "," expr! "]}," Sass SCSS Parser else_block":{"type":"method","name":"else_block","children":[],"call":[" else_block "," ss ","node add_else "," block ","Sass Tree IfNode  new "," sass_script "," tok ","@scanner pos= ","@scanner pos ","@scanner @scanner pos = ","@scanner @scanner pos  "]}," Sass SCSS Parser if_directive":{"type":"method","name":"if_directive","children":[],"call":[" else_block "," ss "," block "," node ","Sass Tree IfNode  new "," sass_script ","@scanner pos= ","@scanner pos ","  block  ","@scanner @scanner pos = ","@scanner @scanner pos  "]}," Sass SCSS Parser while_directive":{"type":"method","name":"while_directive","children":[],"call":[" block "," node ","Sass Tree WhileNode  new "," ss "," sass_script "]}," Sass SCSS Parser for_directive":{"type":"method","name":"for_directive","children":[],"call":[" block "," node ","Sass Tree ForNode  new "," ss "," sass_script ","(or\n  (send nil :tok\n    (regexp\n      (str \"to\")\n      (regopt)))\n  (send nil :tok!\n    (regexp\n      (str \"through\")\n      (regopt)))) == "," tok! "," tok ","Set  [] ","(or\n  (send nil : sass_script k\n    (regexp\n      (str \" sass_script \")\n      (regopt)))\n  (send nil : sass_script k!\n    (regexp\n      (str \"through\")\n      (regopt)))) == ","  sass_script k! ","  sass_script k "]}," Sass SCSS Parser warn_directive":{"type":"method","name":"warn_directive","children":[],"call":[" node ","Sass Tree WarnNode  new "," sass_script "]}," Sass SCSS Parser debug_directive":{"type":"method","name":"debug_directive","children":[],"call":[" node ","Sass Tree DebugNode  new "," sass_script "]}," Sass SCSS Parser include_directive":{"type":"method","name":"include_directive","children":[],"call":[" node ","Sass Tree MixinNode  new "," ss "," sass_script "," tok! "]}," Sass SCSS Parser mixin_directive":{"type":"method","name":"mixin_directive","children":[],"call":[" block "," node ","Sass Tree MixinDefNode  new "," ss "," sass_script "," tok! "]}," Sass SCSS Parser special_directive":{"type":"method","name":"special_directive","children":[],"call":[" send ","DIRECTIVES  include? ","name gsub to_sym ","name gsub ","name gsub to_name gsub to_sym  "]}," Sass SCSS Parser directive":{"type":"method","name":"directive","children":[],"call":[" tok! "," block_contents ","node has_children= "," tok "," node ","Sass Tree DirectiveNode  new ","(str \"@\") strip "," selector "," expr "," str "," special_directive "," ss ","CssParser  new parse_selector_string ","CssParser  new "," node  has_children= ","  node  "," special_ special_directive ective "]}," Sass SCSS Parser process_comment":{"type":"method","name":"process_comment","children":[],"call":["node << ","comment line= ","@line - ","text count ","Sass Tree CommentNode  new ","pre_str + ","text sub gsub + ","text sub gsub ","text sub ","@scanner string [] reverse [] reverse gsub ","@scanner string [] reverse [] reverse ","@scanner string [] reverse [] ","@scanner string [] reverse ","@scanner string [] ","@scanner pos ","@scanner string ","text =~ ","Sass Tree CommentNode  new  line= ","text sub gsub +  count ","@scanner string [] reverse [] reverse gsub  + ","text sub gsub +  sub gsub + ","text sub gsub +  sub gsub ","text sub gsub +  sub ","text sub gsub +  =~ "]}," Sass SCSS Parser whitespace":{"type":"method","name":"whitespace","children":[],"call":[" ss "," tok "]}," Sass SCSS Parser ss_comments":{"type":"method","name":"ss_comments","children":[],"call":[" process_comment "," tok "," pro tok ess_ tok omment "]}," Sass SCSS Parser ss":{"type":"method","name":"ss","children":[],"call":[" tok "]}," Sass SCSS Parser s":{"type":"method","name":"s","children":[],"call":[" process_comment "," tok "," pro tok ess_ tok omment "]}," Sass SCSS Parser stylesheet":{"type":"method","name":"stylesheet","children":[],"call":[" s "," block_contents "," node ","Sass Tree RootNode  new ","@scanner string ","  node  "]}," Sass SCSS Parser init_scanner!":{"type":"method","name":"init_scanner!","children":[],"call":["StringScanner  new ","(send\n  (const\n    (const nil :Haml) :Util) :check_encoding\n  (ivar :@template)) gsub "," raise ","Sass SyntaxError  new ","Haml Util  check_encoding ","@template is_a? ","@template gsub "]}," Sass SCSS Parser parse_interp_ident":{"type":"method","name":"parse_interp_ident","children":[],"call":[" interp_ident "," init_scanner! "]}," Sass SCSS Parser parse":{"type":"method","name":"parse","children":[],"call":[" expected ","@scanner eos? "," stylesheet "," init_scanner! ","StringScanner  new ","(send\n  (const\n    (const nil :Haml) :Util) :check_encoding\n  (ivar :@template)) gsub "," raise ","Sass SyntaxError  new ","Haml Util  check_encoding ","StringScanner  new  eos? "]}," Sass SCSS Parser initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass SCSS CssParser nested_properties!":{"type":"method","name":"nested_properties!","children":[],"call":[" expected "]}," Sass SCSS CssParser block_child":{"type":"method","name":"block_child","children":[],"call":[" declaration_or_ruleset "," directive "," ruleset "," declaration "]}," Sass SCSS CssParser special_directive":{"type":"method","name":"special_directive","children":[],"call":["name == "]}," Sass SCSS CssParser use_css_import?":{"type":"method","name":"use_css_import?","children":[],"call":[]}," Sass SCSS CssParser interp_ident":{"type":"method","name":"interp_ident","children":[],"call":[" tok "]}," Sass SCSS CssParser interp_string":{"type":"method","name":"interp_string","children":[],"call":[" tok "]}," Sass SCSS CssParser interpolation":{"type":"method","name":"interpolation","children":[],"call":[]}," Sass SCSS CssParser parent_selector":{"type":"method","name":"parent_selector","children":[],"call":[]}," Sass Script equals_warning":{"type":"method","name":"equals_warning","children":[],"call":[]}," Sass Script var_warning":{"type":"method","name":"var_warning","children":[],"call":[]}," Sass Script Variable _perform":{"type":"method","name":"_perform","children":[],"call":["val original= ","val dup ","val is_a? "," raise ","SyntaxError  new "," name ","environment var ","val dup  original= ","environment var  original= ","val dup  dup ","environment var  dup ","val dup  is_a? ","environment var  is_a? "]}," Sass Script Variable children":{"type":"method","name":"children","children":[],"call":[]}," Script UnaryOperation _perform":{"type":"method","name":"_perform","children":[],"call":[" raise ","Sass SyntaxError  new ","e name to_s == ","operator to_s ","e name to_s ","e name ","literal send ","@operand perform ","@operand perform  send "]}," Script UnaryOperation children":{"type":"method","name":"children","children":[],"call":[]}," Script UnaryOperation to_sass":{"type":"method","name":"to_sass","children":[],"call":["op + + ","op + ","op =~ ","Lexer OPERATORS_REVERSE  [] ","@operand to_sass ","(send\n  (lvar :operand) :=~\n  (const\n    (const\n      (const\n        (const nil :Sass) :SCSS) :RX) :IDENT)) == ","operand =~ ","@operator == ","@operand is_a? ","Lexer OPERATORS_REVERSE  []  + + ","Lexer OPERATORS_REVERSE  []  + ","Lexer OPERATORS_REVERSE  []  =~ ","@Lexer OPERATORS_REVERSE  [] erand to_sass ","@@operand to_sass  to_sass ","(send\n  (lvar :Lexer OPERATORS_REVERSE  [] erand) :=~\n  (const\n    (const\n      (const\n        (const nil :Sass) :SCSS) :RX) :IDENT)) == ","(send\n  (lvar :@operand to_sass ) :=~\n  (const\n    (const\n      (const\n        (const nil :Sass) :SCSS) :RX) :IDENT)) == ","Lexer OPERATORS_REVERSE  [] erand =~ ","@operand to_sass  =~ ","@Lexer OPERATORS_REVERSE  [] erator == ","@Lexer OPERATORS_REVERSE  [] erand is_a? ","@@operand to_sass  is_a? "]}," Script StringInterpolation parse_str":{"type":"method","name":"parse_str","children":[],"call":[]}," Script StringInterpolation _perform":{"type":"method","name":"_perform","children":[],"call":["Sass Script String  new ","before type ","res << ","@after perform value ","@after perform ","mid to_s ","mid value ","mid is_a? ","@mid perform ","before value ","@before perform ","val to_s ","val value ","val is_a? ","@before perform value "," opts ","@before perform  type ","@after perform @mid perform ue ","@mid perform  to_s ","@mid perform  value ","mid @mid perform ue ","@mid perform  is_a? ","@@mid perform  perform ","@before perform  value ","before @mid perform ue ","@@before perform  perform ","@mid perform  @mid perform ue ","@@before perform  perform value ","@before perform @mid perform ue "]}," Script StringInterpolation children":{"type":"method","name":"children","children":[],"call":["(ivar :@before) compact "]}," Script StringInterpolation to_sass":{"type":"method","name":"to_sass","children":[],"call":["res << ","res << << << ","res << << ","@mid to_sass ","after_str gsub! ","before_str gsub! ","before_quote_char != ","before_str empty? ! ","before_str empty? ","before_quote_char ! ","after_str empty? ! ","after_str empty? ","after_quote_char ! "," parse_str ","@after to_sass ","@before to_sass "]}," Script StringInterpolation inspect":{"type":"method","name":"inspect","children":[],"call":["@after inspect ","@mid inspect ","@before inspect "]}," Script StringInterpolation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script String to_sass":{"type":"method","name":"to_sass","children":[],"call":[" to_s ","Sass Script String  new to_sass ","Sass Script String  new "," value ","Sass SCSS RX  escape_ident include? ","Sass SCSS RX  escape_ident "," value !~ "," context == "," context "," type == "," type ","value gsub ","value include? "," value gsub ","type == "," value include? ","opts [] == ","opts [] "," value size == "," value size ","  value gsub  ","  value gsub  !~ "," value gsub  gsub "," value gsub  include? ","  value gsub  gsub ","  value gsub  include? ","  value gsub  size == ","  value gsub  size "]}," Script String to_s":{"type":"method","name":"to_s","children":[],"call":[" value gsub "," value "," value include? ","opts [] == ","opts [] "," value size == "," value size "," context == "," context "," type == "," type "," to_sass "]}," Script String plus":{"type":"method","name":"plus","children":[],"call":["Sass Script String  new "," type "," value + "," value ","other to_s ","other value ","other is_a? "]}," Script String initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script String context=":{"type":"method","name":"context=","children":[],"call":["context == "]}," Sass Script Parser node":{"type":"method","name":"node","children":[],"call":["node line= ","@lexer line "]}," Sass Script Parser number":{"type":"method","name":"number","children":[],"call":["num original= ","num to_s ","tok value "," literal "," try_tok ","tok value  original= ","tok value  to_s "," try_tok  value "," try_ try_tok  "]}," Sass Script Parser special_fun":{"type":"method","name":"special_fun","children":[],"call":["Script Interpolation  new "," node ","Script String  new ","Haml Util  enum_slice inject ","Haml Util  enum_slice ","tok value [] ","tok value ","tok value first "," paren "," try_tok "," try_tok  value [] "," try_tok  value ","tok value  node  "," try_tok  value first "," try_ try_tok  "]}," Sass Script Parser raw":{"type":"method","name":"raw","children":[],"call":[" node ","Script String  new ","tok value "," special_fun "," try_tok "," try_tok  value "," try_ try_tok  "]}," Sass Script Parser fn_arglist":{"type":"method","name":"fn_arglist","children":[],"call":[" fn_arglist "," try_tok "," equals "," assert_expr ","  equals quals "," ass equals rt_ equals xpr "]}," Sass Script Parser defn_arglist!":{"type":"method","name":"defn_arglist!","children":[],"call":[" assert_tok "," try_tok ","res << "," raise ","SyntaxError  new ","var inspect ","Script  equals_warning ","@options [] ","val to_sass ","c value ","val options= ","val context= ","tok type == ","tok type "," assert_expr ","Script Variable  new ","@lexer offset + ","@lexer offset ","@lexer line "," loop ","Script Variable  new  inspect ","var inspe assert_tok t ","S assert_tok ript  equals_warning "," assert_expr  to_sass ","c  assert_expr ue "," assert_tok  value "," assert_expr  options= "," assert_expr  context= ","val  assert_tok ontext= ","S assert_tok ript Variable  new ","@lexer @lexer offset +  + ","@lexer @lexer offset +  ","@lexer @lexer line  "]}," Sass Script Parser ident":{"type":"method","name":"ident","children":[],"call":[" node ","Script String  new ","name value ","Color  new ","Color HTML4_COLORS  [] ","@lexer next ","@stop_at include? ","@lexer peek value ","@lexer peek "," funcall ","@lexer peek type == ","@lexer peek type ","name value downcase ","@lexer next  value ","@lexer next  value downcase "]}," Sass Script Parser interpolation":{"type":"method","name":"interpolation","children":[],"call":["e line= ","Script Interpolation  new "," concat ","@lexer whitespace? "," parse_interpolated ","@lexer line "," try_tok ","Script Interpolation  new  linScript Interpolation  new = "," concat  lin concat = ","e @lexer line = ","Script IntScript Interpolation  new rpolation  nScript Interpolation  new w ","Script Int concat rpolation  n concat w ","@lScript Interpolation  new xScript Interpolation  new r whitScript Interpolation  new spacScript Interpolation  new ? ","@l concat x concat r whit concat spac concat ? "," parsScript Interpolation  new _intScript Interpolation  new rpolatScript Interpolation  new d "," pars concat _int concat rpolat concat d "," parse_ try_tok olated ","@lScript Interpolation  new xScript Interpolation  new r linScript Interpolation  new  ","@l concat x concat r lin concat  ","@lexer @lexer line  "]}," Sass Script Parser lexer_class":{"type":"method","name":"lexer_class","children":[],"call":[]}," Sass Script Parser precedence_of":{"type":"method","name":"precedence_of","children":[],"call":[" raise "," Array include? "," Array ","PRECEDENCE  each_with_index "]}," Sass Script Parser parse_until":{"type":"method","name":"parse_until","children":[],"call":[" raise ","e modify_backtrace ","@options [] ","@lexer line ","expr options= "," assert_done "," assert_expr "," assert_expr  options= "," assert_ assert_expr  "]}," Sass Script Parser line":{"type":"method","name":"line","children":[],"call":["@lexer line "]}," Script Operation operand_to_sass":{"type":"method","name":"operand_to_sass","children":[],"call":["op to_sass ","Sass Script Parser  precedence_of < ","Sass Script Parser  precedence_of ","op operator ","op is_a? ","assoc ! ","sub_pred == ","side == ","sub_pred < ","Sass Script Parser  associative? ","Sass Script Parser  associative?  ! ","Sass Script Parser  precedence_of  == ","sub_Sass Script Parser  precedence_of  == ","Sass Script Parser  precedence_of  < ","sub_Sass Script Parser  precedence_of  < ","Sass Script Parser  Sass Script Parser  associative? iative? "]}," Script Operation _perform":{"type":"method","name":"_perform","children":[],"call":[" raise ","Sass SyntaxError  new ","e name to_s == ","@operator to_s ","e name to_s ","e name ","res options= ","environment options ","literal1 send ","Sass Script String  new ","literal2 value ","literal2 is_a? ","literal1 value ","literal1 is_a? "," context == "," context ","@operator == ","@operand2 perform ","@operand1 perform "," opts ","literal1 send  options= ","Sass Script String  new  send ","@operand1 perform  send ","Sass Script String  new  value ","@operand2 perform  value ","Sass Script String  new  is_a? ","@operand2 perform  is_a? ","@operand1 perform  value ","@operand1 perform  is_a? "]}," Script Operation children":{"type":"method","name":"children","children":[],"call":[]}," Script Operation to_sass":{"type":"method","name":"to_sass","children":[],"call":["Lexer OPERATORS_REVERSE  [] "," operand_to_sass ","Sass Script Parser  precedence_of "]}," Script Number comparable_to?":{"type":"method","name":"comparable_to?","children":[],"call":[" operate "]}," Script Number unary_plus":{"type":"method","name":"unary_plus","children":[],"call":[]}," Script Node _perform":{"type":"method","name":"_perform","children":[],"call":[" raise ","NotImplementedError  new "]}," Script Node dasherize":{"type":"method","name":"dasherize","children":[],"call":["s gsub ","opts [] "]}," Script Node to_sass":{"type":"method","name":"to_sass","children":[],"call":[" raise ","NotImplementedError  new "]}," Script Node children":{"type":"method","name":"children","children":[],"call":[" raise ","NotImplementedError  new "]}," Script Node initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script Node context=":{"type":"method","name":"context=","children":[],"call":["c context= "," children each "," children "]}," Script Node options=":{"type":"method","name":"options=","children":[],"call":["c options= "," children each "," children "]}," Script Literal _perform":{"type":"method","name":"_perform","children":[],"call":[]}," Script Literal to_s":{"type":"method","name":"to_s","children":[],"call":[" raise ","Sass SyntaxError  new "]}," Script Literal unary_plus":{"type":"method","name":"unary_plus","children":[],"call":["Sass Script String  new "," to_s "]}," Script Literal single_eq":{"type":"method","name":"single_eq","children":[],"call":["Sass Script String  new ","other to_s "," to_s "]}," Script Literal options":{"type":"method","name":"options","children":[],"call":[" raise ","Sass SyntaxError  new "," class "]}," Script Literal children":{"type":"method","name":"children","children":[],"call":[]}," Sass Script Lexer scan":{"type":"method","name":"scan","children":[],"call":["str [] size ","str [] ","@offset + ","str size ","c == ","str count ","@scanner scan ","@scanner scan  [] size ","@scanner scan  [] ","@scanner scan  size ","str count  == ","str str count ount ","@scanner scan  count ","@sstr count anner sstr count an "]}," Sass Script Lexer raw":{"type":"method","name":"raw","children":[],"call":[" scan "]}," Sass Script Lexer ident_op":{"type":"method","name":"ident_op","children":[],"call":["OPERATORS  [] "," scan ","REGULAR_EXPRESSIONS  [] "]}," Sass Script Lexer special_fun":{"type":"method","name":"special_fun","children":[],"call":["str1 size + ","str2 size ","str1 size ","Haml Util  merge_adjacent_strings ","(lvar :str1) + ","Sass Engine  parse_interp ","str2 [] size ","str2 [] ","@offset + ","c == ","str2 count ","Haml Shared  balance "," scan "," scan  size + "," scan  size ","Haml Util  merge_adjastr2 count ent_strings ","(lvar : scan ) + ","str2 count  == ","str2 str2 count ount ","Haml Shared  balanstr2 count e "," sstr2 count an "]}," Sass Script Lexer _variable":{"type":"method","name":"_variable","children":[],"call":["@scanner [] ","Script  var_warning ","@options [] ","offset + ","@scanner [] != ","@scanner [] == "," scan "]}," Sass Script Lexer str":{"type":"method","name":"str","children":[],"call":["@scanner string [] ","@scanner string ","@scanner pos ","@tok pos "]}," Sass Script Lexer expected!":{"type":"method","name":"expected!","children":[],"call":["Sass SCSS Parser  expected "," unpeek! "]}," Sass Script Lexer unpeek!":{"type":"method","name":"unpeek!","children":[],"call":["@scanner pos= ","@tok pos "]}," Sass Script Lexer whitespace?":{"type":"method","name":"whitespace?","children":[],"call":["@scanner string [] =~ ","@scanner string [] ","@scanner pos - ","@scanner pos ","@scanner string ","tok pos "]}," Sass Script Lexer string_re":{"type":"method","name":"string_re","children":[],"call":[]}," Script Interpolation _perform":{"type":"method","name":"_perform","children":[],"call":["Sass Script String  new ","res << ","@after perform to_s ","@after perform ","val to_s ","val value ","val is_a? ","@mid perform ","@before perform to_s ","@before perform "," opts ","@mid perform  to_s ","@mid perform  @mid perform ue ","@mid perform  is_a? "]}," Script Interpolation children":{"type":"method","name":"children","children":[],"call":["(ivar :@before) compact "]}," Script Interpolation to_sass":{"type":"method","name":"to_sass","children":[],"call":["res << ","@after to_sass ","res << << << ","res << << ","@mid to_sass ","@before to_sass "]}," Script Interpolation inspect":{"type":"method","name":"inspect","children":[],"call":["@after inspect ","@mid inspect ","@before inspect "," after inspect "," after "]}," Script Interpolation initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Script Functions adjust":{"type":"method","name":"adjust","children":[],"call":["color with ","Haml Util  restrict ","color send send ","amount value ","color send "," raise ","ArgumentError  new ","range last ","range first ","range include? "," assert_type "]}," Script Functions comparable":{"type":"method","name":"comparable","children":[],"call":["Sass Script Bool  new ","number1 comparable_to? "," assert_type "]}," Script Functions unitless":{"type":"method","name":"unitless","children":[],"call":["Sass Script Bool  new ","number unitless? "," assert_type "]}," Script Functions unit":{"type":"method","name":"unit","children":[],"call":["Sass Script String  new ","number unit_str "," assert_type "]}," Script Functions type_of":{"type":"method","name":"type_of","children":[],"call":["Sass Script String  new ","obj class name gsub downcase ","obj class name gsub ","obj class name ","obj class "]}," Script Functions quote":{"type":"method","name":"quote","children":[],"call":["Sass Script String  new ","str value "," assert_type "]}," Script Functions unquote":{"type":"method","name":"unquote","children":[],"call":["Sass Script String  new ","str value "," assert_type ","value value "]}," Script Functions complement":{"type":"method","name":"complement","children":[],"call":[" adjust_hue ","Number  new "]}," Script Functions grayscale":{"type":"method","name":"grayscale","children":[],"call":[" desaturate ","Number  new "]}," Script Functions mix":{"type":"method","name":"mix","children":[],"call":["Color  new ","rgb + ","color1 alpha * + ","color2 alpha * ","1 - ","color2 alpha ","color1 alpha * ","color1 alpha ","v1 * + ","v2 * ","v1 * ","color1 rgb zip map ","color1 rgb zip ","color2 rgb ","color1 rgb ","(send\n  (begin\n    (if\n      (begin\n        (send\n          (send\n            (lvar :w) :*\n            (lvar :a)) :==\n          (int -1)))\n      (lvar :w)\n      (send\n        (begin\n          (send\n            (lvar :w) :+\n            (lvar :a))) :/\n        (begin\n          (send\n            (int 1) :+\n            (send\n              (lvar :w) :*\n              (lvar :a))))))) :+\n  (int 1)) / ","(if\n  (begin\n    (send\n      (send\n        (lvar :w) :*\n        (lvar :a)) :==\n      (int -1)))\n  (lvar :w)\n  (send\n    (begin\n      (send\n        (lvar :w) :+\n        (lvar :a))) :/\n    (begin\n      (send\n        (int 1) :+\n        (send\n          (lvar :w) :*\n          (lvar :a)))))) + ","(send\n  (lvar :w) :+\n  (lvar :a)) / ","1 + ","w * ","w + ","w * == ","color1 alpha - ","p * - ","p * ","weight value / ","weight value "," raise ","ArgumentError  new ","(irange\n  (int 0)\n  (int 100)) include? "," assert_type ","Color  nep * -  ","color1 color1 alpha * +  * + ","color1 color1 alpha - lphcolor1 alpha -  * + ","color1 alweight value / ha * + ","color2 color1 alpha * +  * ","color2 color1 alpha - lphcolor1 alpha -  * ","color2 alweight value / ha * ","color2 color1 alpha * +  ","color2 color1 alpha - lphcolor1 alpha -  ","color2 alweight value / ha ","color1 color1 alpha * +  * ","color1 color1 alpha - lphcolor1 alpha -  * ","color1 alweight value / ha * ","color1 color1 alpha * +  ","color1 color1 alpha - lphcolor1 alpha -  ","color1 alweight value / ha ","color1 rgb zip mcolor1 alpha - p ","color1 rgb ziweight value /  maweight value /  ","color1 rgb ziweight value /  ","(send\n  (begin\n    (if\n      (begin\n        (send\n          (send\n            (lvcolor1 alpha - r :w) :*\n            (lvcolor1 alpha - r :color1 alpha - )) :==\n          (int -1)))\n      (lvcolor1 alpha - r :w)\n      (send\n        (begin\n          (send\n            (lvcolor1 alpha - r :w) :+\n            (lvcolor1 alpha - r :color1 alpha - ))) :/\n        (begin\n          (send\n            (int 1) :+\n            (send\n              (lvcolor1 alpha - r :w) :*\n              (lvcolor1 alpha - r :color1 alpha - ))))))) :+\n  (int 1)) / ","(send\n  (begin\n    (if\n      (begin\n        (send\n          (send\n            (lvar :p * - ) :*\n            (lvar :a)) :==\n          (int -1)))\n      (lvar :p * - )\n      (send\n        (begin\n          (send\n            (lvar :p * - ) :+\n            (lvar :a))) :/\n        (begin\n          (send\n            (int 1) :+\n            (send\n              (lvar :p * - ) :*\n              (lvar :a))))))) :+\n  (int 1)) / ","(if\n  (begin\n    (send\n      (send\n        (lvcolor1 alpha - r :w) :*\n        (lvcolor1 alpha - r :color1 alpha - )) :==\n      (int -1)))\n  (lvcolor1 alpha - r :w)\n  (send\n    (begin\n      (send\n        (lvcolor1 alpha - r :w) :+\n        (lvcolor1 alpha - r :color1 alpha - ))) :/\n    (begin\n      (send\n        (int 1) :+\n        (send\n          (lvcolor1 alpha - r :w) :*\n          (lvcolor1 alpha - r :color1 alpha - )))))) + ","(if\n  (begin\n    (send\n      (send\n        (lvar :p * - ) :*\n        (lvar :a)) :==\n      (int -1)))\n  (lvar :p * - )\n  (send\n    (begin\n      (send\n        (lvar :p * - ) :+\n        (lvar :a))) :/\n    (begin\n      (send\n        (int 1) :+\n        (send\n          (lvar :p * - ) :*\n          (lvar :a)))))) + ","(send\n  (lvcolor1 alpha - r :w) :+\n  (lvcolor1 alpha - r :color1 alpha - )) / ","(send\n  (lvar :p * - ) :+\n  (lvar :a)) / ","p * -  * ","p * -  + ","p * -  * == ","color1 color1 alpha * +  - ","color1 color1 alpha - lphcolor1 alpha -  - ","color1 alweight value / ha - ","weight value /  * - ","weight value /  * ","weight vcolor1 alpha - lue / ","p * - eight value / ","weight vcolor1 alpha - lue ","p * - eight value "," rcolor1 alpha - ise ","ArgumentError  nep * -  ","(ircolor1 alpha - nge\n  (int 0)\n  (int 100)) include? "," color1 alpha - ssert_type "," assert_tyweight value / e "]}," Script Functions adjust_hue":{"type":"method","name":"adjust_hue","children":[],"call":["color with ","color hue + ","degrees value ","color hue "," assert_type "]}," Script Functions desaturate":{"type":"method","name":"desaturate","children":[],"call":[" adjust "]}," Script Functions saturate":{"type":"method","name":"saturate","children":[],"call":[" adjust "]}," Script Functions darken":{"type":"method","name":"darken","children":[],"call":[" adjust "]}," Script Functions lighten":{"type":"method","name":"lighten","children":[],"call":[" adjust "]}," Script Functions transparentize":{"type":"method","name":"transparentize","children":[],"call":[" adjust "]}," Script Functions opacify":{"type":"method","name":"opacify","children":[],"call":[" adjust "]}," Script Functions opacity":{"type":"method","name":"opacity","children":[],"call":["Sass Script Number  new ","color alpha "," assert_type "]}," Script Functions alpha":{"type":"method","name":"alpha","children":[],"call":[" opacity ","Sass Script String  new ","(send\n  (lvar :args) :map) join ","a to_s ","args map ","a value =~ ","a value ","a type == ","a type ","a is_a? ","args all? ","Sass Script Number  new ","color alpha "," assert_type "]}," Script Functions lightness":{"type":"method","name":"lightness","children":[],"call":["Sass Script Number  new ","color lightness "," assert_type "]}," Script Functions saturation":{"type":"method","name":"saturation","children":[],"call":["Sass Script Number  new ","color saturation "," assert_type "]}," Script Functions hue":{"type":"method","name":"hue","children":[],"call":["Sass Script Number  new ","color hue "," assert_type "]}," Script Functions blue":{"type":"method","name":"blue","children":[],"call":["Sass Script Number  new ","color blue "," assert_type "]}," Script Functions green":{"type":"method","name":"green","children":[],"call":["Sass Script Number  new ","color green "," assert_type "]}," Script Functions red":{"type":"method","name":"red","children":[],"call":["Sass Script Number  new ","color red "," assert_type "]}," Script Functions hsla":{"type":"method","name":"hsla","children":[],"call":["Color  new ","alpha value "," raise ","ArgumentError  new ","(irange\n  (int 0)\n  (int 100)) include? ","a value ","(lvar :hue) map ","(irange\n  (int 0)\n  (int 1)) include? "," assert_type "]}," Script Functions rgba":{"type":"method","name":"rgba","children":[],"call":[" raise ","ArgumentError  new ","args size "," rgba "," rgb ","color with ","alpha value ","(irange\n  (int 0)\n  (int 1)) include? "," assert_type "]}," Sass Script Funcall _perform":{"type":"method","name":"_perform","children":[],"call":[" raise ","Sass SyntaxError  new "," name ","e message ","t =~ ","e backtrace any? ","e backtrace ","result options= ","environment options ","Functions EvaluationContext  new send ","Functions EvaluationContext  new ","Script String  new ","(send\n  (lvar :args) :map) join ","a perform ","args map ","ruby_name !~ ","Haml Util  has? "," name gsub "," args map "," args "," opts ","Functions EvaluationContext  new send  options= "," name gsub  !~ "]}," Sass Script Funcall children":{"type":"method","name":"children","children":[],"call":[]}," Sass Script Funcall to_sass":{"type":"method","name":"to_sass","children":[],"call":["(send\n  (send nil :args) :map) join ","a to_sass "," args map "," args "," dasherize "," name "]}," Sass Script Funcall context=":{"type":"method","name":"context=","children":[],"call":["@name == "]}," Sass Script CssParser string":{"type":"method","name":"string","children":[],"call":["tok value ","@lexer peek type == ","@lexer peek type ","@lexer peek "," number "," try_tok "," try_tok  value "," try_ try_tok  "]}," Sass Script CssParser lexer_class":{"type":"method","name":"lexer_class","children":[],"call":[]}," Sass Script CssLexer important":{"type":"method","name":"important","children":[],"call":[" scan ","  scan can "]}," Sass Script CssLexer string":{"type":"method","name":"string","children":[],"call":["Script String  new ","(or\n  (send\n    (ivar :@scanner) :[]\n    (int 1))\n  (send\n    (ivar :@scanner) :[]\n    (int 2))) gsub ","@scanner [] "," scan ","re == ","(or\n  (send\n    (ivar :@scanner) :[]\n    (int 1))\n  (send\n    (ivar :@scanner) :[]\n    (int 2))) gsub gsub "]}," Sass Script CssLexer token":{"type":"method","name":"token","children":[],"call":[" important "]}," Script Color rgb_to_hsl!":{"type":"method","name":"rgb_to_hsl!","children":[],"call":["@attrs []= ","l * ","s * ","h % ","d / ","2 - ","2 * ","l < ","max == ","(send\n  (lvar :max) :+\n  (lvar :min)) / ","max + ","60 * / + ","60 * / ","60 * ","r - ","b - ","g - ","max - ","(lvar :r) min ","(lvar :r) max ","@attrs [] / ","@attrs [] ","(sym :red) map ","(send\n  (lvar :max) :+\n  (lvar :min)) /  * ","max -  / ","(send\n  (lvar :max) :+\n  (lvar :min)) /  < ","(lvar :r) max  == ","(send\n  ((send\n  (lvar :max) :+\n  (lvar :min)) / var :max) :+\n  ((send\n  (lvar :max) :+\n  (lvar :min)) / var :min)) / ","(senmax - \n  (lvar :max) :+\n  (lvar :min)) / ","(send\n  (lvar :max) :+\n  (lvar :(lvar :r) min )) / ","(send\n  (lvar :(lvar :r) max ) :+\n  (lvar :min)) / ","(lvar :r) max  + ","(lvar :r) max  - ","((send\n  (lvar :max) :+\n  (lvar :min)) / var :r) min ","(lvar :r) (lvar :r) min  ","((send\n  (lvar :max) :+\n  (lvar :min)) / var :r) max ","(lvar :r) (lvar :r) max  ","(sym :remax - ) map "]}," Script Color hue_to_rgb":{"type":"method","name":"hue_to_rgb","children":[],"call":["m1 + ","(send\n  (lvar :m2) :-\n  (lvar :m1)) * * ","(send\n  (lvar :m2) :-\n  (lvar :m1)) * ","2.0 / - ","2.0 / ","m2 - ","h * < ","h * ","h > ","h < "]}," Script Color hsl_to_rgb!":{"type":"method","name":"hsl_to_rgb!","children":[],"call":["(send\n  (lvar :c) :*\n  (int 255)) round ","c * ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :m2)\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map "," hue_to_rgb ","h - ","1.0 / ","h + ","@attrs []= ","l * - ","l * ","l + - ","l + ","s + ","l <= ","@attrs [] / ","@attrs [] ","(send\n  (@attrs [] / var :c) :*\n  (int 255)) round ","(@attrs [] / end\n  (lvar :c) :*\n  (int 255)) round ","(send nil :hue_to_rgb\n  (lvar :l * - )\n  (lvar :m2)\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :l + - )\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :l * )\n  (send\n    (lvar :h) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map ","(send ni@attrs [] /  :hue_to_rgb\n  (@attrs [] / var :m1)\n  (@attrs [] / var :m2)\n  (send\n    (@attrs [] / var :h) :+\n    (send\n      (f@attrs [] / oat 1.0) :/\n      (int 3)))) map ","(@attrs [] / end nil :hue_to_rgb\n  (lvar :m1)\n  (lvar :m2)\n  (@attrs [] / end\n    (lvar :h) :+\n    (@attrs [] / end\n      (float 1.0) :/\n      (int 3)))) map ","(send nil :@attrs [] / ue_to_rgb\n  (lvar :m1)\n  (lvar :m2)\n  (send\n    (lvar :@attrs [] / ) :+\n    (send\n      (float 1.0) :/\n      (int 3)))) map "," @attrs [] / ue_to_rgb ","@attrs [] /  - ","@attrs [] /  + ","@attr@attrs [] /  []= ","@attrs [] /  * - ","@attrs [] /  * ","@attrs [] /  + - ","@attrs [] /  <= ","@attr@attrs [] /  [] / ","@attr@attrs [] /  [] "]}," Script Color hex_str":{"type":"method","name":"hex_str","children":[],"call":["num to_s rjust ","num to_s "," rgb map "," rgb "]}," Script Color rgba_str":{"type":"method","name":"rgba_str","children":[],"call":[" alpha "," alpha to_i "," alpha % == "," alpha % "," rgb join "," rgb ","Number  round "," options [] == "," options [] "," options "]}," Script Color smallest":{"type":"method","name":"smallest","children":[],"call":["color size <= ","small_hex_str size ","color size ","HTML4_COLORS_REVERSE  [] "," rgb "," hex_str gsub "," hex_str ","HTML4_COLORS_REVERSE  []  size <= "," hex_str gsub  size ","HTML4_COLORS_REVERSE  []  size "]}," Script Color inspect":{"type":"method","name":"inspect","children":[],"call":[" hex_str "," rgba_str "," alpha? "]}," Script Color eq":{"type":"method","name":"eq","children":[],"call":["Sass Script Bool  new "," alpha == ","other alpha "," alpha "," rgb == ","other rgb "," rgb ","other is_a? "]}," Script Color hsl":{"type":"method","name":"hsl","children":[],"call":["(send nil :hue) freeze "," lightness "," saturation "," hue "]}," Script Color alpha?":{"type":"method","name":"alpha?","children":[],"call":[" alpha < "," alpha "]}," Script Color alpha":{"type":"method","name":"alpha","children":[],"call":["@attrs [] "]}," Script Color lightness":{"type":"method","name":"lightness","children":[],"call":["@attrs [] "," rgb_to_hsl! "]}," Script Color saturation":{"type":"method","name":"saturation","children":[],"call":["@attrs [] "," rgb_to_hsl! "]}," Script Color hue":{"type":"method","name":"hue","children":[],"call":["@attrs [] "," rgb_to_hsl! "]}," Script Color blue":{"type":"method","name":"blue","children":[],"call":["@attrs [] "," hsl_to_rgb! "]}," Script Color green":{"type":"method","name":"green","children":[],"call":["@attrs [] "," hsl_to_rgb! "]}," Script Color red":{"type":"method","name":"red","children":[],"call":["@attrs [] "," hsl_to_rgb! "]}," Sass Plugin try_delete_css":{"type":"method","name":"try_delete_css","children":[],"call":["File  delete "," run_deleting_css ","File  exists? "]}," Sass Plugin watch":{"type":"method","name":"watch","children":[],"call":[" update_stylesheets "," try_delete_css "," run_template_deleted ","path delete "," run_template_created ","path create "," run_template_modified ","path update ","mon file ","individual_files each ","File  join ","relative gsub ","path glob ","mon path "," template_locations zip each "," template_locations zip "," css_locations "," template_locations ","FSSM  monitor ","FSSM Backends  const_set ","Haml Util  silence_warnings "," require ","FSSM Backends Default  name == ","FSSM Backends Default  name ","individual_files empty? "," raise ","e message << << ","File  exists? "," scope ","e message << ","e message "," template_location_array each "," template_location_array "," try_delete_File  join  "," File  join _locations "]}," Sass Plugin force_update_stylesheets":{"type":"method","name":"force_update_stylesheets","children":[],"call":[" options= "," update_stylesheets "," options []= "," options "," options dup "]}," Sass Plugin StalenessChecker compute_dependencies":{"type":"method","name":"compute_dependencies","children":[],"call":["(send\n  (send\n    (const nil :Files) :tree_for\n    (lvar :filename)\n    (send\n      (const nil :Plugin) :engine_options)) :grep\n  (const\n    (const nil :Tree) :ImportNode)) compact ","File  expand_path ","n full_filename ","n full_filename =~ ","Files  tree_for grep ","Files  tree_for ","Plugin  engine_options "]}," Sass Plugin StalenessChecker dependency_updated?":{"type":"method","name":"dependency_updated?","children":[],"call":[" dependencies_stale? "," mtime > "," mtime "," lambda "]}," Sass Plugin StalenessChecker dependencies":{"type":"method","name":"dependencies","children":[],"call":["@dependencies []= "," compute_dependencies "," mtime ","stored_mtime < ","stored_mtime ! ","@dependencies [] ","@ compute_dependencies  []= "," compute_ compute_dependencies  ","@ compute_dependencies  [] "]}," Sass Plugin StalenessChecker mtime":{"type":"method","name":"mtime","children":[],"call":["@dependencies delete ","File  mtime to_i ","File  mtime ","@mtimes [] "]}," Sass Plugin StalenessChecker dependencies_stale?":{"type":"method","name":"dependencies_stale?","children":[],"call":["timestamps []= "," dependencies any? "," dependency_updated? "," dependencies ","checked_css_mtime > ","is_stale ! ","checked_css_mtime <= ","timestamps each_pair ","@dependencies_stale [] "]}," Sass Plugin StalenessChecker stylesheet_needs_update?":{"type":"method","name":"stylesheet_needs_update?","children":[],"call":[" dependency_updated? call "," dependency_updated? ","css_mtime == "," mtime ","File  expand_path ","@dependencies delete "," dependencies_stale? "," mtime > ","File  exists? "," mtime  == "]}," Sass Plugin StalenessChecker initialize":{"type":"method","name":"initialize","children":[],"call":[" class dependencies_cache "," class "]}," Less Engine parse_with_sass":{"type":"method","name":"parse_with_sass","children":[],"call":[" raise ","e modify_backtrace "," parse_without_sass "]}," Less Engine initialize_with_sass":{"type":"method","name":"initialize_with_sass","children":[],"call":["obj path ","obj is_a? "," initialize_without_sass "]}," Less Node FontFamily to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script Operation  new ","(send\n  (ivar :@family) :map) inject ","f to_sass_tree ","@family map "]}," Less Node Quoted to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script String  new "]}," Less Node Anonymous to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script String  new "]}," Less Node Keyword to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script String  new "]}," Less Node Function to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script Funcall  new ","a to_sass_tree ","@args map "]}," Less Node Variable to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script Variable  new ","node line= "," src_line ","Sass Tree VariableNode  new ","@value to_sass_tree "," hide_in_sass ","Sass Tree VariableNode  new  line= "]}," Less Node Number to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script Number  new "," unit "]}," Less Node Color to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Script Color  new "," a "," b "," g "," r "]}," Less Node Expression _sass_split":{"type":"method","name":"_sass_split","children":[],"call":["arr [] ","i + "," _to_sass_tree ","parens == ","e == ","arr [] each_with_index ","arr [] to_sass_tree ","arr [] == "]}," Less Node Expression _to_sass_tree2":{"type":"method","name":"_to_sass_tree2","children":[],"call":["Sass Script Operation  new "," _to_sass_tree ","rest [] "," _to_sass_tree2 "," _sass_split ","op == ","LESS_TO_SASS_OPERATORS  [] ","rest [] is_a? ","rest empty? ","LESS_TO_SASS_OPERATORS  []  == "]}," Less Node Expression _to_sass_tree":{"type":"method","name":"_to_sass_tree","children":[],"call":[" _to_sass_tree2 "," _sass_split ","Sass Script UnaryOperation  new "," _to_sass_tree ","arr [] ","arr [] == ","Sass Script Operation  new "," _to_sass_tree_plus_minus_eq ","rest empty? "," _to_sass_trSass Script Operation  new Sass Script Operation  new 2 ","Sass Script UnaryOpSass Script Operation  new ration  nSass Script Operation  new w "," _to_sass_trSass Script Operation  new Sass Script Operation  new  ","Sass Script OpSass Script Operation  new ration  nSass Script Operation  new w "," _to_sass_trSass Script Operation  new Sass Script Operation  new _plus_minus_Sass Script Operation  new q ","rSass Script Operation  new st Sass Script Operation  new mpty? "]}," Less Node Expression to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["val options= "," _to_sass_tree ","Sass Script Operation  new ","(send nil :map) inject "," map "," first is_a? "," first "," _to_sass_tree  options= "]}," Less Node Property to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Tree PropNode  new ","@value to_sass_tree "," hide_in_sass "]}," Less Node SassNode to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":[" hide_in_sass "]}," Less Node SassNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Less Node Mixin Def to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["mixin << ","r to_sass_tree "," rules each "," rules ","Sass Tree MixinDefNode  new ","v value to_sass_tree ","v value ","Sass Script Variable  new ","v value flatten! ","@params map "," name "," hide_in_sass ","Sass Tree MixinDefNode  new  << "]}," Less Node Mixin Call to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["Sass Tree MixinNode  new ","v to_sass_tree ","@params map ","@mixin name gsub ","@mixin name "," hide_in_sass "]}," Less Node Element sass_selector_str":{"type":"method","name":"sass_selector_str","children":[],"call":["@selector + "]}," Less Node Element to_sass_tree":{"type":"method","name":"to_sass_tree","children":[],"call":["rule << ","r to_sass_tree ","last_el rules each ","last_el rules ","Sass Tree RuleNode  new ","(send\n  (send nil :group) :map) join ","comma_sel gsub! "," parent root? "," parent ","comma_sel join gsub ","comma_sel join ","el rules first ","el rules ","el rules first is_a? ","el rules size == ","el rules size ","comma_sel << ","el sass_selector_str "," loop "," group map "," group "," equal? ! "," equal? "," group first "," hide_in_sass ","root << "," rules each "," rules ","Sass Tree RootNode  new "," root? ","Sass Tree RuleNode  new  << ","last_el Sass Tree RuleNode  new s each ","last_el rules first  rules each ","last_el Sass Tree RuleNode  new s ","last_el rules first  rules ","comma_(send\n  (send nil :group) :map) join  gsub! ","comma_sel join gsub  gsub! ","comma_sel rules first  gsub! "," parent Sass Tree RootNode  new ? ","comma_(send\n  (send nil :group) :map) join  join gsub ","comma_sel join gsub  join gsub ","comma_sel rules first  join gsub ","comma_(send\n  (send nil :group) :map) join  join ","comma_sel join gsub  join ","comma_sel rules first  join ","el Sass Tree RuleNode  new s first ","el rules first  rules first ","el Sass Tree RuleNode  new s ","el rules first  rules ","el Sass Tree RuleNode  new s first is_a? ","el rules first  rules first is_a? ","el Sass Tree RuleNode  new s size == ","el rules first  rules size == ","el Sass Tree RuleNode  new s size ","el rules first  rules size ","comma_(send\n  (send nil :group) :map) join  << ","comma_sel join gsub  << ","comma_sel rules first  << ","el sass_(send\n  (send nil :group) :map) join ector_str ","el rules first  sass_sel rules first ector_str ","Sass Tree RootNode  new  << "," Sass Tree RuleNode  new s each "," Sass Tree RuleNode  new s "," Sass Tree RootNode  new ? "]}," Less Node Element top":{"type":"method","name":"top","children":[],"call":[" parent top "," parent "," parent equal? "]}," Less StyleSheet Alpha1 build":{"type":"method","name":"build","children":[],"call":["Node Function  new ","Node Expression  new "," variable build "," variable ","Node Operator  new ","Node Keyword  new "]}," Less StyleSheet Import1 build_with_sass":{"type":"method","name":"build_with_sass","children":[],"call":[" raise ","Sass SyntaxError  new "," url text_value "," url ","r hide_in_sass= ","(send\n  (send\n    (lvar :env) :rules) :-\n  (lvar :old_rules)) each ","env rules - ","env rules "," build_without_sass ","env rules dup ","env << ","Node SassNode  new ","import line= "," input line_of "," interval first "," interval "," input ","Sass Tree ImportNode  new "," url value gsub "," url value ","(send\n  (send\n    (lvar :env) :rules) :-\n  (lvar :env rules dup )) each ","Sass Tree ImportNode  new  line= ","import  input line_of = "," input  input line_of _of "]}," Less StyleSheet Accessor1 build":{"type":"method","name":"build","children":[],"call":["Node Anonymous  new "," text_value ","Haml Util  haml_warn "]}," Less StyleSheet Selectors2 build_with_sass":{"type":"method","name":"build_with_sass","children":[],"call":["e group= ","rarr each ","e top ","arr map ","method == "," build_without_sass ","r build_without_sass  each "," build_without_sass  map "]}," Less StyleSheet Declaration3 build_with_sass":{"type":"method","name":"build_with_sass","children":[],"call":["env rules last src_line= "," input line_of "," interval first "," interval "," input ","env rules last ","env rules "," build_without_sass "]}," Less StyleSheet Mixin4 selector_str":{"type":"method","name":"selector_str","children":[],"call":["(send\n  (lvar :path) :map) join gsub ","(send\n  (lvar :path) :map) join ","e sass_selector_str ","path map "]}," Less StyleSheet Mixin4 selector_base":{"type":"method","name":"selector_base","children":[],"call":["(send\n  (const\n    (const nil :Node) :Element) :new\n  (send\n    (lvar :el) :name)\n  (lvar :sel)) + ","path [] ","i + ","Node Element  new ","el name ","el selector ","el selector =~ ","path first ","e selector !~ ","e selector ","Haml Util  enum_with_index to_a reverse find ","Haml Util  enum_with_index to_a reverse ","Haml Util  enum_with_index to_a ","Haml Util  enum_with_index "]}," Less StyleSheet Mixin4 build_with_sass":{"type":"method","name":"build_with_sass","children":[],"call":["env << ","Node SassNode  new ","Sass Tree ExtendNode  new ","Sass Tree CommentNode  new ","Haml Util  haml_warn ","base == "," selector_str "," selector_base ","Node Mixin Call  new ","el is_a? "," raise "," selectors text_value "," selectors ","current descend ","node selector ","path inject ","env root "," selectors build each "," selectors build "," selector_str  == ","  selector_str ector_str "," selector_ selector_str  ","  selector_str ector_base ","  selector_str ectors text_value ","  selector_str ectors ","node  selector_str ector ","  selector_str ectors build each ","  selector_str ectors build "]}," Sass SyntaxError header_string":{"type":"method","name":"header_string","children":[],"call":["e sass_backtrace_str + + ","(send\n  (send\n    (const\n      (const nil :Haml) :Util) :enum_with_index\n    (lvar :section)) :map) join ","line_offset + + ","line_offset + ","Haml Util  enum_with_index map ","Haml Util  enum_with_index ","e sass_backtrace_str + ","e sass_backtrace_str ","section empty? ","section nil? ","e sass_template rstrip split [] ","line_num + ","e sass_template rstrip split ","e sass_template rstrip ","e sass_template ","(send\n  (lvar :line_num) :-\n  (int 6)) max ","line_num - ","e sass_line + - ","e sass_line + ","e sass_line ","options [] ","e message ","e class ","e is_a? ","(send\n  (send\n    (const\n      (const nil :Haml) :Util) :enum_with_index\n    (lvar :e sass_template rstrip split [] )) :map) join ","e sass_template rstrip split []  empty? ","e sass_template rstrip split []  nil? ","e sass_line + -  + ","(send\n  (lvar :e sass_line + - ) :-\n  (int 6)) max ","e sass_line + -  - "]}," Sass SyntaxError exception_to_css":{"type":"method","name":"exception_to_css","children":[],"call":["header gsub gsub ","header gsub ","e backtrace join ","e backtrace "," header_string "," raise ","options [] "," header_string  gsub gsub "," header_string  gsub ","  header_string _string "]}," Sass SyntaxError sass_backtrace_str":{"type":"method","name":"sass_backtrace_str","children":[],"call":["(str \"Syntax error: \") + ","(send\n  (send\n    (const\n      (const nil :Haml) :Util) :enum_with_index\n    (send nil :sass_backtrace)) :map) join ","(str \"\\n        \") + + ","entry [] ","(str \"\\n        \") + ","i == ","Haml Util  enum_with_index map ","Haml Util  enum_with_index "," sass_backtrace "," message ","lines [] + ","(send\n  (send\n    (lvar :lines) :[]\n    (irange\n      (int 1)\n      (int -1))) :map) join ","\n + + ","\n + ","  * ","Syntax error:  size ","lines [] map ","lines [] "," message split "," message split  [] + ","(send\n  (send\n    (lvar : message split ) :[]\n    (irange\n      (int 1)\n      (int -1))) :map) join "," message split  [] map "," message split  [] "]}," Sass SyntaxError backtrace":{"type":"method","name":"backtrace","children":[],"call":["(send\n  (send nil :sass_backtrace) :map) + ","(begin\n  (or\n    (send\n      (lvar :h) :[]\n      (sym :filename))\n    (str \"(sass)\"))) + ","h [] "," sass_backtrace map "," sass_backtrace "," nil? "]}," Sass SyntaxError modify_backtrace":{"type":"method","name":"modify_backtrace","children":[],"call":["attrs empty? ","entry include? ","attrs reject! "," sass_backtrace []= ","attrs merge "," sass_backtrace "," sass_backtrace [] ","(erange\n  (int 0)\n  (send\n    (send nil :sass_backtrace) :size)) to_a reverse each ","(erange\n  (int 0)\n  (send\n    (send nil :sass_backtrace) :size)) to_a reverse ","(erange\n  (int 0)\n  (send\n    (send nil :sass_backtrace) :size)) to_a "," sass_backtrace size ","v nil? ","attrs reject "," sass_backtrace []  include? "]}," Sass SyntaxError add_backtrace":{"type":"method","name":"add_backtrace","children":[],"call":[" sass_backtrace << ","v nil? ","attrs reject "," sass_backtrace "]}," Sass SyntaxError sass_line":{"type":"method","name":"sass_line","children":[],"call":[" sass_backtrace first [] "," sass_backtrace first "," sass_backtrace "]}," Sass SyntaxError sass_mixin":{"type":"method","name":"sass_mixin","children":[],"call":[" sass_backtrace first [] "," sass_backtrace first "," sass_backtrace "]}," Sass SyntaxError sass_filename":{"type":"method","name":"sass_filename","children":[],"call":[" sass_backtrace first [] "," sass_backtrace first "," sass_backtrace "]}," Sass Environment stack":{"type":"method","name":"stack","children":[],"call":["@parent stack "]}," Sass Environment pop_frame":{"type":"method","name":"pop_frame","children":[],"call":[" stack pop "," stack "," stack last [] "," stack last "," mixins_in_use delete ","popped [] "," mixins_in_use "," stack pop  [] "]}," Sass Environment prepare_frame":{"type":"method","name":"prepare_frame","children":[],"call":[" push_frame ","frame_info merge "]}," Sass Environment push_frame":{"type":"method","name":"push_frame","children":[],"call":[" stack push "," stack "," stack last merge! "," stack last "," stack last delete "," stack last [] "," mixins_in_use << "," mixins_in_use "," stack last [] ! "]}," Sass Engine parse_interp":{"type":"method","name":"parse_interp","children":[],"call":[" class parse_interp "," class "]}," Sass Engine format_comment_text":{"type":"method","name":"format_comment_text","children":[],"call":["/* + + ","/* + ","content join ","// + ","content last gsub! ","content last ","content first gsub! ","content first ","(if\n  (send\n    (lvar :l) :empty?)\n  (str \"\")\n  (str \" \")) + ","l empty? ","content map! ","l gsub! ","content each ","content empty? ","content shift ","content first strip empty? ","content first strip ","text split ","content join gsub ","text split  join ","text split  last gsub! ","text split  last ","text split  first gsub! ","text split  first ","text split  map! ","text split  each ","text split  empty? ","text split  shift ","text split  first strip empty? ","text split  first strip ","text split  join gsub "]}," Sass Engine parse_property_or_rule":{"type":"method","name":"parse_property_or_rule","children":[],"call":["Tree RuleNode  new ","res + "," parse_interp ","scanner rest ","res pop "," parse_property ","scanner [] ","scanner scan ","line text [] ","scanner pos ","line text ","res << ","res unshift ","parser parse_interp_ident ","Sass SCSS SassParser  new ","StringScanner  new ","parser parse_interp_ident  + ","scanner parser parse_interp_ident t ","StringScanner  new  rest ","parser parse_interp_ident  pop ","StringScanner  new  [] ","StringScanner  new  scan ","StringScanner  new  pos ","parser parse_interp_ident  << ","parser parse_interp_ident  unshift ","Sass SCSS SassParser  new  parse_interp_ident "]}," Sass Engine _to_tree":{"type":"method","name":"_to_tree","children":[],"call":[" raise ","e sass_template= ","e modify_backtrace ","@options [] ","root options= "," append_children "," tree first "," tree "," tabulate ","Tree RootNode  new ","Sass SCSS Parser  new parse ","Sass SCSS Parser  new ","@options [] == ","Sass SyntaxError  new "," check_encoding "," check_encoding! ","Tree RootNode  new  options= ","Sass SCSS Parser  new parse  options= "]}," Callbacks define_callback":{"type":"method","name":"define_callback","children":[],"call":[" class_eval ","name inspect "]}," Haml Util lcs_backtrace":{"type":"method","name":"lcs_backtrace","children":[],"call":[" lcs_backtrace ","i - ","j - ","c [] [] > ","c [] [] ","c [] "," lcs_backtrace << ","y [] ","x [] ","j == ","i == "]}," Haml Util lcs_table":{"type":"method","name":"lcs_table","children":[],"call":["c [] []= ","(send\n  (send\n    (lvar :c) :[]\n    (lvar :i)) :[]\n  (send\n    (lvar :j) :-\n    (int 1))) max ","c [] [] ","c [] ","i - ","j - ","c [] [] + ","y [] ","x [] ","(erange\n  (int 1)\n  (send\n    (lvar :y) :size)) each ","y size ","(erange\n  (int 1)\n  (send\n    (lvar :x) :size)) each ","x size ","y size times ","x size times ","Array  new "]}," Haml Util set_eql?":{"type":"method","name":"set_eql?","children":[],"call":["(send\n  (send\n    (send\n      (lvar :set1) :to_a) :uniq) :sort_by) eql? ","e hash ","set2 to_a uniq sort_by ","set2 to_a uniq ","set2 to_a ","set1 to_a uniq sort_by ","set1 to_a uniq ","set1 to_a ","set1 eql? "," ruby1_8_6? "]}," Haml Util set_hash":{"type":"method","name":"set_hash","children":[],"call":["(send\n  (lvar :set) :map) uniq sort hash ","(send\n  (lvar :set) :map) uniq sort ","(send\n  (lvar :set) :map) uniq ","e hash ","set map ","set hash "," ruby1_8_6? "]}," Haml Util flatten":{"type":"method","name":"flatten","children":[],"call":["res << ","res concat "," flatten ","n - ","e is_a? ","arr inject ","n == ","arr flatten "," ruby1_8_6? "]}," Haml Util ord":{"type":"method","name":"ord","children":[],"call":["c ord ","c [] "," ruby1_8? "]}," Haml Util enum_slice":{"type":"method","name":"enum_slice","children":[],"call":["enum each_slice ","enum enum_slice "," ruby1_8? "]}," Haml Util enum_cons":{"type":"method","name":"enum_cons","children":[],"call":["enum each_cons ","enum enum_cons "," ruby1_8? "]}," Haml Util check_encoding":{"type":"method","name":"check_encoding","children":[],"call":["i + ","(str \"Invalid \") rstrip ","e error_char dump ","e error_char ","encoding name ","line encode ","str force_encoding split each_with_index ","str force_encoding split ","str force_encoding ","Regexp  new ","\r\n|\r|\n encode force_encoding ","\r\n|\r|\n encode ","str encoding ","str gsub ","\\A encode ","str encoding name ","str encoding name =~ ","str valid_encoding? "," ruby1_8? ","str encoding == ","str encoding  name ","str force_str encoding  split each_with_index ","str force_str encoding  split ","str force_str encoding  ","\r\n|\r|\n encode force_str encoding  ","str str encoding  ","str str encoding  name ","str str encoding  name =~ ","str valid_str encoding ? ","str str encoding  == "]}," Haml Util ruby1_8_6?":{"type":"method","name":"ruby1_8_6?","children":[],"call":["Haml Util RUBY_VERSION  [] < ","Haml Util RUBY_VERSION  [] "," ruby1_8? "]}," Haml Util haml_warn":{"type":"method","name":"haml_warn","children":[],"call":[" warn "]}," Haml Util silence_haml_warnings":{"type":"method","name":"silence_haml_warnings","children":[],"call":[]}," Haml Util caller_info":{"type":"method","name":"caller_info","children":[],"call":["info []= ","info [] to_i ","info [] ","entry scan first ","entry scan ","info [] sub! ","entry scan first  []= ","entry scan first  [] to_i ","entry scan first  [] ","entry scan first  [] sub! "]}," Haml Util lcs":{"type":"method","name":"lcs","children":[],"call":[" lcs_backtrace ","y size - ","y size ","x size - ","x size "," lcs_table ","a == "," proc "]}," Haml Util paths":{"type":"method","name":"paths","children":[],"call":[" flatten ","path + ","paths map ","arr map ","arrs inject ","(send\n  (lvar :arr) :map) flatten "]}," Haml Util strip_string_array":{"type":"method","name":"strip_string_array","children":[],"call":["arr last rstrip! ","arr last ","arr last is_a? ","arr first lstrip! ","arr first ","arr first is_a? "]}," Haml Util substitute":{"type":"method","name":"substitute","children":[],"call":["res []= ","i + ","from size ","res [] == ","res [] ","i < ","res size ","ary dup ","ary dup  []= ","ary dup  [] == ","ary dup  [] ","ary dup  size "]}," Haml Util intersperse":{"type":"method","name":"intersperse","children":[],"call":["(send\n  (lvar :enum) :inject\n  (array)) [] ","a << << ","a << ","enum inject "]}," Haml Util restrict":{"type":"method","name":"restrict","children":[],"call":["(send\n  (array\n    (lvar :value)\n    (send\n      (lvar :range) :first)) :max) min ","range last ","(lvar :value) max ","range first "]}," Haml Util SubsetMap []":{"type":"method","name":"[]","children":[],"call":[" get map "," get "]}," Haml Util SubsetMap get":{"type":"method","name":"get","children":[],"call":["@vals [] ","res map! ","res sort! ","res uniq! ","res compact! ","Haml Util  flatten ","subset subset? ","subsets map ","@hash [] ","set map ","res flatten! ","Haml Util  flatten  map! ","Haml Util  flatten  sort! ","Haml Util  flatten  uniq! ","Haml Util  flatten  compact! ","@hash []  map ","Haml Util  flatten  flatten! "]}," Haml Util SubsetMap []=":{"type":"method","name":"[]=","children":[],"call":["@hash [] << ","set to_set ","@hash [] ","set each ","@vals << ","@vals size "," raise ","ArgumentError  new ","set empty? "]}," Haml Util SubsetMap empty?":{"type":"method","name":"empty?","children":[],"call":["@hash empty? "]}," Haml Util SubsetMap initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml HTML Elem haml_css_attr?":{"type":"method","name":"haml_css_attr?","children":[],"call":["attr =~ "]}," Haml HTML Elem to_haml_filter":{"type":"method","name":"to_haml_filter","children":[],"call":[" tabulate ","content gsub! ","tabs + ","l =~ ","l strip empty? ","l strip ","content split all? ","content split ","content [] "," erb_to_interpolation ","CGI  unescapeHTML "," innerText "," children first content "," children first "," children "," children first is_a? "," erb_to_interpolation  gsub! ","CGI  unescapeHTML  gsub! "," children first content  gsub! "," erb_to_interpolation  split all? ","CGI  unescapeHTML  split all? "," children first content  split all? "," erb_to_interpolation  split ","CGI  unescapeHTML  split "," children first content  split "," erb_to_interpolation  [] ","CGI  unescapeHTML  [] "," children first content  [] "," children first  erb_to_interpolation  "," children first CGI  unescapeHTML  "," children first  children first content  "]}," Haml HTML Elem render_children":{"type":"method","name":"render_children","children":[],"call":["output + ","child to_haml ","tabs + ","(or\n  (send\n    (self) :children)\n  (array)) inject "," children "]}," Haml HTML Node parse_text_with_interpolation":{"type":"method","name":"parse_text_with_interpolation","children":[],"call":["(send\n  (send\n    (lvar :text) :split\n    (str \"\\n\")) :map) join ","Haml Engine SPECIAL_CHARACTERS  include? ","line [] "," tabulate ","line strip! ","text split map ","text split ","text empty? ","text strip! "]}," Haml HTML Node uninterp":{"type":"method","name":"uninterp","children":[],"call":["text gsub "]}," Haml HTML Node erb_to_interpolation":{"type":"method","name":"erb_to_interpolation","children":[],"call":["str + + + ","str + + ","CGI  unescapeHTML ","elem innerText strip ","elem innerText ","str + ","elem to_s ","elem is_a? "," Hpricot  XML children inject "," Hpricot  XML children "," Hpricot  XML ","text gsub! ","CGI  escapeHTML ","(str \"<haml:loud>\") each "," uninterp ","options [] ","CGI  escapeHTML  gsub! "]}," Haml HTML ERB mid_block?":{"type":"method","name":"mid_block?","children":[],"call":[" valid_ruby? "]}," Haml HTML ERB block_closer?":{"type":"method","name":"block_closer?","children":[],"call":[" valid_ruby? ","begin\n + "]}," Haml HTML ERB block_opener?":{"type":"method","name":"block_opener?","children":[],"call":[" valid_ruby? ","code + "]}," Haml HTML ERB valid_ruby?":{"type":"method","name":"valid_ruby?","children":[],"call":["RubyParser  new parse ","RubyParser  new "]}," Haml HTML ERB h":{"type":"method","name":"h","children":[],"call":["CGI  escapeHTML "]}," Haml HTML ERB add_expr_debug":{"type":"method","name":"add_expr_debug","children":[],"call":[" raise ","Haml Error  new "]}," Haml HTML ERB add_expr_literal":{"type":"method","name":"add_expr_literal","children":[],"call":["src << "," block_opener? ","src << << << ","src << << "," h "]}," Haml HTML ERB add_stmt":{"type":"method","name":"add_stmt","children":[],"call":["src << "," mid_block? "," block_opener? ","src << << << ","src << << "," h ","code strip == ","code strip "," block_closer? "]}," Haml HTML ERB add_text":{"type":"method","name":"add_text","children":[],"call":["src << "]}," Haml HTML ERB add_postamble":{"type":"method","name":"add_postamble","children":[],"call":[]}," Haml HTML ERB add_preamble":{"type":"method","name":"add_preamble","children":[],"call":[]}," Haml HTML ERB escaped_expr":{"type":"method","name":"escaped_expr","children":[],"call":[" raise ","Haml Error  new "]}," Haml HTML ERB compile":{"type":"method","name":"compile","children":[],"call":[]}," Haml Helpers merge_name_and_attributes":{"type":"method","name":"merge_name_and_attributes","children":[],"call":["Buffer  merge_attrs ","key to_s ","Haml Util  map_keys ","Precompiler  parse_class_and_id ","name =~ ","Haml Parser  parse_class_and_id ","AttributeBuilder  merge_attributes! "]}," ActionView Helpers CacheHelper fragment_for_with_haml":{"type":"method","name":"fragment_for_with_haml","children":[],"call":[" capture "," fragment_for_without_haml "," controller perform_caching "," controller "]}," Haml Filters Css render_with_options":{"type":"method","name":"render_with_options","children":[],"call":["text rstrip gsub ","text rstrip ","options [] ","options [] == ","str << ","text gsub! ","text rstrip  rstrip gsub ","text rstrip  rstrip ","text rstrip  gsub! "]}," Haml Exec SassConvert try_less_note":{"type":"method","name":"try_less_note","children":[],"call":[" warn "]}," Haml Exec SassConvert process_file":{"type":"method","name":"process_file","children":[],"call":[" handle_load_error "," raise ","e message ","e sass_line ","e sass_filename ","@options [] ","output write ","File  open ","input path ","(send\n  (lvar :input) :is_a?\n  (const nil :File)) send "," Sass Engine  new to_tree "," Sass Engine  new ","input read "," Sass Files  tree_for ","input is_a? ","Less Engine  new to_tree to_sass_tree send ","Less Engine  new to_tree to_sass_tree ","Less Engine  new to_tree ","Less Engine  new ","input is_a? ! "," try_less_note "," require ","@options [] == "," Sass CSS  new render "," Sass CSS  new "," Haml Util  silence_haml_warnings ","@options [] []= ","@options []= ","output path ","output is_a? "," get_line ","File  open  write ","input read  path ","(send\n  (lvar :input read ) :is_a?\n  (const nil :File)) send ","input read  read ","input read  is_a? ","input read  is_a? ! ","File  open  path ","File  open  is_a? "]}," Haml Exec SassConvert process_directory":{"type":"method","name":"process_directory","children":[],"call":[" process_file "," open_file ","@options [] "," puts_action ","File  exists? ","FileUtils  mkdir_p ","File  dirname ","File  directory? ","f gsub ","output_name []= ","@options [] size ","Dir  glob ","ext == "," raise ","@options [] ! ","@options [] == ","File  directory? ! ","@options []= ","@args shift ","from == "," open_file _name []= ","@options []= _name []= ","f gsub  []= ","@options []  == "]}," Haml Exec SassConvert process_result":{"type":"method","name":"process_result","children":[],"call":[" process_file ","@options [] "," raise ","input path ","File  directory? "," process_directory "," require ","e message "," get_line ","output write ","File  open ","(send\n  (lvar :input) :is_a?\n  (const nil :File)) send "," Sass Engine  new to_tree "," Sass Engine  new ","input read "," Sass Files  tree_for ","input is_a? "," Sass CSS  new render "," Sass CSS  new ","@options [] == "," Haml Util  silence_haml_warnings ","@options [] []= ","@options []= ","output path ","output is_a? ","@options []  path ","@options []  write ","File  open  write ","(send\n  (lvar :@options [] ) :is_a?\n  (const nil :File)) send ","@options []  read ","@options []  is_a? ","File  open  path ","File  open  is_a? "]}," Haml Exec SassConvert set_opts":{"type":"method","name":"set_opts","children":[],"call":["@options [] []= ","@options [] ","opts on ","@options []= "," raise ","(sym :scss) include? ","name downcase to_sym ","name downcase "," try_less_note ","@options [] == ","(sym :css) include? ","opts banner= ","Encoding  default_external= "," Haml Util  ruby1_8? "]}," Haml Exec SassConvert initialize":{"type":"method","name":"initialize","children":[],"call":["@options []= "," require "]}," Haml Exec Sass watch_or_update":{"type":"method","name":"watch_or_update","children":[],"call":[" Sass Plugin  watch "," puts "," Sass Plugin  on_template_deleted "," Sass Plugin  on_template_created "," Sass Plugin  on_template_modified "," Sass Plugin  update_stylesheets ","@options [] "," puts_action ","error message ","error sass_line ","error sass_filename "," raise ","error is_a? "," Sass Plugin  on_compilation_error "," Sass Plugin  on_deleting_css "," Sass Plugin  on_creating_directory ","File  exists? "," Sass Plugin  on_updating_stylesheet "," Sass Plugin  options []= "," Sass Plugin  options ","dirs map! ","from gsub ","files map! ","File  directory? ","(send\n  (ivar :@args) :map) partition ","name split ","@args map ","@args [] ","@args [] =~ ","File  exist? ! ","File  exist? ","@args [] include? ! ","@args [] include? "," Sass Plugin  options merge! "," require ","(send\n  (block\n    (send\n      (ivar :@args) :map)\n    (args\n      (arg :name))\n    (send\n      (lvar :name) :split\n      (str \":\")\n      (int 2))) :map) partition ","(send\n  (ivar :@args) :map) map "," split_colon_path "," colon_path? ! "," colon_path? "," exit "," p "," probably_dest_dir? ","@args empty? ","@options [] ! "]}," Haml Exec Sass interactive":{"type":"method","name":"interactive","children":[],"call":[" Sass Repl  new run "," Sass Repl  new "," require "]}," Haml Exec Generic handle_load_error":{"type":"method","name":"handle_load_error","children":[],"call":[" exit ","$stderr puts "," raise ","dep empty? ","dep nil? ","@options [] ","err message scan [] ","err message scan ","err message ","err message [] ","err message scan []  empty? ","err message []  empty? ","err message scan []  nil? ","err message []  nil? "]}," Haml Exec Generic color":{"type":"method","name":"color","children":[],"call":["COLORS  [] ","STDOUT  tty? ! ","STDOUT  tty? ","ENV  [] empty? ","ENV  [] ","ENV  [] nil? "," raise "]}," Haml Exec Generic puts_action":{"type":"method","name":"puts_action","children":[],"call":[" printf "," color ","@options [] [] ","@options [] "]}," Haml Exec Generic parse":{"type":"method","name":"parse","children":[],"call":[" process_result ","@opts parse! ","OptionParser  new "," method ","OptionParser  new  parse! "]}," Sass Tree RootNode cssize!":{"type":"method","name":"cssize!","children":[],"call":[" raise ","Sass SyntaxError  new ","child line ","Properties aren't allowed at the root of a document. + ","child pseudo_class_selector_message ","c is_a? "," children find "," children "," children unshift "," children reject! ","parent nil? ","Haml Util  ruby1_8? ","child pseudo_class_selector_Properties aren't allowed at the root of a document. +  "]}," Sass SCSS Parser value":{"type":"method","name":"value","children":[],"call":[" sass_script ","Sass Script String  new "," tok? "," tok? ! ","(send nil :str) empty? ! ","(send nil :str) empty? "," ss "," str "," tok "]}," Sass SCSS Parser expected_property_separator":{"type":"method","name":"expected_property_separator","children":[],"call":[]}," Sass SCSS Parser functional_pseudo":{"type":"method","name":"functional_pseudo","children":[],"call":[" tok! "," expr! "," ss "," str "," tok "]}," Sass SCSS Parser class_expr":{"type":"method","name":"class_expr","children":[],"call":[". + "," tok! "," tok "]}," Sass SCSS Parser property":{"type":"method","name":"property","children":[],"call":[" ss ","res << "," tok "," interpolation "," str "]}," Sass SCSS Parser media":{"type":"method","name":"media","children":[],"call":[" block "," node ","Sass Tree DirectiveNode  new ","(send nil :str) strip "," media_query_list "," str "]}," Sass SCSS Parser import":{"type":"method","name":"import","children":[],"call":[" node ","Sass Tree ImportNode  new ","path strip ","Sass Tree DirectiveNode  new ","(str \"@import \") strip "," use_css_import? ","media strip empty? ! ","media strip empty? ","media strip ","(send nil :str) strip "," media_query_list "," str "," ss ","@scanner [] "," tok! "," tok ","(send nil :str) strip  strip empty? ! ","(send nil :str) strip  strip empty? ","(send nil :str) strip  strip "," (send nil :str) strip _query_list "]}," Sass SCSS Parser if":{"type":"method","name":"if","children":[],"call":[" else_block "," ss "," block "," node ","Sass Tree IfNode  new "," sass_script ","  block  "]}," Sass SCSS Parser while":{"type":"method","name":"while","children":[],"call":[" block "," node ","Sass Tree WhileNode  new "," ss "," sass_script "]}," Sass SCSS Parser for":{"type":"method","name":"for","children":[],"call":[" block "," node ","Sass Tree ForNode  new "," ss "," sass_script ","(or\n  (send nil :tok\n    (regexp\n      (str \"to\")\n      (regopt)))\n  (send nil :tok!\n    (regexp\n      (str \"through\")\n      (regopt)))) == "," tok! "," tok ","Set  [] ","(or\n  (send nil : sass_script k\n    (regexp\n      (str \" sass_script \")\n      (regopt)))\n  (send nil : sass_script k!\n    (regexp\n      (str \"through\")\n      (regopt)))) == ","  sass_script k! ","  sass_script k "]}," Sass SCSS Parser debug":{"type":"method","name":"debug","children":[],"call":[" node ","Sass Tree DebugNode  new "," sass_script "]}," Sass SCSS Parser include":{"type":"method","name":"include","children":[],"call":[" node ","Sass Tree MixinNode  new "," ss "," sass_script "," tok! "]}," Sass SCSS Parser mixin":{"type":"method","name":"mixin","children":[],"call":[" block "," node ","Sass Tree MixinDefNode  new "," ss "," sass_script "," tok! "]}," Sass SCSS CssParser expected_property_separator":{"type":"method","name":"expected_property_separator","children":[],"call":[]}," Sass SCSS CssParser variable":{"type":"method","name":"variable","children":[],"call":[]}," Haml Exec Sass color":{"type":"method","name":"color","children":[],"call":["COLORS  [] ","STDOUT  tty? ! ","STDOUT  tty? ","ENV  [] empty? ","ENV  [] "," raise "]}," Haml Exec Sass puts_action":{"type":"method","name":"puts_action","children":[],"call":[" printf "," color "]}," Sass SCSS Parser warn":{"type":"method","name":"warn","children":[],"call":[" node ","Sass Tree WarnNode  new "," sass_script "]}," Sass Selector SimpleSequence handle_extend_loop":{"type":"method","name":"handle_extend_loop","children":[],"call":[" raise ","Sass SyntaxError  new ","(send\n  (begin\n    (send\n      (send\n        (lvar :conses) :[]\n        (irange\n          (lvar :i)\n          (int -1))) :+\n      (send\n        (lvar :conses) :[]\n        (erange\n          (int 0)\n          (lvar :i))))) :map) join ","str << << ","sseq2 first filename ","sseq2 first ","str << ","sseq2 first line ","SimpleSequence  new inspect ","SimpleSequence  new ","(send\n  (send\n    (lvar :conses) :[]\n    (irange\n      (lvar :i)\n      (int -1))) :+\n  (send\n    (lvar :conses) :[]\n    (erange\n      (int 0)\n      (lvar :i)))) map ","conses [] + ","conses [] ","sseq1 first line <=> ","sseq1 first line ","sseq1 first ","Haml Util  enum_with_index max ","Haml Util  enum_with_index ","Haml Util  enum_cons to_a ","Haml Util  enum_cons ","sseqs push ","sseqs first eql? ","sseqs first ","supers inject ","(send\n  (begin\n    (send\n      (send\n        (lvar :Haml Util  enum_cons to_a ) :[]\n        (irange\n          (lvar :i)\n          (int -1))) :+\n      (send\n        (lvar :Haml Util  enum_cons to_a ) :[]\n        (erange\n          (int 0)\n          (lvar :i))))) :map) join ","(send\n  (send\n    (lvar :Haml Util  enum_cons to_a ) :[]\n    (irange\n      (lvar :i)\n      (int -1))) :+\n  (send\n    (lvar :Haml Util  enum_cons to_a ) :[]\n    (erange\n      (int 0)\n      (lvar :i)))) map ","Haml Util  enum_cons to_a  [] + ","Haml Util  enum_cons to_a  [] "]}," Sass Selector SimpleSequence eql?":{"type":"method","name":"eql?","children":[],"call":["other rest eql? "," rest ","other rest ","other base eql? "," base ","other base ","other class == "," class ","other class ","Haml Util  set_eql? "]}," Sass Selector SimpleSequence hash":{"type":"method","name":"hash","children":[],"call":["(send nil :base) hash "," rest "," base ","Haml Util  set_hash "]}," Sass Selector Sequence unify_heads":{"type":"method","name":"unify_heads","children":[],"call":["sseq1 [] << ","sseq1 [] ","sseq1 last unify ","sseq2 last members ","sseq2 last ","sseq1 last ","sseq2 last is_a? ","sseq1 last is_a? ","sseq2 size == ","sseq2 size "]}," Sass Selector Sequence seq_split":{"type":"method","name":"seq_split","children":[],"call":["head << ","tail shift ","tail first is_a? ","tail first ","head last is_a? ","head last ","tail empty? ! ","tail empty? ","seq dup ","seq dup  shift ","seq dup  first is_a? ","seq dup  first ","seq dup  empty? ! ","seq dup  empty? "]}," Sass Selector Sequence eql?":{"type":"method","name":"eql?","children":[],"call":["(send\n  (send\n    (lvar :other) :members) :reject) eql? ","m == "," members reject "," members ","other members reject ","other members ","other class == "," class ","other class "]}," Sass Selector Sequence hash":{"type":"method","name":"hash","children":[],"call":["(send\n  (send nil :members) :reject) hash ","m == "," members reject "," members "]}," Sass Selector CommaSequence eql?":{"type":"method","name":"eql?","children":[],"call":["other members eql? "," members ","other members ","other class == "," class ","other class "]}," Sass Selector CommaSequence hash":{"type":"method","name":"hash","children":[],"call":[" members hash "," members "]}," Sass Plugin normalize_template_location!":{"type":"method","name":"normalize_template_location!","children":[],"call":[" options []= "," options [] to_a "," options [] "," options ","File  join "," options [] is_a? "]}," Sass Plugin template_location_array":{"type":"method","name":"template_location_array","children":[],"call":[" options []= "," options "," options [] "," normalize_template_location! "]}," Sass Plugin remove_template_location":{"type":"method","name":"remove_template_location","children":[],"call":[" template_location_array delete "," template_location_array "," normalize_template_location! "]}," Sass Plugin add_template_location":{"type":"method","name":"add_template_location","children":[],"call":[" template_location_array << "," template_location_array "," normalize_template_location! "]}," Sass Callbacks define_callback":{"type":"method","name":"define_callback","children":[],"call":[" class_eval ","name inspect "]}," Tree MixinNode handle_include_loop!":{"type":"method","name":"handle_include_loop!","children":[],"call":[" raise ","Sass SyntaxError  new ","msg << << ","(send\n  (send\n    (const\n      (const nil :Haml) :Util) :enum_cons\n    (lvar :mixins)\n    (int 2)) :map) join ","Haml Util  enum_cons map ","Haml Util  enum_cons ","msg << ","mixins << ","mixins [] == ","mixins [] ","mixins size == ","mixins size ","(send\n  (send\n    (lvar :environment) :stack) :map) compact ","s [] ","environment stack map ","environment stack ","(send\n  (send\n    (const\n      (const nil :Haml) :Util) :enum_cons\n    (lvar :(send\n  (send\n    (lvar :environment) :stack) :map) compact )\n    (int 2)) :map) join ","(send\n  (send\n    (lvar :environment) :stack) :map) compact  << ","(send\n  (send\n    (lvar :environment) :stack) :map) compact  [] == ","(send\n  (send\n    (lvar :environment) :stack) :map) compact  [] ","(send\n  (send\n    (lvar :environment) :stack) :map) compact  size == ","(send\n  (send\n    (lvar :environment) :stack) :map) compact  size "]}," Sass Script Parser try_ops_after_interp":{"type":"method","name":"try_ops_after_interp","children":[],"call":["interp line= ","@lexer line ","Script Interpolation  new ","wb ! "," assert_expr ","str line= ","Script String  new ","Lexer OPERATORS_REVERSE  [] ","op type ","@lexer whitespace? "," try_op_before_interp "," try_tok ","@lexer after_interpolation? ","Script Interpolation  new  line= "," try_op_before_interp  line= ","Script String  new  line= "," try_tok  type "," try_op_before_Script Interpolation  new  "," try_op_before_ try_op_before_interp  "," try_ try_tok _before_interp ","@lexer after_Script Interpolation  new olation? ","@lexer after_ try_op_before_interp olation? "]}," Sass Script Parser try_op_before_interp":{"type":"method","name":"try_op_before_interp","children":[],"call":[" interpolation ","interp line= ","@lexer line ","Script Interpolation  new ","wa ! ","str line= ","Script String  new ","Lexer OPERATORS_REVERSE  [] ","op type ","@lexer whitespace? ","@lexer peek type == ","@lexer peek type ","@lexer peek "," Script Interpolation  new olation ","Script Interpolation  new  line= ","Script String  new  line= "]}," MerbBootLoader run":{"type":"method","name":"run","children":[],"call":[]}," Sass Environment mixins_in_use":{"type":"method","name":"mixins_in_use","children":[],"call":["@parent mixins_in_use "]}," Sass Engine check_encoding!":{"type":"method","name":"check_encoding!","children":[],"call":[" raise ","Sass SyntaxError  new "," check_sass_encoding "]}," Sass Engine _render":{"type":"method","name":"_render","children":[],"call":["rendered encode "," source_encoding "," ruby1_8? "," _to_tree render "," _to_tree ","rendered gsub ","(str \"@charset \\\"\") encode "," source_encoding name ","Regexp  new ","\\A@charset \"(.*?)\" encode "," _to_tree render  encode ","rendered encode  encode "," _to_tree render  gsub ","rendered encode  gsub "]}," Sass Engine source_encoding":{"type":"method","name":"source_encoding","children":[],"call":[" check_encoding! "]}," Sass CSS check_encoding!":{"type":"method","name":"check_encoding!","children":[],"call":[" raise ","Sass SyntaxError  new ","Haml Util  check_sass_encoding "]}," Sass CSS source_encoding":{"type":"method","name":"source_encoding","children":[],"call":[" check_encoding! "]}," Haml Util try_parse_haml_emacs_magic_comment":{"type":"method","name":"try_parse_haml_emacs_magic_comment","children":[],"call":["scanner pos= ","val =~ ","name =~ ","scanner [] ","scanner scan ","scanner pos ","scanner scanner pos = ","scanner scanner pos  "]}," Haml Util parse_haml_magic_comment":{"type":"method","name":"parse_haml_magic_comment","children":[],"call":["scanner [] ","scanner scan "," try_parse_haml_emacs_magic_comment ","StringScanner  new ","str dup force_encoding ","str dup ","StringScanner  new  [] ","StringScanner  new  scan ","str dup force_en try_parse_haml_emacs_magic_comment  "]}," Haml Util _enc":{"type":"method","name":"_enc","children":[],"call":["string encode force_encoding ","string encode "]}," Haml Util check_sass_encoding":{"type":"method","name":"check_sass_encoding","children":[],"call":["str encoding ","str encode "," check_encoding ","str force_encoding ","charset << ","Encoding  find ","charset + ","encoding [] ","charset force_encoding encode ","charset force_encoding ","bin =~ ","Haml Util CHARSET_REGEXPS  [] ","Haml Util ENCODINGS_TO_CHECK  find ","str dup force_encoding ","str dup "," ruby1_8? "," check_encoding  encoding "," check_encoding  encode "," check_encoding  force_encoding ","charset force_encoding encode  << ","charset force_encoding encode  + ","charset force_encoding encode  force_encoding encode ","charset force_encoding encode  force_encoding ","str dup force_encoding  =~ "," check_encoding  dup force_encoding "," check_encoding  dup "]}," Haml Util check_haml_encoding":{"type":"method","name":"check_haml_encoding","children":[],"call":[" check_encoding ","str force_encoding "," parse_haml_magic_comment "," ruby1_8? ","str dup ","str frozen? ","str dup  force_encoding ","str dup  dup ","str dup  frozen? "]}," Haml Plugin handles_encoding?":{"type":"method","name":"handles_encoding?","children":[],"call":[]}," Haml Util ap_geq?":{"type":"method","name":"ap_geq?","children":[],"call":["ActionPack VERSION STRING  >= "," version_geq "]}," Sass Selector SelectorPseudoClass to_a":{"type":"method","name":"to_a","children":[],"call":["(str \":\") + + ","(str \":\") + ","@selector to_a "]}," Sass Selector SelectorPseudoClass initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass Selector CommaSequence to_a":{"type":"method","name":"to_a","children":[],"call":["arr delete ","Haml Util  intersperse flatten ","Haml Util  intersperse ","m to_a ","@members map ","Haml Util  intersperse flatten  delete "]}," Sass SCSS Parser selector_comma_sequence":{"type":"method","name":"selector_comma_sequence","children":[],"call":["Selector CommaSequence  new ","selectors []= ","Selector Sequence  new ","(str \"\\n\") + ","selectors last members ","selectors last ","ws include? ","selectors << "," expr! "," ss "," str "," tok "," _selector "," _selector ectors []= "," _selector ectors last members "," _selector ectors last "," _selector ectors << "," _ _selector ector "]}," Sass Engine parse_import":{"type":"method","name":"parse_import","children":[],"call":["Tree ImportNode  new ","Tree DirectiveNode  new ","f =~ ","value split map ","value split ","match post_match strip [] != ","match post_match strip [] ","match post_match strip ","match post_match ","match post_match strip empty? ! ","match post_match strip empty? ","match offset first == ","match offset first ","match offset ","value match "," raise ","SyntaxError  new ","@line + ","line children empty? ","line children ","scanner scan ","values << ","scanner rest inspect ","scanner rest "," parse_import_arg "," loop ","StringScanner  new ","StringScanner  new  scan ","StringScanner  new  rest inspect ","StringScanner  new  rest "]}," Haml Util windows?":{"type":"method","name":"windows?","children":[],"call":["RbConfig CONFIG  [] =~ ","RbConfig CONFIG  [] "]}," Haml Exec Sass split_colon_path":{"type":"method","name":"split_colon_path","children":[],"call":["one + + ","one + ","two split ","two =~ ","one =~ ","path split "," Haml Util  windows? ","one + +  + + ","one + +  + ","one + +  =~ "]}," Haml Exec Sass colon_path?":{"type":"method","name":"colon_path?","children":[],"call":[" split_colon_path [] nil? ! "," split_colon_path [] nil? "," split_colon_path [] "," split_colon_path "]}," Sass Engine parse_import_arg":{"type":"method","name":"parse_import_arg","children":[],"call":["Tree ImportNode  new ","Tree DirectiveNode  new ","val =~ ","scanner scan ","scanner [] ","scanner eos? "]}," Haml Exec Sass probably_dest_dir?":{"type":"method","name":"probably_dest_dir?","children":[],"call":["Dir  glob empty? ","Dir  glob ","File  join "," colon_path? "]}," Sass SCSS CssParser parse_selector_string":{"type":"method","name":"parse_selector_string","children":[],"call":[" selector "," str "," init_scanner! "]}," Sass SCSS Parser has_children?":{"type":"method","name":"has_children?","children":[],"call":["child_or_array has_children ","child_or_array last has_children ","child_or_array last ","child_or_array is_a? "]}," Sass SCSS Parser import_arg":{"type":"method","name":"import_arg","children":[],"call":[" node ","Sass Tree ImportNode  new ","path strip ","Sass Tree DirectiveNode  new ","(str \"@import \") strip "," use_css_import? ","media strip empty? ! ","media strip empty? ","media strip ","path =~ ","(send nil :str) strip "," media_query_list "," str "," ss ","@scanner [] "," tok! "," tok ","(send nil :str) strip  strip empty? ! ","(send nil :str) strip  strip empty? ","(send nil :str) strip  strip "," (send nil :str) strip _query_list "]}," Haml Util version_geq":{"type":"method","name":"version_geq","children":[],"call":[" version_gt ! "," version_gt ","@@version_comparison_cache []= ","@@version_comparison_cache fetch ","@@version_comparison_cache key? "]}," Haml Util version_gt":{"type":"method","name":"version_gt","children":[],"call":["p1 > ","p1 == ","release2 ! ","release1 ! ","p2 to_i ","p1 to_i ","p2 =~ ","p1 =~ ","Array  new zip ","v2 split ","v1 split ","Array  new ","(send\n  (lvar :v1) :length) max ","v2 length ","v1 length ","p2 =~  ! ","p1 =~  ! "]}," Script Number round":{"type":"method","name":"round","children":[],"call":[]}," Script Node opts":{"type":"method","name":"opts","children":[],"call":["literal options= "," options "]}," Haml Util inspect":{"type":"method","name":"inspect","children":[],"call":["\" + + ","\" + ","s inspect [] ","s inspect ","obj gsub ","obj inspect ","obj is_a? ",": + "," inspect ","obj to_s "," version_geq "]}," Sass Script Parser associative?":{"type":"method","name":"associative?","children":[],"call":["ASSOCIATIVE  include? "]}," Less Node Expression _to_sass_tree_unary":{"type":"method","name":"_to_sass_tree_unary","children":[],"call":[" _sass_split ","arr [] ","Sass Script UnaryOperation  new ","arr [] == "]}," Less Node Expression _to_sass_tree_times_div":{"type":"method","name":"_to_sass_tree_times_div","children":[],"call":["Sass Script Operation  new "," _to_sass_tree_unary ","rest [] ","LESS_TO_SASS_OPERATORS  [] ","(str \"*\") include? ","rest [] is_a? ","Sass Script OpSass Script Operation  new ration  nSass Script Operation  new w "," _to_sass_trSass Script Operation  new Sass Script Operation  new _unary ","rSass Script Operation  new st [] ","(str \"*\") includSass Script Operation  new ? ","rSass Script Operation  new st [] is_a? "]}," Less Node Expression _to_sass_tree_plus_minus_eq":{"type":"method","name":"_to_sass_tree_plus_minus_eq","children":[],"call":["Sass Script Operation  new "," _to_sass_tree_times_div ","rest [] ","LESS_TO_SASS_OPERATORS  [] ","(str \"+\") include? ","rest [] is_a? ","Sass Script OpSass Script Operation  new ration  nSass Script Operation  new w "," _to_sass_trSass Script Operation  new Sass Script Operation  new _timSass Script Operation  new s_div ","rSass Script Operation  new st [] ","(str \"+\") includSass Script Operation  new ? ","rSass Script Operation  new st [] is_a? "]}," Haml Plugin call":{"type":"method","name":"call","children":[],"call":[]}," Tree CharsetNode _to_s":{"type":"method","name":"_to_s","children":[],"call":[" name "]}," Tree CharsetNode to_src":{"type":"method","name":"to_src","children":[],"call":[" semi "," name ","   * "]}," Tree CharsetNode invisible?":{"type":"method","name":"invisible?","children":[],"call":["Haml Util  ruby1_8? ! ","Haml Util  ruby1_8? "]}," Tree CharsetNode initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Sass SCSS Parser charset_directive":{"type":"method","name":"charset_directive","children":[],"call":[" node ","Sass Tree CharsetNode  new "," ss ","@scanner [] "," tok! "]}," Haml Util inspect_obj":{"type":"method","name":"inspect_obj","children":[],"call":["\" + + ","\" + ","s inspect [] ","s inspect ","obj gsub ","obj inspect ","obj is_a? ",": + "," inspect_obj ","obj to_s "," version_geq "," RUBY_VERSION  >= ","s dump [] ","s dump "]}," Sass SCSS Parser else_directive":{"type":"method","name":"else_directive","children":[],"call":[" raise ","Sass SyntaxError  new "]}," Haml Util ironruby?":{"type":"method","name":"ironruby?","children":[],"call":["RUBY_ENGINE  == "]}," Haml Exec Generic puts":{"type":"method","name":"puts","children":[],"call":["Kernel  puts ","@options [] [] ","@options [] "]}," Haml HTML Node included":{"type":"method","name":"included","children":[{"type":"method","name":"to_haml","children":[],"asgn":[{"type":"local","name":"node","value":"node next_node "},["node next_node "],{"type":"local","name":"node","value":"node next_node "},["node next_node "],{"type":"local","name":"node","value":" next_node "},[" next_node "],{"type":"local","name":"text","value":" uninterp "},[" uninterp "]],"call":[" parse_text_with_interpolation ","node next_node ","node converted_to_haml= ","text << "," uninterp ","node to_s ","node next_node ","node next_node is_a? ","node next_node ","text << << << ","text << << ","CGI  unescapeHTML gsub strip ","CGI  unescapeHTML gsub ","CGI  unescapeHTML ","node inner_text ","text << ","node converted_to_haml= ","node name == ","node name ","node is_a? "," next_node "," uninterp "," to_s "," to_s strip empty? "," to_s strip "," to_s "," converted_to_haml "]},{"type":"method","name":"erb_to_interpolation","children":[],"asgn":[{"type":"local","name":"text","value":"CGI  escapeHTML "},["CGI  escapeHTML "]],"call":["str + + + ","str + + ","CGI  unescapeHTML ","elem innerText strip ","elem innerText ","str + ","str + ","CGI  unescapeHTML ","elem to_s ","elem is_a? "," Hpricot  XML children inject "," Hpricot  XML children "," Hpricot  XML ","text gsub! ","CGI  escapeHTML ","(str \"<haml:loud>\") each ","CGI  escapeHTML "," uninterp ","options [] "]},{"type":"method","name":"tabulate","children":[],"asgn":[],"call":["   * "]},{"type":"method","name":"uninterp","children":[],"asgn":[],"call":["text gsub "]},{"type":"method","name":"attr_hash","children":[],"asgn":[],"call":[" attributes to_hash "," attributes "]},{"type":"method","name":"parse_text","children":[],"asgn":[],"call":[" parse_text_with_interpolation "," uninterp "]},{"type":"method","name":"parse_text_with_interpolation","children":[],"asgn":[],"call":["(send\n  (send\n    (lvar :text) :split\n    (str \"\\n\")) :map) join ","Haml Engine SPECIAL_CHARACTERS  include? ","line [] "," tabulate ","line strip! ","text split map ","text split ","text empty? ","text strip! "]}],"call":[]}," Haml Util ap_2_3_6?":{"type":"method","name":"ap_2_3_6?","children":[],"call":["ActionPack VERSION TINY  >= ","ActionPack VERSION MINOR  == ","ActionPack VERSION MAJOR  == "," require "]}," RealERB set_eoutvar":{"type":"method","name":"set_eoutvar","children":[],"call":["compiler post_cmd= ","cmd push ","compiler pre_cmd= ","compiler insert_cmd= ","compiler put_cmd= "]}," Fragments fragment_for":{"type":"method","name":"fragment_for","children":[],"call":["block call "," write_fragment ","buffer [] ","buffer length ","buffer concat ","cache html_safe "," read_fragment "," perform_caching "," read_fragment  html_safe "]}," Haml Util try_sass":{"type":"method","name":"try_sass","children":[],"call":["$LOAD_PATH unshift "," scope ","$\" delete "," haml_warn ","Sass  version [] != ","Sass  version [] ","Sass  version ","Sass  version [] == ","Sass  version [] > ","Sass  respond_to? "," require ","Sass  version [] >= "]}," Haml Util abstract":{"type":"method","name":"abstract","children":[],"call":[" raise ","NotImplementedError  new "," caller_info [] "," caller_info ","obj class "]}," Haml Util load":{"type":"method","name":"load","children":[],"call":["obj _after_load ","obj respond_to? ","Marshal  load ","Marshal  load  _after_load ","Marshal  load  respond_to? "]}," Haml Util dump":{"type":"method","name":"dump","children":[],"call":["obj _after_dump ","obj respond_to? ","Marshal  dump ","obj _around_dump ","obj _before_dump ","obj Marshal  dump pond_to? "]}," Haml Compiler compile_silent_script_with_haml_block_deprecation":{"type":"method","name":"compile_silent_script_with_haml_block_deprecation","children":[],"call":[" compile_silent_script_without_haml_block_deprecation ","@node value []= ","@node value [] ","@node value ","@node value [] =~ ","@node value [] ! "]}," Haml Parser flat?":{"type":"method","name":"flat?","children":[],"call":[]}," Haml Parser filter_opened?":{"type":"method","name":"filter_opened?","children":[],"call":["@next_line full =~ ","@indentation * ","@next_line full ","@template_tabs + "]}," Haml Parser block_opened?":{"type":"method","name":"block_opened?","children":[],"call":["@next_line tabs > ","@line tabs ","@next_line tabs "]}," Haml Parser balance":{"type":"method","name":"balance","children":[],"call":[" raise ","SyntaxError  new ","Haml Shared  balance ","Haml Util  balance ","Error  message ","HamlSyntaxError  new ","HamlError  message "]}," Haml Parser unescape_interpolation":{"type":"method","name":"unescape_interpolation","children":[],"call":["res + ","res << ","#{ + + ","#{ + "," eval ","\" + + ","\" + "," balance [] [] "," balance [] "," balance ","escapes % == ","escapes % ","scan matched [] ","-3 - ","scan matched ","(send\n  (send\n    (send\n      (lvar :scan) :[]\n      (int 2)) :size) :-\n  (int 1)) / ","scan [] size - ","scan [] size ","scan [] ","Haml Shared  handle_interpolation ","str dump ","Haml Util  handle_interpolation ","(send\n  (send\n    (send\n      (lvar :scan) :[]\n      (int 2)) :size) :-\n  (int 1)) /  % == ","(send\n  (send\n    (send\n      (lvar :scan) :[]\n      (int 2)) :size) :-\n  (int 1)) /  % "]}," Haml Parser contains_interpolation?":{"type":"method","name":"contains_interpolation?","children":[],"call":["str include? "]}," Haml Parser is_ruby_multiline?":{"type":"method","name":"is_ruby_multiline?","children":[],"call":["text [] != ","text [] ","text [] == ","text length > ","text length ","(or\n  (begin\n    (send\n      (send\n        (lvar :text) :[]\n        (irange\n          (int -3)\n          (int -2))) :=~\n      (regexp\n        (str \"\\\\W\\\\?\")\n        (regopt))))\n  (send\n    (send\n      (lvar :text) :[]\n      (irange\n        (int -3)\n        (int -2))) :==\n    (str \"?\\\\\"))) ! ","text [] =~ ","(or\n  (begin\n    (send\n      (send\n        (lvar :text) :[]\n        (int -3)\n        (int 2)) :=~\n      (regexp\n        (str \"\\\\W\\\\?\")\n        (regopt))))\n  (send\n    (send\n      (lvar :text) :[]\n      (int -3)\n      (int 2)) :==\n    (str \"?\\\\\"))) ! "]}," Haml Parser handle_ruby_multiline":{"type":"method","name":"handle_ruby_multiline","children":[],"call":[" next_line ","text << << ","new_line strip ","text << ","new_line strip empty? ","new_line == "," raw_next_line first "," raw_next_line "," is_ruby_multiline? "," un_next_line ","@next_line full ","text rstrip ","line text << ","new_line text rstrip ","new_line text ","line text ","new_line text empty? ","new_line eod? ","@template shift ","new_line nil? ","line text rstrip! ","text rstrip  << << "," raw_next_line first  strip ","@template shift  strip ","text rstrip  << "," raw_next_line first  strip empty? ","@template shift  strip empty? "," raw_next_line first  == ","@template shift  == ","text rstrip  rstrip ","line text rstrip  << "," raw_next_line first  text rstrip ","@template shift  text rstrip ","new_line text rstrip  rstrip "," raw_next_line first  text ","@template shift  text ","new_line text rstrip  ","line text rstrip  "," raw_next_line first  text empty? ","@template shift  text empty? ","new_line text rstrip  empty? "," raw_next_line first  eod? ","@template shift  eod? "," raw_next_line first  nil? ","@template shift  nil? ","line text rstrip  rstrip! "]}," Haml Parser is_multiline?":{"type":"method","name":"is_multiline?","children":[],"call":["text [] == ","text [] ","text length > ","text length ","text !~ "]}," Haml Parser handle_multiline":{"type":"method","name":"handle_multiline","children":[],"call":[" un_next_line ","line text << ","new_line strip [] ","new_line strip ","line text "," is_multiline? ","new_line strip empty? ","new_line == "," raw_next_line first "," raw_next_line ","line text slice! ","@template shift ","new_line text strip [] ","new_line text strip ","new_line text ","new_line text strip empty? ","new_line eod? ","@template first "," loop "," raw_next_line first  strip [] ","@template first  strip [] "," raw_next_line first  strip ","@template first  strip "," raw_next_line first  strip empty? ","@template first  strip empty? "," raw_next_line first  == ","@template first  == "," raw_next_line first  text strip [] ","@template first  text strip [] "," raw_next_line first  text strip ","@template first  text strip "," raw_next_line first  text ","@template first  text "," raw_next_line first  text strip empty? ","@template first  text strip empty? "," raw_next_line first  eod? ","@template first  eod? "]}," Haml Parser un_next_line":{"type":"method","name":"un_next_line","children":[],"call":["@template unshift "]}," Haml Parser closes_flat?":{"type":"method","name":"closes_flat?","children":[],"call":["line full !~ ","line full ","line text empty? ! ","line text empty? ","line text "]}," Haml Parser next_line":{"type":"method","name":"next_line","children":[],"call":[" handle_multiline "," next_line ","line text empty? ","line text ","line full =~ ","@line full [] ","@line full ","line full ","@line text [] == ","@line text [] ","@line text "," closes_flat? ! "," closes_flat? "," flat? ","@line tabs ","Line  new ","text lstrip chomp ","text lstrip ","text strip ","text == "," raw_next_line "," instance_variable_defined? "," raise ","@template shift "," handle_multiLine  new  "," next_Line  new  ","Line  new  text empty? ","Line  new  text ","Line  new  full =~ ","@Line  new  full [] ","@Line  new  full ","Line  new  full ","@Line  new  text [] == ","@Line  new  text [] ","@Line  new  text ","@Line  new  tabs "," raw_next_Line  new  "]}," Haml Parser raw_next_line":{"type":"method","name":"raw_next_line","children":[],"call":["@template shift "]}," Haml Parser parse_new_attribute":{"type":"method","name":"parse_new_attribute","children":[],"call":["\" + + ","\" + ","(send\n  (lvar :content) :map) join "," inspect_obj [] "," inspect_obj ","t == ","content map ","content first [] ","content first ","content size == ","content size ","content << "," balance first [] "," balance first "," balance ","scanner [] == ","scanner [] ","scanner [] gsub ","scanner scan "," loop ","s << ","content each_with_object "," dup ","Util  inspect_obj [] ","Util  inspect_obj ","(send\n  (lscanner scan  :content) :map) join "]}," Haml Parser parse_new_attributes":{"type":"method","name":"parse_new_attributes","children":[],"call":["scanner rest ","dynamic_attributes == ","dynamic_attributes << ","dynamic_attributes << << << << ","dynamic_attributes << << << ","dynamic_attributes << << "," inspect_obj ","static_attributes []= ","type == ","attributes each ","scanner scan "," next_line ","line << << ","@next_line text ","line << ","scanner eos? ","attributes []= "," raise ","Haml SyntaxError  new ","last_line - ","text inspect ","(or\n  (send\n    (const\n      (const nil :Haml) :Shared) :balance\n    (lvar :line)\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line))) first ","Haml Shared  balance ","name == ","name nil? "," parse_new_attribute "," loop ","StringScanner  new ","line dup ","(or\n  (send\n    (const\n      (const nil :Haml) :Util) :balance\n    (lvar :line)\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line))) first ","Haml Util  balance ","Error  message ","text << ","scanned first ","@line index + ","@line index ","{ dup ","Util  inspect_obj ","Haml HamlSyntaxError  new ","HamlError  message ","StringScanner  new  rest ","{ dup  == ","{ dup  << ","{ dup  << << << << ","{ dup  << << << ","{ dup  << << ","StringScanner  new  scan "," next_line dup  ","line dup  << << ","@next_line (or\n  (send\n    (const\n      (const nil :Haml) :Shared) :balance\n    (lvar :line)\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line))) first  ","@next_line (or\n  (send\n    (const\n      (const nil :Haml) :Util) :balance\n    (lvar :line)\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line))) first  ","@next_line scanned first  ","@next_line dup  text ","line dup  << ","StringScanner  new  eos? ","last_line dup  - ","@line index +  - ","(or\n  (send\n    (const\n      (const nil :Haml) :Shared) :balance\n    (lvar :line)\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line))) first  inspect ","(or\n  (send\n    (const\n      (const nil :Haml) :Util) :balance\n    (lvar :line)\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line))) first  inspect ","scanned first  inspect ","(or\n  (send\n    (const\n      (const nil :Haml) :Shared) :balance\n    (lvar :line dup )\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line dup ))) first ","line dup  dup ","(or\n  (send\n    (const\n      (const nil :Haml) :Util) :balance\n    (lvar :line dup )\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line dup ))) first ","(or\n  (send\n    (const\n      (const nil :Haml) :Shared) :balance\n    (lvar :line)\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line))) first  << ","(or\n  (send\n    (const\n      (const nil :Haml) :Util) :balance\n    (lvar :line)\n    (str \"(\")\n    (str \")\"))\n  (array\n    (lvar :line))) first  << ","scanned first  << ","Haml Util  balance  first ","@line dup  index + ","@line dup  index "]}," Haml Parser parse_old_attributes":{"type":"method","name":"parse_old_attributes","children":[],"call":["attributes_hash [] "," raise "," next_line ","line << << ","@next_line text ","line << ","e message == ","e message ","line strip [] == ","line strip [] ","line strip "," balance ","line dup ","Error  message ","text << ","text strip [] == ","text strip [] ","text strip ","@line index + ","@line index ","text dup ","@template empty? ! ","@template empty? ","balanced sub "," balance_tokens ","text sub ","HamlError  message ","attributes_hash []  [] ","balanced sub  [] "," next_line dup  ","line dup  << << ","@next_line dup  text ","@next_line text dup  ","line dup  << ","line dup  strip [] == ","line dup  strip [] ","line dup  strip ","line dup  dup ","text dup  << ","text dup  strip [] == ","text dup  strip [] ","text dup  strip ","@line dup  index + ","@line dup  index ","text dup  dup ","text dup  sub "]}," Haml Parser parse_tag":{"type":"method","name":"parse_tag","children":[],"call":["value to_s strip ","value to_s ","nuke_whitespace include? ","rest scan [] ","rest scan "," balance ","object_ref == ","attributes_hashes []= "," parse_new_attributes "," parse_old_attributes ","rest [] "," raise ","SyntaxError  new ","attributes =~ ","line scan [] ","line scan ","attributes_hashes << ","@options [] ","Error  message ","@line index + ","@line index ","value strip! ","value nil? ","@options remove_whitespace ","rest empty? ! ","rest empty? ","attributes empty? ! ","attributes empty? ","text scan [] ","text scan ","HamlSyntaxError  new ","HamlError  message ","value to_s strip  to_s strip ","value to_s strip  to_s ","value to_s strip  strip! ","value to_s strip  nil? "]}," Haml Parser parse_static_hash":{"type":"method","name":"parse_static_hash","children":[],"call":["attributes []= "," eval to_s "," eval ","scanner scan ","scanner eos? ","StringScanner  new ","text empty? ","text [] ","StringScanner  new  scan ","StringScanner  new  eos? ","text []  empty? ","text []  [] "]}," Haml Parser parse_class_and_id":{"type":"method","name":"parse_class_and_id","children":[],"call":[]}," Haml Parser close_silent_script":{"type":"method","name":"close_silent_script","children":[],"call":["first children= ","node children= ","first children ","first children empty? ","first value [] == ","first value [] ","first value ","first type == ","first type ","node children first ","node children ","node value [] == ","node value [] ","node value ","@script_level_stack pop ","(str \"if\") include? ","node children first  children= ","node children first  children ","node children first  children empty? ","node children first  value [] == ","node children first  value [] ","node children first  value ","node children first  type == ","node children first  type ","node children node children first  "]}," Haml Parser close_haml_comment":{"type":"method","name":"close_haml_comment","children":[],"call":[" close_flat_section "]}," Haml Parser close_filter":{"type":"method","name":"close_filter","children":[],"call":[" close_flat_section "]}," Haml Parser close":{"type":"method","name":"close","children":[],"call":[" send ","node type "," respond_to? ","@parent parent "]}," Haml Parser filter":{"type":"method","name":"filter","children":[],"call":["ParseNode  new ","@indentation * ","@template_tabs + "," filter_opened? ","String  new "," raise ","Error  new ","name =~ ","Error  message ","@line index + ","@line index ","HamlError  new ","HamlError  message "]}," Haml Parser doctype":{"type":"method","name":"doctype","children":[],"call":["ParseNode  new ","line [] strip downcase scan [] ","line [] strip downcase scan ","line [] strip downcase ","line [] strip ","line [] "," raise ","SyntaxError  new ","@next_line index "," block_opened? ","Error  message ","@line index + ","@line index ","text [] strip downcase scan [] ","text [] strip downcase scan ","text [] strip downcase ","text [] strip ","text [] ","HamlSyntaxError  new ","HamlError  message "]}," Haml Parser comment":{"type":"method","name":"comment","children":[],"call":["ParseNode  new "," raise ","SyntaxError  new ","@next_line index ","line empty? ! ","line empty? "," block_opened? ","conditional << ","line strip! "," balance ","line [] == ","line [] ","Haml Error  message ","@line index + ","@line index ","text empty? ! ","text empty? ","text strip! ","text [] == ","text [] "," unescape_interpolation "," contains_interpolation? ","Util  unescape_interpolation ","Util  contains_interpolation? ","HamlSyntaxError  new ","Haml HamlError  message ","text []  empty? ! "," unescape_interpolation  empty? ! ","Util  unescape_interpolation  empty? ! ","text []  empty? "," unescape_interpolation  empty? ","Util  unescape_interpolation  empty? ","text []  strip! "," unescape_interpolation  strip! ","Util  unescape_interpolation  strip! ","text []  [] == "," unescape_interpolation  [] == ","Util  unescape_interpolation  [] == ","text []  [] "," unescape_interpolation  [] ","Util  unescape_interpolation  [] "]}," Haml Parser div":{"type":"method","name":"div","children":[],"call":[" tag ","%div + ","line text= ","line text "]}," Haml Parser tag":{"type":"method","name":"tag","children":[],"call":["ParseNode  new "," handle_ruby_multiline "," block_opened? ","value empty? ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :[]\n        (sym :autoclose)) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :[]\n        (sym :autoclose)) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ","t === ","@options [] any? ","@options [] "," block_opened? ! "," raise ","SyntaxError  new ","@next_line index "," is_ruby_multiline? ! "," is_ruby_multiline? ","value empty? ! ","last_line - ","attributes_list compact! ","attributes_list << ","attributes_hashes [] ","Buffer  merge_attrs "," parse_static_hash ","Parser  parse_class_and_id "," unescape_interpolation "," contains_interpolation? ","value [] strip ","value [] ","value [] == ","action != ","action == ","@options [] include? "," parse_tag ","(send\n  (lvar :attributes_hashes) :map!) compact! ","syntax == ","attributes_hashes map! ","Error  message ","line text ","line index + ","line index ","line text= ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :autoclose) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :autoclose) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ","@options autoclose any? ","@options autoclose ","@options suppress_eval ","@options escape_html ","@options ugly ","@options preserve include? ","@options preserve ","dynamic_attributes old= ","AttributeBuilder  merge_attributes! ","dynamic_attributes new= ","DynamicAttributes  new ","AttributeMerger  merge_attributes! ","Util  unescape_interpolation ","Util  contains_interpolation? ","HamlSyntaxError  new ","HamlError  message "," handle_ruby_multi handle_ruby_multiline  "," handle_ruby_multiline  empty? "," unescape_interpolation  empty? ","value [] strip  empty? ","Util  unescape_interpolation  empty? ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar : handle_ruby_multiline ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :[]\n        (sym :autoclose)) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar : unescape_interpolation ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :[]\n        (sym :autoclose)) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value [] strip ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :[]\n        (sym :autoclose)) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :Util  unescape_interpolation ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :[]\n        (sym :autoclose)) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar : handle_ruby_multiline ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :[]\n        (sym :autoclose)) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar : unescape_interpolation ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :[]\n        (sym :autoclose)) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value [] strip ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :[]\n        (sym :autoclose)) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :Util  unescape_interpolation ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :[]\n        (sym :autoclose)) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ","@next_ handle_ruby_multiline  index "," is_ruby_multi handle_ruby_multiline ? ! "," is_ruby_multi handle_ruby_multiline ? "," handle_ruby_multiline  empty? ! "," unescape_interpolation  empty? ! ","value [] strip  empty? ! ","Util  unescape_interpolation  empty? ! ","last_ handle_ruby_multiline  - ","Parser  parse_class_and_id _list compact! ","Parser  parse_class_and_id _list << ","Parser  parse_class_and_id _hashes [] "," handle_ruby_multiline  [] strip "," unescape_interpolation  [] strip ","value [] strip  [] strip ","Util  unescape_interpolation  [] strip "," handle_ruby_multiline  [] "," unescape_interpolation  [] ","value [] strip  [] ","Util  unescape_interpolation  [] "," handle_ruby_multiline  [] == "," unescape_interpolation  [] == ","value [] strip  [] == ","Util  unescape_interpolation  [] == ","(send\n  (lvar :Parser  parse_class_and_id _hashes) :map!) compact! ","Parser  parse_class_and_id _hashes map! "," handle_ruby_multiline  text "," handle_ruby_multiline  index + "," handle_ruby_multiline  index "," handle_ruby_multiline  text= ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar : handle_ruby_multiline ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :autoclose) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar : unescape_interpolation ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :autoclose) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value [] strip ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :autoclose) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :Util  unescape_interpolation ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :autoclose) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar : handle_ruby_multiline ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :autoclose) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar : unescape_interpolation ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :autoclose) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :value [] strip ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :autoclose) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ","(and\n  (and\n    (send\n      (send nil :block_opened?) :!)\n    (send\n      (lvar :Util  unescape_interpolation ) :empty?))\n  (block\n    (send\n      (send\n        (ivar :@options) :autoclose) :any?)\n    (args\n      (arg :t))\n    (send\n      (lvar :t) :===\n      (lvar :tag_name)))) ! ","dynamic_Parser  parse_class_and_id  old= ","DynamicAttributes  new  old= ","AttributeBuilder  merge_Parser  parse_class_and_id ! ","dynamic_Parser  parse_class_and_id  new= ","DynamicAttributes  new  new= ","AttributeMerger  merge_Parser  parse_class_and_id ! "]}," Haml Parser haml_comment":{"type":"method","name":"haml_comment","children":[],"call":["ParseNode  new "," block_opened? ","@line index + ","@line index ","@indentation * ","@template_tabs + ","@filter_buffer << ","text empty? ","String  new "," filter_opened? ","String  new  << "]}," Haml Parser silent_script":{"type":"method","name":"silent_script","children":[],"call":["ParseNode  new ","text [] ","(str \"if\") include? "," block_keyword "," handle_ruby_multiline "," raise ","SyntaxError  new ","@index - ","(str \"You don't need to use \\\"- end\\\" in Haml. Un-indent to close a block:\\n\") rstrip ","text [] strip == ","text [] strip "," haml_comment ","text [] == ","Haml SyntaxError  new ","@line index ","Error  message ","@line tabs ","@script_level_stack last ","@script_level_stack last != ","@script_level_stack empty? ","(str \"else\") include? ","@script_level_stack push ","@script_level_stack last [] ","@script_level_stack last [] != ","@script_level_stack last []= ","@script_level_stack last [] + == ","@script_level_stack last [] + ","@script_level_stack last [] ! ","keyword == "," check_push_script_stack ","line text [] ","line text ","@line index + ","line index ","line text [] strip == ","line text [] strip ","line text [] == ","Haml HamlSyntaxError  new ","HamlError  message ","HamlSyntaxError  new "," handle_ruby_multiline  [] "," block_ block_keyword  "," handle_ruby_multi handle_ruby_multiline  "," handle_ruby_multiline  [] strip == "," handle_ruby_multiline  [] strip "," handle_ruby_multiline  [] == ","@ handle_ruby_multiline  index ","Error  Error  message  ","Error  HamlError  message  ","@ handle_ruby_multiline  tabs "," block_keyword  == ","line  handle_ruby_multiline  [] "," handle_ruby_multiline  text [] ","line  handle_ruby_multiline  "," handle_ruby_multiline  text ","@ handle_ruby_multiline  index + "," handle_ruby_multiline  index ","line  handle_ruby_multiline  [] strip == "," handle_ruby_multiline  text [] strip == ","line  handle_ruby_multiline  [] strip "," handle_ruby_multiline  text [] strip ","line  handle_ruby_multiline  [] == "," handle_ruby_multiline  text [] == ","HamlError  Error  message  ","HamlError  HamlError  message  "]}," Haml Parser flat_script":{"type":"method","name":"flat_script","children":[],"call":[" script "," raise ","SyntaxError  new ","text empty? ","Error  message ","line text empty? ","line text ","HamlSyntaxError  new ","HamlError  message "]}," Haml Parser script":{"type":"method","name":"script","children":[],"call":["ParseNode  new ","@options [] ","escape_html nil? "," handle_ruby_multiline "," raise ","SyntaxError  new ","text empty? ","Error  message "," check_push_script_stack "," block_keyword ","line text ","line index + ","line index ","@options escape_html ","line text empty? ","HamlSyntaxError  new ","HamlError  message ","@options []  nil? ","@options escape_html  nil? "," handle_ruby_multi handle_ruby_multiline  "," handle_ruby_multiline  empty? "," block_ block_keyword  ","line  handle_ruby_multiline  "," handle_ruby_multiline  text "," handle_ruby_multiline  index + "," handle_ruby_multiline  index ","@options @options []  ","@options @options escape_html  ","line  handle_ruby_multiline  empty? "," handle_ruby_multiline  text empty? "]}," Haml Parser plain":{"type":"method","name":"plain","children":[],"call":[" script ","escape_html ! "," unescape_interpolation ","@options [] ","escape_html nil? ","ParseNode  new "," contains_interpolation? "," raise ","SyntaxError  new ","@next_line index "," block_opened? ","Error  message ","line text= ","line text ","@options escape_html ","line index + ","line index ","@options mime_type != ","@options mime_type ","n value []= ","n value "," script tap ","Util  unescape_interpolation ","Util  contains_interpolation? ","HamlSyntaxError  new ","HamlError  message ","@options []  ! ","@options escape_html  ! ","@options []  nil? ","@options escape_html  nil? ","@options @options []  ","@options @options escape_html  "]}," Haml Parser push":{"type":"method","name":"push","children":[],"call":["node parent= ","@parent children << ","@parent children "]}," Haml Parser mid_block_keyword?":{"type":"method","name":"mid_block_keyword?","children":[],"call":["MID_BLOCK_KEYWORDS  include? "," block_keyword "]}," Haml Parser block_keyword":{"type":"method","name":"block_keyword","children":[],"call":["keyword [] ","text scan [] ","text scan ","text scan []  [] "]}," Haml Parser process_line":{"type":"method","name":"process_line","children":[],"call":[" push "," plain ","text [] ","escape_html ! ","text [] strip ","text [] == "," flat_script "," script "," doctype "," filter ","text [] downcase "," silent_script "," comment "," tag "," div ","index + ","line strip! ","line text [] == ","line text [] ","line text ","line text [] downcase ","line text= ","line text [] lstrip "," haml_comment ","(str \"{\") include? "]}," Haml Parser process_indent":{"type":"method","name":"process_indent","children":[],"call":[" close "," mid_block_keyword? ","line text ","to_close - - == ","to_close - - ","to_close - ","to_close times ","@template_tabs - ","line tabs ","@template_tabs > ","line tabs <= "," continuation_script? ","@template_tabs -  - - == ","@template_tabs -  - - ","@template_tabs -  - ","@template_tabs -  times "]}," Haml Parser parse":{"type":"method","name":"parse","children":[],"call":[" close ","@parent type == ","@parent type "," raise ","SyntaxError  new ","@next_line index ","@next_line tabs - ","@line tabs ","@next_line tabs ","@next_line tabs - > "," flat? ! "," flat? ","@parent children last ","@parent children "," block_opened? "," process_line ","@line index ","@line text ","@line text empty? ","@filter_buffer << ","text gsub! ","@line full dup ","@line full "," process_indent "," next_line ","@line tabs != ","ParseNode  new ","@parent type != ","@haml_comment ! ","e backtrace unshift ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (ivar :@index)) + - ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (ivar :@index)) + ","@options [] ","e line + ","e line ","e backtrace ","Error  message ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (send\n    (send\n      (ivar :@line) :index) :+\n    (int 1))) + - ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (send\n    (send\n      (ivar :@line) :index) :+\n    (int 1))) + ","@options line ","@line index + ","@options filename "," loop ","@parent children last  type == ","ParseNode  new  type == ","@parent children last  type ","ParseNode  new  type "," next_line  tabs ","@parent children last  children last ","ParseNode  new  children last ","@parent children last  children ","ParseNode  new  children "," next_line  index ","@line @line full dup  "," next_line  text ","@line @line full dup  empty? "," next_line  text empty? ","@line full dup  gsub! "," next_line  full dup "," next_line  full "," next_line  tabs != ","@parent children last  type != ","ParseNode  new  type != ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (send\n    (send\n      (ivar : next_line ) :index) :+\n    (int 1))) + - ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (send\n    (send\n      (ivar : next_line ) :index) :+\n    (int 1))) + "," next_line  index + "]}," Haml Parser ParseNode inspect":{"type":"method","name":"inspect","children":[],"call":["text + ","text << << ","c inspect gsub ","c inspect ","text << "," children each "," children "," value inspect "," value "," type ","(send\n  (send nil :children) :map) join ","c inspect gsub! "," children map ","s << "," children each_with_object "]}," Haml Parser ParseNode initialize":{"type":"method","name":"initialize","children":[],"call":[" children "]}," Haml Parser Line tabs":{"type":"method","name":"tabs","children":[],"call":[" raise ","SyntaxError  new ","line index ","(str \"Inconsistent indentation: \") strip gsub ","(str \"Inconsistent indentation: \") strip ","Haml Shared  human_indentation ","@template_tabs + ","whitespace =~ "," flat? ","whitespace == ","@indentation * ","whitespace length / ","@indentation length ","whitespace length ","@indentation include? ","@indentation nil? ","(lvasgn :whitespace\n  (send\n    (send\n      (lvar :line) :full) :[]\n    (regexp\n      (str \"^\\\\s+\")\n      (regopt)))) ! ","line full [] ","line full ","line text empty? ","line text "," compiler instance_eval "," compiler ","Haml Util  human_indentation ","Error  message "," parser compute_tabs "," parser ","@template_whitespace length /  + ","line full []  =~ ","line full []  == ","line full []  length / ","line full []  length ","(lvasgn :line full [] \n  (send\n    (send\n      (lvar :line) :full) :[]\n    (regexp\n      (str \"^\\\\s+\")\n      (regopt)))) ! ","Error  Error  message  "," parser compute_whitespace length /  "]}," Hpricot Node parse_text_with_interpolation":{"type":"method","name":"parse_text_with_interpolation","children":[],"call":["(send\n  (send\n    (lvar :text) :split\n    (str \"\\n\")) :map) join ","Haml Engine SPECIAL_CHARACTERS  include? ","line [] "," tabulate ","line strip! ","text split map ","text split ","text empty? ","text strip! "]}," Hpricot Node parse_text":{"type":"method","name":"parse_text","children":[],"call":[" parse_text_with_interpolation "," uninterp "]}," Hpricot Node attr_hash":{"type":"method","name":"attr_hash","children":[],"call":[" attributes to_hash "," attributes "]}," Hpricot Node uninterp":{"type":"method","name":"uninterp","children":[],"call":["text gsub "]}," Hpricot Node tabulate":{"type":"method","name":"tabulate","children":[],"call":["   * "]}," Hpricot Node erb_to_interpolation":{"type":"method","name":"erb_to_interpolation","children":[],"call":["str + + + ","str + + ","CGI  unescapeHTML ","elem innerText strip ","elem innerText ","str + ","elem to_s ","elem is_a? "," Hpricot  XML children inject "," Hpricot  XML children "," Hpricot  XML ","text gsub! ","CGI  escapeHTML ","(str \"<haml:loud>\") each "," uninterp ","options [] ","CGI  escapeHTML  gsub! "]}," Hpricot Node to_haml":{"type":"method","name":"to_haml","children":[],"call":[" parse_text_with_interpolation ","node next_node ","node converted_to_haml= ","text << "," uninterp ","node to_s ","node next_node is_a? ","text << << << ","text << << ","CGI  unescapeHTML gsub strip ","CGI  unescapeHTML gsub ","CGI  unescapeHTML ","node inner_text ","node name == ","node name ","node is_a? "," next_node "," to_s "," to_s strip empty? "," to_s strip "," converted_to_haml "," parse_ uninterp _with_interpolation ","node next_node  next_node next_node  "," next_node  next_ next_node  ","node next_node  converted_to_haml= "," next_node  converted_to_haml= "," uninterp  << ","node next_node  to_s "," next_node  to_s ","node next_node  next_node next_node  is_a? "," next_node  next_ next_node  is_a? "," uninterp  << << << "," uninterp  << << ","node next_node  inner_text "," next_node  inner_text ","node inner_ uninterp  ","node next_node  name == "," next_node  name == ","node next_node  name "," next_node  name ","node next_node  is_a? "," next_node  is_a? "," next_node next_node  "," next_ next_node  "]}," Haml Compiler compile":{"type":"method","name":"compile","children":[],"call":[" send ","node children empty? ","node children ","node type "," compile ","node children each "," proc "," instance_variable_defined? "," raise ","InternalError  new "," compile_tag "," compile_silent_script "," compile_script "," compile_plain "," compile_filter "," compile_doctype "," compile_comment "," compile_children "]}," Haml Compiler rstrip_buffer!":{"type":"method","name":"rstrip_buffer!","children":[],"call":[" raise ","SyntaxError  new "," rstrip_buffer! ","index - ","last [] gsub! ","last [] ","@to_merge slice! ","last [] empty? ","last [] rstrip! ","last first "," push_silent ","last nil? ","@to_merge [] ","last []= ","last [] rstrip ","@to_merge []  [] gsub! ","@to_merge []  [] ","@to_merge []  [] empty? ","@to_merge []  [] rstrip! ","@to_merge []  first ","@to_merge []  nil? ","@to_merge []  []= ","@to_merge []  [] rstrip "]}," Haml Compiler resolve_newlines":{"type":"method","name":"resolve_newlines","children":[],"call":["\n * ","(lvar :diff) max ","@node line ","diff <= ","@node line - ","(lvar :@node line - ) max ","@node line -  <= "]}," Haml Compiler prerender_tag":{"type":"method","name":"prerender_tag","children":[],"call":[" xhtml? ","Compiler  build_attributes ","@options [] "," html? ","@options xhtml? ","@options html? ","@options hyphenate_data_attrs ","@options escape_attrs ","@options attr_wrapper "]}," Haml Compiler filter_and_join":{"type":"method","name":"filter_and_join","children":[],"call":[]}," Haml Compiler build_attributes":{"type":"method","name":"build_attributes","children":[],"call":[]}," Haml Compiler push_generated_script":{"type":"method","name":"push_generated_script","children":[],"call":["text count ","@to_merge << "," resolve_newlines + "," resolve_newlines "]}," Haml Compiler push_script":{"type":"method","name":"push_script","children":[],"call":[" concat_merged_text ","@options [] ","opts [] ","@precompiled << "," push_silent ","@node value [] ","@node value "," flush_merged_text "," push_generated_script "," block_given? "," push_merged_text "," static_method_name ","(or\n  (or\n    (send\n      (lvar :opts) :[]\n      (sym :preserve_script))\n    (send\n      (lvar :opts) :[]\n      (sym :preserve_tag)))\n  (send\n    (lvar :opts) :[]\n    (sym :escape_html))) ! ","args << << ","args << "," block_given? ! ","name to_sym ","args map! "," options [] "," options ","script count ","@to_merge << "," resolve_newlines + "," resolve_newlines ","@options suppress_eval? ","@options ugly ","@temple << "," build_script_formatter "," push_text ","args join ","opts [] ! ! ","opts [] ! "]}," Haml Compiler flush_merged_text":{"type":"method","name":"flush_merged_text","children":[],"call":["@precompiled << ","@dont_tab_up_next_text inspect ","@options [] ","str empty? "," raise ","SyntaxError  new ","str << ","(str \"_hamlout.adjust_tabs(\") + ","@options [] ! ","mtabs != "," inspect_obj [] "," inspect_obj ","@to_merge each ","@to_merge empty? ","@options ugly ","@to_merge join ","@options ugly ! ","@to_merge map! ","@temple << ","@to_merge join  empty? ","@to_merge join  << ","(@to_merge join  \"_hamlout.adjust_tabs(\") + "]}," Haml Compiler push_text":{"type":"method","name":"push_text","children":[],"call":[" push_merged_text ","@to_merge << "]}," Haml Compiler concat_merged_text":{"type":"method","name":"concat_merged_text","children":[],"call":["@to_merge << "]}," Haml Compiler push_merged_text":{"type":"method","name":"push_merged_text","children":[],"call":["@to_merge << ","   * ","@options [] ","indent ! ","@options ugly "]}," Haml Compiler push_silent":{"type":"method","name":"push_silent","children":[],"call":["text count + ","text count ","@precompiled << "," resolve_newlines "," options [] "," options "," flush_merged_text ","(send\n  (lvar :text) :+\n  (lvar :newline)) count ","text + ","text == ","@options suppress_eval? ","@output_line + + ","newline count ","@output_line + ","@temple << ","@output_line + +  + + ","@output_line + +  + "]}," Haml Compiler text_for_doctype":{"type":"method","name":"text_for_doctype","children":[],"call":["@node value [] ","@node value "," html4? ","@node value [] == "," xhtml? "," html5? ","@options [] "," html? ","@options html4? ","@options xhtml? ","@options html5? ","@options html? ","@options attr_wrapper ","@options attr_@options []  ","@options attr_@options attr_wrapper  "]}," Haml Compiler compile_filter":{"type":"method","name":"compile_filter","children":[],"call":["filter internal_compile ","@node value [] ","@node value "," raise ","Error  new ","@node line - ","@node line ","Filters  defined [] ","Filters  defined ","(str \"maruku\") include? ","Error  message ","@filters [] ","@filter_compiler compile ","Filters  defined []  internal_compile ","@filters []  internal_compile ","@Filters  defined [] s [] ","@@filters [] s [] ","@Filters  defined [] _compiler compile ","@@filters [] _compiler compile "]}," Haml Compiler compile_doctype":{"type":"method","name":"compile_doctype","children":[],"call":[" push_text "," text_for_doctype ","@doctype_compiler compile "," text_for_ text_for_doctype  ","@ text_for_doctype _compiler compile "]}," Haml Compiler compile_comment":{"type":"method","name":"compile_comment","children":[],"call":[" push_text ","@node value [] ","@node value "," block_given? "," push_script "," compile_children ","@comment_compiler compile "]}," Haml Compiler compile_tag":{"type":"method","name":"compile_tag","children":[],"call":[" concat_merged_text ","(str \"</\") + ","t [] "," push_script ","t merge "," push_merged_text ","t [] ! "," rstrip_buffer! "," block_given? ","value nil? ","@to_merge << ","parse ! ","> + "," block_given? ! "," html? "," /> + "," xhtml? "," push_generated_script "," inspect_obj ","attributes_hashes join ","attributes_hashes first ","attributes_hashes size == ","attributes_hashes size ","attributes_hashes empty? ","open_tag << ","(or\n  (or\n    (lvar :parse)\n    (send\n      (lvar :t) :[]\n      (sym :nuke_inner_whitespace)))\n  (begin\n    (and\n      (send\n        (lvar :t) :[]\n        (sym :self_closing))\n      (send\n        (lvar :t) :[]\n        (sym :nuke_outer_whitespace))))) ! "," prerender_tag ","preserve_script ! ","object_ref == ","@options [] ","@node value "," push_silent ","(send\n  (array\n    (send\n      (lvar :t) :[]\n      (sym :name))\n    (send\n      (lvar :t) :[]\n      (sym :self_closing))\n    (send\n      (send nil :block_given?) :!)\n    (send\n      (lvar :t) :[]\n      (sym :preserve_tag))\n    (send\n      (lvar :t) :[]\n      (sym :escape_html))\n    (send\n      (lvar :t) :[]\n      (sym :attributes))\n    (send\n      (lvar :t) :[]\n      (sym :nuke_outer_whitespace))\n    (send\n      (lvar :t) :[]\n      (sym :nuke_inner_whitespace))) :map) join ","(send\n  (lvar :t) :[]\n  (sym :name)) map ","@options html? ","@options xhtml? ","@options suppress_eval "," push_text "," push_temple ","@attribute_compiler compile ","t [] merge! ","@options filename split last << << ","@node line to_s ","@node line ","@options filename split last << ","@options filename split last ","@options filename split ","@options filename ","Haml Parser DynamicAttributes  new "," compile_children ","@tag_compiler compile "," conca@node value _merged_@node value ex@node value  ","(s@node value r \"</\") + ","@node value  [] "," push_scrip@node value  ","@node value  merge "," push_merged_@node value ex@node value  ","@node value  [] ! "," rs@node value rip_buffer! ","t []  nil? ","@@node value o_merge << ","t []  ! "," h@node value ml? "," xh@node value ml? "," push_genera@node value ed_scrip@node value  "," inspec@node value _obj ","t []  join ","a@node value @node value ribu@node value es_hashes join ","t []  first ","a@node value @node value ribu@node value es_hashes firs@node value  ","t []  size == ","a@node value @node value ribu@node value es_hashes size == ","t []  size ","a@node value @node value ribu@node value es_hashes size ","t []  empty? ","a@node value @node value ribu@node value es_hashes emp@node value y? "," prerender_tag  << ","open_@node value ag << ","(or\n  (or\n    (lvar :t [] )\n    (send\n      (lvar :t) :[]\n      (sym :nuke_inner_whitespace)))\n  (begin\n    (and\n      (send\n        (lvar :t) :[]\n        (sym :self_closing))\n      (send\n        (lvar :t) :[]\n        (sym :nuke_outer_whitespace))))) ! ","(or\n  (or\n    (lvar :parse)\n    (send\n      (lvar :@node value ) :[]\n      (sym :nuke_inner_whi@node value espace)))\n  (begin\n    (and\n      (send\n        (lvar :@node value ) :[]\n        (sym :self_closing))\n      (send\n        (lvar :@node value ) :[]\n        (sym :nuke_ou@node value er_whi@node value espace))))) ! "," prerender_@node value ag ","preserve_scrip@node value  ! ","t []  == ","objec@node value _ref == ","@op@node value ions [] ","@node t []  "," push_silen@node value  ","(send\n  (array\n    (send\n      (lvar :@node value ) :[]\n      (sym :name))\n    (send\n      (lvar :@node value ) :[]\n      (sym :self_closing))\n    (send\n      (send nil :block_given?) :!)\n    (send\n      (lvar :@node value ) :[]\n      (sym :preserve_@node value ag))\n    (send\n      (lvar :@node value ) :[]\n      (sym :escape_h@node value ml))\n    (send\n      (lvar :@node value ) :[]\n      (sym :a@node value @node value ribu@node value es))\n    (send\n      (lvar :@node value ) :[]\n      (sym :nuke_ou@node value er_whi@node value espace))\n    (send\n      (lvar :@node value ) :[]\n      (sym :nuke_inner_whi@node value espace))) :map) join ","(send\n  (lvar :@node value ) :[]\n  (sym :name)) map ","@op@node value ions h@node value ml? ","@op@node value ions xh@node value ml? ","@op@node value ions suppress_eval "," push_@node value ex@node value  "," push_@node value emple ","@a@node value @node value ribu@node value e_compiler compile ","@node value  [] merge! ","@op@node value ions filename spli@node value  las@node value  << << ","@node line @node value o_s ","@op@node value ions filename spli@node value  las@node value  << ","@op@node value ions filename spli@node value  las@node value  ","@op@node value ions filename spli@node value  ","@op@node value ions filename ","Haml Parser DynamicA@node value @node value ribu@node value es  new ","@@node value ag_compiler compile "]}," Haml Compiler compile_haml_comment":{"type":"method","name":"compile_haml_comment","children":[],"call":[]}," Haml Compiler compile_silent_script":{"type":"method","name":"compile_silent_script","children":[],"call":["@node parent value [] ","@node parent value ","@node parent ","Parser MID_BLOCK_KEYWORDS  include? ","@node parent value []= ","@node parent children last equal? ","@node parent children last ","@node parent children ","keyword == "," push_silent ","@node value [] ","@node value ","@node value []= "," block_given? ","keyword ! ","@options [] ","@options suppress_eval "," compile_children ","@silent_script_compiler compile ","@node value []  == ","@node value []  ! "]}," Haml Compiler compile_script":{"type":"method","name":"compile_script","children":[],"call":[" push_script ","@node value [] ","@node value "," nuke_inner_whitespace? "," compile_children ","@script_compiler compile "]}," Haml Compiler compile_plain":{"type":"method","name":"compile_plain","children":[],"call":[" push_text ","@node value [] ","@node value ","node value [] ","node value "]}," Haml Compiler compile_root":{"type":"method","name":"compile_root","children":[],"call":[" flush_merged_text "," block_given? "]}," Haml Compiler locals_code":{"type":"method","name":"locals_code","children":[],"call":["(send\n  (lvar :names) :map) join + ","(send\n  (lvar :names) :map) join "," inspect_obj ","name to_s ","name to_sym ","names map ","names keys ","Hash  == ","Hash  === ","(send\n  (lvar :names keys ) :map) join + ","(send\n  (lvar :names keys ) :map) join ","names keys  map ","names keys  keys "]}," Haml Compiler precompiled_method_return_value":{"type":"method","name":"precompiled_method_return_value","children":[],"call":[]}," Haml Compiler precompiled_with_ambles":{"type":"method","name":"precompiled_with_ambles","children":[],"call":["preamble + + + ","preamble + + "," precompiled ","preamble + "," locals_code ","(begin\n  (send nil :precompiled_method_return_value)) gsub "," precompiled_method_return_value ","(str \"begin\\n\") gsub "," options_for_buffer inspect "," options_for_buffer "," options for_buffer inspect "," options for_buffer "," options ","(begin\n  (send nil :precompiled_method_return_value)) tr ","(str \"begin\\n\") tr ","(str \"begin\\n\") gsub  + + + ","(str \"begin\\n\") tr  + + + ","(str \"begin\\n\") gsub  + + ","(str \"begin\\n\") tr  + + ","(str \"begin\\n\") gsub  + ","(str \"begin\\n\") tr  + "]}," Haml Buffer attributes":{"type":"method","name":"attributes","children":[],"call":["Compiler  build_attributes ","@options [] "," html? "," class merge_attrs "," parse_object_ref "," class "," to_hash ","k to_s ","old map ","attributes_hashes each ","Hash  [] ","AttributeBuilder  build_attributes ","AttributeBuilder  merge_attributes! ","result []= ","old each "]}," ActionView Helpers TagHelper content_tag_string_with_haml":{"type":"method","name":"content_tag_string_with_haml","children":[],"call":[" content_tag_string_without_haml ","(str \"<\") html_safe ","ERB Util  h "," tag_options ","name to_sym == ","name to_sym "," ERB Util  h _tag_string_without_haml ","  tag_options  "]}," ActionView Renderer render_template_with_haml":{"type":"method","name":"render_template_with_haml","children":[],"call":["rendered gsub html_safe ","rendered gsub "," render_template_without_haml "," render_template_without_haml  gsub html_safe "," render_template_without_haml  gsub "]}," AbstractController Rendering render_to_body_with_haml":{"type":"method","name":"render_to_body_with_haml","children":[],"call":["rendered gsub html_safe ","rendered gsub "," render_to_body_without_haml "," render_to_body_without_haml  gsub html_safe "," render_to_body_without_haml  gsub "]}," ActionView Helpers FormHelper text_area_with_haml":{"type":"method","name":"text_area_with_haml","children":[],"call":[" text_area_without_haml sub html_safe "," text_area_without_haml sub "," text_area_without_haml "]}," ActionView Helpers FormTagHelper text_area_tag_with_haml":{"type":"method","name":"text_area_tag_with_haml","children":[],"call":[" text_area_tag_without_haml sub html_safe "," text_area_tag_without_haml sub "," text_area_tag_without_haml "]}," Haml Filters Redcarpet render":{"type":"method","name":"render","children":[],"call":[" Redcarpet  new to_html "," Redcarpet  new "]}," Haml Util human_indentation":{"type":"method","name":"human_indentation","children":[],"call":["indentation length ","indentation length == ","indentation inspect + ","indentation inspect ","indentation include? ! ","indentation include? "]}," Haml Util balance":{"type":"method","name":"balance","children":[],"call":["scanner rest ","str strip ","count == ","scanner matched [] == ","scanner matched [] ","scanner matched ","str << ","scanner scan ","Regexp  new ","finish chr ","start chr ","StringScanner  new ","scanner is_a? "," dup ","StringScanner  new  rest "," dup   dup ip ","StringScanner  new  matched [] == ","StringScanner  new  matched [] ","StringScanner  new  matched "," dup  << ","StringScanner  new  scan ","StringScanner  new  is_a? "]}," Haml Util handle_interpolation":{"type":"method","name":"handle_interpolation","children":[],"call":["scan rest ","scan scan ","StringScanner  new ","StringScanner  new  rest ","StringScanner  new  StringScanner  new  "]}," Haml Compiler precompiled_method_return_value_with_haml_xss":{"type":"method","name":"precompiled_method_return_value_with_haml_xss","children":[],"call":[" precompiled_method_return_value_without_haml_xss "]}," Haml HTML Elem haml_attribute_pair":{"type":"method","name":"haml_attribute_pair","children":[],"call":["name inspect ","name index ","options [] ","value inspect "," dynamic_attributes [] "," dynamic_attributes "," dynamic_attribute? ","name inspect  inspect ","name inspect  index ","value inspect  inspect "," dynamic_attributes []  inspect "]}," Haml Filters Erb precompiled":{"type":"method","name":"precompiled","children":[],"call":[" sub "," require ","(const\n  (const\n    (cbase) :Erubis) :Eruby) ! "]}," Haml Filters PrecompiledTiltFilter compile":{"type":"method","name":"compile","children":[],"call":["compiler send "," precompiled ","compiler options [] ","compiler options "]}," Haml Filters PrecompiledTiltFilter precompiled":{"type":"method","name":"precompiled","children":[],"call":["(send\n  (send nil :template_class) :new\n  (nil)\n  (int 1)\n  (send nil :options)) send first ","(send\n  (send nil :template_class) :new\n  (nil)\n  (int 1)\n  (send nil :options)) send "," template_class new "," options "," template_class "]}," Haml Filters TiltFilter extended":{"type":"method","name":"extended","children":[{"type":"method","name":"render","children":[],"asgn":[],"call":["(send\n  (send nil :template_class) :new\n  (nil)\n  (int 1)\n  (send nil :options)) render "," template_class new "," options "," template_class ","Haml Util  silence_warnings "]}],"call":[]}," Haml Filters TiltFilter template_class":{"type":"method","name":"template_class","children":[],"call":[" raise ","Error  new ","Tilt  [] "," tilt_extension ","Error  message ","e message split last strip ","e message split last ","e message split ","e message "]}," Haml Filters register_tilt_filter":{"type":"method","name":"register_tilt_filter","children":[],"call":["Filters  defined []= ","x to_s ","Filters  defined ","(send\n  (lvar :options) :[]\n  (sym :alias)) flatten each ","(send\n  (lvar :options) :[]\n  (sym :alias)) flatten ","options [] ","options has_key? ","filter tilt_extension= ","name downcase ","options fetch ","filter template_class= ","filter extend "," const_set ","Module  new "," raise "," constants map include? ","name to_s "," constants map "," constants "," const_get "," const_set  tilt_extension= "," const_set  template_class= "," const_set  extend "]}," Haml Engine set_up_encoding":{"type":"method","name":"set_up_encoding","children":[],"call":["ops []= ","ops [] name ","ops [] ","ops [] is_a? ","ops [] name == ","template encoding ","Encoding  default_internal ","@options tap "]}," Haml Compiler flatten_data_attributes":{"type":"method","name":"flatten_data_attributes","children":[],"call":[]}," Haml Compiler build_data_keys":{"type":"method","name":"build_data_keys","children":[],"call":[]}," Haml Compiler nuke_inner_whitespace?":{"type":"method","name":"nuke_inner_whitespace?","children":[],"call":[" nuke_inner_whitespace? ","node parent ","node value [] ","node value "]}," Haml Buffer new_encoded_string":{"type":"method","name":"new_encoded_string","children":[],"call":[" encode ","Encoding  find "," options [] "," options "]}," Haml Util unescape_interpolation":{"type":"method","name":"unescape_interpolation","children":[],"call":["res + ","res << ","#{ + + ","#{ + "," eval ","\" + + ","\" + "," balance [] [] "," balance [] "," balance ","escapes % == ","escapes % ","scan matched [] ","-3 - ","scan matched ","(send\n  (send\n    (send\n      (lvar :scan) :[]\n      (int 2)) :size) :-\n  (int 1)) / ","scan [] size - ","scan [] size ","scan [] ","Haml Util  handle_interpolation ","str dump ","content prepend ","char == ","scan scan "," dup "," dup  + "," dup  << ","(send\n  (send\n    (send\n      (lvar :scan) :[]\n      (int 2)) :size) :-\n  (int 1)) /  % == ","(send\n  (send\n    (send\n      (lvar :scan) :[]\n      (int 2)) :size) :-\n  (int 1)) /  % "," eval  prepend ","scan []  == "]}," Haml Util contains_interpolation?":{"type":"method","name":"contains_interpolation?","children":[],"call":["str include? ","(str \"#[\\\\{$@]\") === "]}," Haml Parser initialize":{"type":"method","name":"initialize","children":[],"call":["(send\n  (lvar :template) :rstrip) split + ","(send\n  (lvar :template) :rstrip) split ","template rstrip ","@template << ","Line  new ","@template size ","text rstrip ","match each_with_index map ","match each_with_index ","match pop ","template rstrip scan ","Options  wrap "," children ","options key? ! ","options key? ","ParserOptions  new ","(send\n  (lvar :template) :rstrip) split +  << ","(send\n  (lvar :template) :rstrip) split +  size ","template rstrip scan  each_with_index map ","template rstrip scan  each_with_index ","template rstrip scan  pop "]}," Haml Options defaults":{"type":"method","name":"defaults","children":[],"call":[" class defaults "," class ","Haml TempleEngine  options to_hash merge ","Haml TempleEngine  options to_hash ","Haml TempleEngine  options "]}," Haml Options for_buffer":{"type":"method","name":"for_buffer","children":[],"call":["hash []= "," send "," class buffer_option_keys inject "," class buffer_option_keys "," class "," class buffer_defaults [] != "," class buffer_defaults [] "," class buffer_defaults "," public_send "]}," Haml Options encoding=":{"type":"method","name":"encoding=","children":[],"call":["@encoding upcase == ","@encoding upcase ","value to_s ","value name ","value is_a? ","value to_s  upcase == ","value name  upcase == ","value to_s  upcase ","value name  upcase "]}," Haml Options remove_whitespace=":{"type":"method","name":"remove_whitespace=","children":[],"call":[]}," Haml Options format=":{"type":"method","name":"format=","children":[],"call":[" raise ","value inspect "," class valid_formats include? "," class valid_formats "," class "]}," Haml Options format":{"type":"method","name":"format","children":[],"call":[" mime_type == "," mime_type "]}," Haml Options attr_wrapper=":{"type":"method","name":"attr_wrapper=","children":[],"call":[" class defaults [] "," class defaults "," class "]}," Haml Options html5?":{"type":"method","name":"html5?","children":[],"call":[" format == "," format "]}," Haml Options html4?":{"type":"method","name":"html4?","children":[],"call":[" format == "," format "]}," Haml Options html?":{"type":"method","name":"html?","children":[],"call":[" html5? "," html4? "]}," Haml Options xhtml?":{"type":"method","name":"xhtml?","children":[],"call":[" html? ! "," html? "]}," Haml Options []=":{"type":"method","name":"[]=","children":[],"call":[" send "]}," Haml Options []":{"type":"method","name":"[]","children":[],"call":[" send "]}," Haml Options initialize":{"type":"method","name":"initialize","children":[],"call":[" block_given? "," send ","(send\n  (lvar :values) :reject) each ","v nil? "," defaults has_key? ! "," defaults has_key? "," defaults ","values reject "," instance_variable_set "," defaults each ","v nil? ! ","values each "]}," Haml Options buffer_option_keys":{"type":"method","name":"buffer_option_keys","children":[],"call":[]}," Haml Options valid_formats":{"type":"method","name":"valid_formats","children":[],"call":[]}," Haml Engine initialize_encoding":{"type":"method","name":"initialize_encoding","children":[],"call":["@options encoding= ","@template encoding ","Encoding  default_internal "]}," Haml Compiler precompiled_with_return_value":{"type":"method","name":"precompiled_with_return_value","children":[],"call":[" precompiled + + "," precompiled_method_return_value "," precompiled + "," precompiled "]}," Haml Compiler precompiled":{"type":"method","name":"precompiled","children":[],"call":["@precompiled encode ","@precompiled force_encoding ","encoding == ","Encoding  find ","@options [] ","@options encoding ","@precompiled force_Encoding  find  ","Encoding  find  == ","@options Encoding  find  "]}," Haml Compiler initialize":{"type":"method","name":"initialize","children":[],"call":["AttributeCompiler  new ","Options  wrap ","Filters  defined merge ","options [] ","Filters  defined ","TagCompiler  new ","SilentScriptCompiler  new ","ScriptCompiler  new ","Filters  new ","DoctypeCompiler  new ","CommentCompiler  new ","ChildrenCompiler  new ","Identity  new "]}," Haml Options cdata":{"type":"method","name":"cdata","children":[],"call":[" xhtml? "]}," Haml Error message":{"type":"method","name":"message","children":[],"call":[]}," Haml Parser check_push_script_stack":{"type":"method","name":"check_push_script_stack","children":[],"call":["@script_level_stack last << ","@script_level_stack last ","keyword == ","@script_level_stack push ","@line tabs ","keyword to_sym ","(str \"if\") include? "]}," Haml SafeErubisTemplate precompiled_postamble":{"type":"method","name":"precompiled_postamble","children":[],"call":["(zsuper) join "]}," Haml SafeErubisTemplate precompiled_preamble":{"type":"method","name":"precompiled_preamble","children":[],"call":["(zsuper) join "]}," Haml SafeErubisTemplate prepare":{"type":"method","name":"prepare","children":[],"call":["@options merge! "]}," Haml SafeErubisTemplate initialize_engine":{"type":"method","name":"initialize_engine","children":[],"call":[]}," Haml Filters ScssRailsTemplate syntax":{"type":"method","name":"syntax","children":[],"call":[]}," Haml Filters SassRailsTemplate sass_options":{"type":"method","name":"sass_options","children":[],"call":["options [] []= "," ActionView Base  new ","options [] "]}," Haml Filters SassRailsTemplate render":{"type":"method","name":"render","children":[],"call":[" Rails  application assets context_class new "," Rails  application assets "," Rails  application "," Rails  application assets context_class ","environment context_class new ","environment context_class "," Sprockets Railtie  build_environment ","Rails  application "," Sprockets Railtie  build_environment  context_class new "," Sprockets Railtie  build_environment  context_class "," Sprockets Railtie  build_ Sprockets Railtie  build_environment  "]}," Haml Filters remove_filter":{"type":"method","name":"remove_filter","children":[],"call":[" remove_const ","name to_sym "," constants map include? ","name to_s "," constants map "," constants "," defined delete ","name downcase "," defined ","name to_s downcase "," registered delete ","name to_s downcase to_sym "," registered "]}," ActionView Helpers HamlSupport is_haml?":{"type":"method","name":"is_haml?","children":[],"call":["@template_object send "]}," ActionView Helpers HamlSupport haml_buffer":{"type":"method","name":"haml_buffer","children":[],"call":["@template_object send "]}," Haml Buffer fix_textareas!":{"type":"method","name":"fix_textareas!","children":[],"call":["match [] ","content sub! ","match [] == ","pattern match ","input gsub! ","match [] to_s ","tabs nil? ","input include? ","<textarea freeze "," toplevel? ","pattern match  [] ","match []  sub! ","pattern match  [] == ","pattern pattern match  ","pattern match  [] to_s "]}," Haml ErubisTemplateHandler initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml ParseNode to_temple":{"type":"method","name":"to_temple","children":[],"call":[" send "," type "]}," Haml Temple Parser compile":{"type":"method","name":"compile","children":[],"call":["exp push "," compile ","node children map ","node children ","node children [] ","node children length == ","node children length ","node children empty? ","node to_temple ","node to_temple  push "]}," Haml Temple Parser call":{"type":"method","name":"call","children":[],"call":[" puts ","- * "," p "," compile tap "," compile ","parser parse tap ","parser parse "," Haml Parser  new "," Haml Parser  new  parse tap "," Haml Parser  new  parse "]}," Haml Temple Parser initialize":{"type":"method","name":"initialize","children":[],"call":["Options  new "]}," Haml Temple Expressions on_tag":{"type":"method","name":"on_tag","children":[],"call":["exp last << ","exp last ","attribs each "," value [] "," value ","exp push << ","exp push "," value [] != "," value []  each "]}," Haml Temple Expressions on_doctype":{"type":"method","name":"on_doctype","children":[],"call":[" value [] "," value "]}," Haml Temple Expressions on_root":{"type":"method","name":"on_root","children":[],"call":[]}," Haml Temple Expressions on_plain":{"type":"method","name":"on_plain","children":[],"call":["\n + "," value [] "," value "]}," Haml Helpers prettify":{"type":"method","name":"prettify","children":[],"call":["(send\n  (lvar :text) :map) join ","line slice ","line length ","text map ","min_tabs > ","line index ","text each ","text delete ","text split ","(send\n  (lvar :text split ) :map) join ","text split  map ","text split  each ","text split  delete ","text split  split "]}," Haml Parser Line strip!":{"type":"method","name":"strip!","children":[],"call":[" text lstrip! "," text "," text= "," text [] "]}," Haml Parser compute_tabs":{"type":"method","name":"compute_tabs","children":[],"call":[" raise ","SyntaxError  new ","line index ","Error  message ","Haml Util  human_indentation ","line whitespace ","@template_tabs + ","line whitespace =~ "," flat? ","line whitespace == ","@indentation * ","line whitespace length / ","@indentation length ","line whitespace length ","@indentation include? ","@indentation nil? ","line whitespace ! ","line text empty? ","line text "," human_indentation ","HamlSyntaxError  new ","HamlError  message ","Error  Error  message  ","Error  HamlError  message  ","@template_line whitespace length /  + ","line whitespace  * ","line whitespace  length ","line whitespace  include? ","line whitespace  nil? ","HamlError  Error  message  ","HamlError  HamlError  message  "]}," Haml Helpers haml_tag_if":{"type":"method","name":"haml_tag_if","children":[],"call":["ErrorReturn  new "," haml_tag "]}," Haml TempleLineCounter count_lines":{"type":"method","name":"count_lines","children":[],"call":[]}," Haml TempleEngine inspect_obj":{"type":"method","name":"inspect_obj","children":[],"call":["obj inspect "," inspect_obj ","obj to_s ","s inspect [] ","s inspect ","obj gsub "]}," Haml TempleEngine locals_code":{"type":"method","name":"locals_code","children":[],"call":["code << "," inspect_obj ","name to_s ","name to_sym ","names each_with_object ","names keys ","Hash  === ","(send\n  (lvar :names) :map) join ","names map ","names keys  each_with_object ","names keys  keys ","(send\n  (lvar :names keys ) :map) join ","names keys  map "]}," Haml TempleEngine precompiled_method_return_value":{"type":"method","name":"precompiled_method_return_value","children":[],"call":[]}," Haml TempleEngine initialize_encoding":{"type":"method","name":"initialize_encoding","children":[],"call":["template encoding ","Encoding  default_internal "]}," Haml TempleEngine precompiled_with_ambles":{"type":"method","name":"precompiled_with_ambles","children":[],"call":[" precompiled "," locals_code ","(begin\n  (send nil :precompiled_method_return_value)) tr! "," precompiled_method_return_value ","(str \"begin\\n\") tr! ","Options  new for_buffer inspect ","Options  new for_buffer ","Options  new "," options ","(begin\n  (lvar :preamble)) dup ","(begin\n  (send nil :precompiled_method_return_value)) tr ","(str \"begin\\n\") tr ","(begin\n  (lvar :before_postamble)) tr ","(begin\n  (send\n    (lvar :after_preamble) :tr\n    (str \"\\n\")\n    (str \";\"))) dup ","after_preamble tr ","(begin\n  (lvar :(str \"begin\\n\") tr! )) dup ","(begin\n  (lvar :(str \"begin\\n\") tr )) dup ","(begin\n  (lvar :before_(begin\n  (send nil :precompiled_method_return_value)) tr! )) tr ","(begin\n  (lvar :before_(begin\n  (send nil :precompiled_method_return_value)) tr )) tr ","(begin\n  (lvar :before_(begin\n  (lvar :before_postamble)) tr )) tr ","(begin\n  (send\n    (lvar :after_(str \"begin\\n\") tr! ) :tr\n    (str \"\\n\")\n    (str \";\"))) dup ","(begin\n  (send\n    (lvar :after_(str \"begin\\n\") tr ) :tr\n    (str \"\\n\")\n    (str \";\"))) dup ","after_(str \"begin\\n\") tr!  tr ","after_(str \"begin\\n\") tr  tr "]}," Haml TempleEngine precompiled_with_return_value":{"type":"method","name":"precompiled_with_return_value","children":[],"call":[" precompiled_method_return_value "," precompiled ","(begin\n  (send nil :precompiled)) dup "]}," Haml TempleEngine precompiled":{"type":"method","name":"precompiled","children":[],"call":["@precompiled encode ","@precompiled force_encoding ","encoding == ","Encoding  find ","@precompiled dup force_encoding ","@precompiled dup ","@precompiled force_Encoding  find  ","Encoding  find  == ","@precompiled dup force_Encoding  find  "]}," Haml TempleEngine compile":{"type":"method","name":"compile","children":[],"call":[" call "," initialize_encoding "," options [] "," options "]}," Haml TempleEngine precompiled_method_return_value_with_haml_xss":{"type":"method","name":"precompiled_method_return_value_with_haml_xss","children":[],"call":[" precompiled_method_return_value_without_haml_xss "]}," Haml Template Options []=":{"type":"method","name":"[]=","children":[],"call":["Haml Options  buffer_defaults []= ","Haml Options  buffer_defaults ","Haml Options  buffer_defaults key? "]}," Haml Parser close_flat_section":{"type":"method","name":"close_flat_section","children":[],"call":[]}," Haml Parser continuation_script?":{"type":"method","name":"continuation_script?","children":[],"call":[" mid_block_keyword? ","text [] == ","text [] "]}," Haml Parser DynamicAttributes stripped_old":{"type":"method","name":"stripped_old","children":[],"call":[" old sub! sub! "," old sub! "," old "," old nil? "]}," Haml Parser DynamicAttributes to_literal":{"type":"method","name":"to_literal","children":[],"call":["(send nil :new) compact join ","(send nil :new) compact "," stripped_old "," new "]}," Haml Parser DynamicAttributes old=":{"type":"method","name":"old=","children":[],"call":[" raise ","ArgumentError  new ","value =~ "]}," Haml Parser call":{"type":"method","name":"call","children":[],"call":[" raise ","e backtrace unshift ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (send\n    (send\n      (ivar :@line) :index) :+\n    (int 1))) + - ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (send\n    (send\n      (ivar :@line) :index) :+\n    (int 1))) + ","@options line ","@line index + ","@line index ","e line + ","e line ","@options filename ","e backtrace "," close ","@parent type == ","@parent type ","SyntaxError  new ","@next_line index ","Error  message ","@next_line tabs - ","@line tabs ","@next_line tabs ","@next_line tabs - > "," flat? ! "," flat? ","@parent children last ","@parent children "," block_opened? "," process_line ","@line text empty? ","@line text ","@filter_buffer << ","text gsub! ","@line full dup ","@line full "," process_indent "," next_line "," loop ","@line tabs != ","ParseNode  new ","@template << ","Line  new ","@template size ","text rstrip ","match each_with_index map ","match each_with_index ","match pop ","template rstrip scan ","template rstrip "," error_with_lineno ","Haml Error  new ","Haml Util  check_haml_encoding ","HamlSyntaxError  new ","HamlError  message ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (send\n    (send\n      (ivar : next_line ) :index) :+\n    (int 1))) + - ","(if\n  (send\n    (lvar :e) :line)\n  (send\n    (send\n      (lvar :e) :line) :+\n    (int 1))\n  (send\n    (send\n      (ivar : next_line ) :index) :+\n    (int 1))) + "," next_line  index + "," next_line  index ","@parent children last  type == ","ParseNode  new  type == ","@parent children last  type ","ParseNode  new  type "," next_line  tabs ","@parent children last  children last ","ParseNode  new  children last ","@parent children last  children ","ParseNode  new  children ","@line @line full dup  empty? "," next_line  text empty? ","@line @line full dup  "," next_line  text ","@line full dup  gsub! "," next_line  full dup "," next_line  full "," next_line  tabs != ","@line full dup  rstrip ","template rstrip scan  each_with_index map ","template rstrip scan  each_with_index ","template rstrip scan  pop "]}," Haml Options wrap":{"type":"method","name":"wrap","children":[],"call":["Options  new ","options is_a? "]}," Haml Options buffer_defaults":{"type":"method","name":"buffer_defaults","children":[],"call":["hash merge "," defaults [] "," defaults "," buffer_option_keys inject "," buffer_option_keys "]}," Haml Helpers haml_internal_concat":{"type":"method","name":"haml_internal_concat","children":[],"call":[" haml_buffer buffer << ","text to_s gsub "," haml_indent ","text to_s "," haml_buffer buffer "," haml_buffer "," haml_buffer tabulation == "," haml_buffer tabulation "]}," Haml Helpers XssMods haml_internal_concat_with_haml_xss":{"type":"method","name":"haml_internal_concat_with_haml_xss","children":[],"call":[" haml_internal_concat_without_haml_xss "," haml_xss_html_escape "]}," Haml SafeErubiTemplate precompiled_postamble":{"type":"method","name":"precompiled_postamble","children":[],"call":["(zsuper) join "]}," Haml SafeErubiTemplate precompiled_preamble":{"type":"method","name":"precompiled_preamble","children":[],"call":["(zsuper) join "]}," Haml SafeErubiTemplate prepare":{"type":"method","name":"prepare","children":[],"call":["@options merge! "]}," Haml ErubiTemplateHandler initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml Helpers ActionViewMods output_buffer=":{"type":"method","name":"output_buffer=","children":[],"call":[" haml_buffer buffer= "," haml_buffer ","String  new ","new_buffer is_a? ","Haml Util  rails_xss_safe? "," is_haml? ","String  new  is_a? "]}," Haml Helpers ActionViewMods output_buffer":{"type":"method","name":"output_buffer","children":[],"call":[" haml_buffer buffer "," haml_buffer "," is_haml? "]}," Haml Helpers ActionViewMods render":{"type":"method","name":"render","children":[],"call":[" non_haml ","(and\n  (and\n    (send\n      (lvar :options) :is_a?\n      (const nil :Hash))\n    (send\n      (lvar :options) :[]\n      (sym :layout)))\n  (send nil :block_given?)) ! "," block_given? ","options [] ","options is_a? "," is_haml? ","args first ","(and\n  (and\n    (send\n      (lvar :args first ) :is_a?\n      (const nil :Hash))\n    (send\n      (lvar :args first ) :[]\n      (sym :layout)))\n  (send nil :block_given?)) ! ","args first  [] ","args first  is_a? "]}," Haml Generator concat":{"type":"method","name":"concat","children":[],"call":[]}," Haml Generator on_newline":{"type":"method","name":"on_newline","children":[],"call":[]}," Haml Generator on_code":{"type":"method","name":"on_code","children":[],"call":[]}," Haml Generator on_dynamic":{"type":"method","name":"on_dynamic","children":[],"call":[" concat "]}," Haml Generator on_static":{"type":"method","name":"on_static","children":[],"call":[" concat ","Util  inspect_obj "," options [] "," options "]}," Haml Generator on_multi":{"type":"method","name":"on_multi","children":[],"call":["(send\n  (lvar :exp) :map) join "," compile ","exp map "]}," Haml Generator call":{"type":"method","name":"call","children":[],"call":[" compile "]}," Haml Exec Haml validate_ruby":{"type":"method","name":"validate_ruby","children":[],"call":[" eval ","@options [] "," binding "]}," Haml Escapable on_dynamic":{"type":"method","name":"on_dynamic","children":[],"call":["@escape_code % ","@once_escape_code % ","@escape == "," escape_code "," escape_once_code "]}," Haml Escapable on_static":{"type":"method","name":"on_static","children":[],"call":["@escaper [] ","@once_escaper [] ","@escape == "," escape "," escape_once "]}," Haml Escapable on_escape":{"type":"method","name":"on_escape","children":[],"call":[" compile ","flag value ","flag is_a? "]}," Haml Escapable initialize":{"type":"method","name":"initialize","children":[],"call":[" eval ","@once_escape_code % ","@escape_code % "," options [] "," options "]}," Haml Engine compiler":{"type":"method","name":"compiler","children":[],"call":[]}," Haml Compiler build_script_formatter":{"type":"method","name":"build_script_formatter","children":[],"call":["opts [] "]}," Haml Compiler push_temple":{"type":"method","name":"push_temple","children":[],"call":["TempleLineCounter  count_lines ","@temple << ","@temple concat ","(array\n  (sym :newline)) * "," resolve_newlines count "," resolve_newlines "," flush_merged_text ","newlines empty? "," resolve_ resolve_newlines  count "," resolve_ resolve_newlines  "," resolve_newlines  empty? "]}," Haml Compiler call":{"type":"method","name":"call","children":[],"call":[" compile "," runtime_error ","ast is_a? "]}," Haml AttributeParser each_balaned_tokens":{"type":"method","name":"each_balaned_tokens","children":[],"call":["block call ","attr_tokens empty? ","attr_tokens << ","open_tokens [] ","open_tokens values all? ","open_tokens values ","token [] ","tokens each ","h []= ","Hash  new "]}," Haml AttributeParser each_attribute":{"type":"method","name":"each_attribute","children":[],"call":["block call ","tokens map join strip ","tokens map join ","tokens map "," shift_key! "," each_balaned_tokens ","all_tokens [] ","Ripper  lex ","hash_literal strip ","(send\n  (lvar :tokens) :map) join strip ","(send\n  (lvar :tokens) :map) join ","t [] "," each_balanced_tokens "," shift_ shift_key! ! ","Ripper  lex  [] "]}," Haml AttributeParser shift_hash_rocket!":{"type":"method","name":"shift_hash_rocket!","children":[],"call":["str == ","type == ","tokens shift ","tokens empty? "]}," Haml AttributeParser expect_string_end!":{"type":"method","name":"expect_string_end!","children":[],"call":[" raise ","token [] != ","token [] "]}," Haml AttributeParser shift_key!":{"type":"method","name":"shift_key!","children":[],"call":[" raise ","UnexpectedKeyError  new "," shift_hash_rocket! "," expect_string_end! ","next_token [] != ","next_token [] ","tokens shift ","tokens shift [] ","first_text != ","first_text tr ","IGNORED_TYPES  include? ","tokens first [] ","tokens first ","tokens empty? ! ","tokens empty? ","tokens shift  [] != ","tokens shift  [] "]}," Haml AttributeParser hash_literal?":{"type":"method","name":"hash_literal?","children":[],"call":["body [] [] == ","body [] [] ","body [] ","body size == ","body size ","body is_a? ","sym == ","Ripper  sexp ","Temple StaticAnalyzer  syntax_error? "]}," Haml AttributeParser parse":{"type":"method","name":"parse","children":[],"call":["hash []= "," each_attribute "," hash_literal? ","attr_tokens map join strip ","attr_tokens map join ","attr_tokens map "," parse_key! "," each_attr ","Ripper  lex [] ","Ripper  lex ","Temple StaticAnalyzer  syntax_error? "," wrap_bracket ","(send\n  (lvar :attr_tokens) :map) join strip ","(send\n  (lvar :attr_tokens) :map) join ","t [] ","RubyExpression  syntax_error? "," parse_ parse_key! ! "]}," Haml AttributeParser available?":{"type":"method","name":"available?","children":[],"call":["Temple StaticAnalyzer  available? "]}," Haml AttributeCompiler unique_name":{"type":"method","name":"unique_name","children":[],"call":[]}," Haml AttributeCompiler true_value":{"type":"method","name":"true_value","children":[],"call":[]}," Haml AttributeCompiler compile_common_attribute":{"type":"method","name":"compile_common_attribute","children":[],"call":[" true_value "," runtime_build ","AttributeValue  new "," merged_value "," unique_name ","Escapable EscapeSafeBuffer  new "]}," Haml AttributeCompiler compile_id_or_class_attribute":{"type":"method","name":"compile_id_or_class_attribute","children":[],"call":[" runtime_build ","AttributeValue  new "," merged_value "," unique_name ","Escapable EscapeSafeBuffer  new "]}," Haml AttributeCompiler compile_attribute":{"type":"method","name":"compile_attribute","children":[],"call":[" compile_common_attribute "," compile_id_or_class_attribute "," static_build ","Temple StaticAnalyzer  static? ","v to_literal ","values all? "," attr_literal "]}," Haml AttributeCompiler frozen_string":{"type":"method","name":"frozen_string","children":[],"call":["Haml Util  inspect_obj "," to_literal "]}," Haml AttributeCompiler merged_value":{"type":"method","name":"merged_value","children":[],"call":["values map join ","values map "," frozen_string ","values first to_literal ","values first ","values size == ","values size "," method "," attr_literal "]}," Haml AttributeCompiler static_build":{"type":"method","name":"static_build","children":[],"call":[" eval to_s "," eval ","(send\n  (lvar :arguments) :map) join ","Haml Util  inspect_obj ","arguments map ","(send\n  (send\n    (lvar :values) :group_by\n    (block-pass\n      (sym :key))) :map) join "," merged_value "," frozen_string ","values group_by map ","values group_by ","arguments map join "," method "]}," Haml AttributeCompiler runtime_build":{"type":"method","name":"runtime_build","children":[],"call":["(send\n  (send\n    (lvar :values) :group_by\n    (block-pass\n      (sym :key))) :map) join "," merged_value "," frozen_string ","values group_by map ","values group_by ","(ivar :@is_html) map join ","(ivar :@is_html) map "," method "]}," Haml AttributeCompiler compile_attribute_values":{"type":"method","name":"compile_attribute_values","children":[],"call":[" runtime_build "," compile_attribute ","values first key ","values first ","values map uniq size == ","values map uniq size ","values map uniq ","values map "]}," Haml AttributeCompiler build_attribute_values":{"type":"method","name":"build_attribute_values","children":[],"call":["attribute_values << ","AttributeValue  new ","parsed_hash each ","parsed_hashes each ","attributes each "," tap "]}," Haml AttributeCompiler compile":{"type":"method","name":"compile","children":[],"call":[" compile_attribute_values ","values_by_base_key [] ","values_by_base_key keys sort map ","values_by_base_key keys sort ","values_by_base_key keys ","attribute_values group_by ","AttributeBuilder  verify_attribute_names! ","attribute_values map "," build_attribute_values ","AttributeCompiler  runtime_build ","AttributeParser  parse ","(send\n  (lvar :dynamic_attributes) :new) compact map ","(send\n  (lvar :dynamic_attributes) :new) compact ","dynamic_attributes old ","dynamic_attributes new ","AttributeParser  available? ! ","AttributeParser  available? ","object_ref != ","attributes_hashes map "," group_values_for_sort map "," group_values_for_sort "," compile_runtime_build "," static_compile ","node value [] ","node value ","hashes << "," runtime_compile ","(send\n  (send\n    (send\n      (lvar :node) :value) :[]\n    (sym :dynamic_attributes)) :new) compact each ","(send\n  (send\n    (send\n      (lvar :node) :value) :[]\n    (sym :dynamic_attributes)) :new) compact ","node value [] old ","node value [] new ","Ripper  respond_to? ! ","Ripper  respond_to? ","node value [] != ","value empty? ","hash any? ","hash nil? "," compile_ build_attribute_values  ","attribute_values group_by  [] ","attribute_values group_by  keys sort map ","attribute_values group_by  keys sort ","attribute_values group_by  keys "," build_attribute_values  group_by "," build_attribute_values  map "," build_ build_attribute_values  ","attributes_AttributeParser  parse es map ","AttributeParser  parse es << ","AttributeParser  parse  any? ","AttributeParser  parse  nil? "]}," Haml AttributeCompiler initialize":{"type":"method","name":"initialize","children":[],"call":["options [] ","(sym :html4) include? "]}," Haml AttributeCompiler AttributeValue base_key":{"type":"method","name":"base_key","children":[],"call":[" key split first "," key split "," key "]}," Haml AttributeCompiler AttributeValue to_literal":{"type":"method","name":"to_literal","children":[],"call":[" value ","Haml Util  inspect_obj "," type "]}," Haml AttributeBuilder flatten_data_attributes":{"type":"method","name":"flatten_data_attributes","children":[],"call":["hash merge! "," flatten_data_attributes ","(lvar :key) join ","key == ","(send\n  (lvar :data) :sort) inject ","x [] to_s <=> ","y [] to_s ","y [] ","x [] to_s ","x [] ","data sort ","seen << ","data object_id ","seen include? ","data is_a? "]}," Haml AttributeBuilder build_data_keys":{"type":"method","name":"build_data_keys","children":[],"call":["Hash  [] ","name to_s tr ","name to_s ","name == ","data_hash map "]}," Haml AttributeBuilder merge_value":{"type":"method","name":"merge_value","children":[],"call":["(send\n  (send\n    (lvar :merged_class) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort join ","(send\n  (send\n    (lvar :merged_class) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort ","merged_class split | ","to split ","merged_class split "," filter_and_join ","key == ","to merge ","to is_a? ! ","to is_a? ","from is_a? ! ","from is_a? ","to kind_of? ","from kind_of? ","(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :merged_class) :split\n    (str \" \"))) join ","to split | ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :merged_class) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort join ) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort join ","(send\n  (send\n    (lvar : filter_and_join ) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort join ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :merged_class) :split\n    (str \" \"))) join ) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort join ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :merged_class) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort join ) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort ","(send\n  (send\n    (lvar : filter_and_join ) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :merged_class) :split\n    (str \" \"))) join ) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort ","(send\n  (send\n    (lvar :merged_class) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort join  split | "," filter_and_join  split | ","(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :merged_class) :split\n    (str \" \"))) join  split | ","(send\n  (send\n    (lvar :merged_class) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort join  split "," filter_and_join  split ","(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :merged_class) :split\n    (str \" \"))) join  split ","(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :(send\n  (send\n    (lvar :merged_class) :split\n    (str \" \")) :|\n  (send\n    (lvar :to) :split\n    (str \" \"))) sort join ) :split\n    (str \" \"))) join ","(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar : filter_and_join ) :split\n    (str \" \"))) join ","(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :merged_class) :split\n    (str \" \"))) join ) :split\n    (str \" \"))) join "]}," Haml AttributeBuilder verify_attribute_names!":{"type":"method","name":"verify_attribute_names!","children":[],"call":[" raise ","InvalidAttributeNameError  new ","attribute_name =~ ","attribute_names each "]}," Haml AttributeBuilder merge_values":{"type":"method","name":"merge_values","children":[],"call":[" merge_value ","values inject "]}," Haml AttributeBuilder merge_attributes!":{"type":"method","name":"merge_attributes!","children":[],"call":["to []= "," merge_value ","from [] ","to [] ","from keys each ","from keys "]}," Haml AttributeBuilder filter_and_join":{"type":"method","name":"filter_and_join","children":[],"call":["value empty? ! ","value empty? ","value nil? ! ","value nil? ","value to_s ","value join ","value compact! ","item to_s ","value map! ","value flatten ","value is_a? ","value respond_to? ","value to_s  empty? ! ","value join  empty? ! ","value flatten  empty? ! ","value to_s  empty? ","value join  empty? ","value flatten  empty? ","value to_s  nil? ! ","value join  nil? ! ","value flatten  nil? ! ","value to_s  nil? ","value join  nil? ","value flatten  nil? ","value to_s  to_s ","value join  to_s ","value flatten  to_s ","value to_s  join ","value join  join ","value flatten  join ","value to_s  compact! ","value join  compact! ","value flatten  compact! ","value to_s  map! ","value join  map! ","value flatten  map! ","value to_s  flatten ","value join  flatten ","value flatten  flatten ","value to_s  is_a? ","value join  is_a? ","value flatten  is_a? ","value to_s  respond_to? ","value join  respond_to? ","value flatten  respond_to? "]}," Haml AttributeBuilder build_attributes":{"type":"method","name":"build_attributes","children":[],"call":["result join ","result sort! ","result compact! ","value to_s ","Haml Helpers  html_escape ","Haml Helpers  escape_once ","escape_attrs == ","value == "," filter_and_join ","attr == ","value nil? ","attributes collect ","data_attributes merge "," verify_attribute_names! ","data_attributes keys "," build_data_keys "," flatten_data_attributes ","attributes delete ","value is_a? ","attributes each ","Haml Helpers  html_escape_without_haml_xss ","Haml Helpers  escape_once_without_haml_xss ","Haml Helpers  escape_once  to_s "," filter_and_join  to_s ","Haml Helpers  escape_once_without_haml_xss  to_s ","Haml Helpers  escape_once  == "," filter_and_join  == ","Haml Helpers  escape_once_without_haml_xss  == ","Haml Helpers  escape_once  nil? "," filter_and_join  nil? ","Haml Helpers  escape_once_without_haml_xss  nil? ","data_attributes merge  collect ","data_data_attributes merge  merge "," build_data_keys  merge "," flatten_data_attributes  merge ","attributes delete  merge ","data_data_attributes merge  keys "," build_data_keys  keys "," flatten_data_attributes  keys ","attributes delete  keys "," flatten_data_data_attributes merge  "," flatten_ build_data_keys  "," flatten_ flatten_data_attributes  "," flatten_attributes delete  ","data_attributes merge  delete ","Haml Helpers  escape_once  is_a? "," filter_and_join  is_a? ","Haml Helpers  escape_once_without_haml_xss  is_a? ","data_attributes merge  each "]}," Haml Buffer preserve":{"type":"method","name":"preserve","children":[],"call":["Haml Helpers  find_and_preserve "," options [] "," options ","Haml Helpers  preserve "]}," Haml Buffer format_script":{"type":"method","name":"format_script","children":[],"call":[" fix_textareas! ","result include? "," toplevel? "," preserve ","result_name strip ","result to_s "," html_escape "," preserve  include? ","result_name strip  include? "," preserve _name strip ","result_name strip _name strip ","result to_s  strip "," html_escape  strip "," preserve  to_s ","result_name strip  to_s "]}," Haml AttributeParser each_attr":{"type":"method","name":"each_attr","children":[],"call":["attr_tokens empty? ","attr_tokens << ","paren_open == ","brace_open == ","array_open == ","tokens each ","open_tokens [] ","open_tokens values all? ","open_tokens values ","h []= ","Hash  new "]}," Haml AttributeParser skip_until_hash_rocket!":{"type":"method","name":"skip_until_hash_rocket!","children":[],"call":["str == ","type == ","tokens shift ","tokens empty? "]}," Haml AttributeParser assert_type!":{"type":"method","name":"assert_type!","children":[],"call":[" raise ","token [] != ","token [] "]}," Haml AttributeParser parse_key!":{"type":"method","name":"parse_key!","children":[],"call":[" raise "," skip_until_hash_rocket! "," assert_type! ","next_token [] == ","next_token [] ","tokens shift ","str != ","str tr "," parse_key! ","tokens shift  [] == ","tokens shift  [] "]}," Haml AttributeParser wrap_bracket":{"type":"method","name":"wrap_bracket","children":[],"call":["text [] == ","text [] ","text strip ","text strip  [] == ","text strip  [] ","text strip  strip "]}," Haml AttributeCompiler group_values_for_sort":{"type":"method","name":"group_values_for_sort","children":[],"call":["value_groups << ","v key start_with? ","v key ","sorted_values partition ","sorted_values first key ","sorted_values first ","sorted_values empty? "," tap ","values sort_by ","v sorted_values first key  start_with? ","v sorted_values first key  ","values sort_by  partition ","sorted_values first sorted_values first key  ","values sort_by  first key ","values sort_by  first ","values sort_by  empty? "]}," Haml AttributeParser each_balanced_tokens":{"type":"method","name":"each_balanced_tokens","children":[],"call":["block call ","attr_tokens empty? ","attr_tokens << ","open_tokens [] ","open_tokens values all? ","open_tokens values ","token [] ","tokens each ","h []= ","Hash  new "]}," Haml Parser stripped_old":{"type":"method","name":"stripped_old","children":[],"call":[" old sub! sub! "," old sub! "," old "," old nil? "]}," Haml Parser to_literal":{"type":"method","name":"to_literal","children":[],"call":["(send nil :new) compact join ","(send nil :new) compact "," stripped_old "," new "]}," Haml Parser old=":{"type":"method","name":"old=","children":[],"call":[" []= "," raise ","ArgumentError  new ","value =~ "]}," Haml Parser inspect":{"type":"method","name":"inspect","children":[],"call":["s << ","c inspect gsub! ","c inspect "," children each_with_object "," children "," value inspect "," value "," type ","(str \"(\") dup "," dup "]}," Haml Parser strip!":{"type":"method","name":"strip!","children":[],"call":[" text lstrip! "," text "," text= "," text [] "]}," Haml Parser tabs":{"type":"method","name":"tabs","children":[],"call":[" parser compute_tabs "," parser "]}," Haml AttributeCompiler to_literal":{"type":"method","name":"to_literal","children":[],"call":[" value ","Haml Util  inspect_obj "," type ","value to_s "]}," Haml Escapable escape_code":{"type":"method","name":"escape_code","children":[],"call":[]}," Haml Escapable escape_once_code":{"type":"method","name":"escape_once_code","children":[],"call":[]}," Haml Escapable escape":{"type":"method","name":"escape","children":[],"call":[" Haml Helpers  html_escape "," Haml Helpers  html_escape_without_haml_xss "]}," Haml Escapable escape_once":{"type":"method","name":"escape_once","children":[],"call":[" Haml Helpers  escape_once "," Haml Helpers  escape_once_without_haml_xss "]}," Haml AttributeCompiler attr_literal":{"type":"method","name":"attr_literal","children":[],"call":["attr value "," to_literal ","attr type "]}," Haml AttributeCompiler compile_runtime_build":{"type":"method","name":"compile_runtime_build","children":[],"call":["dynamic_attributes to_literal "," to_literal ","(ivar :@is_html) map join ","(ivar :@is_html) map "," method "]}," Haml Parser balance_tokens":{"type":"method","name":"balance_tokens","children":[],"call":[" raise ","SyntaxError  new ","Error  message ","buf sub ","count == ","text << ","Ripper  lex each ","Ripper  lex "," dup ","HamlSyntaxError  new ","HamlError  message "," dup  << "]}," Haml AttributeBuilder underscore":{"type":"method","name":"underscore","children":[],"call":["word downcase! ","word tr! ","word gsub! ","camel_cased_word to_s dup ","camel_cased_word to_s ","camel_cased_word to_s dup  downcase! ","camel_cased_word to_s dup  tr! ","camel_cased_word to_s dup  gsub! ","camel_cased_camel_cased_word to_s dup  to_s dup ","camel_cased_camel_cased_word to_s dup  to_s "]}," Haml AttributeBuilder parse_object_ref":{"type":"method","name":"parse_object_ref","children":[],"call":["class freeze ","id freeze ","ref id ","key join ","key nil? ","ref to_key ","ref respond_to? "," underscore ","ref class ","ref haml_object_ref ","ref nil? ","ref [] ","ref []  id ","ref to_key  join ","ref to_key  nil? ","ref to_ref to_key  ","ref []  to_key ","ref []  respond_to? ","ref []  class ","ref []  haml_object_ref []  ","ref []  nil? ","ref []  [] "]}," Haml AttributeBuilder build":{"type":"method","name":"build","children":[],"call":[" build_attributes "," merge_attributes! "," parse_object_ref ","result []= ","k to_s ","old each ","attributes_hashes each "]}," Haml Util escape_html_safe":{"type":"method","name":"escape_html_safe","children":[],"call":[]}," Haml Util escape_html":{"type":"method","name":"escape_html","children":[],"call":[]}," Haml TemplateExtension compile":{"type":"method","name":"compile","children":[],"call":[]}," Haml StringSplitter compile":{"type":"method","name":"compile","children":[],"call":[" compile_tokens! "," raise ","tokens size ","tokens size < ","tokens pop ","(sym :on_comment) include? ","tokens last [] ","tokens last ","Ripper  lex ","code strip "," tap "," compile_Ripper  lex ! ","Ripper  lex  size ","Ripper  lex  size < ","Ripper  lex  pop ","Ripper  lex  last [] ","Ripper  lex  last "]}," Haml RubyExpression on_parse_error":{"type":"method","name":"on_parse_error","children":[],"call":[" raise "]}," Haml RubyExpression string_literal?":{"type":"method","name":"string_literal?","children":[],"call":[]}," Haml RubyExpression syntax_error?":{"type":"method","name":"syntax_error?","children":[],"call":[]}," Haml RailsTemplate supports_streaming?":{"type":"method","name":"supports_streaming?","children":[],"call":["RailsTemplate  options [] ","RailsTemplate  options "]}," Haml RailsTemplate call":{"type":"method","name":"call","children":[],"call":["Engine  new call ","Engine  new ","options merge ","template short_identifier ","template format == ","template format ","ActionView Base  try ","template type == ","template type ","template respond_to? ","RailsTemplate  options ","template source ","template identifier ","options merge  merge ","RailsTemplate  options  merge ","RailsTemplate  options merge  ","RailsTemplate  RailsTemplate  options  "]}," Haml RailsTemplate set_options":{"type":"method","name":"set_options","children":[],"call":[" options update "," options "]}," Haml RailsTemplate options":{"type":"method","name":"options","children":[],"call":[]}," Haml RailsHelpers capture_haml":{"type":"method","name":"capture_haml","children":[],"call":[" capture "]}," Haml RailsHelpers succeed":{"type":"method","name":"succeed","children":[],"call":["(begin\n  (send\n    (send nil :capture_haml\n      (block-pass\n        (lvar :block))) :chomp)) html_safe "," escape_once "," capture_haml chomp "," capture_haml ","str html_safe? "," escape_once  html_safe? "]}," Haml RailsHelpers precede":{"type":"method","name":"precede","children":[],"call":["(begin\n  (send nil :escape_once\n    (lvar :str))) html_safe "," capture_haml chomp "," capture_haml "," escape_once ","(begin\n  (lvar :str)) html_safe ","str html_safe? ","(begin\n  (send nil :escape_once\n    (lvar : escape_once ))) html_safe ","(begin\n  (lvar : escape_once )) html_safe "," escape_once  html_safe? "]}," Haml RailsHelpers surround":{"type":"method","name":"surround","children":[],"call":["(begin\n  (send nil :escape_once\n    (lvar :front))) html_safe "," escape_once ","output chomp "," capture_haml ","(begin\n  (lvar :front)) html_safe ","back html_safe? ","front html_safe? ","(begin\n  (send nil :escape_once\n    (lvar : escape_once ))) html_safe "," capture_haml  chomp ","(begin\n  (lvar : escape_once )) html_safe "," escape_once  html_safe? "]}," Haml RailsHelpers preserve":{"type":"method","name":"preserve","children":[],"call":[" html_safe "," preserve "," capture_haml "]}," Haml RailsHelpers find_and_preserve":{"type":"method","name":"find_and_preserve","children":[],"call":[" preserve ","s =~ ","input to_s gsub ","input to_s ","s << ","Regexp  escape ","s empty? ","tags each_with_object "," find_and_preserve "," capture_haml "]}," Haml Parser ParserOptions initialize":{"type":"method","name":"initialize","children":[],"call":[" instance_variable_set ","values [] ","values key? ","AVAILABLE_OPTIONS  each ","DEFAULTS  each "]}," Haml Parser merge_value":{"type":"method","name":"merge_value","children":[],"call":["(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :merged_class) :split\n    (str \" \"))) join ","to split | ","merged_class split ","to split "," filter_and_join ","key == ","to merge ","to is_a? ! ","to is_a? ","from is_a? ! ","from is_a? ","to kind_of? ","from kind_of? ","(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :merged_class) :split\n    (str \" \"))) join ) :split\n    (str \" \"))) join ","(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar : filter_and_join ) :split\n    (str \" \"))) join ","(send\n  (send\n    (lvar :to) :split\n    (str \" \")) :|\n  (send\n    (lvar :merged_class) :split\n    (str \" \"))) join  split "," filter_and_join  split "]}," Haml Parser filter_and_join":{"type":"method","name":"filter_and_join","children":[],"call":["value empty? ! ","value empty? ","value nil? ! ","value nil? ","value to_s ","value join ","value compact! ","item to_s ","value map! ","value flatten ","value is_a? ","value respond_to? ","value to_s  empty? ! ","value join  empty? ! ","value flatten  empty? ! ","value to_s  empty? ","value join  empty? ","value flatten  empty? ","value to_s  nil? ! ","value join  nil? ! ","value flatten  nil? ! ","value to_s  nil? ","value join  nil? ","value flatten  nil? ","value to_s  to_s ","value join  to_s ","value flatten  to_s ","value to_s  join ","value join  join ","value flatten  join ","value to_s  compact! ","value join  compact! ","value flatten  compact! ","value to_s  map! ","value join  map! ","value flatten  map! ","value to_s  flatten ","value join  flatten ","value flatten  flatten ","value to_s  is_a? ","value join  is_a? ","value flatten  is_a? ","value to_s  respond_to? ","value join  respond_to? ","value flatten  respond_to? "]}," Haml Parser merge_attributes!":{"type":"method","name":"merge_attributes!","children":[],"call":["to []= "," merge_value ","from [] ","to [] ","from keys each ","from keys "]}," Haml Parser error_with_lineno":{"type":"method","name":"error_with_lineno","children":[],"call":["SyntaxError  new ","error message ","trace match to_s to_i ","trace match to_s ","trace match ","error backtrace first ","error backtrace ","error line ","HamlSyntaxError  new ","error backtrace first  match to_s to_i ","error backtrace first  match to_s ","error backtrace first  match ","error backerror backtrace first  first ","error backerror backtrace first  ","error trace match to_s to_i  "]}," Haml ObjectRef underscore":{"type":"method","name":"underscore","children":[],"call":["word downcase! ","word tr! ","word gsub! ","camel_cased_word to_s dup ","camel_cased_word to_s ","camel_cased_word to_s dup  downcase! ","camel_cased_word to_s dup  tr! ","camel_cased_word to_s dup  gsub! ","camel_cased_camel_cased_word to_s dup  to_s dup ","camel_cased_camel_cased_word to_s dup  to_s "]}," Haml ObjectRef parse":{"type":"method","name":"parse","children":[],"call":["(lvar :prefix) compact join ","(lvar :prefix) compact ","object id "," underscore ","object class ","object haml_object_ref ","object respond_to? "]}," Haml Identity generate":{"type":"method","name":"generate","children":[],"call":[]}," Haml Identity initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml HTML on_html_condcomment":{"type":"method","name":"on_html_condcomment","children":[],"call":[" on_html_comment "]}," Haml ForceEscapable on_escape":{"type":"method","name":"on_escape","children":[],"call":[" compile "]}," Haml ForceEscapable initialize":{"type":"method","name":"initialize","children":[],"call":[" eval ","@escape_code % "," options [] "," options "]}," Haml FescapeDispathcer on_fescape":{"type":"method","name":"on_fescape","children":[],"call":[" compile "]}," Haml Filters find_compiler":{"type":"method","name":"find_compiler","children":[],"call":["compiler new ","@compilers [] "," raise ","FilterNotFound  new ","node line to_i - ","node line to_i ","node line ","Filters  registered [] ","Filters  registered ","node value [] to_sym ","node value [] ","node value ","Filters  registered []  new ","@Filters  registered [] s [] "]}," Haml Filters compile":{"type":"method","name":"compile","children":[],"call":[" find_compiler compile "," find_compiler ","node value [] ","node value "]}," Haml Filters initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml Filters register":{"type":"method","name":"register","children":[],"call":[" registered []= "," registered "]}," Haml Filters TiltBase dynamic_compile":{"type":"method","name":"dynamic_compile","children":[],"call":["text prepend sub! ","text prepend ","\\ * ","escapes - ","escapes % == ","escapes % ","1 size "," Haml Util  unescape_interpolation gsub "," Haml Util  unescape_interpolation ","node value [] ","node value ","1 size  - ","1 size  % == ","1 size  % "]}," Haml Filters TiltBase static_compile":{"type":"method","name":"static_compile","children":[],"call":["temple << ","node value [] split size times ","node value [] split size ","node value [] split ","node value [] ","node value ","TiltBase  render "]}," Haml Filters TiltBase compile_with_tilt":{"type":"method","name":"compile_with_tilt","children":[],"call":[" static_compile "," dynamic_compile "," Haml Util  contains_interpolation? ","node value [] ","node value "]}," Haml Filters TiltBase explicit_require?":{"type":"method","name":"explicit_require?","children":[],"call":["Tilt  registered? ! ","Tilt  registered? ","Gem Version  new >= ","Gem Version  new "]}," Haml Filters TiltBase render":{"type":"method","name":"render","children":[],"call":[]}," Haml Filters TextBase compile_text!":{"type":"method","name":"compile_text!","children":[],"call":["temple << ","node value [] split size times ","node value [] split size ","node value [] split ","node value [] ","node value ","text prepend ","\\ * ","escapes - ","escapes % == ","escapes % ","1 size "," Haml Util  unescape_interpolation gsub "," Haml Util  unescape_interpolation "," Haml Util  contains_interpolation? ","node value [] rstrip gsub ","node value [] rstrip ","node value [] rstrip gsub  prepend ","1 size  - ","1 size  % == ","1 size  % "]}," Haml Filters Scss compile":{"type":"method","name":"compile","children":[],"call":["temple << "," compile_with_tilt "," require "," explicit_require? "]}," Haml Filters Sass compile":{"type":"method","name":"compile","children":[],"call":["temple << "," compile_with_tilt "," require "," explicit_require? "]}," Haml Filters Preserve compile_text":{"type":"method","name":"compile_text","children":[],"call":[" Haml Util  unescape_interpolation "," Haml Util  contains_interpolation? "]}," Haml Filters Preserve compile":{"type":"method","name":"compile","children":[],"call":[" compile_text ","text gsub ","node value [] rstrip + ","node value [] rstrip ","node value [] ","node value "," compile_text gsub  "," compile_node value [] rstrip +  ","text gsub  gsub ","node value [] rstrip +  gsub "]}," Haml Filters Plain compile_plain":{"type":"method","name":"compile_plain","children":[],"call":["StringSplitter  compile map ","StringSplitter  compile "," Haml Util  unescape_interpolation "]}," Haml Filters Plain compile":{"type":"method","name":"compile","children":[],"call":[" compile_plain ","text rstrip "," Haml Util  contains_interpolation? ","node value [] ","node value ","text rstrip  rstrip ","node value []  rstrip "]}," Haml Filters Markdown compile":{"type":"method","name":"compile","children":[],"call":[" compile_with_tilt "," require "," explicit_require? "]}," Haml Filters Less compile":{"type":"method","name":"compile","children":[],"call":["temple << "," compile_with_tilt "," require "," explicit_require? "]}," Haml Filters Javascript compile_xhtml":{"type":"method","name":"compile_xhtml","children":[],"call":["temple << "," compile_text! "]}," Haml Filters Javascript compile_html":{"type":"method","name":"compile_html","children":[],"call":["temple << "," compile_text! "]}," Haml Filters Javascript compile":{"type":"method","name":"compile","children":[],"call":[" compile_html "," compile_xhtml "]}," Haml Filters Escaped compile_text":{"type":"method","name":"compile_text","children":[],"call":[" Haml Util  unescape_interpolation "," Haml Util  contains_interpolation? "]}," Haml Filters Escaped compile":{"type":"method","name":"compile","children":[],"call":[" compile_text ","node value [] rstrip ","node value [] ","node value "," compile_node value [] rstrip  "]}," Haml Filters Erb compile":{"type":"method","name":"compile","children":[],"call":[" compile_with_tilt "," precompiled_with_tilt "]}," Haml Filters Css compile_xhtml":{"type":"method","name":"compile_xhtml","children":[],"call":["temple << "," compile_text! "]}," Haml Filters Css compile_html":{"type":"method","name":"compile_html","children":[],"call":["temple << "," compile_text! "]}," Haml Filters Css compile":{"type":"method","name":"compile","children":[],"call":[" compile_html "," compile_xhtml "]}," Haml Filters Coffee compile":{"type":"method","name":"compile","children":[],"call":["temple << "," compile_with_tilt "," require "," explicit_require? "]}," Haml Filters Cdata compile_cdata":{"type":"method","name":"compile_cdata","children":[],"call":["temple << "," compile_text! "]}," Haml Filters Cdata compile":{"type":"method","name":"compile","children":[],"call":[" compile_cdata "]}," Haml Filters Base initialize":{"type":"method","name":"initialize","children":[],"call":["options [] "]}," Haml DynamicMerger count_newline":{"type":"method","name":"count_newline","children":[],"call":["exp == ","exps each "]}," Haml DynamicMerger merge_dynamic":{"type":"method","name":"merge_dynamic","children":[],"call":[" raise ","type inspect ","strlit_body << ","arg dump sub! sub! gsub ","arg dump sub! sub! ","arg dump sub! ","arg dump ","exps each ","String  new ","type == ","exps any? ","String  new  << "]}," Haml DynamicMerger on_multi":{"type":"method","name":"on_multi","children":[],"call":["result [] ","result size == ","result size ","result concat "," merge_dynamic ","result << "," compile ","exps shift ","buffer << ","(send\n  (lvar :count) :+\n  (int 1)) times ","count + ","count == ","exps [] last count ","exps [] last ","exps [] ","exps [] first == ","exps [] first ","exps size > "," count_newline ","exps size ","type == ","(send\n  (int 1) :+\n  (lvar :count)) times ","1 + ","e == ","exps [] all? ","arg count ","arg count == ","exps first ","exps empty? ","exps dup ","exps dup  shift ","(send\n  (lvar : count_newline ) :+\n  (int 1)) times ","(send\n  (lvar :arg count ) :+\n  (int 1)) times "," count_newline  + ","arg count  + "," count_newline  == ","arg count  == ","exps [] last  count_newline  ","exps [] last arg count  ","exps dup  [] last count ","exps dup  [] last ","exps dup  [] ","exps dup  [] first == ","exps dup  [] first ","exps dup  size > ","  count_newline _newline "," arg count _newline ","exps dup  size ","(send\n  (int 1) :+\n  (lvar : count_newline )) times ","(send\n  (int 1) :+\n  (lvar :arg count )) times ","exps dup  [] all? ","arg  count_newline  ","arg arg count  ","arg  count_newline  == ","arg arg count  == ","exps dup  first ","exps dup  empty? ","exps dup  dup "]}," Haml Compiler runtime_error":{"type":"method","name":"runtime_error","children":[],"call":["temple << ","error line inspect ","error line ","error message ","error class ","error line times ","(sym :multi) tap "]}," Haml Compiler compile_children":{"type":"method","name":"compile_children","children":[],"call":[" compile ","@children_compiler compile "]}," Haml Compiler TagCompiler self_closing?":{"type":"method","name":"self_closing?","children":[],"call":["node value [] ","node value ","@autoclose include? "]}," Haml Compiler TagCompiler compile_interpolated_plain":{"type":"method","name":"compile_interpolated_plain","children":[],"call":["temple << ","node value [] ","node value ","StringSplitter  compile each ","StringSplitter  compile "]}," Haml Compiler TagCompiler delegate_optimization":{"type":"method","name":"delegate_optimization","children":[],"call":["node value [] ","node value "]}," Haml Compiler TagCompiler compile_contents":{"type":"method","name":"compile_contents","children":[],"call":["node value [] ","node value ","@identity generate "," delegate_optimization ","Temple StaticAnalyzer  static? ","RubyExpression  string_literal? ","Ripper  respond_to? "," compile_interpolated_plain "," self_closing? ","node value [] nil? ","node children empty? ! ","node children empty? ","node children "]}," Haml Compiler TagCompiler compile":{"type":"method","name":"compile","children":[],"call":["node value [] ","node value "," compile_contents ","@attribute_compiler compile "," compile_ compile_contents  "]}," Haml Compiler TagCompiler initialize":{"type":"method","name":"initialize","children":[],"call":["AttributeCompiler  new ","options [] "]}," Haml Compiler SilentScriptCompiler compile_with_children":{"type":"method","name":"compile_with_children","children":[],"call":["node value [] ","node value "]}," Haml Compiler SilentScriptCompiler compile":{"type":"method","name":"compile","children":[],"call":[" compile_with_children ","node value [] ","node value ","node children empty? ","node children "]}," Haml Compiler ScriptCompiler escape_html":{"type":"method","name":"escape_html","children":[],"call":[]}," Haml Compiler ScriptCompiler find_and_preserve":{"type":"method","name":"find_and_preserve","children":[],"call":[]}," Haml Compiler ScriptCompiler compile_script_result":{"type":"method","name":"compile_script_result","children":[],"call":["node value [] ","node value "," find_and_preserve ","node value [] ! "]}," Haml Compiler ScriptCompiler compile_script_assign":{"type":"method","name":"compile_script_assign","children":[],"call":["Temple Utils  unique_name ","node value [] ","node value ","node children empty? ","node children "]}," Haml Compiler ScriptCompiler dynamic_compile":{"type":"method","name":"dynamic_compile","children":[],"call":["temple << "," compile_script_result "," compile_script_assign ","@identity generate "," compile_script_assign  << "]}," Haml Compiler ScriptCompiler static_compile":{"type":"method","name":"static_compile","children":[],"call":["ScriptCompiler  find_and_preserve ","node value [] ","node value ","Haml Util  escape_html "," eval to_s "," eval "]}," Haml Compiler ScriptCompiler delegate_optimization":{"type":"method","name":"delegate_optimization","children":[],"call":["node value [] ","node value "]}," Haml Compiler ScriptCompiler compile_interpolated_plain":{"type":"method","name":"compile_interpolated_plain","children":[],"call":["temple << ","node value [] ","node value ","StringSplitter  compile each ","StringSplitter  compile "]}," Haml Compiler ScriptCompiler compile":{"type":"method","name":"compile","children":[],"call":[" dynamic_compile "," static_compile ","Temple StaticAnalyzer  static? ","node value [] ","node value "," delegate_optimization ","RubyExpression  string_literal? "," compile_interpolated_plain ","node children empty? ","node children ","Ripper  respond_to? "]}," Haml Compiler ScriptCompiler initialize":{"type":"method","name":"initialize","children":[],"call":["options [] "]}," Haml Compiler DoctypeCompiler xml_doctype":{"type":"method","name":"xml_doctype","children":[],"call":[]}," Haml Compiler DoctypeCompiler html_doctype":{"type":"method","name":"html_doctype","children":[],"call":["node value [] ","node value "]}," Haml Compiler DoctypeCompiler compile":{"type":"method","name":"compile","children":[],"call":["node value [] ","node value "," html_doctype "," xml_doctype "," rdfa_doctype "]}," Haml Compiler DoctypeCompiler initialize":{"type":"method","name":"initialize","children":[],"call":["options [] "]}," Haml Compiler CommentCompiler compile_conditional_comment":{"type":"method","name":"compile_conditional_comment","children":[],"call":["node value [] ","node value ","node children empty? ","node children ","node value [] =~ "," compile_text "]}," Haml Compiler CommentCompiler compile_html_comment":{"type":"method","name":"compile_html_comment","children":[],"call":["node value [] ","node value ","node children empty? ","node children "," compile_text "]}," Haml Compiler CommentCompiler compile":{"type":"method","name":"compile","children":[],"call":[" compile_html_comment "," compile_conditional_comment ","node value [] ","node value "]}," Haml Compiler ChildrenCompiler insert_whitespace?":{"type":"method","name":"insert_whitespace?","children":[],"call":["(str \"ruby\") include? ! ","(str \"ruby\") include? ","node value [] ","node value "," nuke_inner_whitespace? ! "," nuke_inner_whitespace? ","node children empty? ","node children ","node value [] != ","node type "," nuke_outer_whitespace? "]}," Haml Compiler ChildrenCompiler rstrip_whitespace!":{"type":"method","name":"rstrip_whitespace!","children":[],"call":["temple delete_at ","temple [] == ","temple [] "," rstrip_whitespace! ","temple [] [] ","exp delete_at ","exp [] == ","exp [] ","else_index - "," find_else_index ","exp replace ","@multi_flattener call ","code start_with? ","temple size == ","temple size "," find_else_index  - "," find_ find_else_index  "]}," Haml Compiler ChildrenCompiler nuke_outer_whitespace?":{"type":"method","name":"nuke_outer_whitespace?","children":[],"call":["node value [] ","node value ","node type != ","node type "]}," Haml Compiler ChildrenCompiler nuke_prev_whitespace?":{"type":"method","name":"nuke_prev_whitespace?","children":[],"call":[" nuke_prev_whitespace? ","node children first ","node children ","node children empty? ! ","node children empty? ","node value [] ","node value ","node type "]}," Haml Compiler ChildrenCompiler nuke_inner_whitespace?":{"type":"method","name":"nuke_inner_whitespace?","children":[],"call":[" nuke_inner_whitespace? ","node parent ","node parent nil? ","node value [] ","node value ","node type == ","node type "]}," Haml Compiler ChildrenCompiler prepend_whitespace?":{"type":"method","name":"prepend_whitespace?","children":[],"call":[" nuke_inner_whitespace? ! "," nuke_inner_whitespace? ","(sym :comment) include? ","node type "]}," Haml Compiler ChildrenCompiler confirm_whitespace":{"type":"method","name":"confirm_whitespace","children":[],"call":["temple map "]}," Haml Compiler ChildrenCompiler moving_lineno":{"type":"method","name":"moving_lineno","children":[],"call":["TempleLineCounter  count_lines ","node type ","block call ","node value [] ","node value ","node children empty? ","node children ","attribute_hash count ","(send\n  (send\n    (send\n      (lvar :node) :value) :[]\n    (sym :dynamic_attributes)) :new) compact each ","(send\n  (send\n    (send\n      (lvar :node) :value) :[]\n    (sym :dynamic_attributes)) :new) compact ","node value [] old ","node value [] new "]}," Haml Compiler ChildrenCompiler insert_newlines!":{"type":"method","name":"insert_newlines!","children":[],"call":["node line ","temple << ","(send\n  (send\n    (lvar :node) :line) :-\n  (ivar :@lineno)) times ","node line - ","(send\n  (send\n    (lvar :node) :line) :-\n  (ivar :node line )) times "]}," Haml Compiler ChildrenCompiler compile":{"type":"method","name":"compile","children":[],"call":[" confirm_whitespace "," rstrip_whitespace! "," nuke_inner_whitespace? ","temple << "," insert_whitespace? ","block call "," moving_lineno "," insert_newlines! "," nuke_prev_whitespace? ","node children each ","node children "," prepend_whitespace? ","node children empty? "]}," Haml Compiler ChildrenCompiler initialize":{"type":"method","name":"initialize","children":[],"call":["Temple Filters MultiFlattener  new "]}," Haml CLI validate_ruby":{"type":"method","name":"validate_ruby","children":[],"call":[" eval "," binding "]}," Haml CLI pp_object":{"type":"method","name":"pp_object","children":[],"call":[" pp "," require ","IRB ColorPrinter  pp "]}," Haml CLI puts_code":{"type":"method","name":"puts_code","children":[],"call":[" puts ","IRB Color  colorize_code "," require "]}," Haml CLI method_missing":{"type":"method","name":"method_missing","children":[],"call":[" render ","args first to_s ","args first ","args length > ","args length "]}," Haml CLI engine_options":{"type":"method","name":"engine_options","children":[],"call":["Haml Engine  options to_h merge "," options [] "," options ","Haml Engine  options to_h ","Haml Engine  options "]}," Haml CLI generate_temple":{"type":"method","name":"generate_temple","children":[],"call":["Haml Compiler  new call ","Haml Compiler  new "," engine_options "," generate_ast "," generate_ generate_ast  "]}," Haml CLI generate_ast":{"type":"method","name":"generate_ast","children":[],"call":["Haml Parser  new call ","Haml Parser  new "," engine_options "," read_file "]}," Haml CLI generate_code":{"type":"method","name":"generate_code","children":[],"call":["Haml Engine  new call ","Haml Engine  new "," engine_options ","handler call ","ActionView Template  new ","Haml RailsTemplate  new "," require "," options [] "," options "," read_file ","Haml RailsTemplate  new  call "]}," Haml CLI read_file":{"type":"method","name":"read_file","children":[],"call":["File  read ","STDIN  read ","file == "]}," Haml CLI process_load_options":{"type":"method","name":"process_load_options","children":[],"call":[" require "," options [] "," options ","$LOAD_PATH unshift ","$LOAD_PATH include? "," options [] split each "," options [] split "]}," Haml CLI version":{"type":"method","name":"version","children":[],"call":[" puts "]}," Haml CLI parse":{"type":"method","name":"parse","children":[],"call":[" pp_object "," options [] "," options "," generate_ast "]}," Haml CLI temple":{"type":"method","name":"temple","children":[],"call":[" pp_object "," options [] "," options "," generate_temple "]}," Haml CLI compile":{"type":"method","name":"compile","children":[],"call":[" puts_code "," options [] "," options "," puts "," abort ","error message split first ","error message split ","error message "," validate_ruby "," generate_code "," puts_ generate_code  "," validate_ruby  message split first "," validate_ruby  message split "," validate_ruby  message "," generate_ generate_code  "]}," Haml CLI render":{"type":"method","name":"render","children":[],"call":[" puts "," eval "," binding "," generate_code "," process_load_options "," generate_ generate_code  "]}," Haml AttributeCompiler literal_for":{"type":"method","name":"literal_for","children":[],"call":["exp inspect ","type == "]}," Haml AttributeCompiler attribute_builder":{"type":"method","name":"attribute_builder","children":[],"call":["args join "," literal_for ","values map ","@escape_attrs inspect "]}," Haml AttributeCompiler compile_common!":{"type":"method","name":"compile_common!","children":[],"call":["temple << ","values last "]}," Haml AttributeCompiler compile_boolean!":{"type":"method","name":"compile_boolean!","children":[],"call":["temple << ","@format == ","@identity generate ","value to_s "," eval ","Temple StaticAnalyzer  static? "," literal_for ","values last "," eval  to_s "," eval s last "]}," Haml AttributeCompiler compile_data!":{"type":"method","name":"compile_data!","children":[],"call":["temple << "," eval to_s "," eval ","Temple StaticAnalyzer  static? ","type == ","values all? ","args join "," literal_for ","values map ","@quote inspect ","@escape_attrs inspect "]}," Haml AttributeCompiler compile_class!":{"type":"method","name":"compile_class!","children":[],"call":["temple << "," eval to_s "," eval ","Temple StaticAnalyzer  static? ","type == ","values all? "," attribute_builder "]}," Haml AttributeCompiler compile_id!":{"type":"method","name":"compile_id!","children":[],"call":["temple << "," eval to_s "," eval ","Temple StaticAnalyzer  static? ","type == ","values all? "," attribute_builder "]}," Haml AttributeCompiler static_compile":{"type":"method","name":"static_compile","children":[],"call":[" compile_common! "," compile_boolean! "," compile_data! "," compile_class! "," compile_id! ","exp != ","values select! ","h [] ","dynamic_hashes map ","static_hash [] ","keys each ","(splat\n  (send\n    (lvar :static_hash) :keys)) uniq sort ","(splat\n  (send\n    (lvar :static_hash) :keys)) uniq ","dynamic_hashes map flatten ","static_hash keys ","(splat\n  (send\n    (lvar :static_hash) :keys)) uniq sort  each ","(splat\n  (send\n    (lvar :static_hash) :(splat\n  (send\n    (lvar :static_hash) :keys)) uniq sort )) uniq sort ","(splat\n  (send\n    (lvar :static_hash) :(splat\n  (send\n    (lvar :static_hash) :keys)) uniq sort )) uniq ","static_hash (splat\n  (send\n    (lvar :static_hash) :keys)) uniq sort  "]}," Haml AttributeCompiler runtime_compile":{"type":"method","name":"runtime_compile","children":[],"call":["node value [] to_literal ","node value [] ","node value ","args join ","(send\n  (ivar :@escape_attrs) :inspect) + ","@format inspect ","@quote inspect ","@escape_attrs inspect ","attrs unshift ","node value [] inspect ","node value [] != ","(send\n  (ivar :@escape_attrs) :inspect) +  join "]}," AttributeBuilder escape_html":{"type":"method","name":"escape_html","children":[],"call":["Haml Util  escape_html "]}," AttributeBuilder build_boolean!":{"type":"method","name":"build_boolean!","children":[],"call":["buf << "," escape_html "]}," AttributeBuilder merge_all_attrs":{"type":"method","name":"merge_all_attrs","children":[],"call":["merged []= ","merged [] << ","merged [] ","data freeze ","class freeze ","id freeze ","key to_s ","hash each ","hashes each "," raise ","hash is_a? ","key to_s  to_s "]}," AttributeBuilder flatten_attributes":{"type":"method","name":"flatten_attributes","children":[],"call":["flattened []= ","k to_s gsub ","k to_s ","k nil? "," flatten_attributes each "," flatten_attributes ","attributes each "]}," AttributeBuilder build_data_attribute":{"type":"method","name":"build_data_attribute","children":[],"call":["attrs join ","attrs << "," escape_html ","value to_s ","hash sort_by each ","hash sort_by "," flatten_attributes ","hashes last "," merge_all_attrs ","h is_a? ","hashes all? ","hashes size > ","hashes size "," flatten_attributes  sort_by each "," flatten_attributes  sort_by "," flatten_attributes es last "," flatten_attributes es all? "," flatten_attributes es size > "," flatten_attributes es size "]}," AttributeBuilder build_aria":{"type":"method","name":"build_aria","children":[],"call":[" build_data_attribute "]}," AttributeBuilder build_data":{"type":"method","name":"build_data","children":[],"call":[" build_data_attribute "]}," AttributeBuilder build_class":{"type":"method","name":"build_class","children":[],"call":[" escape_html ","classes map uniq join ","classes map uniq ","classes map ","classes << ","value to_s ","value select ","value is_a? ","value split ","values each ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq ","(send\n  (send\n    (lvar :value) :flatten) :select) map ","value flatten select ","value flatten ","values first ","values size == ","values size ","value to_s  to_s ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join  to_s ","values first  to_s ","value to_s  select ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join  select ","values first  select ","value to_s  is_a? ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join  is_a? ","values first  is_a? ","value to_s  split ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join  split ","values first  split ","value to_s s each ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join s each ","values first s each ","(send\n  (send\n    (lvar :value to_s ) :flatten) :select) map uniq join ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join ) :flatten) :select) map uniq join ","(send\n  (send\n    (lvar :values first ) :flatten) :select) map uniq join ","(send\n  (send\n    (lvar :value to_s ) :flatten) :select) map uniq ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join ) :flatten) :select) map uniq ","(send\n  (send\n    (lvar :values first ) :flatten) :select) map uniq ","(send\n  (send\n    (lvar :value to_s ) :flatten) :select) map ","(send\n  (send\n    (lvar :(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join ) :flatten) :select) map ","(send\n  (send\n    (lvar :values first ) :flatten) :select) map ","value to_s  flatten select ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join  flatten select ","values first  flatten select ","value to_s  flatten ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join  flatten ","values first  flatten ","value to_s s first ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join s first ","values first s first ","value to_s s size == ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join s size == ","values first s size == ","value to_s s size ","(send\n  (send\n    (lvar :value) :flatten) :select) map uniq join s size ","values first s size "]}," AttributeBuilder build_id":{"type":"method","name":"build_id","children":[],"call":[" escape_html ","(send\n  (send\n    (lvar :values) :flatten) :select) join ","values flatten select ","values flatten "]}," AttributeBuilder build":{"type":"method","name":"build","children":[],"call":["buf join ","buf << "," escape_html ","hash [] to_s ","hash [] "," build_boolean! "," build_data ","data freeze "," build_class ","class freeze "," build_id ","id freeze ","keys each ","hash keys sort! ","hash keys "," merge_all_attrs ","hashes << ","Haml ObjectRef  parse "," build_aria "," merge_all_attrs  [] to_s "," merge_all_attrs  [] ","hash keys sort!  each ","hash hash keys sort!  sort! "," merge_all_attrs  keys sort! ","hash hash keys sort!  "," merge_all_attrs  keys "," merge_all_attrs es << "]}," Haml Ambles call":{"type":"method","name":"call","children":[],"call":["ret << "]}," Haml Ambles initialize":{"type":"method","name":"initialize","children":[],"call":[" options [] "," options "]}," Haml HamlError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Haml HamlError message":{"type":"method","name":"message","children":[],"call":[]}," Haml StringSplitter call":{"type":"method","name":"call","children":[],"call":[]}," Haml StringSplitter SyntaxChecker on_parse_error":{"type":"method","name":"on_parse_error","children":[],"call":[" raise "]}," Haml StringSplitter SyntaxChecker syntax_error?":{"type":"method","name":"syntax_error?","children":[],"call":[]}," Haml StringSplitter string_literal?":{"type":"method","name":"string_literal?","children":[],"call":["type == ","instructions first ","instructions size > ","instructions size ","type != ","Ripper  sexp ","SyntaxChecker  syntax_error? "]}," Haml StringSplitter on_dynamic":{"type":"method","name":"on_dynamic","children":[],"call":["temple << "," on_dynamic ","StringSplitter  compile each ","StringSplitter  compile ","code include? "," string_literal? "]}," Haml StringSplitter shift_balanced_embexpr":{"type":"method","name":"shift_balanced_embexpr","children":[],"call":["embedded << ","embexpr_open == ","tokens shift ","tokens empty? ","String  new tap ","String  new "]}," Haml StringSplitter escape_quotes":{"type":"method","name":"escape_quotes","children":[],"call":["beg_str sub ","beg_str [] "]}," Haml StringSplitter compile_tokens!":{"type":"method","name":"compile_tokens!","children":[],"call":["exps << ","embedded empty? "," shift_balanced_embexpr "," eval to_s "," eval "," escape_quotes ","tokens shift ","tokens empty? "," strip_quotes! "," shift_balanced_embexpr  empty? "]}," Haml StringSplitter strip_quotes!":{"type":"method","name":"strip_quotes!","children":[],"call":[" raise ","type != ","tokens pop ","tokens shift "]}," Haml Filters TiltBase precompiled_with_tilt":{"type":"method","name":"precompiled_with_tilt","children":[],"call":["(send\n  (send\n    (const\n      (cbase) :Tilt) :[]\n    (dstr\n      (str \"t.\")\n      (begin\n        (lvar :name)))) :new) send first ","(send\n  (send\n    (const\n      (cbase) :Tilt) :[]\n    (dstr\n      (str \"t.\")\n      (begin\n        (lvar :name)))) :new) send ","node value [] ","node value "," Tilt  [] new "," Tilt  [] "]}," Haml Compiler CommentCompiler compile_text":{"type":"method","name":"compile_text","children":[],"call":["node value [] ","node value "]}," Haml Whitespace on_whitespace":{"type":"method","name":"on_whitespace","children":[],"call":[]}," Haml Compiler ChildrenCompiler find_else_index":{"type":"method","name":"find_else_index","children":[],"call":["index + ","arg [] match? ","arg [] ","arg [] == ","args each_with_index ","multi != "]}," Haml ForceEscape on_escape":{"type":"method","name":"on_escape","children":[],"call":[" compile "]}," Haml ForceEscape initialize":{"type":"method","name":"initialize","children":[],"call":[" eval ","@escape_code % "," options [] "," options "]}," Haml EscapeAny on_dynamic":{"type":"method","name":"on_dynamic","children":[],"call":["@escape_code % "]}," Haml EscapeanyDispathcer on_escapeany":{"type":"method","name":"on_escapeany","children":[],"call":[" compile "]}," Haml Escape initialize":{"type":"method","name":"initialize","children":[],"call":[" eval ","@escape_code % "," options [] "," options "]}," Haml RailsTemplate default_format":{"type":"method","name":"default_format","children":[],"call":[]}," Haml Compiler DoctypeCompiler rdfa_doctype":{"type":"method","name":"rdfa_doctype","children":[],"call":[]}}