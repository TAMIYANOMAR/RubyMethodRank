{" Crack XML parse":{"type":"method","name":"parse","children":[],"call":[]}," REXMLUtilityNode to_s":{"type":"method","name":"to_s","children":[],"call":[" to_html "]}," REXMLUtilityNode to_html":{"type":"method","name":"to_html","children":[],"call":[" name "," inner_html "," attributes to_xml_attributes "," attributes "," attributes merge! ","Crack Util  to_xml_attributes "]}," REXMLUtilityNode inner_html":{"type":"method","name":"inner_html","children":[],"call":["@children join "]}," REXMLUtilityNode undasherize_keys":{"type":"method","name":"undasherize_keys","children":[],"call":["params []= ","params delete ","key tr ","params keys each ","params keys "]}," REXMLUtilityNode translate_xml_entities":{"type":"method","name":"translate_xml_entities","children":[],"call":["value gsub gsub gsub gsub gsub ","value gsub gsub gsub gsub ","value gsub gsub gsub ","value gsub gsub ","value gsub "]}," REXMLUtilityNode typecast_value":{"type":"method","name":"typecast_value","children":[],"call":["proc call ","proc nil? "," class typecasts [] "," class typecasts "," class "," class typecasts []  call "," class typecasts []  nil? "]}," REXMLUtilityNode to_hash":{"type":"method","name":"to_hash","children":[],"call":[" name "," typecast_value ","out nil? ","out empty? ","out merge! "," attributes "," attributes empty? ","e to_hash [] ","e to_hash ","v map ","v first ","v size == ","v size ","groups each ","out flatten ","out << ","v first to_hash entries first last ","v first to_hash entries first ","v first to_hash entries ","v first to_hash ","@type == ","(or-asgn\n  (send\n    (lvar :s) :[]\n    (send\n      (lvar :e) :name))\n  (array)) << ","s [] ","e name ","@children inject "," translate_xml_entities "," inner_html ","f content_type= "," attributes [] ","f original_filename= "," attr_accessor ","StringIO  new ","(or\n  (send\n    (ivar :@children) :first)\n  (str \"\")) unpack first ","(or\n  (send\n    (ivar :@children) :first)\n  (str \"\")) unpack ","@children first "," unnormalize_xml_entities ","t attributes= ","t class send ","t class ","t is_a? ","REXMLUtiliyNodeString  new ","@children first is_a? ","@children first nil? ","  typecast_value ypecas typecast_value _value "," REXMLUtiliyNodeString  new ypecasREXMLUtiliyNodeString  new _value ","out flatten  nil? ","ou typecast_value  nil? ","ouREXMLUtiliyNodeString  new  nil? ","out flatten  empty? ","ou typecast_value  emp typecast_value y? ","ouREXMLUtiliyNodeString  new  empREXMLUtiliyNodeString  new y? ","out flatten  merge! ","ou typecast_value  merge! ","ouREXMLUtiliyNodeString  new  merge! "," a typecast_value  typecast_value ribu typecast_value es "," aREXMLUtiliyNodeString  new REXMLUtiliyNodeString  new ribuREXMLUtiliyNodeString  new es "," a typecast_value  typecast_value ribu typecast_value es emp typecast_value y? "," aREXMLUtiliyNodeString  new REXMLUtiliyNodeString  new ribuREXMLUtiliyNodeString  new es empREXMLUtiliyNodeString  new y? ","e  typecast_value o_hash [] ","e REXMLUtiliyNodeString  new o_hash [] ","e  typecast_value o_hash ","e REXMLUtiliyNodeString  new o_hash ","v StringIO  new irst ","v firs typecast_value  ","v firsREXMLUtiliyNodeString  new  ","out flatten  flatten ","out StringIO  new latten ","ou typecast_value  fla typecast_value  typecast_value en ","ouREXMLUtiliyNodeString  new  flaREXMLUtiliyNodeString  new REXMLUtiliyNodeString  new en ","out flatten  << ","ou typecast_value  << ","ouREXMLUtiliyNodeString  new  << ","v StringIO  new irst to_hash entries StringIO  new irst last ","v firs typecast_value   typecast_value o_hash en typecast_value ries firs typecast_value  las typecast_value  ","v firsREXMLUtiliyNodeString  new  REXMLUtiliyNodeString  new o_hash enREXMLUtiliyNodeString  new ries firsREXMLUtiliyNodeString  new  lasREXMLUtiliyNodeString  new  ","v StringIO  new irst to_hash entries StringIO  new irst ","v firs typecast_value   typecast_value o_hash en typecast_value ries firs typecast_value  ","v firsREXMLUtiliyNodeString  new  REXMLUtiliyNodeString  new o_hash enREXMLUtiliyNodeString  new ries firsREXMLUtiliyNodeString  new  ","v StringIO  new irst to_hash entries ","v firs typecast_value   typecast_value o_hash en typecast_value ries ","v firsREXMLUtiliyNodeString  new  REXMLUtiliyNodeString  new o_hash enREXMLUtiliyNodeString  new ries ","v StringIO  new irst to_hash ","v firs typecast_value   typecast_value o_hash ","v firsREXMLUtiliyNodeString  new  REXMLUtiliyNodeString  new o_hash ","@ typecast_value ype == ","@REXMLUtiliyNodeString  new ype == ","@children injec typecast_value  ","@children injecREXMLUtiliyNodeString  new  ","  typecast_value ransla typecast_value e_xml_en typecast_value i typecast_value ies "," REXMLUtiliyNodeString  new ranslaREXMLUtiliyNodeString  new e_xml_enREXMLUtiliyNodeString  new iREXMLUtiliyNodeString  new ies "," inner_h typecast_value ml "," inner_hREXMLUtiliyNodeString  new ml ","StringIO  new  content_type= ","f con typecast_value en typecast_value _ typecast_value ype= ","f conREXMLUtiliyNodeString  new enREXMLUtiliyNodeString  new _REXMLUtiliyNodeString  new ype= "," a typecast_value  typecast_value ribu typecast_value es [] "," aREXMLUtiliyNodeString  new REXMLUtiliyNodeString  new ribuREXMLUtiliyNodeString  new es [] ","StringIO  new  original_StringIO  new ilename= "," a typecast_value  typecast_value r_accessor "," aREXMLUtiliyNodeString  new REXMLUtiliyNodeString  new r_accessor ","S typecast_value ringIO  new ","SREXMLUtiliyNodeString  new ringIO  new ","(or\n  (send\n    (ivar :@children) :StringIO  new irst)\n  (str \"\")) unpack StringIO  new irst ","(or\n  (send\n    (ivar :@children) :firs typecast_value )\n  (s typecast_value r \"\")) unpack firs typecast_value  ","(or\n  (send\n    (ivar :@children) :firsREXMLUtiliyNodeString  new )\n  (sREXMLUtiliyNodeString  new r \"\")) unpack firsREXMLUtiliyNodeString  new  ","(or\n  (send\n    (ivar :@children) :StringIO  new irst)\n  (str \"\")) unpack ","(or\n  (send\n    (ivar :@children) :firs typecast_value )\n  (s typecast_value r \"\")) unpack ","(or\n  (send\n    (ivar :@children) :firsREXMLUtiliyNodeString  new )\n  (sREXMLUtiliyNodeString  new r \"\")) unpack ","@children StringIO  new irst ","@children firs typecast_value  ","@children firsREXMLUtiliyNodeString  new  "," unnormalize_xml_en typecast_value i typecast_value ies "," unnormalize_xml_enREXMLUtiliyNodeString  new iREXMLUtiliyNodeString  new ies "," typecast_value  a typecast_value  typecast_value ribu typecast_value es= ","REXMLUtiliyNodeString  new  aREXMLUtiliyNodeString  new REXMLUtiliyNodeString  new ribuREXMLUtiliyNodeString  new es= "," typecast_value  class send ","REXMLUtiliyNodeString  new  class send "," typecast_value  class ","REXMLUtiliyNodeString  new  class "," typecast_value  is_a? ","REXMLUtiliyNodeString  new  is_a? ","REXMLU typecast_value iliyNodeS typecast_value ring  new ","REXMLUREXMLUtiliyNodeString  new iliyNodeSREXMLUtiliyNodeString  new ring  new ","@children StringIO  new irst is_a? ","@children firs typecast_value  is_a? ","@children firsREXMLUtiliyNodeString  new  is_a? ","@children StringIO  new irst nil? ","@children firs typecast_value  nil? ","@children firsREXMLUtiliyNodeString  new  nil? "]}," REXMLUtilityNode add_node":{"type":"method","name":"add_node","children":[],"call":["@children << ","node is_a? "]}," REXMLUtilityNode initialize":{"type":"method","name":"initialize","children":[],"call":[" undasherize_keys ","attributes delete == ","attributes delete ","attributes [] "," class available_typecasts include? "," class available_typecasts "," class ","name tr ","Hash  [] ","(send\n  (lvar :normalized_attributes) :map) flatten "," unnormalize_xml_entities ","normalized_attributes map ","Hash  []  delete == ","Hash  []  delete ","Hash  []  [] ","(send\n  (lvar :normalized_Hash  [] ) :map) flatten ","normalized_Hash  []  map "]}," REXMLUtilityNode available_typecasts=":{"type":"method","name":"available_typecasts=","children":[],"call":[]}," REXMLUtilityNode available_typecasts":{"type":"method","name":"available_typecasts","children":[],"call":[]}," REXMLUtilityNode typecasts=":{"type":"method","name":"typecasts=","children":[],"call":[]}," REXMLUtilityNode typecasts":{"type":"method","name":"typecasts","children":[],"call":[]}," Crack JSON convert_json_to_yaml":{"type":"method","name":"convert_json_to_yaml","children":[],"call":[]}," Crack JSON unescape":{"type":"method","name":"unescape","children":[],"call":[]}," Crack JSON parse":{"type":"method","name":"parse","children":[],"call":[]}," Hash to_xml_attributes":{"type":"method","name":"to_xml_attributes","children":[],"call":["(send nil :map) join ","m downcase ","k to_s snake_case sub ","k to_s snake_case ","k to_s "," map ","v to_s gsub ","v to_s "]}," Hash normalize_param":{"type":"method","name":"normalize_param","children":[],"call":["param << "," normalize_param ","stack << ","value is_a? ","hash each ","stack each ","URI  encode ","Regexp  new ","value to_s ","(send\n  (lvar :value) :map) join ","value map "]}," Hash to_params":{"type":"method","name":"to_params","children":[],"call":["params chop! ","(send\n  (self) :map) join "," normalize_param "," map ","(send\n  (self) :map) join  chop! "]}," String snake_case":{"type":"method","name":"snake_case","children":[],"call":["$+ downcase "," gsub =~ "," gsub "," downcase "," =~ "]}," String blank?":{"type":"method","name":"blank?","children":[],"call":[" strip empty? "," strip "]}," FalseClass blank?":{"type":"method","name":"blank?","children":[],"call":[]}," TrueClass blank?":{"type":"method","name":"blank?","children":[],"call":[]}," NilClass blank?":{"type":"method","name":"blank?","children":[],"call":[]}," Numeric blank?":{"type":"method","name":"blank?","children":[],"call":[]}," Object blank?":{"type":"method","name":"blank?","children":[],"call":[" empty? "," respond_to? "," nil? "]}," REXMLUtilityNode unnormalize_xml_entities":{"type":"method","name":"unnormalize_xml_entities","children":[],"call":["REXML Text  unnormalize "]}," Crack Util to_xml_attributes":{"type":"method","name":"to_xml_attributes","children":[],"call":["(send\n  (lvar :hash) :map) join ","v to_s gsub ","v to_s ","m downcase ","Crack Util  snake_case sub ","Crack Util  snake_case ","k to_s ","hash map "]}," Crack Util snake_case":{"type":"method","name":"snake_case","children":[],"call":["$+ downcase ","str gsub =~ ","str gsub ","str downcase ","str =~ "]}," Crack XML parser=":{"type":"method","name":"parser=","children":[],"call":[]}," Crack XML parser":{"type":"method","name":"parser","children":[],"call":[]}," Crack REXMLParser parse":{"type":"method","name":"parse","children":[],"call":[]}," Crack JSON parser_exceptions":{"type":"method","name":"parser_exceptions","children":[],"call":[]}," Crack JSON format_dates":{"type":"method","name":"format_dates","children":[],"call":[]}}