{" String parse_csv":{"type":"method","name":"parse_csv","children":[],"call":["CSV  parse_line "]}," Array to_csv":{"type":"method","name":"to_csv","children":[],"call":["CSV  generate_line "]}," CSV":{"type":"method","name":"CSV","children":[],"call":["CSV  instance "]}," CSV raw_encoding":{"type":"method","name":"raw_encoding","children":[],"call":["@io encoding ","@io respond_to? ","@io string encoding ","@io string ","@io is_a? ","@io external_encoding ","@io internal_encoding "]}," CSV encode_str":{"type":"method","name":"encode_str","children":[],"call":["(send\n  (lvar :chunks) :map) join ","chunk encode ","@encoding name ","chunks map "]}," CSV encode_re":{"type":"method","name":"encode_re","children":[],"call":["Regexp  new "," encode_str "]}," CSV escape_re":{"type":"method","name":"escape_re","children":[],"call":["@re_esc + ","str gsub "]}," CSV add_unconverted_fields":{"type":"method","name":"add_unconverted_fields","children":[],"call":["row instance_eval "," attr_reader ","row instance_variable_set "]}," CSV parse_headers":{"type":"method","name":"parse_headers","children":[],"call":[" class Row  new "," convert_fields "," class "," shift ","(const nil :Array) include? ! ","(const nil :Array) include? ","@use_headers class ","h freeze ","h is_a? ","@headers each ","row nil? "," class parse_line ","@headers nil? "," convert_fields  each "," convert_fields  nil? "]}," CSV convert_fields":{"type":"method","name":"convert_fields","children":[],"call":["field is_a? ","converter [] ","FieldInfo  new "," lineno ","@headers [] ","headers ! ","converter arity == ","converter arity ","field nil? ","converters each ","fields map with_index ","fields map ","field empty? ","@nil_value nil? ","converters empty? ","@use_headers ! "," fields_converter convert "," fields_converter "," header_fields_converter convert "," header_fields_converter "," parser_fields_converter convert "," parser_fields_converter ","converter []  is_a? ","@@headers [] s [] ","@headers [] s ! ","converter []  nil? ","converter [] s map with_index ","converter [] s map ","converter []  empty? ","@use_@headers [] s ! "," converter [] s_converter convert "," converter [] s_converter "," header_converter [] s_converter convert "," @headers [] _fields_converter convert "," header_converter [] s_converter "," @headers [] _fields_converter "," parser_converter [] s_converter convert "," parser_converter [] s_converter "]}," CSV add_converter":{"type":"method","name":"add_converter","children":[],"call":[" instance_variable_get << "," instance_variable_get "," add_converter ","combo each ","const [] ","name nil? ","const []  each "]}," CSV init_comments":{"type":"method","name":"init_comments","children":[],"call":[" raise ","@skip_lines respond_to? ! ","@skip_lines respond_to? ","Regexp  new ","@skip_lines is_a? ","options delete ","Regexp  escape ","Regexp  new  respond_to? ! ","options delete  respond_to? ! ","Regexp  new  respond_to? ","options delete  respond_to? ","Regexp  new  is_a? ","options delete  is_a? "]}," CSV init_headers":{"type":"method","name":"init_headers","children":[],"call":[" init_converters ","options delete "]}," CSV init_converters":{"type":"method","name":"init_converters","children":[],"call":["options delete ","convert call ","converter is_a? ","options [] each ","options [] ","options []= ","options [] is_a? ","options [] nil? "," method ","field_name to_s sub ","field_name to_s "," instance_variable_set ","Array  new ","field_name == ","converters each "," method  call "," method er is_a? "," method ers each "]}," CSV init_parsers":{"type":"method","name":"init_parsers","children":[],"call":[" encode_str "," encode_re "," escape_re ","options delete "]}," CSV init_separators":{"type":"method","name":"init_separators","children":[],"call":["do_quote call ","field count nonzero? ","field count ","field empty? "," String ","field nil? "," lambda "," encode_str ","encoded_quote + + ","encoded_quote + ","field gsub ","encoded_quote * ","@quote_char encode ","field encoding ","options delete ","@row_sep to_s encode ","@row_sep to_s ","@row_sep == ","@io read ","saved_pos nonzero? ","saved_pos > ","@io rewind ","sample =~ "," encode_re ","sample << ","@io gets ","sample end_with? ","@io pos ","@io class == ","@io class ","(const nil :ARGF) include? "," raise ","@quote_char length != ","@quote_char length ","options delete to_s encode ","options delete to_s ","@quote_char * ","quote_char to_s encode ","quote_char to_s ","col_sep to_s encode ","col_sep to_s ","next_char == ","sample each_char each_cons ","sample each_char ","Regexp  new ","Regexp  escape ","@col_sep == ","StringIO  new ","saved_prefix empty? ","saved_prefix join ","saved_prefix << ","@io respond_to? "," String  count nonzero? "," String  count "," String  empty? "," String  nil? ","@quote_char encode  + + ","@quote_char encode  + "," String  gsub ","@quote_char encode  * ","options delete to_s encode  encode ","quote_char to_s encode  encode "," String  encoding ","@row_sep to_s encode  to_s encode ","options delete  to_s encode "," encode_str  to_s encode ","@row_sep to_s encode  to_s ","options delete  to_s "," encode_str  to_s ","@row_sep to_s encode  == ","options delete  == "," encode_str  == ","@io pos  nonzero? ","@io pos  > ","@io gets  =~ ","@io gets  << ","@io gets  end_with? ","options delete to_s encode  length != ","quote_char to_s encode  length != ","options delete to_s encode  length ","quote_char to_s encode  length ","options delete to_s encode  * ","quote_char to_s encode  * ","@io gets  each_char each_cons ","@io gets  each_char ","options delete to_s encode  == ","col_sep to_s encode  == ","saved_prefix join  empty? ","saved_prefix join  join ","saved_prefix join  << "]}," CSV inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (lvar :str) :map) join ","s force_encoding ","s encode ","Encoding Converter  asciicompat_encoding ","s encoding ","str map ","str join ","str << ","str << << "," headers inspect "," headers ","str << << << << ","a inspect ","str << << << "," instance_variable_get ","(str \"lineno\") each ","@encoding name ","p inspect ","@io path ","@io respond_to? ","@io class to_s ","@io class ","@io == "," class to_s "," class ","_headers inspect "," __send__ ","(str \"skip_blanks\") each ","(sEncoding Converter  asciicompat_encoding nd\n  (lvar :str) :map) join ","(send\n  (lv instance_variable_get r :str) :m instance_variable_get p) join ","(send\n  (lv __send__ r :str) :m __send__ p) join ","(send\n  (lvar :str) :ma@io path ) join ","s forcEncoding Converter  asciicompat_encoding _Encoding Converter  asciicompat_encoding ncoding ","s Encoding Converter  asciicompat_encoding ncodEncoding Converter  asciicompat_encoding  ","Encoding ConvEncoding Converter  asciicompat_encoding rtEncoding Converter  asciicompat_encoding r  asciicompat_Encoding Converter  asciicompat_encoding ncoding ","Encoding Converter   instance_variable_get sciicomp instance_variable_get t_encoding ","Encoding Converter   __send__ sciicomp __send__ t_encoding ","Encoding Converter  asciicom@io path at_encoding ","s Encoding Converter  asciicompat_encoding ncoding ","str m instance_variable_get p ","str m __send__ p ","str ma@io path  "," hEncoding Converter  asciicompat_encoding adEncoding Converter  asciicompat_encoding rs inspEncoding Converter  asciicompat_encoding ct "," he instance_variable_get ders inspect "," he __send__ ders inspect "," headers ins@io path ect "," hEncoding Converter  asciicompat_encoding adEncoding Converter  asciicompat_encoding rs "," he instance_variable_get ders "," he __send__ ders ","a inspEncoding Converter  asciicompat_encoding ct "," instance_variable_get  inspect "," __send__  inspect ","a ins@io path ect "," instancEncoding Converter  asciicompat_encoding _variablEncoding Converter  asciicompat_encoding _gEncoding Converter  asciicompat_encoding t "," inst instance_variable_get nce_v instance_variable_get ri instance_variable_get ble_get "," inst __send__ nce_v __send__ ri __send__ ble_get ","(str \"linEncoding Converter  asciicompat_encoding no\") Encoding Converter  asciicompat_encoding ach ","(str \"lineno\") e instance_variable_get ch ","(str \"lineno\") e __send__ ch ","@Encoding Converter  asciicompat_encoding ncoding namEncoding Converter  asciicompat_encoding  ","@encoding n instance_variable_get me ","@encoding n __send__ me ","p inspEncoding Converter  asciicompat_encoding ct ","@io path  ins@io path ect ","@io p instance_variable_get th ","@io p __send__ th ","@io @io path ath ","@io rEncoding Converter  asciicompat_encoding spond_to? ","@io res@io path ond_to? ","@io cl instance_variable_get ss to_s ","@io cl __send__ ss to_s ","@io cl instance_variable_get ss ","@io cl __send__ ss "," cl instance_variable_get ss to_s "," cl __send__ ss to_s "," cl instance_variable_get ss "," cl __send__ ss ","_hEncoding Converter  asciicompat_encoding adEncoding Converter  asciicompat_encoding rs inspEncoding Converter  asciicompat_encoding ct ","_he instance_variable_get ders inspect ","_he __send__ ders inspect ","_headers ins@io path ect "," headers  inspect "," __sEncoding Converter  asciicompat_encoding nd__ ","(str \"skip_blanks\") Encoding Converter  asciicompat_encoding ach ","(str \"skip_bl instance_variable_get nks\") e instance_variable_get ch ","(str \"skip_bl __send__ nks\") e __send__ ch ","(str \"ski@io path _blanks\") each "]}," CSV shift":{"type":"method","name":"shift","children":[],"call":[" add_unconverted_fields ","csv respond_to? ! ","csv respond_to? "," parse_headers "," convert_fields ","@converters empty? ","csv dup "," raise "," lineno + "," lineno ","csv last sum >= ","csv last sum ","csv last ","@io eof? ","csv [] []= ","csv [] ","csv << ","part empty? ","Unquoted fields do not allow  + ","part =~ ","@parsers [] ","csv last gsub! ","@quote_char * ","csv last =~ ","part [] ","part [] == ","part count % != ","part count % ","part count ","csv last push ","csv []= ","csv [] push join ","csv [] push ","parts each ","csv [] << ","parts empty? ","parse split ","@skip_lines match ","Array  new "," class Row  new "," class ","parse empty? ","csv empty? ","parse sub! ","@io gets "," loop ","(const nil :Array) include? ","@use_headers class "," header_row? ","csv last size >= ","csv last size ","part end_with? ","part [] << ","part start_with? ","csv last << << ","csv last << ","parse clone ","@line concat ","MalformedCSVError  new ","part match? ","csv last match? ","parse encoding ","parse valid_encoding? ","@prefix_io ! ","parse << ","parse end_with? ","@prefix_io eof? ","@prefix_io gets ","@parser_enumerator next "," parser parse "," parser "," parser_enumerator next "," parser_enumerator "," add_csv dup _fields "," parse_headers  respond_to? ! "," convert_fields  respond_to? ! ","Array  new  respond_to? ! "," parse_headers  respond_to? "," convert_fields  respond_to? ","Array  new  respond_to? "," @io gets _headers "," @prefix_io gets _headers "," parse_headers  dup "," convert_fields  dup ","Array  new  dup "," parse_headers  last sum >= "," convert_fields  last sum >= ","Array  new  last sum >= "," parse_headers  last sum "," convert_fields  last sum ","Array  new  last sum "," parse_headers  last "," convert_fields  last ","Array  new  last "," parse_headers  [] []= "," convert_fields  [] []= ","Array  new  [] []= "," parse_headers  [] "," convert_fields  [] ","Array  new  [] "," parse_headers  << "," convert_fields  << ","Array  new  << ","@@io gets rs [] ","@@prefix_io gets rs [] "," parse_headers  last gsub! "," convert_fields  last gsub! ","Array  new  last gsub! "," parse_headers  last =~ "," convert_fields  last =~ ","Array  new  last =~ "," parse_headers  last push "," convert_fields  last push ","Array  new  last push "," parse_headers  []= "," convert_fields  []= ","Array  new  []= "," parse_headers  [] push join "," convert_fields  [] push join ","Array  new  [] push join "," parse_headers  [] push "," convert_fields  [] push ","Array  new  [] push ","parse split  each "," parse_headers  [] << "," convert_fields  [] << ","Array  new  [] << ","parse split  empty? ","@io gets  split ","@prefix_io gets  split ","@io gets  empty? ","@prefix_io gets  empty? "," parse_headers  empty? "," convert_fields  empty? ","Array  new  empty? ","@io gets  sub! ","@prefix_io gets  sub! "," parse_headers  last size >= "," convert_fields  last size >= ","Array  new  last size >= "," parse_headers  last size "," convert_fields  last size ","Array  new  last size "," parse_headers  last << << "," convert_fields  last << << ","Array  new  last << << "," parse_headers  last << "," convert_fields  last << ","Array  new  last << ","@io gets  clone ","@prefix_io gets  clone ","parse clone  concat "," parse_headers  last match? "," convert_fields  last match? ","Array  new  last match? ","@io gets  encoding ","@prefix_io gets  encoding ","@io gets  valid_encoding? ","@prefix_io gets  valid_encoding? ","@io gets  << ","@prefix_io gets  << ","@io gets  end_with? ","@prefix_io gets  end_with? ","@@io gets r_enumerator next ","@@prefix_io gets r_enumerator next "," @io gets r @io gets  "," @prefix_io gets r @prefix_io gets  "," @io gets r "," @prefix_io gets r "," @io gets r_enumerator next "," @prefix_io gets r_enumerator next "," @io gets r_enumerator "," @prefix_io gets r_enumerator "]}," CSV header_row?":{"type":"method","name":"header_row?","children":[],"call":["@headers nil? "," parser header_row? "," parser "]}," CSV read":{"type":"method","name":"read","children":[],"call":["Table  new "," to_a "," parser headers "," parser "," parser use_headers? ","csv read "," open "," parser  parser headers  "," parser use_ parser headers ? "]}," CSV each":{"type":"method","name":"each","children":[],"call":[" to_enum "," shift "," block_given? "," parser parse "," parser ","enumerator next "," parser_enumerator "," __method__ "," parser_enumerator each "," parser_enumerator next "," parser_enumerator  next "," parser_ parser_enumerator  "," parser_ parser_enumerator  each "," parser_ parser_enumerator  next "]}," CSV header_convert":{"type":"method","name":"header_convert","children":[],"call":[" add_converter "," class "," header_fields_converter add_converter "," header_fields_converter "]}," CSV convert":{"type":"method","name":"convert","children":[],"call":[" add_converter "," class "," fields_converter add_converter "," fields_converter "," parser_fields_converter add_converter "," parser_fields_converter "]}," CSV <<":{"type":"method","name":"<<","children":[],"call":["@io << ","@io seek ","@io set_encoding ","Encoding  compatible? ","@io string ","output encode ","output encoding != "," raw_encoding ","output encoding ","@io is_a? ","row map join + ","row map join ","row map "," header_row? ","row [] ","@headers map ","row fields "," class "," << "," parse_headers ","(const nil :Array) include? ","@use_headers class ","@write_headers ! "," writer << "," writer ","@io set_ raw_encoding  ","output encode  encode ","row map join +  encode ","output encode  encoding != ","row map join +  encoding != ","output  raw_encoding  != "," raw_ raw_encoding  ","output encode  encoding ","row map join +  encoding ","output  raw_encoding  "]}," CSV rewind":{"type":"method","name":"rewind","children":[],"call":["@io rewind ","@writer rewind "]}," CSV liberal_parsing?":{"type":"method","name":"liberal_parsing?","children":[],"call":[" parser liberal_parsing? "," parser "]}," CSV force_quotes?":{"type":"method","name":"force_quotes?","children":[],"call":["@writer_options [] "]}," CSV skip_blanks?":{"type":"method","name":"skip_blanks?","children":[],"call":[" parser skip_blanks? "," parser "]}," CSV header_converters":{"type":"method","name":"header_converters","children":[],"call":["name first ","HeaderConverters  rassoc ","@header_converters map "," header_fields_converter map "," header_fields_converter ","HeaderConverters  rassoc  first "]}," CSV write_headers?":{"type":"method","name":"write_headers?","children":[],"call":["@writer_options [] "]}," CSV return_headers?":{"type":"method","name":"return_headers?","children":[],"call":[" parser return_headers? "," parser "]}," CSV headers":{"type":"method","name":"headers","children":[],"call":["raw_headers == ","@parser_options [] "," parser headers "," parser ","@writer headers ","@parser_options []  == "]}," CSV unconverted_fields?":{"type":"method","name":"unconverted_fields?","children":[],"call":[" parser unconverted_fields? "," parser "]}," CSV converters":{"type":"method","name":"converters","children":[],"call":["name first ","Converters  rassoc ","@converters map "," fields_converter map "," fields_converter "," parser_fields_converter map "," parser_fields_converter ","Converters  rassoc  first "]}," CSV initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","options keys join ","options keys ","options empty? ","options delete ","(or\n  (lvar :encoding)\n  (send\n    (lvar :options) :delete\n    (sym :encoding))) ! ! ","(or\n  (lvar :encoding)\n  (send\n    (lvar :options) :delete\n    (sym :encoding))) ! "," init_comments "," init_headers "," init_converters "," init_parsers "," init_separators ","[-\\]\\[\\.^$?*+{}()|# \r\n\t\f\u000b] encode ","\\ encode freeze ","\\ encode ","Encoding  default_external ","Encoding  default_internal ","Encoding  find "," raw_encoding ","StringIO  new ","data is_a? ","DEFAULT_OPTIONS  merge ","ArgumentError  new ","data nil? "," << "," parse_headers ","(const nil :Array) include? ","@use_headers class "," header_row? ","encoding ! ! ","encoding ! ","encoding split ","encoding is_a? ","empty_value == "," determine_encoding "," writer ","@writer_options [] ","encoding nil? ! ","encoding nil? ","@io set_encoding ","data encoding ","field_size_limit - ","max_field_size nil? ","data dup force_encoding ","data dup ","data encode ","DEFAULT_OPTIONS  merge  keys join ","DEFAULT_OPTIONS  merge  keys ","DEFAULT_OPTIONS  merge  empty? ","DEFAULT_OPTIONS  merge  delete ","(or\n  (lvar :options delete )\n  (send\n    (lvar :options) :delete\n    (sym :options delete ))) ! ! ","(or\n  (lvar :Encoding  find )\n  (send\n    (lvar :options) :delete\n    (sym :Encoding  find ))) ! ! ","(or\n  (lvar :encoding)\n  (send\n    (lvar :DEFAULT_OPTIONS  merge ) :delete\n    (sym :encoding))) ! ! ","(or\n  (lvar :options delete )\n  (send\n    (lvar :options) :delete\n    (sym :options delete ))) ! ","(or\n  (lvar :Encoding  find )\n  (send\n    (lvar :options) :delete\n    (sym :Encoding  find ))) ! ","(or\n  (lvar :encoding)\n  (send\n    (lvar :DEFAULT_OPTIONS  merge ) :delete\n    (sym :encoding))) ! "," raw_options delete  "," raw_Encoding  find  ","data dup force_encoding  is_a? ","data encode  is_a? ","data dup force_encoding  nil? ","data encode  nil? ","options delete  ! ! ","Encoding  find  ! ! ","options delete  ! ","Encoding  find  ! ","options delete  split ","Encoding  find  split ","options delete  is_a? ","Encoding  find  is_a? "," determine_options delete  "," determine_Encoding  find  ","@writer_DEFAULT_OPTIONS  merge  [] ","options delete  nil? ! ","Encoding  find  nil? ! ","options delete  nil? ","Encoding  find  nil? ","@io set_options delete  ","@io set_Encoding  find  ","StringIO  new  set_encoding ","data options delete  ","data Encoding  find  ","data dup force_encoding  encoding ","data encode  encoding ","field_size_limit -  nil? ","data dup force_options delete  ","data dup force_Encoding  find  ","data dup force_encoding  dup force_encoding ","data encode  dup force_encoding ","data dup force_encoding  dup ","data encode  dup ","data dup force_encoding  encode ","data encode  encode "]}," CSV table":{"type":"method","name":"table","children":[],"call":["Hash  new "," read ","default_options merge ","default_default_options merge  merge "]}," CSV readlines":{"type":"method","name":"readlines","children":[],"call":[" read "]}," CSV parse_line":{"type":"method","name":"parse_line","children":[],"call":["Hash  new "," new shift "," new "," new each first "," new each "]}," CSV parse":{"type":"method","name":"parse","children":[],"call":["csv close ","csv read ","csv each "," block_given? "," new "," new  close "," new  read "," new  each "]}," CSV open":{"type":"method","name":"open","children":[],"call":["csv close "," block_given? "," raise ","f close "," new ","(pair\n  (sym :encoding)\n  (send\n    (const nil :Encoding) :default_external)) merge ","Encoding  default_external ","mode == ","(str \"needs binmode\") match? ","e message ","File  open ","(pair\n  (sym :universal_newline)\n  (false)) merge ","options delete ","(str \"newline\\\\z\") match? ","options delete_if ","file_opts [] ","file_opts key? ","options dup "," new  close ","File  open  close ","(pair\n  (sym :encoding)\n  (send\n    (const nil :Encoding) :deFile  open ault_external)) merge ","Encoding  deFile  open ault_external ","(pair\n  (sym :universal_newline)\n  (File  open alse)) merge ","options delete_iFile  open  ","(pair\n  (sym :encoding)\n  (send\n    (const nil :Encoding) :default_external)) merge  [] ","(pair\n  (sym :universal_newline)\n  (false)) merge  [] ","options dup  [] ","File  open ile_opts [] ","(pair\n  (sym :encoding)\n  (send\n    (const nil :Encoding) :default_external)) merge  key? ","(pair\n  (sym :universal_newline)\n  (false)) merge  key? ","options dup  key? ","File  open ile_opts key? "]}," CSV generate_line":{"type":"method","name":"generate_line","children":[],"call":["Hash  new ","(send\n  (send nil :new\n    (lvar :str)\n    (hash\n      (kwsplat\n        (lvar :options)))) :<<\n  (lvar :row)) string "," new << "," new ","str force_encoding ","field encoding ","f is_a? ","row find ","options [] "," +@ ","(pair\n  (sym :row_sep)\n  (gvar :$INPUT_RECORD_SEPARATOR)) merge ","field ascii_only? ","field is_a? ","row each ","(pair\n  (sym :row_sep)\n  (send\n    (const nil :InputRecordSeparator) :value)) merge ","InputRecordSeparator  value ","(send\n  (send nil :new\n    (lvar : +@ )\n    (hash\n      (kwsplat\n        (lvar :options)))) :<<\n  (lvar :row))  +@ ing ","(send\n  (send nil :new\n    (lvar :str)\n    (hash\n      (kwsplat\n        (lvar :(pair\n  (sym :row_sep)\n  (gvar :$INPUT_RECORD_SEPARATOR)) merge )))) :<<\n  (lvar :row)) string ","(send\n  (send nil :new\n    (lvar :str)\n    (hash\n      (kwsplat\n        (lvar :(pair\n  (sym :row_sep)\n  (send\n    (const nil :InputRecordSeparator) :value)) merge )))) :<<\n  (lvar :row)) string "," +@  force_encoding ","(pair\n  (sym :row_sep)\n  (gvar :$INPUT_RECORD_SEPARATOR)) merge  [] ","(pair\n  (sym :row_sep)\n  (send\n    (const nil :InputRecordSeparator) :value)) merge  [] "]}," CSV generate":{"type":"method","name":"generate","children":[],"call":["csv string "," new ","str force_encoding "," +@ ","options [] ","str seek ","StringIO  new ","str set_encoding "," new  string ","csv  +@ ing ","csv StringIO  new ing "," +@  force_encoding ","StringIO  new  force_encoding ","str force_options []  "," +@  seek ","StringIO  new  seek "," +@  set_encoding ","StringIO  new  set_encoding ","str set_options []  "]}," CSV foreach":{"type":"method","name":"foreach","children":[],"call":["Hash  new ","csv each "," open "," to_enum "," __method__ "," block_given? "]}," CSV filter":{"type":"method","name":"filter","children":[],"call":["output << ","input each "," new ","out_options []= ","in_options []= ","1 to_sym ","key to_s ","options each ","Hash  new ","first_row headers ","first_row is_a? ","input shift ","out_options [] ","out_options [] == ","in_options [] ","InputRecordSeparator  value "," new  << "," new  each ","first_row first_row headers  ","input shift  headers ","input shift  is_a? "," new  shift "]}," CSV instance":{"type":"method","name":"instance","children":[],"call":["Hash  new "," block_given? "," new ","@@instances [] ","(send\n  (lvar :data) :object_id) + ","options values_at ","sym to_s ","DEFAULT_OPTIONS  keys sort_by ","DEFAULT_OPTIONS  keys ","data object_id "]}," CSV Table inspect":{"type":"method","name":"inspect","children":[],"call":["(str \"#<\") encode "," to_a size "," to_a "," class ","inspected << << ","inspected << ","summary encoding ascii_compatible? ","summary encoding "," to_csv ","(str \"#<\") +@ ","(str \"#<\") +@  << << ","(str \"#<\") +@  << "," to_csv  encoding ascii_compatible? "," to_csv  encoding "]}," CSV Table to_csv":{"type":"method","name":"to_csv","children":[],"call":["(send\n  (ivar :@table) :inject\n  (if\n    (lvar :wh)\n    (array\n      (send\n        (send nil :headers) :to_csv\n        (lvar :options)))\n    (array))) join ","rows + ","row fields to_csv ","row fields ","row header_row? ","@table inject "," headers to_csv "," headers ","options fetch ","array join ","array push ","@table each ","@table first each ","@table first ","limit < ","@table size + + ","@table size + ","@table size ","(send\n  (ivar :@table) :inject\n  (if\n    (lvar :options fetch )\n    (array\n      (send\n        (send nil :headers) :to_csv\n        (lvar :options)))\n    (array))) join ","@table size + +  < "]}," CSV Table to_a":{"type":"method","name":"to_a","children":[],"call":["array + ","row fields ","row header_row? ","@table inject "," headers ","array push ","@table each "]}," CSV Table ==":{"type":"method","name":"==","children":[],"call":["@table == ","other table ","other is_a? "]}," CSV Table each":{"type":"method","name":"each","children":[],"call":["@table each ","block [] "," [] "," headers each "," headers ","@mode == "," size "," headers size "," enum_for "," __method__ "," block_given? ","row [] ","@table map "," headers each with_index "]}," CSV Table delete_if":{"type":"method","name":"delete_if","children":[],"call":[" delete ","to_delete map ","to_delete << ","block [] "," [] "," headers each_with_index "," headers ","Array  new ","@table delete_if ","@mode == "," headers size "," size "," enum_for "," __method__ ","deleted << "," headers each "," block_given? ","Array  new  map ","Array  new  << "]}," CSV Table delete":{"type":"method","name":"delete","children":[],"call":["row delete last ","row delete ","@table map ","@table delete_at ","index_or_header is_a? ","@mode == ","deleted_values [] ","indexes_or_headers size == ","indexes_or_headers size ","indexes_or_headers map "," raise ","indexes_or_headers empty? ","@headers delete ","@headers delete_at "]}," CSV Table push":{"type":"method","name":"push","children":[],"call":[" << ","rows each "]}," CSV Table <<":{"type":"method","name":"<<","children":[],"call":["@table << ","Row  new "," headers ","row_or_array is_a? "]}," CSV Table values_at":{"type":"method","name":"values_at","children":[],"call":["row values_at ","@table map ","@table values_at ","index last is_a? ","index last ","index first is_a? ","index first ","index is_a? ","indices_or_headers all? ","@mode == "]}," CSV Table []=":{"type":"method","name":"[]=","children":[],"call":["row []= ","row header_row? ","@table each ","value [] ","@table each_with_index ","value is_a? ","@table []= ","Row  new "," headers ","index_or_header is_a? ","@mode == ","@headers []= ","@headers size ","@headers index "]}," CSV Table []":{"type":"method","name":"[]","children":[],"call":["row [] ","@table map ","@table [] ","index_or_header is_a? ","@mode == "]}," CSV Table headers":{"type":"method","name":"headers","children":[],"call":["@table first headers ","@table first ","Array  new ","@table empty? ","@headers dup "]}," CSV Table by_row!":{"type":"method","name":"by_row!","children":[],"call":[]}," CSV Table by_row":{"type":"method","name":"by_row","children":[],"call":[" class new by_row! "," class new ","@table dup "," class "]}," CSV Table by_col_or_row!":{"type":"method","name":"by_col_or_row!","children":[],"call":[]}," CSV Table by_col_or_row":{"type":"method","name":"by_col_or_row","children":[],"call":[" class new by_col_or_row! "," class new ","@table dup "," class "]}," CSV Table by_col!":{"type":"method","name":"by_col!","children":[],"call":[]}," CSV Table by_col":{"type":"method","name":"by_col","children":[],"call":[" class new by_col! "," class new ","@table dup "," class "]}," CSV Table initialize":{"type":"method","name":"initialize","children":[],"call":["@table first headers ","@table first ","@table empty? "]}," CSV Row inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (lvar :str) :map) join ","s force_encoding ","s encode ","Encoding Converter  asciicompat_encoding ","s encoding ","str map ","str join ","str << ","str << << << << ","field inspect ","str << << << ","str << << ","header inspect ","header to_s ","header is_a? "," each "," class to_s "," class ","(sEncoding Converter  asciicompat_encoding nd\n  (lvar :str) :map) join ","s forcEncoding Converter  asciicompat_encoding _Encoding Converter  asciicompat_encoding ncoding ","s Encoding Converter  asciicompat_encoding ncodEncoding Converter  asciicompat_encoding  ","Encoding ConvEncoding Converter  asciicompat_encoding rtEncoding Converter  asciicompat_encoding r  asciicompat_Encoding Converter  asciicompat_encoding ncoding ","s Encoding Converter  asciicompat_encoding ncoding ","fiEncoding Converter  asciicompat_encoding ld inspEncoding Converter  asciicompat_encoding ct ","hEncoding Converter  asciicompat_encoding adEncoding Converter  asciicompat_encoding r inspEncoding Converter  asciicompat_encoding ct ","hEncoding Converter  asciicompat_encoding adEncoding Converter  asciicompat_encoding r to_s ","hEncoding Converter  asciicompat_encoding adEncoding Converter  asciicompat_encoding r is_a? "," Encoding Converter  asciicompat_encoding ach "]}," CSV Row to_csv":{"type":"method","name":"to_csv","children":[],"call":[" fields to_csv "," fields "]}," CSV Row to_hash":{"type":"method","name":"to_hash","children":[],"call":["Hash  [] ","ary push ","@row inject ","Array  new ","@row to_h "]}," CSV Row ==":{"type":"method","name":"==","children":[],"call":["@row == ","other row ","other is_a? "]}," CSV Row each":{"type":"method","name":"each","children":[],"call":["@row each "," size "," enum_for "," __method__ "," block_given? "]}," CSV Row field?":{"type":"method","name":"field?","children":[],"call":[" fields include? "," fields "]}," CSV Row header?":{"type":"method","name":"header?","children":[],"call":[" headers include? "," headers "]}," CSV Row index":{"type":"method","name":"index","children":[],"call":["index + ","index nil? "," headers [] index "," headers [] "," headers "," headers [] index  + "," headers [] index  nil? "," headers []  headers [] index  "]}," CSV Row fields":{"type":"method","name":"fields","children":[],"call":["all + "," field "," Array "," fields values_at "," fields ","h_or_i exclude_end? "," index ","h_or_i end ","h_or_i end is_a? ","h_or_i begin ","h_or_i begin is_a? ","h_or_i is_a? ","headers_and_or_indices inject ","Array  new ","pair last ","@row map ","headers_and_or_indices empty? ","all << ","all concat ","headers_and_or_indices each "]}," CSV Row delete_if":{"type":"method","name":"delete_if","children":[],"call":["@row delete_if "," size "," enum_for "," __method__ "," block_given? "]}," CSV Row delete":{"type":"method","name":"delete","children":[],"call":["@row delete_at "," index ","header_or_index is_a? ","  index ndex ","header_or_ index ndex  index s_a? "]}," CSV Row push":{"type":"method","name":"push","children":[],"call":[" << ","args each "]}," CSV Row <<":{"type":"method","name":"<<","children":[],"call":["@row << ","arg each ","arg is_a? ","arg size == ","arg size "]}," CSV Row []=":{"type":"method","name":"[]=","children":[],"call":["@row [] []= ","@row [] "," << ","args first ","index nil? "," index ","pair nil? ","@row map! ","@row []= ","@row [] nil? ","args first is_a? ","args pop "," index  nil? ","  index  "]}," CSV Row has_key?":{"type":"method","name":"has_key?","children":[],"call":["@row assoc ! ! ","@row assoc ! ","@row assoc "]}," CSV Row fetch":{"type":"method","name":"fetch","children":[],"call":["varargs first "," raise ","varargs empty? "," block_given? ","pair last ","@row assoc ","varargs length > ","varargs length ","@row assoc  last "]}," CSV Row field":{"type":"method","name":"field","children":[],"call":["pair last ","pair map ","header_or_index is_a? ","pair nil? ","@row [] send ","@row [] ","@row [] public_send ","@row [] send  last ","@row [] public_send  last ","@row [] send  map ","@row [] public_send  map ","@row [] send  nil? ","@row [] public_send  nil? "]}," CSV Row headers":{"type":"method","name":"headers","children":[],"call":["pair first ","@row map "]}," CSV Row field_row?":{"type":"method","name":"field_row?","children":[],"call":[" header_row? ! "," header_row? "]}," CSV Row header_row?":{"type":"method","name":"header_row?","children":[],"call":[]}," CSV Row initialize":{"type":"method","name":"initialize","children":[],"call":["pair reverse! ","fields zip map ","fields zip ","headers zip ","headers size >= ","fields size ","headers size ","h freeze ","h is_a? ","headers each ","fields zip each "]}," CSV Table dig":{"type":"method","name":"dig","children":[],"call":["value dig "," raise ","value class ","value respond_to? ","index_or_headers empty? ","value nil? "," [] "," []  dig "," []  class "," []  respond_to? "," []  nil? "]}," CSV Row dig":{"type":"method","name":"dig","children":[],"call":["value dig "," raise ","value class ","value respond_to? ","indexes empty? ","value nil? "," field "," field  dig "," field  class "," field  respond_to? "," field  nil? "]}," CSV determine_encoding":{"type":"method","name":"determine_encoding","children":[],"call":["Encoding  default_external ","Encoding  default_internal ","Encoding  find ","encoding split ","encoding is_a? "," raw_encoding "]}," CSV MalformedCSVError initialize":{"type":"method","name":"initialize","children":[],"call":[]}," CSV MatchP match?":{"type":"method","name":"match?","children":[],"call":[" =~ "]}," CSV Row to_h":{"type":"method","name":"to_h","children":[],"call":["hash []= "," [] ","hash key? "," each "]}," CSV Row initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["@row dup ","@row collect ","@row dup  dup ","@row collect  dup ","@row dup  collect ","@row collect  collect "]}," CSV writer_options":{"type":"method","name":"writer_options","children":[],"call":["@writer_options merge "," header_fields_converter "," writer_fields_converter "]}," CSV writer":{"type":"method","name":"writer","children":[],"call":["Writer  new "," writer_options "]}," CSV parser_options":{"type":"method","name":"parser_options","children":[],"call":["@parser_options merge "," header_fields_converter "," fields_converter "," parser_fields_converter "]}," CSV parser":{"type":"method","name":"parser","children":[],"call":["Parser  new "," parser_options "]}," CSV build_header_fields_converter":{"type":"method","name":"build_header_fields_converter","children":[],"call":["fields_converter add_converter "," normalize_converters each "," normalize_converters ","FieldsConverter  new ","@base_fields_converter_options merge "," build_fields_converter ","FieldsConverter  new  add_converter ","@base_FieldsConverter  new _options merge ","@base_fields_converter_@base_fields_converter_options merge  merge "," build_FieldsConverter  new  "]}," CSV header_fields_converter":{"type":"method","name":"header_fields_converter","children":[],"call":[" build_header_fields_converter "]}," CSV build_fields_converter":{"type":"method","name":"build_fields_converter","children":[],"call":["fields_converter add_converter "," normalize_converters each "," normalize_converters ","FieldsConverter  new ","@base_fields_converter_options merge ","FieldsConverter  new  add_converter ","@base_FieldsConverter  new _options merge ","@base_fields_converter_@base_fields_converter_options merge  merge "]}," CSV fields_converter":{"type":"method","name":"fields_converter","children":[],"call":[" build_fields_converter "]}," CSV normalize_converters":{"type":"method","name":"normalize_converters","children":[],"call":["converters collect ","converters is_a? "]}," CSV line":{"type":"method","name":"line","children":[],"call":[" parser line "," parser "]}," CSV lineno":{"type":"method","name":"lineno","children":[],"call":[" parser lineno "," parser ","@writer lineno "]}," CSV skip_lines":{"type":"method","name":"skip_lines","children":[],"call":[" parser skip_lines "," parser "]}," CSV field_size_limit":{"type":"method","name":"field_size_limit","children":[],"call":[" parser field_size_limit "," parser "]}," CSV quote_char":{"type":"method","name":"quote_char","children":[],"call":[" parser quote_character "," parser "]}," CSV row_sep":{"type":"method","name":"row_sep","children":[],"call":[" parser row_separator "," parser "]}," CSV col_sep":{"type":"method","name":"col_sep","children":[],"call":[" parser column_separator "," parser "]}," CSV Writer prepare_output":{"type":"method","name":"prepare_output","children":[],"call":["@output seek ","@output set_encoding ","Encoding  compatible? ","@options [] ","@encoding != ","@output external_encoding ","@output internal_encoding ","@output is_a? "]}," CSV Writer prepare_format":{"type":"method","name":"prepare_format","children":[],"call":["quote call ","quotable_pattern match? ","field empty? "," String ","field nil? "," lambda ","Regexp  new ","[\r\n encode + + + ","] encode ","[\r\n encode + + ","Regexp  escape ","quote_character encode ","[\r\n encode + ","[\r\n encode ","@options [] ","encoded_quote_character + + ","encoded_quote_character + ","field gsub ","encoded_quote_character * ","field encoding ","row_separator to_s encode ","row_separator to_s ","$INPUT_RECORD_SEPARATOR encode ","row_separator == ","@options [] to_s encode ","@options [] to_s ","@options fetch ","@quote_character encode "," prepare_force_quotes_fields ","force_quotes is_a? ","InputRecordSeparator  value encode ","InputRecordSeparator  value ","Regexp  new  match? "," String  empty? "," String  nil? ","@options []  encode ","quote_character encode  + + ","encoded_@options []  + + ","quote_character encode  + ","encoded_@options []  + "," String  gsub ","quote_character encode  * ","encoded_@options []  * "," String  encoding ","@options []  to_s encode ","@options []  to_s ","@options []  == ","@@options []  encode "," prepare_force_quotes_ String s "," prepare_@options [] _fields ","@options []  is_a? "]}," CSV Writer prepare_header":{"type":"method","name":"prepare_header","children":[],"call":["header freeze ","header is_a? ","@headers each ","converter convert ","@options [] ","CSV  parse_line ","converter convert  each ","CSV  parse_line  each ","@@options []  each ","@options []  convert "]}," CSV Writer prepare":{"type":"method","name":"prepare","children":[],"call":[" prepare_output "," prepare_format "," prepare_header ","@options [] "]}," CSV Writer rewind":{"type":"method","name":"rewind","children":[],"call":["@options [] nil? ","@options [] "]}," CSV Writer <<":{"type":"method","name":"<<","children":[],"call":["@output << ","line encode ","row collect join + ","row collect join ","row collect ","row [] ","@headers collect ","row fields ","converted_row join + ","converted_row join "," quote ","@fields_converter convert "," lineno ","(false) * ","row size ","line encode  encode ","row collect join +  encode ","converted_row join +  encode ","row fields  collect join + ","@fields_converter convert  collect join + ","row fields  collect join ","@fields_converter convert  collect join ","row fields  collect ","@fields_converter convert  collect ","row fields  [] ","@fields_converter convert  [] ","row fields  fields ","@fields_converter convert  fields ","converted_row fields  join + ","converted_@fields_converter convert  join + ","converted_row fields  join ","converted_@fields_converter convert  join "," line encode no "," row collect join + no "," converted_row join + no ","row fields  size ","@fields_converter convert  size "]}," CSV Writer initialize":{"type":"method","name":"initialize","children":[],"call":[" << ","@options [] "," prepare "]}," CSV Parser add_unconverted_fields":{"type":"method","name":"add_unconverted_fields","children":[],"call":["row instance_variable_set "," attr_reader "]}," CSV Parser emit_row":{"type":"method","name":"emit_row","children":[],"call":[" add_unconverted_fields ","row respond_to? ! ","row respond_to? ","@fields_converter convert ","Row  new "," adjust_headers ","@headers nil? ","@fields_converter convert  respond_to? ! ","Row  new  respond_to? ! ","@fields_converter convert  respond_to? ","Row  new  respond_to? "," adjust_headers  nil? "]}," CSV Parser start_row":{"type":"method","name":"start_row","children":[],"call":["@scanner keep_start ","@scanner keep_drop "]}," CSV Parser parse_row_end":{"type":"method","name":"parse_row_end","children":[],"call":["@scanner keep_back ","@scanner keep_drop ","@scanner scan ","@row_ends all? ","@scanner keep_start "]}," CSV Parser parse_column_end":{"type":"method","name":"parse_column_end","children":[],"call":["@scanner keep_back ","@scanner keep_drop ","@scanner scan ","@column_ends all? ","@scanner keep_start "]}," CSV Parser parse_quoted_column_value":{"type":"method","name":"parse_quoted_column_value","children":[],"call":["value << ","quotes [] ","n_quotes / ","(send\n  (lvar :n_quotes) :-\n  (int 1)) / ","n_quotes - ","(send\n  (lvar :n_quotes) :%\n  (int 2)) == ","n_quotes % ","n_quotes == ","quotes size "," raise ","MalformedCSVError  new ","@lineno + ","@scanner scan_all ","(send\n  (lvar :n_quotes) :-\n  (int 2)) / ","(send\n  (lvar :n_quotes) :%\n  (int 2)) zero? "," ignore_broken_line ","@scanner scan ","quotes []  << ","@scanner scan_all  [] ","quotes size  / ","n_@scanner scan_all  / ","(send\n  (lvar :quotes size ) :-\n  (int 1)) / ","(send\n  (lvar :n_@scanner scan_all ) :-\n  (int 1)) / ","quotes size  - ","n_@scanner scan_all  - ","(send\n  (lvar :quotes size ) :%\n  (int 2)) == ","(send\n  (lvar :n_@scanner scan_all ) :%\n  (int 2)) == ","quotes size  % ","n_@scanner scan_all  % ","quotes size  == ","n_@scanner scan_all  == ","@scanner scan_all  size ","(send\n  (lvar :quotes size ) :-\n  (int 2)) / ","(send\n  (lvar :n_@scanner scan_all ) :-\n  (int 2)) / ","(send\n  (lvar :quotes size ) :%\n  (int 2)) zero? ","(send\n  (lvar :n_@scanner scan_all ) :%\n  (int 2)) zero? "]}," CSV Parser parse_unquoted_column_value":{"type":"method","name":"parse_unquoted_column_value","children":[],"call":["@scanner scan_all ","value << ","sub_value nil? ","sub_separator nil? ","@scanner keep_back ","@scanner scan ","@column_ends all? ","@scanner keep_start ","value gsub! ","@scanner scan_all  << ","sub_@scanner scan_all  nil? ","@scanner scan_all  nil? ","@scanner scan_all  gsub! "]}," CSV Parser parse_column_value":{"type":"method","name":"parse_column_value","children":[],"call":[" parse_quoted_column_value "," parse_unquoted_column_value ","@quote_character + + + ","@quote_character + + ","@quote_character + ","quoted_value empty? ","unquoted_value gsub ","@quote_character * ","@scanner scan_all "," parse_quoted_column_value  empty? "," parse_unquoted_column_value  gsub ","unquoted_value gsub  gsub ","un parse_quoted_column_value  gsub "]}," CSV Parser skip_line?":{"type":"method","name":"skip_line?","children":[],"call":["@skip_lines match ","@skip_lines match? ","line include? ","line delete_suffix ","@skip_line delete_suffix s match ","@skip_line delete_suffix s match? ","line delete_suffix  include? ","line delete_suffix  delete_suffix "]}," CSV Parser skip_needless_lines":{"type":"method","name":"skip_needless_lines","children":[],"call":["@scanner keep_back ","@scanner keep_drop "," skip_line? ","line << "," parse_row_end "," encode ","@scanner scan_all ","@scanner keep_start ","@scanner eos? "]}," CSV Parser build_scanner":{"type":"method","name":"build_scanner","children":[],"call":["InputsScanner  new ","inputs << ","StringIO  new ","@samples collect ","Scanner  new "," raise ","MalformedCSVError  new ","@lineno + ","string valid_encoding? ","@samples [] ","@input eof? ","@input respond_to? ","@samples size == ","@samples size ","@input string ","@input is_a? ","@samples empty? ","UnoptimizedStringIO  new ","@lineno + + ","line valid_encoding? ! ","line valid_encoding? ","string lines index ","string lines "," Integer ","ENV  [] ","@input read ","@input != ","InvalidEncodingError  new ","@samples []  valid_encoding? ","@input string  valid_encoding? ","@input read  valid_encoding? ","@input @samples []  ","@input @input string  ","@input @input read  ","@samples []  lines index ","@input string  lines index ","@input read  lines index ","@samples []  lines ","@input string  lines ","@input read  lines "]}," CSV Parser UnoptimizedStringIO eof?":{"type":"method","name":"eof?","children":[],"call":["@io eof? "]}," CSV Parser UnoptimizedStringIO gets":{"type":"method","name":"gets","children":[],"call":["@io gets "]}," CSV Parser UnoptimizedStringIO initialize":{"type":"method","name":"initialize","children":[],"call":["StringIO  new ","string encoding "]}," CSV Parser may_quoted?":{"type":"method","name":"may_quoted?","children":[],"call":["sample [] index ","sample [] ","@samples first ","@samples empty? ","@input string ","@input is_a? ","@quote_character nil? ","@input seek ","@input read ","@input pos ","@samples first  [] index ","@input string  [] index ","@input read  [] index ","@samples first  [] ","@input string  [] ","@input read  [] ","@@samples first s first ","@@input string s first ","@@input read s first ","@@samples first s empty? ","@@input string s empty? ","@@input read s empty? ","@input @input pos  "]}," CSV Parser prepare_parser":{"type":"method","name":"prepare_parser","children":[],"call":[" may_quoted? "]}," CSV Parser adjust_headers":{"type":"method","name":"adjust_headers","children":[],"call":["h freeze ","h is_a? ","adjusted_headers each ","@header_fields_converter convert ","@header_fields_converter convert  each "]}," CSV Parser parse_headers":{"type":"method","name":"parse_headers","children":[],"call":["CSV  parse_line ","quoted_fields << ","info quoted? "," lambda "]}," CSV Parser prepare_header":{"type":"method","name":"prepare_header","children":[],"call":[" adjust_headers "," parse_headers ","@options [] ","(false) * ","@raw_headers size "," adjust_@options []  "," parse_@options []  "," parse_headers  size ","@raw_@options []  size "]}," CSV Parser last_line":{"type":"method","name":"last_line","children":[],"call":["@scanner keep_end "]}," CSV Parser prepare_line":{"type":"method","name":"prepare_line","children":[],"call":[]}," CSV Parser detect_row_separator":{"type":"method","name":"detect_row_separator","children":[],"call":["cr_index < ","cr + ","cr_index + == ","cr_index + ","sample index ","sample [] index ","sample [] ","sample index  < ","sample [] index  < ","sample index  + == ","sample [] index  + == ","sample index  + ","sample [] index  + "]}," CSV Parser resolve_row_separator":{"type":"method","name":"resolve_row_separator","children":[],"call":["separator to_s encode ","separator to_s ","separator == "," detect_row_separator ","@samples << ","sample << ","@input gets ","sample end_with? ","32 * ","@input is_a? ","@input respond_to? ","@input string ","\n encode ","\r encode ","@input seek ","@input read ","@input pos ","InputRecordSeparator  value "," detect_row_separator  to_s encode ","InputRecordSeparator  value  to_s encode "," detect_row_separator  to_s ","InputRecordSeparator  value  to_s "," detect_row_separator  == ","InputRecordSeparator  value  == "," detect_row_ detect_row_separator  "," detect_row_InputRecordSeparator  value  ","@@input gets s << ","@input gets  << ","@input gets  end_with? ","@input @input pos  "]}," CSV Parser prepare_regexp":{"type":"method","name":"prepare_regexp","children":[],"call":["Regexp  new ","[^\r\n]+ encode ","[\r\n] encode ","[^ encode + + + ","\r\n]+ encode ","[^ encode + + ","[^ encode + ","[^ encode ","]+ encode ","escaped_quote_character + ","+ encode ","Regexp  escape ","@row_separator each_char collect ","@row_separator each_char ","@row_separator size > ","@row_separator size ","@column_separator each_char collect ","@column_separator each_char ","@column_separator size > ","@column_separator size "," raise ","skip_lines inspect ","skip_lines respond_to? ","skip_lines encode ","@options [] ","@quote_character length != ","@quote_character length ","@options [] to_s encode ","@options [] to_s "," resolve_row_separator encode "," resolve_row_separator ","escaped_first_column_separator + ","@column_separator [] ","Regexp  escape  + "," resolve_row_separator encode  each_char collect "," resolve_row_separator encode  each_char "," resolve_row_separator encode  size > "," resolve_row_separator encode  size ","@options [] to_s encode  each_char collect ","@options [] to_s encode  each_char ","@options [] to_s encode  size > ","@options [] to_s encode  size ","@options []  inspect ","@options []  respond_to? ","@options []  encode ","@options [] to_s encode  length != ","@options [] to_s encode  length ","@options [] to_s encode  [] "]}," CSV Parser prepare_variable":{"type":"method","name":"prepare_variable","children":[],"call":["@options [] ","liberal_parsing [] ","liberal_parsing is_a? ","@options []  [] ","@options []  is_a? "]}," CSV Parser prepare":{"type":"method","name":"prepare","children":[],"call":[" prepare_parser "," prepare_header "," prepare_line "," prepare_regexp "," prepare_variable "," prepare_unquoted "," prepare_quoted "," prepare_separators "," prepare_strip "," prepare_skip_lines "," prepare_quote_character "," prepare_backslash "," validate_strip_and_col_sep_options "]}," CSV Parser parse":{"type":"method","name":"parse","children":[],"call":[" raise ","MalformedCSVError  new ","@lineno + ","@scanner rest start_with? ","@scanner rest ","@scanner scan ","Do not allow except col_sep_split_separator  + "," emit_row ","row << ","value nil? ","row empty? ","@scanner eos? "," start_row "," skip_needless_lines "," parse_row_end "," parse_column_end ","value size >= ","value size "," parse_column_value "," build_scanner "," add_unconverted_fields ","Row  new "," to_enum "," __method__ "," block_given? "," ignore_broken_line "," parse_quotable "," parse_no_quote "," quote_character nil? "," quote_character "," parse_quotable_loose "," parse_quotable_robust ","error message ","InvalidEncodingError  new ","@@lineno +  + "," build_scanner  rest start_with? "," build_scanner  rest "," build_scanner  scan "," parse_column_value  nil? "," build_scanner  eos? "," parse_column_value  size >= "," parse_column_value  size "," parse_column_ parse_column_value  ","error Do not allow except col_sep_split_separator  +  "]}," CSV Parser line":{"type":"method","name":"line","children":[],"call":[" last_line "]}," CSV Parser lineno":{"type":"method","name":"lineno","children":[],"call":[]}," CSV Parser liberal_parsing?":{"type":"method","name":"liberal_parsing?","children":[],"call":[]}," CSV Parser skip_blanks?":{"type":"method","name":"skip_blanks?","children":[],"call":[]}," CSV Parser return_headers?":{"type":"method","name":"return_headers?","children":[],"call":[]}," CSV Parser header_row?":{"type":"method","name":"header_row?","children":[],"call":["@headers nil? "]}," CSV Parser headers":{"type":"method","name":"headers","children":[],"call":[]}," CSV Parser unconverted_fields?":{"type":"method","name":"unconverted_fields?","children":[],"call":[]}," CSV Parser skip_lines":{"type":"method","name":"skip_lines","children":[],"call":[]}," CSV Parser field_size_limit":{"type":"method","name":"field_size_limit","children":[],"call":[]}," CSV Parser quote_character":{"type":"method","name":"quote_character","children":[],"call":[]}," CSV Parser row_separator":{"type":"method","name":"row_separator","children":[],"call":[]}," CSV Parser column_separator":{"type":"method","name":"column_separator","children":[],"call":[]}," CSV Parser initialize":{"type":"method","name":"initialize","children":[],"call":[" prepare "]}," CSV Parser InputsScanner read_chunk":{"type":"method","name":"read_chunk","children":[],"call":[" read_chunk ","@inputs empty? ","@inputs shift ","StringScanner  new "," encode ","input eof? ","input respond_to? "," raise ","chunk valid_encoding? ","input gets ","string valid_encoding? ","input string ","@inputs first ","keep []= ","keep_data dup ","keep_buffer << ","keep [] ","string [] ","@scanner pos - ","@scanner pos ","@scanner string ","@keeps last ","@keeps empty? ","string byteslice ","input read "," adjust_last_keep "," read_input gets  ","@@inputs first s empty? ","@@inputs first s shift ","@inputs first  eof? ","@inputs first  respond_to? ","input gets  valid_encoding? ","@inputs first  gets ","input string  valid_encoding? ","@scanner string  valid_encoding? ","input read  valid_encoding? ","input input string  ","input @scanner string  ","input input read  ","@inputs first  string ","@@inputs first s first ","@keeps last  []= ","string []  dup ","string byteslice  dup ","@keeps last _data dup ","keep []  << ","@keeps last _buffer << ","@keeps last  [] ","input string  [] ","@scanner string  [] ","input read  [] ","StringScanner  new  pos - ","StringScanner  new  pos ","StringScanner  new  string ","@scanner input string  ","@scanner @scanner string  ","@scanner input read  ","@@keeps last s last ","@@keeps last s empty? ","input string  byteslice ","@scanner string  byteslice ","input read  byteslice ","@inputs first  read "," adjust_last_@keeps last  "]}," CSV Parser InputsScanner rest":{"type":"method","name":"rest","children":[],"call":["@scanner rest "]}," CSV Parser InputsScanner keep_drop":{"type":"method","name":"keep_drop","children":[],"call":["@keeps pop ","last_keep []= ","last_keep [] << ","last_keep [] ","@keeps last ","@keeps last  []= ","@keeps last  [] << ","@keeps last  [] "]}," CSV Parser InputsScanner keep_back":{"type":"method","name":"keep_back","children":[],"call":["@scanner pos= ","StringScanner  new ","@inputs unshift ","StringIO  new ","keep empty? ! ","keep empty? ","string [] ","string size - ","string size ","@scanner string ","@keeps pop ","string byteslice ","string bytesize - ","string bytesize "," read_chunk ","@scanner eos? "," raise ","scanner object_id ","scanner inspect ","@scanner object_id ","@scanner inspect ","@scanner != ","scanner == ","string bytesize - - ","@scanner pos ","StringScanner  new  pos= ","string []  empty? ! ","string byteslice  empty? ! ","string []  empty? ","string byteslice  empty? ","@scanner string  [] ","@scanner string  size - ","@scanner string  size ","StringScanner  new  string ","@scanner @scanner string  ","@string [] s pop ","@string byteslice s pop ","@scanner string  byteslice ","@scanner string  bytesize - ","@scanner string  bytesize ","StringScanner  new  eos? ","StringScanner  new  object_id ","StringScanner  new  inspect ","StringScanner  new  != ","@scanner string  bytesize - - ","StringScanner  new  pos "]}," CSV Parser InputsScanner keep_end":{"type":"method","name":"keep_end","children":[],"call":["buffer << ","@scanner string [] ","@scanner pos - ","@scanner pos ","@scanner string ","@keeps pop ","@scanner string byteslice ","scanner == ","@@scanner string [] s pop ","@@scanner string byteslice s pop "]}," CSV Parser InputsScanner keep_start":{"type":"method","name":"keep_start","children":[],"call":["@keeps push ","@scanner pos "," adjust_last_keep "]}," CSV Parser InputsScanner eos?":{"type":"method","name":"eos?","children":[],"call":["@scanner eos? "]}," CSV Parser InputsScanner scan_all":{"type":"method","name":"scan_all","children":[],"call":["value << ","@scanner scan "," read_chunk ","@scanner eos? ","value nil? ","@scanner scan  << ","@scanner scan  nil? "]}," CSV Parser InputsScanner scan":{"type":"method","name":"scan","children":[],"call":[" read_chunk ","@scanner eos? ","@scanner scan "]}," CSV Parser InputsScanner initialize":{"type":"method","name":"initialize","children":[],"call":[" read_chunk ","@inputs empty? ","inputs dup ","inputs dup  empty? "]}," CSV Parser Scanner keep_drop":{"type":"method","name":"keep_drop","children":[],"call":["@keeps pop "]}," CSV Parser Scanner keep_back":{"type":"method","name":"keep_back","children":[],"call":[" pos= ","@keeps pop "]}," CSV Parser Scanner keep_end":{"type":"method","name":"keep_end","children":[],"call":[" string [] "," pos - "," pos "," string ","@keeps pop "," string byteslice "]}," CSV Parser Scanner keep_start":{"type":"method","name":"keep_start","children":[],"call":["@keeps push "," pos "]}," CSV Parser Scanner initialize":{"type":"method","name":"initialize","children":[],"call":[]}," CSV FieldsConverter need_convert?":{"type":"method","name":"need_convert?","children":[],"call":["@converters empty? ! ","@converters empty? "]}," CSV FieldsConverter need_static_convert?":{"type":"method","name":"need_static_convert?","children":[],"call":["(and\n  (send\n    (ivar :@nil_value) :nil?)\n  (ivar :@empty_value_is_empty_string)) ! ","@nil_value nil? "]}," CSV FieldsConverter convert":{"type":"method","name":"convert","children":[],"call":["field is_a? ","converter [] ","FieldInfo  new ","headers [] ","converter arity == ","converter arity ","field nil? ","@converters each ","field empty? ","fields collect with_index ","fields collect "," need_convert? ","quoted_fields [] ","converter []  is_a? ","headers [] s [] ","converter []  nil? ","converter []  empty? ","converter [] s collect with_index ","converter [] s collect ","quoted_converter [] s [] ","quoted_fields [] _fields [] "]}," CSV FieldsConverter empty?":{"type":"method","name":"empty?","children":[],"call":["@converters empty? "]}," CSV FieldsConverter each":{"type":"method","name":"each","children":[],"call":["@converters each "]}," CSV FieldsConverter add_converter":{"type":"method","name":"add_converter","children":[],"call":["@converters << "," add_converter ","combo each ","@builtin_converters [] ","name nil? "," builtin_converters [] "," builtin_converters ","@builtin_converters []  each "," builtin_converters []  each "]}," CSV FieldsConverter initialize":{"type":"method","name":"initialize","children":[],"call":[" need_static_convert? ","options [] ","@empty_value == ","options []  == "]}," CSV Writer quote":{"type":"method","name":"quote","children":[],"call":[" quote_field ","@quotable_pattern match? ","field empty? "," String ","field nil? ","field valid_encoding? ","@force_quotes_fields [] "," quote_ String  "," String  empty? "," String  nil? "," String  valid_encoding? ","@force_quotes_ String s [] "]}," CSV Writer quote_field":{"type":"method","name":"quote_field","children":[],"call":["encoded_quote_character + + ","encoded_quote_character + ","field gsub ","encoded_quote_character * ","@quote_character encode ","field encoding "," String ","@quote_character encode  + + ","@quote_character encode  + "," String  gsub ","@quote_character encode  * "," String  encoding "]}," CSV Parser use_headers?":{"type":"method","name":"use_headers?","children":[],"call":[]}," CSV parser_enumerator":{"type":"method","name":"parser_enumerator","children":[],"call":[" parser parse "," parser "]}," CSV build_writer_fields_converter":{"type":"method","name":"build_writer_fields_converter","children":[],"call":[" build_fields_converter "]}," CSV writer_fields_converter":{"type":"method","name":"writer_fields_converter","children":[],"call":[" build_writer_fields_converter "]}," CSV build_parser_fields_converter":{"type":"method","name":"build_parser_fields_converter","children":[],"call":[" build_fields_converter ","@base_fields_converter_options merge ","@base_fields_converter_@base_fields_converter_options merge  merge "]}," CSV parser_fields_converter":{"type":"method","name":"parser_fields_converter","children":[],"call":[" build_parser_fields_converter "]}," CSV eof?":{"type":"method","name":"eof?","children":[],"call":[" parser_enumerator peek "," parser_enumerator "]}," CSV to_io":{"type":"method","name":"to_io","children":[],"call":["@io to_io ","@io respond_to? "]}," CSV to_i":{"type":"method","name":"to_i","children":[],"call":["@io to_i "," raise ","@io respond_to? "]}," CSV stat":{"type":"method","name":"stat","children":[],"call":["@io stat "," raise ","@io respond_to? "]}," CSV path":{"type":"method","name":"path","children":[],"call":["@io path ","@io respond_to? "]}," CSV ioctl":{"type":"method","name":"ioctl","children":[],"call":["@io ioctl "," raise ","@io respond_to? "]}," CSV flock":{"type":"method","name":"flock","children":[],"call":["@io flock "," raise ","@io respond_to? "]}," CSV binmode?":{"type":"method","name":"binmode?","children":[],"call":["@io binmode? ","@io respond_to? "]}," CSV Parser ignore_broken_line":{"type":"method","name":"ignore_broken_line","children":[],"call":["@scanner scan_all "]}," CSV Parser strip_value":{"type":"method","name":"strip_value","children":[],"call":["value strip! ","value [] ","value end_with? ","value start_with? ","value size ","value nil? ","value delete_suffix! ","value delete_prefix! ","value []  strip! ","value []  [] ","value []  end_with? ","value []  start_with? ","value []  size ","value value size  ","value []  nil? ","value []  delete_suffix! ","value []  delete_prefix! "]}," CSV Parser parse_quotable":{"type":"method","name":"parse_quotable","children":[],"call":[" raise ","MalformedCSVError  new "," ignore_broken_line ","(str \"New line must be <\") + ","new_line inspect ","@row_separator inspect ","@scanner scan ","@scanner rest start_with? ","@scanner rest ","Unquoted fields do not allow new line  + "," emit_row ","row << ","value nil? ","row empty? ","@scanner eos? "," start_row "," skip_needless_lines "," parse_row_end "," parse_column_end ","value size >= ","value size ","@scanner scan_all "," parse_column_value ","@scanner scan  inspect "," parse_column_value  nil? "," parse_column_value  size >= "," parse_column_value  size "," parse_column_ parse_column_value  "]}," CSV Parser parse_no_quote":{"type":"method","name":"parse_no_quote","children":[],"call":[" emit_row ","row []= ","row [] empty? ","row [] ","i < ","row size ","value split "," strip_value ","value empty? ","value chomp! "," skip_line? ","scanner each_line ","@scanner string ","@scanner respond_to? ","line split ","line empty? ","line chomp! ","line delete_suffix ","@scanner each_line "," validate_field_size ","row each ","(false) * "," emit_value split  "," emit_line split  ","value split  []= ","line split  []= ","value split  [] empty? ","line split  [] empty? ","value split  [] ","line split  [] ","value split  size ","line split  size "," strip_value  split "," strip_ strip_value  "," strip_value  empty? "," strip_value  chomp! "," skip_ strip_value ? "," skip_line delete_suffix ? ","@scanner string  each_line ","scanner each_ strip_value  ","scanner each_line delete_suffix  ","@@scanner string  string ","@@scanner string  respond_to? ","line delete_suffix  split ","line delete_suffix  empty? ","line delete_suffix  chomp! "," strip_value  delete_suffix ","line delete_suffix  delete_suffix ","@@scanner string  each_line ","@scanner each_ strip_value  ","@scanner each_line delete_suffix  ","value split  each ","line split  each "]}," CSV Parser UnoptimizedStringIO each_line":{"type":"method","name":"each_line","children":[],"call":["@io each_line "]}," CSV Parser prepare_unquoted":{"type":"method","name":"prepare_unquoted","children":[],"call":["Regexp  new ","[^ encode + + ","]+ encode ","[^ encode + ","[^ encode ","no_unquoted_values << ","\r\n encode ","@quote_character nil? ","\r\n encode  << "]}," CSV Parser prepare_quoted":{"type":"method","name":"prepare_quoted","children":[],"call":["@column_separator == ","  encode ","Regexp  new ","@escaped_strip + + + + ","* encode ","@escaped_strip + + + ","@escaped_strip + + ","@escaped_strip + ","[^ encode + + ","]+ encode ","[^ encode + ","[^ encode ","no_quoted_values << ","@escaped_quote_character dup ","@escaped_quote_character + ","+ encode ","@escaped_quote_character dup  << "]}," CSV Parser prepare_separators":{"type":"method","name":"prepare_separators","children":[],"call":["Regexp  new ","[^\r\n]+ encode ","[\r\n] encode ","Regexp  escape ","@row_separator each_char collect ","@row_separator each_char ","@row_separator size > ","@row_separator size ","@escaped_first_column_separator + ","+ encode ","@column_separator each_char collect ","@column_separator each_char ","@column_separator size > ","@column_separator size ","@column_separator [] "," resolve_row_separator encode "," resolve_row_separator ","@options [] ","@options [] to_s encode ","@options [] to_s ","\n encode ","\r encode "," raise ","column_separator inspect ","@column_separator size < ","column_separator to_s encode ","column_separator to_s ","\r\n|\n|\r encode "," resolve_row_separator encode  each_char collect "," resolve_row_separator encode  each_char "," resolve_row_separator encode  size > "," resolve_row_separator encode  size ","Regexp  escape  + ","@escaped_first_@options []  + ","@options [] to_s encode  each_char collect ","column_separator to_s encode  each_char collect ","@@options []  each_char collect ","@options [] to_s encode  each_char ","column_separator to_s encode  each_char ","@@options []  each_char ","@options [] to_s encode  size > ","column_separator to_s encode  size > ","@@options []  size > ","@options [] to_s encode  size ","column_separator to_s encode  size ","@@options []  size ","@options [] to_s encode  [] ","column_separator to_s encode  [] ","@@options []  [] ","@options []  inspect ","@options [] to_s encode  size < ","column_separator to_s encode  size < ","@@options []  size < ","@options []  to_s encode ","@options []  to_s "]}," CSV Parser prepare_strip":{"type":"method","name":"prepare_strip","children":[],"call":["Regexp  new ","(str \"[\") encode ","strip_values encode ","@escaped_strip + ","+ encode ","Regexp  escape ","@strip encode "," raise ","@strip length ","@strip is_a? ","@options [] ","+\\z encode ","strip_values encode  + ","Regexp  escape  + ","@strip encode  encode ","@options []  encode ","@strip encode  length ","@options []  length ","@strip encode  is_a? ","@options []  is_a? "]}," CSV Parser prepare_skip_lines":{"type":"method","name":"prepare_skip_lines","children":[],"call":[" raise ","skip_lines inspect ","skip_lines respond_to? ","skip_lines encode ","@options [] ","@options []  inspect ","@options []  respond_to? ","@options []  encode "]}," CSV Parser prepare_quote_character":{"type":"method","name":"prepare_quote_character","children":[],"call":["@backslash_character + ","Regexp  new ","Regexp  escape "," raise ","@quote_character length != ","@quote_character length ","@quote_character to_s encode ","@quote_character to_s ","@quote_character nil? ","@options [] ","@quote_character * ","@quote_character to_s encode  length != ","@options []  length != ","@quote_character to_s encode  length ","@options []  length ","@quote_character to_s encode  to_s encode ","@options []  to_s encode ","@quote_character to_s encode  to_s ","@options []  to_s ","@quote_character to_s encode  nil? ","@options []  nil? ","@quote_character to_s encode  * ","@options []  * "]}," CSV Parser prepare_backslash":{"type":"method","name":"prepare_backslash","children":[],"call":["Regexp  new ","Regexp  escape ","\\ encode ","@backslash_character + ","@quote_character nil? ","\\ encode  + "]}," CSV Parser InputsScanner each_line":{"type":"method","name":"each_line","children":[],"call":["@inputs shift ","line end_with? ","buffer << ","input each_line ","@scanner terminate ","@scanner rest ","buffer bytesize -@ ","buffer bytesize ","@scanner pos "," read_chunk ","@scanner pos= ","line bytesize + ","line bytesize ","line empty? ","buffer bytesize + ","line [] ","line start_with? ","row_separator [] ","buffer end_with? ","n_row_separator_chars == ","row_separator size "," enum_for "," __method__ "," block_given? ","@@inputs shift s shift ","@@scanner rest s shift ","line []  end_with? ","@inputs shift  each_line ","@scanner rest  each_line ","input each_line []  ","line []  bytesize + ","line []  bytesize ","line []  empty? ","line []  [] ","line []  start_with? ","row_separator size  == "]}," CSV Parser parse_quotable_robust":{"type":"method","name":"parse_quotable_robust","children":[],"call":[" raise ","MalformedCSVError  new "," ignore_broken_line ","(str \"New line must be <\") + ","new_line inspect ","@row_separator inspect ","@scanner scan ","@scanner rest start_with? ","@scanner rest ","Unquoted fields do not allow new line  + "," emit_row ","row << ","value nil? ","row empty? ","@scanner eos? "," start_row "," skip_needless_lines "," parse_row_end "," parse_column_end ","value size >= ","value size ","@scanner scan_all "," parse_column_value ","Illegal end-of-line sequence outside of a quoted field  + ","@scanner check "," liberal_parsing? "," validate_field_size ","quoted_fields << ","@scanner scan  inspect ","@scanner check  inspect "," parse_column_value  nil? "," parse_column_value  size >= "," parse_column_value  size "," parse_column_ parse_column_value  "]}," CSV Parser parse_quotable_loose":{"type":"method","name":"parse_quotable_loose","children":[],"call":["@scanner keep_drop "," emit_row ","@scanner keep_start "," parse_quotable_robust ","@scanner keep_back ","row []= ","column [] ","column end_with? ","column start_with? ","n_quotes == ","n_quotes zero? ","column count ","column empty? ","row [] ","i < ","row size ","line split ","line include? ","line empty? ","line delete_suffix "," skip_line? ","@scanner each_line "," validate_field_size ","quoted_fields << "," emit_line split  ","line split  []= ","row []  [] ","row []  end_with? ","row []  start_with? ","column count  == ","column count  zero? ","row []  count ","row []  empty? ","line split  [] ","line split  size ","line delete_suffix  split ","line delete_suffix  include? ","line delete_suffix  empty? ","line delete_suffix  delete_suffix "," skip_line delete_suffix ? ","@scanner each_line delete_suffix  "]}," CSV Parser Scanner each_line":{"type":"method","name":"each_line","children":[],"call":[" pos= ","line bytesize "," rest each_line "," rest "," pos "]}," CSV DeleteSuffix delete_suffix":{"type":"method","name":"delete_suffix","children":[],"call":[" [] ","(send\n  (send\n    (lvar :suffix) :size) :+\n  (int 1)) -@ ","suffix size + ","suffix size "," end_with? ","suffix size -@ "]}," CSV Writer prepare_force_quotes_fields":{"type":"method","name":"prepare_force_quotes_fields","children":[],"call":[" raise ",":force_quotes element must be  + + ","force_quotes inspect ","name_or_index inspect ",":force_quotes element must be  + ","@force_quotes_fields []= ","index nil? ","@headers index ",":headers is required when you use field name  + + ",":headers is required when you use field name  + ","@headers nil? ","name_or_index to_s ","force_quotes each ","name_or_@headers index  inspect ","name_or_index to_s _or_index inspect ","@headers index  nil? ","@headers @headers index  ",":headers is required when you use field name_or_index to_s   + + ",":headers is required when you use field name_or_index to_s   + ","name_or_@headers index  to_s ","name_or_index to_s _or_index to_s "]}," CSV Row deconstruct":{"type":"method","name":"deconstruct","children":[],"call":[" fields "]}," CSV Row deconstruct_keys":{"type":"method","name":"deconstruct_keys","children":[],"call":[" [] ","keys to_h "," to_h ","keys nil? "]}," CSV InputRecordSeparator value":{"type":"method","name":"value","children":[],"call":[]}," CSV FieldsConverter builtin_converters":{"type":"method","name":"builtin_converters","children":[],"call":[" CSV  const_get "]}," CSV Parser validate_strip_and_col_sep_options":{"type":"method","name":"validate_strip_and_col_sep_options","children":[],"call":[" raise ","Regexp  new match? ","Regexp  new ","@column_separator end_with? ","@column_separator start_with? ","@strip is_a? "]}," CSV max_field_size":{"type":"method","name":"max_field_size","children":[],"call":[" parser max_field_size "," parser "]}," CSV Parser validate_field_size":{"type":"method","name":"validate_field_size","children":[],"call":[" raise ","MalformedCSVError  new ","field size "," ignore_broken_line ","field size <= "]}," CSV Parser max_field_size":{"type":"method","name":"max_field_size","children":[],"call":[]}," CSV Parser InputsScanner adjust_last_keep":{"type":"method","name":"adjust_last_keep","children":[],"call":["keep []= ","keep_data dup ","buffer << ","string byteslice ","@scanner pos - ","@scanner pos ","@scanner eos? ","start == ","@scanner != ","@scanner string ","keep nil? ","@keeps last ","@keeps last  []= ","string byteslice  dup ","@keeps last _data dup ","@scanner string  byteslice ","@scanner @scanner string  ","@keeps last  nil? ","@@keeps last s last "]}," CSV Parser InputsScanner trace":{"type":"method","name":"trace","children":[],"call":[" pp "]}," CSV Parser InputsScanner check":{"type":"method","name":"check","children":[],"call":["@scanner check "]}," CSV generate_lines":{"type":"method","name":"generate_lines","children":[],"call":["csv << ","rows each "," generate "]}," CSV InvalidEncodingError initialize":{"type":"method","name":"initialize","children":[],"call":[]}}