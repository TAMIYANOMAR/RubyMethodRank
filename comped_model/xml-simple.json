{" XmlSimple put_into_cache":{"type":"method","name":"put_into_cache","children":[],"call":[" raise ","@@cache save_mem_copy ","@@cache save_mem_share ","@@cache save_storable ","@options [] each ","@options [] ","@options has_key? "]}," XmlSimple load_xml_file":{"type":"method","name":"load_xml_file","children":[],"call":[" parse ","File  readlines to_s ","File  readlines ","IO  read "]}," XmlSimple find_xml_file":{"type":"method","name":"find_xml_file","children":[],"call":[" raise ","searchpath join ","File  file? ","searchpath empty? ","File  join ","searchpath each ","filename != ","File  basename ","File  basename  != "]}," XmlSimple parse":{"type":"method","name":"parse","children":[],"call":["Document  new "]}," XmlSimple node_to_text":{"type":"method","name":"node_to_text","children":[],"call":["node value strip ","node value ","node instance_of? ","node value nil? ","(send\n  (send\n    (lvar :node) :texts) :map) join ","t value ","node texts map ","node texts ","node to_s strip ","node to_s ","node texts join ","Text  unnormalize ","node is_a? "]}," XmlSimple empty":{"type":"method","name":"empty","children":[],"call":["value nil? ","value !~ ","value empty? "]}," XmlSimple normalise_space":{"type":"method","name":"normalise_space","children":[],"call":["text strip gsub ","text strip ","text gsub! ","text sub! "]}," XmlSimple escape_value":{"type":"method","name":"escape_value","children":[],"call":["Text  normalize ","result gsub! ","data dup ","data == ","data nil? ","data dup  gsub! "]}," XmlSimple hash_to_array":{"type":"method","name":"hash_to_array","children":[],"call":["arrayref << ","(pair\n  (send\n    (send\n      (ivar :@options) :[]\n      (str \"keyattr\")) :[]\n    (int 0))\n  (lvar :key)) update ","@options [] [] ","@options [] ","(pair\n  (send\n    (send\n      (send\n        (ivar :@options) :[]\n        (str \"keyattr\")) :[]\n      (lvar :parent)) :[]\n    (int 0))\n  (lvar :key)) update ","@options [] [] [] ","@options [] has_key? ","@options [] instance_of? ","value instance_of? ","hashref each ","@options [] is_a? ","value is_a? "]}," XmlSimple scalar":{"type":"method","name":"scalar","children":[],"call":["value instance_of? ","value is_a? "]}," XmlSimple value_to_xml":{"type":"method","name":"value_to_xml","children":[],"call":["result join ","@ancestors pop "," scalar ! "," scalar "," raise ","ref type ","result << << << << << ","result << << << << ","result << << << ","result << << ","result << "," value_to_xml ","indent + ","@options [] ","value instance_of? "," escape_value ","value to_s ","ref each ","ref instance_of? ","nested empty? ! ","nested empty? ","nested [] sub! ","nested [] ","text_content nil? ! ","text_content nil? ","key == ","nested << ","@options [] nil? ","@options has_key? ","value nil? ","key [] == ","key [] ","key nil? ! ","key nil? ","ref empty? ! ","ref empty? ","ref []= ","@options [] [] ","@options [] has_key? "," hash_to_array ","indent != ","@options [] empty? ! ","@options [] empty? ","ref to_s + ","ref to_s ","(lvar :indent) join ","@ancestors << ","@ancestors member? ","name != ","name nil? ! ","name nil? ","(send\n  (lvar :key) :=~\n  (regexp\n    (str \"^@(.*)\")\n    (regopt))) ! ","key =~ ","key to_s [] == ","key to_s [] ","key to_s ","key != ","value is_a? ","ref is_a? ","@options [] ! "," hash_to_array  type ","  escape_value _to_xml "," value to_s _to_xml "," escape_value  instance_of? ","value to_s  instance_of? "," escape_ escape_value  "," escape_value to_s  "," escape_value  to_s ","value to_s  to_s "," hash_to_array  each "," hash_to_array  instance_of? "," escape_value  nil? ","value to_s  nil? "," hash_to_array  empty? ! "," hash_to_array  empty? "," hash_to_array  []= "," hash_to_array  to_s + "," hash_to_array  to_s "," escape_value  is_a? ","value to_s  is_a? "," hash_to_array  is_a? "]}," XmlSimple get_var":{"type":"method","name":"get_var","children":[],"call":["@_var_values [] ","@_var_values has_key? "]}," XmlSimple set_var":{"type":"method","name":"set_var","children":[],"call":["@_var_values []= "]}," XmlSimple has_mixed_content?":{"type":"method","name":"has_mixed_content?","children":[],"call":["element texts join !~ ","element texts join ","element texts ","element has_elements? ","element has_text? ","element texts join strip empty? ! ","element texts join strip empty? ","element texts join strip "]}," XmlSimple get_attributes":{"type":"method","name":"get_attributes","children":[],"call":["attributes []= ","node attributes each ","node attributes ","@ + ","@options [] ","n to_sym ","@options [] == ","@options has_key? "," kebab_to_snake_case "," kebab_to_snake_case to_sym "]}," XmlSimple force_array?":{"type":"method","name":"force_array?","children":[],"call":["key =~ ","forcearray [] each ","forcearray [] ","forcearray has_key? ","forcearray instance_of? ","@options [] ","@options [] == ","key == ","forcearray is_a? ","@options []  [] each ","@options []  [] ","@options []  has_key? ","@options []  instance_of? ","@options []  is_a? "]}," XmlSimple merge":{"type":"method","name":"merge","children":[],"call":["hash []= "," force_array? ","value instance_of? ","hash [] ","hash [] << ","hash [] instance_of? ","hash has_key? ","key to_s downcase to_sym ","key to_s downcase ","key to_s ","@options [] == ","@options [] ","@options has_key? "," set_var "," get_var ","value gsub! ","@_var_values empty? ","@_var_values nil? "," normalise_space ","conv call ","conv at ","c match ","conv find ","value is_a? ","hash [] is_a? "," kebab_to_snake_case "," normalise_space  instance_of? ","conv call  instance_of? ","hash has_key to_s downcase to_sym ? ","hash has_ kebab_to_snake_case ? ","key to_s downcase to_sym  to_s downcase to_sym "," kebab_to_snake_case  to_s downcase to_sym ","key to_s downcase to_sym  to_s downcase "," kebab_to_snake_case  to_s downcase ","key to_s downcase to_sym  to_s "," kebab_to_snake_case  to_s ","@options has_key to_s downcase to_sym ? ","@options has_ kebab_to_snake_case ? "," normalise_space  gsub! ","conv call  gsub! ","@_var_ normalise_space s empty? ","@_var_conv call s empty? ","@_var_ normalise_space s nil? ","@_var_conv call s nil? ","conv at  call ","@options []  call ","conv at  at ","@options []  at ","conv at  find ","@options []  find "," normalise_space  is_a? ","conv call  is_a? "]}," XmlSimple collapse_content":{"type":"method","name":"collapse_content","children":[],"call":["hash []= ","hash [] [] ","hash [] ","hash each_key ","value has_key? ","value size == ","value size ","value instance_of? ","hash each_value ","@options [] ","value is_a? "]}," XmlSimple fold_array_by_name":{"type":"method","name":"fold_array_by_name","children":[],"call":[" collapse_content ","@options [] ","$stderr puts ","hash [] delete ","hash [] ","flag == ","hash [] []= ","hash [] [] ","hash []= "," normalise_space ","@options [] == ","value instance_of? ","x [] ","x has_key? ","x instance_of? ","array each ","Hash  new ","@options [] [] ","@options [] has_key? ","value is_a? ","x is_a? "," collapse_content  [] delete ","Hash  new  [] delete "," collapse_content  [] ","Hash  new  [] "," collapse_content  [] []= ","Hash  new  [] []= "," collapse_content  [] [] ","Hash  new  [] [] "," collapse_content  []= ","Hash  new  []= "," normalise_space  instance_of? ","x []  instance_of? "," normalise_space  is_a? ","x []  is_a? "]}," XmlSimple fold_array":{"type":"method","name":"fold_array","children":[],"call":[" collapse_content ","@options [] ","hash []= ","x delete "," normalise_space ","@options [] == ","value instance_of? ","x [] ","x has_key? ","@options [] each ","x instance_of? ","array each ","Hash  new ","value is_a? ","x is_a? "," collapse_content  []= ","Hash  new  []= "," normalise_space  instance_of? ","x []  instance_of? "," normalise_space  is_a? ","x []  is_a? "]}," XmlSimple fold_arrays":{"type":"method","name":"fold_arrays","children":[],"call":["hash []= "," fold_array_by_name "," fold_array ","keyattr instance_of? ","value instance_of? ","hash each ","@options [] ","keyattr is_a? ","value is_a? "," kebab_to_snake_case ","@options []  instance_of? "," kebab_to_snake_case attr instance_of? ","@options []  is_a? "," kebab_to_snake_case attr is_a? "]}," XmlSimple collapse_text_node":{"type":"method","name":"collapse_text_node","children":[],"call":[" merge ","@options [] ","@options [] ! ","element has_attributes? ","element has_attributes? ! "," empty "," node_to_text "]}," XmlSimple collapse":{"type":"method","name":"collapse","children":[],"call":["@options [] == ","@options [] ","@options has_key? ","result empty? ","result [] ","result [] instance_of? ","result has_key? ","count == ","result []= ","@options [] [] == ","@options [] [] ","value to_a [] ","value to_a ","value size == ","value size ","value instance_of? ","result each "," fold_arrays "," collapse_text_node ","element has_text? ","content [] ","content size == ","content size ","x to_s ","element texts map ","element texts "," has_mixed_content? "," merge ","child name ","element attributes empty? ","element attributes "," empty "," collapse ","element each_element ","element has_elements? "," normalise_space "," get_attributes ","result [] is_a? ","value is_a? "," kebab_to_snake_case "," raise ","key != "," merge  empty? "," get_attributes  empty? "," merge  [] "," get_attributes  [] "," merge  [] instance_of? "," get_attributes  [] instance_of? "," merge  has_key? "," get_attributes  has_key? "," fold_arrays  == "," merge  []= "," get_attributes  []= "," collapse  to_a [] "," collapse  to_a "," collapse  size == "," collapse  size "," collapse  instance_of? "," merge  each "," get_attributes  each ","content []  [] ","content []  size == ","content []  size "," has_mixed_content [] ? "," merge  [] is_a? "," get_attributes  [] is_a? "," collapse  is_a? "]}," XmlSimple handle_options":{"type":"method","name":"handle_options","children":[],"call":["@options has_key? ","@options [] "," raise ","@options [] instance_of? ! ","@options [] instance_of? ","@options []= ","@options [] []= ","@options [] [] << ","@options [] [] ","@options [] [] instance_of? ","tag instance_of? ","force_list each ","force_list empty? ","value =~ ","@options [] each "," scalar ! "," scalar ","@options [] nil? ","@options has_key? ! ","@options [] =~ ","@options [] == ","@default_options [] ","@default_options has_key? ","known_options each ","@default_options nil? "," normalize_option_names ","KNOWN_OPTIONS  [] ","KNOWN_OPTIONS  has_key? ","@options instance_of? ","Hash  new ","@options [] is_a? ! ","@options [] is_a? ","@options [] [] is_a? ","tag is_a? ","@options is_a? "," normalize_option_names  has_key? "," normalize_option_names  [] "," normalize_option_names  [] instance_of? ! "," normalize_option_names  [] instance_of? "," normalize_option_names  []= "," normalize_option_names  [] []= "," normalize_option_names  [] [] << "," normalize_option_names  [] [] "," normalize_option_names  [] [] instance_of? ","@options []  each ","@options []  empty? "," normalize_option_names  [] each "," normalize_option_names  [] nil? "," normalize_option_names  has_key? ! "," normalize_option_names  [] =~ "," normalize_option_names  [] == ","KNOWN_OPTIONS  []  each "," normalize_option_names  instance_of? "," normalize_option_names  [] is_a? ! "," normalize_option_names  [] is_a? "," normalize_option_names  [] [] is_a? "," normalize_option_names  is_a? "]}," XmlSimple normalize_option_names":{"type":"method","name":"normalize_option_names","children":[],"call":["result []= "," raise ","known_options member? ! ","known_options member? ","lkey gsub! ","key downcase ","options each ","Hash  new ","options nil? ","key to_s downcase gsub ","key to_s downcase ","key to_s ","Hash  new  []= ","key downcase  gsub! ","key to_s downcase gsub  gsub! "]}," XmlSimple xml_out":{"type":"method","name":"xml_out","children":[],"call":["file write ","File  open ","@options [] ","@options [] write ","@options [] kind_of? ","@options has_key? ","@options [] + + ","@options [] + "," value_to_xml ","ref []= ","value to_s "," scalar ! "," scalar ","refsave each ","ref instance_of? ","@options [] == ","@options []= ","keys [] ","ref [] ","keys size == ","keys size ","ref keys "," handle_options ","ref is_a? "," value_to_@options [] + +  "," value_to_ value_to_xml  ","ref []  []= ","ref [] save each ","ref []  instance_of? ","ref keys  [] ","ref []  [] ","ref keys  size == ","ref keys  size ","ref []  keys ","ref ref keys  ","ref []  is_a? "]}," XmlSimple xml_in":{"type":"method","name":"xml_in","children":[],"call":[" put_into_cache "," merge ","@doc root name ","@doc root ","@options [] "," collapse "," raise ","string type "," parse ","string readlines to_s ","string readlines ","string kind_of? "," load_xml_file ","@@cache restore_mem_copy ","@@cache restore_mem_share ","@@cache restore_storable ","@options [] each ","@options has_key? "," find_xml_file ","$stdin readlines to_s ","$stdin readlines ","string == ","string =~ ","string instance_of? ","@options [] unshift ","directory nil? ","File  dirname ","string sub! ","File  basename ","string nil? "," handle_options ","string read ","$stdin read ","File  basename dup ","string is_a? ","string class ","string respond_to? "," parse  root name "," load_xml_file  root name "," parse  root "," load_xml_file  root ","File  basename  type ","File  basename dup  type ","File  basename  readlines to_s ","File  basename dup  readlines to_s ","File  basename  readlines ","File  basename dup  readlines ","File  basename  kind_of? ","File  basename dup  kind_of? ","File  basename  == ","File  basename dup  == ","File  basename  =~ ","File  basename dup  =~ ","File  basename  instance_of? ","File  basename dup  instance_of? ","File  dirname  nil? ","File  basename  sub! ","File  basename dup  sub! ","File  basename  nil? ","File  basename dup  nil? ","File  basename  read ","File  basename dup  read ","File  basename  is_a? ","File  basename dup  is_a? ","File  basename  class ","File  basename dup  class ","File  basename  respond_to? ","File  basename dup  respond_to? "]}," XmlSimple initialize":{"type":"method","name":"initialize","children":[],"call":["Hash  new "," normalize_option_names ","KNOWN_OPTIONS  [] & ","KNOWN_OPTIONS  [] "," raise ","defaults instance_of? ","defaults nil? ","(send\n  (send\n    (const nil :KNOWN_OPTIONS) :[]\n    (str \"in\")) :+\n  (send\n    (const nil :KNOWN_OPTIONS) :[]\n    (str \"out\"))) uniq ","KNOWN_OPTIONS  [] + ","defaults is_a? "]}," XmlSimple Cache get_from_memory_cache":{"type":"method","name":"get_from_memory_cache","children":[],"call":["cache [] [] ","cache [] ","cache [] [] > ","File  mtime to_i ","File  mtime "]}," XmlSimple Cache get_cache_filename":{"type":"method","name":"get_cache_filename","children":[],"call":["filename sub "]}," XmlSimple Cache restore_mem_copy":{"type":"method","name":"restore_mem_copy","children":[],"call":["Marshal  load ","data nil? "," get_from_memory_cache ","Marshal  load  nil? "," get_from_memory_cache  nil? "]}," XmlSimple Cache save_mem_copy":{"type":"method","name":"save_mem_copy","children":[],"call":["@mem_share_cache []= ","Marshal  dump ","Time  now to_i ","Time  now "]}," XmlSimple Cache restore_mem_share":{"type":"method","name":"restore_mem_share","children":[],"call":[" get_from_memory_cache "]}," XmlSimple Cache save_mem_share":{"type":"method","name":"save_mem_share","children":[],"call":["@mem_share_cache []= ","Time  now to_i ","Time  now "]}," XmlSimple Cache restore_storable":{"type":"method","name":"restore_storable","children":[],"call":["Marshal  load ","File  open ","File  mtime to_i > ","File  mtime to_i ","File  mtime ","File  exist? "," get_cache_filename "," get_ get_cache_filename name "]}," XmlSimple Cache save_storable":{"type":"method","name":"save_storable","children":[],"call":["Marshal  dump ","File  open "," get_cache_filename "," get_ get_cache_filename name "]}," XmlSimple Cache initialize":{"type":"method","name":"initialize","children":[],"call":[]}," XmlSimple kebab_to_snake_case":{"type":"method","name":"kebab_to_snake_case","children":[],"call":["key to_sym ","key to_s gsub ","key to_s ","key is_a? ","@options [] ","key to_sym  to_sym ","key to_s gsub  to_sym ","key to_sym  to_s gsub ","key to_s gsub  to_s gsub ","key to_sym  to_s ","key to_s gsub  to_s ","key to_sym  is_a? ","key to_s gsub  is_a? "]}}