{" Sexp pretty_print":{"type":"method","name":"pretty_print","children":[],"call":["q pp ","q seplist "," + "," fuzzy_hash ","q group "]}," Sexp inspect":{"type":"method","name":"inspect","children":[],"call":[" old_inspect sub "," fuzzy_hash "," old_inspect "]}," Sexp each_sexp":{"type":"method","name":"each_sexp","children":[],"call":["Sexp  === "," each "]}," Sexp deep_each":{"type":"method","name":"deep_each","children":[],"call":["sexp deep_each ","block [] "," each_sexp "]}," Sexp all_subhashes":{"type":"method","name":"all_subhashes","children":[],"call":["hashes << ","node fuzzy_hash "," deep_each "]}," Sexp fuzzy_hash":{"type":"method","name":"fuzzy_hash","children":[],"call":[" structure hash "," structure "]}," Sexp compare_to":{"type":"method","name":"compare_to","children":[],"call":["l_sub compare_to ","l_sexp zip each ","l_sexp zip ","(send\n  (lvar :r_lits) :-\n  (lvar :l_lits)) size ","r_lits - ","(send\n  (lvar :l_lits) :&\n  (lvar :r_lits)) size ","l_lits & ","(send\n  (lvar :l_lits) :-\n  (lvar :r_lits)) size ","l_lits - ","Sexp  === ","they partition "," partition "]}," Sexp similarity":{"type":"method","name":"similarity","children":[],"call":["(send\n  (float 2.0) :*\n  (lvar :s)) / ","2.0 * + + ","2.0 * + ","2.0 * "," compare_to "]}," Sexp structure":{"type":"method","name":"structure","children":[],"call":[" uncached_structure "]}," Sexp mass":{"type":"method","name":"mass","children":[],"call":[" structure flatten size "," structure flatten "," structure "]}," Symbol hash":{"type":"method","name":"hash","children":[],"call":[" to_s hash "," to_s "]}," Flay report":{"type":"method","name":"report","children":[],"call":[" puts ","node line ","node file ","nodes each ","Matches found in %p (mass = %d) % ","nodes size * ","node mass ","nodes size ","node first ","nodes first ","nodes first first == ","nodes first first ","(send\n  (send\n    (self) :hashes) :sort_by) each ","(send\n  (send\n    (send\n      (lvar :nodes) :first) :mass) :*\n  (send\n    (lvar :nodes) :size)) -@ ","nodes first mass * ","nodes first mass "," hashes sort_by "," hashes "," prune "," n_way_diff ","r2r process ","s deep_clone ","nodes map ","Ruby2Ruby  new ","(send\n  (str \"A\") :+\n  (lvar :i)) chr ","A + ","nodes each_with_index ","%d) %s code found in %p (mass%s = %d) % ","identical [] "," hashes [] ","(send\n  (lvar :masses) :sort_by) each "," hashes [] first file "," hashes [] first ","m -@ ","masses sort_by ","masses [] ","masses []= ","identical []= ","n == ","nodes [] all? ","nodes [] "," hashes each "," option [] "," option "," identical [] "," identical ","(send\n  (send nil :masses) :sort_by) each "," masses sort_by "," masses "," total ","x line ","x file ","%8.2f: %s % ","(send\n  (send\n    (self) :summary) :sort_by) each ","v -@ "," summary sort_by "," summary ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ","A ord + ","A ord ","(send\n  (lvar :nodes) :sort_by) each_with_index ","nodes sort_by "," analyze ","io puts "," sexp_to_rb "," send "," respond_to? ","File  extname sub ","File  extname ","s file ","item structural_hash ","  %s%s:%d%s % ","loc line ","loc file ","loc fuzzy? ","%s:  % ","item locations each_with_index ","item locations ","%s%s code found in %p (mass%s = %d) % ","item mass ","item bonus ","item name ","item identical? ","%d)  % ","count + ","data each_with_index ","x modified? ","%s code found in %p (mass%s = %d) % ","sorted each "," hashes [] first first to_s "," hashes [] first first "," hashes [] first line ","nodes first  line ","nodes size ode linodes size e ","nodes first  file ","nodes size ode file ","nodes first s each ","nodes ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h ","nodes ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h ","nodes size odes each "," hashes []  each ","Mat(send\n  (str \"A\") :+\n  (lvar :i)) chr hes found in %p (mass = %d) % ","Mat(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr hes found in %p (mass = %d) % ","Matches founodes size d inodes size  %p (mass = %d) % ","nodes first s size * ","nodes size odes size * "," hashes []  size * ","nodes first  mass ","nodes size ode mass ","nodes first s size ","nodes size odes size "," hashes []  size ","nodes first  first ","nodes size ode first ","nodes first s first ","nodes size odes first "," hashes []  first ","nodes first s first first == ","nodes size odes first first == "," hashes []  first first == ","nodes first s first first ","nodes size odes first first "," hashes []  first first ","(send\n  (send\n    (self) :hashes) :sort_by) ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h ","(send\n  (send\n    (self) :hashes) :sort_by) ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h ","(senodes size d\n  (senodes size d\n    (self) :hashes) :sort_by) each ","(send\n  (send\n    (send\n      (lvar :nodes first s) :first) :mass) :*\n  (send\n    (lvar :nodes first s) :size)) -@ ","(senodes size d\n  (senodes size d\n    (senodes size d\n      (lvar :nodes size odes) :first) :mass) :*\n  (senodes size d\n    (lvar :nodes size odes) :size)) -@ ","(send\n  (send\n    (send\n      (lvar : hashes [] ) :first) :mass) :*\n  (send\n    (lvar : hashes [] ) :size)) -@ ","nodes first s first mass * ","nodes size odes first mass * "," hashes []  first mass * ","nodes first s first mass ","nodes size odes first mass "," hashes []  first mass "," prunodes size e "," nodes size _way_diff ","Ruby2Ruby  new  process ","r2r pro(send\n  (str \"A\") :+\n  (lvar :i)) chr ess ","r2r pro(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ess ","s deep_(send\n  (str \"A\") :+\n  (lvar :i)) chr lone ","s deep_(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr lone ","s deep_clonodes size e ","nodes first s map ","nodes size odes map "," hashes []  map ","Ruby2Ruby  nodes size ew ","(send\n  (str \"A\") :+\n  (lvar :i)) (send\n  (str \"A\") :+\n  (lvar :i)) chr hr ","(send\n  (str \"A\") :+\n  (lvar :i)) (send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr hr ","(senodes size d\n  (str \"A\") :+\n  (lvar :i)) chr ","nodes first s each_with_index ","nodes ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h_with_index ","nodes ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h_with_index ","nodes size odes each_with_inodes size dex "," hashes []  each_with_index ","%d) %s (send\n  (str \"A\") :+\n  (lvar :i)) chr ode found in %p (mass%s = %d) % ","%d) %s (send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ode found in %p (mass%s = %d) % ","%d) %s code founodes size d inodes size  %p (mass%s = %d) % ","identi(send\n  (str \"A\") :+\n  (lvar :i)) chr al [] ","identi(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr al [] ","idenodes size tical [] ","(send\n  (lvar :masses) :sort_by) ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h ","(send\n  (lvar :masses) :sort_by) ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h ","(senodes size d\n  (lvar :masses) :sort_by) each ","identi(send\n  (str \"A\") :+\n  (lvar :i)) chr al []= ","identi(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr al []= ","idenodes size tical []= ","nodes size  == ","nodes first s [] all? ","nodes size odes [] all? "," hashes []  [] all? ","nodes first s [] ","nodes size odes [] "," hashes []  [] "," hashes ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h "," hashes ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h "," optionodes size  [] "," optionodes size  "," identi(send\n  (str \"A\") :+\n  (lvar :i)) chr al [] "," identi(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr al [] "," idenodes size tical [] "," identi(send\n  (str \"A\") :+\n  (lvar :i)) chr al "," identi(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr al "," idenodes size tical ","(send\n  (send nil :masses) :sort_by) ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h ","(send\n  (send nil :masses) :sort_by) ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h ","(senodes size d\n  (senodes size d nodes size il :masses) :sort_by) each ","x linodes size e ","(send\n  (send\n    (self) :summary) :sort_by) ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h ","(send\n  (send\n    (self) :summary) :sort_by) ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h ","(senodes size d\n  (senodes size d\n    (self) :summary) :sort_by) each ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) (send\n  (str \"A\") :+\n  (lvar :i)) chr hr ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) (send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr hr ","(senodes size d\n  (senodes size d\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ","(send\n  (lvar :nodes first s) :sort_by) each_with_index ","(send\n  (lvar :nodes) :sort_by) ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h_with_index ","(send\n  (lvar :nodes) :sort_by) ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h_with_index ","(senodes size d\n  (lvar :nodes size odes) :sort_by) each_with_inodes size dex ","(send\n  (lvar : hashes [] ) :sort_by) each_with_index ","nodes first s sort_by ","nodes size odes sort_by "," hashes []  sort_by "," anodes size alyze "," senodes size d "," responodes size d_to? ","File  extnodes size ame sub ","File  extnodes size ame ","item stru(send\n  (str \"A\") :+\n  (lvar :i)) chr tural_hash ","item stru(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr tural_hash ","lo(send\n  (str \"A\") :+\n  (lvar :i)) chr  line ","lo(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr  line ","loc linodes size e ","lo(send\n  (str \"A\") :+\n  (lvar :i)) chr  file ","lo(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr  file ","lo(send\n  (str \"A\") :+\n  (lvar :i)) chr  fuzzy? ","lo(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr  fuzzy? ","item lo(send\n  (str \"A\") :+\n  (lvar :i)) chr ations ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h_with_index ","item lo(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ations ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h_with_index ","item locationodes size s each_with_inodes size dex ","item lo(send\n  (str \"A\") :+\n  (lvar :i)) chr ations ","item lo(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ations ","item locationodes size s ","%s%s (send\n  (str \"A\") :+\n  (lvar :i)) chr ode found in %p (mass%s = %d) % ","%s%s (send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ode found in %p (mass%s = %d) % ","%s%s code founodes size d inodes size  %p (mass%s = %d) % ","item bonodes size us ","item nodes size ame ","item identi(send\n  (str \"A\") :+\n  (lvar :i)) chr al? ","item identi(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr al? ","item idenodes size tical? ","(send\n  (str \"A\") :+\n  (lvar :i)) chr ount + ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ount + ","counodes size t + ","data ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h_with_index ","data ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h_with_index ","data each_with_inodes size dex "," analyze  each_with_index ","%s (send\n  (str \"A\") :+\n  (lvar :i)) chr ode found in %p (mass%s = %d) % ","%s (send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ode found in %p (mass%s = %d) % ","%s code founodes size d inodes size  %p (mass%s = %d) % ","sorted ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h ","sorted ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h "," hashes [] first linodes size e "]}," Flay prune":{"type":"method","name":"prune","children":[],"call":["all_hashes [] "," hashes delete_if "," hashes ","all_hashes []= ","node all_subhashes each ","node all_subhashes ","nodes each "," hashes values each "," hashes values ","nodes size == ","nodes size ","node all_structural_subhashes each ","node all_structural_subhashes "," filter "," option [] "," option "," prune_conservatively "," prune_liberally ","nodes all? "]}," Flay process":{"type":"method","name":"process","children":[],"call":[" hashes [] << "," hashes [] ","node fuzzy_hash "," hashes ","node mass < ","node mass ","Sexp  === ","node any? ","pt deep_each ","Time  now ","RubyParser  new process ","File  read ","RubyParser  new "," warn ","files each "," process_fuzzy_similarities "," process_sexp "," masses [] "," masses "," total ","nodes size "," identical [] "," identical "," masses []= ","nodes first mass * ","nodes first mass ","nodes first "," identical []= ","n == ","nodes [] all? ","nodes [] "," hashes each "," prune "," option [] "," option ","e message strip ","e message "," send "," respond_to? ","ext empty? ","ext nil? ","File  extname sub ","File  extname "," analyze ","pTime  now  deep_each ","RubyParser  new process  deep_each "," process_fuzzy_similariTime  now ies "," Time  now oTime  now al "," idenTime  now ical [] "," idenTime  now ical ","nodes firsTime  now  mass * ","nodes firsTime  now  mass ","nodes firsTime  now  "," idenTime  now ical []= "," opTime  now ion [] "," oRubyParser  new process ion [] "," opTime  now ion "," oRubyParser  new process ion ","e message sTime  now rip "," respond_Time  now o? ","exTime  now  empTime  now y? ","ext emRubyParser  new process y? ","File  extname sub  empty? ","exTime  now  nil? ","File  extname sub  nil? ","File  exTime  now name sub ","File  File  extname sub name sub ","File  exTime  now name ","File  File  extname sub name "]}," Flay initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","Hash  new "," require ","@option [] "," mass_threshold= "," total= "," masses= "," identical= ","Flay  default_options ","Flay  default_options merge ","Flay  default_options merge  [] "]}," Array triangle":{"type":"method","name":"triangle","children":[],"call":[" at ","(erange\n  (send\n    (lvar :i) :+\n    (int 1))\n  (lvar :max)) each ","i + ","(erange\n  (int 0)\n  (lvar :max)) each "," size ","(erange\n  (send\n    (lvar :i) :+\n    (int 1))\n  (lvar : size )) each ","(erange\n  (int 0)\n  (lvar : size )) each "]}," Array intersection":{"type":"method","name":"intersection","children":[],"call":["j + ","intersection << ","m == ","other at ","(erange\n  (lvar :start)\n  (lvar :other_size)) each "," each_with_index ","other length ","iother at tersectioother at  << ","(erange\n  (lvar :j + )\n  (lvar :other_size)) each ","(eraother at ge\n  (lvar :start)\n  (lvar :other_size)) each ","(erange\n  (lvar :start)\n  (lvar :other length )) each "," each_with_iother at dex ","other leother at gth "]}," Flay n_way_diff":{"type":"method","name":"n_way_diff","children":[],"call":["groups flatten join ","groups flatten ","l group ","(send\n  (lvar :lines) :reject) map ","l empty? ","lines reject ","lines first ","collapsed size == ","collapsed size ","lines uniq ","groups map! ","data [] zip ","data [] ","o group= ","s each ","s push ","(str \"\") * ","max - ","s size ","s scan ","s group ","data map! ","(send\n  (lvar :data) :map) max ","s scan size ","data map ","s group= ","(send\n  (str \"A\") :+\n  (lvar :i)) chr ","A + ","data each_with_index ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ","A ord + ","A ord ","(send\n  (lvar :comments) :+\n  (lvar :codes)) flatten join ","(send\n  (lvar :comments) :+\n  (lvar :codes)) flatten ","comments + "," collapse_and_label "," pad_with_empty_strings ","codes << ","comments << ","n == ","subdata [] ","n - ","s !~ ","subdata find_index "," split_and_group each "," split_and_group ","data [] zip  flatten join ","groups scan  flatten join ","data [] zip  flatten ","groups scan  flatten ","(s scan end\n  (lvar :lines scan ) :reject) map ","(send\n  (lvar :lines) :rejes group t) map ","(send\n  (lvar :lines) :reje(send\n  (str \"A\") :+\n  (lvar :i)) chr t) map ","(send\n  (lvar :lines) :reje(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr t) map ","lines scan  reject ","lines rejes group t ","lines reje(send\n  (str \"A\") :+\n  (lvar :i)) chr t ","lines reje(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr t ","lines scan  firs scan t ","lines uniq  size == ","collaps scan ed s scan ize == ","s group ollapsed size == ","(send\n  (str \"A\") :+\n  (lvar :i)) chr ollapsed size == ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ollapsed size == ","lines uniq  size ","collaps scan ed s scan ize ","s group ollapsed size ","(send\n  (str \"A\") :+\n  (lvar :i)) chr ollapsed size ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ollapsed size ","lines scan  uniq ","data [] zip  map! ","groups scan  map! ","s scan  each ","s eas group h ","s ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h ","s ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h ","s scan  pus scan h ","(s scan tr \"\") * ","(send\n  (lvar :data) :map) max  - ","s scan  s scan ize ","s scan  s scan can ","s ss group an ","s s(send\n  (str \"A\") :+\n  (lvar :i)) chr an ","s s(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr an ","s scan  group ","(s scan end\n  (lvar :data) :map) max ","(send\n  (lvar :data) :map) (send\n  (lvar :data) :map) max  ","s scan  s scan can s scan ize ","s ss group an size ","s s(send\n  (str \"A\") :+\n  (lvar :i)) chr an size ","s s(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr an size ","s scan  group= ","(s scan end\n  (s scan tr \"A\") :+\n  (lvar :i)) chr ","(send\n  (str \"A\") :+\n  (lvar :i)) s group hr ","(send\n  (str \"A\") :+\n  (lvar :i)) (send\n  (str \"A\") :+\n  (lvar :i)) chr hr ","(send\n  (str \"A\") :+\n  (lvar :i)) (send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr hr ","data eas group h_with_index ","data ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h_with_index ","data ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h_with_index ","(s scan end\n  (s scan end\n    (s scan tr \"A\") :ord) :+\n  (lvar :i)) chr ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) s group hr ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) (send\n  (str \"A\") :+\n  (lvar :i)) chr hr ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) (send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr hr ","(s scan end\n  (lvar :comments scan ) :+\n  (lvar :codes scan )) flatten join ","(send\n  (lvar :s group omments) :+\n  (lvar :s group odes)) flatten join ","(send\n  (lvar :(send\n  (str \"A\") :+\n  (lvar :i)) chr omments) :+\n  (lvar :(send\n  (str \"A\") :+\n  (lvar :i)) chr odes)) flatten join ","(send\n  (lvar :(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr omments) :+\n  (lvar :(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr odes)) flatten join ","(send\n  (lvar :comments) :+\n  (lvar : collapse_and_label )) flatten join ","(send\n  (lvar : collapse_and_label ) :+\n  (lvar :codes)) flatten join ","(s scan end\n  (lvar :comments scan ) :+\n  (lvar :codes scan )) flatten ","(send\n  (lvar :s group omments) :+\n  (lvar :s group odes)) flatten ","(send\n  (lvar :(send\n  (str \"A\") :+\n  (lvar :i)) chr omments) :+\n  (lvar :(send\n  (str \"A\") :+\n  (lvar :i)) chr odes)) flatten ","(send\n  (lvar :(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr omments) :+\n  (lvar :(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr odes)) flatten ","(send\n  (lvar :comments) :+\n  (lvar : collapse_and_label )) flatten ","(send\n  (lvar : collapse_and_label ) :+\n  (lvar :codes)) flatten ","comments scan  + ","s group omments + ","(send\n  (str \"A\") :+\n  (lvar :i)) chr omments + ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr omments + "," collapse_and_label  + "," collaps scan e_and_label "," s group ollapse_and_label "," (send\n  (str \"A\") :+\n  (lvar :i)) chr ollapse_and_label "," (send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ollapse_and_label "," pad_with_empty_s scan trings scan  ","codes scan  << ","s group odes << ","(send\n  (str \"A\") :+\n  (lvar :i)) chr odes << ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr odes << "," collapse_and_label  << ","comments scan  << ","s group omments << ","(send\n  (str \"A\") :+\n  (lvar :i)) chr omments << ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr omments << ","s scan ubdata [] ","s scan  !~ ","s scan ubdata find_index "," s scan plit_and_group each "," split_and_group eas group h "," split_and_group ea(send\n  (str \"A\") :+\n  (lvar :i)) chr h "," split_and_group ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h "," s scan plit_and_group "]}," Flay process_fuzzy_similarities":{"type":"method","name":"process_fuzzy_similarities","children":[],"call":[" hashes [] push "," hashes [] ","similar first hash ","similar first "," hashes ","similar size > ","similar size "," p ","detected []= ","similar << ","similarity > ","s1 similarity ","intersection size >= ","max * ","intersection size ","(send\n  (lvar :h1) :size) max ","h2 size ","h1 size ","h1 intersection ","detected [] ","all_hashes [] each ","all_hashes [] ","i + ","all_hashes each_with_index ","all_hashes to_a ","all_hashes []= ","(send\n  (send\n    (lvar :node) :grep\n    (const nil :Sexp)) :map) flatten ","s hash ","node grep map ","node grep ","node mass > ","4 * "," mass_threshold ","node mass ","nodes each "," hashes values each "," hashes values ","s1 similarity  > ","s1 s1 similarity  ","h1 intersection  size >= ","(send\n  (lvar :h1) :size) max  * ","h1 intersection  size ","(send\n  (lvar :h1) :size) (send\n  (lvar :h1) :size) max  ","h1 h1 intersection  ","all_hashes to_a  [] each ","all_hashes to_a  [] ","all_hashes to_a  each_with_index ","all_hashes to_a  to_a ","all_hashes to_a  []= "]}," Flay process_sexp":{"type":"method","name":"process_sexp","children":[],"call":[" hashes [] << "," hashes [] ","node fuzzy_hash "," hashes ","node mass < "," mass_threshold ","node mass ","Sexp  === ","node any? ","pt deep_each ","node structural_hash "," process_fuzzy "," option [] "," option ","pattern satisfy? "," option [] any? ","node none? "," filter_sexp deep_each "," filter_sexp "]}," FlayTask define":{"type":"method","name":"define","children":[],"call":[" raise "," threshold ","flay total ","flay total > ","flay report "," verbose ","flay process ","Flay  expand_dirs_to_files "," dirs ","Flay  new "," task "," name "," desc "," dirs join "," require ","Flay  run ","Flay  filter_files ","Flay  new  total ","Flay  run  total ","Flay  new  total > ","Flay  run  total > ","Flay  new  report ","Flay  run  report ","Flay  new  process ","Flay  run  process ","Flay  expand_dirs_to_Flay  filter_files  ","Flay  filter_Flay  filter_files  "]}," FlayTask initialize":{"type":"method","name":"initialize","children":[],"call":[" define ","File  directory? ! ","File  directory? ","@dirs reject! "," block_given? ","Rake  application options trace ","Rake  application options ","Rake  application "]}," Flay process_erb":{"type":"method","name":"process_erb","children":[],"call":["RubyParser  new process ","RubyParser  new ","ERB  new src ","ERB  new ","File  read "," raise "," warn "," option [] "," option ","Erubis  new src ","Erubis  new ","Erubi Engine  new src ","Erubi Engine  new ","Erubi  new src ","Erubi  new ","ERB  new ERB  new src  ","Erubis  new ERB  new src  ","Erubi Engine  new ERB  new src  ","Erubi  new ERB  new src  "]}," Flay process_rb":{"type":"method","name":"process_rb","children":[],"call":["RubyParser  new process ","File  read ","RubyParser  new "," warn ","File  binread "," option [] "," option "]}," Flay load_plugins":{"type":"method","name":"load_plugins","children":[],"call":[]}," Flay expand_dirs_to_files":{"type":"method","name":"expand_dirs_to_files","children":[],"call":[]}," Flay parse_options":{"type":"method","name":"parse_options","children":[],"call":[]}," Flay default_options":{"type":"method","name":"default_options","children":[],"call":[]}," FlayGauntlet score_for":{"type":"method","name":"score_for","children":[],"call":["flay total ","flay process ","Flay  expand_dirs_to_files ","Flay  new ","File  directory? ! ","File  directory? ","(str \"app\") reject ","Flay  run ","Flay  new  total ","Flay  run  total ","Flay  new  process ","Flay  run  process "]}," FlayGauntlet display_report":{"type":"method","name":"display_report","children":[],"call":[" puts ","%3d: %10.2f: %s % ","top each_with_index ","(send\n  (lvar :good_data) :sort_by) first ","flay -@ ","good_data sort_by ","average flay    : %.2f +/- %.2f % ","scores stddev ","scores average ","bad projects    : %d % ","good_data size ","great projects  : %d % ","broken projects : %d % ","good_data values ","good_data []= ","flay == ","flay < ","@data each ","(send\n  (lvar :good_data) :sort_by) first  each_with_index ","good_data values  stddev ","good_data values  average "]}," FlayGauntlet run":{"type":"method","name":"run","children":[],"call":[" dirty= "," data []= "," score_for "," data "," warn "]}," Flay analyze":{"type":"method","name":"analyze","children":[],"call":[" masses [] "," masses "," total ","nodes size "," identical [] "," identical "," masses []= ","nodes first mass * ","nodes first mass ","nodes first "," identical []= ","n == ","nodes [] all? ","nodes [] "," hashes each "," hashes "," prune ","(send\n  (lvar :sorted) :map) compact ","Item  [] ","node first ","Location  [] ","x line ","x file ","x modified? ","(send\n  (lvar :nodes) :sort_by) each_with_index map ","(send\n  (lvar :nodes) :sort_by) each_with_index ","nodes sort_by ","nodes first first == ","nodes first first "," hashes [] ","sorted map "," hashes [] first first to_s "," hashes [] first first "," hashes [] first "," hashes [] first line "," hashes [] first file ","m -@ "," masses sort_by "," update_masses ","node sexp_type ","exp sexp_type to_s ","exp sexp_type ","exp line ","exp file ","nodes size odes size ","nodes first s size "," hashes []  size "," idenodes size tical [] "," idenodes size tical ","nodes size odes first mass * ","nodes first s first mass * "," hashes []  first mass * ","nodes size odes first mass ","nodes first s first mass "," hashes []  first mass ","nodes size odes first ","nodes first s first "," hashes []  first "," idenodes size tical []= ","nodes size  == ","nodes size odes [] all? ","nodes first s [] all? "," hashes []  [] all? ","nodes size odes [] ","nodes first s [] "," hashes []  [] "," prunodes size e ","(senodes size d\n  (lvar :sorted) :map) compact ","nodes size ode first ","nodes first  first ","Locationodes size   [] ","x linodes size e ","(senodes size d\n  (lvar :nodes size odes) :sort_by) each_with_inodes size dex map ","(send\n  (lvar :nodes first s) :sort_by) each_with_index map ","(send\n  (lvar : hashes [] ) :sort_by) each_with_index map ","(senodes size d\n  (lvar :nodes size odes) :sort_by) each_with_inodes size dex ","(send\n  (lvar :nodes first s) :sort_by) each_with_index ","(send\n  (lvar : hashes [] ) :sort_by) each_with_index ","nodes size odes sort_by ","nodes first s sort_by "," hashes []  sort_by ","nodes size odes first first == ","nodes first s first first == "," hashes []  first first == ","nodes size odes first first ","nodes first s first first "," hashes []  first first "," hashes [] first linodes size e ","nodes size ode sexp_type ","nodes first  sexp_type ","node s hashes [] first _type "," hashes [] first  s hashes [] first _type to_s "," hashes [] first  s hashes [] first _type ","exp linodes size e "," hashes [] first  line "," hashes [] first  file "]}," Flay summary":{"type":"method","name":"summary","children":[],"call":["score [] ","sexp file ","sexps each ","mass to_f / ","sexps size ","mass to_f "," hashes [] "," hashes "," masses each "," masses ","Hash  new ","Hash  new  [] "," hashes []  each "," hashes []  size "]}," Sexp all_structural_subhashes":{"type":"method","name":"all_structural_subhashes","children":[],"call":["hashes << ","node structural_hash "," deep_each "]}," Sexp structural_hash":{"type":"method","name":"structural_hash","children":[],"call":[" structure hash "," structure "," pure_ruby_hash "]}," Flay Erubis add_expr_escaped":{"type":"method","name":"add_expr_escaped","children":[],"call":["src << << << ","src << << ","src << ","code =~ "]}," Flay Erubis add_expr_literal":{"type":"method","name":"add_expr_literal","children":[],"call":["src << << << ","src << << ","src << ","code =~ "]}," Array delete_eql":{"type":"method","name":"delete_eql","children":[],"call":["o1 equal? ","other any? "," delete_if "]}," Sexp pure_ruby_hash":{"type":"method","name":"pure_ruby_hash","children":[],"call":["(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) & ","hash + ","hash << ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) & ","hash ^ ","hash >> ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) & ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) & ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) & ","hash + & ","o pure_ruby_hash ","Sexp  === "," each ","hash >> & ","hash << & ","n & "," raise "," sexp inspect "," sexp "," first ","NODE_NAMES  [] "," sexp_type ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) & ) :<<\n      (int 15)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) & ) :<<\n      (int 15)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) & ) :<<\n      (int 15)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) & ) :<<\n      (int 15)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) & ) :<<\n      (int 15)))) & ","(send\n  (lvar :hash + & ) :+\n  (begin\n    (send\n      (lvar :hash + & ) :<<\n      (int 15)))) & ","(seNODE_NAMES  [] d\n  (lvar :hash) :+\n  (begiNODE_NAMES  [] \n    (seNODE_NAMES  [] d\n      (lvar :hash) :<<\n      (iNODE_NAMES  [] t 15)))) & ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) &  + ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) &  + ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) &  + ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) &  + ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) &  + ","hash + &  + ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) &  << ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) &  << ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) &  << ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) &  << ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) &  << ","hash + &  << ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) & ) :^\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) & ) :>>\n      (int 11)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) & ) :^\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) & ) :>>\n      (int 11)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) & ) :^\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) & ) :>>\n      (int 11)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) & ) :^\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) & ) :>>\n      (int 11)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) & ) :^\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) & ) :>>\n      (int 11)))) & ","(send\n  (lvar :hash + & ) :^\n  (begin\n    (send\n      (lvar :hash + & ) :>>\n      (int 11)))) & ","(seNODE_NAMES  [] d\n  (lvar :hash) :^\n  (begiNODE_NAMES  [] \n    (seNODE_NAMES  [] d\n      (lvar :hash) :>>\n      (iNODE_NAMES  [] t 11)))) & ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) &  ^ ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) &  ^ ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) &  ^ ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) &  ^ ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) &  ^ ","hash + &  ^ ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) &  >> ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) &  >> ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) &  >> ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) &  >> ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) &  >> ","hash + &  >> ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) & ) :<<\n      (int 3)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) & ) :<<\n      (int 3)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) & ) :<<\n      (int 3)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) & ) :<<\n      (int 3)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) & ) :<<\n      (int 3)))) & ","(send\n  (lvar :hash + & ) :+\n  (begin\n    (send\n      (lvar :hash + & ) :<<\n      (int 3)))) & ","(seNODE_NAMES  [] d\n  (lvar :hash) :+\n  (begiNODE_NAMES  [] \n    (seNODE_NAMES  [] d\n      (lvar :hash) :<<\n      (iNODE_NAMES  [] t 3)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) & ) :^\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) & ) :>>\n      (int 6)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) & ) :^\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) & ) :>>\n      (int 6)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) & ) :^\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) & ) :>>\n      (int 6)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) & ) :^\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) & ) :>>\n      (int 6)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) & ) :^\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) & ) :>>\n      (int 6)))) & ","(send\n  (lvar :hash + & ) :^\n  (begin\n    (send\n      (lvar :hash + & ) :>>\n      (int 6)))) & ","(seNODE_NAMES  [] d\n  (lvar :hash) :^\n  (begiNODE_NAMES  [] \n    (seNODE_NAMES  [] d\n      (lvar :hash) :>>\n      (iNODE_NAMES  [] t 6)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) & ) :<<\n      (int 10)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) & ) :<<\n      (int 10)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) & ) :<<\n      (int 10)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) & ) :<<\n      (int 10)))) & ","(send\n  (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) & ) :+\n  (begin\n    (send\n      (lvar :(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) & ) :<<\n      (int 10)))) & ","(send\n  (lvar :hash + & ) :+\n  (begin\n    (send\n      (lvar :hash + & ) :<<\n      (int 10)))) & ","(seNODE_NAMES  [] d\n  (lvar :hash) :+\n  (begiNODE_NAMES  [] \n    (seNODE_NAMES  [] d\n      (lvar :hash) :<<\n      (iNODE_NAMES  [] t 10)))) & ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) &  + & ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) &  + & ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) &  + & ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) &  + & ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) &  + & ","hash + &  + & ","o pure_ruby_(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) &  ","o pure_ruby_(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) &  ","o pure_ruby_(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) &  ","o pure_ruby_(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) &  ","o pure_ruby_(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) &  ","o pure_ruby_hash + &  ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) &  >> & ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) &  >> & ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) &  >> & ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) &  >> & ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) &  >> & ","hash + &  >> & ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 15)))) &  << & ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 11)))) &  << & ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 3)))) &  << & ","(send\n  (lvar :hash) :^\n  (begin\n    (send\n      (lvar :hash) :>>\n      (int 6)))) &  << & ","(send\n  (lvar :hash) :+\n  (begin\n    (send\n      (lvar :hash) :<<\n      (int 10)))) &  << & ","hash + &  << & ","NODE_NAMES  []  & "," sexp iNODE_NAMES  [] spect "]}," Sexp split_code":{"type":"method","name":"split_code","children":[],"call":[" split_at "," code_index "," code_ code_index  "]}," Sexp code_index":{"type":"method","name":"code_index","children":[],"call":["(pair\n  (sym :block)\n  (int 0)) [] "," sexp_type "]}," Sexp split_at":{"type":"method","name":"split_at","children":[],"call":[" [] ","n + "]}," Sexp +":{"type":"method","name":"+","children":[],"call":[" dup concat "," dup "]}," Sexp []":{"type":"method","name":"[]","children":[],"call":["s modified= "," modified ","s line= "," line ","s file= "," file ","Sexp  === "]}," Sexp initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["s modified= ","o modified ","s line= ","o line ","s file= ","o file "]}," Flay sexp_to_rb":{"type":"method","name":"sexp_to_rb","children":[],"call":["@r2r process ","sexp deep_clone ","Ruby2Ruby  new "," require "]}," Flay collapse_and_label":{"type":"method","name":"collapse_and_label","children":[],"call":["l group ","(send\n  (lvar :lines) :reject) map ","l empty? ","lines reject ","lines first ","lines uniq size == ","lines uniq size ","lines uniq ","ary [] zip map ","ary [] zip ","ary [] "]}," Flay pad_with_empty_strings":{"type":"method","name":"pad_with_empty_strings","children":[],"call":["a + ","(str \"\") * ","max - ","a size ","ary map ","(send\n  (lvar :ary) :map) max ","s size ","(send\n  (lvar :ary) :map) max  - ","(send\n  (lvar :ary) :map) (send\n  (lvar :ary) :map) max  "]}," Flay split_and_group":{"type":"method","name":"split_and_group","children":[],"call":["s2 group= ","s scan map ","s scan ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr ","A ord + ","A ord ","ary each_with_index map ","ary each_with_index ","s s(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr an map ","s s(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr an ","(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) (send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr hr ","ary ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h_with_index map ","ary ea(send\n  (send\n    (str \"A\") :ord) :+\n  (lvar :i)) chr h_with_index "]}," Flay prune_liberally":{"type":"method","name":"prune_liberally","children":[],"call":["v size <= ","v size "," hashes delete_if "," hashes ","v delete_eql ","hashes_to_prune [] "," hashes each ","hashes_to_prune [] << ","subscore > "," masses [] "," masses ","subnode structural_hash ","node deep_each ","node structural_hash ","nodes each "," hashes values each "," hashes values ","h []= ","Hash  new "," update_masses ","all_hashes [] ","all_hashes [] << "," masses []  > "]}," Flay prune_conservatively":{"type":"method","name":"prune_conservatively","children":[],"call":["hashes_to_prune [] "," hashes delete_if "," hashes ","hashes_to_prune []= ","nodes first all_structural_subhashes each ","nodes first all_structural_subhashes ","nodes first "," hashes values each "," hashes values ","all_hashes [] ","all_hashes []= "]}," Flay filter":{"type":"method","name":"filter","children":[],"call":["pattern =~ ","patterns any? ","sexps any? "," hashes delete_if "," hashes ","patterns empty? "]}," Flay process_fuzzy":{"type":"method","name":"process_fuzzy","children":[],"call":[" hashes [] << "," hashes [] ","new_node structural_hash "," hashes ","sub line == ","new_node line ","sub line ","sub file == ","new_node file ","sub file "," hashes [] any? ","new_node mass < "," mass_threshold ","new_node mass ","Sexp  === ","new_node any? ","tmpl + ","code combination each ","code combination ","(send\n  (send\n    (lvar :code) :size) :-\n  (int 1)) downto ","code size - ","code size ","tmpl modified= ","node split_code ","avg_mass > ","node size > ","node size ","node mass / ","node mass ","node has_code? ","tmpl +  structural_hash ","tmpl +  line ","tmpl +  file ","tmpl +  mass < ","tmpl +  mass ","tmpl +  any? ","node mass /  > "]}," Flay update_masses":{"type":"method","name":"update_masses","children":[],"call":[" masses [] "," masses "," total ","nodes size "," identical [] "," identical "," masses []= ","nodes first mass * ","nodes first mass ","nodes first "," hashes each "," hashes "," masses clear "," total= "]}," Flay run":{"type":"method","name":"run","children":[],"call":[]}," Flay filter_sexp":{"type":"method","name":"filter_sexp","children":[],"call":[" filter_sexp ","pattern satisfy? "," option [] any? "," option [] "," option ","Sexp  === ","exp delete_if "]}," Flay Erubi flush_newline_if_pending":{"type":"method","name":"flush_newline_if_pending","children":[],"call":["src << ","\n * ","@newline_pending > "]}," Flay Erubi add_postamble":{"type":"method","name":"add_postamble","children":[],"call":[" flush_newline_if_pending "," src "]}," Flay Erubi add_code":{"type":"method","name":"add_code","children":[],"call":[" flush_newline_if_pending "," src "]}," Flay Erubi add_expression":{"type":"method","name":"add_expression","children":[],"call":[" src << << << "," src << << "," src << "," src ","BLOCK_EXPR  match? ","indicator == "," flush_newline_if_pending "]}," Flay Erubi add_text":{"type":"method","name":"add_text","children":[],"call":[" src << "," src ","text gsub ","\n * ","@newline_pending > ","text == ","text empty? "]}," Flay Erubi initialize":{"type":"method","name":"initialize","children":[],"call":["properties []= "]}," Flay filter_files":{"type":"method","name":"filter_files","children":[],"call":[]}}