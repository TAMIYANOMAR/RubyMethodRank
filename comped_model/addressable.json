{" Addressable URI replace_self":{"type":"method","name":"replace_self","children":[],"call":["uri fragment ","uri query ","uri path ","@specified_port to_s to_i ","@specified_port to_s ","uri instance_variable_get ","uri host ","uri password ","uri user ","uri scheme ","uri port "," instance_variable_set "," instance_variables each "," instance_variables "," remove_instance_variable "," instance_variable_defined? ","var != "," reset_ivs ","uri instance_variable_get  to_s to_i ","uri instance_variable_get  to_s "]}," Addressable URI validate":{"type":"method","name":"validate","children":[],"call":[" raise "," path == "," path "," host == "," host "," scheme != "," scheme "," fragment == "," fragment "," query == "," query "," port == "," port "," password == "," password "," user == "," user "," scheme == "," password != "," user != "," specified_port != "," specified_port "," to_s "," port != "," validation_deferred "," authority != "," authority "," path [] != "," path [] "," path != ","@validation_deferred ! ! ","@validation_deferred ! "," path empty? ! "," path empty? "," host empty? "," ip_based? "," host to_s "," host [] !~ ","Regexp  new "," host [] "," host [] != "," host =~ "," host nil? ! "," host nil? ","Cannot have a path with two leading slashes  + "," authority == "," path [] == ","SLASH  + "]}," Addressable URI normalize_path":{"type":"method","name":"normalize_path","children":[],"call":[]}," Addressable URI IDNA use_libidn?":{"type":"method","name":"use_libidn?","children":[],"call":[]}," Addressable URI IDNA to_unicode":{"type":"method","name":"to_unicode","children":[],"call":[]}," Addressable URI IDNA to_ascii":{"type":"method","name":"to_ascii","children":[],"call":[]}," Addressable URI inspect":{"type":"method","name":"inspect","children":[],"call":[" sprintf "," to_s "," object_id "," class to_s "," class ","URI  to_s "]}," Addressable URI to_h":{"type":"method","name":"to_h","children":[],"call":[" fragment "," query "," path "," specified_port "," host "," password "," user "," scheme "]}," Addressable URI to_s":{"type":"method","name":"to_s","children":[],"call":["uri_string << "," fragment "," fragment != "," query "," query != "," path to_s "," path "," authority "," authority != "," scheme "," scheme != ","uri_string force_encoding ","uri_string respond_to? "," raise "," path =~ "," path empty? ! "," path empty? "," path != "," scheme == ","String  new ","String  new  << ","String  new  force_encoding ","String  new  respond_to? "]}," Addressable URI dup":{"type":"method","name":"dup","children":[],"call":["duplicated_uri instance_variable_set ","(ivar :@specified_port) ! ","Addressable URI  new "," fragment dup "," fragment "," fragment != "," query dup "," query "," query != "," path dup "," path "," path != "," port "," host dup "," host "," host != "," password dup "," password "," password != "," user dup "," user "," user != "," scheme dup "," scheme "," scheme != "," specified_port "," class new "," class ","Addressable URI  new  instance_variable_set "," class new  instance_variable_set "]}," Addressable URI eql?":{"type":"method","name":"eql?","children":[],"call":[" to_s == ","uri to_s "," to_s ","uri kind_of? "," class "]}," Addressable URI ==":{"type":"method","name":"==","children":[],"call":[" normalize to_s == ","uri normalize to_s ","uri normalize "," normalize to_s "," normalize ","uri kind_of? "," class "]}," Addressable URI ===":{"type":"method","name":"===","children":[],"call":[" normalize to_s == "," normalize to_s "," normalize ","URI  parse normalize to_s ","URI  parse normalize ","URI  parse ","uri to_s ","uri normalize to_s ","uri normalize ","uri respond_to? "," Addressable URI  parse normalize to_s "," Addressable URI  parse normalize "," Addressable URI  parse "]}," Addressable URI display_uri":{"type":"method","name":"display_uri","children":[],"call":["display_uri instance_variable_set ","URI IDNA  to_unicode ","display_uri host "," normalize "," Addressable IDNA  to_unicode ","display_uri host= "," normalize  instance_variable_set "," normalize  host "," normalize  host= "]}," Addressable URI normalize!":{"type":"method","name":"normalize!","children":[],"call":[" replace_self "," normalize "]}," Addressable URI normalize":{"type":"method","name":"normalize","children":[],"call":["Addressable URI  parse ","Addressable URI  normalized_encode ","Addressable URI  new "," fragment strip "," fragment "," fragment != "," query strip "," query "," query != ","(str \"http\") include? ","normalized_path == "," class normalize_path "," class ","normalized_path != ","normalized_host != ","normalized_scheme != "," path strip "," path "," path != "," class scheme_mapping [] == "," class scheme_mapping [] "," class scheme_mapping "," port ","URI IDNA  to_ascii "," host strip downcase "," host strip "," host "," host != "," password strip "," password "," password != "," user strip "," user "," user != "," class parse normalize "," class parse "," to_s scan flatten [] "," to_s scan flatten "," to_s scan "," to_s "," to_s =~ ","normalized_scheme == "," scheme strip downcase "," scheme strip "," scheme "," scheme != ","normalized_host [] ","normalized_host [] == ","normalized_password == ","normalized_user == ","normalized_scheme =~ ","normalized_password ! "," normalized_fragment "," normalized_query "," normalized_path "," normalized_authority "," normalized_scheme "," to_s [] "," normalized_scheme == ","URI  parse normalize ","URI  parse "," class new "," class normalize_path  == "," path strip  == "," class normalize_path  != "," path strip  != ","URI IDNA  to_ascii  != "," host strip downcase  != ","normalized_host []  != "," scheme strip downcase  != "," scheme strip downcase  == ","URI IDNA  to_ascii  [] "," host strip downcase  [] ","normalized_host []  [] ","URI IDNA  to_ascii  [] == "," host strip downcase  [] == ","normalized_host []  [] == "," password strip  == "," user strip  == "," scheme strip downcase  =~ "," password strip  ! ","  fragment strip  ","  query strip  ","  class normalize_path  ","  path strip  ","  scheme strip downcase  ","  scheme strip downcase  == "]}," Addressable URI route_to":{"type":"method","name":"route_to","children":[],"call":["uri route_from "," class parse ","uri to_s "," class ","uri kind_of? "," class parse route_from ","URI  parse route_from ","URI  parse "," class parse  route_from "," class parse  to_s "," class parse  kind_of? "]}," Addressable URI route_from":{"type":"method","name":"route_from","children":[],"call":["Addressable URI  new ","segments [] ","segments []= ","normalized_self scheme ","segments [] != ","segments [] == ","normalized_self query == ","uri query ","normalized_self query ","normalized_self path == ","uri path ","normalized_self path ","normalized_self authority == ","uri authority ","normalized_self authority ","normalized_self scheme == ","uri scheme ","normalized_self to_h ","Addressable URI  parse ","normalized_self fragment ","normalized_self == "," raise "," to_s ","uri relative? ","normalized_self relative? "," normalize ","uri normalize "," class parse ","uri to_s "," class ","uri kind_of? ","segments [] gsub! ","Regexp  new ","^ + ","Regexp  escape ","uri path != ","normalized_self to_hash "," class parse normalize ","components [] ","components []= ","components [] != ","components [] gsub! ","URI  parse normalize ","URI  parse ","components [] gsub ","(send\n  (send\n    (send\n      (lvar :uri_splitted_path) :fill\n      (str \"..\")) :+\n    (array\n      (lvar :self_dir))) :+\n  (lvar :self_splitted_path)) join ","uri_splitted_path fill + + ","uri_splitted_path fill + ","uri_splitted_path fill ","uri_splitted_path shift ","self_splitted_path shift ","self_dir == ","uri_splitted_path empty? ! ","uri_splitted_path empty? ","self_splitted_path empty? ! ","self_splitted_path empty? "," split_path ","normalized_self to_h  [] ","normalized_self to_hash  [] ","normalized_self to_h  []= ","normalized_self to_hash  []= "," normalize  scheme ","normalized_self to_h  [] != ","normalized_self to_hash  [] != ","normalized_self to_h  [] == ","normalized_self to_hash  [] == "," normalize  query == ","uri normalize  query "," class parse  query "," class parse normalize  query ","URI  parse normalize  query "," normalize  query "," normalize  path == ","uri normalize  path "," class parse  path "," class parse normalize  path ","URI  parse normalize  path "," normalize  path "," normalize  authority == ","uri normalize  authority "," class parse  authority "," class parse normalize  authority ","URI  parse normalize  authority "," normalize  authority "," normalize  scheme == ","uri normalize  scheme "," class parse  scheme "," class parse normalize  scheme ","URI  parse normalize  scheme "," normalize  to_h "," normalize  fragment "," normalize  == ","uri normalize  relative? "," class parse  relative? "," class parse normalize  relative? ","URI  parse normalize  relative? "," normalize  relative? ","uri normalize  normalize "," class parse  normalize "," class parse normalize  normalize ","URI  parse normalize  normalize ","uri normalize  to_s "," class parse  to_s "," class parse normalize  to_s ","URI  parse normalize  to_s ","uri normalize  kind_of? "," class parse  kind_of? "," class parse normalize  kind_of? ","URI  parse normalize  kind_of? ","normalized_self to_h  [] gsub! ","normalized_self to_hash  [] gsub! ","uri normalize  path != "," class parse  path != "," class parse normalize  path != ","URI  parse normalize  path != "," normalize  to_hash ","normalized_self to_hash  [] gsub ","(send\n  (send\n    (send\n      (lvar :uri normalize _splitted_path) :fill\n      (str \"..\")) :+\n    (array\n      (lvar :self_dir))) :+\n  (lvar :self_splitted_path)) join ","(send\n  (send\n    (send\n      (lvar : class parse _splitted_path) :fill\n      (str \"..\")) :+\n    (array\n      (lvar :self_dir))) :+\n  (lvar :self_splitted_path)) join ","(send\n  (send\n    (send\n      (lvar : class parse normalize _splitted_path) :fill\n      (str \"..\")) :+\n    (array\n      (lvar :self_dir))) :+\n  (lvar :self_splitted_path)) join ","(send\n  (send\n    (send\n      (lvar :URI  parse normalize _splitted_path) :fill\n      (str \"..\")) :+\n    (array\n      (lvar :self_dir))) :+\n  (lvar :self_splitted_path)) join ","(send\n  (send\n    (send\n      (lvar :uri_splitted_path) :fill\n      (str \"..\")) :+\n    (array\n      (lvar :self_splitted_path shift ))) :+\n  (lvar :self_splitted_path)) join ","(send\n  (send\n    (send\n      (lvar : split_path ) :fill\n      (str \"..\")) :+\n    (array\n      (lvar :self_dir))) :+\n  (lvar :self_splitted_path)) join ","(send\n  (send\n    (send\n      (lvar :uri_splitted_path) :fill\n      (str \"..\")) :+\n    (array\n      (lvar :self_dir))) :+\n  (lvar : split_path )) join ","uri normalize _splitted_path fill + + "," class parse _splitted_path fill + + "," class parse normalize _splitted_path fill + + ","URI  parse normalize _splitted_path fill + + "," split_path  fill + + ","uri normalize _splitted_path fill + "," class parse _splitted_path fill + "," class parse normalize _splitted_path fill + ","URI  parse normalize _splitted_path fill + "," split_path  fill + ","uri normalize _splitted_path fill "," class parse _splitted_path fill "," class parse normalize _splitted_path fill ","URI  parse normalize _splitted_path fill "," split_path  fill ","uri normalize _splitted_path shift "," class parse _splitted_path shift "," class parse normalize _splitted_path shift ","URI  parse normalize _splitted_path shift "," split_path  shift ","self_splitted_path shift  == ","uri normalize _splitted_path empty? ! "," class parse _splitted_path empty? ! "," class parse normalize _splitted_path empty? ! ","URI  parse normalize _splitted_path empty? ! "," split_path  empty? ! ","uri normalize _splitted_path empty? "," class parse _splitted_path empty? "," class parse normalize _splitted_path empty? ","URI  parse normalize _splitted_path empty? "," split_path  empty? "]}," Addressable URI merge!":{"type":"method","name":"merge!","children":[],"call":[" replace_self "," merge "]}," Addressable URI merge":{"type":"method","name":"merge","children":[],"call":[" + ","uri validation_deferred= ","uri fragment= "," fragment ","hash [] ","hash has_key? ","uri query= "," query ","uri path= "," path ","uri port= "," port ","uri host= "," host ","hash has_key? ! ","uri password= "," password ","uri user= "," user ","uri userinfo= "," userinfo ","uri authority= "," authority ","uri scheme= "," scheme ","Addressable URI  new "," raise ","(send\n  (send\n    (lvar :hash) :keys) :&\n  (array\n    (sym :user)\n    (sym :password))) any? ","hash keys & ","hash keys ","Cannot specify both an authority and any of the components  + ","(send\n  (send\n    (lvar :hash) :keys) :&\n  (array\n    (sym :userinfo)\n    (sym :user)\n    (sym :password)\n    (sym :host)\n    (sym :port))) any? ","hash to_hash ","hash class ","hash respond_to? ! ","hash respond_to? ","uri defer_validation "," class new "," class ","Addressable URI  new  validation_deferred= "," class new  validation_deferred= ","Addressable URI  new  fragment= "," class new  fragment= ","hash to_hash  [] ","hash to_hash  has_key? ","Addressable URI  new  query= "," class new  query= ","Addressable URI  new  path= "," class new  path= ","Addressable URI  new  port= "," class new  port= ","Addressable URI  new  host= "," class new  host= ","hash to_hash  has_key? ! ","Addressable URI  new  password= "," class new  password= ","Addressable URI  new  user= "," class new  user= ","Addressable URI  new  userinfo= "," class new  userinfo= ","Addressable URI  new  authority= "," class new  authority= ","Addressable URI  new  scheme= "," class new  scheme= ","(send\n  (send\n    (lvar :hash to_hash ) :keys) :&\n  (array\n    (sym :user)\n    (sym :password))) any? ","hash to_hash  keys & ","hash to_hash  keys ","(send\n  (send\n    (lvar :hash to_hash ) :keys) :&\n  (array\n    (sym :userinfo)\n    (sym :user)\n    (sym :password)\n    (sym :host)\n    (sym :port))) any? ","hash to_hash  to_hash to_hash  ","hash to_hash  class ","hash to_hash  respond_to? ! ","hash to_hash  respond_to? ","Addressable URI  new  defer_validation "," class new  defer_validation "]}," Addressable URI +":{"type":"method","name":"+","children":[],"call":["Addressable URI  new ","uri fragment "," scheme "," specified_port "," host "," password "," user ","uri query "," class normalize_path ","base_path + ","uri path "," class ","base_path gsub! "," path dup "," path "," path nil? ","uri path [] == ","uri path [] "," query ","uri query != ","uri path == ","uri specified_port ","uri host ","uri password ","uri user ","uri authority != ","uri authority ","uri scheme ","uri scheme != "," dup ","uri to_s == ","uri to_s ","URI  parse ","uri kind_of? ! ","uri kind_of? "," authority != "," authority ","base_path == ","base_path =~ ","URI  parse  fragment ","URI  parse  query "," class normalize_path  + "," path dup  + ","URI  parse  path "," class normalize_path  gsub! "," path dup  gsub! ","URI  parse  path [] == ","URI  parse  path [] ","URI  parse  query != ","URI  parse  path == ","URI  parse  specified_port ","URI  parse  host ","URI  parse  password ","URI  parse  user ","URI  parse  authority != ","URI  parse  authority ","URI  parse  scheme ","URI  parse  scheme != ","URI  parse  to_s == ","URI  parse  to_s ","URI  parse  kind_of? ! ","URI  parse  kind_of? "," class normalize_path  == "," path dup  == "," class normalize_path  =~ "," path dup  =~ "]}," Addressable URI absolute?":{"type":"method","name":"absolute?","children":[],"call":[" relative? ! "," relative? "]}," Addressable URI relative?":{"type":"method","name":"relative?","children":[],"call":[" scheme nil? "," scheme "]}," Addressable URI ip_based?":{"type":"method","name":"ip_based?","children":[],"call":[" class ip_based_schemes include? "," scheme strip downcase "," scheme strip "," scheme "," class ip_based_schemes "," class "," scheme nil? ","URI  ip_based_schemes include? ","URI  ip_based_schemes "]}," Addressable URI fragment=":{"type":"method","name":"fragment=","children":[],"call":["new_fragment to_str "," validate "," raise "," frozen? ","new_fragment class ","new_fragment respond_to? ! ","new_fragment respond_to? "," remove_composite_values "," remove_instance_variable "]}," Addressable URI fragment":{"type":"method","name":"fragment","children":[],"call":[" instance_variable_defined? "]}," Addressable URI query=":{"type":"method","name":"query=","children":[],"call":["new_query to_str "," raise "," frozen? ","new_query class ","new_query respond_to? ! ","new_query respond_to? "," remove_composite_values "," remove_instance_variable "]}," Addressable URI query":{"type":"method","name":"query","children":[],"call":[" instance_variable_defined? "]}," Addressable URI extname":{"type":"method","name":"extname","children":[],"call":["File  extname "," basename gsub "," basename "," path == "," path "]}," Addressable URI basename":{"type":"method","name":"basename","children":[],"call":["File  basename gsub ","File  basename "," path "," path == ","File  basename sub "]}," Addressable URI path=":{"type":"method","name":"path=","children":[],"call":[" host != "," host ","@path [] != ","@path [] ","@path != ","(or\n  (lvar :new_path)\n  (str \"\")) to_str "," raise "," frozen? ","new_path class ","new_path respond_to? ! ","new_path respond_to? ","@path empty? ! ","@path empty? ","(or\n  (lvar :new_path)\n  (const nil :EMPTYSTR)) to_str ","(or\n  (lvar :new_path)\n  (const nil :EMPTY_STR)) to_str "," remove_composite_values "," remove_instance_variable "," validate ","(or\n  (lvar :new_path)\n  (str \"\")) to_str  [] != ","(or\n  (lvar :new_path)\n  (const nil :EMPTYSTR)) to_str  [] != ","(or\n  (lvar :new_path)\n  (const nil :EMPTY_STR)) to_str  [] != ","(or\n  (lvar :new_path)\n  (str \"\")) to_str  [] ","(or\n  (lvar :new_path)\n  (const nil :EMPTYSTR)) to_str  [] ","(or\n  (lvar :new_path)\n  (const nil :EMPTY_STR)) to_str  [] ","(or\n  (lvar :new_path)\n  (str \"\")) to_str  != ","(or\n  (lvar :new_path)\n  (const nil :EMPTYSTR)) to_str  != ","(or\n  (lvar :new_path)\n  (const nil :EMPTY_STR)) to_str  != ","(or\n  (lvar :new_path)\n  (str \"\")) to_str  empty? ! ","(or\n  (lvar :new_path)\n  (const nil :EMPTYSTR)) to_str  empty? ! ","(or\n  (lvar :new_path)\n  (const nil :EMPTY_STR)) to_str  empty? ! ","(or\n  (lvar :new_path)\n  (str \"\")) to_str  empty? ","(or\n  (lvar :new_path)\n  (const nil :EMPTYSTR)) to_str  empty? ","(or\n  (lvar :new_path)\n  (const nil :EMPTY_STR)) to_str  empty? "]}," Addressable URI path":{"type":"method","name":"path","children":[],"call":[" instance_variable_defined? "]}," Addressable URI specified_port":{"type":"method","name":"specified_port","children":[],"call":["port == ","@specified_port to_s to_i ","@specified_port to_s ","@specified_port to_s to_i  == ","@specified_@specified_port to_s to_i  to_s to_i ","@specified_@specified_port to_s to_i  to_s "]}," Addressable URI port=":{"type":"method","name":"port=","children":[],"call":["new_port to_s to_i ","new_port to_s "," validate ","@port == "," raise ","new_port inspect ","(send\n  (send\n    (lvar :new_port) :to_s) :=~\n  (regexp\n    (str \"^\\\\d+$\")\n    (regopt))) ! ","new_port to_s =~ ","new_port != ","Addressable URI  unencode_component ","new_port to_str ","new_port respond_to? "," frozen? "," remove_composite_values "," remove_instance_variable ","new_port valid_encoding? ! ","new_port valid_encoding? ","Addressable URI  unencode_component  to_s to_i ","Addressable URI  unencode_component  to_s ","new_port to_s to_i  == ","Addressable URI  unencode_component  inspect ","(send\n  (send\n    (lvar :Addressable URI  unencode_component ) :to_s) :=~\n  (regexp\n    (str \"^\\\\d+$\")\n    (regopt))) ! ","Addressable URI  unencode_component  to_s =~ ","Addressable URI  unencode_component  != ","Addressable URI  unencode_component  to_str ","Addressable URI  unencode_component  respond_to? ","Addressable URI  unencode_component  valid_encoding? ! ","Addressable URI  unencode_component  valid_encoding? "]}," Addressable URI port":{"type":"method","name":"port","children":[],"call":["@port to_i "," class scheme_mapping [] "," scheme strip downcase "," scheme strip "," scheme "," class scheme_mapping "," class "," scheme nil? ","@port to_i == "," instance_variable_defined? ","@port to_i  to_i "," class scheme_mapping []  to_i ","@port to_i  to_i == "," class scheme_mapping []  to_i == "]}," Addressable URI scheme_mapping":{"type":"method","name":"scheme_mapping","children":[],"call":[]}," Addressable URI ip_based_schemes":{"type":"method","name":"ip_based_schemes","children":[],"call":[]}," Addressable URI authority=":{"type":"method","name":"authority=","children":[],"call":[" validate "," host= "," user= "," password= ","new_port == ","new_authority scan flatten [] ","new_authority scan flatten ","new_authority scan ","new_authority gsub gsub ","new_authority gsub ","new_userinfo strip scan flatten [] ","new_userinfo strip scan flatten ","new_userinfo strip scan ","new_userinfo strip ","new_userinfo != ","new_authority != "," port= ","new_authority [] ","new_userinfo strip [] ","new_authority to_str "," raise "," frozen? ","new_authority class ","new_authority respond_to? ! ","new_authority respond_to? "," remove_composite_values "," remove_instance_variable ","new_authority sub sub ","new_authority sub ","new_authority scan flatten []  == ","new_authority []  == ","new_authority to_str  scan flatten [] ","new_authority to_str  scan flatten ","new_authority to_str  scan ","new_authority to_str  gsub gsub ","new_authority to_str  gsub ","new_userinfo strip scan flatten [] info strip scan flatten [] ","new_userinfo strip [] info strip scan flatten [] ","new_authority scan flatten []  strip scan flatten [] ","new_authority []  strip scan flatten [] ","new_userinfo strip scan flatten [] info strip scan flatten ","new_userinfo strip [] info strip scan flatten ","new_authority scan flatten []  strip scan flatten ","new_authority []  strip scan flatten ","new_userinfo strip scan flatten [] info strip scan ","new_userinfo strip [] info strip scan ","new_authority scan flatten []  strip scan ","new_authority []  strip scan ","new_userinfo strip scan flatten [] info strip ","new_userinfo strip [] info strip ","new_authority scan flatten []  strip ","new_authority []  strip ","new_userinfo strip scan flatten [] info != ","new_userinfo strip [] info != ","new_authority scan flatten []  != ","new_authority []  != ","new_authority to_str  != ","new_authority to_str  [] ","new_userinfo strip scan flatten [] info strip [] ","new_userinfo strip [] info strip [] ","new_authority scan flatten []  strip [] ","new_authority []  strip [] ","new_authority to_str  to_str ","new_authority to_str  class ","new_authority to_str  respond_to? ! ","new_authority to_str  respond_to? ","new_authority to_str  sub sub ","new_authority to_str  sub "]}," Addressable URI authority":{"type":"method","name":"authority","children":[],"call":["@authority << "," specified_port "," specified_port != "," host "," userinfo "," userinfo != "," host nil? ","@authority nil? ","(ivar :@authority) ! ","authority << "," port "," port != ","String  new ","@String  new  << ","@String  new  nil? ","(ivar :@String  new ) ! ","String  new  << "]}," Addressable URI host=":{"type":"method","name":"host=","children":[],"call":[" validate ","new_host to_str "," raise "," frozen? ","new_host class ","new_host respond_to? ! ","new_host respond_to? ","@host to_s ","@host [] !~ ","Regexp  new ","@host [] ","@host [] != ","@host =~ ","@host != "," remove_composite_values "," remove_instance_variable ","@host nil? ! ","@host nil? ","new_host to_str  to_s ","new_host to_str  [] !~ ","new_host to_str  [] ","new_host to_str  [] != ","new_host to_str  =~ ","new_host to_str  != ","new_host to_str  nil? ! ","new_host to_str  nil? "]}," Addressable URI host":{"type":"method","name":"host","children":[],"call":[" instance_variable_defined? "]}," Addressable URI userinfo=":{"type":"method","name":"userinfo=","children":[],"call":[" validate "," user= "," password= ","new_userinfo to_s strip scan flatten [] ","new_userinfo to_s strip scan flatten ","new_userinfo to_s strip scan ","new_userinfo to_s strip ","new_userinfo to_s ","new_userinfo to_str strip [] ","new_userinfo to_str strip ","new_userinfo to_str "," raise "," frozen? ","new_userinfo class ","new_userinfo respond_to? ! ","new_userinfo respond_to? "," remove_composite_values "," remove_instance_variable ","new_userinfo to_s strip scan flatten [] info to_s strip scan flatten [] ","new_userinfo to_s strip scan flatten [] info to_s strip scan flatten ","new_userinfo to_s strip scan flatten [] info to_s strip scan ","new_userinfo to_s strip scan flatten [] info to_s strip ","new_userinfo to_s strip scan flatten [] info to_s ","new_userinfo to_s strip scan flatten [] info to_str strip [] ","new_userinfo to_s strip scan flatten [] info to_str strip ","new_userinfo to_s strip scan flatten [] info to_str ","new_userinfo to_s strip scan flatten [] info class ","new_userinfo to_s strip scan flatten [] info respond_to? ! ","new_userinfo to_s strip scan flatten [] info respond_to? "]}," Addressable URI userinfo":{"type":"method","name":"userinfo","children":[],"call":["current_password != ","current_user != ","current_password == ","current_user == "," password "," user ","@userinfo nil? ","(ivar :@userinfo) ! ","current_password ! ","current_user ! ","@userinfo == "," password  != "," user  != "," password  == "," user  == "," password  ! "," user  ! "]}," Addressable URI password=":{"type":"method","name":"password=","children":[],"call":[" validate ","@user nil? ","@password != ","new_password to_str "," raise "," frozen? ","new_password class ","new_password respond_to? ! ","new_password respond_to? "," remove_composite_values "," remove_instance_variable "," user= "," user nil? "," user ","new_password to_str  != "]}," Addressable URI password":{"type":"method","name":"password","children":[],"call":[" instance_variable_defined? "]}," Addressable URI user=":{"type":"method","name":"user=","children":[],"call":[" validate ","@user nil? ","@password != ","new_user to_str "," raise "," frozen? ","new_user class ","new_user respond_to? ! ","new_user respond_to? "," password != "," password "," remove_composite_values "," remove_instance_variable "," user ","new_user to_str  nil? "]}," Addressable URI user":{"type":"method","name":"user","children":[],"call":[" instance_variable_defined? "]}," Addressable URI scheme=":{"type":"method","name":"scheme=","children":[],"call":["@scheme to_s strip == ","@scheme to_s strip ","@scheme to_s ","new_scheme to_str "," validate "," raise "," frozen? ","new_scheme class ","new_scheme respond_to? ! ","new_scheme respond_to? ","new_scheme !~ ","@scheme to_s strip empty? "," remove_composite_values "," remove_instance_variable ","new_scheme to_str  to_s strip == ","new_scheme to_str  to_s strip ","new_scheme to_str  to_s ","new_scheme to_str  to_str ","new_scheme to_str  class ","new_scheme to_str  respond_to? ! ","new_scheme to_str  respond_to? ","new_scheme to_str  !~ ","new_scheme to_str  to_s strip empty? "]}," Addressable URI scheme":{"type":"method","name":"scheme","children":[],"call":[" instance_variable_defined? "]}," Addressable URI initialize":{"type":"method","name":"initialize","children":[],"call":[" validate ","@port == ","@port to_i "," raise ","@port inspect ","(send\n  (ivar :@port) :=~\n  (regexp\n    (str \"^\\\\d+$\")\n    (regopt))) ! ","@port =~ ","@port != ","@port to_s ","@port kind_of? ","port to_s ","@scheme to_s strip == ","@scheme to_s strip ","@scheme to_s ","port kind_of? ","@host != ","@path [] != ","@path [] ","@path != "," validation_deferred= "," fragment= ","options [] "," query= "," path= "," authority= "," port= "," host= "," userinfo= "," password= "," user= "," scheme= ","(send\n  (send\n    (lvar :options) :keys) :&\n  (array\n    (sym :user)\n    (sym :password))) any? ","options keys & ","options keys ","options has_key? ","Cannot specify both an authority and any of the components  + ","(send\n  (send\n    (lvar :options) :keys) :&\n  (array\n    (sym :userinfo)\n    (sym :user)\n    (sym :password)\n    (sym :host)\n    (sym :port))) any? "," defer_validation "," query_values= "," to_s "," reset_ivs ","@port to_i  == ","@port to_s  == ","port to_s  == ","@port to_i  to_i ","@port to_s  to_i ","port to_s  to_i ","@port to_i  inspect ","@port to_s  inspect ","port to_s  inspect ","(send\n  (ivar :@port to_i ) :=~\n  (regexp\n    (str \"^\\\\d+$\")\n    (regopt))) ! ","(send\n  (ivar :@port to_s ) :=~\n  (regexp\n    (str \"^\\\\d+$\")\n    (regopt))) ! ","(send\n  (ivar :port to_s ) :=~\n  (regexp\n    (str \"^\\\\d+$\")\n    (regopt))) ! ","@port to_i  =~ ","@port to_s  =~ ","port to_s  =~ ","@port to_i  != ","@port to_s  != ","port to_s  != ","@port to_i  to_s ","@port to_s  to_s ","port to_s  to_s ","@port to_i  kind_of? ","@port to_s  kind_of? ","port to_s  kind_of? "]}," Addressable URI extract":{"type":"method","name":"extract","children":[],"call":[]}," Addressable URI normalized_encode":{"type":"method","name":"normalized_encode","children":[],"call":[]}," Addressable URI encode":{"type":"method","name":"encode","children":[],"call":[]}," Addressable URI unencode_segment":{"type":"method","name":"unencode_segment","children":[],"call":[]}," Addressable URI encode_segment":{"type":"method","name":"encode_segment","children":[],"call":["Addressable URI CharacterClasses RESERVED  + "]}," Addressable URI join":{"type":"method","name":"join","children":[],"call":["Addressable URI  new ","uri fragment "," scheme "," port "," host "," password "," user ","uri query "," class normalize_path ","base_path + ","uri path "," class "," authority != "," authority ","base_path == ","base_path gsub! ","base_path =~ "," path dup "," path ","uri path [] == ","uri path [] "," query ","uri query != ","uri path == ","uri port ","uri host ","uri password ","uri user ","uri authority != ","uri authority ","uri scheme ","uri scheme != "," dup ","uri to_s == ","uri to_s "," class parse ","uri to_str ","uri kind_of? ! ","uri kind_of? "," raise ","uri class ","uri respond_to? ! ","uri respond_to? ","URI  normalize_path ","base_path empty? ","uri path empty? ","uri to_s empty? ","URI  parse "," class new ","base_path sub! ","base_path include? "," class parse  fragment ","URI  parse  fragment "," class parse  query ","URI  parse  query "," class normalize_path  + "," path dup  + ","URI  normalize_path  + "," class parse  path ","URI  parse  path "," class normalize_path  == "," path dup  == ","URI  normalize_path  == "," class normalize_path  gsub! "," path dup  gsub! ","URI  normalize_path  gsub! "," class normalize_path  =~ "," path dup  =~ ","URI  normalize_path  =~ "," class parse  path [] == ","URI  parse  path [] == "," class parse  path [] ","URI  parse  path [] "," class parse  query != ","URI  parse  query != "," class parse  path == ","URI  parse  path == "," class parse  port ","URI  parse  port "," class parse  host ","URI  parse  host "," class parse  password ","URI  parse  password "," class parse  user ","URI  parse  user "," class parse  authority != ","URI  parse  authority != "," class parse  authority ","URI  parse  authority "," class parse  scheme ","URI  parse  scheme "," class parse  scheme != ","URI  parse  scheme != "," class parse  to_s == ","URI  parse  to_s == "," class parse  to_s ","URI  parse  to_s "," class parse  to_str ","URI  parse  to_str "," class parse  kind_of? ! ","URI  parse  kind_of? ! "," class parse  kind_of? ","URI  parse  kind_of? "," class parse  class ","URI  parse  class "," class parse  respond_to? ! ","URI  parse  respond_to? ! "," class parse  respond_to? ","URI  parse  respond_to? "," class normalize_path  empty? "," path dup  empty? ","URI  normalize_path  empty? "," class parse  path empty? ","URI  parse  path empty? "," class parse  to_s empty? ","URI  parse  to_s empty? "," class normalize_path  sub! "," path dup  sub! ","URI  normalize_path  sub! "," class normalize_path  include? "," path dup  include? ","URI  normalize_path  include? "]}," Addressable URI expand_template":{"type":"method","name":"expand_template","children":[],"call":[]}," Addressable URI convert_path":{"type":"method","name":"convert_path","children":[],"call":[]}," Addressable URI parse":{"type":"method","name":"parse","children":[],"call":[]}," Addressable URI extract_mapping":{"type":"method","name":"extract_mapping","children":[],"call":["mapping []= ","processor restore ","processor respond_to? ","processor != ","values [] ","variables [] ","variables size ","variables size == ","values size "," to_s scan flatten "," to_s scan "," to_s ","Regexp  new ","processor match ","v scan flatten [] ","v scan flatten ","v scan ","escaped_pattern gsub ","Regexp  escape gsub gsub ","Regexp  escape gsub ","Regexp  escape ","variables each ","pattern scan flatten ","pattern scan "," to_s == ","variables size > ","expansion [] "," send ","extract_method to_sym "," raise ","(send\n  (array\n    (lvar :extract_method)\n    (send\n      (lvar :extract_method) :to_sym)) :&\n  (send nil :private_methods)) empty? ","(lvar :extract_method) & "," private_methods "," parse_template_expansion ","expansion =~ ","unparsed_values [] ","expansions each_with_index ","expansions size == ","unparsed_values size ","expansions size ","expansions size > "," parse_template_pattern ","reserved + ","processor restore s [] ","values [] s [] "," to_s scan flatten  [] ","pattern scan flatten  [] ","pattern scan flatten  size ","pattern scan flatten  size == ","processor restore s size ","values [] s size "," to_s scan flatten  size ","Regexp  escape gsub gsub  gsub ","pattern scan flatten  each ","pattern scan flatten  size > ","unparsed_processor restore s [] ","unparsed_values [] s [] ","unparsed_ to_s scan flatten  [] ","unparsed_processor restore s size ","unparsed_values [] s size ","unparsed_ to_s scan flatten  size "]}," Addressable URI to_hash":{"type":"method","name":"to_hash","children":[],"call":[" fragment "," query "," path "," specified_port "," host "," password "," user "," scheme "," port "]}," Addressable URI heuristic_parse":{"type":"method","name":"heuristic_parse","children":[],"call":[]}," Addressable URI hash":{"type":"method","name":"hash","children":[],"call":[" normalize to_s hash * "," normalize to_s hash "," normalize to_s "," normalize "," to_s hash * "," to_s hash "," to_s "]}," Addressable URI validation_deferred=":{"type":"method","name":"validation_deferred=","children":[],"call":[" validate "," raise "," frozen? "]}," Addressable URI validation_deferred":{"type":"method","name":"validation_deferred","children":[],"call":["@validation_deferred ! ! ","@validation_deferred ! "]}," Addressable URI omit!":{"type":"method","name":"omit!","children":[],"call":[" replace_self "," omit "]}," Addressable URI omit":{"type":"method","name":"omit","children":[],"call":["duplicated_uri validation_deferred= ","duplicated_uri send ","(send\n  (send\n    (lvar :component) :to_s) :+\n  (str \"=\")) to_sym ","component to_s + ","component to_s ","components each "," dup "," raise ","invalid_components inspect ","invalid_components empty? ","components - ","duplicated_uri user= ","duplicated_uri normalized_user ","duplicated_uri defer_validation "," dup  validation_deferred= "," dup  send ","components -  inspect ","components -  empty? "," dup  user= "," dup  normalized_user "," dup  defer_validation "]}," Addressable URI join!":{"type":"method","name":"join!","children":[],"call":[" replace_self "," join "]}," Addressable URI normalized_fragment":{"type":"method","name":"normalized_fragment","children":[],"call":[" fragment strip "," fragment ","Addressable URI  encode_component ","Addressable IDNA  unicode_normalize_kc ","Addressable URI  unencode_component ","Addressable URI  normalize_component ","component == ","@normalized_fragment force_encoding "," force_utf8_encoding_if_needed ","@normalized_fragment == ","Addressable URI  encode_Addressable URI  normalize_component  ","Addressable URI  unencode_Addressable URI  normalize_component  ","Addressable URI  normalize_Addressable URI  normalize_component  ","Addressable URI  normalize_component  == "]}," Addressable URI query_values=":{"type":"method","name":"query_values=","children":[],"call":["(block\n  (send\n    (send\n      (lvar :new_query_values) :to_hash) :inject\n    (array))\n  (args\n    (arg :accumulator)\n    (arg :pair))\n  (begin\n    (masgn\n      (mlhs\n        (lvasgn :key)\n        (lvasgn :value))\n      (lvar :pair))\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :encode_component\n        (lvar :key)\n        (const\n          (const nil :CharacterClasses) :UNRESERVED)))\n    (if\n      (send\n        (lvar :value) :==\n        (true))\n      (send\n        (lvar :accumulator) :<<\n        (dstr\n          (begin\n            (lvar :key))))\n      (begin\n        (lvasgn :value\n          (send\n            (send\n              (self) :class) :encode_component\n            (lvar :value)\n            (const\n              (const nil :CharacterClasses) :UNRESERVED)))\n        (send\n          (lvar :accumulator) :<<\n          (dstr\n            (begin\n              (lvar :key))\n            (str \"=\")\n            (begin\n              (lvar :value)))))))) join ","accumulator << "," class encode_component "," class ","value == ","new_query_values to_hash inject ","new_query_values to_hash ","buffer chop ","buffer << ","e call ","stack << ","value kind_of? ","(block\n  (send\n    (lvar :hash) :sort_by)\n  (args\n    (arg :key))\n  (send\n    (lvar :key) :to_s)) each ","key to_s ","hash sort_by ","stack each ","accu []= ","accu size to_s ","accu size ","value inject ","new_query_values each ","component to_s ","component kind_of? "," lambda "," raise ","new_query_values class ","new_query_values respond_to? ! ","new_query_values respond_to? "," frozen? "," query= ","new_query_values sort! ","key kind_of? ","new_query_values map ","new_query_values == ","new_query_values is_a? ! ","new_query_values is_a? ","URI  encode_component ","to_query call ","value each_with_index ","value is_a? ","value each ","value sort! ","value map "," dup ","(block\n  (send\n    (send\n      (lvar :new_query_ class encode_component s) :to_hash) :inject\n    (array))\n  (args\n    (arg :accumulator)\n    (arg :pair))\n  (begin\n    (masgn\n      (mlhs\n        (lvasgn :key)\n        (lvasgn : class encode_component ))\n      (lvar :pair))\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :encode_component\n        (lvar :key)\n        (const\n          (const nil :CharacterClasses) :UNRESERVED)))\n    (if\n      (send\n        (lvar : class encode_component ) :==\n        (true))\n      (send\n        (lvar :accumulator) :<<\n        (dstr\n          (begin\n            (lvar :key))))\n      (begin\n        (lvasgn : class encode_component \n          (send\n            (send\n              (self) :class) :encode_component\n            (lvar : class encode_component )\n            (const\n              (const nil :CharacterClasses) :UNRESERVED)))\n        (send\n          (lvar :accumulator) :<<\n          (dstr\n            (begin\n              (lvar :key))\n            (str \"=\")\n            (begin\n              (lvar : class encode_component )))))))) join ","(block\n  (send\n    (send\n      (lvar :new_query_values) :to_hash) :inject\n    (array))\n  (args\n    (arg :accumulator)\n    (arg :pair))\n  (begin\n    (masgn\n      (mlhs\n        (lvasgn : class encode_component )\n        (lvasgn :value))\n      (lvar :pair))\n    (lvasgn : class encode_component \n      (send\n        (send\n          (self) :class) :encode_component\n        (lvar : class encode_component )\n        (const\n          (const nil :CharacterClasses) :UNRESERVED)))\n    (if\n      (send\n        (lvar :value) :==\n        (true))\n      (send\n        (lvar :accumulator) :<<\n        (dstr\n          (begin\n            (lvar : class encode_component ))))\n      (begin\n        (lvasgn :value\n          (send\n            (send\n              (self) :class) :encode_component\n            (lvar :value)\n            (const\n              (const nil :CharacterClasses) :UNRESERVED)))\n        (send\n          (lvar :accumulator) :<<\n          (dstr\n            (begin\n              (lvar : class encode_component ))\n            (str \"=\")\n            (begin\n              (lvar :value)))))))) join ","(block\n  (send\n    (send\n      (lvar :new_query_values) :to_hash) :inject\n    (array))\n  (args\n    (arg :accumulator)\n    (arg :pair))\n  (begin\n    (masgn\n      (mlhs\n        (lvasgn :key to_s )\n        (lvasgn :value))\n      (lvar :pair))\n    (lvasgn :key to_s \n      (send\n        (send\n          (self) :class) :encode_component\n        (lvar :key to_s )\n        (const\n          (const nil :CharacterClasses) :UNRESERVED)))\n    (if\n      (send\n        (lvar :value) :==\n        (true))\n      (send\n        (lvar :accumulator) :<<\n        (dstr\n          (begin\n            (lvar :key to_s ))))\n      (begin\n        (lvasgn :value\n          (send\n            (send\n              (self) :class) :encode_component\n            (lvar :value)\n            (const\n              (const nil :CharacterClasses) :UNRESERVED)))\n        (send\n          (lvar :accumulator) :<<\n          (dstr\n            (begin\n              (lvar :key to_s ))\n            (str \"=\")\n            (begin\n              (lvar :value)))))))) join ","(block\n  (send\n    (send\n      (lvar :new_query_values) :to_hash) :inject\n    (array))\n  (args\n    (arg :accumulator)\n    (arg :pair))\n  (begin\n    (masgn\n      (mlhs\n        (lvasgn :key)\n        (lvasgn :value))\n      (lvar :pair))\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :encode_component to_s \n        (lvar :key)\n        (const\n          (const nil :CharacterClasses) :UNRESERVED)))\n    (if\n      (send\n        (lvar :value) :==\n        (true))\n      (send\n        (lvar :accumulator) :<<\n        (dstr\n          (begin\n            (lvar :key))))\n      (begin\n        (lvasgn :value\n          (send\n            (send\n              (self) :class) :encode_component to_s \n            (lvar :value)\n            (const\n              (const nil :CharacterClasses) :UNRESERVED)))\n        (send\n          (lvar :accumulator) :<<\n          (dstr\n            (begin\n              (lvar :key))\n            (str \"=\")\n            (begin\n              (lvar :value)))))))) join ","(block\n  (send\n    (send\n      (lvar :new_query_values to_hash ) :to_hash) :inject\n    (array))\n  (args\n    (arg :accumulator)\n    (arg :pair))\n  (begin\n    (masgn\n      (mlhs\n        (lvasgn :key)\n        (lvasgn :value))\n      (lvar :pair))\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :encode_component\n        (lvar :key)\n        (const\n          (const nil :CharacterClasses) :UNRESERVED)))\n    (if\n      (send\n        (lvar :value) :==\n        (true))\n      (send\n        (lvar :accumulator) :<<\n        (dstr\n          (begin\n            (lvar :key))))\n      (begin\n        (lvasgn :value\n          (send\n            (send\n              (self) :class) :encode_component\n            (lvar :value)\n            (const\n              (const nil :CharacterClasses) :UNRESERVED)))\n        (send\n          (lvar :accumulator) :<<\n          (dstr\n            (begin\n              (lvar :key))\n            (str \"=\")\n            (begin\n              (lvar :value)))))))) join "," class encode_component to_s  "," class encode_component  == ","new_query_ class encode_component s to_hash inject ","new_query_values to_hash  to_hash inject ","new_query_ class encode_component s to_hash ","new_query_values to_hash  to_hash "," dup  chop "," dup  << "," class encode_component  kind_of? ","(block\n  (send\n    (lvar :hash) :sort_by)\n  (args\n    (arg : class encode_component ))\n  (send\n    (lvar : class encode_component ) :to_s)) each ","(block\n  (send\n    (lvar :hash) :sort_by)\n  (args\n    (arg :key to_s ))\n  (send\n    (lvar :key to_s ) :to_s)) each "," class encode_component  to_s ","key to_s  to_s "," class encode_component  inject ","new_query_ class encode_component s each ","new_query_values to_hash  each ","component to_s  to_s ","component to_s  kind_of? ","new_query_ class encode_component s class ","new_query_values to_hash  class ","new_query_ class encode_component s respond_to? ! ","new_query_values to_hash  respond_to? ! ","new_query_ class encode_component s respond_to? ","new_query_values to_hash  respond_to? ","new_query_ class encode_component s sort! ","new_query_values to_hash  sort! ","key to_s  kind_of? ","new_query_ class encode_component s map ","new_query_values to_hash  map ","new_query_ class encode_component s == ","new_query_values to_hash  == ","new_query_ class encode_component s is_a? ! ","new_query_values to_hash  is_a? ! ","new_query_ class encode_component s is_a? ","new_query_values to_hash  is_a? ","URI  encode_component to_s  "," class encode_component  each_with_index "," class encode_component  is_a? "," class encode_component  each "," class encode_component  sort! "," class encode_component  map "]}," Addressable URI query_values":{"type":"method","name":"query_values","children":[],"call":["current_hash []= ","subkeys last ","current_hash [] << ","current_hash [] ","subkeys [] ","subkeys size - ","subkeys size ","key split ","(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\\\[\\\\]$\")\n    (regopt))) ! ! ","(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\\\[\\\\]$\")\n    (regopt))) ! ","key =~ ","options [] == ","options [] ","accumulator []= "," raise ","key inspect ","accumulator [] "," class unencode_component gsub "," class unencode_component "," class ","value != ","value nil? ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")) :map)\n  (args\n    (arg :pair))\n  (send\n    (lvar :pair) :split\n    (str \"=\"))) inject ","pair split "," query split map "," query split "," query "," query == ","(sym :flat) include? ! ","(sym :flat) include? ","defaults merge ","dehash call ","value kind_of? ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","accu << ","hash sort inject ","hash sort ","hash keys all? ","hash keys ","hash != ","hash []= ","hash each "," lambda ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")) :map)\n  (args\n    (arg :pair))\n  (if\n    (and\n      (lvar :pair)\n      (send\n        (lvar :pair) :!=\n        (str \"\")))\n    (send\n      (lvar :pair) :split\n      (str \"=\")\n      (int -1)) nil)) compact inject ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")) :map)\n  (args\n    (arg :pair))\n  (if\n    (and\n      (lvar :pair)\n      (send\n        (lvar :pair) :!=\n        (str \"\")))\n    (send\n      (lvar :pair) :split\n      (str \"=\")\n      (int -1)) nil)) compact ","pair != ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","value gsub ","accumulator << ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","empty_accumulator dup ","flat_array == ","Invalid notation. Must be one of:  + ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")) :map)\n  (args\n    (arg :pair))\n  (if\n    (and\n      (lvar :pair)\n      (send\n        (lvar :pair) :!=\n        (str \"\")))\n    (send\n      (lvar :pair) :split\n      (str \"=\")\n      (int 2)) nil)) compact inject ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")) :map)\n  (args\n    (arg :pair))\n  (if\n    (and\n      (lvar :pair)\n      (send\n        (lvar :pair) :!=\n        (str \"\")))\n    (send\n      (lvar :pair) :split\n      (str \"=\")\n      (int 2)) nil)) compact ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (const nil :URI) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","URI  unencode_component ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")) :map)\n  (args\n    (arg :pair))\n  (if\n    (and\n      (lvar :pair)\n      (send\n        (send\n          (lvar :pair) :empty?) :!))\n    (send\n      (lvar :pair) :split\n      (str \"=\")\n      (int 2)) nil)) compact inject ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")) :map)\n  (args\n    (arg :pair))\n  (if\n    (and\n      (lvar :pair)\n      (send\n        (send\n          (lvar :pair) :empty?) :!))\n    (send\n      (lvar :pair) :split\n      (str \"=\")\n      (int 2)) nil)) compact ","pair empty? ! ","pair empty? ","accu []= ","pair [] ","return_type == ","pair []= ","pair [] to_str gsub ","pair [] to_str ","pair [] respond_to? ","split_query inject ","return_type != ","Array  == ","(send\n  (send\n    (send\n      (self) :query) :split\n    (str \"&\")) :map) compact ","pair [] to_str tr ","value tr ","(str \"http\") include? "," scheme ","current_hash []  []= ","subkeys [] s last ","key split  last ","sub class unencode_component s last ","subURI  unencode_component s last ","current_hash []  [] << ","current_hash []  [] ","subkeys [] s [] ","key split  [] ","sub class unencode_component s [] ","subURI  unencode_component s [] ","subkeys [] s size - ","key split  size - ","sub class unencode_component s size - ","subURI  unencode_component s size - ","subkeys [] s size ","key split  size ","sub class unencode_component s size ","subURI  unencode_component s size "," class unencode_component  split ","URI  unencode_component  split ","(send\n  (lvar : class unencode_component ) :=~\n  (regexp\n    (str \"\\\\[\\\\]$\")\n    (regopt))) ! ! ","(send\n  (lvar :URI  unencode_component ) :=~\n  (regexp\n    (str \"\\\\[\\\\]$\")\n    (regopt))) ! ! ","(send\n  (lvar : class unencode_component ) :=~\n  (regexp\n    (str \"\\\\[\\\\]$\")\n    (regopt))) ! ","(send\n  (lvar :URI  unencode_component ) :=~\n  (regexp\n    (str \"\\\\[\\\\]$\")\n    (regopt))) ! "," class unencode_component  =~ ","URI  unencode_component  =~ ","defaults merge  [] == ","defaults merge  [] "," class unencode_component  inspect ","URI  unencode_component  inspect "," class unencode_component gsub  != "," class unencode_component  != ","URI  unencode_component  != ","value tr  != ","pair [] to_str  != "," class unencode_component gsub  nil? "," class unencode_component  nil? ","URI  unencode_component  nil? ","value tr  nil? ","pair [] to_str  nil? "," class unencode_component gsub  kind_of? "," class unencode_component  kind_of? ","URI  unencode_component  kind_of? ","value tr  kind_of? ","pair [] to_str  kind_of? ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash [] \n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash [] ) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash [] ) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash [] \n              (send\n                (lvar :current_hash [] ) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash [] ) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash [] ) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash [] ) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash [] ) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys [] s\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys [] s\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys [] s) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkeys [] \n              (send\n                (lvar :subkeys [] s) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkeys [] )) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkeys [] )\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkeys [] )))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys [] s) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys [] s) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys [] s) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys [] s) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :key split \n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :key split \n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :key split ) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :key split ) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :key split ) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :key split ) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :key split ) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :key split ) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component gsub )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :nil?)\n      (lvasgn : class unencode_component gsub \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :!=\n        (true))\n      (lvasgn : class unencode_component gsub \n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar : class unencode_component gsub )) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component gsub )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_ class unencode_component gsub \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_ class unencode_component gsub \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_ class unencode_component gsub )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar : class unencode_component gsub )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar : class unencode_component gsub )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component ) :nil?)\n      (lvasgn : class unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component ) :!=\n        (true))\n      (lvasgn : class unencode_component \n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar : class unencode_component )) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_ class unencode_component \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_ class unencode_component \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_ class unencode_component )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar : class unencode_component )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar : class unencode_component )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :URI  unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar :URI  unencode_component ) :nil?)\n      (lvasgn :URI  unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :URI  unencode_component ) :!=\n        (true))\n      (lvasgn :URI  unencode_component \n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :URI  unencode_component )) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :URI  unencode_component )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_URI  unencode_component \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_URI  unencode_component \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_URI  unencode_component )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :URI  unencode_component )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :URI  unencode_component )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value tr )))\n  (begin\n    (if\n      (send\n        (lvar :value tr ) :nil?)\n      (lvasgn :value tr \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value tr ) :!=\n        (true))\n      (lvasgn :value tr \n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value tr )) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value tr )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value tr \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value tr \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value tr )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value tr )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value tr )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :pair [] to_str )))\n  (begin\n    (if\n      (send\n        (lvar :pair [] to_str ) :nil?)\n      (lvasgn :pair [] to_str \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :pair [] to_str ) :!=\n        (true))\n      (lvasgn :pair [] to_str \n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :pair [] to_str )) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :pair [] to_str )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_pair [] to_str \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_pair [] to_str \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_pair [] to_str )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :pair [] to_str )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :pair [] to_str )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg : class unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn : class unencode_component \n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar : class unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar : class unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar : class unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar : class unencode_component )\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :sub class unencode_component s\n              (send\n                (lvar : class unencode_component ) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar : class unencode_component ) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :sub class unencode_component s\n                (send\n                  (lvar : class unencode_component ) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :sub class unencode_component s) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :sub class unencode_component \n              (send\n                (lvar :sub class unencode_component s) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :sub class unencode_component )) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :sub class unencode_component )\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :sub class unencode_component )))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :sub class unencode_component s) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :sub class unencode_component s) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :sub class unencode_component s) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :sub class unencode_component s) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :URI  unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :URI  unencode_component \n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :URI  unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :URI  unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :URI  unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :URI  unencode_component )\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subURI  unencode_component s\n              (send\n                (lvar :URI  unencode_component ) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :URI  unencode_component ) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subURI  unencode_component s\n                (send\n                  (lvar :URI  unencode_component ) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subURI  unencode_component s) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subURI  unencode_component \n              (send\n                (lvar :subURI  unencode_component s) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subURI  unencode_component )) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subURI  unencode_component )\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subURI  unencode_component )))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subURI  unencode_component s) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subURI  unencode_component s) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subURI  unencode_component s) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subURI  unencode_component s) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (begin\n      (block\n        (send\n          (send\n            (send\n              (self) :query) :split\n            (str \"&\")) :map)\n        (args\n          (arg :pair))\n        (send\n          (lvar :pair) :split\n          (str \"=\")))) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :defaults merge ) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :defaults merge ) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :defaults merge ) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","hash  class unencode_component s all? ","hash URI  unencode_component s all? ","hash  class unencode_component s ","hash URI  unencode_component s ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash [] \n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash [] ) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash [] ) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash [] \n              (send\n                (lvar :current_hash [] ) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash [] ) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash [] ) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash [] ) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash [] ) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys [] s\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys [] s\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys [] s) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkeys [] \n              (send\n                (lvar :subkeys [] s) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkeys [] )) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkeys [] )\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkeys [] )))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys [] s) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys [] s) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys [] s) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys [] s) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :key split \n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :key split \n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :key split ) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :key split ) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :key split ) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :key split ) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :key split ) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :key split ) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component gsub )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :nil?)\n      (lvasgn : class unencode_component gsub \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :!=\n        (true))\n      (lvasgn : class unencode_component gsub \n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar : class unencode_component gsub )) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component gsub )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_ class unencode_component gsub \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_ class unencode_component gsub \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_ class unencode_component gsub )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar : class unencode_component gsub )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar : class unencode_component gsub )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component ) :nil?)\n      (lvasgn : class unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component ) :!=\n        (true))\n      (lvasgn : class unencode_component \n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar : class unencode_component )) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_ class unencode_component \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_ class unencode_component \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_ class unencode_component )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar : class unencode_component )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar : class unencode_component )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :URI  unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar :URI  unencode_component ) :nil?)\n      (lvasgn :URI  unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :URI  unencode_component ) :!=\n        (true))\n      (lvasgn :URI  unencode_component \n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :URI  unencode_component )) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :URI  unencode_component )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_URI  unencode_component \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_URI  unencode_component \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_URI  unencode_component )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :URI  unencode_component )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :URI  unencode_component )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value tr )))\n  (begin\n    (if\n      (send\n        (lvar :value tr ) :nil?)\n      (lvasgn :value tr \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value tr ) :!=\n        (true))\n      (lvasgn :value tr \n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value tr )) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value tr )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value tr \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value tr \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value tr )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value tr )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value tr )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :pair [] to_str )))\n  (begin\n    (if\n      (send\n        (lvar :pair [] to_str ) :nil?)\n      (lvasgn :pair [] to_str \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :pair [] to_str ) :!=\n        (true))\n      (lvasgn :pair [] to_str \n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :pair [] to_str )) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :pair [] to_str )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_pair [] to_str \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_pair [] to_str \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_pair [] to_str )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :pair [] to_str )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :pair [] to_str )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg : class unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn : class unencode_component \n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar : class unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar : class unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar : class unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar : class unencode_component )\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :sub class unencode_component s\n              (send\n                (lvar : class unencode_component ) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar : class unencode_component ) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :sub class unencode_component s\n                (send\n                  (lvar : class unencode_component ) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :sub class unencode_component s) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :sub class unencode_component \n              (send\n                (lvar :sub class unencode_component s) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :sub class unencode_component )) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :sub class unencode_component )\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :sub class unencode_component )))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :sub class unencode_component s) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :sub class unencode_component s) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :sub class unencode_component s) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :sub class unencode_component s) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :URI  unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :URI  unencode_component \n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :URI  unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :URI  unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :URI  unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :URI  unencode_component )\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subURI  unencode_component s\n              (send\n                (lvar :URI  unencode_component ) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :URI  unencode_component ) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subURI  unencode_component s\n                (send\n                  (lvar :URI  unencode_component ) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subURI  unencode_component s) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subURI  unencode_component \n              (send\n                (lvar :subURI  unencode_component s) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subURI  unencode_component )) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subURI  unencode_component )\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subURI  unencode_component )))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subURI  unencode_component s) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subURI  unencode_component s) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subURI  unencode_component s) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subURI  unencode_component s) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (send\n              (self) :class) :unencode_component\n            (lvar :value)) :gsub\n          (regexp\n            (str \"\\\\+\")\n            (regopt))\n          (str \" \"))) nil)\n    (if\n      (send\n        (send\n          (lvar :defaults merge ) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :defaults merge ) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :defaults merge ) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash [] \n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash [] ) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash [] ) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash [] \n              (send\n                (lvar :current_hash [] ) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash [] ) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash [] ) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash [] ) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash [] ) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys [] s\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys [] s\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys [] s) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkeys [] \n              (send\n                (lvar :subkeys [] s) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkeys [] )) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkeys [] )\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkeys [] )))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys [] s) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys [] s) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys [] s) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys [] s) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :key split \n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :key split \n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :key split ) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :key split ) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :key split ) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :key split ) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :key split ) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :key split ) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component gsub )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :nil?)\n      (lvasgn : class unencode_component gsub \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :!=\n        (true))\n      (lvasgn : class unencode_component gsub \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar : class unencode_component gsub ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component gsub )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_ class unencode_component gsub \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_ class unencode_component gsub \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_ class unencode_component gsub )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar : class unencode_component gsub )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar : class unencode_component gsub )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component ) :nil?)\n      (lvasgn : class unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component ) :!=\n        (true))\n      (lvasgn : class unencode_component \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar : class unencode_component ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_ class unencode_component \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_ class unencode_component \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_ class unencode_component )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar : class unencode_component )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar : class unencode_component )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :URI  unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar :URI  unencode_component ) :nil?)\n      (lvasgn :URI  unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :URI  unencode_component ) :!=\n        (true))\n      (lvasgn :URI  unencode_component \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :URI  unencode_component ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :URI  unencode_component )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_URI  unencode_component \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_URI  unencode_component \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_URI  unencode_component )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :URI  unencode_component )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :URI  unencode_component )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value tr )))\n  (begin\n    (if\n      (send\n        (lvar :value tr ) :nil?)\n      (lvasgn :value tr \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value tr ) :!=\n        (true))\n      (lvasgn :value tr \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value tr ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value tr )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value tr \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value tr \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value tr )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value tr )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value tr )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :pair [] to_str )))\n  (begin\n    (if\n      (send\n        (lvar :pair [] to_str ) :nil?)\n      (lvasgn :pair [] to_str \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :pair [] to_str ) :!=\n        (true))\n      (lvasgn :pair [] to_str \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :pair [] to_str ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :pair [] to_str )))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_pair [] to_str \n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_pair [] to_str \n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_pair [] to_str )\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :pair [] to_str )))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :pair [] to_str )))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg : class unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn : class unencode_component \n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar : class unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar : class unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar : class unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar : class unencode_component )\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :sub class unencode_component s\n              (send\n                (lvar : class unencode_component ) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar : class unencode_component ) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :sub class unencode_component s\n                (send\n                  (lvar : class unencode_component ) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :sub class unencode_component s) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :sub class unencode_component \n              (send\n                (lvar :sub class unencode_component s) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :sub class unencode_component )) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :sub class unencode_component )\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :sub class unencode_component )))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :sub class unencode_component s) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :sub class unencode_component s) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :sub class unencode_component s) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :sub class unencode_component s) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :URI  unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :URI  unencode_component \n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :URI  unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :URI  unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :URI  unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :URI  unencode_component )\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :options) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subURI  unencode_component s\n              (send\n                (lvar :URI  unencode_component ) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :URI  unencode_component ) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subURI  unencode_component s\n                (send\n                  (lvar :URI  unencode_component ) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subURI  unencode_component s) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subURI  unencode_component \n              (send\n                (lvar :subURI  unencode_component s) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subURI  unencode_component )) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subURI  unencode_component )\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subURI  unencode_component )))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subURI  unencode_component s) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subURI  unencode_component s) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subURI  unencode_component s) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subURI  unencode_component s) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (hash))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :defaults merge ) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (begin\n        (if\n          (send\n            (send\n              (lvar :defaults merge ) :[]\n              (sym :notation)) :==\n            (sym :dot))\n          (begin\n            (lvasgn :array_value\n              (false))\n            (lvasgn :subkeys\n              (send\n                (lvar :key) :split\n                (str \".\"))))\n          (if\n            (send\n              (send\n                (lvar :defaults merge ) :[]\n                (sym :notation)) :==\n              (sym :subscript))\n            (begin\n              (lvasgn :array_value\n                (send\n                  (send\n                    (begin\n                      (send\n                        (lvar :key) :=~\n                        (regexp\n                          (str \"\\\\[\\\\]$\")\n                          (regopt)))) :!) :!))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (regexp\n                    (str \"[\\\\[\\\\]]+\")\n                    (regopt))))) nil))\n        (lvasgn :current_hash\n          (lvar :accumulator))\n        (for\n          (lvasgn :i)\n          (erange\n            (int 0)\n            (begin\n              (send\n                (send\n                  (lvar :subkeys) :size) :-\n                (int 1))))\n          (begin\n            (lvasgn :subkey\n              (send\n                (lvar :subkeys) :[]\n                (lvar :i)))\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (lvar :subkey)\n                (hash)))\n            (lvasgn :current_hash\n              (send\n                (lvar :current_hash) :[]\n                (lvar :subkey)))))\n        (if\n          (lvar :array_value)\n          (begin\n            (if\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) nil\n              (send\n                (lvar :current_hash) :[]=\n                (send\n                  (lvar :subkeys) :last)\n                (array)))\n            (send\n              (send\n                (lvar :current_hash) :[]\n                (send\n                  (lvar :subkeys) :last)) :<<\n              (lvar :value)))\n          (send\n            (lvar :current_hash) :[]=\n            (send\n              (lvar :subkeys) :last)\n            (lvar :value)))))\n    (lvar :accumulator))) inject "," class unencode_component gsub  gsub "," class unencode_component  gsub ","URI  unencode_component  gsub ","value tr  gsub ","pair [] to_str  gsub ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash [] \n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash [] ) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash [] ) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash [] \n                (send\n                  (lvar :current_hash [] ) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash [] ) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash [] ) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash [] ) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash [] ) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys [] s\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys [] s\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys [] s) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkeys [] \n                (send\n                  (lvar :subkeys [] s) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkeys [] )) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkeys [] )\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkeys [] )))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys [] s) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys [] s) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys [] s) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys [] s) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :key split \n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :key split \n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :key split ) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :key split ) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :key split ) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :key split ) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :key split ) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :key split ) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component gsub )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :nil?)\n      (lvasgn : class unencode_component gsub \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :!=\n        (true))\n      (lvasgn : class unencode_component gsub \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar : class unencode_component gsub ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component gsub )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar : class unencode_component gsub )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_ class unencode_component gsub \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_ class unencode_component gsub \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_ class unencode_component gsub )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar : class unencode_component gsub )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar : class unencode_component gsub ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component ) :nil?)\n      (lvasgn : class unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component ) :!=\n        (true))\n      (lvasgn : class unencode_component \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar : class unencode_component ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar : class unencode_component )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_ class unencode_component \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_ class unencode_component \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_ class unencode_component )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar : class unencode_component )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar : class unencode_component ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :URI  unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar :URI  unencode_component ) :nil?)\n      (lvasgn :URI  unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :URI  unencode_component ) :!=\n        (true))\n      (lvasgn :URI  unencode_component \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :URI  unencode_component ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :URI  unencode_component )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :URI  unencode_component )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_URI  unencode_component \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_URI  unencode_component \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_URI  unencode_component )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :URI  unencode_component )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :URI  unencode_component ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value tr )))\n  (begin\n    (if\n      (send\n        (lvar :value tr ) :nil?)\n      (lvasgn :value tr \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value tr ) :!=\n        (true))\n      (lvasgn :value tr \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value tr ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value tr )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value tr )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value tr \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value tr \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value tr )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value tr )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value tr ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :pair [] to_str )))\n  (begin\n    (if\n      (send\n        (lvar :pair [] to_str ) :nil?)\n      (lvasgn :pair [] to_str \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :pair [] to_str ) :!=\n        (true))\n      (lvasgn :pair [] to_str \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :pair [] to_str ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :pair [] to_str )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :pair [] to_str )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_pair [] to_str \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_pair [] to_str \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_pair [] to_str )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :pair [] to_str )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :pair [] to_str ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg : class unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn : class unencode_component \n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar : class unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar : class unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar : class unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar : class unencode_component )\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar : class unencode_component )\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :sub class unencode_component s\n                (send\n                  (lvar : class unencode_component ) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar : class unencode_component ) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :sub class unencode_component s\n                  (send\n                    (lvar : class unencode_component ) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :sub class unencode_component s) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :sub class unencode_component \n                (send\n                  (lvar :sub class unencode_component s) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :sub class unencode_component )) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :sub class unencode_component )\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :sub class unencode_component )))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :sub class unencode_component s) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :sub class unencode_component s) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :sub class unencode_component s) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :sub class unencode_component s) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :URI  unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :URI  unencode_component \n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :URI  unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :URI  unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :URI  unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :URI  unencode_component )\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :URI  unencode_component )\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subURI  unencode_component s\n                (send\n                  (lvar :URI  unencode_component ) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :URI  unencode_component ) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subURI  unencode_component s\n                  (send\n                    (lvar :URI  unencode_component ) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subURI  unencode_component s) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subURI  unencode_component \n                (send\n                  (lvar :subURI  unencode_component s) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subURI  unencode_component )) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subURI  unencode_component )\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subURI  unencode_component )))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subURI  unencode_component s) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subURI  unencode_component s) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subURI  unencode_component s) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subURI  unencode_component s) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int -1)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :defaults merge ) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :defaults merge ) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :defaults merge ) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :defaults merge ) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash [] \n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash [] ) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash [] ) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash [] \n                (send\n                  (lvar :current_hash [] ) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash [] ) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash [] ) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash [] ) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash [] ) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys [] s\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys [] s\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys [] s) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkeys [] \n                (send\n                  (lvar :subkeys [] s) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkeys [] )) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkeys [] )\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkeys [] )))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys [] s) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys [] s) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys [] s) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys [] s) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :key split \n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :key split \n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :key split ) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :key split ) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :key split ) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :key split ) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :key split ) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :key split ) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component gsub )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :nil?)\n      (lvasgn : class unencode_component gsub \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :!=\n        (true))\n      (lvasgn : class unencode_component gsub \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar : class unencode_component gsub ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component gsub )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar : class unencode_component gsub )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_ class unencode_component gsub \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_ class unencode_component gsub \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_ class unencode_component gsub )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar : class unencode_component gsub )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar : class unencode_component gsub ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component ) :nil?)\n      (lvasgn : class unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component ) :!=\n        (true))\n      (lvasgn : class unencode_component \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar : class unencode_component ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar : class unencode_component )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_ class unencode_component \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_ class unencode_component \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_ class unencode_component )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar : class unencode_component )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar : class unencode_component ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :URI  unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar :URI  unencode_component ) :nil?)\n      (lvasgn :URI  unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :URI  unencode_component ) :!=\n        (true))\n      (lvasgn :URI  unencode_component \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :URI  unencode_component ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :URI  unencode_component )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :URI  unencode_component )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_URI  unencode_component \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_URI  unencode_component \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_URI  unencode_component )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :URI  unencode_component )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :URI  unencode_component ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value tr )))\n  (begin\n    (if\n      (send\n        (lvar :value tr ) :nil?)\n      (lvasgn :value tr \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value tr ) :!=\n        (true))\n      (lvasgn :value tr \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value tr ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value tr )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value tr )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value tr \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value tr \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value tr )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value tr )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value tr ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :pair [] to_str )))\n  (begin\n    (if\n      (send\n        (lvar :pair [] to_str ) :nil?)\n      (lvasgn :pair [] to_str \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :pair [] to_str ) :!=\n        (true))\n      (lvasgn :pair [] to_str \n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :pair [] to_str ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :pair [] to_str )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :pair [] to_str )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_pair [] to_str \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_pair [] to_str \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_pair [] to_str )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :pair [] to_str )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :pair [] to_str ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg : class unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn : class unencode_component \n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar : class unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar : class unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar : class unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar : class unencode_component )\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar : class unencode_component )\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :sub class unencode_component s\n                (send\n                  (lvar : class unencode_component ) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar : class unencode_component ) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :sub class unencode_component s\n                  (send\n                    (lvar : class unencode_component ) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :sub class unencode_component s) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :sub class unencode_component \n                (send\n                  (lvar :sub class unencode_component s) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :sub class unencode_component )) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :sub class unencode_component )\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :sub class unencode_component )))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :sub class unencode_component s) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :sub class unencode_component s) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :sub class unencode_component s) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :sub class unencode_component s) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :URI  unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :URI  unencode_component \n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :URI  unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :URI  unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :URI  unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :URI  unencode_component )\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :URI  unencode_component )\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subURI  unencode_component s\n                (send\n                  (lvar :URI  unencode_component ) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :URI  unencode_component ) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subURI  unencode_component s\n                  (send\n                    (lvar :URI  unencode_component ) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subURI  unencode_component s) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subURI  unencode_component \n                (send\n                  (lvar :subURI  unencode_component s) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subURI  unencode_component )) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subURI  unencode_component )\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subURI  unencode_component )))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subURI  unencode_component s) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subURI  unencode_component s) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subURI  unencode_component s) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subURI  unencode_component s) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (lvar :pair) :!=\n                (str \"\")))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (send\n          (self) :class) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (send\n            (self) :class) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :defaults merge ) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :defaults merge ) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :defaults merge ) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :defaults merge ) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (const nil :URI) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash [] \n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash [] ) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash [] ) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash [] \n                (send\n                  (lvar :current_hash [] ) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash [] ) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash [] ) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash [] ) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash [] ) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (const nil :URI) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys [] s\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys [] s\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys [] s) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkeys [] \n                (send\n                  (lvar :subkeys [] s) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkeys [] )) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkeys [] )\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkeys [] )))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys [] s) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys [] s) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys [] s) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys [] s) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (const nil :URI) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :key split \n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :key split \n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :key split ) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :key split ) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :key split ) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :key split ) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :key split ) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :key split ) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (const nil :URI) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :(send\n  (lvar :key) :=~\n  (regexp\n    (str \"\\[\\]$\")\n    (regopt))) ! ! )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component gsub )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :nil?)\n      (lvasgn : class unencode_component gsub \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (const nil :URI) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component gsub ) :!=\n        (true))\n      (lvasgn : class unencode_component gsub \n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar : class unencode_component gsub ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component gsub )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar : class unencode_component gsub )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_ class unencode_component gsub \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_ class unencode_component gsub \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_ class unencode_component gsub )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar : class unencode_component gsub )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar : class unencode_component gsub ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg : class unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar : class unencode_component ) :nil?)\n      (lvasgn : class unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (const nil :URI) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar : class unencode_component ) :!=\n        (true))\n      (lvasgn : class unencode_component \n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar : class unencode_component ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar : class unencode_component )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar : class unencode_component )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_ class unencode_component \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_ class unencode_component \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_ class unencode_component )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar : class unencode_component )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar : class unencode_component ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :URI  unencode_component )))\n  (begin\n    (if\n      (send\n        (lvar :URI  unencode_component ) :nil?)\n      (lvasgn :URI  unencode_component \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (const nil :URI) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :URI  unencode_component ) :!=\n        (true))\n      (lvasgn :URI  unencode_component \n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar :URI  unencode_component ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :URI  unencode_component )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :URI  unencode_component )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_URI  unencode_component \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_URI  unencode_component \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_URI  unencode_component )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :URI  unencode_component )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :URI  unencode_component ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value tr )))\n  (begin\n    (if\n      (send\n        (lvar :value tr ) :nil?)\n      (lvasgn :value tr \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (const nil :URI) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value tr ) :!=\n        (true))\n      (lvasgn :value tr \n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar :value tr ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value tr )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value tr )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value tr \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value tr \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value tr )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value tr )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value tr ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :pair [] to_str )))\n  (begin\n    (if\n      (send\n        (lvar :pair [] to_str ) :nil?)\n      (lvasgn :pair [] to_str \n        (true)) nil)\n    (lvasgn :key\n      (send\n        (const nil :URI) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :pair [] to_str ) :!=\n        (true))\n      (lvasgn :pair [] to_str \n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar :pair [] to_str ) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :pair [] to_str )))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :pair [] to_str )))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_pair [] to_str \n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_pair [] to_str \n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_pair [] to_str )\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :pair [] to_str )))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :pair [] to_str ))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg : class unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn : class unencode_component \n      (send\n        (const nil :URI) :unencode_component\n        (lvar : class unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar : class unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar : class unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar : class unencode_component )\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar : class unencode_component )\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :sub class unencode_component s\n                (send\n                  (lvar : class unencode_component ) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar : class unencode_component ) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :sub class unencode_component s\n                  (send\n                    (lvar : class unencode_component ) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :sub class unencode_component s) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :sub class unencode_component \n                (send\n                  (lvar :sub class unencode_component s) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :sub class unencode_component )) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :sub class unencode_component )\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :sub class unencode_component )))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :sub class unencode_component s) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :sub class unencode_component s) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :sub class unencode_component s) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :sub class unencode_component s) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :URI  unencode_component )\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :URI  unencode_component \n      (send\n        (const nil :URI) :unencode_component\n        (lvar :URI  unencode_component )))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :options) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :URI  unencode_component ))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :URI  unencode_component ) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :URI  unencode_component )\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :options) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :URI  unencode_component )\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :options) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subURI  unencode_component s\n                (send\n                  (lvar :URI  unencode_component ) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :options) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :URI  unencode_component ) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subURI  unencode_component s\n                  (send\n                    (lvar :URI  unencode_component ) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subURI  unencode_component s) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subURI  unencode_component \n                (send\n                  (lvar :subURI  unencode_component s) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subURI  unencode_component )) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subURI  unencode_component )\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subURI  unencode_component )))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subURI  unencode_component s) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subURI  unencode_component s) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subURI  unencode_component s) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subURI  unencode_component s) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (begin\n        (block\n          (send\n            (send\n              (send\n                (self) :query) :split\n              (str \"&\")) :map)\n          (args\n            (arg :pair))\n          (if\n            (and\n              (lvar :pair)\n              (send\n                (send\n                  (lvar :pair) :empty?) :!))\n            (send\n              (lvar :pair) :split\n              (str \"=\")\n              (int 2)) nil))) :compact) :inject\n    (send\n      (lvar :empty_accumulator) :dup))\n  (args\n    (arg :accumulator)\n    (mlhs\n      (arg :key)\n      (arg :value)))\n  (begin\n    (if\n      (send\n        (lvar :value) :nil?)\n      (lvasgn :value\n        (true)) nil)\n    (lvasgn :key\n      (send\n        (const nil :URI) :unencode_component\n        (lvar :key)))\n    (if\n      (send\n        (lvar :value) :!=\n        (true))\n      (lvasgn :value\n        (send\n          (const nil :URI) :unencode_component\n          (send\n            (lvar :value) :gsub\n            (regexp\n              (str \"\\\\+\")\n              (regopt))\n            (str \" \")))) nil)\n    (if\n      (send\n        (send\n          (lvar :defaults merge ) :[]\n          (sym :notation)) :==\n        (sym :flat))\n      (begin\n        (if\n          (send\n            (lvar :accumulator) :[]\n            (lvar :key))\n          (send nil :raise\n            (const nil :ArgumentError)\n            (dstr\n              (str \"Key was repeated: \")\n              (begin\n                (send\n                  (lvar :key) :inspect)))) nil)\n        (send\n          (lvar :accumulator) :[]=\n          (lvar :key)\n          (lvar :value)))\n      (if\n        (send\n          (send\n            (lvar :defaults merge ) :[]\n            (sym :notation)) :==\n          (sym :flat_array))\n        (send\n          (lvar :accumulator) :<<\n          (array\n            (lvar :key)\n            (lvar :value)))\n        (begin\n          (if\n            (send\n              (send\n                (lvar :defaults merge ) :[]\n                (sym :notation)) :==\n              (sym :dot))\n            (begin\n              (lvasgn :array_value\n                (false))\n              (lvasgn :subkeys\n                (send\n                  (lvar :key) :split\n                  (str \".\"))))\n            (if\n              (send\n                (send\n                  (lvar :defaults merge ) :[]\n                  (sym :notation)) :==\n                (sym :subscript))\n              (begin\n                (lvasgn :array_value\n                  (send\n                    (send\n                      (begin\n                        (send\n                          (lvar :key) :=~\n                          (regexp\n                            (str \"\\\\[\\\\]$\")\n                            (regopt)))) :!) :!))\n                (lvasgn :subkeys\n                  (send\n                    (lvar :key) :split\n                    (regexp\n                      (str \"[\\\\[\\\\]]+\")\n                      (regopt))))) nil))\n          (lvasgn :current_hash\n            (lvar :accumulator))\n          (for\n            (lvasgn :i)\n            (erange\n              (int 0)\n              (begin\n                (send\n                  (send\n                    (lvar :subkeys) :size) :-\n                  (int 1))))\n            (begin\n              (lvasgn :subkey\n                (send\n                  (lvar :subkeys) :[]\n                  (lvar :i)))\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (lvar :subkey)\n                  (hash)))\n              (lvasgn :current_hash\n                (send\n                  (lvar :current_hash) :[]\n                  (lvar :subkey)))))\n          (if\n            (lvar :array_value)\n            (begin\n              (if\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) nil\n                (send\n                  (lvar :current_hash) :[]=\n                  (send\n                    (lvar :subkeys) :last)\n                  (array)))\n              (send\n                (send\n                  (lvar :current_hash) :[]\n                  (send\n                    (lvar :subkeys) :last)) :<<\n                (lvar :value)))\n            (send\n              (lvar :current_hash) :[]=\n              (send\n                (lvar :subkeys) :last)\n              (lvar :value))))))\n    (lvar :accumulator))) inject ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")) :map)\n  (args\n    (arg :pair))\n  (if\n    (and\n      (lvar :pair)\n      (send\n        (send\n          (lvar :pair) :empty?) :!))\n    (send\n      (lvar :pair) :split\n      (str \"=\")\n      (int 2)) nil)) compact  inject ","(send\n  (send\n    (send\n      (self) :query) :split\n    (str \"&\")) :map) compact  inject "," class unencode_component gsub  tr "," class unencode_component  tr ","URI  unencode_component  tr ","value tr  tr ","pair [] to_str  tr "]}," Addressable URI normalized_query":{"type":"method","name":"normalized_query","children":[],"call":[" query strip "," query ","Addressable URI  encode_component ","Addressable IDNA  unicode_normalize_kc ","Addressable URI  unencode_component ","Addressable URI  normalize_component ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")\n      (int -1)) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (send\n      (const\n        (const\n          (const\n            (const nil :Addressable) :URI) :CharacterClasses) :QUERY) :sub\n      (str \"\\\\&\")\n      (str \"\")))) join ","Addressable URI CharacterClasses QUERY  sub "," query split map "," query split ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")\n      (int -1)) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (send\n      (const\n        (const\n          (const\n            (const nil :Addressable) :URI) :CharacterClasses) :QUERY) :sub\n      (str \"\\\\&\")\n      (str \"\"))\n    (str \"+\"))) join ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")\n      (int -1)) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join ","modified_query_class sub ","component == ","(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join ","pairs map ","pairs sort! ","flags include? ","(or\n  (send\n    (self) :query)\n  (str \"\")) split ","modified_query_class sub! sub! ","modified_query_class sub! ","Addressable URI CharacterClasses QUERY  dup ","(send\n  (lvar :pairs) :map) join ","@normalized_query force_encoding ","pairs delete_if ","pairs delete_if uniq! ","(or\n  (send nil :query)\n  (str \"\")) split "," force_utf8_encoding_if_needed ","@normalized_query == ","Addressable URI  encode_(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join  ","Addressable URI  encode_(send\n  (lvar :pairs) :map) join  ","Addressable URI  unencode_(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join  ","Addressable URI  unencode_(send\n  (lvar :pairs) :map) join  ","Addressable URI  normalize_(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join  ","Addressable URI  normalize_(send\n  (lvar :pairs) :map) join  ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")\n      (int -1)) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join \n    (lvar :pair)\n    (send\n      (const\n        (const\n          (const\n            (const nil :Addressable) :URI) :CharacterClasses) :QUERY) :sub\n      (str \"\\\\&\")\n      (str \"\")))) join ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")\n      (int -1)) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_(send\n  (lvar :pairs) :map) join \n    (lvar :pair)\n    (send\n      (const\n        (const\n          (const\n            (const nil :Addressable) :URI) :CharacterClasses) :QUERY) :sub\n      (str \"\\\\&\")\n      (str \"\")))) join ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")\n      (int -1)) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join \n    (lvar :pair)\n    (send\n      (const\n        (const\n          (const\n            (const nil :Addressable) :URI) :CharacterClasses) :QUERY) :sub\n      (str \"\\\\&\")\n      (str \"\"))\n    (str \"+\"))) join ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")\n      (int -1)) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_(send\n  (lvar :pairs) :map) join \n    (lvar :pair)\n    (send\n      (const\n        (const\n          (const\n            (const nil :Addressable) :URI) :CharacterClasses) :QUERY) :sub\n      (str \"\\\\&\")\n      (str \"\"))\n    (str \"+\"))) join ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")\n      (int -1)) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class sub )\n    (str \"+\"))) join ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")\n      (int -1)) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :Addressable URI CharacterClasses QUERY  dup )\n    (str \"+\"))) join ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")\n      (int -1)) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join \n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join ","(block\n  (send\n    (send\n      (send\n        (self) :query) :split\n      (str \"&\")\n      (int -1)) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_(send\n  (lvar :pairs) :map) join \n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join ","modified_query_class sub  sub ","Addressable URI CharacterClasses QUERY  dup  sub ","(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join  == ","(send\n  (lvar :pairs) :map) join  == ","(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class sub )\n    (str \"+\"))) join ","(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :Addressable URI CharacterClasses QUERY  dup )\n    (str \"+\"))) join ","(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join \n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join ","(block\n  (send\n    (lvar :pairs) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_(send\n  (lvar :pairs) :map) join \n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join ","(block\n  (send\n    (lvar :(or\n  (send\n    (self) :query)\n  (str \"\")) split ) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join ","(block\n  (send\n    (lvar :(or\n  (send nil :query)\n  (str \"\")) split ) :map)\n  (args\n    (arg :pair))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :pair)\n    (lvar :modified_query_class)\n    (str \"+\"))) join ","(or\n  (send\n    (self) :query)\n  (str \"\")) split  map ","(or\n  (send nil :query)\n  (str \"\")) split  map ","(or\n  (send\n    (self) :query)\n  (str \"\")) split  sort! ","(or\n  (send nil :query)\n  (str \"\")) split  sort! ","modified_query_class sub  sub! sub! ","Addressable URI CharacterClasses QUERY  dup  sub! sub! ","modified_query_class sub  sub! ","Addressable URI CharacterClasses QUERY  dup  sub! ","(send\n  (lvar :(or\n  (send\n    (self) :query)\n  (str \"\")) split ) :map) join ","(send\n  (lvar :(or\n  (send nil :query)\n  (str \"\")) split ) :map) join ","(or\n  (send\n    (self) :query)\n  (str \"\")) split  delete_if ","(or\n  (send nil :query)\n  (str \"\")) split  delete_if ","(or\n  (send\n    (self) :query)\n  (str \"\")) split  delete_if uniq! ","(or\n  (send nil :query)\n  (str \"\")) split  delete_if uniq! "]}," Addressable URI normalized_path":{"type":"method","name":"normalized_path","children":[],"call":["(str \"http\") include? "," normalized_scheme ","result == "," class normalize_path "," path strip "," path "," class ","Addressable URI  encode_component ","Addressable IDNA  unicode_normalize_kc ","Addressable URI  unencode_component ","(block\n  (send\n    (send\n      (send\n        (send\n          (self) :path) :strip) :split\n      (str \"/\")\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join ","Addressable URI  normalize_component "," path strip split map "," path strip split "," path sub! "," path =~ "," path != "," scheme == "," scheme ","result empty? ","URI  normalize_path ","(block\n  (send\n    (send\n      (send\n        (send\n          (self) :path) :strip) :split\n      (const nil :SLASH)\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join "," path empty? ! "," path empty? ","(block\n  (send\n    (send\n      (send\n        (lvar :path) :strip) :split\n      (const nil :SLASH)\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join ","path strip split map ","path strip split ","path strip ","path sub ","path =~ "," path to_s ","(send\n  (send\n    (send\n      (lvar :path) :strip) :split\n    (const nil :SLASH)\n    (int -1)) :map) join ","@normalized_path force_encoding ","SLASH  dup "," force_utf8_encoding_if_needed "," class normalize_path  == ","Addressable URI  encode_component  == ","(block\n  (send\n    (send\n      (send\n        (send\n          (self) :path) :strip) :split\n      (str \"/\")\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join  == ","URI  normalize_path  == ","(block\n  (send\n    (send\n      (send\n        (send\n          (self) :path) :strip) :split\n      (const nil :SLASH)\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join  == ","(block\n  (send\n    (send\n      (send\n        (lvar :path) :strip) :split\n      (const nil :SLASH)\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join  == ","(send\n  (send\n    (send\n      (lvar :path) :strip) :split\n    (const nil :SLASH)\n    (int -1)) :map) join  == ","SLASH  dup  == "," class normalize_path sub  "," class normalize_ path to_s  "," path sub  strip ","  path to_s  strip "," path sub  ","  path to_s  ","(block\n  (send\n    (send\n      (send\n        (send\n          (self) :path sub ) :strip) :split\n      (str \"/\")\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join ","(block\n  (send\n    (send\n      (send\n        (send\n          (self) : path to_s ) :strip) :split\n      (str \"/\")\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join "," path sub  strip split map ","  path to_s  strip split map "," path sub  strip split ","  path to_s  strip split "," path sub  sub! ","  path to_s  sub! "," path sub  =~ ","  path to_s  =~ "," path sub  != ","  path to_s  != "," class normalize_path  empty? ","Addressable URI  encode_component  empty? ","(block\n  (send\n    (send\n      (send\n        (send\n          (self) :path) :strip) :split\n      (str \"/\")\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join  empty? ","URI  normalize_path  empty? ","(block\n  (send\n    (send\n      (send\n        (send\n          (self) :path) :strip) :split\n      (const nil :SLASH)\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join  empty? ","(block\n  (send\n    (send\n      (send\n        (lvar :path) :strip) :split\n      (const nil :SLASH)\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join  empty? ","(send\n  (send\n    (send\n      (lvar :path) :strip) :split\n    (const nil :SLASH)\n    (int -1)) :map) join  empty? ","SLASH  dup  empty? ","URI  normalize_path sub  ","URI  normalize_ path to_s  ","(block\n  (send\n    (send\n      (send\n        (send\n          (self) :path sub ) :strip) :split\n      (const nil :SLASH)\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join ","(block\n  (send\n    (send\n      (send\n        (send\n          (self) : path to_s ) :strip) :split\n      (const nil :SLASH)\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join "," path sub  empty? ! ","  path to_s  empty? ! "," path sub  empty? ","  path to_s  empty? ","(block\n  (send\n    (send\n      (send\n        (lvar :path sub ) :strip) :split\n      (const nil :SLASH)\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join ","(block\n  (send\n    (send\n      (send\n        (lvar : path to_s ) :strip) :split\n      (const nil :SLASH)\n      (int -1)) :map)\n  (args\n    (arg :segment))\n  (send\n    (const\n      (const nil :Addressable) :URI) :normalize_component\n    (lvar :segment)\n    (const\n      (const\n        (const\n          (const nil :Addressable) :URI) :CharacterClasses) :PCHAR))) join ","path sub  strip split map "," path to_s  strip split map ","path sub  strip split "," path to_s  strip split ","path sub  strip "," path to_s  strip ","path sub  sub "," path to_s  sub ","path sub  =~ "," path to_s  =~ "," path sub  to_s ","  path to_s  to_s ","(send\n  (send\n    (send\n      (lvar :path sub ) :strip) :split\n    (const nil :SLASH)\n    (int -1)) :map) join ","(send\n  (send\n    (send\n      (lvar : path to_s ) :strip) :split\n    (const nil :SLASH)\n    (int -1)) :map) join ","@normalized_path sub  force_encoding ","@normalized_ path to_s  force_encoding "]}," Addressable URI inferred_port":{"type":"method","name":"inferred_port","children":[],"call":[" port to_i "," port "," class port_mapping [] "," scheme strip downcase "," scheme strip "," scheme "," class port_mapping "," class "," port to_i == ","URI  port_mapping [] ","URI  port_mapping "," default_port "]}," Addressable URI normalized_port":{"type":"method","name":"normalized_port","children":[],"call":[" port "," class port_mapping [] == "," class port_mapping [] "," normalized_scheme "," class port_mapping "," class ","URI  port_mapping [] == ","URI  port_mapping [] ","URI  port_mapping ","@normalized_port == "]}," Addressable URI port_mapping":{"type":"method","name":"port_mapping","children":[],"call":[]}," Addressable URI normalized_authority":{"type":"method","name":"normalized_authority","children":[],"call":["authority << "," normalized_port "," normalized_port != "," normalized_host "," normalized_userinfo "," normalized_userinfo != "," normalized_host nil? "," authority ","@normalized_authority force_encoding ","String  new "," force_utf8_encoding_if_needed ","String  new  << "," String  new  ","@normalized_String  new  force_encoding "]}," Addressable URI normalized_host":{"type":"method","name":"normalized_host","children":[],"call":["result [] ","result [] == "," Addressable IDNA  to_ascii "," class unencode_component "," host strip downcase "," host strip "," host "," class "," host strip != "," host != ","URI  unencode_component "," host strip empty? ! "," host strip empty? ","result =~ ","Addressable URI  normalize_component ","@normalized_host force_encoding ","EMPTY_STR  dup ","@normalized_host empty? ! ","@normalized_host empty? "," force_utf8_encoding_if_needed ","result []  [] "," Addressable IDNA  to_ascii  [] ","Addressable URI  normalize_component  [] ","result []  [] == "," Addressable IDNA  to_ascii  [] == ","Addressable URI  normalize_component  [] == ","result []  =~ "," Addressable IDNA  to_ascii  =~ ","Addressable URI  normalize_component  =~ "]}," Addressable URI normalized_userinfo":{"type":"method","name":"normalized_userinfo","children":[],"call":["current_password ! ","current_user ! "," normalized_password "," normalized_user "," userinfo ","@normalized_userinfo force_encoding ","(begin\n  (lvar :current_user)) dup "," force_utf8_encoding_if_needed ","@normalized_userinfo == "," normalized_password  ! "," normalized_user  ! ","(begin\n  (lvar : normalized_user )) dup "]}," Addressable URI normalized_password":{"type":"method","name":"normalized_password","children":[],"call":[" password strip "," password "," user strip == "," user strip "," user "," user ! "," password strip == "," normalized_scheme =~ "," normalized_scheme ","Addressable URI  encode_component ","Addressable IDNA  unicode_normalize_kc ","Addressable URI  unencode_component ","Addressable URI  normalize_component "," user strip empty? "," password strip empty? ","@normalized_password force_encoding "," force_utf8_encoding_if_needed ","@normalized_password == "]}," Addressable URI normalized_user":{"type":"method","name":"normalized_user","children":[],"call":[" user strip "," user "," password strip == "," password strip "," password "," password ! "," user strip == "," normalized_scheme =~ "," normalized_scheme ","Addressable URI  encode_component ","Addressable IDNA  unicode_normalize_kc ","Addressable URI  unencode_component ","Addressable URI  normalize_component "," password strip empty? "," user strip empty? ","@normalized_user force_encoding "," force_utf8_encoding_if_needed ","@normalized_user == "]}," Addressable URI normalized_scheme":{"type":"method","name":"normalized_scheme","children":[],"call":[" scheme strip downcase "," scheme strip "," scheme "," scheme =~ "," scheme != ","Addressable URI  encode_component ","Addressable IDNA  unicode_normalize_kc ","Addressable URI  unencode_component ","Addressable URI  normalize_component ","@normalized_scheme force_encoding ","svn+ssh dup "," force_utf8_encoding_if_needed ","@normalized_scheme == ","Addressable URI  normalize_component  force_encoding ","svn+ssh dup  force_encoding ","Addressable URI  normalize_component  == ","svn+ssh dup  == "]}," Addressable URI unencode":{"type":"method","name":"unencode","children":[],"call":[]}," Addressable URI encode_component":{"type":"method","name":"encode_component","children":[],"call":["CharacterClasses RESERVED  + "]}," Addressable URI extract_list_operator":{"type":"method","name":"extract_list_operator","children":[],"call":["mapping []= ","variables first ","processor restore ","values map! ","processor respond_to? ","value split "," raise ","variables size != ","variables size ","value split  map! "]}," Addressable URI extract_join_operator":{"type":"method","name":"extract_join_operator","children":[],"call":[" raise ","Template operator 'join' variable mismatch:  + ","variables inspect ","parsed_variables inspect ","(send\n  (lvar :parsed_variables) :&\n  (lvar :variables)) != ","parsed_variables & ","mapping []= ","processor restore ","processor respond_to? ","unparsed_value [] ","parsed_variables << ","value split ","unprocessor restore  [] ","ununparsed_value []  [] "]}," Addressable URI extract_suffix_operator":{"type":"method","name":"extract_suffix_operator","children":[],"call":["mapping []= ","variables first ","processor restore ","values map! ","processor respond_to? ","values pop ","values [] == ","values [] ","values << ","value [] == ","value [] ","argument size -@ ","argument size ","value split "," raise ","value [] != ","variables size != ","variables size ","value split  map! ","value split  pop ","value split  [] == ","value split  [] ","value split  << "]}," Addressable URI extract_prefix_operator":{"type":"method","name":"extract_prefix_operator","children":[],"call":["mapping []= ","variables first ","processor restore ","values map! ","processor respond_to? ","values shift ","values [] == ","values [] ","values << ","value [] == ","value [] ","argument size -@ ","argument size ","value split "," raise ","value [] != ","variables size != ","variables size ","value split  map! ","value split  shift ","value split  [] == ","value split  [] ","value split  << "]}," Addressable URI extract_neg_operator":{"type":"method","name":"extract_neg_operator","children":[],"call":[" raise ","value != "]}," Addressable URI extract_opt_operator":{"type":"method","name":"extract_opt_operator","children":[],"call":[" raise ","value != "]}," Addressable URI parse_template_expansion":{"type":"method","name":"parse_template_expansion","children":[],"call":["var gsub ","variables split map ","variables split ","operator gsub! ","capture [] split ","capture [] "]}," Addressable URI parse_template_pattern":{"type":"method","name":"parse_template_pattern","children":[],"call":["Regexp  new ","processor match ","expansion [] ","processor respond_to? ","processor != ","names first ","(str \"prefix\") include? "," parse_template_expansion ","expansion =~ ","expansions << ","escaped_pattern gsub ","escaped gsub ","Regexp  escape gsub ","Regexp  escape ","reserved + ","expansion [] s first "]}," Addressable URI expand_list_operator":{"type":"method","name":"expand_list_operator","children":[],"call":[]}," Addressable URI expand_join_operator":{"type":"method","name":"expand_join_operator","children":[],"call":[]}," Addressable URI expand_suffix_operator":{"type":"method","name":"expand_suffix_operator","children":[],"call":[]}," Addressable URI expand_prefix_operator":{"type":"method","name":"expand_prefix_operator","children":[],"call":[]}," Addressable URI expand_neg_operator":{"type":"method","name":"expand_neg_operator","children":[],"call":[]}," Addressable URI expand_opt_operator":{"type":"method","name":"expand_opt_operator","children":[],"call":[]}," Addressable IDNA punycode_adapt":{"type":"method","name":"punycode_adapt","children":[],"call":[]}," Addressable IDNA punycode_decode_digit":{"type":"method","name":"punycode_decode_digit","children":[],"call":[]}," Addressable IDNA punycode_encode_digit":{"type":"method","name":"punycode_encode_digit","children":[],"call":[]}," Addressable IDNA punycode_delimiter?":{"type":"method","name":"punycode_delimiter?","children":[],"call":[]}," Addressable IDNA punycode_basic?":{"type":"method","name":"punycode_basic?","children":[],"call":[]}," Addressable IDNA punycode_decode":{"type":"method","name":"punycode_decode","children":[],"call":[]}," Addressable IDNA punycode_encode":{"type":"method","name":"punycode_encode","children":[],"call":[]}," Addressable IDNA lookup_unicode_composition":{"type":"method","name":"lookup_unicode_composition","children":[],"call":[]}," Addressable IDNA lookup_unicode_lowercase":{"type":"method","name":"lookup_unicode_lowercase","children":[],"call":[]}," Addressable IDNA lookup_unicode_compatibility":{"type":"method","name":"lookup_unicode_compatibility","children":[],"call":[]}," Addressable IDNA lookup_unicode_combining_class":{"type":"method","name":"lookup_unicode_combining_class","children":[],"call":[]}," Addressable IDNA unicode_decompose_hangul":{"type":"method","name":"unicode_decompose_hangul","children":[],"call":[]}," Addressable IDNA unicode_decompose":{"type":"method","name":"unicode_decompose","children":[],"call":[]}," Addressable IDNA unicode_sort_canonical":{"type":"method","name":"unicode_sort_canonical","children":[],"call":[]}," Addressable IDNA unicode_compose_pair":{"type":"method","name":"unicode_compose_pair","children":[],"call":[]}," Addressable IDNA unicode_compose":{"type":"method","name":"unicode_compose","children":[],"call":[]}," Addressable IDNA unicode_downcase":{"type":"method","name":"unicode_downcase","children":[],"call":[]}," Addressable IDNA unicode_normalize_kc":{"type":"method","name":"unicode_normalize_kc","children":[],"call":["value to_s unicode_normalize ","value to_s "]}," Addressable IDNA to_unicode":{"type":"method","name":"to_unicode","children":[],"call":[]}," Addressable IDNA to_ascii":{"type":"method","name":"to_ascii","children":[],"call":[]}," Addressable URI frozen?":{"type":"method","name":"frozen?","children":[],"call":[" to_s frozen? "," to_s "]}," Addressable URI freeze":{"type":"method","name":"freeze","children":[],"call":[" to_s freeze "," to_s "," hash "," normalized_fragment "," normalized_query "," normalized_path "," normalized_site "," normalized_authority "," normalized_port "," normalized_host "," normalized_userinfo "," normalized_password "," normalized_user "," normalized_scheme "]}," Addressable Template extract_list_operator":{"type":"method","name":"extract_list_operator","children":[],"call":[" raise ","mapping []= ","variables first ","mapping [] == ","mapping [] ","processor restore ","values map! ","processor respond_to? ","values pop ","values [] == ","values [] ","value split ","variables size != ","variables size ","value split  map! ","value split  pop ","value split  [] == ","value split  [] "]}," Addressable Template extract_join_operator":{"type":"method","name":"extract_join_operator","children":[],"call":[" raise ","Template operator 'join' variable mismatch:  + ","variables inspect ","parsed_variables inspect ","(send\n  (lvar :parsed_variables) :&\n  (lvar :variables)) != ","parsed_variables & ","mapping [] != ","mapping [] ","parsed_variables include? ! ","parsed_variables include? ","mapping []= ","mapping [] == ","processor restore ","processor respond_to? ","unparsed_value [] ","parsed_variables << ","value split ","unprocessor restore  [] ","ununparsed_value []  [] "]}," Addressable Template extract_suffix_operator":{"type":"method","name":"extract_suffix_operator","children":[],"call":[" raise ","mapping []= ","variables first ","mapping [] == ","mapping [] ","values first ","values size == ","values size ","processor restore ","values map! ","processor respond_to? ","values pop ","values [] == ","values [] ","value split ","value [] != ","value [] ","argument size -@ ","argument size ","variables size != ","variables size ","values first  first ","value split  first ","values first  size == ","value split  size == ","values first  size ","value split  size ","values first  map! ","value split  map! ","values first  pop ","value split  pop ","values first  [] == ","value split  [] == ","values first  [] ","value split  [] "]}," Addressable Template extract_prefix_operator":{"type":"method","name":"extract_prefix_operator","children":[],"call":[" raise ","mapping []= ","variables first ","mapping [] == ","mapping [] ","values first ","values size == ","values size ","processor restore ","values map! ","processor respond_to? ","values pop ","values [] == ","values [] ","values shift ","values << ","value [] == ","value [] ","argument size -@ ","argument size ","value split ","value [] != ","variables size != ","variables size ","values first  first ","value split  first ","values first  size == ","value split  size == ","values first  size ","value split  size ","values first  map! ","value split  map! ","values first  pop ","value split  pop ","values first  [] == ","value split  [] == ","values first  [] ","value split  [] ","values first  shift ","value split  shift ","values first  << ","value split  << "]}," Addressable Template extract_neg_operator":{"type":"method","name":"extract_neg_operator","children":[],"call":[" raise ","value != "]}," Addressable Template extract_opt_operator":{"type":"method","name":"extract_opt_operator","children":[],"call":[" raise ","value != "]}," Addressable Template parse_template_pattern":{"type":"method","name":"parse_template_pattern","children":[],"call":["Regexp  new ","processor match ","expansion [] ","processor respond_to? ","processor != ","Regexp  escape ","operator == ","names first ","(str \"prefix\") include? "," parse_template_expansion ","expansion =~ ","expansions << ","escaped_pattern gsub ","escaped gsub ","Regexp  escape gsub ","leader + ","(send\n  (send\n    (lvar :varlist) :split\n    (str \",\")) :map) join ","modifier == ","UNRESERVED  gsub ","varspec match ","varlist split map ","varlist split ","JOINERS  fetch ","LEADERS  fetch ","expansion match "," parse_new_template_pattern ","pattern == ","processor nil? ","expansion [] s first ","Regexp  escape  + "]}," Addressable Template parse_template_expansion":{"type":"method","name":"parse_template_expansion","children":[],"call":["var gsub ","variables map ","(block\n  (send\n    (lvar :variables) :inject\n    (hash))\n  (args\n    (arg :accu)\n    (arg :var))\n  (begin\n    (masgn\n      (mlhs\n        (lvasgn :varname)\n        (lvasgn :_)\n        (lvasgn :vardefault))\n      (send\n        (send\n          (lvar :var) :scan\n          (regexp\n            (str \"^(.+?)(=(.*))?$\")\n            (regopt))) :[]\n        (int 0)))\n    (send\n      (lvar :accu) :[]=\n      (lvar :varname)\n      (lvar :vardefault))\n    (lvar :accu))) merge ","accu []= ","var scan [] ","var scan ","variables inject ","variables split ","operator gsub! ","capture [] split ","capture [] ","variables split  map ","(block\n  (send\n    (lvar :variables split ) :inject\n    (hash))\n  (args\n    (arg :accu)\n    (arg :var))\n  (begin\n    (masgn\n      (mlhs\n        (lvasgn :varname)\n        (lvasgn :_)\n        (lvasgn :vardefault))\n      (send\n        (send\n          (lvar :var) :scan\n          (regexp\n            (str \"^(.+?)(=(.*))?$\")\n            (regopt))) :[]\n        (int 0)))\n    (send\n      (lvar :accu) :[]=\n      (lvar :varname)\n      (lvar :vardefault))\n    (lvar :accu))) merge ","variables split  inject ","variables split  split "]}," Addressable Template expand_list_operator":{"type":"method","name":"expand_list_operator","children":[],"call":["variables first "," raise ","values join ","values kind_of? ","mapping [] ","partial ! ","variables size != ","variables size ","mapping []  join ","mapping []  kind_of? "]}," Addressable Template expand_join_operator":{"type":"method","name":"expand_join_operator","children":[],"call":[" raise ","buffer << ","mapping [] ","variables [] ","index + ","index != ","variables size - ","variables size ","state == ","variables size == ","buffer empty? ","buffer [] != ","buffer [] ","buffer empty? ! ","variable + + ","variable + ","buffer [] == ","mapping [] kind_of? ! ","mapping [] kind_of? ","variables each_with_index ","variable_values join ","accu << ","variables inject ","partial ! "]}," Addressable Template expand_suffix_operator":{"type":"method","name":"expand_suffix_operator","children":[],"call":["variables first ","value to_s + ","value to_s ","(block\n  (send\n    (lvar :value) :map)\n  (args\n    (arg :list_value))\n  (send\n    (lvar :list_value) :+\n    (lvar :argument))) join ","list_value + ","value map ","value kind_of? ","partial ! ","mapping [] "," raise ","variables size != ","variables size ","mapping []  to_s + ","mapping []  to_s ","(block\n  (send\n    (lvar :mapping [] ) :map)\n  (args\n    (arg :list_mapping [] ))\n  (send\n    (lvar :list_mapping [] ) :+\n    (lvar :argument))) join ","list_mapping []  + ","mapping []  map ","mapping []  kind_of? "]}," Addressable Template expand_prefix_operator":{"type":"method","name":"expand_prefix_operator","children":[],"call":["variables first ","argument + ","value to_s ","(block\n  (send\n    (lvar :value) :map)\n  (args\n    (arg :list_value))\n  (send\n    (lvar :argument) :+\n    (lvar :list_value))) join ","value map ","value kind_of? ","partial ! ","mapping [] "," raise ","variables size != ","variables size ","mapping []  to_s ","(block\n  (send\n    (lvar :mapping [] ) :map)\n  (args\n    (arg :list_mapping [] ))\n  (send\n    (lvar :argument) :+\n    (lvar :list_mapping [] ))) join ","mapping []  map ","mapping []  kind_of? "]}," Addressable Template expand_neg_operator":{"type":"method","name":"expand_neg_operator","children":[],"call":["variables join ","variables_present ! ","mapping [] ","mapping [] != ","variables any? "]}," Addressable Template expand_opt_operator":{"type":"method","name":"expand_opt_operator","children":[],"call":["variables join ","variables_present ! ","mapping [] ","mapping [] != ","variables any? "]}," Addressable Template transform_mapping":{"type":"method","name":"transform_mapping","children":[],"call":["accu []= ","Addressable IDNA  unicode_normalize_kc ","transformed_value map! ","transformed_value kind_of? ","processor transform ","processor respond_to? "," raise ","value inspect ","value kind_of? ","processor validate ! ","processor validate ","processor != ","Addressable URI  encode_component ","value map ","processor respond_to? ! ","processor == ","value map! ","value to_str ","value to_ary ","value respond_to? ","value class ","mapping inject ","name class ","name to_str ","name respond_to? ","name to_s ","Symbol  === ","value to_s ","Numeric  === ","Addressable IDNA  unicode_normalize_kc  map! ","processor transform  map! ","Addressable URI  encode_component  map! ","transformed_Addressable IDNA  unicode_normalize_kc  map! ","transformed_value to_str  map! ","transformed_value to_ary  map! ","transformed_value to_s  map! ","Addressable IDNA  unicode_normalize_kc  kind_of? ","processor transform  kind_of? ","Addressable URI  encode_component  kind_of? ","transformed_Addressable IDNA  unicode_normalize_kc  kind_of? ","transformed_value to_str  kind_of? ","transformed_value to_ary  kind_of? ","transformed_value to_s  kind_of? ","Addressable IDNA  unicode_normalize_kc  inspect ","value to_str  inspect ","value to_ary  inspect ","value to_s  inspect ","value to_str  kind_of? ","value to_ary  kind_of? ","value to_s  kind_of? ","Addressable IDNA  unicode_normalize_kc  map ","value to_str  map ","value to_ary  map ","value to_s  map ","value to_str  map! ","value to_ary  map! ","value to_s  map! ","Addressable IDNA  unicode_normalize_kc  to_str ","value to_str  to_str ","value to_ary  to_str ","value to_s  to_str ","Addressable IDNA  unicode_normalize_kc  to_ary ","value to_str  to_ary ","value to_ary  to_ary ","value to_s  to_ary ","Addressable IDNA  unicode_normalize_kc  respond_to? ","value to_str  respond_to? ","value to_ary  respond_to? ","value to_s  respond_to? ","Addressable IDNA  unicode_normalize_kc  class ","value to_str  class ","value to_ary  class ","value to_s  class ","name to_str  class ","name to_s  class ","name to_str  to_str ","name to_s  to_str ","name to_str  respond_to? ","name to_s  respond_to? ","name to_str  to_s ","name to_s  to_s ","Addressable IDNA  unicode_normalize_kc  to_s ","value to_str  to_s ","value to_ary  to_s ","value to_s  to_s "]}," Addressable Template variables":{"type":"method","name":"variables","children":[],"call":["result uniq ","result << ","expansion [] ","result concat "," parse_template_expansion ","expansion =~ ","expansions each "," parse_template_pattern "," pattern ","(send\n  (send nil :ordered_variable_defaults) :map) uniq "," ordered_variable_defaults map "," ordered_variable_defaults "]}," Addressable Template expand":{"type":"method","name":"expand","children":[],"call":["Addressable URI  parse ","transformed_mapping [] ","capture scan [] ","capture scan "," send ","expand_method to_sym "," raise ","(send\n  (array\n    (lvar :expand_method)\n    (send\n      (lvar :expand_method) :to_sym)) :&\n  (send nil :private_methods)) empty? ","(lvar :expand_method) & "," private_methods "," parse_template_expansion ","capture =~ ","result gsub! "," transform_mapping "," pattern dup "," pattern "," transform_capture "," normalize_keys "," transform_mapping  [] ","transformed_ normalize_keys  [] "," pattern dup  gsub! "," transform_ normalize_keys  "]}," Addressable Template partial_expand":{"type":"method","name":"partial_expand","children":[],"call":["Addressable Template  new ","transformed_mapping [] ","capture scan [] ","capture scan "," send ","expand_method to_sym "," raise ","(send\n  (array\n    (lvar :expand_method)\n    (send\n      (lvar :expand_method) :to_sym)) :&\n  (send nil :private_methods)) empty? ","(lvar :expand_method) & "," private_methods "," parse_template_expansion ","capture =~ ","result gsub! "," transform_mapping "," pattern dup "," pattern "," transform_partial_capture "," normalize_keys "," transform_mapping  [] ","transformed_ normalize_keys  [] "," pattern dup  gsub! "," transform_ normalize_keys  "]}," Addressable Template match":{"type":"method","name":"match","children":[],"call":["Addressable Template MatchData  new ","mapping []= ","mapping [] == ","mapping [] ","processor restore ","processor respond_to? ","processor != ","expansion [] "," send ","extract_method to_sym "," raise ","(send\n  (array\n    (lvar :extract_method)\n    (send\n      (lvar :extract_method) :to_sym)) :&\n  (send nil :private_methods)) empty? ","(lvar :extract_method) & "," private_methods "," parse_template_expansion ","expansion =~ ","unparsed_values [] ","expansions each_with_index ","expansions size == ","unparsed_values size ","expansions size ","expansions size > ","uri to_str == "," pattern ","uri to_str ","uri to_str scan flatten ","uri to_str scan "," parse_template_pattern ","Addressable URI  parse ","index + ","Addressable URI  unencode_component ","value map ","value is_a? ","acc []= ","value inject ","processor == ","value nil? ","unparsed_values [] split ","val nil? ","v split ","JOINERS  [] ","modifier == ","value split ","varspec [] ","varspec match ","varlist split each ","varlist split ","expansion match ","expansions each ","uri to_str match ","mapping [] nil? ","mapping has_key? ! ","mapping has_key? ","uri is_a? ","unparsed_processor restore s [] ","unparsed_Addressable URI  unencode_component s [] ","unparsed_unparsed_values [] split s [] ","unparsed_value split s [] ","unparsed_values [] s [] ","uri to_str scan flatten  [] ","expansions each_with_index +  ","unparsed_processor restore s size ","unparsed_Addressable URI  unencode_component s size ","unparsed_unparsed_values [] split s size ","unparsed_value split s size ","unparsed_values [] s size ","uri to_str scan flatten  size ","Addressable URI  parse  to_str == ","Addressable URI  parse  to_str ","Addressable URI  parse  to_str scan flatten ","Addressable URI  parse  to_str scan ","index +  + ","processor restore  map ","Addressable URI  unencode_component  map ","unparsed_values [] split  map ","value split  map ","processor restore  is_a? ","Addressable URI  unencode_component  is_a? ","unparsed_values [] split  is_a? ","value split  is_a? ","processor restore  inject ","Addressable URI  unencode_component  inject ","unparsed_values [] split  inject ","value split  inject ","processor restore  nil? ","Addressable URI  unencode_component  nil? ","unparsed_values [] split  nil? ","value split  nil? ","unparsed_processor restore s [] split ","unparsed_Addressable URI  unencode_component s [] split ","unparsed_unparsed_values [] split s [] split ","unparsed_value split s [] split ","unparsed_values [] s [] split ","uri to_str scan flatten  [] split ","processor restore  split ","Addressable URI  unencode_component  split ","unparsed_values [] split  split ","value split  split ","Addressable URI  parse  to_str match ","Addressable URI  parse  is_a? "]}," Addressable Template extract":{"type":"method","name":"extract","children":[],"call":["match_data mapping "," match "," match  mapping "]}," Addressable Template inspect":{"type":"method","name":"inspect","children":[],"call":[" sprintf "," pattern "," object_id "," class to_s "," class "]}," Addressable Template initialize":{"type":"method","name":"initialize","children":[],"call":["pattern to_str freeze ","pattern to_str "," raise ","pattern class ","pattern respond_to? ! ","pattern respond_to? ","pattern to_str dup freeze ","pattern to_str dup "]}," Addressable Template MatchData inspect":{"type":"method","name":"inspect","children":[],"call":[" sprintf "," mapping inspect "," mapping "," object_id "," class to_s "," class "]}," Addressable Template MatchData values":{"type":"method","name":"values","children":[],"call":["accu << "," mapping [] "," mapping "," variables inject "," variables "]}," Addressable Template MatchData variables":{"type":"method","name":"variables","children":[],"call":[" template variables "," template "]}," Addressable Template MatchData initialize":{"type":"method","name":"initialize","children":[],"call":["mapping dup freeze ","mapping dup ","uri dup freeze ","uri dup "]}," Addressable Template ordered_variable_defaults":{"type":"method","name":"ordered_variable_defaults","children":[],"call":["result << ","result concat ","mapping [] ","variables map "," parse_template_expansion ","expansions inject "," parse_template_pattern "," pattern ","(send\n  (lvar :expansions) :map) flatten ","varspec [] ","varlist split map ","varlist split ","capture match ","expansions map ","expansions flat_map "]}," Addressable Template variable_defaults":{"type":"method","name":"variable_defaults","children":[],"call":["Hash  [] ","(send\n  (send nil :ordered_variable_defaults) :reject) flatten ","v nil? "," ordered_variable_defaults reject "," ordered_variable_defaults "]}," Addressable URI defer_validation":{"type":"method","name":"defer_validation","children":[],"call":[" validate ","block call "," raise "," block_given? "]}," Addressable URI request_uri=":{"type":"method","name":"request_uri=","children":[],"call":[" query= "," path= ","path_component != ","path_component to_s ","new_request_uri [] ","new_request_uri to_str "," raise "," scheme !~ "," scheme "," absolute? ","new_request_uri class ","new_request_uri respond_to? ! ","new_request_uri respond_to? ","path_component empty? ! ","path_component empty? "," remove_composite_values ","path_component to_s  != ","new_request_uri []  != ","path_component to_s  to_s ","new_request_uri []  to_s ","new_request_uri to_str  [] ","new_request_uri to_str  to_str ","new_request_uri to_str  class ","new_request_uri to_str  respond_to? ! ","new_request_uri to_str  respond_to? ","path_component to_s  empty? ! ","new_request_uri []  empty? ! ","path_component to_s  empty? ","new_request_uri []  empty? "]}," Addressable URI request_uri":{"type":"method","name":"request_uri","children":[],"call":["(if\n  (send\n    (send\n      (self) :path) :!=\n    (str \"\"))\n  (send\n    (self) :path)\n  (str \"/\")) + "," query "," path "," path != "," scheme !~ "," scheme "," absolute? ","(if\n  (send\n    (send\n      (send\n        (self) :path) :empty?) :!)\n  (send\n    (self) :path)\n  (const nil :SLASH)) + "," path empty? ! "," path empty? "]}," Addressable URI normalize_component":{"type":"method","name":"normalize_component","children":[],"call":["CharacterClasses RESERVED  + "]}," Addressable URI site=":{"type":"method","name":"site=","children":[],"call":[" authority= "," scheme= ","new_site [] ","new_site to_str "," raise ","new_site class ","new_site respond_to? ! ","new_site respond_to? ","new_site to_str  [] ","new_site to_str  to_str ","new_site to_str  class ","new_site to_str  respond_to? ! ","new_site to_str  respond_to? "]}," Addressable URI normalized_site":{"type":"method","name":"normalized_site","children":[],"call":["site_string << "," normalized_authority "," normalized_authority != "," normalized_scheme "," normalized_scheme != "," site ","@normalized_site force_encoding "," dup "," force_utf8_encoding_if_needed "," dup  << "]}," Addressable URI site":{"type":"method","name":"site","children":[],"call":["site_string << "," authority "," authority != "," scheme "," scheme != "," dup "," dup  << "]}," Addressable URI form_unencode":{"type":"method","name":"form_unencode","children":[],"call":[]}," Addressable URI form_encode":{"type":"method","name":"form_encode","children":[],"call":[]}," Addressable URI origin":{"type":"method","name":"origin","children":[],"call":[" normalized_host "," normalized_scheme ","(begin\n  (send\n    (self) :normalized_scheme)) + "," normalized_port "," authority "," scheme "]}," Addressable URI default_port":{"type":"method","name":"default_port","children":[],"call":["URI  port_mapping [] "," scheme strip downcase "," scheme strip "," scheme ","URI  port_mapping "]}," Addressable Template normalize_keys":{"type":"method","name":"normalize_keys","children":[],"call":["accu []= "," raise ","name class ","name to_str ","name respond_to? ","name to_s ","Symbol  === ","mapping inject ","name to_str  class ","name to_s  class ","name to_str  to_str ","name to_s  to_str ","name to_str  respond_to? ","name to_s  respond_to? ","name to_str  to_s ","name to_s  to_s "]}," Addressable Template normalize_value":{"type":"method","name":"normalize_value","children":[],"call":["Addressable IDNA  unicode_normalize_kc ","acc []= ","value inject ","value kind_of? ","value map! ","value to_str ","value to_ary ","value respond_to? ","value is_a? ","value unicode_normalize ","value dup force_encoding ","value dup ","value encoding != ","value encoding "," normalize_value ","value to_s ","value kind_of? ! ","value to_ary map! ","Addressable IDNA  unicode_normalize_kc  inject ","value to_str  inject ","value to_ary  inject ","value unicode_normalize  inject ","value dup force_encoding  inject ","value to_s  inject ","Addressable IDNA  unicode_normalize_kc  kind_of? ","value to_str  kind_of? ","value to_ary  kind_of? ","value unicode_normalize  kind_of? ","value dup force_encoding  kind_of? ","value to_s  kind_of? ","Addressable IDNA  unicode_normalize_kc  map! ","value to_str  map! ","value to_ary  map! ","value unicode_normalize  map! ","value dup force_encoding  map! ","value to_s  map! ","Addressable IDNA  unicode_normalize_kc  to_str ","value to_str  to_str ","value to_ary  to_str ","value unicode_normalize  to_str ","value dup force_encoding  to_str ","value to_s  to_str ","Addressable IDNA  unicode_normalize_kc  to_ary ","value to_str  to_ary ","value to_ary  to_ary ","value unicode_normalize  to_ary ","value dup force_encoding  to_ary ","value to_s  to_ary ","Addressable IDNA  unicode_normalize_kc  respond_to? ","value to_str  respond_to? ","value to_ary  respond_to? ","value unicode_normalize  respond_to? ","value dup force_encoding  respond_to? ","value to_s  respond_to? ","Addressable IDNA  unicode_normalize_kc  is_a? ","value to_str  is_a? ","value to_ary  is_a? ","value unicode_normalize  is_a? ","value dup force_encoding  is_a? ","value to_s  is_a? ","Addressable IDNA  unicode_normalize_kc  unicode_normalize ","value to_str  unicode_normalize ","value to_ary  unicode_normalize ","value unicode_normalize  unicode_normalize ","value dup force_encoding  unicode_normalize ","value to_s  unicode_normalize ","Addressable IDNA  unicode_normalize_kc  dup force_encoding ","value to_str  dup force_encoding ","value to_ary  dup force_encoding ","value unicode_normalize  dup force_encoding ","value dup force_encoding  dup force_encoding ","value to_s  dup force_encoding ","Addressable IDNA  unicode_normalize_kc  dup ","value to_str  dup ","value to_ary  dup ","value unicode_normalize  dup ","value dup force_encoding  dup ","value to_s  dup ","Addressable IDNA  unicode_normalize_kc  encoding != ","value to_str  encoding != ","value to_ary  encoding != ","value unicode_normalize  encoding != ","value dup force_encoding  encoding != ","value to_s  encoding != ","Addressable IDNA  unicode_normalize_kc  encoding ","value to_str  encoding ","value to_ary  encoding ","value unicode_normalize  encoding ","value dup force_encoding  encoding ","value to_s  encoding "," normalize_Addressable IDNA  unicode_normalize_kc  "," normalize_value to_str  "," normalize_value to_ary  "," normalize_value unicode_normalize  "," normalize_value dup force_encoding  "," normalize_value to_s  ","Addressable IDNA  unicode_normalize_kc  to_s ","value to_str  to_s ","value to_ary  to_s ","value unicode_normalize  to_s ","value dup force_encoding  to_s ","value to_s  to_s ","Addressable IDNA  unicode_normalize_kc  kind_of? ! ","value to_str  kind_of? ! ","value to_ary  kind_of? ! ","value unicode_normalize  kind_of? ! ","value dup force_encoding  kind_of? ! ","value to_s  kind_of? ! ","Addressable IDNA  unicode_normalize_kc  to_ary map! ","value to_str  to_ary map! ","value to_ary  to_ary map! ","value unicode_normalize  to_ary map! ","value dup force_encoding  to_ary map! ","value to_s  to_ary map! "]}," Addressable Template join_values":{"type":"method","name":"join_values","children":[],"call":["leader + ","(send\n  (lvar :return_value) :map) join ","return_value map ","v != ","; + ","(send\n  (lvar :v) :map) join ","v map ","v is_a? ","v join ","v first =~ ","v first ","JOINERS  fetch ","LEADERS  fetch ","LEADERS  fetch  + "]}," Addressable Template transform_capture":{"type":"method","name":"transform_capture","children":[],"call":[" join_values ","return_value empty? ","acc << "," normalize_value ","processor transform ","processor respond_to? "," raise ","value inspect ","value kind_of? ","processor validate ! ","processor validate ","processor != ","Addressable URI  encode_component ","value [] ","transformed_value join ","modifier == ","value map ","val [] ","Addressable URI CharacterClasses RESERVED  + ","processor respond_to? ! ","processor == ","value class ","value respond_to? ","Hash  === ","modifier gsub to_i ","modifier gsub ","modifier =~ ","value to_s ","Symbol  === ","Numeric  === ","(str \"+\") include? ","value == ","mapping [] ","varspec match ","varlist split inject ","varlist split ","capture match "," join_ normalize_value s "," join_value to_s s "," join_mapping [] s ","return_ normalize_value  empty? ","return_value to_s  empty? ","return_mapping []  empty? "," normalize_ normalize_value  "," normalize_value to_s  "," normalize_mapping []  "," normalize_value  inspect ","value to_s  inspect ","mapping []  inspect "," normalize_value  kind_of? ","value to_s  kind_of? ","mapping []  kind_of? "," normalize_value  [] ","value to_s  [] ","mapping []  [] "," normalize_value  join ","processor transform  join ","Addressable URI  encode_component  join ","transformed_value join  join ","transformed_ normalize_value  join ","transformed_value to_s  join ","transformed_mapping []  join "," normalize_value  map ","value to_s  map ","mapping []  map "," normalize_value  class ","value to_s  class ","mapping []  class "," normalize_value  respond_to? ","value to_s  respond_to? ","mapping []  respond_to? "," normalize_value  to_s ","value to_s  to_s ","mapping []  to_s "," normalize_value  == ","value to_s  == ","mapping []  == "]}," Addressable Template transform_partial_capture":{"type":"method","name":"transform_partial_capture","children":[],"call":["acc << ","operator == ","is_first ! "," transform_capture ","mapping [] ","varspec match ","varlist split inject ","varlist split ","capture match ","mapping key? ","vars zip reduce ","vars zip "," operator_sequence take ","vars length "," operator_sequence ","(lvar :first_to_expand) + ","varspec == ","vars reject ","vars find ","? == "," dup ","next_val != ","vars inject ","mapping [] nil? ! ","mapping [] nil? ","(lvar :first_to_expand) + pec match ","varlist split pec match ","(lvar :first_to_expand) +  zip reduce ","varlist split  zip reduce ","(lvar :first_to_expand) +  zip ","varlist split  zip ","(lvar :first_to_expand) +  length ","varlist split  length ","(lvar :first_to_expand) + pec == ","varlist split pec == ","(lvar :first_to_expand) +  reject ","varlist split  reject ","(lvar :first_to_expand) +  find ","varlist split  find "," transform_capture  != ","(lvar :first_to_expand) +  inject ","varlist split  inject "]}," Addressable Template MatchData pre_match":{"type":"method","name":"pre_match","children":[],"call":[]}," Addressable Template MatchData values_at":{"type":"method","name":"values_at","children":[],"call":[" [] ","indexes map "]}," Addressable Template MatchData to_s":{"type":"method","name":"to_s","children":[],"call":[" uri to_s "," uri "]}," Addressable Template MatchData to_a":{"type":"method","name":"to_a","children":[],"call":[" values "," to_s "]}," Addressable Template MatchData []":{"type":"method","name":"[]","children":[],"call":[" to_a [] "," to_a "," mapping [] ","key to_s "," mapping ","Symbol  === ","String  === "]}," Addressable URI split_path":{"type":"method","name":"split_path","children":[],"call":["splitted << ","path end_with? ","path split ","path split  << "]}," Addressable URI empty?":{"type":"method","name":"empty?","children":[],"call":[" to_s empty? "," to_s "]}," Addressable URI hostname=":{"type":"method","name":"hostname=","children":[],"call":[" host= ","(str \"\\\\A\\\\[.*\\\\]\\\\z\") !~ ","new_hostname to_str "," raise ","new_hostname class ","new_hostname respond_to? ! ","new_hostname respond_to? ","new_hostname to_s ","new_hostname to_s  to_str ","new_hostname to_s  class ","new_hostname to_s  respond_to? ! ","new_hostname to_s  respond_to? ","new_hostname to_s  to_s "]}," Addressable URI hostname":{"type":"method","name":"hostname","children":[],"call":[" host "]}," Addressable Template ==":{"type":"method","name":"==","children":[],"call":[" pattern == ","template pattern "," pattern ","template kind_of? "]}," Addressable URI remove_composite_values":{"type":"method","name":"remove_composite_values","children":[],"call":[" remove_instance_variable "]}," Addressable URI origin=":{"type":"method","name":"origin=","children":[],"call":[" validate "," remove_composite_values "," remove_instance_variable "," userinfo= "," port= "," host= "," scheme= ","new_origin [] "," raise ","new_origin to_str ","new_origin class ","new_origin respond_to? ! ","new_origin respond_to? ","new_origin to_str  [] ","new_origin to_str  to_str ","new_origin to_str  class ","new_origin to_str  respond_to? ! ","new_origin to_str  respond_to? "]}," Addressable Template operator_sequence":{"type":"method","name":"operator_sequence","children":[],"call":["y << ","rest_operator to_s ","head_operator to_s ","Enumerator  new ","? == "]}," Addressable Template generate":{"type":"method","name":"generate","children":[{"type":"method","name":"transform","children":[],"asgn":[],"call":[" block call "," block "]}],"call":["result to_s "," expand ","processor block= ","options [] "," block call "," block "," attr_accessor ","Object  new ","recall merge "," expand  to_s ","Object  new  block= ","options []  block= "]}," Addressable Template named_captures":{"type":"method","name":"named_captures","children":[],"call":[" to_regexp named_captures "," to_regexp "]}," Addressable Template source":{"type":"method","name":"source","children":[],"call":[" to_regexp source "," to_regexp "]}," Addressable Template to_regexp":{"type":"method","name":"to_regexp","children":[],"call":["Regexp  new "," parse_template_pattern "," pattern "]}," Addressable Template freeze":{"type":"method","name":"freeze","children":[],"call":[" named_captures "," variable_defaults "," variables "]}," Addressable URI domain":{"type":"method","name":"domain","children":[],"call":["PublicSuffix  domain "," host "]}," Addressable URI tld":{"type":"method","name":"tld","children":[],"call":["PublicSuffix  parse tld ","PublicSuffix  parse "," host "]}," Addressable URI tld=":{"type":"method","name":"tld=","children":[],"call":[" host= ","PublicSuffix Domain  new to_s ","PublicSuffix Domain  new "," domain sub "," tld "," domain "," host sub "," host "]}," Addressable Template parse_new_template_pattern":{"type":"method","name":"parse_new_template_pattern","children":[],"call":["Regexp  new ","(send\n  (send\n    (lvar :varlist) :split\n    (str \",\")) :map) join ","modifier == ","UNRESERVED  gsub ","processor match ","processor respond_to? ","varspec match ","varlist split map ","varlist split ","Regexp  escape ","JOINERS  fetch ","LEADERS  fetch ","expansion match ","expansions << ","escaped_pattern gsub ","escaped gsub ","Regexp  escape gsub "]}," Addressable IDNA ucs4_to_utf8":{"type":"method","name":"ucs4_to_utf8","children":[],"call":[]}," Addressable URI force_utf8_encoding_if_needed":{"type":"method","name":"force_utf8_encoding_if_needed","children":[],"call":["str force_encoding ","str encoding != ","str encoding "]}," Addressable URI reset_ivs":{"type":"method","name":"reset_ivs","children":[],"call":[]}," Addressable URI init_with":{"type":"method","name":"init_with","children":[],"call":[" instance_variable_set ","coder map each ","coder map "," reset_ivs "]}," Addressable URI encode_with":{"type":"method","name":"encode_with","children":[],"call":["coder []= ","ivar to_s slice ","ivar to_s ","value != "," instance_variable_get "," instance_variables each "," instance_variables "," instance_variable_get  != "]}}