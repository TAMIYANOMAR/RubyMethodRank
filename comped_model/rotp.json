{" ROTP TOTP timehash":{"type":"method","name":"timehash","children":[],"call":["i / "," interval * "," interval ","time utc to_i * ","time utc to_i ","time utc ","i /  / ","time utc to_i *  / "," i / nterval * "," time utc to_i * nterval * "," i / nterval "," time utc to_i * nterval ","ti / me utc to_i /  * ","ttime utc to_i * me utc to_time utc to_i *  * ","ti / me utc to_i /  ","ttime utc to_i * me utc to_time utc to_i *  ","ti / me utc ","ttime utc to_i * me utc "]}," ROTP TOTP now":{"type":"method","name":"now","children":[],"call":[" generate_otp "," timehash ","Time  now "," timecode "]}," ROTP TOTP at":{"type":"method","name":"at","children":[],"call":[" generate_otp "," timehash ","Time  at ","time to_i ","time class == ","time class "," timecode "," Time  at hash ","Time  at  to_i ","Time  at  class == ","Time  at  class "," Time  at code "]}," ROTP TOTP initialize":{"type":"method","name":"initialize","children":[],"call":["options [] "]}," ROTP OTP int_to_bytestring":{"type":"method","name":"int_to_bytestring","children":[],"call":["result reverse join rjust ","0 chr ","result reverse join ","result reverse ","result << ","(send\n  (lvar :int) :&\n  (int 255)) chr ","int & ","int == "," raise ","int >= "]}," ROTP OTP generate_otp":{"type":"method","name":"generate_otp","children":[],"call":["code % ","10 ** "," digits ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :offset)) :&\n  (int 127)) << | | | ","hmac [] & ","hmac [] ","offset + ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :offset)) :&\n  (int 127)) << | | ","(send\n  (send\n    (lvar :hmac) :[]\n    (send\n      (lvar :offset) :+\n      (int 2))) :&\n  (int 255)) << ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :offset)) :&\n  (int 127)) << | ","(send\n  (send\n    (lvar :hmac) :[]\n    (send\n      (lvar :offset) :+\n      (int 1))) :&\n  (int 255)) << ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :offset)) :&\n  (int 127)) << ","OpenSSL HMAC  digest "," int_to_bytestring "," secret ","OpenSSL Digest Digest  new "," digest "," byte_secret ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << | | | ","hmac [] ord & ","hmac [] ord ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << | | ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (send\n        (lvar :offset) :+\n        (int 2))) :ord) :&\n  (int 255)) << ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << | ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (send\n        (lvar :offset) :+\n        (int 1))) :ord) :&\n  (int 255)) << ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << ","(send\n  (lvar :code) :%\n  (send\n    (int 10) :**\n    (send nil :digits))) to_s rjust ","(send\n  (lvar :code) :%\n  (send\n    (int 10) :**\n    (send nil :digits))) to_s ","OpenSSL Digest  new ","code_str [] "," digits -@ ","(send\n  (send\n    (int 10) :**\n    (send nil :digits)) :+\n  (begin\n    (send\n      (lvar :code) :%\n      (send\n        (int 10) :**\n        (send nil :digits))))) to_s ","10 ** + ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :offset)) :&\n  (int 127)) << | | |  % ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << | | |  % ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :hmac [] & )) :&\n  (int 127)) << | | | ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :hmac [] ord & )) :&\n  (int 127)) << | | | ","(send\n  (send\n    (lvar :OpenSSL HMAC  digest ) :[]\n    (lvar :offset)) :&\n  (int 127)) << | | | ","OpenSSL HMAC  digest  [] & ","OpenSSL HMAC  digest  [] ","hmac [] &  + ","hmac [] ord &  + ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :hmac [] & )) :&\n  (int 127)) << | | ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :hmac [] ord & )) :&\n  (int 127)) << | | ","(send\n  (send\n    (lvar :OpenSSL HMAC  digest ) :[]\n    (lvar :offset)) :&\n  (int 127)) << | | ","(send\n  (send\n    (lvar :hmac) :[]\n    (send\n      (lvar :hmac [] & ) :+\n      (int 2))) :&\n  (int 255)) << ","(send\n  (send\n    (lvar :hmac) :[]\n    (send\n      (lvar :hmac [] ord & ) :+\n      (int 2))) :&\n  (int 255)) << ","(send\n  (send\n    (lvar :OpenSSL HMAC  digest ) :[]\n    (send\n      (lvar :offset) :+\n      (int 2))) :&\n  (int 255)) << ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :hmac [] & )) :&\n  (int 127)) << | ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :hmac [] ord & )) :&\n  (int 127)) << | ","(send\n  (send\n    (lvar :OpenSSL HMAC  digest ) :[]\n    (lvar :offset)) :&\n  (int 127)) << | ","(send\n  (send\n    (lvar :hmac) :[]\n    (send\n      (lvar :hmac [] & ) :+\n      (int 1))) :&\n  (int 255)) << ","(send\n  (send\n    (lvar :hmac) :[]\n    (send\n      (lvar :hmac [] ord & ) :+\n      (int 1))) :&\n  (int 255)) << ","(send\n  (send\n    (lvar :OpenSSL HMAC  digest ) :[]\n    (send\n      (lvar :offset) :+\n      (int 1))) :&\n  (int 255)) << ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :hmac [] & )) :&\n  (int 127)) << ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :hmac [] ord & )) :&\n  (int 127)) << ","(send\n  (send\n    (lvar :OpenSSL HMAC  digest ) :[]\n    (lvar :offset)) :&\n  (int 127)) << ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :hmac [] & )) :ord) :&\n  (int 127)) << | | | ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :hmac [] ord & )) :ord) :&\n  (int 127)) << | | | ","(send\n  (send\n    (send\n      (lvar :OpenSSL HMAC  digest ) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << | | | ","OpenSSL HMAC  digest  [] ord & ","OpenSSL HMAC  digest  [] ord ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :hmac [] & )) :ord) :&\n  (int 127)) << | | ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :hmac [] ord & )) :ord) :&\n  (int 127)) << | | ","(send\n  (send\n    (send\n      (lvar :OpenSSL HMAC  digest ) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << | | ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (send\n        (lvar :hmac [] & ) :+\n        (int 2))) :ord) :&\n  (int 255)) << ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (send\n        (lvar :hmac [] ord & ) :+\n        (int 2))) :ord) :&\n  (int 255)) << ","(send\n  (send\n    (send\n      (lvar :OpenSSL HMAC  digest ) :[]\n      (send\n        (lvar :offset) :+\n        (int 2))) :ord) :&\n  (int 255)) << ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :hmac [] & )) :ord) :&\n  (int 127)) << | ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :hmac [] ord & )) :ord) :&\n  (int 127)) << | ","(send\n  (send\n    (send\n      (lvar :OpenSSL HMAC  digest ) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << | ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (send\n        (lvar :hmac [] & ) :+\n        (int 1))) :ord) :&\n  (int 255)) << ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (send\n        (lvar :hmac [] ord & ) :+\n        (int 1))) :ord) :&\n  (int 255)) << ","(send\n  (send\n    (send\n      (lvar :OpenSSL HMAC  digest ) :[]\n      (send\n        (lvar :offset) :+\n        (int 1))) :ord) :&\n  (int 255)) << ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :hmac [] & )) :ord) :&\n  (int 127)) << ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :hmac [] ord & )) :ord) :&\n  (int 127)) << ","(send\n  (send\n    (send\n      (lvar :OpenSSL HMAC  digest ) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << ","(send\n  (lvar :(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :offset)) :&\n  (int 127)) << | | | ) :%\n  (send\n    (int 10) :**\n    (send nil :digits))) to_s rjust ","(send\n  (lvar :(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << | | | ) :%\n  (send\n    (int 10) :**\n    (send nil :digits))) to_s rjust ","(send\n  (lvar :(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :offset)) :&\n  (int 127)) << | | | ) :%\n  (send\n    (int 10) :**\n    (send nil :digits))) to_s ","(send\n  (lvar :(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << | | | ) :%\n  (send\n    (int 10) :**\n    (send nil :digits))) to_s ","(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :offset)) :&\n  (int 127)) << | | | _str [] ","(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << | | | _str [] ","(send\n  (send\n    (int 10) :**\n    (send nil :digits)) :+\n  (begin\n    (send\n      (lvar :code) :%\n      (send\n        (int 10) :**\n        (send nil :digits))))) to_s  [] ","(send\n  (send\n    (int 10) :**\n    (send nil :digits)) :+\n  (begin\n    (send\n      (lvar :(send\n  (send\n    (lvar :hmac) :[]\n    (lvar :offset)) :&\n  (int 127)) << | | | ) :%\n      (send\n        (int 10) :**\n        (send nil :digits))))) to_s ","(send\n  (send\n    (int 10) :**\n    (send nil :digits)) :+\n  (begin\n    (send\n      (lvar :(send\n  (send\n    (send\n      (lvar :hmac) :[]\n      (lvar :offset)) :ord) :&\n  (int 127)) << | | | ) :%\n      (send\n        (int 10) :**\n        (send nil :digits))))) to_s "]}," ROTP OTP initialize":{"type":"method","name":"initialize","children":[],"call":["Base32  decode ","options [] "]}," ROTP HOTP at":{"type":"method","name":"at","children":[],"call":[" generate_otp "]}," ROTP random_base32":{"type":"method","name":"random_base32","children":[],"call":[]}," ROTP TOTP timecode":{"type":"method","name":"timecode","children":[],"call":["i / "," interval * "," interval ","time utc to_i * ","time utc to_i ","time utc ","time utc to_i / "," timeint / "," timeint ","time utc to_i *  / "," time utc to_i * nterval * "," time utc to_i * nterval ","ttime utc to_i * me utc to_time utc to_i *  * ","ttime utc to_i * me utc to_time utc to_i *  ","ttime utc to_i * me utc ","ttime utc to_i * me utc to_time utc to_i *  / "," ttime utc to_i * metime utc to_i * nt / "," ttime utc to_i * metime utc to_i * nt "]}," ROTP TOTP provisioning_uri":{"type":"method","name":"provisioning_uri","children":[],"call":[" secret ","URI  encode "," encode_params "," issuer "," interval "," interval == "," issuer nil? "," digits "," digits == "," digest upcase "," digest "," digest upcase == ","Addressable URI  escape "," digest casecmp zero? "," digest casecmp ","Addressable URI  encode ","OTP URI  new to_s ","OTP URI  new "]}," ROTP OTP byte_secret":{"type":"method","name":"byte_secret","children":[],"call":["Base32  decode ","@secret upcase "]}," ROTP HOTP provisioning_uri":{"type":"method","name":"provisioning_uri","children":[],"call":[" secret ","URI  encode "," encode_params "," digits "," digits == ","Addressable URI  escape ","OTP URI  new to_s ","OTP URI  new "]}," ROTP TOTP verify":{"type":"method","name":"verify","children":[],"call":["otp == "," at ","t * "," interval "," generate_otp ","timecodes each ","t > "," timecode ","timecodes select "," get_timecodes "," get_timecodes  each "," get_timecodes  select "," get_ get_timecodes  "]}," ROTP HOTP verify":{"type":"method","name":"verify","children":[],"call":["otp == "," at ","counters find ","(irange\n  (lvar :counter)\n  (send\n    (lvar :counter) :+\n    (lvar :retries))) to_a ","counter + ","(irange\n  (lvar :counter)\n  (send\n    (lvar :counter) :+\n    (lvar :retries))) to_a  find "]}," ROTP Base32 decode_quint":{"type":"method","name":"decode_quint","children":[],"call":["CHARS  index ","q downcase "," raise ","CHARS  inCHARS  index ex ","q CHARS  index owncase "]}," ROTP Base32 decode_block":{"type":"method","name":"decode_block","children":[],"call":["bytes []= ","(send\n  (begin\n    (send\n      (send\n        (lvar :quints) :[]\n        (int 6)) :&\n      (int 7))) :<<\n  (int 5)) + ","quints [] ","(send\n  (send\n    (lvar :quints) :[]\n    (int 6)) :&\n  (int 7)) << ","quints [] & ","(send\n  (begin\n    (send\n      (send\n        (lvar :quints) :[]\n        (int 4)) :&\n      (int 1))) :<<\n  (int 7)) + + ","quints [] >> ","(send\n  (begin\n    (send\n      (send\n        (lvar :quints) :[]\n        (int 4)) :&\n      (int 1))) :<<\n  (int 7)) + ","quints [] << ","(send\n  (send\n    (lvar :quints) :[]\n    (int 4)) :&\n  (int 1)) << ","length < ","(send\n  (begin\n    (send\n      (send\n        (lvar :quints) :[]\n        (int 3)) :&\n      (int 15))) :<<\n  (int 4)) + ","(send\n  (send\n    (lvar :quints) :[]\n    (int 3)) :&\n  (int 15)) << ","(send\n  (begin\n    (send\n      (send\n        (lvar :quints) :[]\n        (int 1)) :&\n      (int 3))) :<<\n  (int 6)) + + ","(send\n  (begin\n    (send\n      (send\n        (lvar :quints) :[]\n        (int 1)) :&\n      (int 3))) :<<\n  (int 6)) + ","(send\n  (send\n    (lvar :quints) :[]\n    (int 1)) :&\n  (int 3)) << ","(send\n  (send\n    (lvar :quints) :[]\n    (int 0)) :<<\n  (int 3)) + "," decode_quint ","block each_char map ","block each_char ","block scan length ","block scan ","block bytesize == ","block bytesize ","block bytesize % == ","block bytesize % ","block scan length  < ","block scan block scan length  "]}," ROTP Base32 random_base32":{"type":"method","name":"random_base32","children":[],"call":["b32 << ","CHARS  [] ","b % ","OpenSSL Random  random_bytes each_byte ","OpenSSL Random  random_bytes ","String  new ","SecureRandom  random_bytes each_byte ","SecureRandom  random_bytes "," random ","str_len * / ","str_len * ","String  new  << "]}," ROTP Base32 decode":{"type":"method","name":"decode","children":[],"call":["output join ","output << ","c chr "," decode_block map "," decode_block ","str scan each ","str scan ","str tr ","result pack ","bits_left - ","idx + ","result []= ","(send\n  (lvar :buffer) :>>\n  (begin\n    (send\n      (lvar :bits_left) :-\n      (int 8)))) & ","buffer >> ","bits_left >= ","bits_left + ","buffer | "," decode_quint & "," decode_quint ","buffer << ","str split each ","str split ","str tr upcase ","str tr  scan each ","str tr upcase  scan each ","str tr  scan ","str tr upcase  scan ","str tr  tr ","str tr upcase  tr ","bits_left -  - ","bits_left +  - ","idx +  + ","(send\n  (lvar :buffer) :>>\n  (begin\n    (send\n      (lvar :bits_left - ) :-\n      (int 8)))) & ","(send\n  (lvar :buffer) :>>\n  (begin\n    (send\n      (lvar :bits_left + ) :-\n      (int 8)))) & ","(send\n  (lvar :buffer | ) :>>\n  (begin\n    (send\n      (lvar :bits_left) :-\n      (int 8)))) & ","(send\n  (lvar :buffer << ) :>>\n  (begin\n    (send\n      (lvar :bits_left) :-\n      (int 8)))) & ","buffer |  >> ","buffer <<  >> ","bits_left -  >= ","bits_left +  >= ","bits_left -  + ","bits_left +  + ","buffer |  | ","buffer <<  | ","buffer |  << ","buffer <<  << ","str tr  split each ","str tr upcase  split each ","str tr  split ","str tr upcase  split ","str tr  tr upcase ","str tr upcase  tr upcase "]}," ROTP OTP verify":{"type":"method","name":"verify","children":[],"call":["input to_i == ","input to_i "," time_constant_compare "," raise ","generated is_a? ","input is_a? "]}," ROTP TOTP verify_with_drift":{"type":"method","name":"verify_with_drift","children":[],"call":[" verify ","time + ","n * "," interval ","(irange\n  (send\n    (lvar :drift_intervals) :-@)\n  (lvar :drift_intervals)) any? ","drift_intervals -@ ","drift / ","times any? ","times << ","times last < ","times last ","(irange\n  (send\n    (lvar :time) :-\n    (lvar :drift))\n  (send\n    (lvar :time) :+\n    (lvar :drift))) step to_a ","(irange\n  (send\n    (lvar :time) :-\n    (lvar :drift))\n  (send\n    (lvar :time) :+\n    (lvar :drift))) step ","time - ","time to_i ","time to_i  + ","(irange\n  (send\n    (lvar :drift / ) :-@)\n  (lvar :drift / )) any? ","drift /  -@ ","(irange\n  (send\n    (lvar :time) :-\n    (lvar :drift))\n  (send\n    (lvar :time) :+\n    (lvar :drift))) step to_a  any? ","time to_i s any? ","(irange\n  (send\n    (lvar :time) :-\n    (lvar :drift))\n  (send\n    (lvar :time) :+\n    (lvar :drift))) step to_a  << ","time to_i s << ","(irange\n  (send\n    (lvar :time) :-\n    (lvar :drift))\n  (send\n    (lvar :time) :+\n    (lvar :drift))) step to_a  last < ","time to_i s last < ","(irange\n  (send\n    (lvar :time) :-\n    (lvar :drift))\n  (send\n    (lvar :time) :+\n    (lvar :drift))) step to_a  last ","time to_i s last ","(irange\n  (send\n    (lvar :time to_i ) :-\n    (lvar :drift))\n  (send\n    (lvar :time to_i ) :+\n    (lvar :drift))) step to_a ","(irange\n  (send\n    (lvar :time to_i ) :-\n    (lvar :drift))\n  (send\n    (lvar :time to_i ) :+\n    (lvar :drift))) step ","time to_i  - ","time to_i  to_i "]}," ROTP OTP encode_params":{"type":"method","name":"encode_params","children":[],"call":["uri + ","params_str chop! ","params_str << ","CGI  escape ","v to_s ","params each ","String  new ","String  new  chop! ","String  new  << "]}," ROTP HOTP verify_with_retries":{"type":"method","name":"verify_with_retries","children":[],"call":[" verify ","initial_count + ","1 upto ","retries <= "]}," ROTP OTP time_constant_compare":{"type":"method","name":"time_constant_compare","children":[],"call":["res == ","byte ^ ","l shift ","b each_byte ","a unpack ","a bytesize ","a bytesize != ","b bytesize ","b empty? ","a empty? ","a unpack  shift "]}," ROTP CLI red":{"type":"method","name":"red","children":[],"call":[]}," ROTP CLI options":{"type":"method","name":"options","children":[],"call":[" arguments options "," arguments "]}," ROTP CLI arguments":{"type":"method","name":"arguments","children":[],"call":["ROTP Arguments  new "," argv "," filename "]}," ROTP CLI output":{"type":"method","name":"output","children":[],"call":[" fail ","ROTP HOTP  new at "," options counter "," options ","ROTP HOTP  new "," options secret "," options mode == "," options mode ","ROTP TOTP  new now ","ROTP TOTP  new "," arguments to_s "," arguments "," errors "," options warnings "]}," ROTP CLI errors":{"type":"method","name":"errors","children":[],"call":[" red "," options counter to_i < "," options counter to_i "," options counter "," options "," options mode == "," options mode ","ROTP Base32 CHARS  index == ","ROTP Base32 CHARS  index ","c downcase "," options secret to_s chars any? "," options secret to_s chars "," options secret to_s "," options secret "," options secret to_s == ","(sym :time) include? ","ROTP Base32 CHARS  index nil? ","c upcase "]}," ROTP CLI run":{"type":"method","name":"run","children":[],"call":[" puts "," output "]}," ROTP CLI initialize":{"type":"method","name":"initialize","children":[],"call":[]}," ROTP Arguments red":{"type":"method","name":"red","children":[],"call":[]}," ROTP Arguments green":{"type":"method","name":"green","children":[],"call":[]}," ROTP Arguments bold":{"type":"method","name":"bold","children":[],"call":[]}," ROTP Arguments parser":{"type":"method","name":"parser","children":[],"call":[" options! mode= "," options! ","parser on_tail ","parser on "," options! counter= ","counter to_i "," options! secret= ","parser separator "," green ","     + + ","     + "," bold "," filename "," green + ","parser banner= ","OptionParser  new "," options! digest= "]}," ROTP Arguments parse":{"type":"method","name":"parse","children":[],"call":[" options! warnings= "," red ","exception message + ","exception message "," options! "," options! mode= "," parser parse "," arguments "," parser "," arguments empty? "]}," ROTP Arguments default_options":{"type":"method","name":"default_options","children":[],"call":["OpenStruct  new "]}," ROTP Arguments options!":{"type":"method","name":"options!","children":[],"call":[" default_options "]}," ROTP Arguments to_s":{"type":"method","name":"to_s","children":[],"call":[" parser help + "," parser help "," parser "]}," ROTP Arguments options":{"type":"method","name":"options","children":[],"call":[" options! "," parse "]}," ROTP Arguments initialize":{"type":"method","name":"initialize","children":[],"call":[" Array "]}," ROTP TOTP verify_with_drift_and_prior":{"type":"method","name":"verify_with_drift_and_prior","children":[],"call":[" verify ","times find ","(irange\n  (lvar :first_bin)\n  (lvar :last_bin)) step to_a ","(irange\n  (lvar :first_bin)\n  (lvar :last_bin)) step "," interval ","first_bin > ","prior_bin + ","prior_bin >= ","prior_time to_i / * ","prior_time to_i / ","prior_time to_i ","(send\n  (lvar :time) :+\n  (lvar :drift)) to_i / * ","(send\n  (lvar :time) :+\n  (lvar :drift)) to_i / ","(send\n  (lvar :time) :+\n  (lvar :drift)) to_i ","time + ","(send\n  (lvar :time) :-\n  (lvar :drift)) to_i / * ","(send\n  (lvar :time) :-\n  (lvar :drift)) to_i / ","(send\n  (lvar :time) :-\n  (lvar :drift)) to_i ","time - ","(irange\n  (lvar :first_bin)\n  (lvar :last_bin)) step to_a  find ","(irange\n  (lvar :prior_bin + )\n  (lvar :last_bin)) step to_a ","(irange\n  (lvar :(send\n  (lvar :time) :-\n  (lvar :drift)) to_i / * )\n  (lvar :last_bin)) step to_a ","(irange\n  (lvar :first_bin)\n  (lvar :(send\n  (lvar :time) :+\n  (lvar :drift)) to_i / * )) step to_a ","(irange\n  (lvar :prior_bin + )\n  (lvar :last_bin)) step ","(irange\n  (lvar :(send\n  (lvar :time) :-\n  (lvar :drift)) to_i / * )\n  (lvar :last_bin)) step ","(irange\n  (lvar :first_bin)\n  (lvar :(send\n  (lvar :time) :+\n  (lvar :drift)) to_i / * )) step ","prior_bin +  > ","(send\n  (lvar :time) :-\n  (lvar :drift)) to_i / *  > ","prior_time to_i / *  + ","prior_time to_i / *  >= "]}," ROTP TOTP timeint":{"type":"method","name":"timeint","children":[],"call":["time utc to_i ","time utc ","time to_i ","time class == ","time class "]}," ROTP TOTP get_timecodes":{"type":"method","name":"get_timecodes","children":[],"call":["(irange\n  (lvar :timecode_start)\n  (lvar :timecode_end)) step to_a ","(irange\n  (lvar :timecode_start)\n  (lvar :timecode_end)) step "," timecode ","now + ","now - "," timeint ","(irange\n  (lvar :timecode_start)\n  (lvar : timecode )) step to_a ","(irange\n  (lvar : timecode )\n  (lvar :timecode_end)) step to_a ","(irange\n  (lvar :timecode_start)\n  (lvar : timecode )) step ","(irange\n  (lvar : timecode )\n  (lvar :timecode_end)) step "," timeint  + "," timeint  - "]}," ROTP Base32 random":{"type":"method","name":"random","children":[],"call":[" encode ","SecureRandom  random_bytes "]}," ROTP Base32 encode":{"type":"method","name":"encode","children":[],"call":["out concat ","CHARS  [] ","bits_left - ","MASK  & ","buffer >> ","bits_left + ","buffer << ","SHIFT  - ","idx + ","buffer | ","data [] & ","data [] ","idx < ","data length ","bits_left < ","bits_left > ","b unpack ","String  new ","String  new  concat ","bits_left -  - ","bits_left +  - ","buffer <<  >> ","buffer |  >> ","data []  >> ","bits_left -  + ","bits_left +  + ","buffer <<  << ","buffer |  << ","data []  << ","idx +  + ","buffer <<  | ","buffer |  | ","data []  | ","b unpack  [] & ","b unpack  [] ","idx +  < ","b unpack  length ","bits_left -  < ","bits_left +  < ","bits_left -  > ","bits_left +  > "]}," ROTP OTP URI type":{"type":"method","name":"type","children":[],"call":[]}," ROTP OTP URI period":{"type":"method","name":"period","children":[],"call":["@otp interval ","@otp interval == ","@otp is_a? "]}," ROTP OTP URI parameters":{"type":"method","name":"parameters","children":[],"call":["(send\n  (block\n    (send\n      (hash\n        (pair\n          (sym :secret)\n          (send\n            (ivar :@otp) :secret))\n        (pair\n          (sym :issuer)\n          (send nil :issuer))\n        (pair\n          (sym :algorithm)\n          (send nil :algorithm))\n        (pair\n          (sym :digits)\n          (send nil :digits))\n        (pair\n          (sym :period)\n          (send nil :period))\n        (pair\n          (sym :counter)\n          (send nil :counter))) :reject)\n    (args\n      (arg :_)\n      (arg :v))\n    (send\n      (lvar :v) :nil?)) :map) join ","ERB Util  url_encode ","(send\n  (hash\n    (pair\n      (sym :secret)\n      (send\n        (ivar :@otp) :secret))\n    (pair\n      (sym :issuer)\n      (send nil :issuer))\n    (pair\n      (sym :algorithm)\n      (send nil :algorithm))\n    (pair\n      (sym :digits)\n      (send nil :digits))\n    (pair\n      (sym :period)\n      (send nil :period))\n    (pair\n      (sym :counter)\n      (send nil :counter))) :reject) map ","v nil? ","(pair\n  (sym :secret)\n  (send\n    (ivar :@otp) :secret)) reject "," counter "," period "," digits "," algorithm "," issuer ","@otp secret ","(send\n  (block\n    (send\n      (send\n        (hash\n          (pair\n            (sym :secret)\n            (send\n              (ivar :@otp) :secret))\n          (pair\n            (sym :issuer)\n            (send nil :issuer))\n          (pair\n            (sym :algorithm)\n            (send nil :algorithm))\n          (pair\n            (sym :digits)\n            (send nil :digits))\n          (pair\n            (sym :period)\n            (send nil :period))\n          (pair\n            (sym :counter)\n            (send nil :counter))) :merge\n        (send\n          (ivar :@otp) :provisioning_params)) :reject)\n    (args\n      (arg :_)\n      (arg :v))\n    (send\n      (lvar :v) :nil?)) :map) join ","(send\n  (send\n    (hash\n      (pair\n        (sym :secret)\n        (send\n          (ivar :@otp) :secret))\n      (pair\n        (sym :issuer)\n        (send nil :issuer))\n      (pair\n        (sym :algorithm)\n        (send nil :algorithm))\n      (pair\n        (sym :digits)\n        (send nil :digits))\n      (pair\n        (sym :period)\n        (send nil :period))\n      (pair\n        (sym :counter)\n        (send nil :counter))) :merge\n    (send\n      (ivar :@otp) :provisioning_params)) :reject) map ","(pair\n  (sym :secret)\n  (send\n    (ivar :@otp) :secret)) merge reject ","(pair\n  (sym :secret)\n  (send\n    (ivar :@otp) :secret)) merge ","@otp provisioning_params "]}," ROTP OTP URI label":{"type":"method","name":"label","children":[],"call":["(send\n  (block\n    (send\n      (send\n        (array\n          (send nil :issuer)\n          (send\n            (ivar :@account_name) :rstrip)) :compact) :map)\n    (args\n      (arg :s))\n    (send\n      (lvar :s) :tr\n      (str \":\")\n      (str \"_\"))) :map) join ","ERB Util  url_encode ","(send\n  (send\n    (array\n      (send nil :issuer)\n      (send\n        (ivar :@account_name) :rstrip)) :compact) :map) map ","s tr ","(send nil :issuer) compact map ","(send nil :issuer) compact ","@account_name rstrip "," issuer "]}," ROTP OTP URI issuer":{"type":"method","name":"issuer","children":[],"call":["@otp issuer ","@otp is_a? "]}," ROTP OTP URI digits":{"type":"method","name":"digits","children":[],"call":["@otp digits ","@otp digits == "]}," ROTP OTP URI counter":{"type":"method","name":"counter","children":[],"call":[" fail ","@counter nil? ","@otp is_a? "]}," ROTP OTP URI algorithm":{"type":"method","name":"algorithm","children":[],"call":["@otp digest upcase ","@otp digest ","(str \"sha256\") include? "]}," ROTP OTP URI to_s":{"type":"method","name":"to_s","children":[],"call":[" parameters "," label "," type "]}," ROTP OTP URI initialize":{"type":"method","name":"initialize","children":[],"call":[]}}