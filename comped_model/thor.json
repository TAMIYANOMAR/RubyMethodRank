{" Thor help":{"type":"method","name":"help","children":[],"call":[" class help ","task include? "," shell "," class "," class_options_help ","options [] ","subclass help ","options merge ","subclass namespace gsub "," namespace ","subclass namespace ","options [] == ","Thor Util  thor_classes_in each ","Thor Util  thor_classes_in ","shell print_list ","shell say ","item << ","task short_description "," banner ","(if\n  (send\n    (lvar :options) :[]\n    (sym :short))\n  (send nil :tasks)\n  (send nil :all_tasks)) map "," all_tasks "," tasks ","task description ","task options map ","task options "," raise "," all_tasks [] ","meth is_a? ","shell print_table ","a [] <=> ","b [] ","a [] ","list sort! ","klass printable_tasks "," printable_tasks ","options [] ! "," class task_help "," class command_help ","klass printable_commands "," printable_commands "," class subcommand_classes [] help "," class subcommand_classes [] "," class subcommand_classes "," class subcommands include? "," class subcommands "," puts ","list descriptions assoc [] ","list descriptions assoc ","list descriptions "," print ","format % "," usage ","%- + + ","%- + ","(send\n  (send\n    (send\n      (send\n        (lvar :list) :max) :usage) :+\n    (send\n      (send\n        (lvar :list) :max) :opt)) :+\n  (int 4)) to_s ","list max usage + + ","list max usage + ","list max opt ","list max ","list max usage ","list usages each ","list usages "," class help_list ","task description split first ","task description split ","task formatted_usage ","(send\n  (send\n    (send\n      (send\n        (send\n          (self) :class) :maxima) :usage) :+\n    (send\n      (send\n        (send\n          (self) :class) :maxima) :opt)) :+\n  (int 4)) to_s "," class maxima usage + + "," class maxima usage + "," class maxima opt "," class maxima "," class maxima usage "," class tasks each "," class tasks "," class tasks [] "," class [] "," all_tasks []  include? "," class tasks []  include? "," class []  include? ","shell print_ printable_tasks  ","shell print_ printable_commands  ","shell print_ class help_list  "," all_tasks []  short_description "," class tasks []  short_description "," class []  short_description ","(if\n  (send\n    (lvar :options) :[]\n    (sym :short))\n  (send nil : all_tasks [] s)\n  (send nil :all_ all_tasks [] s)) map ","(if\n  (send\n    (lvar :options) :[]\n    (sym :short))\n  (send nil : class tasks [] s)\n  (send nil :all_ class tasks [] s)) map ","(if\n  (send\n    (lvar :options) :[]\n    (sym :short))\n  (send nil : class [] s)\n  (send nil :all_ class [] s)) map "," all_ all_tasks [] s "," all_ class tasks [] s "," all_ class [] s ","  all_tasks [] s ","  class tasks [] s ","  class [] s "," all_tasks []  description "," class tasks []  description "," class []  description "," all_tasks []  options map "," class tasks []  options map "," class []  options map "," all_tasks []  options "," class tasks []  options "," class []  options "," all_ all_tasks [] s [] "," all_ class tasks [] s [] "," all_ class [] s [] "," printable_tasks  sort! "," printable_commands  sort! "," class help_list  sort! ","klass printable_ all_tasks [] s ","klass printable_ class tasks [] s ","klass printable_ class [] s "," printable_ all_tasks [] s "," printable_ class tasks [] s "," printable_ class [] s "," class  all_tasks [] _help "," class  class tasks [] _help "," class  class [] _help "," printable_tasks  descriptions assoc [] "," printable_commands  descriptions assoc [] "," class help_list  descriptions assoc [] "," printable_tasks  descriptions assoc "," printable_commands  descriptions assoc "," class help_list  descriptions assoc "," printable_tasks  descriptions "," printable_commands  descriptions "," class help_list  descriptions ","%- + +  % ","(send\n  (send\n    (send\n      (send\n        (lvar : printable_tasks ) :max) :usage) :+\n    (send\n      (send\n        (lvar : printable_tasks ) :max) :opt)) :+\n  (int 4)) to_s ","(send\n  (send\n    (send\n      (send\n        (lvar : printable_commands ) :max) :usage) :+\n    (send\n      (send\n        (lvar : printable_commands ) :max) :opt)) :+\n  (int 4)) to_s ","(send\n  (send\n    (send\n      (send\n        (lvar : class help_list ) :max) :usage) :+\n    (send\n      (send\n        (lvar : class help_list ) :max) :opt)) :+\n  (int 4)) to_s "," printable_tasks  max usage + + "," printable_commands  max usage + + "," class help_list  max usage + + "," printable_tasks  max usage + "," printable_commands  max usage + "," class help_list  max usage + "," printable_tasks  max opt "," printable_commands  max opt "," class help_list  max opt "," printable_tasks  max "," printable_commands  max "," class help_list  max "," printable_tasks  max usage "," printable_commands  max usage "," class help_list  max usage "," printable_tasks  usages each "," printable_commands  usages each "," class help_list  usages each "," printable_tasks  usages "," printable_commands  usages "," class help_list  usages "," class help_ printable_tasks  "," class help_ printable_commands  "," class help_ class help_list  "," all_tasks []  description split first "," class tasks []  description split first "," class []  description split first "," all_tasks []  description split "," class tasks []  description split "," class []  description split "," all_tasks []  formatted_usage "," class tasks []  formatted_usage "," class []  formatted_usage ","task %- + + ted_usage "," class  all_tasks [] s each "," class  class tasks [] s each "," class  class [] s each "," class  all_tasks [] s "," class  class tasks [] s "," class  class [] s "," class  all_tasks [] s [] "," class  class tasks [] s [] "," class  class [] s [] "]}," Thor normalize_task_name":{"type":"method","name":"normalize_task_name","children":[],"call":["meth to_s gsub ","meth to_s "," default_task "," map [] "," map ","possibilities first ","possibilities size < ","possibilities size "," raise ","possibilities join ","possibilities size > "," find_task_possibilities "," default_task to_s gsub "," default_task to_s ","possibilities first  to_s gsub "," map []  to_s gsub ","possibilities first  to_s "," map []  to_s "," find_task_possibilities  first "," find_task_possibilities  size < "," find_task_possibilities  size "," find_task_possibilities  join "," find_task_possibilities  size > "," find_task_ find_task_possibilities  "]}," Thor initialize_added":{"type":"method","name":"initialize_added","children":[],"call":[" class_options merge! "," method_options "," class_options "]}," Thor create_task":{"type":"method","name":"create_task","children":[],"call":[" puts ","(str \"[WARNING] Attempted to create task \") << << "," caller [] inspect "," caller [] "," caller ","(str \"[WARNING] Attempted to create task \") << ","meth inspect ","meth to_sym == ","meth to_sym "," all_tasks [] ","meth to_s "," all_tasks "," tasks []= ","Thor Task  new "," method_options "," tasks ","base_class new ","meth == "]}," Thor baseclass":{"type":"method","name":"baseclass","children":[],"call":[]}," Thor banner":{"type":"method","name":"banner","children":[],"call":["task formatted_usage ","thor  + ","base == ","File  basename ","$0 split first ","$0 split "," banner_base == "," banner_base "," basename ","command formatted_usage ","(send\n  (send\n    (send\n      (lvar :command) :formatted_usage\n      (self)\n      (gvar :$thor_runner)\n      (lvar :subcommand)) :split\n    (str \"\\n\")) :map) join ","command formatted_usage split map ","command formatted_usage split ","File  basename  == ","File  File  basename name "," banner_File  basename  == "," banner_File  basename  "," File  basename name "]}," Thor start":{"type":"method","name":"start","children":[],"call":[" new invoke "," new ","args [] ","Range  new "," arguments size "," arguments ","Task  dynamic ","config merge! ","task options ","Thor Options  split "," all_tasks [] "," all_tasks "," normalize_task_name ","given_args shift ","Thor Task Dynamic  new ","meth !~ "," map [] "," map ","meth empty? ! ","meth empty? ","given_args first to_s ","given_args first ","Thor DynamicTask  new "," all_tasks []  options "," all_ all_tasks [] s [] "," all_ all_tasks [] s "," normalize_ all_tasks [] _name "," normalize_task_name  !~ ","given_args first to_s  !~ "," normalize_task_name  empty? ! ","given_args first to_s  empty? ! "," normalize_task_name  empty? ","given_args first to_s  empty? "]}," Thor method_option":{"type":"method","name":"method_option","children":[],"call":[" build_option "," method_options "," find_and_refresh_task options "," find_and_refresh_task ","options [] "," find_and_refresh_command options "," find_and_refresh_command "]}," Thor method_options":{"type":"method","name":"method_options","children":[],"call":[" build_options "]}," Thor map":{"type":"method","name":"map","children":[],"call":["@map []= ","key each ","key respond_to? ","mappings each "," from_superclass ","kw merge! ","kw empty? ! ","kw empty? ","kw merge!  each "]}," Thor desc":{"type":"method","name":"desc","children":[],"call":["task description= ","task usage= "," find_and_refresh_task ","options [] ","command description= ","command usage= "," find_and_refresh_command "," find_and_refresh_task  description= "," find_and_refresh_task  usage= "," find_and_refresh_ find_and_refresh_task  "," find_and_refresh_command  description= "," find_and_refresh_command  usage= "," find_and_refresh_ find_and_refresh_command  "]}," Thor default_task":{"type":"method","name":"default_task","children":[],"call":["meth to_s "," from_superclass "]}," Thor Util ruby_command":{"type":"method","name":"ruby_command","children":[],"call":["ruby sub! ","linked_ruby == ","File  readlink ","File  symlink? ","alternate_ruby << ","RbConfig CONFIG  [] ","File  join ","File  respond_to? ","ruby_name != ","ruby << ","File  join  sub! ","File  readlink  == ","linked_File  join  == ","File  join  << ","alternate_File  join  << ","File  join _name != ","RbConfig CONFIG  []  != "]}," Thor Util globs_for":{"type":"method","name":"globs_for","children":[],"call":[" escape_globs "]}," Thor Util thor_root_glob":{"type":"method","name":"thor_root_glob","children":[],"call":["File  join ","File  directory? ","files map! ","Dir  [] "," escape_globs "," thor_root ","Dir  []  map! "]}," Thor Util thor_root":{"type":"method","name":"thor_root","children":[],"call":["File  join gsub ","File  join "," user_home ","File  join tr "]}," Thor Util user_home":{"type":"method","name":"user_home","children":[],"call":["File  expand_path ","ENV  [] ","File  join "]}," Thor Util convert_constants_to_namespaces":{"type":"method","name":"convert_constants_to_namespaces","children":[],"call":[]}," Thor Util load_thorfile":{"type":"method","name":"load_thorfile","children":[],"call":["$stderr puts ","e backtrace first ","e backtrace ","e message ","path inspect ","Thor Sandbox  class_eval ","File  binread ","File  read "]}," Thor Util namespace_to_thor_class_and_task":{"type":"method","name":"namespace_to_thor_class_and_task","children":[],"call":[]}," Thor Util camel_case":{"type":"method","name":"camel_case","children":[],"call":["(send\n  (send\n    (lvar :str) :split\n    (str \"_\")) :map) join ","i capitalize ","str split map ","str split ","str =~ ","str !~ ","str split map join "]}," Thor Util snake_case":{"type":"method","name":"snake_case","children":[],"call":["$+ downcase ","str gsub squeeze =~ ","str gsub squeeze ","str gsub ","str downcase ","str =~ ","Regexp  last_match downcase ","Regexp  last_match "]}," Thor Util thor_classes_in":{"type":"method","name":"thor_classes_in","children":[],"call":["stringfied_constants include? ","subclass name gsub ","klass name ","subclass name ","Thor Base  subclasses select ","Thor Base  subclasses ","c to_s ","klass constants map ","klass constants ","klass constants map  include? "]}," Thor Util namespaces_in_content":{"type":"method","name":"namespaces_in_content","children":[],"call":["new_constants compact! ","c namespace ","new_constants map! ","Thor Base  subclasses replace ","Thor Base  subclasses ","Thor Base  subclasses dup "," load_thorfile ","Thor Base  subclasses clear ","Thor Base  subclasses dup  compact! ","Thor Base  subclasses dup  map! "]}," Thor Util namespace_from_thor_class":{"type":"method","name":"namespace_from_thor_class","children":[],"call":[" snake_case squeeze "," snake_case ","constant to_s gsub ","constant to_s "," snake_case squeeze  to_s gsub ","constant to_s gsub  to_s gsub "," snake_case squeeze  to_s ","constant to_s gsub  to_s "]}," Thor Util find_by_namespace":{"type":"method","name":"find_by_namespace","children":[],"call":["klass namespace == ","klass namespace ","Thor Base  subclasses find ","Thor Base  subclasses ","namespace =~ ","namespace empty? ","Thor Base  subclasses detect "]}," Thor Task parse_no_method_error":{"type":"method","name":"parse_no_method_error","children":[],"call":[" raise ","(str \"The \") << "," name ","instance class namespace ","instance class ","e message =~ ","Regexp  escape ","instance to_s ","e message "]}," Thor Task parse_argument_error":{"type":"method","name":"parse_argument_error","children":[],"call":[" raise ","(str \"'\") << "," formatted_usage ","instance class "," name ","instance is_a? ","e message =~ ","e message ","backtrace empty? "," sans_backtrace ","e backtrace ","e backtrace first to_s =~ ","e backtrace first to_s ","e backtrace first ","Regexp  escape "," name split last "," name split "," backtrace_match? "," sans_backtrace  empty? "," sans_ sans_backtrace  ","e  sans_backtrace  ","e  sans_backtrace  first to_s =~ ","e  sans_backtrace  first to_s ","e  sans_backtrace  first ","  sans_backtrace _match? "]}," Thor Task sans_backtrace":{"type":"method","name":"sans_backtrace","children":[],"call":["frame =~ ","backtrace reject ","Regexp  escape ","File  dirname ","RUBY_PLATFORM  =~ "]}," Thor Task public_method?":{"type":"method","name":"public_method?","children":[],"call":["(lvar :collection) include? ! ","(lvar :collection) include? "," name to_sym "," name "," name to_s ","instance private_methods + ","instance protected_methods ","instance private_methods ","(send\n  (lvar :collection) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ","collection & ","(send\n  (send\n    (lvar :instance) :public_methods) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ! ","(send\n  (send\n    (lvar :instance) :public_methods) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ","instance public_methods & ","instance public_methods ","(lvar :instance private_methods + ) include? ! ","(lvar :instance private_methods + ) include? ","(send\n  (lvar :instance private_methods + ) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ","instance private_methods +  & "]}," Thor Task formatted_options":{"type":"method","name":"formatted_options","children":[],"call":["(send\n  (send nil :options) :map) sort join ","(send\n  (send nil :options) :map) sort ","o usage "," options map "," options "]}," Thor Task formatted_arguments":{"type":"method","name":"formatted_arguments","children":[],"call":[" usage to_s "," usage ","match << << ","(send\n  (send\n    (lvar :klass) :arguments) :map) join ","a usage ","klass arguments map ","klass arguments ","match << "," usage to_s gsub "," name ","klass arguments empty? ! ","klass arguments empty? "]}," Thor Task formatted_usage":{"type":"method","name":"formatted_usage","children":[],"call":["formatted strip! ","formatted << "," formatted_options "," formatted_arguments ","klass namespace gsub ","klass namespace ","namespace is_a? ","formatted strip "," required_options "," usage to_s "," usage ","match << << "," required_arguments ","match << "," usage to_s gsub "," name ","klass arguments empty? ! ","klass arguments empty? ","klass arguments ","namespace gsub ","namespace nil? ","(send\n  (send\n    (lvar :klass) :arguments) :map) compact join ","(send\n  (send\n    (lvar :klass) :arguments) :map) compact ","a usage ","klass arguments map ","namespace == ","formatted sub! ","klass namespace split last ","klass namespace split ","(if\n  (lvar :namespace)\n  (send\n    (send\n      (self) :namespace) :+\n    (str \":\"))\n  (str \"\")) + + ","  + "," opts formatted_usage "," opts ","(if\n  (lvar :namespace)\n  (send\n    (send\n      (self) :namespace) :+\n    (str \":\"))\n  (str \"\")) + "," namespace + "," namespace ","klass klass namespace  gsub ","klass klass namespace  ","klass namespace  is_a? ","klass namespace  gsub ","klass namespace  nil? ","klass namespace  == ","klass klass namespace  split last ","klass klass namespace  split ","(if\n  (lvar :klass namespace )\n  (send\n    (send\n      (self) :klass namespace ) :+\n    (str \":\"))\n  (str \"\")) + + ","(if\n  (lvar :klass namespace )\n  (send\n    (send\n      (self) :klass namespace ) :+\n    (str \":\"))\n  (str \"\")) + "," klass namespace  + "," klass namespace  "]}," Thor Task run":{"type":"method","name":"run","children":[],"call":[" parse_no_method_error "," parse_argument_error "," caller ","instance send "," name "," raise ","instance class "," public_method? ","instance class debugging ","instance class respond_to? ","instance class handle_no_task_error "," handle_no_method_error? ","instance class handle_argument_error "," handle_argument_error? "," name to_sym "," local_method? ","instance method arity ","instance method "," private_method? ","instance __send__ "," meth "," namespace ","e message =~ ","Regexp  escape ","obj inspect ","e message "," formatted_usage ","backtrace empty? ","frame =~ ","e backtrace reject ","e backtrace ","obj send ","obj class ","(send\n  (send\n    (lvar :obj) :private_methods) :+\n  (send\n    (lvar :obj) :protected_methods)) include? ","obj private_methods + ","obj protected_methods ","obj private_methods ","instance method instance method arity  "]}," Thor Task short_description":{"type":"method","name":"short_description","children":[],"call":[" description split first "," description split "," description "]}," Thor Task initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" options= ","other options dup ","other options "]}," Thor Task initialize":{"type":"method","name":"initialize","children":[],"call":["name to_s ","args [] "]}," Thor Task dynamic":{"type":"method","name":"dynamic","children":[],"call":[]}," Thor Shell _shared_configuration":{"type":"method","name":"_shared_configuration","children":[],"call":[" merge! "," shell "]}," Thor Shell shell=":{"type":"method","name":"shell=","children":[],"call":[]}," Thor Shell shell":{"type":"method","name":"shell","children":[],"call":["Thor Base  shell new ","Thor Base  shell "]}," Thor Shell initialize":{"type":"method","name":"initialize","children":[],"call":[" shell base "," shell "," shell respond_to? "," shell= ","config [] "]}," Thor Base shell=":{"type":"method","name":"shell=","children":[],"call":[]}," Thor Base shell":{"type":"method","name":"shell","children":[],"call":["ENV  [] ! ","ENV  [] ","RbConfig CONFIG  [] =~ ","RbConfig CONFIG  [] ","Thor Shell  const_get ","ENV  [] size > ","ENV  [] size ","ENV  [] empty? ! ","ENV  [] empty? "]}," Thor Shell Color diff_lcs_loaded?":{"type":"method","name":"diff_lcs_loaded?","children":[],"call":[" require ","@diff_lcs_loaded nil? "]}," Thor Shell Color output_diff_line":{"type":"method","name":"output_diff_line","children":[],"call":[" say ","diff old_element chomp ","diff old_element ","diff new_element chomp ","diff new_element ","diff action "]}," Thor Shell Color show_diff":{"type":"method","name":"show_diff","children":[],"call":[" output_diff_line ","Diff LCS  sdiff each ","Diff LCS  sdiff ","content to_s split ","content to_s ","File  read to_s split ","File  read to_s ","File  read ","ENV  [] nil? ","ENV  [] "," diff_lcs_loaded? ","File  binread to_s split ","File  binread to_s ","File  binread ","content to_s split  to_s split ","content to_s split  to_s "]}," Thor Shell Color set_color":{"type":"method","name":"set_color","children":[],"call":[" class const_get ","color to_s upcase ","color to_s "," class ","color is_a? ","foreground to_s upcase ","foreground to_s ","foreground is_a? ","ansi_colors join "," lookup_color ","colors map ","colors all? "," can_display_colors? ! "," can_display_colors? ","colors compact empty? ","colors compact "," class const_get  to_s upcase "," class const_get  to_s "," class const_get  is_a? ","ansi_ class const_get s join "," lookup_ class const_get  "," class const_get s map "," class const_get s all? "," can_display_ class const_get s? ! "," can_display_ class const_get s? "," class const_get s compact empty? "," class const_get s compact "]}," Thor Shell Basic quiet?":{"type":"method","name":"quiet?","children":[],"call":[" base options [] "," base options "," base "," mute? "]}," Thor Shell Basic show_diff":{"type":"method","name":"show_diff","children":[],"call":[" system ","temp path ","temp rewind ","temp write ","Tempfile  open ","File  dirname ","File  basename ","ENV  [] "," require "]}," Thor Shell Basic file_collision_help":{"type":"method","name":"file_collision_help","children":[],"call":[]}," Thor Shell Basic is?":{"type":"method","name":"is?","children":[],"call":["value [] ","value size == ","value size ","value to_s ","value to_s  [] ","value to_s  size == ","value to_s  size ","value to_s  to_s "]}," Thor Shell Basic set_color":{"type":"method","name":"set_color","children":[],"call":[]}," Thor Shell Basic error":{"type":"method","name":"error","children":[],"call":["$stderr puts "," stderr puts "," stderr "]}," Thor Shell Basic file_collision":{"type":"method","name":"file_collision","children":[],"call":[" say "," file_collision_help "," show_diff "," block_given? "," is? "," raise "," ask "," fail "," loop "," merge "," merge_tool empty? ! "," merge_tool empty? "," merge_tool "]}," Thor Shell Basic print_table":{"type":"method","name":"print_table","children":[],"call":["$stdout puts ","$stdout print ","formats [] % ","column to_s ","formats [] ","row each_with_index ","table each ","formats << ","formats []= ","formats [] insert ","  * ","options [] ","maxima + ","(send\n  (lvar :table) :max) [] size ","(send\n  (lvar :table) :max) [] ","a [] size <=> ","b [] size ","b [] ","a [] size ","a [] ","table max ","0 upto ","table first length - ","table first length ","table first ","table empty? "," truncate ","sentence << ","options []= "," terminal_width ","options [] == ","options [] to_i ","start upto ","colwidth + "," stdout puts "," stdout ","f % ","column is_a? ","maximas [] ","maximas << ","(send\n  (lvar :table) :map) max ","row [] to_s size ","row [] to_s ","row [] ","table map ","colcount - ","(send\n  (lvar :table) :max) size ","a size <=> ","b size ","a size ","i == ","row size - ","row size ","index == ","array each ","(send\n  (lvar :array) :map) max ","array map ","(send\n  (lvar :array) :max) size ","array max ","array empty? "," dup ","(str \"%-\") dup ","%-s dup ","formats [] ormats [] % ","formats [] ormats [] ","formats [] ormats << ","formats [] ormats []= ","formats [] ormats [] insert ","(send\n  (lvar :table) :max) [] size  + ","maximas []  + ","(send\n  (lvar :table) :map) max  + ","(send\n  (lvar :array) :map) max  + ","table formats [] irst length - ","table formats [] irst length ","table formats [] irst "," truncate  << "," dup  << ","options []  + ","formats []  % ","(send\n  (lvar :table) :max) [] size s [] ","maximas [] s [] ","(send\n  (lvar :table) :map) max s [] ","(send\n  (lvar :array) :map) max s [] ","(send\n  (lvar :table) :max) [] size s << ","maximas [] s << ","(send\n  (lvar :table) :map) max s << ","(send\n  (lvar :array) :map) max s << ","(send\n  (lvar :table) :max) size  - ","(send\n  (lvar :array) :max) size  - "]}," Thor Shell Basic print_list":{"type":"method","name":"print_list","children":[],"call":["$stdout puts ","ident + ","list join ","list pop ","options [] ","  * ","list empty? ","  *  + "]}," Thor Shell Basic no?":{"type":"method","name":"no?","children":[],"call":[" yes? ! "," yes? ","(send\n  (send nil :ask\n    (lvar :statement)\n    (lvar :color)\n    (hash\n      (pair\n        (sym :add_to_history)\n        (false)))) :=~\n  (send nil :is?\n    (sym :no))) ! ! ","(send\n  (send nil :ask\n    (lvar :statement)\n    (lvar :color)\n    (hash\n      (pair\n        (sym :add_to_history)\n        (false)))) :=~\n  (send nil :is?\n    (sym :no))) ! "," ask =~ "," is? "," ask "]}," Thor Shell Basic yes?":{"type":"method","name":"yes?","children":[],"call":[" ask =~ "," is? "," ask ","(send\n  (send nil :ask\n    (lvar :statement)\n    (lvar :color)) :=~\n  (send nil :is?\n    (sym :yes))) ! ! ","(send\n  (send nil :ask\n    (lvar :statement)\n    (lvar :color)) :=~\n  (send nil :is?\n    (sym :yes))) ! ","(send\n  (send nil :ask\n    (lvar :statement)\n    (lvar :color)\n    (hash\n      (pair\n        (sym :add_to_history)\n        (false)))) :=~\n  (send nil :is?\n    (sym :yes))) ! ! ","(send\n  (send nil :ask\n    (lvar :statement)\n    (lvar :color)\n    (hash\n      (pair\n        (sym :add_to_history)\n        (false)))) :=~\n  (send nil :is?\n    (sym :yes))) ! "]}," Thor Shell Basic say_status":{"type":"method","name":"say_status","children":[],"call":[" say "," set_color ","status to_s rjust ","status to_s ","log_status is_a? ","   * "," padding + "," padding ","log_status == "," quiet? ","$stdout flush ","$stdout puts "," stdout flush "," stdout "," stdout puts "," stdout print ","buffer << ","buffer end_with? ","message to_s chomp gsub ","message to_s chomp ","message to_s ","  * + ","  * ","status length "," set_color  to_s rjust ","status to_s rjust  to_s rjust "," set_color  to_s ","status to_s rjust  to_s ","log_ set_color  is_a? ","log_status to_s rjust  is_a? ","log_ set_color  == ","log_status to_s rjust  == ","message to_s chomp gsub  to_s chomp gsub ","message to_s chomp gsub  to_s chomp ","message to_s chomp gsub  to_s "," set_color  length ","status to_s rjust  length "]}," Thor Shell Basic say":{"type":"method","name":"say","children":[],"call":["$stdout flush ","$stdout print ","$stdout puts "," set_color ","(or\n  (send\n    (send\n      (lvar :message) :[]\n      (int -1)\n      (int 1)) :==\n    (str \" \"))\n  (send\n    (send\n      (lvar :message) :[]\n      (int -1)\n      (int 1)) :==\n    (str \"\\t\"))) ! ","message [] == ","message [] ","message to_s ","spaces + ","   * "," padding "," stdout flush "," stdout "," stdout print "," stdout puts "," can_display_colors? ","buffer << ","message end_with? ! ","message end_with? "," prepare_message ","message to_s end_with? ! ","message to_s end_with? "," quiet? ","(or\n  (send\n    (send\n      (lvar : set_color ) :[]\n      (int -1)\n      (int 1)) :==\n    (str \" \"))\n  (send\n    (send\n      (lvar : set_color ) :[]\n      (int -1)\n      (int 1)) :==\n    (str \"\\t\"))) ! ","(or\n  (send\n    (send\n      (lvar :message to_s ) :[]\n      (int -1)\n      (int 1)) :==\n    (str \" \"))\n  (send\n    (send\n      (lvar :message to_s ) :[]\n      (int -1)\n      (int 1)) :==\n    (str \"\\t\"))) ! "," set_color  [] == ","message to_s  [] == "," set_color  [] ","message to_s  [] "," set_color  to_s ","message to_s  to_s ","   *  + "," prepare_message  << "," set_color  end_with? ! ","message to_s  end_with? ! "," set_color  end_with? ","message to_s  end_with? "," prepare_ set_color  "," prepare_message to_s  "," set_color  to_s end_with? ! ","message to_s  to_s end_with? ! "," set_color  to_s end_with? ","message to_s  to_s end_with? "]}," Thor Shell Basic ask":{"type":"method","name":"ask","children":[],"call":["$stdin gets strip ","$stdin gets "," say "," ask_simply "," ask_filtered ","options [] ","args pop ","args last is_a? ","args last ","args first ","args pop  [] "]}," Thor Shell Basic padding=":{"type":"method","name":"padding=","children":[],"call":["(int 0) max "]}," Thor Shell Basic initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Runner display_tasks":{"type":"method","name":"display_tasks","children":[],"call":["klass help "," shell "," say ","- * ","base length "," shell set_color ","base == ","klass namespace ","klass tasks empty? ","klass tasks "," print_table ","namespace size ","a [] <=> ","b [] ","a [] ","list sort! "," puts ","task description "," print ","format_string % ","task formatted_usage ","max_left + + ","max_left + ","klass tasks each ","Thor Util  constant_to_thor_path ","klass name ","Options  new ","klass opts ","klass opts empty? ","base to_a empty? ","base to_a ","klass tasks values length > ","klass tasks values length ","klass tasks values ","klass namespace  length ","Thor Util  constant_to_thor_path  length ","klass namespace  == ","Thor Util  constant_to_thor_path  == ","klass namespace  to_a empty? ","Thor Util  constant_to_thor_path  to_a empty? ","klass namespace  to_a ","Thor Util  constant_to_thor_path  to_a "]}," Runner display_klasses":{"type":"method","name":"display_klasses","children":[],"call":[" display_tasks ","klasses each ","Thor Util  thor_classes_in ","klasses dup each ","klasses dup "," say ","klasses empty? "," print_table ","info << ","hash [] join ","hash [] "," thor_yaml each "," thor_yaml ","- * ","labels [] size ","labels [] "," thor_yaml empty? ! "," thor_yaml empty? "," raise ","tasks empty? ","list each ","a [] sub <=> ","b [] sub ","b [] ","a [] sub ","a [] ","list sort ","list []= ","k printable_tasks first ","k printable_tasks ","groups map! ","list [] ","k namespace ","(send\n  (lvar :klasses) :-\n  (lvar :groups)) each ","klasses - ","k ancestors include? ","k ancestors ","klasses select ","h []= ","Hash  new "," show_modules ","k namespace split first ","k namespace split "," display_commands ","commands empty? ","k printable_commands first ","k printable_commands "," fail ","max_left_item maxima usage + ","max_left_item maxima opt ","max_left_item maxima ","max_left_item maxima usage ","(send\n  (send\n    (send\n      (lvar :x) :maxima) :usage) :+\n  (send\n    (send\n      (lvar :x) :maxima) :opt)) to_i <=> ","(send\n  (send\n    (send\n      (lvar :y) :maxima) :usage) :+\n  (send\n    (send\n      (lvar :y) :maxima) :opt)) to_i ","y maxima usage + ","y maxima opt ","y maxima ","y maxima usage ","(send\n  (send\n    (send\n      (lvar :x) :maxima) :usage) :+\n  (send\n    (send\n      (lvar :x) :maxima) :opt)) to_i ","x maxima usage + ","x maxima opt ","x maxima ","x maxima usage ","klasses max ","(send\n  (lvar :klasses) :max) name size ","(send\n  (lvar :klasses) :max) name ","Thor Util  constant_to_thor_path size <=> ","Thor Util  constant_to_thor_path size ","Thor Util  constant_to_thor_path ","y name ","x name "," puts ","(send\n  (send\n    (lvar :info) :[]\n    (sym :constants)) :map) join ","info [] map ","info [] "," print ","(str \"%-\") % ","yaml each ","namespaces_label size ","modules_label size ","(send\n  (lvar :max_name) :+\n  (int 4)) max ","modules_label size + ","max_name + ","(send\n  (lvar :yaml) :max) first size ","(send\n  (lvar :yaml) :max) first ","xk size <=> ","yk size ","xk size ","yaml max ","(lvasgn :yaml\n  (send nil :thor_yaml)) empty? ! ","(lvasgn :yaml\n  (send nil :thor_yaml)) empty? ","xk to_s size <=> ","yk to_s size ","yk to_s ","xk to_s size ","xk to_s "," thor_ thor_yaml  each "," thor_ thor_yaml  "," thor_ thor_yaml  empty? ! "," thor_ thor_yaml  empty? ","max_left_item maxima usage + _item maxima usage + ","max_left_item maxima usage + _item maxima opt ","max_left_item maxima usage + _item maxima ","max_left_item maxima usage + _item maxima usage "," thor_yaml  each ","(send\n  (lvar :(send\n  (lvar :yaml) :max) first size ) :+\n  (int 4)) max ","(send\n  (lvar :yaml) :max) first size  + ","(send\n  (lvar : thor_yaml ) :max) first size ","(send\n  (lvar : thor_yaml ) :max) first "," thor_yaml  max ","(lvasgn : thor_yaml \n  (send nil :thor_ thor_yaml )) empty? ! ","(lvasgn : thor_yaml \n  (send nil :thor_ thor_yaml )) empty? "]}," Runner thorfiles_relevant_to":{"type":"method","name":"thorfiles_relevant_to","children":[],"call":["File  join ","v [] "," thor_root ","files map ","(send\n  (send\n    (lvar :v) :[]\n    (sym :namespaces)) :&\n  (lvar :lookup)) empty? ! ","(send\n  (send\n    (lvar :v) :[]\n    (sym :namespaces)) :&\n  (lvar :lookup)) empty? ","v [] & "," thor_yaml select "," thor_yaml ","meth split [] join ","meth split [] ","meth split ","(send\n  (lvar :v) :[]\n  (sym :filename)) to_s ","(send\n  (send nil :thor_yaml) :select) map ","v [] include? ","Thor Util  to_constant "]}," Runner thorfiles":{"type":"method","name":"thorfiles","children":[],"call":["File  join ","File  directory? ","files map! "," thor_root ","Thor Util  thor_root_glob "," thorfiles_relevant_to ","thorfiles empty? ","(send\n  (send\n    (const\n      (const nil :Thor) :Util) :globs_for\n    (lvar :path)) :map) flatten ","Dir  [] ","Thor Util  globs_for map ","Thor Util  globs_for ","Pathname  pwd ascend ","Pathname  pwd "," save_yaml "," thor_yaml ","Thor Util  convert_constants_to_namespaces ","(if\n  (lvar :relevant_to)\n  (send nil :thorfiles_relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + - ","(if\n  (lvar :relevant_to)\n  (send nil :thorfiles_relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + "," thor_root_glob ","path == ","File  dirname ","(send\n  (send\n    (const\n      (const nil :Thor) :Runner) :globs_for\n    (lvar :path)) :map) flatten ","Thor Runner  globs_for map ","Thor Runner  globs_for ","Dir  pwd ","(if\n  (lvar :relevant_to)\n  (send nil :thorfiles_relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + -  map! "," (send\n  (send\n    (const\n      (const nil :Thor) :Util) :globs_for\n    (lvar :path)) :map) flatten _relevant_to "," (send\n  (send\n    (const\n      (const nil :Thor) :Runner) :globs_for\n    (lvar :path)) :map) flatten _relevant_to "," thor(if\n  (lvar :relevant_to)\n  (send nil :thorfiles_relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + - _relevant_to ","(send\n  (send\n    (const\n      (const nil :Thor) :Util) :globs_for\n    (lvar :path)) :map) flatten  empty? ","(send\n  (send\n    (const\n      (const nil :Thor) :Runner) :globs_for\n    (lvar :path)) :map) flatten  empty? ","thor(if\n  (lvar :relevant_to)\n  (send nil :thorfiles_relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + -  empty? ","(send\n  (send\n    (const\n      (const nil :Thor) :Util) :globs_for\n    (lvar :File  dirname )) :map) flatten ","(send\n  (send\n    (const\n      (const nil :Thor) :Util) :globs_for\n    (lvar :Dir  pwd )) :map) flatten ","(if\n  (lvar :relevant_to)\n  (send nil :(send\n  (send\n    (const\n      (const nil :Thor) :Util) :globs_for\n    (lvar :path)) :map) flatten _relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + - ","(if\n  (lvar :relevant_to)\n  (send nil :(send\n  (send\n    (const\n      (const nil :Thor) :Runner) :globs_for\n    (lvar :path)) :map) flatten _relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + - ","(if\n  (lvar :relevant_to)\n  (send nil :thor(if\n  (lvar :relevant_to)\n  (send nil :thorfiles_relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + - _relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + - ","(if\n  (lvar :relevant_to)\n  (send nil :(send\n  (send\n    (const\n      (const nil :Thor) :Util) :globs_for\n    (lvar :path)) :map) flatten _relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + ","(if\n  (lvar :relevant_to)\n  (send nil :(send\n  (send\n    (const\n      (const nil :Thor) :Runner) :globs_for\n    (lvar :path)) :map) flatten _relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + ","(if\n  (lvar :relevant_to)\n  (send nil :thor(if\n  (lvar :relevant_to)\n  (send nil :thorfiles_relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + - _relevant_to\n    (lvar :relevant_to))\n  (send nil :thor_root_glob)) + ","File  dirname  == ","Dir  pwd  == ","(send\n  (send\n    (const\n      (const nil :Thor) :Runner) :globs_for\n    (lvar :File  dirname )) :map) flatten ","(send\n  (send\n    (const\n      (const nil :Thor) :Runner) :globs_for\n    (lvar :Dir  pwd )) :map) flatten "]}," Runner initialize_thorfiles":{"type":"method","name":"initialize_thorfiles","children":[],"call":["Thor Util  load_thorfile ","Thor Base  subclass_files keys include? ","File  expand_path ","Thor Base  subclass_files keys ","Thor Base  subclass_files "," thorfiles each "," thorfiles "," options [] "," options "," load_thorfile ","Thor  subclass_files keys include? ","Thor  subclass_files keys ","Thor  subclass_files "]}," Runner save_yaml":{"type":"method","name":"save_yaml","children":[],"call":["f puts ","yaml to_yaml ","File  open ","FileUtils  touch ","File  join "," thor_root ","FileUtils  mkdir_p ","File  exists? ","File  exist? "," require "]}," Runner thor_yaml":{"type":"method","name":"thor_yaml","children":[],"call":["YAML  load_file ","File  exists? ","File  join "," thor_root ","File  exist? "]}," Runner thor_root":{"type":"method","name":"thor_root","children":[],"call":["Thor Util  thor_root "," class thor_root "," class "]}," Runner list":{"type":"method","name":"list","children":[],"call":[" display_klasses ","k namespace =~ ","k namespace ","k group == ","k group "," options [] "," options ","Thor Base  subclasses select ","Thor Base  subclasses "," initialize_thorfiles ","Thor Util  constant_to_thor_path =~ ","Thor Util  constant_to_thor_path ","k name ","Thor  subclasses select ","Thor  subclasses ","k group_name == ","k group_name "]}," Runner installed":{"type":"method","name":"installed","children":[],"call":[" display_klasses "," options [] "," options ","Thor Base  subclasses "," initialize_thorfiles ","Thor  subclasses "," load_thorfile ","Thor  subclass_files keys include? ","File  expand_path ","Thor  subclass_files keys ","Thor  subclass_files ","f =~ "," thor_root_glob each "," thor_root_glob "," display_Thor Base  subclasses  "," display_Thor  subclasses  "]}," Runner update":{"type":"method","name":"update","children":[],"call":["File  delete ","File  join "," thor_root ","filename == "," install "," thor_yaml [] [] "," thor_yaml [] "," thor_yaml "," options= "," options merge "," options "," say "," raise "," thor_yaml [] [] ! "," thor_yaml [] ! "," save_yaml "," thor_yaml delete ","FileUtils  rm_rf ","File  directory? ","File  expand_path "," fail "," require ","yaml [] [] ","yaml [] "," options []= "," puts ","yaml [] [] ! ","yaml [] ! "," install  == "," thor_ thor_yaml  [] [] "," thor_ thor_yaml  [] "," thor_ thor_yaml  "," thor_ thor_yaml  [] [] ! "," thor_ thor_yaml  [] ! "," save_ thor_yaml  "," thor_ thor_yaml  delete "," thor_yaml  [] [] "," thor_yaml  [] "," thor_yaml  [] [] ! "," thor_yaml  [] ! "]}," Runner uninstall":{"type":"method","name":"uninstall","children":[],"call":[" puts "," save_yaml "," thor_yaml "," thor_yaml delete ","FileUtils  rm_rf ","File  join "," thor_yaml [] [] "," thor_yaml [] "," thor_root "," say "," raise "," fail ","(send\n  (send\n    (send nil :thor_yaml) :[]\n    (lvar :name)) :[]\n  (sym :filename)) to_s "," require ","yaml delete ","File  delete ","yaml [] [] ","yaml [] "," save_ thor_yaml  "," thor_ thor_yaml  "," thor_ thor_yaml  delete "," thor_ thor_yaml  [] [] "," thor_ thor_yaml  [] ","(send\n  (send\n    (send nil :thor_yaml) :[]\n    (lvar :name)) :[]\n  (sym :File  join name)) to_s ","(send\n  (send\n    (send nil :thor_ thor_yaml ) :[]\n    (lvar :name)) :[]\n  (sym :filename)) to_s "," thor_yaml  delete "," thor_yaml  [] [] "," thor_yaml  [] "]}," Runner install":{"type":"method","name":"install","children":[],"call":[" thor_yaml [] [] "," thor_yaml [] "," thor_yaml ","FileUtils  cp_r ","f puts ","File  open ","package == ","File  join "," thor_root "," say "," save_yaml "," thor_yaml []= ","Thor Util  namespaces_in_content ","Digest MD5  hexdigest ","name + ","File  expand_path ","name =~ "," options [] "," options ","as empty? "," ask ","File  basename ","match [] strip ","match [] ","first_line match ","contents split [] ","contents split "," no? "," raise "," open read "," open ","File  directory? "," initialize_thorfiles ","input read "," fail "," require ","yaml [] [] ","yaml [] ","file puts "," puts ","yaml []= ","FileUtils  touch ","FileUtils  mkdir_p ","Readline  readline "," print ","as ! ","Thor Util  constants_in_contents ","response =~ ","File  exist? ","Digest SHA256  hexdigest ","URI  send "," thor_ thor_yaml  [] [] "," thor_ thor_yaml  [] "," thor_ thor_yaml  "," save_ thor_yaml  "," thor_ thor_yaml  []= "," ask  empty? ","Readline  readline  empty? ","  ask k "," Readline  readline k ","File  b ask ename ","File  bReadline  readline ename ","File  File  basename  ","File  File  join name ","first_line match  [] strip ","first_line match  [] ","first_line first_line match  ","contents split []  match "," open read  split [] "," open  split [] ","URI  send  split [] ","File  open  split [] "," open read  split "," open  split ","URI  send  split ","File  open  split "," thor_yaml  [] [] "," thor_yaml  [] "," thor_yaml  []= "," ask  ! ","Readline  readline  ! ","Thor Util  constants_in_ open read  ","Thor Util  constants_in_ open  ","Thor Util  constants_in_URI  send  ","Thor Util  constants_in_File  open  ","Thor Util  Thor Util  constants_in_contents _in_contents ","Readline  readline  =~ "]}," Runner method_missing":{"type":"method","name":"method_missing","children":[],"call":["klass start "," shell ","args unshift ","Thor Util  namespace_to_thor_class_and_task "," initialize_thorfiles ","meth to_s ","Thor Util  find_class_and_task_by_namespace! ","Thor Util  find_class_and_task_by_namespace "," class handle_no_task_error "," class ","klass nil? "," class handle_no_command_error ","Thor Util  find_class_and_command_by_namespace ","task parse ","ARGV  [] ","task klass new ","task klass ","Thor  [] ","meth to_sym ","meth include? ","Thor Util  namespace_to_thor_class_and_Thor  []  ","meth to_s  to_s ","Thor Util  find_class_and_Thor  [] _by_namespace! ","Thor Util  find_class_and_Thor  [] _by_namespace "," class handle_no_Thor  [] _error ","Thor  []  parse ","Thor  []  klass new ","Thor  []  klass ","meth to_s  to_sym ","meth to_s  include? "]}," Runner help":{"type":"method","name":"help","children":[],"call":["klass start "," shell ","(str \"-h\") compact ","Thor Util  namespace_to_thor_class_and_task "," initialize_thorfiles "," respond_to? ! "," respond_to? ","Thor Util  find_class_and_task_by_namespace! ","Thor Util  find_class_and_task_by_namespace "," class handle_no_task_error "," class ","klass nil? "," class handle_no_command_error ","Thor Util  find_class_and_command_by_namespace ","task include? "]}," Object namespace":{"type":"method","name":"namespace","children":[],"call":["Thor RakeCompat  rake_classes pop ","Thor RakeCompat  rake_classes "," rake_namespace ","Thor RakeCompat  rake_classes << ","klass const_get ","klass const_set ","Class  new ","Thor Util  camel_case to_sym ","Thor Util  camel_case ","name to_s ","Thor RakeCompat  rake_classes last ","Thor RakeCompat  rake_classes last  const_get ","Thor RakeCompat  rake_classes last  const_set "]}," Object task":{"type":"method","name":"task","children":[],"call":["klass class_eval ","task arg_names join ","task arg_names ","task name to_sym inspect ","task name to_sym ","task name ","klass desc ","task comment ","description strip! ","description << ","(send\n  (send\n    (lvar :task) :arg_names) :map) join ","n to_s upcase ","n to_s ","task arg_names map ","task name split last ","task name split ","Thor RakeCompat  rake_classes last ","Thor RakeCompat  rake_classes "," rake_task ","Rake Task  [] invoke ","Rake Task  [] ","klass send ","Thor RakeCompat  rake_classes last  class_eval "," rake_task  arg_names join "," rake_task  arg_names "," rake_task  name to_sym inspect "," rake_task  name to_sym "," rake_task  name ","Thor RakeCompat  rake_classes last  desc "," rake_task  comment ","(send\n  (send\n    (lvar : rake_task ) :arg_names) :map) join "," rake_task  arg_names map "," rake_task  name split last "," rake_task  name split "," rake_ rake_task  ","Thor RakeCompat  rake_classes last  send "]}," Thor RakeCompat included":{"type":"method","name":"included","children":[],"call":[]}," Thor RakeCompat rake_classes":{"type":"method","name":"rake_classes","children":[],"call":[]}," Thor Options parse_peek":{"type":"method","name":"parse_peek","children":[],"call":[" send ","option type ","@non_assigned_required delete "," raise ","option human_name ","option required? ! ","option required? ","option string? "," no_or_skip? ","option boolean? "," current_is_value? ","option default "," last? "," current_is_switch_formatted? ","option lazy_default "," parsing_options? "," fail "]}," Thor Options parse_boolean":{"type":"method","name":"parse_boolean","children":[],"call":[" no_or_skip? ! "," no_or_skip? ","@switches key? ","(str \"true\") include? "," shift "," current_is_value? ","(str \"false\") include? "," peek "]}," Thor Options normalize_switch":{"type":"method","name":"normalize_switch","children":[],"call":["@shorts [] ","@shorts key? ","(or\n  (send\n    (ivar :@shorts) :[]\n    (lvar :arg))\n  (lvar :arg)) tr "]}," Thor Options no_or_skip?":{"type":"method","name":"no_or_skip?","children":[],"call":["arg =~ "]}," Thor Options switch_option":{"type":"method","name":"switch_option","children":[],"call":["@switches [] "," no_or_skip? "]}," Thor Options switch?":{"type":"method","name":"switch?","children":[],"call":["@shorts key? "," switch_option "," normalize_switch "," switch_option nil? ! "," switch_option nil? "]}," Thor Options current_is_switch?":{"type":"method","name":"current_is_switch?","children":[],"call":[" switch? ","1 split any? ","1 split "," peek "]}," Thor Options parse":{"type":"method","name":"parse","children":[],"call":[" check_requirement! "," shift ","@assigns []= "," parse_peek ","option human_name "," switch_option "," normalize_switch "," unshift ","1 split map ","1 split "," current_is_switch? "," peek ","args dup ","assigns freeze ","Thor CoreExt HashWithIndifferentAccess  new ","@unknown << "," peek =~ "," current_is_switch_formatted? "," except_underscores ","@extra << "," peek !~ "," parsing_options? ","@extra size ","hash freeze "," check_required! ","hash []= "," shift to_i "," shift to_f ","$& index "," raise "," peek inspect ","$& == "," assert_value! "," valid? "," peek nil? "," switch_type "," undasherize "," current_is_option? ","@leading_non_opts << ","@args empty? ","Hash  new "," assign_result! ","@Thor CoreExt HashWithIndifferentAccess  new  []= "," switch_option  human_name "," switch_ switch_option  ","  normalize_switch _option "," normalize_ normalize_switch  "," current_is_ normalize_switch ? ","Thor CoreExt HashWithIndifferentAccess  new  freeze "," current_is_ normalize_switch _formatted? "," parsing_ switch_option s? ","Hash  new  freeze ","Hash  new  []= ","  normalize_switch _type "," switch_ switch_type  "," current_is_ switch_option ? "," assign_ parse_peek ! "]}," Thor Options initialize":{"type":"method","name":"initialize","children":[],"call":["option switch_name ","@shorts [] ","short to_s ","option aliases each ","option aliases ","@switches []= ","options each ","options values ","@non_assigned_required delete ","hash_options [] ","@assigns []= ","key to_s ","defaults each ","hash_options values ","short to_s sub ","@shorts delete ","@switches key? ","@shorts keys each ","@shorts keys ","mem []= ","@defaults []= ","@shorts []= ","shorts each ","shorts << ","- + ","nice_name [] ","nice_name length > ","nice_name length ","shorts empty? "," dasherize "," undasherize ","name index == ","name index ","name to_s ","name is_a? ","switches inject ","option switch_short to_s sub  ","option switch_ dasherize  ","option switch_name to_s  ","options values  each ","hash_options values  each ","options values  values ","hash_options values  values ","hash_options values  [] ","hash_hash_options values  [] ","hash_hash_options values  values ","nice_short to_s sub  [] ","nice_ dasherize  [] ","nice_name to_s  [] "," undasherize  [] ","nice_short to_s sub  length > ","nice_ dasherize  length > ","nice_name to_s  length > "," undasherize  length > ","nice_short to_s sub  length ","nice_ dasherize  length ","nice_name to_s  length "," undasherize  length ","short to_s sub  index == "," dasherize  index == ","name to_s  index == ","short to_s sub  index "," dasherize  index ","name to_s  index ","short to_s sub  to_s "," dasherize  to_s ","name to_s  to_s ","short to_s sub  is_a? "," dasherize  is_a? ","name to_s  is_a? "]}," Thor Options to_switches":{"type":"method","name":"to_switches","children":[],"call":[]}," Thor Option dasherize":{"type":"method","name":"dasherize","children":[],"call":["(if\n  (send\n    (send\n      (lvar :str) :length) :>\n    (int 1))\n  (str \"--\")\n  (str \"-\")) + ","str gsub ","str length > ","str length ","str tr "]}," Thor Option undasherize":{"type":"method","name":"undasherize","children":[],"call":["str sub "]}," Thor Option dasherized?":{"type":"method","name":"dasherized?","children":[],"call":[" name index == "," name index "," name "]}," Thor Option valid_type?":{"type":"method","name":"valid_type?","children":[],"call":["VALID_TYPES  include? ","type to_sym "]}," Thor Option validate!":{"type":"method","name":"validate!","children":[],"call":[" raise "," required? "," boolean? "," fail "," validate_default_type! "]}," Thor Option method_missing":{"type":"method","name":"method_missing","children":[],"call":[" type == "," type "," valid_type? ","method to_s sub to_sym ","method to_s sub ","method to_s "]}," Thor Option usage":{"type":"method","name":"usage","children":[],"call":[" aliases join "," aliases ","(send\n  (str \" \") :*\n  (lvar :padding)) << ","  * "," aliases empty? "," required? "," switch_name "," banner "," banner to_s empty? ! "," banner to_s empty? "," banner to_s ","sample << "," dasherize ","no- + "," human_name "," name == "," name "," boolean? "," name start_with? ","(str \"[\") dup ","(begin\n  (send nil :switch_name)) dup "," aliases_for_usage ljust + "," aliases_for_usage ljust "," aliases_for_usage "," switch_name  << ","(str \"[\") dup  << ","(begin\n  (send nil :switch_name)) dup  << "]}," Thor Option human_name":{"type":"method","name":"human_name","children":[],"call":[" name "," undasherize "," dasherized? "]}," Thor Option switch_name":{"type":"method","name":"switch_name","children":[],"call":[" dasherize "," name "," dasherized? "]}," Thor Option parse":{"type":"method","name":"parse","children":[],"call":[]}," Thor Option initialize":{"type":"method","name":"initialize","children":[],"call":["group to_s capitalize ","group to_s ","(splat\n  (lvar :aliases)) compact ","options [] "," Array ","options [] to_s capitalize ","options [] to_s ","options []= ","options key? ","options fetch "]}," Thor Arguments check_requirement!":{"type":"method","name":"check_requirement!","children":[],"call":[" raise "," class name split last downcase "," class name split last "," class name split "," class name "," class ","(send\n  (ivar :@non_assigned_required) :map) join ","o human_name ","o switch_name ","o respond_to? ","@non_assigned_required map ","@non_assigned_required empty? "," fail "]}," Thor Arguments parse_string":{"type":"method","name":"parse_string","children":[],"call":[" shift "," no_or_skip? "," raise ","switch enum join ","switch enum ","switch enum include? ! ","switch enum include? ","@switches [] ","@switches is_a? "," fail ","@switches []  enum join ","@switches []  enum ","@switches []  enum include? ! ","@switches []  enum include? ","@@switches [] es [] ","@@switches [] es is_a? "]}," Thor Arguments parse_numeric":{"type":"method","name":"parse_numeric","children":[],"call":[" shift to_i "," shift "," shift to_f ","$& index "," raise "," peek inspect "," peek ","$& == "," peek =~ "," peek is_a? "," fail ","switch enum join ","switch enum ","switch enum include? ! ","switch enum include? ","@switches [] ","@switches is_a? ","@switches []  enum join ","@switches []  enum ","@switches []  enum include? ! ","@switches []  enum include? ","@@switches [] es [] ","@@switches [] es is_a? "]}," Thor Arguments parse_array":{"type":"method","name":"parse_array","children":[],"call":["array << "," shift "," current_is_value? "," peek is_a? "," peek "]}," Thor Arguments parse_hash":{"type":"method","name":"parse_hash","children":[],"call":["hash []= "," shift split "," shift "," peek include? "," peek "," current_is_value? "," peek is_a? "," raise ","hash [] ","hash include? "]}," Thor Arguments current_is_value?":{"type":"method","name":"current_is_value?","children":[],"call":[" peek to_s !~ "," peek to_s "," peek "]}," Thor Arguments unshift":{"type":"method","name":"unshift","children":[],"call":["@pile unshift ","arg + ","arg kind_of? ","arg is_a? ","arg +  unshift "]}," Thor Arguments shift":{"type":"method","name":"shift","children":[],"call":["@pile shift "]}," Thor Arguments peek":{"type":"method","name":"peek","children":[],"call":["@pile first "]}," Thor Arguments parse":{"type":"method","name":"parse","children":[],"call":[" check_requirement! ","@assigns []= "," send ","argument human_name ","argument type ","@non_assigned_required delete "," peek ","@switches each ","args dup "]}," Thor Arguments initialize":{"type":"method","name":"initialize","children":[],"call":["@non_assigned_required << ","argument required? ","@assigns []= ","argument default ","argument human_name ","arguments each ","argument default != ","argument default nil? ! ","argument default nil? ","argument default dup "]}," Thor Arguments split":{"type":"method","name":"split","children":[],"call":[]}," Thor Argument default_banner":{"type":"method","name":"default_banner","children":[],"call":[" human_name upcase "," human_name "," type "]}," Thor Argument valid_type?":{"type":"method","name":"valid_type?","children":[],"call":["VALID_TYPES  include? ","type to_sym "," class VALID_TYPES  include? "," class "]}," Thor Argument validate!":{"type":"method","name":"validate!","children":[],"call":[" raise "," default nil? ! "," default nil? "," default "," required? ","@enum is_a? ! ","@enum is_a? "," fail "]}," Thor Argument show_default?":{"type":"method","name":"show_default?","children":[],"call":[" default "," default empty? ! "," default empty? "]}," Thor Argument required?":{"type":"method","name":"required?","children":[],"call":[" required "]}," Thor Argument usage":{"type":"method","name":"usage","children":[],"call":[" banner "," required? "]}," Thor Argument initialize":{"type":"method","name":"initialize","children":[],"call":[" validate! "," default_banner ","(or\n  (lvar :type)\n  (sym :string)) to_sym ","name to_s "," raise ","class_name downcase "," valid_type? ! "," valid_type? ","name nil? "," class name split last "," class name split "," class name "," class ","options [] ","options key? "," fail ","(or\n  (lvar :options [] )\n  (sym :string)) to_sym "," class name split last  downcase "," valid_options [] ? ! "," valid_options [] ? "]}," Thor Invocation _initialize_klass_with_initializer":{"type":"method","name":"_initialize_klass_with_initializer","children":[],"call":["object class ","klass new ","stored_config merge merge! ","stored_config merge "," _shared_configuration ","stored_opts dup ","stored_args dup ","object is_a? ","stored_stored_config merge merge!  merge merge! ","stored_stored_config merge merge!  merge "," _shared_stored_config merge merge! uration "]}," Thor Invocation _validate_task":{"type":"method","name":"_validate_task","children":[],"call":["Task  dynamic ","klass all_tasks [] ","task to_s ","klass all_tasks ","task is_a? ! ","task is_a? ","klass default_task ","klass <= "," raise ","object class ","object is_a? ","Thor Task Dynamic  new ","klass respond_to? ","Thor DynamicTask  new ","object class  all_tasks [] ","object class  all_tasks ","object class  default_task ","object class  <= ","object class  respond_to? "]}," Thor Invocation _prepare_for_invocation":{"type":"method","name":"_prepare_for_invocation","children":[],"call":[" _validate_task "," class prepare_for_invocation "," class "," class all_tasks [] ","name to_s "," class all_tasks ","name is_a? "," _validate_ class all_tasks []  "," class all_ class all_tasks [] s [] "," class all_ class all_tasks [] s "]}," Thor Invocation _shared_configuration":{"type":"method","name":"_shared_configuration","children":[],"call":[]}," Thor Invocation invoke":{"type":"method","name":"invoke","children":[],"call":["klass all_tasks map ","klass all_tasks ","iterator call ","args [] ","Range  new ","klass arguments size ","klass arguments ","task run ","current << ","task name ","current include? "," proc ","@_invocations [] "," _initialize_klass_with_initializer "," _prepare_for_invocation ","args is_a? ","task is_a? ","task nil? ","args unshift ","NilClass  === ","args first ","Array  === ","klass send "," _parse_initialization_options "," raise ","klass <= "," _retrieve_class_and_task "," invoke_all "," warn "," caller join "," caller ","name nil? ","instance parent_options= "," options "," _retrieve_class_and_command "," fail ","args first nil? ","args first is_a? ","@_invocations []  << ","@_invocations []  include? "]}," Thor Invocation initialize":{"type":"method","name":"initialize","children":[],"call":["h []= ","Hash  new ","config [] "]}," Thor Invocation ClassMethods prepare_for_invocation":{"type":"method","name":"prepare_for_invocation","children":[],"call":["Thor Util  namespace_to_thor_class_and_task ","name to_s ","Thor Util  find_class_and_task_by_namespace ","key ! ","Thor Util  find_class_and_command_by_namespace "]}," Thor Invocation included":{"type":"method","name":"included","children":[],"call":[]}," Group _invoke_for_class_method":{"type":"method","name":"_invoke_for_class_method","children":[],"call":[" shell padding "," shell "," invoke ","block call ","block arity == ","block arity "," block_given? "," instance_exec "," with_padding "]}," Group create_task":{"type":"method","name":"create_task","children":[],"call":[" tasks []= ","Thor Task  new ","meth to_s "," tasks "]}," Group baseclass":{"type":"method","name":"baseclass","children":[],"call":[]}," Group banner":{"type":"method","name":"banner","children":[],"call":["(send\n  (send\n    (self) :arguments) :map) join ","a usage "," arguments map "," arguments "," namespace "," self_task formatted_usage "," self_task ","File  basename ","$0 split first ","$0 split "," banner_base "," basename "," self_command formatted_usage "," self_command ","File  File  basename name "," banner_File  basename  "," File  basename name "]}," Group get_options_from_invocations":{"type":"method","name":"get_options_from_invocations","children":[],"call":[" block_given? ","(send\n  (send\n    (send\n      (lvar :group_options) :values) :flatten) :any?) ! ","i name == ","option name ","i name ","group_options values flatten any? ","group_options values flatten ","group_options values ","option group nil? ","option group ","base_options [] nil? ","base_options [] ","option name to_sym ","klass class_options values select ","klass class_options values ","klass class_options ","group_options [] ","value classify ","value respond_to? ","value to_s ","klass respond_to? "," prepare_for_invocation ","option default ","option type == ","option type "," class_options [] "," class_options "," invocations each "," invocations ","class_option name ","class_option group nil? ","class_option group ","class_option name to_sym ","(send\n  (send\n    (send\n      (lvar :group_options) :value to_s s) :flatten) :any?) ! ","(send\n  (send\n    (send\n      (lvar :group_ class_options [] s) :values) :flatten) :any?) ! "," class_options []  name ","group_options value to_s s flatten any? ","group_ class_options [] s values flatten any? ","group_options value to_s s flatten ","group_ class_options [] s values flatten ","group_options value to_s s ","group_ class_options [] s values "," class_options []  group nil? "," class_options []  group ","base_ class_options [] s [] nil? ","base_ class_options [] s [] "," class_options []  name to_sym ","klass class_options value to_s s select ","klass class_ class_options [] s values select ","klass class_options value to_s s ","klass class_ class_options [] s values ","klass class_ class_options [] s ","group_ class_options [] s [] ","value to_s  classify ","value to_s  respond_to? ","value to_s  to_s "," class_options []  default "," class_options []  type == "," class_options []  type "," class_ class_options [] s [] "," class_ class_options [] s ","class_ class_options []  name ","class_ class_options []  group nil? ","class_ class_options []  group ","class_ class_options []  name to_sym "]}," Group class_options_help":{"type":"method","name":"class_options_help","children":[],"call":["group_options merge! ","klass send "," class_options "," get_options_from_invocations "]}," Group remove_invocation":{"type":"method","name":"remove_invocation","children":[],"call":[" invocation_blocks delete "," invocation_blocks "," invocations delete "," invocations "," remove_class_option "," remove_task ","names each "," remove_command "]}," Group invoke_from_option":{"type":"method","name":"invoke_from_option","children":[],"call":[" class_eval ","name inspect ","verbose inspect ","name to_s gsub ","name to_s "," invocation_blocks []= "," invocation_blocks "," block_given? "," invocations []= "," invocations "," raise ","(str \"You have to define the option \") << "," class_options key? "," class_options ","names each ","options fetch ","names pop ","names last is_a? ","names last "," fail ","123 + ","options fetch  inspect "," class_names pop  key? "," class_names pop  ","names pop  fetch "]}," Group invoke":{"type":"method","name":"invoke","children":[],"call":[" class_eval ","name inspect ","verbose inspect ","name to_s gsub ","name to_s "," invocation_blocks []= "," invocation_blocks "," block_given? "," invocations []= "," invocations ","names each ","options fetch ","names pop ","names last is_a? ","names last ","64 + ","options fetch  inspect ","names pop  fetch "]}," Group invocation_blocks":{"type":"method","name":"invocation_blocks","children":[],"call":[" from_superclass "]}," Group invocations":{"type":"method","name":"invocations","children":[],"call":[" from_superclass "]}," Group help":{"type":"method","name":"help","children":[],"call":["shell say "," desc "," class_options_help "," banner ","options [] "]}," Group start":{"type":"method","name":"start","children":[],"call":[" new invoke "," new ","Thor Options  split "," help ","config [] ","Thor HELP_MAPPINGS  include? ","given_args first "]}," Group desc":{"type":"method","name":"desc","children":[],"call":[" from_superclass "]}," Thor CoreExt OrderedHash empty?":{"type":"method","name":"empty?","children":[],"call":["@hash empty? "]}," Thor CoreExt OrderedHash merge":{"type":"method","name":"merge","children":[],"call":["hash []= ","other each "," each "," class new "," class "," dup merge! "," dup "," class new  []= "]}," Thor CoreExt OrderedHash each":{"type":"method","name":"each","children":[],"call":["node value ","node key ","node next ","@first value ","@first key "," [] ","@keys each "," to_enum "," block_given? ","node next  value ","node next  key ","node next  next "]}," Thor CoreExt OrderedHash values":{"type":"method","name":"values","children":[],"call":[" map "," [] ","@keys map "]}," Thor CoreExt OrderedHash keys":{"type":"method","name":"keys","children":[],"call":[" map ","@keys dup "]}," Thor CoreExt OrderedHash delete":{"type":"method","name":"delete","children":[],"call":["@hash delete ","node value ","@last == ","@first == ","prev_node next= ","next_node prev= ","node next ","node prev ","@hash [] ","@keys delete_at ","@keys index "," key? ","node node value  ","@hash []  value ","node prev  next= ","prev_@hash []  next= ","node next  prev= ","next_@hash []  prev= ","@hash []  next ","@hash []  prev ","@keys @keys index  "]}," Thor CoreExt OrderedHash []=":{"type":"method","name":"[]=","children":[],"call":["@hash []= ","@last next= ","node prev= ","@first nil? ","Node  new ","node value= ","@hash [] ","(ivar :@first) ! ","@keys << "," key? ","Node  new  prev= ","@hash []  prev= ","Node  new  value= ","@hash []  value= "]}," Thor CoreExt OrderedHash []":{"type":"method","name":"[]","children":[],"call":["@hash [] value ","@hash [] "]}," Thor CoreExt OrderedHash initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Thor CoreExt HashWithIndifferentAccess method_missing":{"type":"method","name":"method_missing","children":[],"call":[" [] "," [] == ","args first "," [] ! ! "," [] ! ","args empty? ","method =~ ","method to_s ","method to_s  =~ ","method to_s  to_s "]}," Thor CoreExt HashWithIndifferentAccess convert_key":{"type":"method","name":"convert_key","children":[],"call":["key to_s ","key is_a? "]}," Thor CoreExt HashWithIndifferentAccess merge!":{"type":"method","name":"merge!","children":[],"call":[" []= "," convert_key ","other each "]}," Thor CoreExt HashWithIndifferentAccess merge":{"type":"method","name":"merge","children":[],"call":[" dup merge! "," dup "]}," Thor CoreExt HashWithIndifferentAccess values_at":{"type":"method","name":"values_at","children":[],"call":[" [] "," convert_key ","indices collect ","indices map "]}," Thor CoreExt HashWithIndifferentAccess delete":{"type":"method","name":"delete","children":[],"call":[" convert_key "]}," Thor CoreExt HashWithIndifferentAccess []=":{"type":"method","name":"[]=","children":[],"call":[" convert_key "]}," Thor CoreExt HashWithIndifferentAccess []":{"type":"method","name":"[]","children":[],"call":[" convert_key "]}," Thor CoreExt HashWithIndifferentAccess initialize":{"type":"method","name":"initialize","children":[],"call":[" []= "," convert_key ","hash each "]}," Thor Base ClassMethods initialize_added":{"type":"method","name":"initialize_added","children":[],"call":[]}," Thor Base ClassMethods create_task":{"type":"method","name":"create_task","children":[],"call":[]}," Thor Base ClassMethods baseclass":{"type":"method","name":"baseclass","children":[],"call":[]}," Thor Base ClassMethods from_superclass":{"type":"method","name":"from_superclass","children":[],"call":["value dup "," superclass send "," superclass "," superclass respond_to? ! "," superclass respond_to? "," == "," baseclass ","value is_a? "," superclass send  dup "," superclass send  is_a? "]}," Thor Base ClassMethods method_added":{"type":"method","name":"method_added","children":[],"call":["Thor Base  register_klass_file "," is_thor_reserved_word? "," create_task ! "," create_task "," public_instance_methods include? ","meth to_sym "," public_instance_methods "," initialize_added ","meth == ","meth to_s "," create_command ! "," create_command "," caller first to_s [] "," caller first to_s "," caller first "," caller "," public_method_defined? "," thor_reserved_word? "," no_commands? "," public_instance_meth to_s ods include? ","meth to_s  to_sym "," public_instance_meth to_s ods ","meth to_s  == ","meth to_s  to_s "," public_meth to_s od_defined? "]}," Thor Base ClassMethods inherited":{"type":"method","name":"inherited","children":[],"call":["Thor Base  register_klass_file ","klass instance_variable_set "]}," Thor Base ClassMethods find_and_refresh_task":{"type":"method","name":"find_and_refresh_task","children":[],"call":[" raise ","name inspect "," tasks []= ","task clone ","name to_s "," tasks "," all_tasks [] "," all_tasks "," tasks [] ","  all_tasks [] s []= ","  tasks [] s []= "," all_tasks []  clone "," tasks []  clone ","  all_tasks [] s ","  tasks [] s "," all_ all_tasks [] s [] "," all_ tasks [] s [] "," all_ all_tasks [] s "," all_ tasks [] s ","  all_tasks [] s [] ","  tasks [] s [] "]}," Thor Base ClassMethods build_options":{"type":"method","name":"build_options","children":[],"call":["scope []= ","Thor Option  parse ","options each "]}," Thor Base ClassMethods build_option":{"type":"method","name":"build_option","children":[],"call":["scope []= ","Thor Option  new ","options [] ","options merge "," check_default_type? ","(pair\n  (sym :check_default_type)\n  (send nil :check_default_type)) merge! "," check_default_type "]}," Thor Base ClassMethods is_thor_reserved_word?":{"type":"method","name":"is_thor_reserved_word?","children":[],"call":[" raise ","word inspect ","THOR_RESERVED_WORDS  include? ","word to_s "," fail "]}," Thor Base ClassMethods class_options_help":{"type":"method","name":"class_options_help","children":[],"call":["groups each ","extra_group merge ","printer call ","groups delete ","shell say ","shell print_table ","list empty? ","list << ","option default ","option show_default? ","item push ","option description ","option usage ","options each ","(send\n  (lvar :options) :collect) max to_i * ","(send\n  (lvar :options) :collect) max to_i ","(send\n  (lvar :options) :collect) max ","o aliases size ","o aliases ","options collect "," proc ","groups [] << ","groups [] ","value group "," class_options each "," class_options "," print_options ","extra_group merge  each ","extra_group merge  delete ","extra_group merge  [] << ","extra_group merge  [] "]}," Thor Base ClassMethods start":{"type":"method","name":"start","children":[],"call":["config [] error ","e message ","config [] "," raise ","given_args include? ","Thor Base  shell new ","Thor Base  shell "," exit "," exit_on_failure? "," debugging "," debugging= ","given_args dup "," dispatch ","given_args delete ","ENV  [] == ","ENV  [] "]}," Thor Base ClassMethods namespace":{"type":"method","name":"namespace","children":[],"call":["name to_s ","Thor Util  namespace_from_thor_class "]}," Thor Base ClassMethods no_tasks":{"type":"method","name":"no_tasks","children":[],"call":[]}," Thor Base ClassMethods remove_task":{"type":"method","name":"remove_task","children":[],"call":[" undef_method ","options [] "," all_tasks delete ","name to_s "," all_tasks "," tasks delete "," tasks ","names each ","names pop ","names last is_a? ","names last ","names pop  [] "]}," Thor Base ClassMethods all_tasks":{"type":"method","name":"all_tasks","children":[],"call":["@all_tasks merge "," tasks "," from_superclass ","Thor CoreExt OrderedHash  new "]}," Thor Base ClassMethods tasks":{"type":"method","name":"tasks","children":[],"call":["Thor CoreExt OrderedHash  new "]}," Thor Base ClassMethods group":{"type":"method","name":"group","children":[],"call":["name to_s "," from_superclass "]}," Thor Base ClassMethods remove_class_option":{"type":"method","name":"remove_class_option","children":[],"call":[" class_options delete "," class_options ","names each "]}," Thor Base ClassMethods remove_argument":{"type":"method","name":"remove_argument","children":[],"call":[" undef_method ","options [] ","a name == ","name to_s ","a name "," arguments delete_if "," arguments ","names each ","names pop ","names last is_a? ","names last ","names pop  [] "]}," Thor Base ClassMethods class_option":{"type":"method","name":"class_option","children":[],"call":[" build_option "," class_options "]}," Thor Base ClassMethods class_options":{"type":"method","name":"class_options","children":[],"call":[" build_options "," from_superclass "]}," Thor Base ClassMethods arguments":{"type":"method","name":"arguments","children":[],"call":[" from_superclass "]}," Thor Base ClassMethods argument":{"type":"method","name":"argument","children":[],"call":[" arguments << ","Thor Argument  new ","options [] "," arguments "," raise ","(str \"You cannot have \") << ","argument human_name inspect ","argument human_name ","name to_s inspect ","name to_s ","argument required? "," arguments each "," remove_argument ","options [] nil? ","options key? ","options [] ! "," attr_accessor "," no_tasks "," is_thor_reserved_word? ","options []= "," no_commands "," fail "," thor_reserved_word? ","argument options [] ! ? "]}," Thor Base register_klass_file":{"type":"method","name":"register_klass_file","children":[],"call":["file_subclasses << ","file_subclasses include? ","Thor Base  subclass_files [] ","File  expand_path ","Thor Base  subclass_files ","Thor Base  subclasses << ","Thor Base  subclasses ","Thor Base  subclasses include? "," caller [] match [] "," caller [] match "," caller [] "," caller ","Thor Base  subclass_files []  << "," caller [] match [] _subclasses << ","Thor Base  subclass_files []  include? "," caller [] match [] _subclasses include? ","Thor Base  subclass_ caller [] match [] s [] ","Thor Base  subclass_ caller [] match [] s "]}," Thor Base subclass_files":{"type":"method","name":"subclass_files","children":[],"call":["h []= ","Hash  new "]}," Thor Base subclasses":{"type":"method","name":"subclasses","children":[],"call":[]}," Thor Base included":{"type":"method","name":"included","children":[],"call":["base send ","base extend "]}," Thor Base initialize":{"type":"method","name":"initialize","children":[],"call":[" options freeze "," options "," options= ","Thor CoreExt HashWithIndifferentAccess  new merge! ","Thor CoreExt HashWithIndifferentAccess  new ","Thor Options  parse ","parse_options merge ","config delete ","options is_a? "," class class_options "," class "," send ","Thor Arguments  parse each ","Thor Arguments  parse "," class arguments ","opts check_unknown! "," class check_unknown_options? ","opts parse ","Thor Options  new ","args each ","thor_args remaining ","thor_args parse each ","thor_args parse ","args + ","opts remaining ","Thor Arguments  new "," class strict_args_position? "," __send__ "," class stop_on_unknown_option? ","config [] ","config [] merge ","local_options is_a? ","config [] disable_class_options "," class disable_required_check? "," Thor Options  parse  freeze "," Thor Options  parse  "," Thor Options  parse = ","parse_Thor Options  parse  merge ","parse_options merge  merge "," class class_options  merge ","Thor Options  parse  is_a? "," class class_Thor Options  parse  ","Thor Options  new  check_unknown! "," class check_unknown_Thor Options  parse ? ","Thor Options  new  parse ","Thor Arguments  parse  each ","thor_args remaining  each ","thor_Thor Arguments  parse  remaining ","thor_thor_args remaining  remaining ","Thor Arguments  new  remaining ","thor_Thor Arguments  parse  parse each ","thor_thor_args remaining  parse each ","Thor Arguments  new  parse each ","thor_Thor Arguments  parse  parse ","thor_thor_args remaining  parse ","Thor Arguments  new  parse ","Thor Arguments  parse  + ","thor_args remaining  + ","Thor Options  new  remaining "," class strict_Thor Arguments  parse _position? "," class strict_thor_args remaining _position? "," class  class stop_on_unknown_option? _option? ","local_Thor Options  parse  is_a? ","config [] disable_class_Thor Options  parse  "," class  class disable_required_check? ? "]}," Thor Actions _cleanup_options_and_set":{"type":"method","name":"_cleanup_options_and_set","children":[],"call":["options merge! ","options delete ","(sym :force) each ","options << ","(str \"--force\") each "]}," Thor Actions _shared_configuration":{"type":"method","name":"_shared_configuration","children":[],"call":[" merge! "," destination_root "]}," Thor Actions thor":{"type":"method","name":"thor","children":[],"call":[" run ","args join strip ","args join ","args push ","Thor Options  to_switches ","args unshift ","config delete ","config key? ","args pop ","args last is_a? ","args last ","args pop  delete ","args pop  key? "]}," Thor Actions run_ruby_script":{"type":"method","name":"run_ruby_script","children":[],"call":[" run ","config merge ","Thor Util  ruby_command "," behavior == "," behavior "]}," Thor Actions run":{"type":"method","name":"run","children":[],"call":[" system "," options [] "," options "," say_status ","config fetch ","config [] ","File  basename ","config [] to_s ","destination inspect "," relative_to_original_destination_root "," destination_root "," behavior == "," behavior ","command to_s "," options [] ! "," abort ","$? success? "," class exit_on_failure? "," class ","success ! ","status success? ","Open3  capture2e "," require "," relative_to_original_destination_root  inspect "," relative_to_original_ relative_to_original_destination_root _root ","  relative_to_original_destination_root _root ","$? $? success? ? ","$? status success? ? ","$? success?  ! ","status success?  ! ","status $? success? ? ","status status success? ? "]}," Thor Actions apply":{"type":"method","name":"apply","children":[],"call":[" shell padding "," shell "," instance_eval "," open read "," open "," say_status "," find_in_source_paths ","path =~ ","config fetch ","io read "," URI is_a? "," URI "," require ","URI  open ","File  open ","URI  send "," find_in_source_ find_in_source_paths s "," find_in_source_paths  =~ "]}," Thor Actions in_root":{"type":"method","name":"in_root","children":[],"call":[" inside ","@destination_stack first "]}," Thor Actions inside":{"type":"method","name":"inside","children":[],"call":[" shell padding "," shell ","@destination_stack pop "," destination_root ","block arity == ","block arity ","FileUtils  cd ","FileUtils  mkdir_p ","File  exist? ","@destination_stack push ","File  expand_path "," say_status ","config fetch ","pretend ! ","File  exist? ! "," options [] "," options "," require "," options []  ! "]}," Thor Actions find_in_source_paths":{"type":"method","name":"find_in_source_paths","children":[],"call":[" raise ","file inspect ","(str \"You don't have any source path defined for class \") << "," class name "," class "," source_paths empty? "," source_paths ","File  exists? ","File  expand_path ","File  join "," source_paths each "," relative_to_original_destination_root "," destination_root "," source_paths join ","message << "," class source_root "," fail ","File  exist? ","possible_files each ","file + ","(str \"Could not find \") dup ","(str \"Could not find \") dup  << "]}," Thor Actions source_paths":{"type":"method","name":"source_paths","children":[],"call":[" class source_paths_for_search "," class "]}," Thor Actions relative_to_original_destination_root":{"type":"method","name":"relative_to_original_destination_root","children":[],"call":["path [] ","path gsub ","@destination_stack [] ","path =~ ","path gsub! ","path dup ","path []= ","root size ","(const\n  (const nil :File) :SEPARATOR) include? ","path start_with? ","path gsub  [] ","path dup  [] ","path gsub  gsub ","path dup  gsub ","path gsub  =~ ","path dup  =~ ","path gsub  gsub! ","path dup  gsub! ","path gsub  dup ","path dup  dup ","path gsub  []= ","path dup  []= ","@destination_stack []  size ","path gsub  start_with? ","path dup  start_with? "]}," Thor Actions destination_root=":{"type":"method","name":"destination_root=","children":[],"call":["@destination_stack []= ","File  expand_path "]}," Thor Actions destination_root":{"type":"method","name":"destination_root","children":[],"call":["@destination_stack last "]}," Thor Actions action":{"type":"method","name":"action","children":[],"call":["instance invoke! ","instance revoke! "," behavior == "," behavior "]}," Thor Actions initialize":{"type":"method","name":"initialize","children":[],"call":[" destination_root= ","config [] "," behavior= "," _cleanup_options_and_set ","config [] to_s "]}," Thor Actions ClassMethods source_paths_for_search":{"type":"method","name":"source_paths_for_search","children":[],"call":[" from_superclass ","paths << "," source_root "," respond_to? "," source_paths "]}," Thor Actions ClassMethods source_paths":{"type":"method","name":"source_paths","children":[],"call":[]}," Thor Actions included":{"type":"method","name":"included","children":[],"call":[]}," Thor Actions InjectIntoFile replace!":{"type":"method","name":"replace!","children":[],"call":["file write ","File  open "," destination ","content gsub! ","File  read "," base options [] "," base options "," base ","File  binread ","content include? ! ","content include? "," replacement "," pretend? ","snippet include? ! ","snippet include? ","(if\n  (send\n    (send nil :behavior) :==\n    (sym :after))\n  (lvar :after)\n  (lvar :before)) to_s "," behavior == "," behavior ","content split ","File  read  gsub! ","File  binread  gsub! ","File  read  include? ! ","File  binread  include? ! ","File  read  include? ","File  binread  include? ","(if\n  (send\n    (send nil :behavior) :==\n    (sym :after))\n  (lvar :after)\n  (lvar :before)) to_s  include? ! ","(if\n  (send\n    (send nil :behavior) :==\n    (sym :after))\n  (lvar :after)\n  (lvar :before)) to_s  include? ","File  read  split ","File  binread  split "]}," Thor Actions InjectIntoFile revoke!":{"type":"method","name":"revoke!","children":[],"call":[" replace! "," flag "," replacement "," say_status "," config [] "," config ","Regexp  escape ","@behavior == "]}," Thor Actions InjectIntoFile invoke!":{"type":"method","name":"invoke!","children":[],"call":[" replace! "," replacement "," flag "," say_status "," config [] "," config "," replacement + ","\\0 + ","@behavior == "," raise "," destination "," pretend? "," exists? ","WARNINGS  [] "]}," Thor Actions InjectIntoFile initialize":{"type":"method","name":"initialize","children":[],"call":["data + ","@config delete ","@flag + ","@config key? ","data call ","data is_a? ","(pair\n  (sym :verbose)\n  (true)) merge ","Regexp  escape ","@flag is_a? ","data call  + ","@config delete  + ","Regexp  escape  + ","data call  call ","data call  is_a? ","@config delete  is_a? ","Regexp  escape  is_a? "]}," Thor Actions inject_into_file":{"type":"method","name":"inject_into_file","children":[],"call":[" action ","InjectIntoFile  new ","args pop ","args empty? ","args shift "," block_given? "]}," Thor Actions remove_file":{"type":"method","name":"remove_file","children":[],"call":[" FileUtils  rm_rf ","File  exists? "," options [] ! "," options [] "," options "," say_status ","config fetch "," relative_to_original_destination_root ","File  expand_path "," destination_root "," behavior == "," behavior ","File  exist? "," require ","File  symlink? ","File  expand_File  expand_path  "]}," Thor Actions gsub_file":{"type":"method","name":"gsub_file","children":[],"call":["file write ","File  open ","content gsub! ","File  read "," options [] "," options "," say_status ","config fetch "," relative_to_original_destination_root ","File  expand_path "," destination_root ","args pop ","args last is_a? ","args last "," behavior == "," behavior ","File  binread ","File  read  gsub! ","File  binread  gsub! ","args pop  fetch ","File  expand_File  expand_path  "]}," Thor Actions append_file":{"type":"method","name":"append_file","children":[],"call":["file write ","block call ","File  open "," options [] "," options "," say_status ","config fetch "," relative_to_original_destination_root ","File  expand_path "," destination_root "," behavior == "," behavior "," inject_into_file ","args << ","config merge! ","args pop ","args last is_a? ","args last ","args pop  fetch ","File  expand_File  expand_path  ","args pop  merge! "]}," Thor Actions prepend_file":{"type":"method","name":"prepend_file","children":[],"call":["file write ","File  open ","content << ","File  read ","block call "," options [] "," options "," say_status ","config fetch "," relative_to_original_destination_root ","File  expand_path "," destination_root "," behavior == "," behavior "," inject_into_file ","args << ","config merge! ","args pop ","args last is_a? ","args last ","args pop  fetch ","File  expand_File  expand_path  ","args pop  merge! "]}," Thor Actions chmod":{"type":"method","name":"chmod","children":[],"call":["FileUtils  chmod_R "," options [] "," options "," say_status ","config fetch "," relative_to_original_destination_root ","File  expand_path "," destination_root "," behavior == "," behavior "," require ","File  expand_File  expand_path  "]}," Thor Actions template":{"type":"method","name":"template","children":[],"call":["ERB  new result ","ERB  new "," File  read "," create_file "," instance_eval ","File  expand_path "," find_in_source_paths ","source to_s ","block call "," File  binread ","args first ","args pop ","args last is_a? ","args last ","source sub ","CapturableERB  new result ","CapturableERB  new ","config delete ","(send\n  (send\n    (const nil :CapturableERB) :new\n    (send\n      (const\n        (cbase) :File) :binread\n      (lvar :source))\n    (nil)\n    (str \"-\")\n    (str \"@output_buffer\")) :tap) result ","erb filename= ","CapturableERB  new tap ","(send\n  (lvar :capturable_erb) :tap) result ","capturable_erb tap ","match [] >= ","match [] ","ERB  version match ","ERB  version "," find_in_File  expand_path _paths ","File  expand_path  to_s ","File  expand_path  sub ","args pop  delete ","(send\n  (send\n    (const nil :CapturableERB) :new\n    (send\n      (const\n        (cbase) :File) :binread\n      (lvar :File  expand_path ))\n    (nil)\n    (str \"-\")\n    (str \"@output_buffer\")) :tap) result ","(send\n  (lvar :CapturableERB  new ) :tap) result ","CapturableERB  new  tap ","ERB  version match  [] >= ","ERB  version match  [] ","ERB  version ERB  version match  "]}," Thor Actions get":{"type":"method","name":"get","children":[],"call":[" create_file ","File  basename ","block call ","block arity == ","block arity "," block_given? "," open read "," open ","File  expand_path "," find_in_source_paths ","source to_s ","source =~ ","File  binread "," open binmode read "," open binmode ","input binmode read ","input binmode ","args first ","args pop ","args last is_a? ","args last "," require ","URI  send ","File  open "," find_in_File  expand_path _paths ","File  expand_path  to_s ","File  expand_path  =~ "]}," Thor Actions copy_file":{"type":"method","name":"copy_file","children":[],"call":["File  read "," create_file ","File  expand_path "," find_in_source_paths ","source to_s ","block call ","File  binread ","args first ","args pop ","args last is_a? ","args last "," chmod ","File  stat mode ","File  stat ","config [] == ","config [] "," find_in_File  expand_path _paths ","File  expand_path  to_s ","File  stat File  stat mode  ","args pop  [] == ","args pop  [] "]}," Thor Actions EmptyDirectory say_status":{"type":"method","name":"say_status","children":[],"call":[" base shell say_status "," relative_destination "," base shell "," base "," config [] "," config "]}," Thor Actions EmptyDirectory on_conflict_behavior":{"type":"method","name":"on_conflict_behavior","children":[],"call":[" say_status "]}," Thor Actions EmptyDirectory invoke_with_conflict_check":{"type":"method","name":"invoke_with_conflict_check","children":[],"call":[" destination ","block call "," pretend? "," say_status "," on_conflict_behavior "," exists? "," on_file_clash_behavior "]}," Thor Actions EmptyDirectory convert_encoded_instructions":{"type":"method","name":"convert_encoded_instructions","children":[],"call":[" base send "," base "," base respond_to? ","1 strip ","filename gsub "," call_public_method "," call_public_1 strip  "]}," Thor Actions EmptyDirectory destination=":{"type":"method","name":"destination=","children":[],"call":[" base relative_to_original_destination_root "," base "," File  expand_path "," base destination_root "," convert_encoded_instructions ","destination to_s "]}," Thor Actions EmptyDirectory pretend?":{"type":"method","name":"pretend?","children":[],"call":[" base options [] "," base options "," base "]}," Thor Actions EmptyDirectory revoke!":{"type":"method","name":"revoke!","children":[],"call":[" FileUtils  rm_rf "," destination "," exists? "," pretend? ! "," pretend? "," say_status "," given_destination "," require "]}," Thor Actions EmptyDirectory invoke!":{"type":"method","name":"invoke!","children":[],"call":[" FileUtils  mkdir_p "," destination "," invoke_with_conflict_check "," require "]}," Thor Actions EmptyDirectory exists?":{"type":"method","name":"exists?","children":[],"call":[" File  exists? "," destination "," File  exist? "]}," Thor Actions EmptyDirectory initialize":{"type":"method","name":"initialize","children":[],"call":[" destination= ","(pair\n  (sym :verbose)\n  (true)) merge "]}," Thor Actions empty_directory":{"type":"method","name":"empty_directory","children":[],"call":[" action ","EmptyDirectory  new "]}," Thor Actions Directory execute!":{"type":"method","name":"execute!","children":[],"call":[" base copy_file "," config "," base "," base template ","file_destination [] "," base empty_directory ","File  dirname ","File  join ","file_source gsub "," source "," given_destination ","File  directory? ","Dir  [] each ","Dir  [] "," config [] ","dirname == ","File  dirname gsub ","@block call ","file_destination gsub! ","Dir  [] sort each ","Dir  [] sort ","Util  escape_globs "," files sort each "," files sort "," files "," file_level_lookup ","file_source match ","File  join  [] ","file_ base copy_file  [] ","file_ base template  [] ","File  File  dirname gsub  "," given_ base copy_file  "," given_ base template  ","File  dirname gsub  == ","File  File  dirname gsub  gsub ","File  join  gsub! ","file_ base copy_file  gsub! ","file_ base template  gsub! "," file_level_File  join  "," file_level_ source  "," file_level_Util  escape_globs  "," file_level_ file_level_lookup  "]}," Thor Actions Directory revoke!":{"type":"method","name":"revoke!","children":[],"call":[" execute! "]}," Thor Actions Directory invoke!":{"type":"method","name":"invoke!","children":[],"call":[" execute! "," base empty_directory "," config "," given_destination "," base "]}," Thor Actions Directory initialize":{"type":"method","name":"initialize","children":[],"call":["(pair\n  (sym :recursive)\n  (true)) merge ","File  expand_path ","base find_in_source_paths ","source to_s ","Dir  [] first ","Dir  [] ","Util  escape_globs "]}," Thor Actions directory":{"type":"method","name":"directory","children":[],"call":[" action ","Directory  new ","args first ","args pop ","args last is_a? ","args last "]}," Thor Actions CreateFile force_on_collision?":{"type":"method","name":"force_on_collision?","children":[],"call":[" render "," base shell file_collision "," destination "," base shell "," base "]}," Thor Actions CreateFile force_or_skip_or_conflict":{"type":"method","name":"force_or_skip_or_conflict","children":[],"call":[" force_or_skip_or_conflict "," force_on_collision? "," say_status ","block call "," pretend? "]}," Thor Actions CreateFile on_conflict_behavior":{"type":"method","name":"on_conflict_behavior","children":[],"call":[" force_or_skip_or_conflict ","options [] "," base options merge "," config "," base options "," base "," say_status "," identical? "," base options merge  [] "," base  base options merge  merge "," base  base options merge  "]}," Thor Actions CreateFile invoke!":{"type":"method","name":"invoke!","children":[],"call":["f write "," render ","File  open "," destination ","FileUtils  mkdir_p ","File  dirname "," invoke_with_conflict_check "," given_destination "," require "," config [] "," config "]}," Thor Actions CreateFile render":{"type":"method","name":"render","children":[],"call":[" data "," data call "," data is_a? "]}," Thor Actions CreateFile identical?":{"type":"method","name":"identical?","children":[],"call":["File  read == "," render ","File  read "," destination "," exists? ","File  binread == ","File  binread "]}," Thor Actions CreateFile initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Thor Actions create_file":{"type":"method","name":"create_file","children":[],"call":[" action ","CreateFile  new ","data to_s ","args first ","args pop ","args last is_a? ","args last ","args first  to_s "]}," Thor Task Dynamic run":{"type":"method","name":"run","children":[],"call":[" raise "," name ","(send\n  (send\n    (lvar :instance) :methods) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ","instance methods & "," name to_sym "," name to_s ","instance methods ","instance class handle_no_task_error ","instance class "]}," Thor Task Dynamic initialize":{"type":"method","name":"initialize","children":[],"call":["name to_s "]}," Runner exit_on_failure?":{"type":"method","name":"exit_on_failure?","children":[],"call":[]}," Thor Base ClassMethods exit_on_failure?":{"type":"method","name":"exit_on_failure?","children":[],"call":["Thor  deprecation_warning "," name "]}," Thor Actions ClassMethods add_runtime_options!":{"type":"method","name":"add_runtime_options!","children":[],"call":[" class_option "]}," Thor Actions InjectIntoFile say_status":{"type":"method","name":"say_status","children":[],"call":[" config [] "," config ","behavior == "," flag == "," flag "]}," Thor Actions inject_into_class":{"type":"method","name":"inject_into_class","children":[],"call":[" inject_into_file ","args << ","config merge! ","args pop ","args last is_a? ","args last "," insert_into_file ","config []= ","args pop  merge! ","args pop  []= "]}," Thor printable_tasks":{"type":"method","name":"printable_tasks","children":[],"call":["item << ","task description "," banner ","(if\n  (lvar :all)\n  (send nil :all_tasks)\n  (send nil :tasks)) map "," tasks "," all_tasks ","task description gsub ","(send\n  (begin\n    (if\n      (lvar :all)\n      (send nil :all_tasks)\n      (send nil :tasks))) :map) compact ","task hidden? "]}," Thor Task required_options":{"type":"method","name":"required_options","children":[],"call":["(send\n  (send nil :options) :map) compact sort join ","(send\n  (send nil :options) :map) compact sort ","(send\n  (send nil :options) :map) compact ","o usage ","o required? "," options map "," options "]}," Thor Task required_arguments":{"type":"method","name":"required_arguments","children":[],"call":["(send\n  (send\n    (lvar :klass) :arguments) :map) compact join ","(send\n  (send\n    (lvar :klass) :arguments) :map) compact ","a usage ","a required? ","klass arguments map ","klass arguments "]}," Thor Shell Basic truncate":{"type":"method","name":"truncate","children":[],"call":["(or\n  (send\n    (lvar :string) :[]\n    (int 0)\n    (send\n      (lvar :width) :-\n      (int 3)))\n  (str \"\")) + ","string [] ","width - ","string length <= ","string length ","(send\n  (send\n    (lvar :chars) :[]\n    (int 0)\n    (send\n      (lvar :width) :-\n      (int 3))) :join) + ","chars [] join ","chars [] ","chars join ","chars length <= ","chars length ","string chars to_a ","string chars "," as_unicode ","chars [] join + ","(send\n  (send\n    (lvar :string chars to_a ) :[]\n    (int 0)\n    (send\n      (lvar :width) :-\n      (int 3))) :join) + ","string chars to_a  [] join ","string chars to_a  [] ","string chars to_a  join ","string chars to_a  length <= ","string chars to_a  length ","string string chars to_a  to_a ","string string chars to_a  ","string chars to_a  [] join + "]}," Thor Shell Basic unix?":{"type":"method","name":"unix?","children":[],"call":["RUBY_PLATFORM  =~ "]}," Thor Shell Basic dynamic_width_tput":{"type":"method","name":"dynamic_width_tput","children":[],"call":["(str \"tput cols 2>/dev/null\") to_i "]}," Thor Shell Basic dynamic_width_stty":{"type":"method","name":"dynamic_width_stty","children":[],"call":["(str \"stty size 2>/dev/null\") split [] to_i ","(str \"stty size 2>/dev/null\") split [] ","(str \"stty size 2>/dev/null\") split "]}," Thor Shell Basic dynamic_width":{"type":"method","name":"dynamic_width","children":[],"call":[" dynamic_width_tput "," dynamic_width_stty nonzero? "," dynamic_width_stty "]}," Thor Shell Basic terminal_width":{"type":"method","name":"terminal_width","children":[],"call":["result < "," dynamic_width "," unix? ","ENV  [] to_i ","ENV  [] "," dynamic_width  < ","ENV  [] to_i  < "]}," Runner banner":{"type":"method","name":"banner","children":[],"call":[]}," Thor Base ClassMethods print_options":{"type":"method","name":"print_options","children":[],"call":["shell say ","shell print_table ","list << ","option default ","option show_default? ","item push ","option description ","option usage ","options each ","(send\n  (lvar :options) :collect) max to_i * ","(send\n  (lvar :options) :collect) max to_i ","(send\n  (lvar :options) :collect) max ","o aliases size ","o aliases ","options collect ","options empty? ","option hide ","option enum join ","option enum ","(send\n  (lvar :options) :map) max to_i * ","(send\n  (lvar :options) :map) max to_i ","(send\n  (lvar :options) :map) max ","options map ","o aliases_for_usage size ","o aliases_for_usage "]}," Thor task_help":{"type":"method","name":"task_help","children":[],"call":["shell say ","task description "," class_options_help ","task options map ","task options "," banner "," raise "," namespace "," all_tasks [] "," all_tasks "," handle_no_task_error "," normalize_task_name ","shell print_wrapped ","task long_description "," all_tasks []  description "," all_tasks []  options map "," all_tasks []  options "," all_ all_tasks [] s [] "," all_ all_tasks [] s "," handle_no_ all_tasks [] _error "," normalize_ all_tasks [] _name "," all_tasks []  long_description "]}," Thor Task backtrace_match?":{"type":"method","name":"backtrace_match?","children":[],"call":["backtrace =~ ","Regexp  escape "," name split last "," name split "," name "]}," Runner show_modules":{"type":"method","name":"show_modules","children":[],"call":[" say "," print_table ","info << ","hash [] join ","hash [] "," thor_yaml each "," thor_yaml ","- * ","labels [] size ","labels [] "]}," Group self_task":{"type":"method","name":"self_task","children":[],"call":["Thor Task Dynamic  new "," class_options "," namespace ","Thor DynamicTask  new "]}," Group printable_tasks":{"type":"method","name":"printable_tasks","children":[],"call":["item << "," desc gsub "," desc "," banner "]}," File binread":{"type":"method","name":"binread","children":[],"call":[]}," Thor Base ClassMethods attr_accessor":{"type":"method","name":"attr_accessor","children":[],"call":[" no_tasks "," no_commands "]}," Thor Base ClassMethods attr_writer":{"type":"method","name":"attr_writer","children":[],"call":[" no_tasks "," no_commands "]}," Thor Base ClassMethods attr_reader":{"type":"method","name":"attr_reader","children":[],"call":[" no_tasks "," no_commands "]}," Runner version":{"type":"method","name":"version","children":[],"call":[" say "," require "," require_relative "]}," Thor handle_argument_error":{"type":"method","name":"handle_argument_error","children":[],"call":[" raise ","task formatted_usage inspect ","task formatted_usage "," banner_base == "," banner_base ","task name inspect ","task name "]}," Thor Util find_class_and_task_by_namespace!":{"type":"method","name":"find_class_and_task_by_namespace!","children":[],"call":[]}," Thor Util find_class_and_task_by_namespace":{"type":"method","name":"find_class_and_task_by_namespace","children":[],"call":[]}," Thor Task handle_no_method_error?":{"type":"method","name":"handle_no_method_error?","children":[],"call":["error message =~ ","Regexp  escape ","instance to_s "," name ","error message "," not_debugging? "]}," Thor Task handle_argument_error?":{"type":"method","name":"handle_argument_error?","children":[],"call":[" sans_backtrace empty? "," sans_backtrace ","error backtrace ","error message =~ ","error message "," not_debugging? ","RUBY_VERSION  >= ","saned size == ","saned size ","saned empty? "," sans_backtrace  size == "," sans_backtrace  size "," sans_backtrace  empty? "]}," Thor Task not_debugging?":{"type":"method","name":"not_debugging?","children":[],"call":["(and\n  (send\n    (send\n      (lvar :instance) :class) :respond_to?\n    (sym :debugging))\n  (send\n    (send\n      (lvar :instance) :class) :debugging)) ! ","instance class debugging ","instance class ","instance class respond_to? "]}," Thor Options check_unknown!":{"type":"method","name":"check_unknown!","children":[],"call":[" raise ","@unknown join ","@unknown empty? ","unknown join ","unknown empty? ","str =~ ","@extra select "," fail ","UnknownArgumentError  new ","@switches keys ","to_check select ","@extra [] ","@extra []  select "]}," Group handle_argument_error":{"type":"method","name":"handle_argument_error","children":[],"call":[" raise ","task name inspect ","task name "," basename ","msg << ","arity > ","command name "," fail ","(begin\n  (send nil :basename)) dup ","(begin\n  (send nil :basename)) dup  << "]}," Thor Base ClassMethods banner_base":{"type":"method","name":"banner_base","children":[],"call":["File  basename ","$0 split first ","$0 split "]}," Thor Base ClassMethods handle_no_task_error":{"type":"method","name":"handle_no_task_error","children":[],"call":[" raise ","task inspect "," namespace inspect "," namespace "," banner_base == "," banner_base "]}," Thor Base ClassMethods check_unknown_options?":{"type":"method","name":"check_unknown_options?","children":[],"call":[" check_unknown_options ! ! "," check_unknown_options ! "," check_unknown_options "]}," Thor Base ClassMethods check_unknown_options!":{"type":"method","name":"check_unknown_options!","children":[],"call":[]}," Thor Shell with_padding":{"type":"method","name":"with_padding","children":[],"call":[" shell padding "," shell "]}," Thor Options current_is_switch_formatted?":{"type":"method","name":"current_is_switch_formatted?","children":[],"call":[" switch_formatted? "," peek "]}," Thor Options switch_formatted?":{"type":"method","name":"switch_formatted?","children":[],"call":[]}," Thor Arguments last?":{"type":"method","name":"last?","children":[],"call":["@pile empty? "]}," Thor Invocation invoke_with_padding":{"type":"method","name":"invoke_with_padding","children":[],"call":[" invoke "," with_padding "]}," Thor Actions ClassMethods source_root":{"type":"method","name":"source_root","children":[],"call":[]}," Thor subcommand_args":{"type":"method","name":"subcommand_args","children":[],"call":["@@original_args [] "]}," Thor subcommand_help":{"type":"method","name":"subcommand_help","children":[],"call":[" class_eval "," desc "]}," Thor subcommand":{"type":"method","name":"subcommand","children":[],"call":["subcommand_class start "," subcommand_args "," define_method ","subcommand_class subcommand_help "," subcommands []= "," subcommands ","subcommand to_s "," invoke "," subcommands << ","Thor Arguments  split "," options ","args unshift ","opts include? "," subcommand_classes []= "," subcommand_classes ","invoke_args unshift ","opts delete ","command ancestor_name= ","subcommand_class commands each ","subcommand_class commands ","subcommand to_s _class start "," subcommand to_s _args ","subcommand to_s _class subcommand to_s _help "," subcommand to_s s []= "," subcommand to_s s ","subcommand to_s  to_s "," subcommand to_s s << "," subcommand to_s _classes []= "," subcommand to_s _classes ","subcommand to_s _class commands each ","subcommand to_s _class commands "]}," Thor subcommands":{"type":"method","name":"subcommands","children":[],"call":[" from_superclass "]}," Thor long_desc":{"type":"method","name":"long_desc","children":[],"call":["task long_description= "," find_and_refresh_task ","options [] ","command long_description= "," find_and_refresh_command "," find_and_refresh_task  long_description= "," find_and_refresh_ find_and_refresh_task  "," find_and_refresh_command  long_description= "," find_and_refresh_ find_and_refresh_command  "]}," Thor Shell HTML diff_lcs_loaded?":{"type":"method","name":"diff_lcs_loaded?","children":[],"call":[" require ","@diff_lcs_loaded nil? "]}," Thor Shell HTML output_diff_line":{"type":"method","name":"output_diff_line","children":[],"call":[" say ","diff old_element chomp ","diff old_element ","diff new_element chomp ","diff new_element ","diff action "]}," Thor Shell HTML show_diff":{"type":"method","name":"show_diff","children":[],"call":[" output_diff_line ","Diff LCS  sdiff each ","Diff LCS  sdiff ","content to_s split ","content to_s ","File  binread to_s split ","File  binread to_s ","File  binread ","ENV  [] nil? ","ENV  [] "," diff_lcs_loaded? ","content to_s split  to_s split ","content to_s split  to_s "]}," Thor Shell HTML ask":{"type":"method","name":"ask","children":[],"call":[" raise "," fail "]}," Thor Shell HTML set_color":{"type":"method","name":"set_color","children":[],"call":[" class const_get ","color to_s upcase ","color to_s "," class ","color is_a? ","styles join ","styles << ","html_colors join "," lookup_color ","colors map ","colors all? ","Thor Util  escape_html "," class const_get  to_s upcase "," class const_get  to_s "," class const_get  is_a? ","html_ class const_get s join "," class const_get s join "," lookup_ class const_get  "," class const_get s map "," class const_get s all? "]}," Thor Shell Basic print_wrapped":{"type":"method","name":"print_wrapped","children":[],"call":["$stdout puts ","para == ","paras last ","line insert ","  * ","para split each ","para split ","paras each ","(send\n  (back-ref :$&) :+\n  (send\n    (int 5) :chr)) gsub gsub ","(send\n  (back-ref :$&) :+\n  (send\n    (int 5) :chr)) gsub ","$& + ","5 chr ","unwrapped strip gsub squeeze gsub ","unwrapped strip gsub squeeze ","unwrapped strip gsub ","unwrapped strip ","paras map! ","message split "," terminal_width - "," terminal_width ","options [] "," stdout puts "," stdout ","unwrapped strip tr squeeze gsub ","unwrapped strip tr squeeze ","unwrapped strip tr ","(send\n  (lvar :paras) :map!) compact! ","word length ","word length + ","(send\n  (send\n    (lvar :counter) :+\n    (send\n      (lvar :word) :length)) :+\n  (int 1)) < ","counter + + ","counter + ","word include? ","word gsub gsub ","word gsub ","unwrapped split inject ","unwrapped split ","words inject ","words first length ","words first ","message split  last ","message split  each ","message split  map! "," terminal_ terminal_width -  - "," terminal_ terminal_width -  ","(send\n  (lvar :message split ) :map!) compact! ","word gsub gsub  length ","word gsub gsub  length + ","(send\n  (send\n    (lvar :word length ) :+\n    (send\n      (lvar :word) :length)) :+\n  (int 1)) < ","(send\n  (send\n    (lvar :words first length ) :+\n    (send\n      (lvar :word) :length)) :+\n  (int 1)) < ","(send\n  (send\n    (lvar :counter) :+\n    (send\n      (lvar :word gsub gsub ) :length)) :+\n  (int 1)) < ","word length  + + ","words first length  + + ","word length  + ","words first length  + ","word gsub gsub  include? ","word gsub gsub  gsub gsub ","word gsub gsub  gsub ","word gsub gsub s inject ","unwrapped split  inject ","word gsub gsub s first length ","unwrapped split  first length ","word gsub gsub s first ","unwrapped split  first "]}," Thor Arguments no_or_skip?":{"type":"method","name":"no_or_skip?","children":[],"call":["arg =~ "]}," Thor Base ClassMethods handle_argument_error":{"type":"method","name":"handle_argument_error","children":[],"call":[" raise "," banner inspect "," banner ","task name inspect ","task name ","msg << ","required > ","-1 - ","arity < "," basename ","required == ","msg << << ","args inspect ","args empty? ! ","args empty? ","command name "," fail ","(str \"ERROR: \\\"\") dup ","(send\n  (lvar :command) :ancestor_name) compact join ","(send\n  (lvar :command) :ancestor_name) compact ","command ancestor_name "," banner split join "," banner split ","task (send\n  (lvar :command) :ancestor_name) compact join  inspect ","task (send\n  (lvar :command) :ancestor_name) compact join  ","(str \"ERROR: \\\"\") dup  << "," base(send\n  (lvar :command) :ancestor_name) compact join  ","(str \"ERROR: \\\"\") dup  << << ","command (send\n  (lvar :command) :ancestor_name) compact join  ","(send\n  (lvar :command) :ancestor_(send\n  (lvar :command) :ancestor_name) compact join ) compact join ","(send\n  (lvar :command) :ancestor_(send\n  (lvar :command) :ancestor_name) compact join ) compact ","command ancestor_(send\n  (lvar :command) :ancestor_name) compact join  "]}," Thor DynamicTask run":{"type":"method","name":"run","children":[],"call":["instance class handle_no_task_error "," name ","instance class ","(send\n  (send\n    (lvar :instance) :methods) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ","instance methods & "," name to_sym "," name to_s ","instance methods "]}," Thor DynamicTask initialize":{"type":"method","name":"initialize","children":[],"call":["name to_s "]}," Thor HiddenTask hidden?":{"type":"method","name":"hidden?","children":[],"call":[]}," Thor Task hidden?":{"type":"method","name":"hidden?","children":[],"call":[]}," Thor retrieve_task_name":{"type":"method","name":"retrieve_task_name","children":[],"call":["args shift ","meth !~ "," map [] "," map ","args first to_s ","args first ","args empty? ","args first to_s  !~ "]}," Thor dispatch":{"type":"method","name":"dispatch","children":[],"call":[" new invoke_task "," new ","args [] ","Range  new "," arguments size "," arguments ","config merge! ","task options ","Thor DynamicTask  new ","Thor Options  split "," all_tasks [] "," normalize_task_name "," all_tasks "," retrieve_task_name ","instance invoke_task ","instance args "," block_given? ","opts clear ","args concat ","args empty? ! ","args empty? "," stop_on_unknown_option? "," default_task ","given_args dup ","given_args first != ","given_args first "," default_task != ","given_args size >= ","given_args size ","config [] ","instance invoke_command ","command options ","Thor DynamicCommand  new "," all_commands [] "," normalize_command_name "," all_commands "," retrieve_command_name "," default_command "," default_command != "," dynamic_command_class new "," dynamic_command_class ","given_args unshift ","command ! ","config []= "," new invoke_Thor DynamicTask  new  "," new invoke_ all_tasks []  ","instance args  [] ","Thor DynamicTask  new  options "," all_tasks []  options "," all_Thor DynamicTask  new s [] "," all_ all_tasks [] s [] "," normalize_Thor DynamicTask  new _name "," normalize_ all_tasks [] _name "," all_Thor DynamicTask  new s "," all_ all_tasks [] s "," retrieve_Thor DynamicTask  new _name "," retrieve_ all_tasks [] _name ","instance invoke_Thor DynamicTask  new  ","instance invoke_ all_tasks []  "," new  invoke_task ","instance instance args  "," new  args ","instance args  concat ","instance args  empty? ! ","instance args  empty? "," default_Thor DynamicTask  new  "," default_ all_tasks []  ","given_instance args  dup ","given_instance args  first != ","given_instance args  first "," default_Thor DynamicTask  new  != "," default_ all_tasks []  != ","given_instance args  size >= ","given_instance args  size "," new  invoke_command ","instance invoke_Thor DynamicCommand  new  ","instance invoke_ all_commands []  ","instance invoke_ dynamic_command_class new  ","Thor DynamicCommand  new  options "," all_commands []  options "," dynamic_command_class new  options "," all_Thor DynamicCommand  new s [] "," all_ all_commands [] s [] "," all_ dynamic_command_class new s [] "," normalize_Thor DynamicCommand  new _name "," normalize_ all_commands [] _name "," normalize_ dynamic_command_class new _name "," all_Thor DynamicCommand  new s "," all_ all_commands [] s "," all_ dynamic_command_class new s "," retrieve_Thor DynamicCommand  new _name "," retrieve_ all_commands [] _name "," retrieve_ dynamic_command_class new _name "," default_Thor DynamicCommand  new  "," default_ all_commands []  "," default_ dynamic_command_class new  "," default_Thor DynamicCommand  new  != "," default_ all_commands []  != "," default_ dynamic_command_class new  != "," dynamic_Thor DynamicCommand  new _class new "," dynamic_ all_commands [] _class new "," dynamic_ dynamic_command_class new _class new "," dynamic_Thor DynamicCommand  new _class "," dynamic_ all_commands [] _class "," dynamic_ dynamic_command_class new _class ","given_instance args  unshift ","Thor DynamicCommand  new  ! "," all_commands []  ! "," dynamic_command_class new  ! "]}," Thor check_unknown_options?":{"type":"method","name":"check_unknown_options?","children":[],"call":["options [] include? ","name to_sym ","options [] ","options [] include? ! "," subcommands include? "," subcommands ","task name ","config [] "," check_unknown_options ","command name "," check_unknown_options  [] include? ","task name  to_sym ","command name  to_sym "," check_unknown_options  [] "," check_unknown_options  [] include? ! "," subconfig [] s include? "," subconfig [] s ","task task name  ","task command name  ","config []  name "," check_unknown_ check_unknown_options  ","command task name  ","command command name  "]}," Thor check_unknown_options!":{"type":"method","name":"check_unknown_options!","children":[],"call":["@check_unknown_options delete ","@check_unknown_options []= "," Array ","options each ","Hash  new "]}," Thor Invocation _parse_initialization_options":{"type":"method","name":"_parse_initialization_options","children":[],"call":["stored_config merge merge! ","stored_config merge "," _shared_configuration ","stored_opts dup ","stored_args dup ","stored_stored_config merge merge!  merge merge! ","stored_stored_config merge merge!  merge "," _shared_stored_config merge merge! uration "]}," Thor Invocation _retrieve_class_and_task":{"type":"method","name":"_retrieve_class_and_task","children":[],"call":[" class prepare_for_invocation "," class ","name to_s "," class all_tasks [] "," class all_tasks ","name nil? "]}," Thor Invocation invoke_all":{"type":"method","name":"invoke_all","children":[],"call":[" invoke_task "," class all_tasks map "," class all_tasks "," class "," invoke_command "," class all_commands map "," class all_commands "]}," Thor Invocation invoke_task":{"type":"method","name":"invoke_task","children":[],"call":["task run ","current << ","task name ","current include? ","@_invocations [] "," class ","@_invocations []  << ","@_invocations []  include? "]}," Group dispatch":{"type":"method","name":"dispatch","children":[],"call":[" new invoke_all "," new "," new invoke_task "," all_tasks [] "," all_tasks ","Thor Options  split "," help ","config [] ","Thor HELP_MAPPINGS  include? ","given_args first ","instance invoke_all ","instance invoke_task ","instance args "," block_given? ","instance invoke_command "," all_commands [] "," all_commands ","given_instance args  first "," new  invoke_all "," new  invoke_task ","instance instance args  "," new  args "," new  invoke_command "]}," Thor Base ClassMethods dispatch":{"type":"method","name":"dispatch","children":[],"call":[" raise "," fail "]}," Thor Base ClassMethods check_unknown_options":{"type":"method","name":"check_unknown_options","children":[],"call":[" from_superclass "]}," Thor Base ClassMethods basename":{"type":"method","name":"basename","children":[],"call":["File  basename split first ","File  basename split ","File  basename "]}," Thor Options except_underscores":{"type":"method","name":"except_underscores","children":[],"call":["x gsub ","x =~ ","args map "]}," Thor Actions with_output_buffer":{"type":"method","name":"with_output_buffer","children":[],"call":[" output_buffer= "," output_buffer "," raise ","buf frozen? "]}," Thor Actions capture":{"type":"method","name":"capture","children":[],"call":["block call "," with_output_buffer "]}," Thor Actions concat":{"type":"method","name":"concat","children":[],"call":["@output_buffer concat "]}," Thor Shell Basic mute?":{"type":"method","name":"mute?","children":[],"call":[]}," Thor Shell Basic mute":{"type":"method","name":"mute","children":[],"call":[]}," Thor Base ClassMethods public_task":{"type":"method","name":"public_task","children":[],"call":[" class_eval ","names each "]}," Thor register":{"type":"method","name":"register","children":[],"call":[" subcommand "," desc "," invoke "," define_method ","klass <= "]}," Thor Actions insert_into_file":{"type":"method","name":"insert_into_file","children":[],"call":[" action ","InjectIntoFile  new ","args shift "," block_given? ","config []= ","config key? ","args shift  []= ","args shift  key? "]}," Thor Actions append_to_file":{"type":"method","name":"append_to_file","children":[],"call":[" insert_into_file ","args << ","config merge! ","args pop ","args last is_a? ","args last ","config []= ","args pop  merge! ","args pop  []= "]}," Thor Actions prepend_to_file":{"type":"method","name":"prepend_to_file","children":[],"call":[" insert_into_file ","args << ","config merge! ","args pop ","args last is_a? ","args last ","config []= ","args pop  merge! ","args pop  []= "]}," Thor Actions link_file":{"type":"method","name":"link_file","children":[],"call":[" create_link ","File  expand_path "," find_in_source_paths ","source to_s ","args first ","args pop ","args last is_a? ","args last "," find_in_File  expand_path _paths ","File  expand_path  to_s "]}," Thor Actions CreateLink invoke!":{"type":"method","name":"invoke!","children":[],"call":[" given_destination ","File  link "," destination "," render ","File  symlink "," config [] "," config ","File  unlink "," exists? ","FileUtils  mkdir_p ","File  dirname "," invoke_with_conflict_check "," config []= "," config [] nil? "," require "]}," Thor Actions CreateLink identical?":{"type":"method","name":"identical?","children":[],"call":["File  identical? "," destination "," render "," exists? ","File  expand_path ","File  dirname "]}," Thor Actions create_link":{"type":"method","name":"create_link","children":[],"call":[" action ","CreateLink  new ","args first ","args pop ","args last is_a? ","args last "]}," Thor find_task_possibilities":{"type":"method","name":"find_task_possibilities","children":[],"call":["unique_possibilities size == ","unique_possibilities size ","possibilities include? ","(send\n  (lvar :possibilities) :map) uniq "," map [] "," map ","possibilities map ","(send\n  (send\n    (send\n      (send nil :all_tasks) :merge\n      (send nil :map)) :keys) :select) sort ","meth == ","n [] "," all_tasks merge keys select "," all_tasks merge keys "," all_tasks merge "," all_tasks ","meth to_s length ","meth to_s ","(send\n  (lvar :possibilities) :map) uniq  size == ","unique_(send\n  (send\n    (send\n      (send nil :all_tasks) :merge\n      (send nil :map)) :keys) :select) sort  size == ","(send\n  (lvar :possibilities) :map) uniq  size ","unique_(send\n  (send\n    (send\n      (send nil :all_tasks) :merge\n      (send nil :map)) :keys) :select) sort  size ","(send\n  (send\n    (send\n      (send nil :all_tasks) :merge\n      (send nil :map)) :keys) :select) sort  include? ","(send\n  (lvar :(send\n  (send\n    (send\n      (send nil :all_tasks) :merge\n      (send nil :map)) :keys) :select) sort ) :map) uniq ","(send\n  (send\n    (send\n      (send nil :all_tasks) :merge\n      (send nil :map)) :keys) :select) sort  map ","meth to_s meth to_s length gth "]}," Thor Task local_method?":{"type":"method","name":"local_method?","children":[],"call":["(send\n  (lvar :methods) :&\n  (array\n    (send\n      (lvar :name) :to_s)\n    (send\n      (lvar :name) :to_sym))) empty? ! ","(send\n  (lvar :methods) :&\n  (array\n    (send\n      (lvar :name) :to_s)\n    (send\n      (lvar :name) :to_sym))) empty? ","methods & ","name to_sym ","name to_s ","instance public_methods + + ","instance protected_methods ","instance public_methods + ","instance private_methods ","instance public_methods ","(send\n  (lvar :instance public_methods + + ) :&\n  (array\n    (send\n      (lvar :name) :to_s)\n    (send\n      (lvar :name) :to_sym))) empty? ! ","(send\n  (lvar :instance public_methods + + ) :&\n  (array\n    (send\n      (lvar :name) :to_s)\n    (send\n      (lvar :name) :to_sym))) empty? ","instance public_methods + +  & ","instance public_instance public_methods + +  + + ","instance protected_instance public_methods + +  ","instance public_instance public_methods + +  + ","instance private_instance public_methods + +  ","instance public_instance public_methods + +  "]}," Thor Task private_method?":{"type":"method","name":"private_method?","children":[],"call":["(send\n  (send\n    (lvar :instance) :private_methods) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ! ","(send\n  (send\n    (lvar :instance) :private_methods) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ","instance private_methods & "," name to_sym "," name "," name to_s ","instance private_methods "]}," Thor Shell Basic ask_filtered":{"type":"method","name":"ask_filtered","children":[],"call":[" say ","answer_set map join ","answer_set map ","answer_set include? "," ask_simply ","answer_set inspect ","answer_set join ","options [] "," answer_match ","options fetch "," ask_simply _set map join ","options []  map join "," ask_simply _set map ","options []  map "," ask_simply _set include? ","options []  include? "," ask_simply _set inspect ","options []  inspect "," ask_simply _set join ","options []  join ","  ask_simply _match "]}," Thor Shell Basic ask_simply":{"type":"method","name":"ask_simply","children":[],"call":[" stdin gets strip "," stdin gets "," stdin "," say ","text strip! "," stdin gets tap ","result == ","result strip! ","Thor LineEditor  readline "," prepare_message ","(lvar :statement) uniq join ","(lvar :statement) uniq ","options [] ","result strip ","Thor LineEditor  readline  == ","result strip  == ","Thor LineEditor  readline  strip! ","result strip  strip! "," prepare_ prepare_message  "," prepare_(lvar :statement) uniq join  ","Thor LineEditor  readline  strip ","result strip  strip "]}," Thor Shell Basic stderr":{"type":"method","name":"stderr","children":[],"call":[]}," Thor Shell Basic stdin":{"type":"method","name":"stdin","children":[],"call":[]}," Thor Shell Basic stdout":{"type":"method","name":"stdout","children":[],"call":[]}," Thor Shell Basic lookup_color":{"type":"method","name":"lookup_color","children":[],"call":[" class const_get ","color to_s upcase ","color to_s "," class ","color is_a? "]}," namespace":{"type":"method","name":"namespace","children":[],"call":["Thor RakeCompat  rake_classes pop ","Thor RakeCompat  rake_classes ","Thor RakeCompat  rake_classes << ","klass const_get ","klass const_set ","Class  new ","Thor Util  camel_case to_sym ","Thor Util  camel_case ","name to_s ","Thor RakeCompat  rake_classes last ","Thor RakeCompat  rake_classes last  const_get ","Thor RakeCompat  rake_classes last  const_set "]}," task":{"type":"method","name":"task","children":[],"call":["Rake Task  [] invoke ","Rake Task  [] ","task name to_sym ","task name ","klass send ","Rake  application last_description= ","Rake  application ","klass desc ","Rake  application last_description ","description strip! ","description << ","(send\n  (send\n    (lvar :task) :arg_names) :map) join ","n to_s upcase ","n to_s ","task arg_names map ","task arg_names ","task name split last ","task name split ","Thor RakeCompat  rake_classes last ","Thor RakeCompat  rake_classes ","Thor RakeCompat  rake_classes last  send ","Thor RakeCompat  rake_classes last  desc "]}," Thor Options remaining":{"type":"method","name":"remaining","children":[],"call":[]}," Thor Arguments remaining":{"type":"method","name":"remaining","children":[],"call":[]}," Thor Actions comment_lines":{"type":"method","name":"comment_lines","children":[],"call":[" gsub_file ","flag source ","flag respond_to? ","flag source  source ","flag source  respond_to? "]}," Thor Actions uncomment_lines":{"type":"method","name":"uncomment_lines","children":[],"call":[" gsub_file ","flag source ","flag respond_to? ","flag source  source ","flag source  respond_to? "]}," Thor Actions EmptyDirectory call_public_method":{"type":"method","name":"call_public_method","children":[],"call":[" raise "," base class "," base "," base respond_to? "," base send "]}," Thor Shell Basic as_unicode":{"type":"method","name":"as_unicode","children":[],"call":[]}," Thor Shell Basic print_in_columns":{"type":"method","name":"print_in_columns","children":[],"call":[" stdout puts "," stdout "," stdout printf ","index zero? ! ","index zero? ","(begin\n  (send\n    (begin\n      (send\n        (lvar :index) :+\n        (int 1))) :%\n    (begin\n      (send\n        (send nil :terminal_width) :/\n        (lvar :colwidth))))) zero? ","(send\n  (lvar :index) :+\n  (int 1)) % "," terminal_width / "," terminal_width ","index + ","array each_with_index ","(or\n  (send\n    (block\n      (send\n        (lvar :array) :map)\n      (args\n        (arg :el))\n      (send\n        (send\n          (lvar :el) :to_s) :size)) :max)\n  (int 0)) + ","(send\n  (lvar :array) :map) max ","el to_s size ","el to_s ","array map ","array empty? ","index + == ","array length ","(begin\n  (send\n    (begin\n      (send\n        (lvar :index) :+\n        (int 1))) :%\n    (begin\n      (send\n        (send nil :terminal_width) :/\n        (lvar :(or\n  (send\n    (block\n      (send\n        (lvar :array) :map)\n      (args\n        (arg :el))\n      (send\n        (send\n          (lvar :el) :to_s) :size)) :max)\n  (int 0)) + ))))) zero? "]}," Thor Util escape_globs":{"type":"method","name":"escape_globs","children":[],"call":["path to_s gsub ","path to_s "]}," Thor Base ClassMethods strict_args_position?":{"type":"method","name":"strict_args_position?","children":[],"call":[" strict_args_position ! ! "," strict_args_position ! "," strict_args_position "]}," Thor Base ClassMethods strict_args_position":{"type":"method","name":"strict_args_position","children":[],"call":[" from_superclass "]}," Thor Base ClassMethods strict_args_position!":{"type":"method","name":"strict_args_position!","children":[],"call":[]}," Thor stop_on_unknown_option?":{"type":"method","name":"stop_on_unknown_option?","children":[],"call":["@stop_on_unknown_option include? ","task name to_sym ","task name ","@stop_on_unknown_option ! ! ","@stop_on_unknown_option ! ","command name to_sym ","command name "," stop_on_unknown_option include? "," stop_on_unknown_option "]}," Thor stop_on_unknown_option!":{"type":"method","name":"stop_on_unknown_option!","children":[],"call":["@stop_on_unknown_option merge ","Set  new "," stop_on_unknown_option merge "," stop_on_unknown_option "," stop_on_unknown_option | "," stop_on_unknown_option |  merge "]}," Thor Options parsing_options?":{"type":"method","name":"parsing_options?","children":[],"call":[" peek "]}," Thor Options current_is_value?":{"type":"method","name":"current_is_value?","children":[],"call":[" parsing_options? ! "," parsing_options? "," peek "]}," Thor Options peek":{"type":"method","name":"peek","children":[],"call":[" shift ","result == ","@extra size ","@args first "]}," Thor CoreExt HashWithIndifferentAccess to_hash":{"type":"method","name":"to_hash","children":[],"call":["Hash  new merge! ","Hash  new "," default "]}," Thor Base ClassMethods stop_on_unknown_option?":{"type":"method","name":"stop_on_unknown_option?","children":[],"call":[]}," Thor Actions Directory files":{"type":"method","name":"files","children":[],"call":["Dir  glob ","Dir  [] "]}," Thor Actions Directory file_level_lookup":{"type":"method","name":"file_level_lookup","children":[],"call":["File  join "]}," Thor find_command_possibilities":{"type":"method","name":"find_command_possibilities","children":[],"call":["unique_possibilities size == ","unique_possibilities size ","possibilities include? ","(send\n  (lvar :possibilities) :map) uniq "," map [] "," map ","possibilities map ","(send\n  (send\n    (send\n      (send nil :all_commands) :merge\n      (send nil :map)) :keys) :select) sort ","meth == ","n [] "," all_commands merge keys select "," all_commands merge keys "," all_commands merge "," all_commands ","meth to_s length ","meth to_s ","(send\n  (lvar :possibilities) :map) uniq  size == ","unique_(send\n  (send\n    (send\n      (send nil :all_commands) :merge\n      (send nil :map)) :keys) :select) sort  size == ","(send\n  (lvar :possibilities) :map) uniq  size ","unique_(send\n  (send\n    (send\n      (send nil :all_commands) :merge\n      (send nil :map)) :keys) :select) sort  size ","(send\n  (send\n    (send\n      (send nil :all_commands) :merge\n      (send nil :map)) :keys) :select) sort  include? ","(send\n  (lvar :(send\n  (send\n    (send\n      (send nil :all_commands) :merge\n      (send nil :map)) :keys) :select) sort ) :map) uniq ","(send\n  (send\n    (send\n      (send nil :all_commands) :merge\n      (send nil :map)) :keys) :select) sort  map ","meth to_s meth to_s length gth "]}," Thor normalize_command_name":{"type":"method","name":"normalize_command_name","children":[],"call":["meth to_s gsub ","meth to_s ","possibilities first "," map [] "," map "," default_command ","possibilities size < ","possibilities size "," raise ","possibilities join ","possibilities size > "," find_command_possibilities "," default_command to_s gsub "," default_command to_s "," fail ","meth to_s tr ","possibilities empty? "," default_command to_s tr ","possibilities first  to_s gsub "," map []  to_s gsub ","possibilities first  to_s "," map []  to_s "," find_command_possibilities  first "," find_command_possibilities  size < "," find_command_possibilities  size "," find_command_possibilities  join "," find_command_possibilities  size > "," find_command_ find_command_possibilities  ","possibilities first  to_s tr "," map []  to_s tr "," find_command_possibilities  empty? "]}," Thor retrieve_command_name":{"type":"method","name":"retrieve_command_name","children":[],"call":["args shift ","meth !~ "," map [] "," map ","args first to_s ","args first ","args empty? ","args first to_s  !~ "]}," Thor create_command":{"type":"method","name":"create_command","children":[],"call":[" puts ","(str \"[WARNING] Attempted to create command \") << << "," caller [] inspect "," caller [] "," caller ","(str \"[WARNING] Attempted to create command \") << ","meth inspect ","meth == "," all_commands [] "," all_commands "," commands []= ","base_class new "," method_options "," commands "]}," Thor printable_commands":{"type":"method","name":"printable_commands","children":[],"call":["(send\n  (begin\n    (if\n      (lvar :all)\n      (send nil :all_commands)\n      (send nil :commands))) :map) compact ","item << ","command description gsub ","command description "," banner ","command hidden? ","(if\n  (lvar :all)\n  (send nil :all_commands)\n  (send nil :commands)) map "," commands "," all_commands "]}," Thor command_help":{"type":"method","name":"command_help","children":[],"call":["shell say ","command description ","shell print_wrapped ","command long_description "," class_options_help ","command options map ","command options "," banner "," handle_no_command_error "," all_commands [] "," all_commands "," normalize_command_name ","command options values "," banner split join "," banner split "," all_commands []  description "," all_commands []  long_description "," all_commands []  options map "," all_commands []  options "," handle_no_ all_commands [] _error "," all_ all_commands [] s [] "," all_ all_commands [] s "," normalize_ all_commands [] _name "," all_commands []  options values "]}," Thor default_command":{"type":"method","name":"default_command","children":[],"call":["meth to_s "," from_superclass ","meth == "]}," Thor package_name":{"type":"method","name":"package_name","children":[],"call":["name == ","name nil? "]}," Thor Util find_class_and_command_by_namespace":{"type":"method","name":"find_class_and_command_by_namespace","children":[],"call":["Thor Util  find_by_namespace ","klass ! ","pieces join ","pieces pop ","namespace split ","namespace include? ","Thor Util  find_by_namespace  ! ","namespace split  join ","namespace split  pop "]}," Thor Shell HTML can_display_colors?":{"type":"method","name":"can_display_colors?","children":[],"call":[]}," Thor Shell Color can_display_colors?":{"type":"method","name":"can_display_colors?","children":[],"call":[" stdout tty? "," stdout "," are_colors_disabled? ! "," are_colors_disabled? "," are_colors_supported? "]}," Thor Shell Basic can_display_colors?":{"type":"method","name":"can_display_colors?","children":[],"call":[]}," Runner display_commands":{"type":"method","name":"display_commands","children":[],"call":[" say "," print_table ","- * ","namespace size "," shell set_color "," shell ","a [] <=> ","b [] ","a [] ","list sort! "]}," Thor Invocation _retrieve_class_and_command":{"type":"method","name":"_retrieve_class_and_command","children":[],"call":[" class prepare_for_invocation "," class ","name to_s "," class all_commands [] "," class all_commands ","name nil? "]}," Thor Invocation invoke_command":{"type":"method","name":"invoke_command","children":[],"call":["command run ","current << ","command name ","current include? ","@_invocations [] "," class ","@_invocations []  << ","@_invocations []  include? "]}," Group create_command":{"type":"method","name":"create_command","children":[],"call":[" commands []= ","Thor Command  new ","meth to_s "," commands "]}," Group self_command":{"type":"method","name":"self_command","children":[],"call":["Thor DynamicCommand  new "," class_options "," namespace "]}," Group printable_commands":{"type":"method","name":"printable_commands","children":[],"call":["item << "," desc gsub "," desc "," banner "]}," IO binread":{"type":"method","name":"binread","children":[],"call":["f read ","File  open "," raise ","1 + ","args size ","args size < "," fail "]}," Thor DynamicCommand run":{"type":"method","name":"run","children":[],"call":["instance class handle_no_command_error "," name ","instance class ","(send\n  (send\n    (lvar :instance) :methods) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ","instance methods & "," name to_sym "," name to_s ","instance methods "]}," Thor DynamicCommand initialize":{"type":"method","name":"initialize","children":[],"call":["name to_s "]}," Thor HiddenCommand hidden?":{"type":"method","name":"hidden?","children":[],"call":[]}," Thor Command handle_no_method_error?":{"type":"method","name":"handle_no_method_error?","children":[],"call":["error message =~ ","Regexp  escape ","instance to_s "," name ","error message "," not_debugging? "]}," Thor Command handle_argument_error?":{"type":"method","name":"handle_argument_error?","children":[],"call":["RUBY_VERSION  >= ","saned size == ","saned size ","saned empty? "," sans_backtrace ","error backtrace ","error message =~ ","error message "," not_debugging? "," sans_backtrace  size == "," sans_backtrace  size "," sans_backtrace  empty? "]}," Thor Command sans_backtrace":{"type":"method","name":"sans_backtrace","children":[],"call":["RUBY_PLATFORM  =~ ","frame =~ ","backtrace reject ","saned - ","RUBY_ENGINE  =~ "]}," Thor Command local_method?":{"type":"method","name":"local_method?","children":[],"call":["(send\n  (lvar :methods) :&\n  (array\n    (send\n      (lvar :name) :to_s)\n    (send\n      (lvar :name) :to_sym))) empty? ! ","(send\n  (lvar :methods) :&\n  (array\n    (send\n      (lvar :name) :to_s)\n    (send\n      (lvar :name) :to_sym))) empty? ","methods & ","name to_sym ","name to_s ","instance public_methods + + ","instance protected_methods ","instance public_methods + ","instance private_methods ","instance public_methods ","(send\n  (lvar :instance public_methods + + ) :&\n  (array\n    (send\n      (lvar :name) :to_s)\n    (send\n      (lvar :name) :to_sym))) empty? ! ","(send\n  (lvar :instance public_methods + + ) :&\n  (array\n    (send\n      (lvar :name) :to_s)\n    (send\n      (lvar :name) :to_sym))) empty? ","instance public_methods + +  & ","instance public_instance public_methods + +  + + ","instance protected_instance public_methods + +  ","instance public_instance public_methods + +  + ","instance private_instance public_methods + +  ","instance public_instance public_methods + +  "]}," Thor Command private_method?":{"type":"method","name":"private_method?","children":[],"call":["(send\n  (send\n    (lvar :instance) :private_methods) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ! ","(send\n  (send\n    (lvar :instance) :private_methods) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ","instance private_methods & "," name to_sym "," name "," name to_s ","instance private_methods "]}," Thor Command public_method?":{"type":"method","name":"public_method?","children":[],"call":["(send\n  (send\n    (lvar :instance) :public_methods) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ! ","(send\n  (send\n    (lvar :instance) :public_methods) :&\n  (array\n    (send\n      (send nil :name) :to_s)\n    (send\n      (send nil :name) :to_sym))) empty? ","instance public_methods & "," name to_sym "," name "," name to_s ","instance public_methods "]}," Thor Command required_options":{"type":"method","name":"required_options","children":[],"call":["(send\n  (send nil :options) :map) compact sort join ","(send\n  (send nil :options) :map) compact sort ","(send\n  (send nil :options) :map) compact ","o usage ","o required? "," options map "," options "]}," Thor Command not_debugging?":{"type":"method","name":"not_debugging?","children":[],"call":["(and\n  (send\n    (send\n      (lvar :instance) :class) :respond_to?\n    (sym :debugging))\n  (send\n    (send\n      (lvar :instance) :class) :debugging)) ! ","instance class debugging ","instance class ","instance class respond_to? "]}," Thor Command formatted_usage":{"type":"method","name":"formatted_usage","children":[],"call":["formatted strip ","formatted << "," required_options "," usage to_s "," usage ","match << << ","(send\n  (send\n    (lvar :klass) :arguments) :map) compact join ","(send\n  (send\n    (lvar :klass) :arguments) :map) compact ","a usage ","klass arguments map ","klass arguments ","match << "," usage to_s gsub "," name ","klass arguments empty? ! ","klass arguments empty? ","klass namespace split last ","klass namespace split ","klass namespace ","namespace gsub ","klass arguments map compact join ","klass arguments map compact "," dup ","(begin\n  (send\n    (send\n      (send\n        (lvar :klass) :namespace) :split\n      (str \":\")) :last)) dup ","(begin\n  (send\n    (lvar :namespace) :gsub\n    (regexp\n      (str \"^(default)\")\n      (regopt))\n    (str \"\"))) dup ","(begin\n  (send nil :ancestor_name)) dup "," ancestor_name ","(send\n  (send nil :Array\n    (send nil :usage)) :map) join ","formatted_specific_usage strip "," required_arguments_for "," Array map "," Array ","(begin\n  (send\n    (lvar :namespace) :gsub\n    (regexp\n      (str \"^(default)\")\n      (regopt))\n    (str \"\"))) dup  strip ","(begin\n  (send nil :ancestor_name)) dup  strip ","(begin\n  (send\n    (lvar :namespace) :gsub\n    (regexp\n      (str \"^(default)\")\n      (regopt))\n    (str \"\"))) dup  << ","(begin\n  (send nil :ancestor_name)) dup  << ","klass klass namespace  split last ","klass klass namespace  split ","klass klass namespace  ","klass namespace  gsub ","(begin\n  (send\n    (send\n      (send\n        (lvar :klass) :klass namespace ) :split\n      (str \":\")) :last)) dup ","(begin\n  (send\n    (lvar :klass namespace ) :gsub\n    (regexp\n      (str \"^(default)\")\n      (regopt))\n    (str \"\"))) dup ","(begin\n  (send\n    (lvar :namespace) :gsub\n    (regexp\n      (str \"^(default)\")\n      (regopt))\n    (str \"\"))) dup _specific_usage strip ","(begin\n  (send nil :ancestor_name)) dup _specific_usage strip "]}," Thor Command run":{"type":"method","name":"run","children":[],"call":[" raise ","instance class handle_no_command_error "," name ","instance class "," handle_no_method_error? "," caller ","instance class handle_argument_error "," handle_argument_error? ","instance __send__ "," name to_sym "," local_method? ","instance method arity ","instance method "," public_method? "," private_method? "," fail ","instance method instance method arity  "]}," Thor Command hidden?":{"type":"method","name":"hidden?","children":[],"call":[]}," Thor Command initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" options= ","other options dup ","other options "]}," Thor Command initialize":{"type":"method","name":"initialize","children":[],"call":["name to_s "]}," Thor Base ClassMethods create_command":{"type":"method","name":"create_command","children":[],"call":[]}," Thor Base ClassMethods find_and_refresh_command":{"type":"method","name":"find_and_refresh_command","children":[],"call":[" raise ","name inspect "," commands []= ","command clone ","name to_s "," commands "," all_commands [] "," all_commands "," commands [] "," fail ","  all_commands [] s []= ","  commands [] s []= "," all_commands []  clone "," commands []  clone ","  all_commands [] s ","  commands [] s "," all_ all_commands [] s [] "," all_ commands [] s [] "," all_ all_commands [] s "," all_ commands [] s ","  all_commands [] s [] ","  commands [] s [] "]}," Thor Base ClassMethods handle_no_command_error":{"type":"method","name":"handle_no_command_error","children":[],"call":[" raise ","command inspect "," namespace inspect "," namespace "," fail ","UndefinedCommandError  new "," all_commands keys "," all_commands "]}," Thor Base ClassMethods public_command":{"type":"method","name":"public_command","children":[],"call":[" class_eval ","names each "]}," Thor Base ClassMethods no_commands":{"type":"method","name":"no_commands","children":[],"call":[" no_commands_context enter "," no_commands_context "]}," Thor Base ClassMethods remove_command":{"type":"method","name":"remove_command","children":[],"call":[" undef_method ","options [] "," all_commands delete ","name to_s "," all_commands "," commands delete "," commands ","names each ","names pop ","names last is_a? ","names last ","names pop  [] "]}," Thor Base ClassMethods all_commands":{"type":"method","name":"all_commands","children":[],"call":["@all_commands merge "," commands "," from_superclass ","Thor CoreExt OrderedHash  new ","@all_commands merge! ","Hash  new "]}," Thor Base ClassMethods commands":{"type":"method","name":"commands","children":[],"call":["Thor CoreExt OrderedHash  new ","Hash  new "]}," Thor Actions CreateLink exists?":{"type":"method","name":"exists?","children":[],"call":["File  symlink? "," destination "]}," Thor dynamic_command_class":{"type":"method","name":"dynamic_command_class","children":[],"call":[]}," Thor stop_on_unknown_option":{"type":"method","name":"stop_on_unknown_option","children":[],"call":["Set  new "]}," Thor subcommand_classes":{"type":"method","name":"subcommand_classes","children":[],"call":[]}," Thor Shell Basic prepare_message":{"type":"method","name":"prepare_message","children":[],"call":["spaces + "," set_color ","message to_s ","   * "," padding ","   *  + "]}," Thor LineEditor best_available":{"type":"method","name":"best_available","children":[],"call":[]}," Thor LineEditor readline":{"type":"method","name":"readline","children":[],"call":[]}," Thor LineEditor Readline PathCompletion base_path":{"type":"method","name":"base_path","children":[],"call":["Dir  pwd "]}," Thor LineEditor Readline PathCompletion glob_pattern":{"type":"method","name":"glob_pattern","children":[],"call":[" text "," base_path "]}," Thor LineEditor Readline PathCompletion absolute_matches":{"type":"method","name":"absolute_matches","children":[],"call":["File  directory? ","Dir  [] map ","Dir  [] "," glob_pattern "]}," Thor LineEditor Readline PathCompletion relative_matches":{"type":"method","name":"relative_matches","children":[],"call":["path sub "," base_path "," absolute_matches map "," absolute_matches "]}," Thor LineEditor Readline PathCompletion matches":{"type":"method","name":"matches","children":[],"call":[" relative_matches "]}," Thor LineEditor Readline PathCompletion initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Thor LineEditor Readline use_path_completion?":{"type":"method","name":"use_path_completion?","children":[],"call":[" options fetch "," options "]}," Thor LineEditor Readline completion_options":{"type":"method","name":"completion_options","children":[],"call":[" options fetch "," options "]}," Thor LineEditor Readline completion_proc":{"type":"method","name":"completion_proc","children":[],"call":["option start_with? "," completion_options select "," completion_options "," proc "," completion_options any? ","PathCompletion  new matches ","PathCompletion  new "," use_path_completion? "]}," Thor LineEditor Readline add_to_history?":{"type":"method","name":"add_to_history?","children":[],"call":[" options fetch "," options "]}," Thor LineEditor Readline readline":{"type":"method","name":"readline","children":[],"call":[" Readline  readline "," add_to_history? "," prompt "," Readline  completion_proc= "," completion_proc "," Readline  completion_append_character= "," echo? "]}," Thor LineEditor Readline available?":{"type":"method","name":"available?","children":[],"call":[]}," Thor LineEditor Basic echo?":{"type":"method","name":"echo?","children":[],"call":[" options fetch "," options "]}," Thor LineEditor Basic get_input":{"type":"method","name":"get_input","children":[],"call":["$stdin noecho ","$stdin gets "," echo? "," require ","RUBY_VERSION  > "]}," Thor LineEditor Basic readline":{"type":"method","name":"readline","children":[],"call":[" get_input ","$stdout print "," prompt "]}," Thor LineEditor Basic initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Thor LineEditor Basic available?":{"type":"method","name":"available?","children":[],"call":[]}," Thor Invocation current_command_chain":{"type":"method","name":"current_command_chain","children":[],"call":["@_invocations values flatten map ","@_invocations values flatten ","@_invocations values "]}," Thor disable_class_options":{"type":"method","name":"disable_class_options","children":[],"call":[]}," Thor Shell Basic indent":{"type":"method","name":"indent","children":[],"call":[" padding= "," padding + "," padding "]}," Thor Option validate_default_type!":{"type":"method","name":"validate_default_type!","children":[],"call":[" raise ","default_type == ","@default class name downcase to_sym ","@default class name downcase ","@default class name ","@default class "," required? "," warn ","@default inspect "," switch_name ","Thor  deprecation_warning ","(begin\n  (lvar :err)) + + ","(begin\n  (lvar :err)) + ","@check_default_type == ","default_type != ","@type != "]}," Thor CoreExt OrderedHash sync_keys!":{"type":"method","name":"sync_keys!","children":[],"call":[" key? ! "," key? ","@keys delete_if "]}," Thor CoreExt OrderedHash inspect":{"type":"method","name":"inspect","children":[],"call":[" class "]}," Thor CoreExt OrderedHash replace":{"type":"method","name":"replace","children":[],"call":["other keys "]}," Thor CoreExt OrderedHash merge!":{"type":"method","name":"merge!","children":[],"call":[" []= ","other_hash each "," [] "," key? "," block_given? "]}," Thor CoreExt OrderedHash shift":{"type":"method","name":"shift","children":[],"call":[" delete ","@keys first ","@@keys first eys first "]}," Thor CoreExt OrderedHash clear":{"type":"method","name":"clear","children":[],"call":["@keys clear "]}," Thor CoreExt OrderedHash each_pair":{"type":"method","name":"each_pair","children":[],"call":[" [] ","@keys each "," to_enum "," block_given? "]}," Thor CoreExt OrderedHash each_value":{"type":"method","name":"each_value","children":[],"call":[" [] ","@keys each "," to_enum "," block_given? "]}," Thor CoreExt OrderedHash each_key":{"type":"method","name":"each_key","children":[],"call":["@keys each "," to_enum "," block_given? "]}," Thor CoreExt OrderedHash to_a":{"type":"method","name":"to_a","children":[],"call":[" [] ","@keys map "]}," Thor CoreExt OrderedHash to_hash":{"type":"method","name":"to_hash","children":[],"call":[]}," Thor CoreExt OrderedHash reject":{"type":"method","name":"reject","children":[],"call":[" dup reject! "," dup "]}," Thor CoreExt OrderedHash delete_if":{"type":"method","name":"delete_if","children":[],"call":[" sync_keys! "]}," Thor CoreExt OrderedHash initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["other keys "]}," Thor CoreExt HashWithIndifferentAccess key?":{"type":"method","name":"key?","children":[],"call":[" convert_key "]}," Thor CoreExt HashWithIndifferentAccess fetch":{"type":"method","name":"fetch","children":[],"call":[" convert_key "]}," Thor Base ClassMethods thor_reserved_word?":{"type":"method","name":"thor_reserved_word?","children":[],"call":[" raise ","word inspect ","THOR_RESERVED_WORDS  include? ","word to_s "]}," Thor Actions CapturableERB set_eoutvar":{"type":"method","name":"set_eoutvar","children":[],"call":["compiler post_cmd= ","compiler pre_cmd= ","compiler insert_cmd= ","compiler put_cmd= "]}," Thor disable_required_check":{"type":"method","name":"disable_required_check","children":[],"call":["Set  new "]}," Thor disable_required_check?":{"type":"method","name":"disable_required_check?","children":[],"call":[" disable_required_check include? ","command name to_sym ","command name "," disable_required_check "]}," Thor disable_required_check!":{"type":"method","name":"disable_required_check!","children":[],"call":[" disable_required_check merge "," disable_required_check "," disable_required_check | "]}," Thor CoreExt HashWithIndifferentAccess replace":{"type":"method","name":"replace","children":[],"call":[]}," Thor CoreExt HashWithIndifferentAccess reverse_merge!":{"type":"method","name":"reverse_merge!","children":[],"call":[" replace "," reverse_merge "]}," Thor CoreExt HashWithIndifferentAccess reverse_merge":{"type":"method","name":"reverse_merge","children":[],"call":[" class new merge "," class new "," class "]}," Thor Base ClassMethods disable_required_check?":{"type":"method","name":"disable_required_check?","children":[],"call":[]}," Thor Base ClassMethods check_default_type?":{"type":"method","name":"check_default_type?","children":[],"call":[" check_default_type ! ! "," check_default_type ! "," check_default_type "]}," Thor Base ClassMethods check_default_type":{"type":"method","name":"check_default_type","children":[],"call":[" from_superclass "]}," Thor Base ClassMethods check_default_type!":{"type":"method","name":"check_default_type!","children":[],"call":[]}," Thor Actions inject_into_module":{"type":"method","name":"inject_into_module","children":[],"call":[" insert_into_file ","args << ","config []= ","args pop ","args last is_a? ","args last ","args pop  []= "]}," Thor Actions EmptyDirectory on_file_clash_behavior":{"type":"method","name":"on_file_clash_behavior","children":[],"call":[" say_status "]}," Thor Shell Basic git_merge_tool":{"type":"method","name":"git_merge_tool","children":[],"call":["(str \"git config merge.tool\") rstrip "]}," Thor Shell Basic merge_tool":{"type":"method","name":"merge_tool","children":[],"call":[" git_merge_tool ","ENV  [] "]}," Thor Shell Basic merge":{"type":"method","name":"merge","children":[],"call":[" system ","temp path "," merge_tool ","temp rewind ","temp write ","Tempfile  open ","File  dirname ","File  extname ","File  basename "," require "]}," Thor UnknownArgumentError initialize":{"type":"method","name":"initialize","children":[],"call":["unknown map join ","unknown map "]}," Thor UnknownArgumentError SpellChecker spell_checker":{"type":"method","name":"spell_checker","children":[],"call":["DidYouMean NoKwargSpellChecker  new "," error switches "," error ","NoKwargSpellChecker  new "]}," Thor UnknownArgumentError SpellChecker corrections":{"type":"method","name":"corrections","children":[],"call":["(send\n  (send\n    (send nil :error) :unknown) :flat_map) uniq map ","(send\n  (send\n    (send nil :error) :unknown) :flat_map) uniq "," spell_checker correct "," spell_checker "," error unknown flat_map "," error unknown "," error "]}," Thor UnknownArgumentError SpellChecker initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Thor UndefinedCommandError initialize":{"type":"method","name":"initialize","children":[],"call":["namespace inspect ","command inspect "]}," Thor UndefinedCommandError SpellChecker spell_checker":{"type":"method","name":"spell_checker","children":[],"call":["DidYouMean NoKwargSpellChecker  new "," error all_commands "," error ","NoKwargSpellChecker  new "]}," Thor UndefinedCommandError SpellChecker corrections":{"type":"method","name":"corrections","children":[],"call":[" spell_checker correct map "," spell_checker correct "," error command "," error "," spell_checker "]}," Thor UndefinedCommandError SpellChecker initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Thor DidYouMean NoKwargSpellChecker initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Thor NoKwargSpellChecker initialize":{"type":"method","name":"initialize","children":[],"call":[]}," UnifiedRuby rewrite_vcall":{"type":"method","name":"rewrite_vcall","children":[],"call":[" rewrite_fcall ","exp push "]}," UnifiedRuby rewrite_resbody":{"type":"method","name":"rewrite_resbody","children":[],"call":[" raise ","structure [] inspect ","structure [] ","structure [] empty? ! ","structure [] empty? ","structure [] nil? "," s include? ","structure flatten [] ","structure flatten "," s ","structure flatten [] == ","result structure ","result << ","code << << ","code << ","list << ","body delete_at ","body [] first == ","body [] first ","body [] ","body first ","exp shift ","exp empty? ","exp first == ","exp first ","result structure  [] inspect ","result structure  [] ","result structure  [] empty? ! ","result structure  [] empty? ","result structure  [] nil? ","result structure  flatten [] ","result structure  flatten ","result structure  flatten [] == ","result result structure  "," s  structure "," s  << "," s  << << ","exp shift  delete_at ","exp shift  [] first == ","exp shift  [] first ","exp shift  [] ","exp shift  first ","exp shift  shift ","exp shift  empty? ","exp shift  first == "]}," UnifiedRuby rewrite_fcall":{"type":"method","name":"rewrite_fcall","children":[],"call":[" rewrite_call ","exp push ","exp size <= ","exp size ","exp insert ","exp []= "]}," UnifiedRuby rewrite_fbody":{"type":"method","name":"rewrite_fbody","children":[],"call":["exp sexp_body "]}," UnifiedRuby rewrite_dmethod":{"type":"method","name":"rewrite_dmethod","children":[],"call":["exp shift "]}," UnifiedRuby rewrite_defs":{"type":"method","name":"rewrite_defs","children":[],"call":["result insert "," rewrite_defn "," s ","exp scope args ","exp scope ","exp shift ","exp delete_at "," rewrite_defn  insert "," s  scope args "," s  scope "," s  shift "," s  delete_at "]}," UnifiedRuby rewrite_defn":{"type":"method","name":"rewrite_defn","children":[],"call":["exp insert "," s ","exp args << ","exp args ","exp scope block block_arg ","exp scope block ","exp scope ","exp scope block args ","exp attrset ","exp ivar ","exp exp scope block args  << ","exp exp scope block args  ","exp scope block exp scope block args  "]}," UnifiedRuby rewrite_call":{"type":"method","name":"rewrite_call","children":[],"call":["exp << "," s "," raise ","args first inspect ","args first ","args []= ","exp pop ","exp last ","exp last  first inspect ","exp last  first ","exp last  []= "]}," UnifiedRuby rewrite_bmethod":{"type":"method","name":"rewrite_bmethod","children":[],"call":["exp find_and_replace_all ","exp block insert ","exp block "," s ","exp sexp_body ","exp delete_at ","args sexp_body ","exp dasgn_curr ","arg last "," raise ","arg size ","arg size == ","exp masgn dasgn_curr sexp_body ","exp masgn dasgn_curr ","exp masgn ","exp []= "," s  find_and_replace_all "," s  block insert "," s  block "," s  s s _body "," s  delete_at ","args s s _body ","exp dasgn_curr  sexp_body ","exp masgn dasgn_curr sexp_body s sexp_body "," s  dasgn_curr ","exp masgn dasgn_curr sexp_body  last ","exp masgn dasgn_curr sexp_body  size ","exp masgn dasgn_curr sexp_body  size == "," s  masgn dasgn_curr s s _body "," s  masgn dasgn_curr "," s  masgn "," s  []= "]}," UnifiedRuby rewrite_argscat":{"type":"method","name":"rewrite_argscat","children":[],"call":["exp [] []= ","exp [] "," raise ","exp inspect ","exp [] [] == ","exp [] [] "]}," SexpProcessor process_dummy":{"type":"method","name":"process_dummy","children":[],"call":["result << "," process ","exp shift ","exp empty? ","@expected new "]}," SexpProcessor on_error_in":{"type":"method","name":"on_error_in","children":[],"call":["@exceptions []= "]}," SexpProcessor error_handler":{"type":"method","name":"error_handler","children":[],"call":[" raise ","$stderr puts "," caller inspect "," caller ","exp inspect ","err class ","@exceptions [] call ","@exceptions [] ","@exceptions has_key? "]}," SexpProcessor assert_type":{"type":"method","name":"assert_type","children":[],"call":[" raise ","list inspect ","typ inspect ","list first != ","list first ","Array  === ! ","Array  === "]}," SexpProcessor generate":{"type":"method","name":"generate","children":[],"call":[" raise "]}," SexpProcessor process":{"type":"method","name":"process","children":[],"call":[" context shift "," context ","result sexp_type= ","exp sexp_type ","result << "," raise ","sub_exp inspect ","Symbol  === ","sub_exp first ","sub_exp empty? ","Array  === "," process "," error_handler ","exp shift ","exp empty? "," caller inspect "," caller ","exp_orig inspect "," class ","type inspect "," assert_empty ","result inspect ","result class ","@expected === "," send ","meth != ","$stderr puts ","meth == ","@processors [] "," puts ","str =~ ","@debug [] ","exp inspect ","@debug has_key? "," rewrite "," context size == "," context size ","@unsupported include? ","exp deep_clone ","@exceptions has_key? "," context unshift ","exp first inspect ","exp first "," expected new "," expected ","supported inspect ","supported empty? ","m - ","o sub intern ","o sub "," public_methods grep "," public_methods ","exp nil? ","result s rewrite _type= ","result sexp_exp first = "," expected new  sexp_type= "," rewrite  s rewrite _type ","exp sexp_exp first  "," expected new  << ","exp shift  inspect ","sub_ rewrite  inspect ","exp shift  first ","sub_ rewrite  first ","exp shift  empty? ","sub_ rewrite  empty? "," rewrite  shift "," rewrite  empty? "," rewrite _orig inspect ","exp deep_clone  inspect ","exp first  inspect "," expected new  inspect "," expected new  class ","@ rewrite ected === ","exp inspect  =~ "," rewrite  inspect ","@unm -  include? "," rewrite  deep_clone "," rewrite  first inspect "," rewrite  first ","  rewrite ected new ","  rewrite ected ","m -  inspect ","m -  empty? "," rewrite  nil? "]}," SexpProcessor rewrite":{"type":"method","name":"rewrite","children":[],"call":[" context shift "," context ","exp first "," send ","@rewriters [] ","old_type == "," rewrite ","Array  === ","exp map! "," context unshift "," send  first ","old_exp first  == "," send  map! "]}," SexpProcessor assert_empty":{"type":"method","name":"assert_empty","children":[],"call":[" raise ","exp_orig inspect ","exp inspect "," class ","exp empty? "]}," SexpProcessor initialize":{"type":"method","name":"initialize","children":[],"call":["@rewriters []= ","name intern ","1 intern ","@processors []= "," public_methods each "," public_methods "]}," Object deep_clone":{"type":"method","name":"deep_clone","children":[],"call":["Marshal  load ","Marshal  dump "]}," s":{"type":"method","name":"s","children":[],"call":["Sexp  new "]}," SexpMatchSpecials ANY":{"type":"method","name":"ANY","children":[],"call":["SexpAny  new "]}," SexpAny inspect":{"type":"method","name":"inspect","children":[],"call":[]}," SexpAny ===":{"type":"method","name":"===","children":[],"call":["Sexp  === "]}," SexpAny ==":{"type":"method","name":"==","children":[],"call":["Sexp  === "]}," Sexp to_s":{"type":"method","name":"to_s","children":[],"call":[" inspect "]}," Sexp to_a":{"type":"method","name":"to_a","children":[],"call":["o to_a ","Sexp  === "," map "]}," Sexp sub":{"type":"method","name":"sub","children":[],"call":["Sexp  from_array ","subset sub ","pattern === ","repl dup ","pattern == "," map "]}," Sexp structure":{"type":"method","name":"structure","children":[],"call":["result << ","subexp structure "," grep each "," grep "," first "," first structure ","Array  === "," class new "," class "," first structure  << "," class new  << "]}," Sexp shift":{"type":"method","name":"shift","children":[],"call":[" raise "," empty? "]}," Sexp sexp_body":{"type":"method","name":"sexp_body","children":[],"call":[" [] "]}," Sexp pretty_print":{"type":"method","name":"pretty_print","children":[],"call":["q pp ","q seplist ","q group "]}," Sexp method_missing":{"type":"method","name":"method_missing","children":[],"call":[" raise "," inspect "," delete ","matches first ","matches size ","sexp first == ","sexp first ","Sexp  === "," find_all ","matches first es first ","matches first es size "]}," Sexp inspect":{"type":"method","name":"inspect","children":[],"call":["(send\n  (self) :map) join ","x inspect "," map "]}," Sexp gsub":{"type":"method","name":"gsub","children":[],"call":["Sexp  from_array ","subset gsub "," map ","pattern == "]}," Sexp find_and_replace_all":{"type":"method","name":"find_and_replace_all","children":[],"call":[" []= ","elem == ","elem find_and_replace_all ","Sexp  === "," each_with_index "]}," Sexp each_of_type":{"type":"method","name":"each_of_type","children":[],"call":["b call ","elem first == ","elem first ","elem each_of_type ","Sexp  === "," each "]}," Sexp array_type?":{"type":"method","name":"array_type?","children":[],"call":["@@array_types include? "," first ","@@array_ first s include? "]}," Sexp =~":{"type":"method","name":"=~","children":[],"call":["pattern === "]}," Sexp ===":{"type":"method","name":"===","children":[],"call":["pattern === ","sexp each ","pattern == ","Sexp  === "]}," Sexp ==":{"type":"method","name":"==","children":[],"call":["obj class == "," class ","obj class "]}," Sexp from_array":{"type":"method","name":"from_array","children":[],"call":[]}," Sexp for":{"type":"method","name":"for","children":[],"call":[]}," Sexp initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Proc to_ruby":{"type":"method","name":"to_ruby","children":[],"call":["ruby gsub! ","ruby sub! "," to_method to_ruby "," to_method "," to_method to_ruby  gsub! "," to_method to_ruby  sub! "," to_method to_ to_method to_ruby  "]}," Proc to_sexp":{"type":"method","name":"to_sexp","children":[],"call":[" to_method to_sexp [] [] "," to_method to_sexp [] "," to_method to_sexp "," to_method "]}," Proc to_method":{"type":"method","name":"to_method","children":[],"call":["ProcStoreTmp  new method ","ProcStoreTmp  new ","ProcStoreTmp  send ","ProcStoreTmp  name ","ProcStoreTmp  ProcStoreTmp  name  "]}," UnboundMethod to_ruby":{"type":"method","name":"to_ruby","children":[],"call":["m to_ruby sub sub ","m to_ruby sub ","m to_ruby ","ProcStoreTmp  new method ","ProcStoreTmp  new ","ProcStoreTmp  send ","ProcStoreTmp  name ","ProcStoreTmp  new method  to_ruby sub sub ","ProcStoreTmp  new method  to_ruby sub ","ProcStoreTmp  new method  to_ruby ","ProcStoreTProcStoreTmp  new method p  new ProcStoreTmp  new method ethod ","ProcStoreTProcStoreTmp  new method p  new ","ProcStoreTProcStoreTmp  new method p  send ","ProcStoreTProcStoreTmp  new method p  naProcStoreTmp  new method e ","ProcStoreTmp  ProcStoreTmp  name  "]}," ProcStoreTmp name":{"type":"method","name":"name","children":[],"call":[]}," Method to_ruby":{"type":"method","name":"to_ruby","children":[],"call":["Ruby2Ruby  new process "," to_sexp ","Ruby2Ruby  new "]}," Method to_sexp":{"type":"method","name":"to_sexp","children":[],"call":["ParseTree  new parse_tree_for_method ","ParseTree  new "," with_class_and_method_name "]}," Method with_class_and_method_name":{"type":"method","name":"with_class_and_method_name","children":[],"call":[" raise "," inspect ","klass nil? ","2 intern "," eval "," inspect =~ "," eval  nil? "]}," Ruby2Ruby indent":{"type":"method","name":"indent","children":[],"call":["(send\n  (send\n    (lvar :s) :to_s) :map) join ","@indent + ","s to_s map ","s to_s "]}," Ruby2Ruby util_module_or_class":{"type":"method","name":"util_module_or_class","children":[],"call":["s + + ","s + "," indent + "," indent ","body join ","body empty? ","body << ","code empty? ","code nil? "," process chomp "," process ","exp shift ","exp empty? ","s << "," indent +  join "," indent +  empty? "," indent +  << "," process chomp  empty? "," process chomp  nil? "]}," Ruby2Ruby util_dthing":{"type":"method","name":"util_dthing","children":[],"call":["s join ","s << << << ","s << << "," process ","s << ","x gsub! ","pt last dump [] ","pt last dump ","pt last ","pt last gsub gsub ","pt last gsub ","pt first ","exp shift ","exp empty? ","exp shift dump [] ","exp shift dump ","exp shift gsub gsub ","exp shift gsub ","pt last dump []  gsub! ","pt last gsub gsub  gsub! ","exp shift dump []  gsub! ","exp shift gsub gsub  gsub! ","exp shift  last dump [] ","exp shift  last dump ","exp shift  last ","exp shift  last gsub gsub ","exp shift  last gsub ","exp shift  first ","ept last dump [] p shift ","ept last gsub gsub p shift ","eexp shift dump [] p shift ","eexp shift gsub gsub p shift ","ept last dump [] p empty? ","ept last gsub gsub p empty? ","eexp shift dump [] p empty? ","eexp shift gsub gsub p empty? ","exp emexp shift y? ","ept last dump [] p shift dump [] ","ept last gsub gsub p shift dump [] ","eexp shift dump [] p shift dump [] ","eexp shift gsub gsub p shift dump [] ","ept last dump [] p shift dump ","ept last gsub gsub p shift dump ","eexp shift dump [] p shift dump ","eexp shift gsub gsub p shift dump ","ept last dump [] p shift gsub gsub ","ept last gsub gsub p shift gsub gsub ","eexp shift dump [] p shift gsub gsub ","eexp shift gsub gsub p shift gsub gsub ","ept last dump [] p shift gsub ","ept last gsub gsub p shift gsub ","eexp shift dump [] p shift gsub ","eexp shift gsub gsub p shift gsub "]}," Ruby2Ruby rewrite_rescue":{"type":"method","name":"rewrite_rescue","children":[],"call":[" s "," context [] == "," context [] "," context ","(sym :defn) include? "]}," Ruby2Ruby cond_loop":{"type":"method","name":"cond_loop","children":[],"call":["code join ","code << "," indent chomp "," indent ","exp shift "," process "]}," Ruby2Ruby process_zsuper":{"type":"method","name":"process_zsuper","children":[],"call":[]}," Ruby2Ruby process_zarray":{"type":"method","name":"process_zarray","children":[],"call":[]}," Ruby2Ruby process_yield":{"type":"method","name":"process_yield","children":[],"call":[" process ","args []= ","args first == ","args first ","exp shift ","exp empty? "," process  []= ","exp shift  []= "," process  first == ","exp shift  first == "," process  first ","exp shift  first "]}," Ruby2Ruby process_xstr":{"type":"method","name":"process_xstr","children":[],"call":[" process_str [] "," process_str "]}," Ruby2Ruby process_while":{"type":"method","name":"process_while","children":[],"call":[" cond_loop "]}," Ruby2Ruby process_when":{"type":"method","name":"process_when","children":[],"call":["src join ","src << ","code chomp "," indent ","code =~ "," process ","exp shift "," process to_s [] "," process to_s ","exp empty? "," context [] == "," context [] "," context "," indent  chomp "," indent  =~ "]}," Ruby2Ruby process_valias":{"type":"method","name":"process_valias","children":[],"call":["exp shift "]}," Ruby2Ruby process_until":{"type":"method","name":"process_until","children":[],"call":[" cond_loop "]}," Ruby2Ruby process_undef":{"type":"method","name":"process_undef","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_true":{"type":"method","name":"process_true","children":[],"call":[]}," Ruby2Ruby process_to_ary":{"type":"method","name":"process_to_ary","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_svalue":{"type":"method","name":"process_svalue","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_super":{"type":"method","name":"process_super","children":[],"call":[" process ","args []= ","args [] == ","args [] ","exp shift ","exp shift  []= ","exp shift  [] == ","exp shift  [] "]}," Ruby2Ruby process_str":{"type":"method","name":"process_str","children":[],"call":["exp shift dump ","exp shift "]}," Ruby2Ruby process_splat":{"type":"method","name":"process_splat","children":[],"call":[" process ","exp shift ","exp empty? "]}," Ruby2Ruby process_self":{"type":"method","name":"process_self","children":[],"call":[]}," Ruby2Ruby process_scope":{"type":"method","name":"process_scope","children":[],"call":[" process ","exp shift ","exp empty? "]}," Ruby2Ruby process_sclass":{"type":"method","name":"process_sclass","children":[],"call":[" indent "," process ","exp shift "]}," Ruby2Ruby process_return":{"type":"method","name":"process_return","children":[],"call":[" process ","exp shift ","exp empty? "]}," Ruby2Ruby process_retry":{"type":"method","name":"process_retry","children":[],"call":[]}," Ruby2Ruby process_rescue":{"type":"method","name":"process_rescue","children":[],"call":[" process ","resbody shift ","exp shift "," assert_type ","exp first ","code join chomp ","code join ","code << ","current == ","r !~ ","(send\n  (ivar :@indent) :+\n  (lvar :r)) size < ","(send\n  (ivar :@indent) :+\n  (lvar :r)) size ","@indent + ","(lvar :body) compact join ","(lvar :body) compact ","resbody gsub ","(sym :block) include? "," indent ","exp empty? ","exp first first == ","exp first first "," context [] "," context "," p(lvar :body) compact join ocess "," process  shift ","resbody shift  shift ","exp shift  shift ","res process  shift ","(lvar :body) compact join esbody shift "," asse(lvar :body) compact join t_type ","exp fi(lvar :body) compact join st ","cu(lvar :body) compact join (lvar :body) compact join ent == "," context []  == ","(lvar :body) compact join  !~ ","(send\n  (iva(lvar :body) compact join  :@indent) :+\n  (lva(lvar :body) compact join  :(lvar :body) compact join )) size < ","(send\n  (iva(lvar :body) compact join  :@indent) :+\n  (lva(lvar :body) compact join  :(lvar :body) compact join )) size ","(lvar : process ) compact join ","(lva(lvar :body) compact join  :body) compact join ","(lvar : process ) compact ","(lva(lvar :body) compact join  :body) compact "," process  gsub ","resbody shift  gsub ","exp shift  gsub ","res process  gsub ","(lvar :body) compact join esbody gsub ","exp fi(lvar :body) compact join st fi(lvar :body) compact join st == ","exp fi(lvar :body) compact join st fi(lvar :body) compact join st "]}," Ruby2Ruby process_resbody":{"type":"method","name":"process_resbody","children":[],"call":["code join ","sexp shift "," assert_type ","exp shift ","exp empty? ","code << "," indent "," indent chomp "," process ","code last << ","code last ","list []= ","list size > ","list size ","body delete_at [] ","body delete_at ","(sym :dasgn_curr) include? ","body [] [] ","body [] ","body nil? ","list pop [] ","list pop ","(sym :lasgn) include? ","list last first ","list last ","sexp empty? ","sexp nil? ","exp shift  shift ","sexp shift  []= ","sexp shift  size > ","sexp shift  size ","sexp shift  delete_at [] ","sexp shift  delete_at ","sexp shift  [] [] ","sexp shift  [] ","sexp shift  nil? ","sexp shift  pop [] ","sexp shift  pop ","sexp shift  last first ","sexp shift  last ","exp shift  empty? ","exp shift  nil? "]}," Ruby2Ruby process_redo":{"type":"method","name":"process_redo","children":[],"call":[]}," Ruby2Ruby process_postexe":{"type":"method","name":"process_postexe","children":[],"call":[]}," Ruby2Ruby process_or":{"type":"method","name":"process_or","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_op_asgn_and":{"type":"method","name":"process_op_asgn_and","children":[],"call":[" process sub "," process ","exp shift "]}," Ruby2Ruby process_op_asgn_or":{"type":"method","name":"process_op_asgn_or","children":[],"call":[" process sub "," process ","exp shift "]}," Ruby2Ruby process_op_asgn2":{"type":"method","name":"process_op_asgn2","children":[],"call":[" process ","exp shift ","exp shift to_s [] ","exp shift to_s "]}," Ruby2Ruby process_op_asgn1":{"type":"method","name":"process_op_asgn1","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_nth_ref":{"type":"method","name":"process_nth_ref","children":[],"call":["exp shift "]}," Ruby2Ruby process_not":{"type":"method","name":"process_not","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_nil":{"type":"method","name":"process_nil","children":[],"call":[]}," Ruby2Ruby process_next":{"type":"method","name":"process_next","children":[],"call":[" process ","exp shift ","exp empty? "]}," Ruby2Ruby process_module":{"type":"method","name":"process_module","children":[],"call":[" util_module_or_class "]}," Ruby2Ruby process_match3":{"type":"method","name":"process_match3","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_match2":{"type":"method","name":"process_match2","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_match":{"type":"method","name":"process_match","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_masgn":{"type":"method","name":"process_masgn","children":[],"call":["lhs join ","r [] ","t != "," process "," process_argscat ","rhs shift ","t == ","rhs first ","rhs nil? ","lhs << "," splat ","rhs last "," context [] == "," context [] "," context "," raise ","lhs inspect ","lhs last ","l first ","lhs map ","lhs shift ","lhs first ","exp shift ","rhs []= ","rhs [] ","rhs == "," s ","exp empty? ","exp shift  join ","r []  [] "," process  [] ","rhs first  != "," pr [] ocess "," p process ocess "," pr [] ocess_ar [] gscat "," p process ocess_a process gscat "," process_argscarhs first  ","r [] hs shift "," process hs shift ","rhs shifrhs first  ","exp shift  shift ","rhs first  == ","r [] hs fir [] st "," process hs fi process st ","rhs firsrhs first  ","exp shift  first ","r [] hs nil? "," process hs nil? ","exp shift  nil? ","exp shift  << "," splarhs first  ","r [] hs last "," process hs last ","rhs lasrhs first  ","exp shift  last "," conrhs first exrhs first  [] == "," conrhs first exrhs first  [] "," conrhs first exrhs first  "," r [] aise ","  process aise ","lhs inspecrhs first  ","exp shift  inspect ","lhs lasrhs first  ","l fir [] st ","l fi process st ","l firsrhs first  ","exp shift  map ","lhs shifrhs first  ","lhs fir [] st ","lhs fi process st ","lhs firsrhs first  ","exp shifrhs first  ","r [] hs []= "," process hs []= ","exp shift  []= ","r [] hs [] "," process hs [] ","exp shift  [] ","r [] hs == "," process hs == ","exp shift  == ","exp emprhs first y? "]}," Ruby2Ruby splat":{"type":"method","name":"splat","children":[],"call":[]}," Ruby2Ruby process_lvar":{"type":"method","name":"process_lvar","children":[],"call":["exp shift to_s ","exp shift "]}," Ruby2Ruby process_lit":{"type":"method","name":"process_lit","children":[],"call":["obj inspect ","exp shift ","exp shift  inspect "]}," Ruby2Ruby process_lasgn":{"type":"method","name":"process_lasgn","children":[],"call":[" process ","exp shift ","exp empty? "]}," Ruby2Ruby process_ivar":{"type":"method","name":"process_ivar","children":[],"call":["exp shift to_s ","exp shift "]}," Ruby2Ruby process_iter":{"type":"method","name":"process_iter","children":[],"call":["result join ","result << "," indent ","body strip ","result size < ","result size ","result !~ ","iter sub! ","iter == "," process ","exp shift ","exp empty? ","args == ","result join  join ","result join  << "," process  strip ","result join  size < ","result join  size ","result join  !~ "," process  sub! "," process  == ","exp shift  == "]}," Ruby2Ruby process_if":{"type":"method","name":"process_if","children":[],"call":[" indent ","r !~ ","(send\n  (ivar :@indent) :+\n  (lvar :r)) size < ","(send\n  (ivar :@indent) :+\n  (lvar :r)) size ","@indent + ","r << ","r =~ ","c chomp ","c =~ "," process ","exp shift ","Ruby2Ruby ASSIGN_NODES  include? ","exp first first ","exp first "," inden process  ","(send\n  (ivar :@inden process ) :+\n  (lvar :r)) size < ","(send\n  (ivar :@inden process ) :+\n  (lvar :r)) size ","@inden process  + "," process   process homp "," process  =~ "," pro process ess ","exp shi process t ","exp shif process  ","Ruby2Ruby ASSIGN_NODES  in process lude? ","exp  process irst  process irst ","exp firs process  firs process  ","exp  process irst ","exp firs process  "]}," Ruby2Ruby process_iasgn":{"type":"method","name":"process_iasgn","children":[],"call":[" process ","exp shift ","lhs to_s ","exp empty? ","exp shift  to_s "]}," Ruby2Ruby process_hash":{"type":"method","name":"process_hash","children":[],"call":["result join "," context [] "," context ","result << "," process ","exp shift ","exp empty? "]}," Ruby2Ruby process_gvar":{"type":"method","name":"process_gvar","children":[],"call":["exp shift to_s ","exp shift "]}," Ruby2Ruby process_gasgn":{"type":"method","name":"process_gasgn","children":[],"call":[" process_iasgn "]}," Ruby2Ruby process_for":{"type":"method","name":"process_for","children":[],"call":["result join ","result << "," indent "," process ","exp shift ","exp empty? "]}," Ruby2Ruby process_flip3":{"type":"method","name":"process_flip3","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_flip2":{"type":"method","name":"process_flip2","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_fcall":{"type":"method","name":"process_fcall","children":[],"call":["code join ","code empty? ","code << "," process ","args []= ","args first == ","args first ","args nil? ","exp shift ","exp shift to_s ","Symbol  === ","exp first ","exp shift  []= ","exp shift  first == ","exp shift  first ","exp shift  nil? "]}," Ruby2Ruby process_false":{"type":"method","name":"process_false","children":[],"call":[]}," Ruby2Ruby process_evstr":{"type":"method","name":"process_evstr","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_ensure":{"type":"method","name":"process_ensure","children":[],"call":[" indent "," process ","exp shift "]}," Ruby2Ruby process_dxstr":{"type":"method","name":"process_dxstr","children":[],"call":[" process_dstr [] "," process_dstr "]}," Ruby2Ruby process_dvar":{"type":"method","name":"process_dvar","children":[],"call":["exp shift to_s ","exp shift "]}," Ruby2Ruby process_dsym":{"type":"method","name":"process_dsym","children":[],"call":[" process_dstr "]}," Ruby2Ruby process_dstr":{"type":"method","name":"process_dstr","children":[],"call":[" util_dthing "]}," Ruby2Ruby process_dregx_once":{"type":"method","name":"process_dregx_once","children":[],"call":[" process_dregx + "," process_dregx "]}," Ruby2Ruby process_dregx":{"type":"method","name":"process_dregx","children":[],"call":["/ << << ","/ << "," util_dthing "]}," Ruby2Ruby process_dot3":{"type":"method","name":"process_dot3","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_dot2":{"type":"method","name":"process_dot2","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_defs":{"type":"method","name":"process_defs","children":[],"call":[" process_defn ","exp unshift ","exp shift "," process "]}," Ruby2Ruby process_defn":{"type":"method","name":"process_defn","children":[],"call":[" raise ","exp inspect ","(str \"def \") gsub "," indent "," process ","exp shift ","args == ","name to_s [] ","name to_s ","exp clear ","name inspect ","(sym :ivar) include? ","type1 == ","exp [] first ","exp [] "," process  == ","exp shift  to_s [] ","exp shift  to_s ","exp shift  inspect ","exp [] first  == "]}," Ruby2Ruby process_defined":{"type":"method","name":"process_defined","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_dasgn":{"type":"method","name":"process_dasgn","children":[],"call":[" process ","exp shift ","exp shift to_s ","exp size == ","exp size "]}," Ruby2Ruby process_dasgn_curr":{"type":"method","name":"process_dasgn_curr","children":[],"call":[" process ","rhs first == ","rhs first "," context [] == "," context [] "," context ","rhs nil? ","exp shift ","exp empty? ","exp shift to_s "]}," Ruby2Ruby process_cvdecl":{"type":"method","name":"process_cvdecl","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_cvasgn":{"type":"method","name":"process_cvasgn","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_cvar":{"type":"method","name":"process_cvar","children":[],"call":["exp shift "]}," Ruby2Ruby process_const":{"type":"method","name":"process_const","children":[],"call":["exp shift to_s ","exp shift "]}," Ruby2Ruby process_colon3":{"type":"method","name":"process_colon3","children":[],"call":["exp shift "]}," Ruby2Ruby process_colon2":{"type":"method","name":"process_colon2","children":[],"call":["exp shift "," process "]}," Ruby2Ruby process_class":{"type":"method","name":"process_class","children":[],"call":[" util_module_or_class "]}," Ruby2Ruby process_cdecl":{"type":"method","name":"process_cdecl","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_case":{"type":"method","name":"process_case","children":[],"call":["result join ","result << "," indent ","code =~ "," process ","pt first == ","pt first ","exp shift ","exp empty? "," indent  =~ ","exp shift  first == ","exp shift  first ","exp emexp shift y? "]}," Ruby2Ruby process_call":{"type":"method","name":"process_call","children":[],"call":["receiver nil? ","args empty? "," process "," process [] ","args_exp first == ","args_exp first ","exp shift ","Ruby2Ruby ASSIGN_NODES  include? ","exp first first ","exp first ","exp first nil? "," process  nil? "," process  empty? "," process _exp first == "," process _exp first "]}," Ruby2Ruby process_break":{"type":"method","name":"process_break","children":[],"call":[" process ","exp shift ","exp empty? "]}," Ruby2Ruby process_block_pass":{"type":"method","name":"process_block_pass","children":[],"call":[" process ","call << ","call last << ","call last ","call last first == ","call last first ","Array  === ","call pop ","exp shift "," s ","exp shift  << ","exp shift  last << ","exp shift  last ","exp shift  last first == ","exp shift  last first ","exp shift  pop "]}," Ruby2Ruby process_block_arg":{"type":"method","name":"process_block_arg","children":[],"call":["exp shift "]}," Ruby2Ruby process_block":{"type":"method","name":"process_block","children":[],"call":["result + "," context [] "," context ","result join ","result << "," process ","code first == ","code first ","code nil? ","exp shift ","exp empty? ","exp << ","result join  + ","result join  join ","result join  << ","exp shift  first == ","exp shift  first ","exp shift  nil? "]}," Ruby2Ruby process_begin":{"type":"method","name":"process_begin","children":[],"call":["code join ","code << "," indent ","src =~ "," process ","exp shift ","exp empty? ","exp first first == ","exp first first ","exp first "," indent  =~ "," process  =~ "]}," Ruby2Ruby process_back_ref":{"type":"method","name":"process_back_ref","children":[],"call":["exp shift "]}," Ruby2Ruby process_attrasgn":{"type":"method","name":"process_attrasgn","children":[],"call":["name to_s [] ","name to_s "," process [] "," process ","args []= ","args [] == ","args [] ","args pop ","exp shift ","exp empty? ","exp shift  to_s [] ","exp shift  to_s ","exp shift  []= ","exp shift  [] == ","exp shift  [] ","exp shift  pop "]}," Ruby2Ruby process_array":{"type":"method","name":"process_array","children":[],"call":[" process_arglist "]}," Ruby2Ruby process_argspush":{"type":"method","name":"process_argspush","children":[],"call":[" process_arglist "]}," Ruby2Ruby process_argscat":{"type":"method","name":"process_argscat","children":[],"call":["args join ","args << "," process ","exp shift ","exp empty? ","ary shift ","ary empty? ","exp shift  shift ","exp shift  empty? "]}," Ruby2Ruby process_arglist":{"type":"method","name":"process_arglist","children":[],"call":["code join ","code << "," process ","exp shift ","exp empty? "]}," Ruby2Ruby process_args":{"type":"method","name":"process_args","children":[],"call":["args join "," raise ","arg inspect ","arg first inspect ","arg first ","args << ","arg last ","args []= ","asgns [] ","asgns has_key? ","args each_with_index ","asgns []= "," process ","lasgn [] ","arg [] each ","arg [] ","exp shift ","exp empty? ","exp shift s join ","exp shift  inspect ","exp shift  first inspect ","exp shift  first ","exp shift s << ","exp shift  last ","exp shift s []= ","exp shift s each_with_index ","exp shift  [] each ","exp shift  [] "]}," Ruby2Ruby process_and":{"type":"method","name":"process_and","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process_alias":{"type":"method","name":"process_alias","children":[],"call":[" process ","exp shift "]}," Ruby2Ruby process":{"type":"method","name":"process","children":[],"call":["Sexp  from_array ","Array  === ","Sexp  === ","SSexp  from_array   from_array ","SSexp  from_array   === "]}," Ruby2Ruby initialize":{"type":"method","name":"initialize","children":[],"call":[" expected= "," strict= "," auto_shift_type= "]}," Ruby2Ruby translate":{"type":"method","name":"translate","children":[],"call":[]}," Thor usage":{"type":"method","name":"usage","children":[],"call":["list usages assoc [] + ","  + "," class format_opts ","list opts assoc [] ","list opts assoc ","list opts "," class ","list usages assoc [] ","list usages assoc ","list usages "," class help_list "," class help_list  usages assoc [] + "," class help_list  opts assoc [] "," class help_list  opts assoc "," class help_list  opts "," class help_list  usages assoc [] "," class help_list  usages assoc "," class help_list  usages "," class help_ class help_list  "]}," Thor initialize":{"type":"method","name":"initialize","children":[],"call":[" puts "," usage "," send ","op to_sym "," methods include? ! "," methods include? "," methods "," public_methods include? "," public_methods "]}," Thor format_opts":{"type":"method","name":"format_opts","children":[],"call":[]}," Thor help_list":{"type":"method","name":"help_list","children":[],"call":[]}," Thor method_added":{"type":"method","name":"method_added","children":[],"call":[" tasks []= ","Task  new "," tasks "," register_klass_file ","@usage ! "," public_instance_methods include? ! "," public_instance_methods include? "," public_instance_methods ","meth == ","meth to_s "," public_instance_meth to_s ods include? ! "," public_instance_meth to_s ods include? "," public_instance_meth to_s ods ","meth to_s  == ","meth to_s  to_s "]}," Thor subclasses":{"type":"method","name":"subclasses","children":[],"call":[]}," Thor subclass_files":{"type":"method","name":"subclass_files","children":[],"call":[]}," Thor inherited":{"type":"method","name":"inherited","children":[],"call":[" register_klass_file "]}," Thor convert_task_options":{"type":"method","name":"convert_task_options","children":[],"call":[]}," Thor spec_task":{"type":"method","name":"spec_task","children":[],"call":[]}," Thor install_task":{"type":"method","name":"install_task","children":[],"call":[]}," Thor package_task":{"type":"method","name":"package_task","children":[],"call":[]}," Getopt Long getopts":{"type":"method","name":"getopts","children":[],"call":[]}," Thor register_klass_file":{"type":"method","name":"register_klass_file","children":[],"call":[" subclasses << "," subclasses "," subclasses include? ","file_subclasses << ","file_subclasses include? "," subclass_files [] ","File  expand_path "," subclass_files "," superclass register_klass_file "," superclass "," == "," subclass_files []  << "," subclass_files []  include? "]}," Thor maxima":{"type":"method","name":"maxima","children":[],"call":[]}," Thor []":{"type":"method","name":"[]","children":[],"call":[]}," Thor opts":{"type":"method","name":"opts","children":[],"call":[]}," Thor tasks":{"type":"method","name":"tasks","children":[],"call":[]}," Thor Util make_constant":{"type":"method","name":"make_constant","children":[],"call":[]}," Thor Util constants_in_contents":{"type":"method","name":"constants_in_contents","children":[],"call":[]}," Thor Util to_constant":{"type":"method","name":"to_constant","children":[],"call":[]}," Thor Util constant_from_thor_path":{"type":"method","name":"constant_from_thor_path","children":[],"call":[]}," Thor Util constant_to_thor_path":{"type":"method","name":"constant_to_thor_path","children":[],"call":[]}," PackageTask run":{"type":"method","name":"run","children":[],"call":["FileUtils  mv ","File  join "," spec file_name "," spec ","@opts [] ","Gem Builder  new build ","Gem Builder  new ","FileUtils  mkdir_p "]}," PackageTask initialize":{"type":"method","name":"initialize","children":[],"call":["(pair\n  (sym :dir)\n  (send\n    (const nil :File) :join\n    (send\n      (const nil :Dir) :pwd)\n    (str \"pkg\"))) merge ","File  join ","Dir  pwd "]}," TaskHash []":{"type":"method","name":"[]","children":[],"call":["Thor Task  dynamic ","task with_klass ","@klass superclass tasks [] ","@klass superclass tasks ","@klass superclass ","@klass == "]}," TaskHash each":{"type":"method","name":"each","children":[],"call":["t with_klass ","@klass superclass tasks each ","@klass superclass tasks ","@klass superclass ","@klass == "]}," TaskHash initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Thor Task parse_args":{"type":"method","name":"parse_args","children":[],"call":[" opts non_opts "," opts "," opts parse "," full_opts non_opts "," full_opts "," full_opts parse "," options? ","args nil? "]}," Thor Task opts":{"type":"method","name":"opts","children":[],"call":[" opts= ","Options  new "," kind_of? "]}," Thor Task with_klass":{"type":"method","name":"with_klass","children":[],"call":["new klass= "," dup "," dup  klass= "]}," Thor Task namespace":{"type":"method","name":"namespace","children":[],"call":["Thor Util  constant_to_thor_path "," klass "]}," Thor Task parse":{"type":"method","name":"parse","children":[],"call":[" run ","obj options= "," parse_args "]}," Runner load_thorfile":{"type":"method","name":"load_thorfile","children":[],"call":["$stderr puts ","e message ","path inspect "," load ","Thor Tasks  class_eval ","File  read "]}," Runner thor_root_glob":{"type":"method","name":"thor_root_glob","children":[],"call":[" class thor_root_glob "," class "]}," Runner globs_for":{"type":"method","name":"globs_for","children":[],"call":[]}," Thor OrderedHash +":{"type":"method","name":"+","children":[],"call":["new []= "," [] ","other each "," clone "," clone  []= "]}," Thor OrderedHash values":{"type":"method","name":"values","children":[],"call":[" map "]}," Thor OrderedHash each":{"type":"method","name":"each","children":[],"call":["node value ","node key ","node next ","@first value ","@first key ","node next  value ","node next  key ","node next  next "]}," Thor OrderedHash []=":{"type":"method","name":"[]=","children":[],"call":["@hash []= ","@last next= ","node prev= ","@first nil? ","old prev next= ","old next ","old prev ","@hash [] ","Node  new ","Node  new  prev= ","@hash []  prev next= ","@hash []  next ","@hash []  prev "]}," Thor OrderedHash []":{"type":"method","name":"[]","children":[],"call":["@hash [] value ","@hash [] "]}," Thor OrderedHash initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":["other instance_variable_get clone ","other instance_variable_get "]}," Thor OrderedHash initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Thor Options check_required!":{"type":"method","name":"check_required!","children":[],"call":[" raise ","hash [] ! ","hash [] "," undasherize ","type == "]}," Thor Options switch_type":{"type":"method","name":"switch_type","children":[],"call":["@switches [] "]}," Thor Options current_is_option?":{"type":"method","name":"current_is_option?","children":[],"call":[" valid? ","1 split any? ","1 split "," peek "]}," Thor Options valid?":{"type":"method","name":"valid?","children":[],"call":["@shorts key? ","@switches key? "]}," Thor Options unshift":{"type":"method","name":"unshift","children":[],"call":["@args unshift ","arg + ","arg kind_of? ","arg +  unshift "]}," Thor Options shift":{"type":"method","name":"shift","children":[],"call":["@args shift "]}," Thor Options dasherize":{"type":"method","name":"dasherize","children":[],"call":["(if\n  (send\n    (send\n      (lvar :str) :length) :>\n    (int 1))\n  (str \"--\")\n  (str \"-\")) + ","str length > ","str length "]}," Thor Options undasherize":{"type":"method","name":"undasherize","children":[],"call":["str sub "]}," Thor Options assert_value!":{"type":"method","name":"assert_value!","children":[],"call":[" raise "," peek nil? "," peek "]}," Thor Options formatted_usage":{"type":"method","name":"formatted_usage","children":[],"call":["(send\n  (ivar :@switches) :map) join ","[ + + + + ","[ + + + ","sample to_s ","[ + + ","[ + ","opt gsub upcase ","opt gsub ","@defaults [] "," undasherize ","opt + + ","opt + ","@switches map ","@switches empty? "," undasherize gsub upcase "," undasherize gsub ","@defaults []  to_s "]}," Thor Options non_opts":{"type":"method","name":"non_opts","children":[],"call":[" leading_non_opts + "," trailing_non_opts "," leading_non_opts "]}," Thor Options Hash method_missing":{"type":"method","name":"method_missing","children":[],"call":[" [] ! ! "," [] ! "," [] ","method to_s =~ ","method to_s "]}," Thor Options Hash convert_key":{"type":"method","name":"convert_key","children":[],"call":["key to_s ","key kind_of? "]}," Thor Options Hash values_at":{"type":"method","name":"values_at","children":[],"call":[" [] "," convert_key ","indices collect "]}," Thor Options Hash []":{"type":"method","name":"[]","children":[],"call":[" convert_key "]}," Thor Options Hash initialize":{"type":"method","name":"initialize","children":[],"call":[" update "]}," ObjectSpace classes":{"type":"method","name":"classes","children":[],"call":["klasses << ","ObjectSpace  each_object "]}," Thor group_name":{"type":"method","name":"group_name","children":[],"call":[]}," Thor group":{"type":"method","name":"group","children":[],"call":[]}," Thor Task options?":{"type":"method","name":"options?","children":[],"call":["@options kind_of? ","@options empty? ! ","@options empty? "]}," Thor Task full_opts":{"type":"method","name":"full_opts","children":[],"call":["Options  new ","(or\n  (send\n    (send nil :klass) :opts)\n  (hash)) merge "," klass opts "," klass "]}," Thor Util full_const_get":{"type":"method","name":"full_const_get","children":[],"call":[]}," Thor deprecation_warning":{"type":"method","name":"deprecation_warning","children":[],"call":[" warn ","(str \"Deprecation warning: \") + ","ENV  [] "]}," Thor Util escape_html":{"type":"method","name":"escape_html","children":[],"call":["CGI  escapeHTML "]}," Thor Shell Color are_colors_disabled?":{"type":"method","name":"are_colors_disabled?","children":[],"call":["ENV  [] nil? ! ","ENV  [] nil? ","ENV  [] ","ENV  [] empty? ! ","ENV  [] empty? "]}," Thor Shell Basic answer_match":{"type":"method","name":"answer_match","children":[],"call":["possibility == ","possibilities detect ","possibility downcase == ","answer downcase ","possibility downcase "]}," Thor Options assign_result!":{"type":"method","name":"assign_result!","children":[],"call":["@assigns []= ","option human_name ","(or-asgn\n  (send\n    (ivar :@assigns) :[]\n    (send\n      (lvar :option) :human_name))\n  (array)) << ","@assigns [] ","option repeatable ","(or-asgn\n  (send\n    (ivar :@assigns) :[]\n    (send\n      (lvar :option) :human_name))\n  (hash)) merge! ","option type == ","option type "]}," Thor NestedContext pop":{"type":"method","name":"pop","children":[],"call":[]}," Thor NestedContext push":{"type":"method","name":"push","children":[],"call":[]}," Thor NestedContext entered?":{"type":"method","name":"entered?","children":[],"call":["@depth > "]}," Thor NestedContext enter":{"type":"method","name":"enter","children":[],"call":[" pop "," push "]}," Thor NestedContext initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Thor Command required_arguments_for":{"type":"method","name":"required_arguments_for","children":[],"call":["usage to_s ","match << << ","klass arguments map compact join ","klass arguments map compact ","klass arguments map ","klass arguments ","match << ","usage to_s gsub "," name ","klass arguments empty? ! ","klass arguments empty? "]}," Thor Base ClassMethods no_commands?":{"type":"method","name":"no_commands?","children":[],"call":[" no_commands_context entered? "," no_commands_context "]}," Thor Base ClassMethods no_commands_context":{"type":"method","name":"no_commands_context","children":[],"call":["NestedContext  new "]}," Thor Base ClassMethods allow_incompatible_default_type!":{"type":"method","name":"allow_incompatible_default_type!","children":[],"call":[]}," Thor Shell Color are_colors_supported?":{"type":"method","name":"are_colors_supported?","children":[],"call":["ENV  [] != ","ENV  [] "," stdout tty? "," stdout "]}," Thor Shell Basic say_error":{"type":"method","name":"say_error","children":[],"call":[" stderr flush "," stderr "," stderr print ","buffer << ","message to_s end_with? ! ","message to_s end_with? ","message to_s "," prepare_message "," quiet? "," prepare_message  << "]}," Thor CoreExt HashWithIndifferentAccess except":{"type":"method","name":"except","children":[],"call":["hash delete "," convert_key ","keys each "," dup tap "," dup "]}," Thor Option aliases_for_usage":{"type":"method","name":"aliases_for_usage","children":[],"call":[" aliases join "," aliases "," aliases empty? "]}," Thor corrections":{"type":"method","name":"corrections","children":[],"call":[" class const_get new corrections "," class const_get new "," class const_get "," class "]}," Thor to_s":{"type":"method","name":"to_s","children":[],"call":[" + ","DidYouMean  formatter message_for "," corrections ","DidYouMean  formatter "]}}