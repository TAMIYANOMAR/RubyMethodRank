{" MiniPortile make_cmd":{"type":"method","name":"make_cmd","children":[],"call":["m dup ","ENV  [] ","(or\n  (or\n    (or\n      (send\n        (const nil :ENV) :[]\n        (str \"MAKE\"))\n      (ivar :@make_command))\n    (send\n      (const nil :ENV) :[]\n      (str \"make\")))\n  (str \"make\")) dup "]}," MiniPortile gcc_cmd":{"type":"method","name":"gcc_cmd","children":[],"call":["cc dup ","RbConfig CONFIG  [] ","ENV  [] ","(or\n  (or\n    (or\n      (send\n        (const nil :ENV) :[]\n        (str \"CC\"))\n      (ivar :@gcc_command))\n    (send\n      (const\n        (const nil :RbConfig) :CONFIG) :[]\n      (str \"CC\")))\n  (str \"gcc\")) dup "]}," MiniPortile with_tempfile":{"type":"method","name":"with_tempfile","children":[],"call":["FileUtils  mv ","temp_file path ","FileUtils  mkdir_p ","File  dirname ","File  unlink ","File  exist? ","temp_file close ","temp_file binmode ","Tempfile  new ","Tempfile  new  path ","Tempfile  new  close ","Tempfile  new  binmode "]}," MiniPortile download_file_ftp":{"type":"method","name":"download_file_ftp","children":[],"call":[" output ","temp_file << ","io read ","OpenURI  open_uri ","params []= ","ENV  [] ","CGI  unescape ","userinfo split map ","userinfo split ","URI  split "," message ","\rDownloading %s (%3d%%)  % ","(send\n  (lvar :bytes) :*\n  (int 100)) / ","bytes * "," lambda "," with_tempfile ","File  basename ","uri path "," raise "," require "]}," MiniPortile download_file_http":{"type":"method","name":"download_file_http","children":[],"call":[" output ","e message "," download_file ","count - ","redirect url "," raise ","count <= ","temp_file << ","io read ","OpenURI  open_uri ","params []= ","CGI  unescape ","userinfo split map ","userinfo split ","URI  split ","ENV  [] ","URI  parse scheme downcase == ","URI  parse scheme downcase ","URI  parse scheme ","URI  parse "," message ","\rDownloading %s (%3d%%)  % ","(send\n  (lvar :bytes) :*\n  (int 100)) / ","bytes * "," lambda "," with_tempfile ","File  basename "," download_file_http "," sleep ","count > "," puts ","\rDownloading %s  % ","count -  - ","count -  <= ","count -  > "]}," MiniPortile download_file":{"type":"method","name":"download_file","children":[],"call":[" raise "," output ","e message ","File  unlink ","File  exist? "," download_file_http "," download_file_ftp ","uri scheme downcase ","uri scheme ","URI  parse ","ArgumentError  new "," download_file_file ","URI  parse  scheme downcase ","URI  parse  scheme "]}," MiniPortile output":{"type":"method","name":"output","children":[],"call":["@logger flush ","@logger puts "]}," MiniPortile message":{"type":"method","name":"message","children":[],"call":["@logger flush ","@logger print "]}," MiniPortile newer?":{"type":"method","name":"newer?","children":[],"call":["File  mtime > ","File  mtime ","File  exist? "]}," MiniPortile execute":{"type":"method","name":"execute","children":[],"call":[" raise "," output ","= * ","log_lines [] ","(send\n  (lvar :log_lines) :length) min -@ ","(send\n  (lvar :log_lines) :length) min ","log_lines length ","File  readlines ","File  exist? ","$? success? "," system ","log_out shellescape ","command map join ","command map ","command kind_of? ","Process  wait "," spawn ","(lvar :command) flatten + ","(lvar :command) flatten ","RbConfig  respond_to? ! ","RbConfig  respond_to? ","Process  respond_to? "," message ","options fetch ","Dir  chdir "," work_path "," log_file ","redirected inspect ","(send\n  (lvar :opt_env) :map) join ","(begin\n  (lvar :k)) shellescape ","opt_env map ","(lvar :opt_env) flatten ","options inspect ","command inspect ","opt_env inspect ","Hash  new ","command_opts fetch ","File  read ","(lvar :log_out) compact each ","(lvar :log_out) compact ","File  readlines  [] ","(send\n  (lvar :File  readlines ) :length) min -@ ","(send\n  (lvar :File  readlines ) :length) min ","File  readlines  length ","$? sucommand map join command map join ess? "," log_file  shellescape ","log_out shellescommand map join ape ","command map join ommand map join ","command map join ommand map ","command map join ommand kind_of? ","Procommand map join ess  wait ","(lvar :command map join ommand) flatten + ","(lvar :command map join ommand) flatten ","Procommand map join ess  respond_to? ","options fetcommand map join h ","Dir  command map join hdir ","redirecommand map join ted inspecommand map join t ","(begin\n  (lvar :k)) shellescommand map join ape ","options inspecommand map join t ","command map join ommand inspecommand map join t ","opt_env inspecommand map join t ","command map join ommand_opts fetcommand map join h ","(lvar : log_file ) compact each ","(lvar :log_out) command map join ompacommand map join t eacommand map join h ","(lvar : log_file ) compact ","(lvar :log_out) command map join ompacommand map join t "]}," MiniPortile extract_file":{"type":"method","name":"extract_file","children":[],"call":[" execute ","Dir  pwd "," tar_compression_switch "," tar_exe "," message ","FileUtils  mkdir_p ","File  basename "]}," MiniPortile detect_host":{"type":"method","name":"detect_host","children":[],"call":["ENV  []= ","m [] ","output match "," gcc_cmd ","ENV  [] ","output match  [] ","output output match atch "," gcc_coutput match d "]}," MiniPortile which":{"type":"method","name":"which","children":[],"call":["File  executable? ","File  join ","exts each ","ENV  [] split each ","ENV  [] split ","ENV  [] ","File  File  join cutable? ","ENV  [] split  each "]}," MiniPortile tar_compression_switch":{"type":"method","name":"tar_compression_switch","children":[],"call":["File  extname "]}," MiniPortile tar_exe":{"type":"method","name":"tar_exe","children":[],"call":[" which ","(str \"gtar\") find "," raise ","TAR_EXECUTABLES  join ","TAR_EXECUTABLES  find "]}," MiniPortile log_file":{"type":"method","name":"log_file","children":[],"call":["File  unlink ","File  exist? ","File  expand_path tap ","File  expand_path "," tmp_path ","@log_files [] "]}," MiniPortile verify_file":{"type":"method","name":"verify_file","children":[],"call":[" raise ","file [] ","is == ","exp downcase ","digest file hexdigest ","digest file ","gpg_status match ","$? exitstatus == ","$? exitstatus ","IO  popen ","io read ","io close_write ","io write ","gpg [] "," which "," download_file ","file [] + ","file has_key? ","key_ids each ","key_ids empty? ","gpg_status scan map ","gpg_status scan "," radigest file hexdigest e ","digest file hexdigest  == ","file []  downcase ","IO  popen  match ","file [] _status match ","file []  [] ","gpg_status scan map  each ","gpg_status scan map  empty? ","IO  popen  scan map ","file [] _status scan map ","IO  popen  scan ","file [] _status scan "]}," MiniPortile files_hashs":{"type":"method","name":"files_hashs","children":[],"call":["hash []= ","File  join "," archives_path ","File  basename "," raise ","hash fetch ","file dup ","@files map "]}," MiniPortile computed_options":{"type":"method","name":"computed_options","children":[],"call":["(send nil :configure_options) flatten "," configure_prefix "," configure_options "]}," MiniPortile configure_prefix":{"type":"method","name":"configure_prefix","children":[],"call":["File  expand_path "," port_path "]}," MiniPortile configure_defaults":{"type":"method","name":"configure_defaults","children":[],"call":[]}," MiniPortile work_path":{"type":"method","name":"work_path","children":[],"call":["File  directory? ","Dir  glob find ","Dir  glob "," tmp_path "]}," MiniPortile archives_path":{"type":"method","name":"archives_path","children":[],"call":[]}," MiniPortile port_path":{"type":"method","name":"port_path","children":[],"call":[]}," MiniPortile tmp_path":{"type":"method","name":"tmp_path","children":[],"call":[]}," MiniPortile path":{"type":"method","name":"path","children":[],"call":["File  expand_path "," port_path "]}," MiniPortile activate":{"type":"method","name":"activate","children":[],"call":["ENV  []= ","(str \"-L\") strip ","old_value include? ","ENV  fetch ","File  expand_path ","@host != ","File  exist? ","ENV  [] ","full_path gsub! ","vars each "," output "," port_path ","File  directory? ! ","File  directory? ","(pair\n  (str \"PATH\")\n  (send\n    (const nil :File) :join\n    (send nil :port_path)\n    (str \"bin\"))) reject ","File  join "," native_path ","ENV  fetch  include? ","File  expand_path  gsub! "," native_path  gsub! "]}," MiniPortile cook":{"type":"method","name":"cook","children":[],"call":[" install "," installed? "," compile "," configure "," configured? "," patch "," extract "," download "," downloaded? "," prepare_build_directory "," source_directory "]}," MiniPortile installed?":{"type":"method","name":"installed?","children":[],"call":[" newer? ","File  directory? ","Dir  glob find ","Dir  glob "," port_path ","File  join "," work_path "]}," MiniPortile configured?":{"type":"method","name":"configured?","children":[],"call":[" newer? ","current_md5 == ","Digest MD5  hexdigest "," computed_options to_s "," computed_options ","File  read ","File  exist? ","File  join "," tmp_path "," work_path ","current_options == "," source_directory ","Digest MD5  hexdigest  == "," computed_options to_s  == "]}," MiniPortile downloaded?":{"type":"method","name":"downloaded?","children":[],"call":["File  exist? ! ","File  exist? ","file [] "," files_hashs detect "," files_hashs "]}," MiniPortile install":{"type":"method","name":"install","children":[],"call":[" execute "," make_cmd "," installed? "]}," MiniPortile compile":{"type":"method","name":"compile","children":[],"call":[" execute "," make_cmd "]}," MiniPortile configure":{"type":"method","name":"configure","children":[],"call":[" execute ","(str \"./configure\") + "," computed_options ","(str \"sh\") + ","RUBY_PLATFORM  =~ ","f write ","File  open ","Digest MD5  hexdigest "," computed_options to_s ","File  join "," tmp_path "," configured? ","command + ","command unshift "," Array "," source_directory ","FileUtils  mkdir_p ","Digest MD5  hexDigest MD5  hexdigest  "," Array  + "," Array  unshift "]}," MiniPortile configure_options":{"type":"method","name":"configure_options","children":[],"call":[" configure_defaults "]}," MiniPortile patch":{"type":"method","name":"patch","children":[],"call":[" apply_patch ","File  exist? ","@patch_files each "]}," MiniPortile apply_patch":{"type":"method","name":"apply_patch","children":[],"call":["(or-asgn\n  (ivasgn :@apply_patch)\n  (case nil\n    (when\n      (send nil :which\n        (str \"git\"))\n      (block\n        (send nil :lambda)\n        (args\n          (arg :file))\n        (begin\n          (send nil :message\n            (dstr\n              (str \"Running git apply with \")\n              (begin\n                (lvar :file))\n              (str \"... \")))\n          (send nil :execute\n            (str \"patch\")\n            (array\n              (str \"git\")\n              (str \"--work-tree=.\")\n              (str \"apply\")\n              (lvar :file))\n            (hash\n              (pair\n                (sym :initial_message)\n                (false)))))))\n    (when\n      (send nil :which\n        (str \"patch\"))\n      (block\n        (send nil :lambda)\n        (args\n          (arg :file))\n        (begin\n          (send nil :message\n            (dstr\n              (str \"Running patch with \")\n              (begin\n                (lvar :file))\n              (str \"... \")))\n          (send nil :execute\n            (str \"patch\")\n            (array\n              (str \"patch\")\n              (str \"-p1\")\n              (str \"-i\")\n              (lvar :file))\n            (hash\n              (pair\n                (sym :initial_message)\n                (false)))))))\n    (send nil :raise\n      (str \"Failed to complete patch task; patch(1) or git(1) is required.\")))) call "," raise "," execute "," message "," lambda "," which ","(or-asgn\n  (ivasgn :@apply_patch)\n  (case nil\n    (when\n      (send nil :which\n        (str \"git\"))\n      (block\n        (send nil :lambda)\n        (args\n          (arg :file))\n        (begin\n          (send nil :message\n            (dstr\n              (str \"Running git apply with \")\n              (begin\n                (lvar :file))\n              (str \"... \")))\n          (send nil :execute\n            (str \"patch\")\n            (array\n              (str \"git\")\n              (str \"--work-tree=.\")\n              (str \"apply\")\n              (str \"--whitespace=warn\")\n              (lvar :file))\n            (hash\n              (pair\n                (sym :initial_message)\n                (false)))))))\n    (when\n      (send nil :which\n        (str \"patch\"))\n      (block\n        (send nil :lambda)\n        (args\n          (arg :file))\n        (begin\n          (send nil :message\n            (dstr\n              (str \"Running patch with \")\n              (begin\n                (lvar :file))\n              (str \"... \")))\n          (send nil :execute\n            (str \"patch\")\n            (array\n              (str \"patch\")\n              (str \"-p1\")\n              (str \"-i\")\n              (lvar :file))\n            (hash\n              (pair\n                (sym :initial_message)\n                (false)))))))\n    (send nil :raise\n      (str \"Failed to complete patch task; patch(1) or git(1) is required.\")))) call ","(or-asgn\n  (ivasgn :@apply_patch)\n  (case nil\n    (when\n      (send nil :which\n        (str \"git\"))\n      (block\n        (send nil :lambda)\n        (args\n          (arg :file))\n        (begin\n          (send nil :message\n            (dstr\n              (str \"Running git apply with \")\n              (begin\n                (lvar :file))\n              (str \"... \")))\n          (send nil :execute\n            (str \"patch\")\n            (array\n              (str \"git\")\n              (str \"--git-dir=.\")\n              (str \"--work-tree=.\")\n              (str \"apply\")\n              (str \"--whitespace=warn\")\n              (lvar :file))\n            (hash\n              (pair\n                (sym :initial_message)\n                (false)))))))\n    (when\n      (send nil :which\n        (str \"patch\"))\n      (block\n        (send nil :lambda)\n        (args\n          (arg :file))\n        (begin\n          (send nil :message\n            (dstr\n              (str \"Running patch with \")\n              (begin\n                (lvar :file))\n              (str \"... \")))\n          (send nil :execute\n            (str \"patch\")\n            (array\n              (str \"patch\")\n              (str \"-p1\")\n              (str \"-i\")\n              (lvar :file))\n            (hash\n              (pair\n                (sym :initial_message)\n                (false)))))))\n    (send nil :raise\n      (str \"Failed to complete patch task; patch(1) or git(1) is required.\")))) call ","(or-asgn\n  (ivasgn :@apply_patch)\n  (case nil\n    (when\n      (send nil :which\n        (str \"git\"))\n      (block\n        (send nil :lambda)\n        (args\n          (arg :file))\n        (begin\n          (send nil :message\n            (dstr\n              (str \"Running git apply with \")\n              (begin\n                (lvar :file))\n              (str \"... \")))\n          (block\n            (send\n              (const nil :Dir) :mktmpdir)\n            (args\n              (arg :tmp_git_dir))\n            (send nil :execute\n              (str \"patch\")\n              (array\n                (str \"git\")\n                (dstr\n                  (str \"--git-dir=\")\n                  (begin\n                    (lvar :tmp_git_dir)))\n                (str \"--work-tree=.\")\n                (str \"apply\")\n                (str \"--whitespace=warn\")\n                (lvar :file))\n              (hash\n                (pair\n                  (sym :initial_message)\n                  (false))))))))\n    (when\n      (send nil :which\n        (str \"patch\"))\n      (block\n        (send nil :lambda)\n        (args\n          (arg :file))\n        (begin\n          (send nil :message\n            (dstr\n              (str \"Running patch with \")\n              (begin\n                (lvar :file))\n              (str \"... \")))\n          (send nil :execute\n            (str \"patch\")\n            (array\n              (str \"patch\")\n              (str \"-p1\")\n              (str \"-i\")\n              (lvar :file))\n            (hash\n              (pair\n                (sym :initial_message)\n                (false)))))))\n    (send nil :raise\n      (str \"Failed to complete patch task; patch(1) or git(1) is required.\")))) call ","Dir  mktmpdir "]}," MiniPortile extract":{"type":"method","name":"extract","children":[],"call":[" extract_file "," tmp_path ","file [] "," files_hashs each "," files_hashs "," verify_file "]}," MiniPortile download":{"type":"method","name":"download","children":[],"call":[" verify_file "," download_file ","file [] "," files_hashs each "," files_hashs "]}," MiniPortile initialize":{"type":"method","name":"initialize","children":[],"call":[" detect_host ","kwargs [] "]}," HTTP edit_path":{"type":"method","name":"edit_path","children":[],"call":[" addr_port "," use_ssl? ","path start_with? "," proxy? "]}," MiniPortile download_file_file":{"type":"method","name":"download_file_file","children":[],"call":["FileUtils  cp ","uri path ","FileUtils  mkdir_p ","File  dirname "]}," MiniPortileCMake make_cmd":{"type":"method","name":"make_cmd","children":[],"call":["MiniPortile  windows? ","MiniPortile  mswin? "]}," MiniPortileCMake configured?":{"type":"method","name":"configured?","children":[],"call":[" newer? ","current_options == "," computed_options to_s "," computed_options ","File  read ","File  exist? ","File  join "," tmp_path "," work_path ","current_md5 == ","Digest MD5  hexdigest "," computed_options to_s  == ","Digest MD5  hexdigest  == "]}," MiniPortileCMake configure":{"type":"method","name":"configure","children":[],"call":[" execute ","(str \"cmake\") + + ","(str \"cmake\") + "," computed_options ","f write "," computed_options to_s ","File  open ","File  join "," tmp_path "," configured? ","Digest MD5  hexdigest ","(send nil :cmake_cmd) + + ","(send nil :cmake_cmd) + "," cmake_cmd ","Digest MD5  hexDigest MD5  hexdigest  "]}," MiniPortileCMake configure_defaults":{"type":"method","name":"configure_defaults","children":[],"call":["MiniPortile  windows? ","MiniPortile  mingw? ","MiniPortile  mswin? "," generator_available? ","(send nil :generator_defaults) flatten "," cmake_compile_flags "," generator_defaults "]}," MiniPortileCMake configure_prefix":{"type":"method","name":"configure_prefix","children":[],"call":["File  expand_path "," port_path "]}," MiniPortile windows?":{"type":"method","name":"windows?","children":[],"call":[]}," MiniPortile mswin?":{"type":"method","name":"mswin?","children":[],"call":[]}," MiniPortile mingw?":{"type":"method","name":"mingw?","children":[],"call":[]}," MiniPortile prepare_build_directory":{"type":"method","name":"prepare_build_directory","children":[],"call":["FileUtils  rm_rf "," port_path ","FileUtils  mkdir_p ","File  join ","(send nil :name) join "," version "," name "," tmp_path "," output "," source_directory "," raise "," source_directory nil? "]}," MiniPortile source_directory=":{"type":"method","name":"source_directory=","children":[],"call":["File  expand_path "," posix_path "]}," MiniPortileCMake cmake_cmd":{"type":"method","name":"cmake_cmd","children":[],"call":["(or\n  (or\n    (send\n      (const nil :ENV) :[]\n      (str \"CMAKE\"))\n    (ivar :@cmake_command))\n  (str \"cmake\")) dup ","ENV  [] "]}," MiniPortileCMake initialize":{"type":"method","name":"initialize","children":[],"call":["kwargs [] "]}," MiniPortile posix_path":{"type":"method","name":"posix_path","children":[],"call":["/ + ","path tr tr ","path tr ","File  expand_path ","MiniPortile  posix_path ","File  expand_path  tr tr ","File  expand_path  tr ","File  expand_File  expand_path  ","MiniPortile  posix_File  expand_path  "]}," MiniPortile native_path":{"type":"method","name":"native_path","children":[],"call":["path tr ","File  expand_path ","MiniPortile  native_path ","File  expand_path  tr ","File  expand_File  expand_path  ","MiniPortile  native_File  expand_path  "]}," MiniPortileCMake generator_available?":{"type":"method","name":"generator_available?","children":[],"call":["stdout_str include? "," raise ","status success? ","Open3  capture2 "," cmake_cmd "]}," MiniPortileCMake cpu_type":{"type":"method","name":"cpu_type","children":[],"call":["MiniPortile  target_cpu ","MiniPortile  target_cpu == "]}," MiniPortileCMake cmake_system_name":{"type":"method","name":"cmake_system_name","children":[],"call":[" raise ","MiniPortile  target_os ","MiniPortile  solaris? ","MiniPortile  openbsd? ","MiniPortile  freebsd? ","MiniPortile  windows? ","MiniPortile  darwin? ","MiniPortile  linux? "," system_name "]}," MiniPortileCMake find_c_and_cxx_compilers":{"type":"method","name":"find_c_and_cxx_compilers","children":[],"call":[" find_compiler ","MiniPortile  darwin? ","ENV  [] "]}," MiniPortileCMake find_compiler":{"type":"method","name":"find_compiler","children":[],"call":[" which ","compilers find "]}," MiniPortileCMake cmake_compile_flags":{"type":"method","name":"cmake_compile_flags","children":[],"call":[" cpu_type "," cmake_system_name "," find_c_and_cxx_compilers "," host "]}," MiniPortileCMake generator_defaults":{"type":"method","name":"generator_defaults","children":[],"call":[" generator_available? ","MiniPortile  mingw? ","MiniPortile  mswin? "]}," MiniPortile target_cpu":{"type":"method","name":"target_cpu","children":[],"call":[]}," MiniPortile target_os":{"type":"method","name":"target_os","children":[],"call":[]}," MiniPortile solaris?":{"type":"method","name":"solaris?","children":[],"call":[]}," MiniPortile linux?":{"type":"method","name":"linux?","children":[],"call":[]}," MiniPortile openbsd?":{"type":"method","name":"openbsd?","children":[],"call":[]}," MiniPortile freebsd?":{"type":"method","name":"freebsd?","children":[],"call":[]}," MiniPortile darwin?":{"type":"method","name":"darwin?","children":[],"call":[]}," MiniPortile minimal_pkg_config":{"type":"method","name":"minimal_pkg_config","children":[],"call":["response strip "," raise ","$? success? ","IO  popen "," Array map "," Array ","MakeMakefile  find_executable0 ","MakeMakefile  config_string ","MakeMakefile  with_config ","pcoptions empty? ","IO  popen  strip "]}," MiniPortile mkmf_config":{"type":"method","name":"mkmf_config","children":[],"call":["(gvar :$libs) join strip ","(gvar :$libs) join ","(gvar :$CXXFLAGS) join strip ","(gvar :$CXXFLAGS) join ","(gvar :$CFLAGS) join strip ","(gvar :$CFLAGS) join ","libpaths | ","(lvar :incflags) join strip ","(lvar :incflags) join ","f sub ","ldflags split map ","ldflags split ","Dir  exist? "," name sub "," name ","File  join "," path "," output "," minimal_pkg_config ","ENV  []= ","(send\n  (const nil :ENV) :[]\n  (str \"PKG_CONFIG_PATH\")) compact join ","(send\n  (const nil :ENV) :[]\n  (str \"PKG_CONFIG_PATH\")) compact ","ENV  [] ","File  dirname ","File  basename "," raise ","File  exist? "," require ","(gvar :(gvar :$libs) join strip ) join strip ","(gvar :(gvar :$libs) join strip ) join ","(gvar :(gvar :$CXXFLAGS) join strip ) join strip ","(gvar :(gvar :$CXXFLAGS) join strip ) join ","(gvar :(gvar :$CFLAGS) join strip ) join strip ","(gvar :(gvar :$CFLAGS) join strip ) join ","(lvar :in minimal_pkg_config ) join strip ","(lvar : minimal_pkg_config ) join strip ","(lvar :in minimal_pkg_config ) join ","(lvar : minimal_pkg_config ) join "," minimal_pkg_config  split map "," minimal_pkg_config  split "]}}