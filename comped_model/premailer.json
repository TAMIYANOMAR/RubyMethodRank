{" Premailer check_client_support":{"type":"method","name":"check_client_support","children":[],"call":["warnings push ","data [] join ","data [] ","WARN_LABEL  [] ","@doc search length > ","@doc search length ","@doc search ","data [] >= ","@options [] ","@client_support [] each ","@client_support [] ","property_support [] [] join ","property_support [] [] ","property_support [] ","property_support [] [] >= ","property_support [] include? ","property_support include? ","properties each ","properties uniq! ","properties push ","el attributes [] to_s gsub ","el attributes [] to_s ","el attributes [] ","el attributes ","@processed_doc search each ","@processed_doc search ","YAML  load ","File  open ","RUBY_VERSION  >= ","Psych  load ","Psych VERSION  >= "," prop ","el attributes [] gsub ","@doc search each ","@client_support []  [] [] join ","@client_support []  [] [] ","@client_support []  [] ","@client_support []  [] [] >= ","@client_support []  [] include? ","@client_support []  include? "]}," Premailer canonicalize":{"type":"method","name":"canonicalize","children":[],"call":[]}," Premailer local_data?":{"type":"method","name":"local_data?","children":[],"call":[]}," Premailer resolve_link":{"type":"method","name":"resolve_link","children":[],"call":[]}," Premailer escape_string":{"type":"method","name":"escape_string","children":[],"call":[]}," Premailer is_media_query?":{"type":"method","name":"is_media_query?","children":[],"call":[]}," Premailer convert_inline_links":{"type":"method","name":"convert_inline_links","children":[],"call":["el []= ","CssParser  convert_uris ","el attributes [] to_s ","el attributes [] ","el attributes ","doc search each ","doc search ","tag []= ","merged to_s ","URI  parse ","merged kind_of? ","Premailer  resolve_link ","URI  escape ","tag attributes [] to_s ","tag attributes [] ","tag attributes ","tag attributes [] to_s =~ ","tags each ","tags empty? ","(str \"href\") each ","@options [] ","base_uri kind_of? ","Addressable URI  parse ","Addressable URI  escape ","merged query= ","merged query + + ","merged query + ","merged query ","append_qs empty? ! ","append_qs empty? ","tag name =~ ","tag name ","tag attributes [] =~ ","URI  parse  to_s ","Premailer  resolve_link  to_s ","Addressable URI  parse  to_s ","URI  parse  kind_of? ","Premailer  resolve_link  kind_of? ","Addressable URI  parse  kind_of? ","doc search  each ","doc search  empty? ","URI  parse  query= ","Premailer  resolve_link  query= ","Addressable URI  parse  query= ","URI  parse  query + + ","Premailer  resolve_link  query + + ","Addressable URI  parse  query + + ","URI  parse  query + ","Premailer  resolve_link  query + ","Addressable URI  parse  query + ","URI  parse  query ","Premailer  resolve_link  query ","Addressable URI  parse  query "]}," Premailer is_xhtml?":{"type":"method","name":"is_xhtml?","children":[],"call":["$stderr puts ","is_xhtml inspect ","@options [] ","(send\n  (lvar :intro) :=~\n  (regexp\n    (str \"w3c//[\\\\s]*dtd[\\\\s]+xhtml\")\n    (regopt :i))) ! ! ","(send\n  (lvar :intro) :=~\n  (regexp\n    (str \"w3c//[\\\\s]*dtd[\\\\s]+xhtml\")\n    (regopt :i))) ! ","intro =~ ","@doc to_html strip split [] join ","@doc to_html strip split [] ","@doc to_html strip split ","@doc to_html strip ","@doc to_html ","@doc to_xhtml strip split [] join ","@doc to_xhtml strip split [] ","@doc to_xhtml strip split ","@doc to_xhtml strip ","@doc to_xhtml ","@doc to_s strip split [] join ","@doc to_s strip split [] ","@doc to_s strip split ","@doc to_s strip ","@doc to_s ","(send\n  (lvar :intro) :=~\n  (regexp\n    (str \"w3c//[\\s]*dtd[\\s]+xhtml\")\n    (regopt :i))) ! !  inspect ","(send\n  (lvar :@doc to_html strip split [] join ) :=~\n  (regexp\n    (str \"w3c//[\\\\s]*dtd[\\\\s]+xhtml\")\n    (regopt :i))) ! ! ","(send\n  (lvar :@doc to_xhtml strip split [] join ) :=~\n  (regexp\n    (str \"w3c//[\\\\s]*dtd[\\\\s]+xhtml\")\n    (regopt :i))) ! ! ","(send\n  (lvar :@doc to_s strip split [] join ) :=~\n  (regexp\n    (str \"w3c//[\\\\s]*dtd[\\\\s]+xhtml\")\n    (regopt :i))) ! ! ","(send\n  (lvar :@doc to_html strip split [] join ) :=~\n  (regexp\n    (str \"w3c//[\\\\s]*dtd[\\\\s]+xhtml\")\n    (regopt :i))) ! ","(send\n  (lvar :@doc to_xhtml strip split [] join ) :=~\n  (regexp\n    (str \"w3c//[\\\\s]*dtd[\\\\s]+xhtml\")\n    (regopt :i))) ! ","(send\n  (lvar :@doc to_s strip split [] join ) :=~\n  (regexp\n    (str \"w3c//[\\\\s]*dtd[\\\\s]+xhtml\")\n    (regopt :i))) ! ","@doc to_html strip split [] join  =~ ","@doc to_xhtml strip split [] join  =~ ","@doc to_s strip split [] join  =~ "]}," Premailer append_query_string":{"type":"method","name":"append_query_string","children":[],"call":["$stderr puts ","e message ","href to_s ","@options [] ","el []= ","href query= ","href query + + ","href query + ","href query ","href query empty? ! ","href query empty? "," puts ","href scheme != ","href scheme ","href host != ","href host ","URI  parse ","href [] =~ ","href [] ","href empty? ","href nil? ","el attributes [] to_s strip ","el attributes [] to_s ","el attributes [] ","el attributes ","doc search each ","doc search ","@base_url host ","qs empty? ","qs to_s gsub! strip! ","qs to_s gsub! ","qs to_s ","qs nil? ","Addressable URI  parse ","qs to_s strip! ","? + ","href [] == ","URI  parse  to_s ","el attributes [] to_s strip  to_s ","Addressable URI  parse  to_s ","el attributes [] to_s  to_s ","URI  parse  query= ","el attributes [] to_s strip  query= ","Addressable URI  parse  query= ","el attributes [] to_s  query= ","URI  parse  query + + ","el attributes [] to_s strip  query + + ","Addressable URI  parse  query + + ","el attributes [] to_s  query + + ","URI  parse  query + ","el attributes [] to_s strip  query + ","Addressable URI  parse  query + ","el attributes [] to_s  query + ","URI  parse  query ","el attributes [] to_s strip  query ","Addressable URI  parse  query ","el attributes [] to_s  query ","URI  parse  query empty? ! ","el attributes [] to_s strip  query empty? ! ","Addressable URI  parse  query empty? ! ","el attributes [] to_s  query empty? ! ","URI  parse  query empty? ","el attributes [] to_s strip  query empty? ","Addressable URI  parse  query empty? ","el attributes [] to_s  query empty? ","URI  parse  scheme != ","el attributes [] to_s strip  scheme != ","Addressable URI  parse  scheme != ","el attributes [] to_s  scheme != ","URI  parse  scheme ","el attributes [] to_s strip  scheme ","Addressable URI  parse  scheme ","el attributes [] to_s  scheme ","URI  parse  host != ","el attributes [] to_s strip  host != ","Addressable URI  parse  host != ","el attributes [] to_s  host != ","URI  parse  host ","el attributes [] to_s strip  host ","Addressable URI  parse  host ","el attributes [] to_s  host ","URI  parse  [] =~ ","el attributes [] to_s strip  [] =~ ","Addressable URI  parse  [] =~ ","el attributes [] to_s  [] =~ ","URI  parse  [] ","el attributes [] to_s strip  [] ","Addressable URI  parse  [] ","el attributes [] to_s  [] ","URI  parse  empty? ","el attributes [] to_s strip  empty? ","Addressable URI  parse  empty? ","el attributes [] to_s  empty? ","URI  parse  nil? ","el attributes [] to_s strip  nil? ","Addressable URI  parse  nil? ","el attributes [] to_s  nil? ","URI  parse  [] == ","el attributes [] to_s strip  [] == ","Addressable URI  parse  [] == ","el attributes [] to_s  [] == "]}," Premailer media_type_ok?":{"type":"method","name":"media_type_ok?","children":[],"call":["media_type strip =~ ","media_type strip ","media_types split any? ","media_types split ","media_types empty? ","media_types nil? ","media_types to_s ","media_types to_s  split any? ","media_types to_s  split ","media_types to_s  empty? ","media_types to_s  nil? ","media_types to_s  to_s "]}," Premailer local_uri?":{"type":"method","name":"local_uri?","children":[],"call":["Premailer  local_data? "," warn "]}," Premailer load_css_from_html!":{"type":"method","name":"load_css_from_html!","children":[],"call":["tags remove ","@options [] ","@css_parser add_block! ","tag inner_html ","tag to_s strip =~ ","tag to_s strip ","tag to_s ","@css_parser load_uri! ","$stderr puts ","Loading css from uri:  + "," load_css_from_local_file! ","Loading css from local file:  + ","Premailer  local_data? ","tag attributes [] to_s ","tag attributes [] ","tag attributes ","Premailer  resolve_link ","File  exists? ","File  join ","tag attributes [] to_s sub! ","@base_url to_s ","File  dirname ","tag attributes [] to_s sub ","@html_file kind_of? ","tag attributes [] to_s include? "," media_type_ok? ","tags each ","@doc search ","File  exist? ","URI  parse ","tag innerHTML ","css_block << ","file gets ","File  open "," puts ","File  exists? ! ","link_uri nil? ","@options [] == ","tag attributes [] to_s sub sub ","@doc search  remove ","@doc search  each ","tag attributes [] to_s  nil? ","Premailer  resolve_link  nil? ","File  join  nil? ","tag attributes [] to_s sub  nil? ","tag attributes [] to_s sub sub  nil? "]}," Premailer load_css_from_options!":{"type":"method","name":"load_css_from_options!","children":[],"call":["@css_parser load_uri! "," load_css_from_local_file! ","Premailer  local_data? ","@css_files each "," load_css_from_string ","@options [] "]}," Premailer load_css_from_string":{"type":"method","name":"load_css_from_string","children":[],"call":["@css_parser add_block! "]}," Premailer load_css_from_local_file!":{"type":"method","name":"load_css_from_local_file!","children":[],"call":[" raise ","@options [] "," load_css_from_string ","css_block << ","file gets ","File  open ","path gsub! ","@css_parser add_block! "]}," Premailer warnings":{"type":"method","name":"warnings","children":[],"call":[" check_client_support ","@css_warnings empty? ","@options [] == ","@options [] "," check_client_support  empty? "]}," Premailer initialize":{"type":"method","name":"initialize","children":[],"call":[" load_css_from_html! "," load_css_from_options! "," append_query_string ","options [] "," convert_inline_links "," load_html "," class send "," class ","Adapter  find ","@options [] ","CssParser Parser  new ","URI  parse ","@is_local_file ! ","@options delete ","(send\n  (ivar :@options) :[]\n  (sym :css)) flatten ","Premailer  local_data? ","(pair\n  (sym :warn_level)\n  (const\n    (const nil :Warnings) :SAFE)) merge ","Adapter  use ","Addressable URI  parse "," extend ","path =~ ","@doc encoding ","@options delete [] ","(pair\n  (sym :warn_level)\n  (const\n    (const nil :Warnings) :SAFE)) merge  [] ","(pair\n  (sym :warn_level)\n  (const\n    (const nil :Warnings) :SAFE)) merge  delete ","(send\n  (ivar :(pair\n  (sym :warn_level)\n  (const\n    (const nil :Warnings) :SAFE)) merge ) :[]\n  (sym :css)) flatten "," load_html  encoding "," convert_inline_links  encoding ","(pair\n  (sym :warn_level)\n  (const\n    (const nil :Warnings) :SAFE)) merge  delete [] "]}," HtmlToPlainText word_wrap":{"type":"method","name":"word_wrap","children":[],"call":["(send\n  (send\n    (lvar :txt) :split\n    (str \"\\n\")) :collect) * ","line gsub strip ","line gsub ","line length > ","line length ","txt split collect ","txt split "]}," HtmlToPlainText convert_to_text":{"type":"method","name":"convert_to_text","children":[],"call":["txt strip ","(if\n  (send\n    (nth-ref 1) :==\n    (str \"\\n\"))\n  (nth-ref 1)\n  (str \"\")) + + + + ","3 == ","(if\n  (send\n    (nth-ref 1) :==\n    (str \"\\n\"))\n  (nth-ref 1)\n  (str \"\")) + + + ","(if\n  (send\n    (nth-ref 1) :==\n    (str \"\\n\"))\n  (nth-ref 1)\n  (str \"\")) + + ","(if\n  (send\n    (nth-ref 1) :==\n    (str \"\\n\"))\n  (nth-ref 1)\n  (str \"\")) + ","1 == ","txt gsub! "," word_wrap ","he decode ","HTMLEntities  new ","\n\n + + ","\n\n + ","htext + + ","- * ","htext + ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + + + + ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + + + ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + + ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + + + + ","* * ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + + + ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + + ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + ","hlength > ","llength > ","l strip length ","l strip ","htext each_line ","htext gsub! ","1 to_i ","3 strip + + + ","3 strip + + ","2 strip ","3 strip + ","3 strip ","3 strip downcase == ","2 strip downcase ","3 strip downcase ","3 empty? ","text strip + + + ","text strip + + ","href strip ","text strip + ","text strip ","text strip downcase == ","href strip downcase ","text strip downcase ","href nil? ","text empty? ","match [] ","(str \"href=(['\\\"])(?:mailto:)?(.+?)\\\\1\") match ","r format ","[ * ","2 + + + ","2 + + ","2 + ","htext + + + ","htext length ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + + + + + ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + + + + + ","htext length > ","2 gsub ","Text Reform  new ","Text Reform  break_wrap ","2 strip + + + ","2 strip + + ","1 strip ","2 strip + ","2 gsub strip ","(  + + ","(  + "," word_wrap  strip ","he decode  strip ","r format  strip ","txt stText Reform  new ip ","(if\n  (send\n    (nth-Text Reform  new ef 1) :==\n    (stText Reform  new  \"\\n\"))\n  (nth-Text Reform  new ef 1)\n  (stText Reform  new  \"\")) + + + + ","(if\n  (send\n    (nth-Text Reform  new ef 1) :==\n    (stText Reform  new  \"\\n\"))\n  (nth-Text Reform  new ef 1)\n  (stText Reform  new  \"\")) + + + ","(if\n  (send\n    (nth-Text Reform  new ef 1) :==\n    (stText Reform  new  \"\\n\"))\n  (nth-Text Reform  new ef 1)\n  (stText Reform  new  \"\")) + + ","(if\n  (send\n    (nth-Text Reform  new ef 1) :==\n    (stText Reform  new  \"\\n\"))\n  (nth-Text Reform  new ef 1)\n  (stText Reform  new  \"\")) + "," word_wrap  gsub! ","he decode  gsub! ","r format  gsub! "," woText Reform  new d_wText Reform  new ap ","HTMLEntities  new  decode ","htext + +  + + ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + + + +  + + ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + + + +  + + ","2 gsub  + + ","2 gsub strip  + + ","h2 strip  + + ","htext + +  + ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + + + +  + ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + + + +  + ","2 gsub  + ","2 gsub strip  + ","h2 strip  + ","(send\n  (stText Reform  new  \"-\") :*\n  (lvaText Reform  new  :hlength)) + + + + ","(send\n  (stText Reform  new  \"-\") :*\n  (lvaText Reform  new  :hlength)) + + + ","(send\n  (stText Reform  new  \"-\") :*\n  (lvaText Reform  new  :hlength)) + + ","(send\n  (stText Reform  new  \"-\") :*\n  (lvaText Reform  new  :hlength)) + ","(send\n  (stText Reform  new  \"*\") :*\n  (lvaText Reform  new  :hlength)) + + + + ","(send\n  (stText Reform  new  \"*\") :*\n  (lvaText Reform  new  :hlength)) + + + ","(send\n  (stText Reform  new  \"*\") :*\n  (lvaText Reform  new  :hlength)) + + ","(send\n  (stText Reform  new  \"*\") :*\n  (lvaText Reform  new  :hlength)) + ","l strip length  > ","l stText Reform  new ip length ","l stText Reform  new ip ","htext + +  each_line ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + + + +  each_line ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + + + +  each_line ","2 gsub  each_line ","2 gsub strip  each_line ","h2 strip  each_line ","htext + +  gsub! ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + + + +  gsub! ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + + + +  gsub! ","2 gsub  gsub! ","2 gsub strip  gsub! ","h2 strip  gsub! ","3 stText Reform  new ip + + + ","3 stText Reform  new ip + + ","2 stText Reform  new ip ","3 stText Reform  new ip + ","3 stText Reform  new ip ","3 stText Reform  new ip downcase == ","2 stText Reform  new ip downcase ","3 stText Reform  new ip downcase ","2 strip  strip + + + ","text stText Reform  new ip + + + ","2 strip  strip + + ","text stText Reform  new ip + + ","match []  strip ","hText Reform  new ef stText Reform  new ip ","2 strip  strip + ","text stText Reform  new ip + ","2 strip  strip ","text stText Reform  new ip ","2 strip  strip downcase == ","text stText Reform  new ip downcase == ","match []  strip downcase ","hText Reform  new ef stText Reform  new ip downcase ","2 strip  strip downcase ","text stText Reform  new ip downcase ","match []  nil? ","hText Reform  new ef nil? ","2 strip  empty? ","(str \"href=(['\\\"])(?:mailto:)?(.+?)\\1\") match  [] ","(str \"match [] =(['\\\"])(?:mailto:)?(.+?)\\\\1\") match ","(str \"href=(['\\\"])(?:mailto:)?(.+?)\\\\1\") (str \"href=(['\\\"])(?:mailto:)?(.+?)\\1\") match  ","(stText Reform  new  \"hText Reform  new ef=(['\\\"])(?:mailto:)?(.+?)\\\\1\") match ","Text Reform  new  foText Reform  new mat ","htext + +  + + + ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + + + +  + + + ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + + + +  + + + ","2 gsub  + + + ","2 gsub strip  + + + ","h2 strip  + + + ","htext + +  length ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + + + +  length ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + + + +  length ","2 gsub  length ","2 gsub strip  length ","h2 strip  length ","(send\n  (stText Reform  new  \"-\") :*\n  (lvaText Reform  new  :hlength)) + + + + + ","(send\n  (stText Reform  new  \"*\") :*\n  (lvaText Reform  new  :hlength)) + + + + + ","htext + +  length > ","(send\n  (str \"-\") :*\n  (lvar :hlength)) + + + +  length > ","(send\n  (str \"*\") :*\n  (lvar :hlength)) + + + +  length > ","2 gsub  length > ","2 gsub strip  length > ","h2 strip  length > ","Text RefoText Reform  new m  new ","Text RefoText Reform  new m  bText Reform  new eak_wText Reform  new ap ","2 stText Reform  new ip + + + ","2 stText Reform  new ip + + ","1 stText Reform  new ip ","2 stText Reform  new ip + ","2 gsub stText Reform  new ip "]}," Premailer Adapter find":{"type":"method","name":"find","children":[],"call":[]}," Premailer Adapter use=":{"type":"method","name":"use=","children":[],"call":[]}," Premailer Adapter default":{"type":"method","name":"default","children":[],"call":[]}," Premailer Adapter use":{"type":"method","name":"use","children":[],"call":[]}," AdapterHelper RgbToHex ensure_hex":{"type":"method","name":"ensure_hex","children":[],"call":[" to_hex ","match_data [] "," is_rgb? "," is_rgb?  [] "]}," AdapterHelper RgbToHex is_rgb?":{"type":"method","name":"is_rgb?","children":[],"call":["pattern match "]}," AdapterHelper RgbToHex to_hex":{"type":"method","name":"to_hex","children":[],"call":["str to_i to_s rjust upcase ","str to_i to_s rjust ","str to_i to_s ","str to_i "]}," Premailer Adapter Nokogumbo load_html":{"type":"method","name":"load_html","children":[],"call":["child swap ","child text ","child cdata? ","doc search children each ","doc search children ","doc search ","(str \"style\") each "," Nokogiri  HTML5 ","RUBY_PLATFORM  == ","thing force_encoding encode! ","thing force_encoding ","@options [] ","RUBY_VERSION  =~ ","thing is_a? ","thing gsub! ","HTML_ENTITIES  map ","@options [] == ","thing read ","thing respond_to? "," open ","File  open ","File  dirname ","input respond_to? "," Nokogiri HTML5  fragment ","URI  open "," Nokogiri  HTML5  search children each "," Nokogiri HTML5  fragment  search children each "," Nokogiri  HTML5  search children "," Nokogiri HTML5  fragment  search children "," Nokogiri  HTML5  search "," Nokogiri HTML5  fragment  search ","thing force_encoding encode!  force_encoding encode! ","thing read  force_encoding encode! "," open  force_encoding encode! ","File  open  force_encoding encode! ","URI  open  force_encoding encode! ","thing force_encoding encode!  force_encoding ","thing read  force_encoding "," open  force_encoding ","File  open  force_encoding ","URI  open  force_encoding ","thing force_encoding encode!  is_a? ","thing read  is_a? "," open  is_a? ","File  open  is_a? ","URI  open  is_a? ","thing force_encoding encode!  gsub! ","thing read  gsub! "," open  gsub! ","File  open  gsub! ","URI  open  gsub! ","thing force_encoding encode!  read ","thing read  read "," open  read ","File  open  read ","URI  open  read ","thing force_encoding encode!  respond_to? ","thing read  respond_to? "," open  respond_to? ","File  open  respond_to? ","URI  open  respond_to? "]}," Premailer Adapter Nokogumbo to_s":{"type":"method","name":"to_s","children":[],"call":["@doc to_html ","@doc to_xhtml "," is_xhtml? "]}," Premailer Adapter Nokogumbo to_plain_text":{"type":"method","name":"to_plain_text","children":[],"call":[" convert_to_text ","@options [] ","@doc to_html ","html_src empty? ! ","html_src empty? ","@doc at inner_html ","@doc at ","@doc to_html  empty? ! ","@doc at inner_html  empty? ! ","@doc to_html  empty? ","@doc at inner_html  empty? "]}," Premailer Adapter Nokogumbo write_unmergable_css_rules":{"type":"method","name":"write_unmergable_css_rules","children":[],"call":["head << ","doc add_child ","doc create_element ","doc root first_element_child add_previous_sibling ","doc root first_element_child ","doc root ","doc at_css ","styles empty? ","unmergable_rules to_s ","style_tag content= "," Nokogiri XML Node  new ","@options [] ","doc at_css add_child "," Nokogiri XML  fragment ","doc at_css children before ","doc at_css children ","doc at_css children empty? ! ","doc at_css children empty? ","doc inner_html= ","doc inner_html ","(lvasgn :body\n  (send\n    (lvar :doc) :search\n    (str \"body\"))) empty? ","doc search ","doc at_css  << ","unmergable_rules to_s  empty? ","doc create_element  content= "," Nokogiri XML Node  new  content= ","(lvasgn :doc search \n  (send\n    (lvar :doc) :search\n    (str \"doc search \"))) empty? "]}," Premailer Adapter Nokogumbo to_inline_css":{"type":"method","name":"to_inline_css","children":[],"call":["@processed_doc to_html ","@options [] ","@processed_doc to_xhtml gsub ","@processed_doc to_xhtml "," is_xhtml? ","el remove_attribute ","doc search each ","doc search ","el set_attribute ","Digest MD5  hexdigest ","targets include? ","el get_attribute ","# + ","targets << ","el get_attribute [] ","el element? ","el remove ","el comment? ","doc traverse "," write_unmergable_css_rules ","el []= ","attributes join + ","attributes join ","pair [] ","(send\n  (block\n    (send\n      (lvar :attributes) :map)\n    (args\n      (arg :attr))\n    (array\n      (send\n        (send\n          (lvar :attr) :split\n          (str \":\")) :first)\n      (lvar :attr))) :sort_by) map ","pair first ","(send\n  (lvar :attributes) :map) sort_by ","attr split first ","attr split ","attributes map ","Premailer  escape_string split map ","Premailer  escape_string split ","Premailer  escape_string ","merged declarations_to_s ","merged create_shorthand! ","declarations delete ","merged instance_variable_get tap ","merged instance_variable_get "," ensure_hex ","css_att end_with? ","merged [] gsub gsub strip ","merged [] gsub gsub ","merged [] gsub ","merged [] ","merged [] empty? ! ","merged [] empty? ","el [] nil? ","el [] ","Premailer RELATED_ATTRIBUTES  [] each ","Premailer RELATED_ATTRIBUTES  [] ","el name ","Premailer RELATED_ATTRIBUTES  has_key? ","merged expand_shorthand! ","CssParser  merge ","declarations << ","CssParser RuleSet  new ","declaration [] to_i ","declaration [] ","declaration [] to_s ","style scan each ","style scan ","el attributes [] to_s ","el attributes [] ","el attributes ","doc search remove ","$stderr puts ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + ","el parent name != ","el parent name ","el parent ","el name != ","el elem? ","selector gsub! ","@unmergable_rules add_rule_set! ","@options [] ! ","selector =~ ","Premailer  is_media_query? ","1 to_s + ","2 to_s downcase ","2 to_s ","1 to_s ","@css_parser each_selector ","[SPEC=1000[ + + ","[SPEC=1000[ + ","CssParser Parser  new ","css_attr end_with? ","new_val gsub! ","(str \"width\") include? ","new_val gsub! strip! ","merged [] dup ","Digest SHA256  hexdigest "," raise ","@processed_ write_unmergable_css_rules  to_html ","@processed_ write_unmergable_css_rules  to_xhtml gsub ","@processed_ write_unmergable_css_rules  to_xhtml "," write_unmergable_css_rules  search each "," write_unmergable_css_rules  search ","el get_attribute [] s include? ","el get_attribute [] s << "," write_unmergable_css_rules  traverse ","doc traveCssParser RuleSet  new e ","Premailer  escape_string split map  join + ","Premailer  escape_string split map  join ","(send\n  (block\n    (send\n      (lvar :Premailer  escape_string split map ) :map)\n    (args\n      (arg :attr))\n    (array\n      (send\n        (send\n          (lvar :attr) :split\n          (str \":\")) :first)\n      (lvar :attr))) :sort_by) map ","(send\n  (block\n    (send\n      (lvar :attributes) :map)\n    (args\n      (arg :attr))\n    (array\n      (send\n        (send\n          (lvar :attr) :split\n          (str \":\")) :fiCssParser RuleSet  new t)\n      (lvar :attr))) :sort_by) map ","pair fiCssParser RuleSet  new t ","(send\n  (lvar :Premailer  escape_string split map ) :map) sort_by ","attr split fiCssParser RuleSet  new t ","Premailer  escape_string split map  map ","CssParser  merge  declarations_to_s ","CssParser  merge  create_shorthand! ","CssParser  merge  instance_variable_get tap ","CssParser  merge  instance_variable_get ","CssParser  merge  [] gsub gsub strip ","CssParser  merge  [] gsub gsub ","CssParser  merge  [] gsub ","CssParser  merge  [] ","CssParser  merge  [] empty? ! ","CssParser  merge  [] empty? ","CssParser  merge  expand_shorthand! ","CssPaCssParser RuleSet  new er  merge ","CssPaCssParser RuleSet  new er RuleSet  new ","el attributes [] to_s  scan each ","el attributes [] to_s  scan ","el Premailer  escape_string split map  [] to_s ","el Premailer  escape_string split map  [] ","el Premailer  escape_string split map  "," write_unmergable_css_rules  search remove ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :Premailer  escape_string split map ) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :Premailer  escape_string split map ) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + ","CssParser Parser  new  add_rule_set! ","@css_paCssParser RuleSet  new er each_selector ","CssPaCssParser RuleSet  new er PaCssParser RuleSet  new er  new "," ensure_hex  gsub! ","merged [] dup  gsub! ","(str \"wel get_attribute th\") include? "," ensure_hex  gsub! strip! ","merged [] dup  gsub! strip! ","CssParser  merge  [] dup "]}," Premailer Adapter NokogiriFast match_selector":{"type":"method","name":"match_selector","children":[],"call":[" narrow_down_nodes ","desc merge ","descendants [] ","base each ","Set  new ","selector split reduce ","selector split ","(str \"[^-a-zA-Z0-9_\\\\s.#]\") match ","Set  new  merge ","Set  new endants [] "]}," Premailer Adapter NokogiriFast narrow_down_nodes":{"type":"method","name":"narrow_down_nodes","children":[],"call":["index [] intersection ","index [] ","intersection_selector split reduce ","intersection_selector split "]}," Premailer Adapter NokogiriFast index_ancestry":{"type":"method","name":"index_ancestry","children":[],"call":[" index_ancestry ","parent parent ","doc != ","descendants []= ","(or\n  (send\n    (lvar :descendants) :[]\n    (lvar :parent))\n  (send\n    (const nil :Set) :new)) add ","Set  new ","descendants [] "]}," Premailer Adapter NokogiriFast make_index":{"type":"method","name":"make_index","children":[],"call":["Set  new ","descendants default= ","index default= ","index []= ","(or\n  (send\n    (lvar :index) :[]\n    (lvar :id))\n  (send\n    (const nil :Set) :new)) add ","index [] ","# + ","node get_attribute ","node has_attribute? ","(or\n  (send\n    (lvar :index) :[]\n    (lvar :c))\n  (send\n    (const nil :Set) :new)) add ",". + ","node get_attribute split each ","node get_attribute split ","(or\n  (send\n    (lvar :index) :[]\n    (send\n      (lvar :node) :name))\n  (send\n    (const nil :Set) :new)) add ","node name "," index_ancestry ","node parent ","node != ","all_nodes push ","page traverse ","des. + endants default= ","(or\n  (send\n    (lvar :index) :[]\n    (lvar :# + ))\n  (send\n    (const nil :Set) :new)) add ","(or\n  (send\n    (lvar :index) :[]\n    (lvar :id))\n  (send\n    (. + onst nil :Set) :new)) add ","(or\n  (send\n    (lvar :index) :[]\n    (lvar :. + ))\n  (send\n    (. + onst nil :Set) :new)) add ","node get_attribute split ea. + h ","(or\n  (send\n    (lvar :index) :[]\n    (send\n      (lvar :node) :name))\n  (send\n    (. + onst nil :Set) :new)) add "," index_an. + estry "]}," Premailer Adapter NokogiriFast load_html":{"type":"method","name":"load_html","children":[],"call":["child swap ","child text ","child cdata? ","doc search children each ","doc search children ","doc search ","(str \"style\") each ","c recover "," Nokogiri  HTML ","@options [] ","RUBY_PLATFORM  == ","thing force_encoding encode! ","thing force_encoding ","RUBY_VERSION  =~ ","thing is_a? ","thing gsub! ","HTML_ENTITIES  map ","@options [] == ","thing read ","thing respond_to? "," open ","File  open ","File  dirname ","input respond_to? "," Nokogiri HTML  fragment ","URI  open "," Nokogiri  HTML5 "," Nokogiri HTML  fragment  search children each "," Nokogiri  HTML5  search children each "," Nokogiri HTML  fragment  search children "," Nokogiri  HTML5  search children "," Nokogiri HTML  fragment  search "," Nokogiri  HTML5  search ","thing force_encoding encode!  force_encoding encode! ","thing read  force_encoding encode! "," open  force_encoding encode! ","File  open  force_encoding encode! ","URI  open  force_encoding encode! ","thing force_encoding encode!  force_encoding ","thing read  force_encoding "," open  force_encoding ","File  open  force_encoding ","URI  open  force_encoding ","thing force_encoding encode!  is_a? ","thing read  is_a? "," open  is_a? ","File  open  is_a? ","URI  open  is_a? ","thing force_encoding encode!  gsub! ","thing read  gsub! "," open  gsub! ","File  open  gsub! ","URI  open  gsub! ","thing force_encoding encode!  read ","thing read  read "," open  read ","File  open  read ","URI  open  read ","thing force_encoding encode!  respond_to? ","thing read  respond_to? "," open  respond_to? ","File  open  respond_to? ","URI  open  respond_to? "]}," Premailer Adapter NokogiriFast to_s":{"type":"method","name":"to_s","children":[],"call":["@doc to_html ","@doc to_xhtml "," is_xhtml? "]}," Premailer Adapter NokogiriFast to_plain_text":{"type":"method","name":"to_plain_text","children":[],"call":[" convert_to_text ","@options [] ","@doc to_html ","html_src empty? ! ","html_src empty? ","@doc at inner_html ","@doc at ","@doc to_html  empty? ! ","@doc at inner_html  empty? ! ","@doc to_html  empty? ","@doc at inner_html  empty? "]}," Premailer Adapter NokogiriFast write_unmergable_css_rules":{"type":"method","name":"write_unmergable_css_rules","children":[],"call":["head << ","doc add_child ","doc create_element ","doc root first_element_child add_previous_sibling ","doc root first_element_child ","doc root ","doc at_css ","styles empty? ","unmergable_rules to_s ","style_tag content= "," Nokogiri XML Node  new ","@options [] ","doc at_css add_child "," Nokogiri XML  fragment ","doc at_css children before ","doc at_css children ","doc at_css children empty? ! ","doc at_css children empty? ","doc inner_html= ","doc inner_html ","(lvasgn :body\n  (send\n    (lvar :doc) :search\n    (str \"body\"))) empty? ","doc search ","doc at_css  << ","unmergable_rules to_s  empty? ","doc create_element  content= "," Nokogiri XML Node  new  content= ","(lvasgn :doc search \n  (send\n    (lvar :doc) :search\n    (str \"doc search \"))) empty? "]}," Premailer Adapter NokogiriFast to_inline_css":{"type":"method","name":"to_inline_css","children":[],"call":["@processed_doc to_html ","@options [] ","@processed_doc to_xhtml gsub ","@processed_doc to_xhtml "," is_xhtml? ","el remove_attribute ","doc search each ","doc search ","el set_attribute ","Digest MD5  hexdigest ","targets include? ","el get_attribute ","# + ","targets << ","el get_attribute [] ","el element? ","el remove ","el comment? ","doc traverse "," write_unmergable_css_rules ","el []= ","attributes join + ","attributes join ","pair [] ","(send\n  (block\n    (send\n      (lvar :attributes) :map)\n    (args\n      (arg :attr))\n    (array\n      (send\n        (send\n          (lvar :attr) :split\n          (str \":\")) :first)\n      (lvar :attr))) :sort_by) map ","pair first ","(send\n  (lvar :attributes) :map) sort_by ","attr split first ","attr split ","attributes map ","Premailer  escape_string split map ","Premailer  escape_string split ","Premailer  escape_string ","merged declarations_to_s ","merged create_shorthand! ","declarations delete ","merged instance_variable_get tap ","merged instance_variable_get "," ensure_hex ","css_att end_with? ","merged [] gsub gsub strip ","merged [] gsub gsub ","merged [] gsub ","merged [] ","merged [] empty? ! ","merged [] empty? ","el [] nil? ","el [] ","Premailer RELATED_ATTRIBUTES  [] each ","Premailer RELATED_ATTRIBUTES  [] ","el name ","Premailer RELATED_ATTRIBUTES  has_key? ","merged expand_shorthand! ","CssParser  merge ","declarations << ","CssParser RuleSet  new ","declaration [] to_i ","declaration [] ","declaration [] to_s ","style scan each ","style scan ","el attributes [] to_s ","el attributes [] ","el attributes ","doc search remove ","$stderr puts ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + ","el parent name != ","el parent name ","el parent ","el name != ","el elem? ","nodes each "," match_selector ","@unmergable_rules add_rule_set! ","@options [] ! ","selector =~ ","Premailer  is_media_query? ","1 to_s + ","2 to_s downcase ","2 to_s ","1 to_s ","selector gsub! ","@css_parser each_selector "," make_index ","[SPEC=1000[ + + ","[SPEC=1000[ + ","CssParser Parser  new ","css_attr end_with? ","new_val gsub! ","(str \"width\") include? ","new_val gsub! strip! ","merged [] dup ","Digest SHA256  hexdigest "," raise ","@processed_ write_unmergable_css_rules  to_html ","@processed_ write_unmergable_css_rules  to_xhtml gsub ","@processed_ write_unmergable_css_rules  to_xhtml "," write_unmergable_css_rules  search each "," write_unmergable_css_rules  search ","el get_attribute [] s include? ","el get_attribute [] s << "," write_unmergable_css_rules  traverse ","doc traveCssParser RuleSet  new e ","Premailer  escape_string split map  join + ","Premailer  escape_string split map  join ","(send\n  (block\n    (send\n      (lvar :Premailer  escape_string split map ) :map)\n    (args\n      (arg :attr))\n    (array\n      (send\n        (send\n          (lvar :attr) :split\n          (str \":\")) :first)\n      (lvar :attr))) :sort_by) map ","(send\n  (block\n    (send\n      (lvar :attributes) :map)\n    (args\n      (arg :attr))\n    (array\n      (send\n        (send\n          (lvar :attr) :split\n          (str \":\")) :fiCssParser RuleSet  new t)\n      (lvar :attr))) :sort_by) map ","pair fiCssParser RuleSet  new t ","(send\n  (lvar :Premailer  escape_string split map ) :map) sort_by ","attr split fiCssParser RuleSet  new t ","Premailer  escape_string split map  map ","CssParser  merge  declarations_to_s ","CssParser  merge  create_shorthand! ","CssParser  merge  instance_variable_get tap ","CssParser  merge  instance_variable_get ","CssParser  merge  [] gsub gsub strip ","CssParser  merge  [] gsub gsub ","CssParser  merge  [] gsub ","CssParser  merge  [] ","CssParser  merge  [] empty? ! ","CssParser  merge  [] empty? ","CssParser  merge  expand_shorthand! ","CssPaCssParser RuleSet  new er  merge ","CssPaCssParser RuleSet  new er RuleSet  new ","el attributes [] to_s  scan each ","el attributes [] to_s  scan ","el Premailer  escape_string split map  [] to_s ","el Premailer  escape_string split map  [] ","el Premailer  escape_string split map  "," write_unmergable_css_rules  search remove ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :Premailer  escape_string split map ) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :Premailer  escape_string split map ) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + ","CssParser Parser  new  add_rule_set! ","@css_paCssParser RuleSet  new er each_selector ","CssPaCssParser RuleSet  new er PaCssParser RuleSet  new er  new "," ensure_hex  gsub! ","merged [] dup  gsub! ","(str \"wel get_attribute th\") include? "," ensure_hex  gsub! strip! ","merged [] dup  gsub! strip! ","CssParser  merge  [] dup "]}," Premailer Adapter Nokogiri load_html":{"type":"method","name":"load_html","children":[],"call":["child swap ","child text ","child cdata? ","doc search children each ","doc search children ","doc search ","(str \"style\") each ","c recover "," Nokogiri  HTML ","@options [] ","RUBY_PLATFORM  == ","thing force_encoding encode! ","thing force_encoding ","RUBY_VERSION  =~ ","thing is_a? ","thing gsub! ","HTML_ENTITIES  map ","@options [] == ","thing read ","thing respond_to? "," open ","File  open ","File  dirname ","input respond_to? "," Nokogiri HTML  fragment ","URI  open ","c noent recover ","c noent ","HTML_ENTITIES  [] map ","HTML_ENTITIES  [] "," Nokogiri HTML  fragment  search children each "," Nokogiri HTML  fragment  search children "," Nokogiri HTML  fragment  search ","thing force_encoding encode!  force_encoding encode! ","thing read  force_encoding encode! "," open  force_encoding encode! ","File  open  force_encoding encode! ","URI  open  force_encoding encode! ","thing force_encoding encode!  force_encoding ","thing read  force_encoding "," open  force_encoding ","File  open  force_encoding ","URI  open  force_encoding ","thing force_encoding encode!  is_a? ","thing read  is_a? "," open  is_a? ","File  open  is_a? ","URI  open  is_a? ","thing force_encoding encode!  gsub! ","thing read  gsub! "," open  gsub! ","File  open  gsub! ","URI  open  gsub! ","thing force_encoding encode!  read ","thing read  read "," open  read ","File  open  read ","URI  open  read ","thing force_encoding encode!  respond_to? ","thing read  respond_to? "," open  respond_to? ","File  open  respond_to? ","URI  open  respond_to? "]}," Premailer Adapter Nokogiri to_s":{"type":"method","name":"to_s","children":[],"call":["@doc to_html ","@doc to_xhtml "," is_xhtml? "]}," Premailer Adapter Nokogiri to_plain_text":{"type":"method","name":"to_plain_text","children":[],"call":[" convert_to_text ","@options [] ","@doc to_html ","html_src empty? ! ","html_src empty? ","@doc at inner_html ","@doc at ","@doc to_html  empty? ! ","@doc at inner_html  empty? ! ","@doc to_html  empty? ","@doc at inner_html  empty? "]}," Premailer Adapter Nokogiri write_unmergable_css_rules":{"type":"method","name":"write_unmergable_css_rules","children":[],"call":["head << ","doc add_child ","doc create_element ","doc root first_element_child add_previous_sibling ","doc root first_element_child ","doc root ","doc at_css ","styles empty? ","unmergable_rules to_s ","style_tag content= "," Nokogiri XML Node  new ","@options [] ","$stderr puts ","head add_child ","unmergable_rules each_selector ","doc at ","doc inner_html= ","doc inner_html ","doc at_css children first before ","doc at_css children first ","doc at_css children ","doc search ","doc at_css add_child "," Nokogiri XML  fragment ","doc at_css children before ","doc at_css children empty? ! ","doc at_css children empty? ","(lvasgn :body\n  (send\n    (lvar :doc) :search\n    (str \"body\"))) empty? ","doc at_css  << ","doc at  << ","doc search  << ","unmergable_rules to_s  empty? ","doc create_element  content= "," Nokogiri XML Node  new  content= ","doc at_css  add_child ","doc at  add_child ","doc search  add_child ","(lvasgn :doc search \n  (send\n    (lvar :doc) :search\n    (str \"doc search \"))) empty? "]}," Premailer Adapter Nokogiri to_inline_css":{"type":"method","name":"to_inline_css","children":[],"call":["@processed_doc to_html ","@options [] ","@processed_doc to_xhtml gsub ","@processed_doc to_xhtml "," is_xhtml? ","el remove_attribute ","doc search each ","doc search ","el set_attribute ","Digest MD5  hexdigest ","targets include? ","el get_attribute ","# + ","targets << ","el get_attribute [] ","el element? ","el remove ","el comment? ","doc traverse "," write_unmergable_css_rules ","el []= ","attributes join + ","attributes join ","pair [] ","(send\n  (block\n    (send\n      (lvar :attributes) :map)\n    (args\n      (arg :attr))\n    (array\n      (send\n        (send\n          (lvar :attr) :split\n          (str \":\")) :first)\n      (lvar :attr))) :sort_by) map ","pair first ","(send\n  (lvar :attributes) :map) sort_by ","attr split first ","attr split ","attributes map ","Premailer  escape_string split map ","Premailer  escape_string split ","Premailer  escape_string ","merged declarations_to_s ","merged create_shorthand! ","declarations delete ","merged instance_variable_get tap ","merged instance_variable_get "," ensure_hex ","css_att end_with? ","merged [] gsub gsub strip ","merged [] gsub gsub ","merged [] gsub ","merged [] ","merged [] empty? ! ","merged [] empty? ","el [] nil? ","el [] ","Premailer RELATED_ATTRIBUTES  [] each ","Premailer RELATED_ATTRIBUTES  [] ","el name ","Premailer RELATED_ATTRIBUTES  has_key? ","merged expand_shorthand! ","CssParser  merge ","declarations << ","CssParser RuleSet  new ","declaration [] to_i ","declaration [] ","declaration [] to_s ","style scan each ","style scan ","el attributes [] to_s ","el attributes [] ","el attributes ","doc search remove ","$stderr puts ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + ","el parent name != ","el parent name ","el parent ","el name != ","el elem? ","selector gsub! ","@unmergable_rules add_rule_set! ","@options [] ! ","selector =~ ","Premailer  is_media_query? ","1 to_s + ","2 to_s downcase ","2 to_s ","1 to_s ","@css_parser each_selector ","[SPEC=1000[ + + ","[SPEC=1000[ + ","CssParser Parser  new ","css_attr end_with? ","new_val gsub! ","(str \"width\") include? ","new_val gsub! strip! ","merged [] dup ","Digest SHA256  hexdigest "," raise ","merged create_dimensions_shorthand! ","merged [] gsub strip ","merged create_border_shorthand! ","Premailer  escape_string split map sort join ","Premailer  escape_string split map sort ","@processed_ write_unmergable_css_rules  to_html ","@processed_ write_unmergable_css_rules  to_xhtml gsub ","@processed_ write_unmergable_css_rules  to_xhtml "," write_unmergable_css_rules  search each "," write_unmergable_css_rules  search ","el get_attribute [] s include? ","el get_attribute [] s << "," write_unmergable_css_rules  traverse ","doc traveCssParser RuleSet  new e ","Premailer  escape_string split map  join + ","Premailer  escape_string split map  join ","(send\n  (block\n    (send\n      (lvar :Premailer  escape_string split map ) :map)\n    (args\n      (arg :attr))\n    (array\n      (send\n        (send\n          (lvar :attr) :split\n          (str \":\")) :first)\n      (lvar :attr))) :sort_by) map ","(send\n  (block\n    (send\n      (lvar :attributes) :map)\n    (args\n      (arg :attr))\n    (array\n      (send\n        (send\n          (lvar :attr) :split\n          (str \":\")) :fiCssParser RuleSet  new t)\n      (lvar :attr))) :sort_by) map ","pair fiCssParser RuleSet  new t ","(send\n  (lvar :Premailer  escape_string split map ) :map) sort_by ","attr split fiCssParser RuleSet  new t ","Premailer  escape_string split map  map ","CssParser  merge  declarations_to_s ","CssParser  merge  create_shorthand! ","CssParser  merge  instance_variable_get tap ","CssParser  merge  instance_variable_get ","CssParser  merge  [] gsub gsub strip ","CssParser  merge  [] gsub gsub ","CssParser  merge  [] gsub ","CssParser  merge  [] ","CssParser  merge  [] empty? ! ","CssParser  merge  [] empty? ","CssParser  merge  expand_shorthand! ","CssPaCssParser RuleSet  new er  merge ","CssPaCssParser RuleSet  new er RuleSet  new ","el attributes [] to_s  scan each ","el attributes [] to_s  scan ","el Premailer  escape_string split map  [] to_s ","el Premailer  escape_string split map  [] ","el Premailer  escape_string split map  "," write_unmergable_css_rules  search remove ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :Premailer  escape_string split map ) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :Premailer  escape_string split map ) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + ","CssParser Parser  new  add_rule_set! ","@css_paCssParser RuleSet  new er each_selector ","CssPaCssParser RuleSet  new er PaCssParser RuleSet  new er  new "," ensure_hex  gsub! ","merged [] dup  gsub! ","(str \"wel get_attribute th\") include? "," ensure_hex  gsub! strip! ","merged [] dup  gsub! strip! ","CssParser  merge  [] dup ","CssParser  merge  create_dimensions_shorthand! ","CssParser  merge  [] gsub strip ","CssParser  merge  create_border_shorthand! "]}," Premailer write_unmergable_css_rules":{"type":"method","name":"write_unmergable_css_rules","children":[],"call":["doc search append ","doc search ","styles empty? ","unmergable_rules each_selector ","doc css children last after ","doc css children last ","doc css children ","doc css ","$stderr puts ","@options [] ","head append ","head inner_html ","head html empty? ","head html ","doc search  append ","doc search  inner_html ","doc search  html empty? ","doc search  html "]}," Premailer load_html":{"type":"method","name":"load_html","children":[],"call":[" Hpricot "," open ","f read ","File  open ","Nokogiri  HTML ","File  dirname ","path read ","path is_a? ","@options [] ","Nokogiri HTML  parse ","input respond_to? "]}," Premailer to_inline_css":{"type":"method","name":"to_inline_css","children":[],"call":["doc to_html ","doc search remove_class ","doc search ","@options [] "," write_unmergable_css_rules ","el []= ","Premailer  escape_string ","merged declarations_to_s ","CssParser  merge ","declarations << ","RuleSet  new ","declaration [] to_i ","declaration [] ","declaration [] to_s ","style scan each ","style scan ","el attributes [] to_s ","el attributes [] ","el attributes ","doc search each ","(or-asgn\n  (send\n    (send\n      (lvar :el) :attributes) :[]\n    (str \"style\"))\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (lvar :el) :attributes) :[]\n    (str \"style\"))\n  (str \"\")) + ","el elem? ","unmergable_rules add_rule_set! ","selector =~ ","1 to_s + ","2 to_s downcase ","2 to_s ","1 to_s ","selector gsub! ","@css_parser each_selector ","[SPEC=1000[ + + ","[SPEC=1000[ + ","CssParser Parser  new ","merged create_dimensions_shorthand! ","merged [] gsub strip ","merged [] gsub ","merged [] ","merged [] empty? ! ","merged [] empty? ","el [] nil? ","el [] ","RELATED_ATTRIBUTES  [] each ","RELATED_ATTRIBUTES  [] ","el name ","RELATED_ATTRIBUTES  has_key? ","merged expand_shorthand! ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + ","doc css each ","doc css ","$stderr puts ","@processed_doc to_original_html ","el parent name != ","el parent name ","el parent ","el name != "," write_unmergable_css_rules  to_html "," write_unmergable_css_rules  search remove_class "," write_unmergable_css_rules  search ","CssParser  merge  declarations_to_s ","CssPaRuleSet  new er  merge ","el attributes [] to_s  scan each ","el attributes [] to_s  scan "," write_unmergable_css_rules  search each ","(or-asgn\n  (send\n    (send\n      (lvar :el) :attributes) :[]\n    (str \"el attributes [] to_s \"))\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (lvar :el) :attributes) :[]\n    (str \"el attributes [] to_s \"))\n  (str \"\")) + ","CssParser Parser  new  add_rule_set! ","@css_paRuleSet  new er each_selector ","CssPaRuleSet  new er PaRuleSet  new er  new ","CssParser  merge  create_dimensions_shorthand! ","CssParser  merge  [] gsub strip ","CssParser  merge  [] gsub ","CssParser  merge  [] ","CssParser  merge  [] empty? ! ","CssParser  merge  [] empty? ","CssParser  merge  expand_shorthand! ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + "," write_unmergable_css_rules  css each "," write_unmergable_css_rules  css ","@processed_ write_unmergable_css_rules  to_original_html "]}," Premailer to_plain_text":{"type":"method","name":"to_plain_text","children":[],"call":[" convert_to_text ","@options [] ","@doc to_html ","@doc search innerHTML ","@doc search ","@doc search inner_html "]}," Premailer to_s":{"type":"method","name":"to_s","children":[],"call":["@doc to_html ","@doc to_xhtml "," is_xhtml? ","@doc to_original_html "]}," Adapter load_adapter":{"type":"method","name":"load_adapter","children":[],"call":[]}," Adapter validate_adapter!":{"type":"method","name":"validate_adapter!","children":[],"call":[]}," Adapter find":{"type":"method","name":"find","children":[],"call":[]}," Adapter adapters":{"type":"method","name":"adapters","children":[],"call":[]}," Adapter use=":{"type":"method","name":"use=","children":[],"call":[]}," Adapter use":{"type":"method","name":"use","children":[],"call":[]}," Adapter Nokogiri load_html":{"type":"method","name":"load_html","children":[],"call":["c noent recover ","c noent "," Nokogiri  HTML ","thing force_encoding encode! ","thing force_encoding ","RUBY_VERSION  =~ ","thing is_a? ","thing read ","thing respond_to? "," open ","File  open ","File  dirname ","input respond_to? ","@options [] ","thing force_encoding encode!  force_encoding encode! ","thing read  force_encoding encode! "," open  force_encoding encode! ","File  open  force_encoding encode! ","thing force_encoding encode!  force_encoding ","thing read  force_encoding "," open  force_encoding ","File  open  force_encoding ","thing force_encoding encode!  is_a? ","thing read  is_a? "," open  is_a? ","File  open  is_a? ","thing force_encoding encode!  read ","thing read  read "," open  read ","File  open  read ","thing force_encoding encode!  respond_to? ","thing read  respond_to? "," open  respond_to? ","File  open  respond_to? "]}," Adapter Nokogiri to_s":{"type":"method","name":"to_s","children":[],"call":["@doc to_html ","@doc to_xhtml "," is_xhtml? "]}," Adapter Nokogiri to_plain_text":{"type":"method","name":"to_plain_text","children":[],"call":[" convert_to_text ","@options [] ","@doc to_html ","html_src empty? ! ","html_src empty? ","@doc at inner_html ","@doc at ","@doc to_html  empty? ! ","@doc at inner_html  empty? ! ","@doc to_html  empty? ","@doc at inner_html  empty? "]}," Adapter Nokogiri write_unmergable_css_rules":{"type":"method","name":"write_unmergable_css_rules","children":[],"call":["$stderr puts ","@options [] ","head add_child ","styles empty? ","unmergable_rules each_selector ","doc at ","doc at  add_child "]}," Adapter Nokogiri to_inline_css":{"type":"method","name":"to_inline_css","children":[],"call":["@processed_doc to_html ","@processed_doc to_xhtml "," is_xhtml? ","el remove_attribute ","el set_attribute ","Digest MD5  hexdigest ","targets include? ","el get_attribute ","doc search each ","doc search ","# + ","targets << ","el get_attribute [] ","@options [] ","el element? ","el remove ","el comment? ","doc traverse "," write_unmergable_css_rules ","el []= ","Premailer  escape_string ","merged declarations_to_s ","merged create_dimensions_shorthand! ","merged [] gsub strip ","merged [] gsub ","merged [] ","merged [] empty? ! ","merged [] empty? ","el [] nil? ","el [] ","Premailer RELATED_ATTRIBUTES  [] each ","Premailer RELATED_ATTRIBUTES  [] ","el name ","Premailer RELATED_ATTRIBUTES  has_key? ","merged expand_shorthand! ","CssParser  merge ","declarations << ","CssParser RuleSet  new ","declaration [] to_i ","declaration [] ","declaration [] to_s ","style scan each ","style scan ","el attributes [] to_s ","el attributes [] ","el attributes ","$stderr puts ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + ","el parent name != ","el parent name ","el parent ","el name != ","el elem? ","selector gsub! ","@unmergable_rules add_rule_set! ","selector =~ ","1 to_s + ","2 to_s downcase ","2 to_s ","1 to_s ","@css_parser each_selector ","[SPEC=1000[ + + ","[SPEC=1000[ + ","CssParser Parser  new ","@processed_ write_unmergable_css_rules  to_html ","@processed_ write_unmergable_css_rules  to_xhtml ","el get_attribute [] s include? "," write_unmergable_css_rules  search each "," write_unmergable_css_rules  search ","el get_attribute [] s << "," write_unmergable_css_rules  traverse ","doc traveCssParser RuleSet  new e ","CssParser  merge  declarations_to_s ","CssParser  merge  create_dimensions_shorthand! ","CssParser  merge  [] gsub strip ","CssParser  merge  [] gsub ","CssParser  merge  [] ","CssParser  merge  [] empty? ! ","CssParser  merge  [] empty? ","CssParser  merge  expand_shorthand! ","CssPaCssParser RuleSet  new er  merge ","CssPaCssParser RuleSet  new er RuleSet  new ","el attributes [] to_s  scan each ","el attributes [] to_s  scan ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + ","CssParser Parser  new  add_rule_set! ","@css_paCssParser RuleSet  new er each_selector ","CssPaCssParser RuleSet  new er PaCssParser RuleSet  new er  new "]}," Adapter Hpricot load_html":{"type":"method","name":"load_html","children":[],"call":[" Hpricot "," open ","File  open ","File  dirname ","input respond_to? ","@options [] "]}," Adapter Hpricot to_s":{"type":"method","name":"to_s","children":[],"call":["@doc to_original_html "]}," Adapter Hpricot to_plain_text":{"type":"method","name":"to_plain_text","children":[],"call":[" convert_to_text ","@options [] ","@doc to_html ","html_src empty? ! ","html_src empty? ","@doc search inner_html ","@doc search ","@doc to_html  empty? ! ","@doc search inner_html  empty? ! ","@doc to_html  empty? ","@doc search inner_html  empty? "]}," Adapter Hpricot write_unmergable_css_rules":{"type":"method","name":"write_unmergable_css_rules","children":[],"call":["$stderr puts ","@options [] ","head append ","head inner_html ","head html empty? ","head html ","styles empty? ","unmergable_rules each_selector ","doc search ","doc search  append ","doc search  inner_html ","doc search  html empty? ","doc search  html "]}," Adapter Hpricot to_inline_css":{"type":"method","name":"to_inline_css","children":[],"call":["@processed_doc to_original_html ","el remove_attribute ","el set_attribute ","Digest MD5  hexdigest ","targets include? ","el get_attribute ","doc search each ","doc search ","# + ","targets << ","el get_attribute [] ","@options [] ","el elem? ","lst delete ","el parent= ","el parent children ","el parent ","el comment? "," write_unmergable_css_rules ","el []= ","Premailer  escape_string ","merged declarations_to_s ","merged create_dimensions_shorthand! ","merged [] gsub strip ","merged [] gsub ","merged [] ","merged [] empty? ! ","merged [] empty? ","el [] nil? ","el [] ","Premailer RELATED_ATTRIBUTES  [] each ","Premailer RELATED_ATTRIBUTES  [] ","el name ","Premailer RELATED_ATTRIBUTES  has_key? ","merged expand_shorthand! ","CssParser  merge ","declarations << ","CssParser RuleSet  new ","declaration [] to_i ","declaration [] ","declaration [] to_s ","style scan each ","style scan ","el attributes [] to_s ","el attributes [] ","el attributes ","$stderr puts ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + ","el parent name != ","el parent name ","el name != ","selector gsub! ","@unmergable_rules add_rule_set! ","selector =~ ","1 to_s + ","2 to_s downcase ","2 to_s ","1 to_s ","@css_parser each_selector ","[SPEC=1000[ + + ","[SPEC=1000[ + ","CssParser Parser  new ","@processed_ write_unmergable_css_rules  to_original_html ","el get_attribute [] s include? "," write_unmergable_css_rules  search each "," write_unmergable_css_rules  search ","el get_attribute [] s << ","el parent children  delete ","CssParser  merge  declarations_to_s ","CssParser  merge  create_dimensions_shorthand! ","CssParser  merge  [] gsub strip ","CssParser  merge  [] gsub ","CssParser  merge  [] ","CssParser  merge  [] empty? ! ","CssParser  merge  [] empty? ","CssParser  merge  expand_shorthand! ","CssPaCssParser RuleSet  new er  merge ","CssPaCssParser RuleSet  new er RuleSet  new ","el attributes [] to_s  scan each ","el attributes [] to_s  scan ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + ","CssParser Parser  new  add_rule_set! ","@css_paCssParser RuleSet  new er each_selector ","CssPaCssParser RuleSet  new er PaCssParser RuleSet  new er  new "]}," Premailer Adapter Hpricot load_html":{"type":"method","name":"load_html","children":[],"call":[" Hpricot "," open ","File  open ","File  dirname ","input respond_to? ","@options [] "]}," Premailer Adapter Hpricot to_s":{"type":"method","name":"to_s","children":[],"call":["@doc to_original_html "]}," Premailer Adapter Hpricot to_plain_text":{"type":"method","name":"to_plain_text","children":[],"call":[" convert_to_text ","@options [] ","@doc to_html ","html_src empty? ! ","html_src empty? ","@doc search inner_html ","@doc search ","@doc to_html  empty? ! ","@doc search inner_html  empty? ! ","@doc to_html  empty? ","@doc search inner_html  empty? "]}," Premailer Adapter Hpricot write_unmergable_css_rules":{"type":"method","name":"write_unmergable_css_rules","children":[],"call":["$stderr puts ","@options [] ","head append ","head inner_html ","head html empty? ","head html ","styles empty? ","unmergable_rules each_selector ","doc search ","doc inner_html= ","doc inner_html << ","doc inner_html ","body append ","unmergable_rules to_s ","doc search  append ","doc search  inner_html ","doc search  html empty? ","doc search  html ","unmergable_rules to_s  empty? "]}," Premailer Adapter Hpricot to_inline_css":{"type":"method","name":"to_inline_css","children":[],"call":["@processed_doc to_original_html ","el remove_attribute ","el set_attribute ","Digest MD5  hexdigest ","targets include? ","el get_attribute ","doc search each ","doc search ","# + ","targets << ","el get_attribute [] ","@options [] ","el elem? ","lst delete ","el parent= ","el parent children ","el parent ","el comment? "," write_unmergable_css_rules ","el []= ","Premailer  escape_string ","merged declarations_to_s ","merged create_dimensions_shorthand! ","merged [] gsub strip ","merged [] gsub ","merged [] ","merged [] empty? ! ","merged [] empty? ","el [] nil? ","el [] ","Premailer RELATED_ATTRIBUTES  [] each ","Premailer RELATED_ATTRIBUTES  [] ","el name ","Premailer RELATED_ATTRIBUTES  has_key? ","merged expand_shorthand! ","CssParser  merge ","declarations << ","CssParser RuleSet  new ","declaration [] to_i ","declaration [] ","declaration [] to_s ","style scan each ","style scan ","el attributes [] to_s ","el attributes [] ","el attributes ","$stderr puts ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"style\")) :to_s)\n  (str \"\")) + ","el parent name != ","el parent name ","el name != ","selector gsub! ","@unmergable_rules add_rule_set! ","selector =~ ","1 to_s + ","2 to_s downcase ","2 to_s ","1 to_s ","@css_parser each_selector ","[SPEC=1000[ + + ","[SPEC=1000[ + ","CssParser Parser  new ","merged create_border_shorthand! ","@options [] ! ","merged [] gsub gsub strip ","merged [] gsub gsub ","doc search remove ","merged create_shorthand! ","Premailer  is_media_query? ","declarations delete ","merged instance_variable_get tap ","merged instance_variable_get "," ensure_hex ","css_att end_with? ","@processed_ write_unmergable_css_rules  to_original_html ","el get_attribute [] s include? "," write_unmergable_css_rules  search each "," write_unmergable_css_rules  search ","el get_attribute [] s << ","el parent children  delete ","CssParser  merge  declarations_to_s ","CssParser  merge  create_dimensions_shorthand! ","CssParser  merge  [] gsub strip ","CssParser  merge  [] gsub ","CssParser  merge  [] ","CssParser  merge  [] empty? ! ","CssParser  merge  [] empty? ","CssParser  merge  expand_shorthand! ","CssPaCssParser RuleSet  new er  merge ","CssPaCssParser RuleSet  new er RuleSet  new ","el attributes [] to_s  scan each ","el attributes [] to_s  scan ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + + ","(or-asgn\n  (send\n    (send\n      (send\n        (lvar :el) :attributes) :[]\n      (str \"el attributes [] to_s \")) :to_s)\n  (str \"\")) + ","CssParser Parser  new  add_rule_set! ","@css_paCssParser RuleSet  new er each_selector ","CssPaCssParser RuleSet  new er PaCssParser RuleSet  new er  new ","CssParser  merge  create_border_shorthand! ","CssParser  merge  [] gsub gsub strip ","CssParser  merge  [] gsub gsub "," write_unmergable_css_rules  search remove ","CssParser  merge  create_shorthand! ","CssParser  merge  instance_variable_get tap ","CssParser  merge  instance_variable_get "]}," Premailer Adapter Hpricot included":{"type":"method","name":"included","children":[],"call":[]}}