{" Annotate load_tasks":{"type":"method","name":"load_tasks","children":[],"call":[]}," Annotate version":{"type":"method","name":"version","children":[],"call":[]}," AnnotateRoutes do_annotate":{"type":"method","name":"do_annotate","children":[],"call":[]}," ActiveRecord Base method_missing":{"type":"method","name":"method_missing","children":[],"call":[]}," AnnotateModels remove_annotations":{"type":"method","name":"remove_annotations","children":[],"call":[" puts ","deannotated join ","e message "," remove_annotation_of_file ","File  exist? ","(send\n  (const nil :File) :join\n  (const nil :UNIT_TEST_DIR)\n  (dstr\n    (begin\n      (send\n        (send\n          (lvar :klass) :name) :underscore))\n    (str \"_test.rb\"))) each ","File  join ","klass name underscore ","klass name ","klass table_name + ","klass table_name ","FIXTURE_DIRS  each "," model_dir ","deannotated << ","klass abstract_class? ! ","klass abstract_class? ","klass < "," get_model_class "," get_model_files each "," get_model_files "," model_dir= ","options [] ","\t + ","e backtrace join ","e backtrace ","(send\n  (const nil :File) :join\n  (const nil :UNIT_TEST_DIR)\n  (dstr\n    (begin\n      (lvar :model_name))\n    (str \"_test.rb\"))) each ","(send\n  (begin\n    (send\n      (const nil :FIXTURE_PATTERNS) :+\n      (const nil :FACTORY_PATTERNS))) :map) each "," resolve_filename ","(send\n  (const nil :FIXTURE_PATTERNS) :+\n  (const nil :FACTORY_PATTERNS)) map ","FIXTURE_PATTERNS  + ","(send\n  (block\n    (send\n      (const nil :TEST_PATTERNS) :map)\n    (args\n      (arg :pat))\n    (array\n      (send\n        (lvar :pat) :[]\n        (int 0))\n      (send nil :resolve_filename\n        (send\n          (lvar :pat) :[]\n          (int 1))\n        (lvar :model_name)\n        (lvar :table_name)))) :map) each "," find_test_file ","(send\n  (const nil :TEST_PATTERNS) :map) map ","pat [] ","TEST_PATTERNS  map ","(send\n  (begin\n    (send\n      (send\n        (send\n          (const nil :TEST_PATTERNS) :+\n          (const nil :FIXTURE_PATTERNS)) :+\n        (const nil :FACTORY_PATTERNS)) :+\n      (const nil :SERIALIZER_PATTERNS))) :map) each ","(send\n  (send\n    (send\n      (const nil :TEST_PATTERNS) :+\n      (const nil :FIXTURE_PATTERNS)) :+\n    (const nil :FACTORY_PATTERNS)) :+\n  (const nil :SERIALIZER_PATTERNS)) map ","TEST_PATTERNS  + + + ","TEST_PATTERNS  + + ","TEST_PATTERNS  + ","(send\n  (begin\n    (send\n      (send\n        (const nil :TEST_PATTERNS) :+\n        (const nil :FIXTURE_PATTERNS)) :+\n      (const nil :FACTORY_PATTERNS))) :map) each ","(send\n  (send\n    (const nil :TEST_PATTERNS) :+\n    (const nil :FIXTURE_PATTERNS)) :+\n  (const nil :FACTORY_PATTERNS)) map ","(send\n  (send nil :get_patterns) :map) each "," get_patterns map "," get_patterns "," root_dir= ","(send\n  (send nil :get_patterns\n    (send nil :matched_types\n      (lvar :options))) :map) each "," matched_types "," parse_options ","$stderr puts ","(send\n  (send nil :get_patterns\n    (lvar :options)\n    (send nil :matched_types\n      (lvar :options))) :map) each "," remove_annotation_of_File  join  ","(send\n  (const nil :File) :join\n  (const nil :UNIT_TEST_DIR)\n  (dstr\n    (begin\n      (send\n        (send\n          (lvar : get_model_class ) :name) :underscore))\n    (str \"_test.rb\"))) each "," get_model_class  name underscore "," get_model_class  name "," get_model_class  table_name + ","klass klass table_name  + "," get_model_class  table_name ","klass klass table_name  "," get_model_class  abstract_class? ! "," get_model_class  abstract_class? "," get_model_class  < "," get_model_File  join s each "," get_model_File  join s ","(send\n  (const nil :File) :join\n  (const nil :UNIT_TEST_DIR)\n  (dstr\n    (begin\n      (lvar :klass name underscore ))\n    (str \"_test.rb\"))) each "," resolve_File  join name ","(send\n  (block\n    (send\n      (const nil :TEST_PATTERNS) :map)\n    (args\n      (arg :pat))\n    (array\n      (send\n        (lvar :pat) :[]\n        (int 0))\n      (send nil :resolve_filename\n        (send\n          (lvar :pat) :[]\n          (int 1))\n        (lvar :klass name underscore )\n        (lvar :table_name)))) :map) each ","(send\n  (block\n    (send\n      (const nil :TEST_PATTERNS) :map)\n    (args\n      (arg :pat))\n    (array\n      (send\n        (lvar :pat) :[]\n        (int 0))\n      (send nil :resolve_filename\n        (send\n          (lvar :pat) :[]\n          (int 1))\n        (lvar :model_name)\n        (lvar :klass table_name )))) :map) each ","(send\n  (block\n    (send\n      (const nil :TEST_PATTERNS) :map)\n    (args\n      (arg :pat))\n    (array\n      (send\n        (lvar :pat) :[]\n        (int 0))\n      (send nil :resolve_File  join name\n        (send\n          (lvar :pat) :[]\n          (int 1))\n        (lvar :model_name)\n        (lvar :table_name)))) :map) each "," find_test_File  join  "]}," AnnotateModels do_annotations":{"type":"method","name":"do_annotations","children":[],"call":[" puts ","annotated join ","annotated length ","annotated empty? ","e inspect ","annotated << "," annotate ","klass abstract_class? ! ","klass abstract_class? ","klass < "," get_model_class "," get_model_files each "," get_model_files "," model_dir= ","options [] ","header << ","version > ","ActiveRecord Migrator  current_version ","PREFIX  dup "," require ","options [] each "," annotate_model_file ","PREFIX_MD  dup ","e backtrace first ","e backtrace ","e message ","File  join "," root_dir= "," parse_options "," get_model_class  abstract_class? ! "," get_model_class  abstract_class? "," get_model_class  < ","PREFIX  dup  << ","PREFIX_MD  dup  << "]}," AnnotateModels get_model_class":{"type":"method","name":"get_model_class","children":[],"call":["Object  const_get ","parts last ","klass const_get ","parts inject ","model split ","file gsub camelize ","file gsub "," require ","File  expand_path "," model_dir ","parts last downcase == ","c downcase ","parts last downcase ","Module  constants detect ","Module  constants ","ActiveSupport Inflector  camelize "," get_loaded_model ","model_path split last ","model_path split ","Module  const_defined? "," raise ","model_path split [] join to_s ","model_path split [] join ","model_path split [] ","model_path match ","Kernel  require ","File  file? ","LoadError  new ","model_path gsub gsub ","model_path gsub "," model_dir each "," silence_warnings ","BadModelFileError  new ","model_path =~ ","model split  last ","model split  inject ","file gsub camelize  split ","ActiveSupport Inflector  camelize  split "," file gsub camelize _dir "," ActiveSupport Inflector  camelize _dir ","model split  last downcase == ","model split  last downcase "," get_loaded_file gsub camelize  "," get_loaded_ActiveSupport Inflector  camelize  ","file gsub camelize _path split last ","ActiveSupport Inflector  camelize _path split last ","file gsub  split last ","model_path split [] join to_s  split last ","model_path gsub gsub  split last ","file gsub camelize _path split ","ActiveSupport Inflector  camelize _path split ","file gsub  split ","model_path split [] join to_s  split ","model_path gsub gsub  split ","file gsub camelize _path split [] join to_s ","ActiveSupport Inflector  camelize _path split [] join to_s ","file gsub  split [] join to_s ","model_path split [] join to_s  split [] join to_s ","model_path gsub gsub  split [] join to_s ","file gsub camelize _path split [] join ","ActiveSupport Inflector  camelize _path split [] join ","file gsub  split [] join ","model_path split [] join to_s  split [] join ","model_path gsub gsub  split [] join ","file gsub camelize _path split [] ","ActiveSupport Inflector  camelize _path split [] ","file gsub  split [] ","model_path split [] join to_s  split [] ","model_path gsub gsub  split [] ","file gsub camelize _path match ","ActiveSupport Inflector  camelize _path match ","file gsub  match ","model_path split [] join to_s  match ","model_path gsub gsub  match ","file gsub camelize _path gsub gsub ","ActiveSupport Inflector  camelize _path gsub gsub ","file gsub  gsub gsub ","model_path split [] join to_s  gsub gsub ","model_path gsub gsub  gsub gsub ","file gsub camelize _path gsub ","ActiveSupport Inflector  camelize _path gsub ","file gsub  gsub ","model_path split [] join to_s  gsub ","model_path gsub gsub  gsub "," file gsub camelize _dir each "," ActiveSupport Inflector  camelize _dir each ","file gsub camelize _path =~ ","ActiveSupport Inflector  camelize _path =~ ","file gsub  =~ ","model_path split [] join to_s  =~ ","model_path gsub gsub  =~ "]}," AnnotateModels get_model_files":{"type":"method","name":"get_model_files","children":[],"call":[" exit "," puts "," model_dir ","Dir  [] ","Dir  chdir ","models empty? ","m match ","models reject! ","models shift ","ARGV  dup ","options [] ","options [] ! "," model_dir join ","models concat ","(send\n  (send\n    (const nil :Dir) :[]\n    (str \"**/*.rb\")) :reject) map ","f [] ","Dir  [] reject ","Dir  [] map "," model_dir each ","ARGV  dup reject ","$stderr puts ","model_files concat ","model_files empty? "," list_model_files_from_argument ","Dir  []  empty? ","ARGV  dup  empty? ","Dir  []  reject! ","ARGV  dup  reject! ","Dir  []  shift ","ARGV  dup  shift ","Dir  []  concat ","ARGV  dup  concat "," list_model_files_from_argument  concat "," list_model_files_from_argument  empty? "," list_ list_model_files_from_argument _from_argument "]}," AnnotateModels options_with_position":{"type":"method","name":"options_with_position","children":[],"call":["options merge ","options [] "]}," AnnotateModels annotate":{"type":"method","name":"annotate","children":[],"call":[" annotate_one_file "," options_with_position ","File  exist? ","File  join ","klass table_name + ","klass table_name ","FIXTURE_DIRS  each ","(send\n  (const nil :File) :join\n  (const nil :EXEMPLARS_TEST_DIR)\n  (dstr\n    (begin\n      (lvar :model_name))\n    (str \"_exemplar.rb\"))) each ","ENV  [] ","(send\n  (const nil :File) :join\n  (const nil :UNIT_TEST_DIR)\n  (dstr\n    (begin\n      (lvar :model_name))\n    (str \"_test.rb\"))) each "," model_dir ","klass name underscore ","klass name "," get_schema_info ","(send\n  (const nil :File) :join\n  (const nil :FIXTURE_TEST_DIR)\n  (dstr\n    (begin\n      (send\n        (lvar :klass) :table_name))\n    (str \".yml\"))) each ","options [] ","(send nil :find_test_file\n  (const nil :UNIT_TEST_DIR)\n  (dstr\n    (begin\n      (lvar :model_name))\n    (str \"_test.rb\"))) each "," find_test_file "," puts ","\t + ","e backtrace join ","e backtrace ","e message ","(send\n  (block\n    (send\n      (const nil :FACTORY_PATTERNS) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :model_name)\n      (lvar :table_name))) :map) detect ","(send\n  (const nil :FACTORY_PATTERNS) :map) map "," resolve_filename ","FACTORY_PATTERNS  map ","(send\n  (block\n    (send\n      (const nil :FIXTURE_PATTERNS) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :model_name)\n      (lvar :table_name))) :map) detect ","(send\n  (const nil :FIXTURE_PATTERNS) :map) map ","FIXTURE_PATTERNS  map ","(send\n  (block\n    (send\n      (block\n        (send\n          (const nil :TEST_PATTERNS) :map)\n        (args\n          (arg :pat))\n        (array\n          (send\n            (lvar :pat) :[]\n            (int 0))\n          (send nil :resolve_filename\n            (send\n              (lvar :pat) :[]\n              (int 1))\n            (lvar :model_name)\n            (lvar :table_name)))) :map)\n    (args\n      (arg :pat))\n    (send nil :find_test_file\n      (splat\n        (lvar :pat)))) :map) detect ","(send\n  (block\n    (send\n      (const nil :TEST_PATTERNS) :map)\n    (args\n      (arg :pat))\n    (array\n      (send\n        (lvar :pat) :[]\n        (int 0))\n      (send nil :resolve_filename\n        (send\n          (lvar :pat) :[]\n          (int 1))\n        (lvar :model_name)\n        (lvar :table_name)))) :map) map ","(send\n  (const nil :TEST_PATTERNS) :map) map ","pat [] ","TEST_PATTERNS  map ","(send\n  (block\n    (send\n      (send\n        (self) :const_get\n        (lvar :patterns_constant)) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :model_name)\n      (lvar :table_name))) :map) detect ","(send\n  (send\n    (self) :const_get\n    (lvar :patterns_constant)) :map) map "," const_get map "," const_get ","(str \"position_in_\") to_sym ","(begin\n  (send\n    (lvar :key) :upcase)) to_sym ","key upcase ","(str \"exclude_\") to_sym ","key pluralize ","(str \"test\") each ","(send\n  (block\n    (send\n      (const nil :TEST_PATTERNS) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :model_name)\n      (lvar :table_name))) :map) detect ","(send\n  (block\n    (send\n      (send\n        (self) :get_patterns\n        (lvar :key)) :map)\n    (args\n      (arg :f))\n    (send nil :resolve_filename\n      (lvar :f)\n      (lvar :model_name)\n      (lvar :table_name))) :map) detect ","(send\n  (send\n    (self) :get_patterns\n    (lvar :key)) :map) map "," get_patterns map "," get_patterns ","MATCHED_TYPES  each ","annotated << ","(send\n  (send\n    (self) :get_patterns\n    (lvar :key)) :map) each ","position_in_class to_sym ","exclude_class to_sym ","key == "," matched_types each "," matched_types ","klass reset_column_information ","(send\n  (send nil :get_patterns\n    (lvar :key)) :map) each ","$stderr puts ","(send\n  (block\n    (send\n      (send nil :get_patterns\n        (lvar :options)\n        (lvar :key)) :map)\n    (args\n      (arg :f))\n    (send nil :resolve_filename\n      (lvar :f)\n      (lvar :model_name)\n      (lvar :table_name))) :map) flatten each ","(send\n  (block\n    (send\n      (send nil :get_patterns\n        (lvar :options)\n        (lvar :key)) :map)\n    (args\n      (arg :f))\n    (send nil :resolve_filename\n      (lvar :f)\n      (lvar :model_name)\n      (lvar :table_name))) :map) flatten "," expand_glob_into_files ","(send\n  (send nil :get_patterns\n    (lvar :options)\n    (lvar :key)) :map) map ","klass klass table_name  + ","klass klass table_name  ","(send\n  (const nil :File) :join\n  (const nil :EXEMPLARS_TEST_DIR)\n  (dstr\n    (begin\n      (lvar :klass name underscore ))\n    (str \"_exemplar.rb\"))) each ","(send\n  (const nil :File) :join\n  (const nil :UNIT_TEST_DIR)\n  (dstr\n    (begin\n      (lvar :klass name underscore ))\n    (str \"_test.rb\"))) each "," get_schema_ get_schema_info  ","(send\n  (const nil :File) :join\n  (const nil :FIXTURE_TEST_DIR)\n  (dstr\n    (begin\n      (send\n        (lvar :klass) :klass table_name ))\n    (str \".yml\"))) each ","(send nil :find_test_file\n  (const nil :UNIT_TEST_DIR)\n  (dstr\n    (begin\n      (lvar :klass name underscore ))\n    (str \"_test.rb\"))) each ","(send\n  (block\n    (send\n      (const nil :FACTORY_PATTERNS) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :klass name underscore )\n      (lvar :table_name))) :map) detect ","(send\n  (block\n    (send\n      (const nil :FACTORY_PATTERNS) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :model_name)\n      (lvar :klass table_name ))) :map) detect ","(send\n  (block\n    (send\n      (const nil :FIXTURE_PATTERNS) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :klass name underscore )\n      (lvar :table_name))) :map) detect ","(send\n  (block\n    (send\n      (const nil :FIXTURE_PATTERNS) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :model_name)\n      (lvar :klass table_name ))) :map) detect ","(send\n  (block\n    (send\n      (block\n        (send\n          (const nil :TEST_PATTERNS) :map)\n        (args\n          (arg :pat))\n        (array\n          (send\n            (lvar :pat) :[]\n            (int 0))\n          (send nil :resolve_filename\n            (send\n              (lvar :pat) :[]\n              (int 1))\n            (lvar :klass name underscore )\n            (lvar :table_name)))) :map)\n    (args\n      (arg :pat))\n    (send nil :find_test_file\n      (splat\n        (lvar :pat)))) :map) detect ","(send\n  (block\n    (send\n      (block\n        (send\n          (const nil :TEST_PATTERNS) :map)\n        (args\n          (arg :pat))\n        (array\n          (send\n            (lvar :pat) :[]\n            (int 0))\n          (send nil :resolve_filename\n            (send\n              (lvar :pat) :[]\n              (int 1))\n            (lvar :model_name)\n            (lvar :klass table_name )))) :map)\n    (args\n      (arg :pat))\n    (send nil :find_test_file\n      (splat\n        (lvar :pat)))) :map) detect ","(send\n  (block\n    (send\n      (const nil :TEST_PATTERNS) :map)\n    (args\n      (arg :pat))\n    (array\n      (send\n        (lvar :pat) :[]\n        (int 0))\n      (send nil :resolve_filename\n        (send\n          (lvar :pat) :[]\n          (int 1))\n        (lvar :klass name underscore )\n        (lvar :table_name)))) :map) map ","(send\n  (block\n    (send\n      (const nil :TEST_PATTERNS) :map)\n    (args\n      (arg :pat))\n    (array\n      (send\n        (lvar :pat) :[]\n        (int 0))\n      (send nil :resolve_filename\n        (send\n          (lvar :pat) :[]\n          (int 1))\n        (lvar :model_name)\n        (lvar :klass table_name )))) :map) map ","(send\n  (block\n    (send\n      (send\n        (self) :const_get\n        (lvar :patterns_constant)) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :klass name underscore )\n      (lvar :table_name))) :map) detect ","(send\n  (block\n    (send\n      (send\n        (self) :const_get\n        (lvar :patterns_constant)) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :model_name)\n      (lvar :klass table_name ))) :map) detect ","(send\n  (block\n    (send\n      (send\n        (self) :const_get\n        (lvar :(begin\n  (send\n    (lvar :key) :upcase)) to_sym )) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :model_name)\n      (lvar :table_name))) :map) detect ","(send\n  (send\n    (self) :const_get\n    (lvar :(begin\n  (send\n    (lvar :key) :upcase)) to_sym )) :map) map ","(send\n  (block\n    (send\n      (const nil :TEST_PATTERNS) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :klass name underscore )\n      (lvar :table_name))) :map) detect ","(send\n  (block\n    (send\n      (const nil :TEST_PATTERNS) :map)\n    (args\n      (arg :file))\n    (send nil :resolve_filename\n      (lvar :file)\n      (lvar :model_name)\n      (lvar :klass table_name ))) :map) detect ","(send\n  (block\n    (send\n      (send\n        (self) :get_patterns\n        (lvar :key)) :map)\n    (args\n      (arg :f))\n    (send nil :resolve_filename\n      (lvar :f)\n      (lvar :klass name underscore )\n      (lvar :table_name))) :map) detect ","(send\n  (block\n    (send\n      (send\n        (self) :get_patterns\n        (lvar :key)) :map)\n    (args\n      (arg :f))\n    (send nil :resolve_filename\n      (lvar :f)\n      (lvar :model_name)\n      (lvar :klass table_name ))) :map) detect ","klass reset_column_ get_schema_info rmation ","(send\n  (block\n    (send\n      (send nil :get_patterns\n        (lvar :options)\n        (lvar :key)) :map)\n    (args\n      (arg :f))\n    (send nil :resolve_filename\n      (lvar :f)\n      (lvar :klass name underscore )\n      (lvar :table_name))) :map) flatten each ","(send\n  (block\n    (send\n      (send nil :get_patterns\n        (lvar :options)\n        (lvar :key)) :map)\n    (args\n      (arg :f))\n    (send nil :resolve_filename\n      (lvar :f)\n      (lvar :model_name)\n      (lvar :klass table_name ))) :map) flatten each ","(send\n  (block\n    (send\n      (send nil :get_patterns\n        (lvar :options)\n        (lvar :key)) :map)\n    (args\n      (arg :f))\n    (send nil :resolve_filename\n      (lvar :f)\n      (lvar :klass name underscore )\n      (lvar :table_name))) :map) flatten ","(send\n  (block\n    (send\n      (send nil :get_patterns\n        (lvar :options)\n        (lvar :key)) :map)\n    (args\n      (arg :f))\n    (send nil :resolve_filename\n      (lvar :f)\n      (lvar :model_name)\n      (lvar :klass table_name ))) :map) flatten "]}," AnnotateModels remove_annotation_of_file":{"type":"method","name":"remove_annotation_of_file","children":[],"call":["f puts ","File  open ","content sub! ","File  read ","File  exist? "," annotate_pattern ","options [] ","content =~ ","File  read  sub! ","File  read  =~ "]}," AnnotateModels annotate_one_file":{"type":"method","name":"annotate_one_file","children":[],"call":["f puts ","File  open ","old_content + + ","old_content + ","info_block + ","options [] == ","options [] ","old_content sub! ","old_header == ","info_block match to_s ","info_block match ","old_content match to_s ","old_content match ","Regexp  new ","File  read ","File  exist? ","(if\n  (send\n    (lvar :old_content) :=~\n    (regexp\n      (str \"\\\\n$\")\n      (regopt)))\n  (lvar :old_content)\n  (send\n    (lvar :old_content) :+\n    (str \"\\\\n\"))) + ","old_content =~ ","new_content == ","old_content sub ","old_columns == ","new_header scan sort ","new_header scan ","old_header scan sort ","old_header scan ","encoding_header + + ","encoding_header + ","old_content rstrip + + ","old_content rstrip + ","old_content rstrip ","(or\n  (send\n    (lvar :options) :[]\n    (sym :position))\n  (str \"before\")) to_s == ","(or\n  (send\n    (lvar :options) :[]\n    (sym :position))\n  (str \"before\")) to_s ","options [] ! ","encoding_header + + + ","options [] to_s == ","options [] to_s ","(str \"after\") include? ","\n + ","new_content end_with? ","magic_comments join + + + ","magic_comments join + + ","magic_comments join + ","magic_comments join ","old_content scan flatten compact ","old_content scan flatten ","old_content scan "," annotate_pattern ","magic_comments_block + + + ","magic_comments_block + + ","magic_comments_block + ","old_content gsub! "," magic_comment_matcher "," magic_comments_as_string ","space_match [] + + ","space_match [] ","space_match [] + ","old_annotation match ","magic_comments_block + + + + ","magic_comments_block empty? ","old_annotation empty? "," abort ","old_content lstrip ","File  read  + + ","File  read  + ","File  read  sub! ","old_content match to_s  == ","old_Regexp  new  == ","File  read  match to_s ","File  read  match ","(if\n  (send\n    (lvar :File  read ) :=~\n    (regexp\n      (str \"\\\\n$\")\n      (regopt)))\n  (lvar :File  read )\n  (send\n    (lvar :File  read ) :+\n    (str \"\\\\n\"))) + ","File  read  =~ ","old_content sub  == ","magic_comments join + + +  == ","magic_comments join +  == ","magic_comments_block + + +  == ","magic_comments_block +  == ","File  read  sub ","info_block match to_s  scan sort ","new_Regexp  new  scan sort ","info_block match to_s  scan ","new_Regexp  new  scan ","old_content match to_s  scan sort ","old_Regexp  new  scan sort ","old_content match to_s  scan ","old_Regexp  new  scan ","encoding_Regexp  new  + + ","old_content match to_s  + + ","Regexp  new _header + + ","encoding_Regexp  new  + ","old_content match to_s  + ","Regexp  new _header + ","File  read  rstrip + + ","File  read  rstrip + ","File  read  rstrip ","encoding_Regexp  new  + + + ","old_content match to_s  + + + ","Regexp  new _header + + + ","old_content sub  end_with? ","magic_comments join + + +  end_with? ","magic_comments join +  end_with? ","magic_comments_block + + +  end_with? ","magic_comments_block +  end_with? ","old_content scan flatten compact  join + + + ","old_content scan flatten compact  join + + ","old_content scan flatten compact  join + ","old_content scan flatten compact  join ","File  read  scan flatten compact ","File  read  scan flatten ","File  read  scan ","old_content scan flatten compact _block + + + "," magic_comments_as_string  + + + ","old_content scan flatten compact _block + + "," magic_comments_as_string  + + ","old_content scan flatten compact _block + "," magic_comments_as_string  + ","File  read  gsub! "," Regexp  new  "," old_content scan flatten compact _as_string ","old_annotation match  [] + + ","old_annotation match  [] ","old_annotation match  [] + ","old_content match to_s  match ","old_content scan flatten compact _block + + + + "," magic_comments_as_string  + + + + ","old_content scan flatten compact _block empty? "," magic_comments_as_string  empty? ","old_content match to_s  empty? ","File  read  lstrip "]}," AnnotateModels get_index_info":{"type":"method","name":"get_index_info","children":[],"call":["index_info << "," sprintf rstrip + "," sprintf rstrip "," sprintf ","index unique ","index columns join ","index columns ","index name ","indexes each ","(send\n  (lvar :indexes) :collect) max + ","(send\n  (lvar :indexes) :collect) max ","index name size ","indexes collect ","indexes empty? ","klass connection indexes ","klass table_name ","klass connection ","(send\n  (lvar :indexes) :sort_by) each ","indexes sort_by ","options [] ","indexes sort_by each "," Array join "," Array "," retrieve_indexes_from_table "," final_index_string "," final_index_string_in_markdown ","klass connection indexes  each "," retrieve_indexes_from_table  each ","(send\n  (lvar :klass connection indexes ) :collect) max + ","(send\n  (lvar : retrieve_indexes_from_table ) :collect) max + ","(send\n  (lvar :klass connection indexes ) :collect) max ","(send\n  (lvar : retrieve_indexes_from_table ) :collect) max ","klass connection indexes  collect "," retrieve_indexes_from_table  collect ","klass connection indexes  empty? "," retrieve_indexes_from_table  empty? ","klass connection klass connection indexes  ","klass connection  retrieve_indexes_from_table  ","(send\n  (lvar :klass connection indexes ) :sort_by) each ","(send\n  (lvar : retrieve_indexes_from_table ) :sort_by) each ","klass connection indexes  sort_by "," retrieve_indexes_from_table  sort_by ","klass connection indexes  sort_by each "," retrieve_indexes_from_table  sort_by each "," retrieve_klass connection indexes _from_table "," retrieve_ retrieve_indexes_from_table _from_table "]}," AnnotateModels get_schema_info":{"type":"method","name":"get_schema_info","children":[],"call":["info << "," get_index_info ","options [] "," sprintf rstrip + "," sprintf rstrip "," sprintf ","attrs join ","col name ","attrs << ","ind join ","ind length == ","ind length ","i == ","ind columns reject! ","ind columns ","indices each ","ind columns include? ","indices select ","klass connection indexes ","klass table_name ","klass connection ","col srid ","col geometry_type ","col respond_to? ","col_type << ","col limit ","col scale ","col precision ","col_type == ","col type to_s ","col type ","col name == ","klass primary_key ","col null "," quote ","col default ","col default nil? ","klass columns each ","klass columns ","(send\n  (send\n    (lvar :klass) :column_names) :collect) max + ","(send\n  (send\n    (lvar :klass) :column_names) :collect) max ","name size ","klass column_names collect ","klass column_names ","klass table_exists? "," sprintf + ","attrs join rstrip ","attrs unshift join ","attrs unshift ","NO_LIMIT_COL_TYPES  include? ","(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s ","col sql_type ","col name to_sym == ","klass primary_key to_sym ","col name to_sym ","cols each ","cols sort_by ","- * ","max_size + ","(send\n  (send\n    (lvar :klass) :column_names) :map) max ","klass column_names map ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send\n  (lvar :md_type_allowance) :-\n  (int 2)) - ","col_type length ","md_type_allowance - ","max_size - ","col name length ","col geometric_type to_s downcase ","col geometric_type to_s ","col geometric_type ","col geometric_type present? ","col limit join ","col limit is_a? ","col_type != ","(send\n  (send\n    (lvar :klass) :primary_key) :collect) include? ","c to_sym ","klass primary_key collect ","klass primary_key is_a? ","col name match ","cols reject! "," get_foreign_key_info ","(send\n  (lvar :indices) :sort_by) each ","ind name ","indices sort_by ","col array "," schema_default "," classified_sort ","(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s "," hide_limit? ","klass columns reject ","ind empty? ","indices sort_by each ","klass primary_key collect include? ","NO_DEFAULT_COL_TYPES  include? ","klass column_names map max "," get_schema_footer_text ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","col_name length ","col comment ","ind columns is_a? "," retrieve_indexes_from_table ","col unsigned? "," hide_default? ","(send\n  (send\n    (lvar :klass) :columns) :map) max ","col name size + ","col comment size ","col name size ","klass columns map ","klass columns first respond_to? ","klass columns first "," get_schema_header_text "," with_comments? "," get_col_type "," max_schema_info_width "," format_default ","max_size - - "," non_ascii_length "," map_col_type_to_ruby_classes ","options [] ! ","(str \"spatial\") include? ! ","(str \"spatial\") include? "," columns ","col comment gsub "," get_attributes "," get_attributes  join "," get_attributes  << ","klass connection indexes  each "," retrieve_indexes_from_table  each ","klass connection indexes  select "," retrieve_indexes_from_table  select ","col type to_s  << ","(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s  << ","(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s  << "," get_col_type  << ","col type to_s  == ","(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s  == ","(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s  == "," get_col_type  == "," get_attributes  join rstrip "," get_attributes  unshift join "," get_attributes  unshift ","cols sort_by  each ","klass columns  each "," classified_sort  each "," columns  each ","cols sort_by  sort_by ","klass columns  sort_by "," classified_sort  sort_by "," columns  sort_by ","(send\n  (send\n    (lvar :klass) :column_names) :collect) max +  + "," max_schema_info_width  + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col type to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar : get_col_type )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :(send\n  (lvar :md_type_allowance) :-\n  (int 2)) - ))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar : get_attributes ) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col type to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar : get_col_type )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :(send\n  (lvar :md_type_allowance) :-\n  (int 2)) - ))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar : get_attributes ) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col type to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar : get_col_type )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :(send\n  (lvar :md_type_allowance) :-\n  (int 2)) - ))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (send\n    (lvar :col) :name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar : get_attributes ) :join\n      (str \", \")) :rstrip)) gsub ","col type to_s  length ","(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s  length ","(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s  length "," get_col_type  length ","(send\n  (send\n    (lvar :klass) :column_names) :collect) max +  - "," max_schema_info_width  - ","col type to_s  != ","(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s  != ","(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s  != "," get_col_type  != ","cols sort_by  reject! ","klass columns  reject! "," classified_sort  reject! "," columns  reject! ","(send\n  (lvar :klass connection indexes ) :sort_by) each ","(send\n  (lvar : retrieve_indexes_from_table ) :sort_by) each ","klass connection indexes  sort_by "," retrieve_indexes_from_table  sort_by ","klass connection indexes  sort_by each "," retrieve_indexes_from_table  sort_by each ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col type to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar : get_col_type )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :(send\n  (lvar :md_type_allowance) :-\n  (int 2)) - ))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col name )\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar : get_attributes ) :join\n      (str \", \")) :rstrip)) gsub rstrip + ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col type to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar : get_col_type )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :(send\n  (lvar :md_type_allowance) :-\n  (int 2)) - ))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col name )\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar : get_attributes ) :join\n      (str \", \")) :rstrip)) gsub rstrip ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col type to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar : get_col_type )\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :(send\n  (lvar :md_type_allowance) :-\n  (int 2)) - ))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :max_size - - ))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col name )\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar :attrs) :join\n      (str \", \")) :rstrip)) gsub ","(send nil :sprintf\n  (dstr\n    (str \"# **`%s`**%\")\n    (begin\n      (lvar :name_remainder))\n    (str \"s | `%s`%\")\n    (begin\n      (lvar :type_remainder))\n    (str \"s | `%s`\"))\n  (lvar :col_name)\n  (str \" \")\n  (lvar :col_type)\n  (str \" \")\n  (send\n    (send\n      (lvar : get_attributes ) :join\n      (str \", \")) :rstrip)) gsub ","col name  length "," get_col type to_s  "," get_(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s  "," get_(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s  "," get_ get_col_type  ","(send\n  (send\n    (lvar :klass) :column_names) :collect) max +  - - "," max_schema_info_width  - - "," map_col type to_s _to_ruby_classes "," map_(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s _to_ruby_classes "," map_(or\n  (send\n    (lvar :col) :sql_type)\n  (send\n    (lvar :col) :type)) to_s _to_ruby_classes "," map_ get_col_type _to_ruby_classes "," map_col_type_to_ map_col_type_to_ruby_classes es "]}," AnnotateModels quote":{"type":"method","name":"quote","children":[],"call":["value inspect ","value to_s "," quote ","value map "]}," AnnotateModels model_dir=":{"type":"method","name":"model_dir=","children":[],"call":[]}," AnnotateModels model_dir":{"type":"method","name":"model_dir","children":[],"call":["@model_dir is_a? "]}," AnnotateModels Generators InstallGenerator copy_tasks":{"type":"method","name":"copy_tasks","children":[],"call":[" template "]}," AnnotateModels find_test_file":{"type":"method","name":"find_test_file","children":[],"call":["File  join ","Dir  glob first ","Dir  glob "]}," AnnotateModels annotate_model_file":{"type":"method","name":"annotate_model_file","children":[],"call":[" puts ","\t + ","e backtrace join ","e backtrace ","options [] ","e message ","annotated << "," annotate ","klass abstract_class? ! ","klass abstract_class? ","klass < "," get_model_class ","klass table_exists? ","File  read ","File  exist? ","annotated concat ","(and\n  (send\n    (send\n      (lvar :klass) :superclass) :<\n    (const\n      (const nil :ActiveRecord) :Base))\n  (send\n    (send\n      (lvar :klass) :table_name) :==\n    (send\n      (send\n        (lvar :klass) :superclass) :table_name))) ! ","klass table_name == ","klass superclass table_name ","klass superclass ","klass table_name ","klass superclass < ","options [] ! ","$stderr puts ","(begin\n  (const nil :SKIP_ANNOTATION_PREFIX)) =~ ","klass is_a? "," get_model_class  abstract_class? ! "," get_model_class  abstract_class? "," get_model_class  < "," get_model_class  table_exists? ","(and\n  (send\n    (send\n      (lvar : get_model_class ) :superclass) :<\n    (const\n      (const nil :ActiveRecord) :Base))\n  (send\n    (send\n      (lvar : get_model_class ) :table_name) :==\n    (send\n      (send\n        (lvar : get_model_class ) :superclass) :table_name))) ! "," get_model_class  table_name == "," get_model_class  superclass table_name "," get_model_class  superclass "," get_model_class  table_name "," get_model_class  superclass < "," get_model_class  is_a? "]}," AnnotateModels get_loaded_model":{"type":"method","name":"get_loaded_model","children":[],"call":["ActiveSupport Inflector  underscore == ","ActiveSupport Inflector  underscore ","(send\n  (send\n    (const nil :ObjectSpace) :each_object\n    (const\n      (cbase) :Class)) :select) detect ","c ancestors include? ","c ancestors ","c ancestors respond_to? ","Class  === ","ObjectSpace  each_object select ","ObjectSpace  each_object ","(send\n  (send\n    (const nil :ObjectSpace) :each_object) :select) detect ","c is_a? ","c to_s ","ActiveSupport Inflector  constantize ","ActiveSupport Inflector  camelize ","loaded_model nil? ! ","loaded_model nil? ","(send\n  (lvar :model_paths) :map) find "," get_loaded_model_by_path ","model_paths map ","absolute_file sub sub sub ","absolute_file sub sub ","absolute_file sub ","(send\n  (gvar :$LOAD_PATH) :select) map ","absolute_file include? ","$LOAD_PATH select ","File  expand_path ","(send\n  (send\n    (gvar :$LOAD_PATH) :map\n    (block-pass\n      (sym :to_s))) :select) map ","$LOAD_PATH map select ","$LOAD_PATH map "," skip_subdirectory_model_load ","File  expand_path  sub sub sub ","File  expand_path  sub sub ","File  expand_path  sub ","File  expand_path  include? "]}," Annotate Generators InstallGenerator copy_tasks":{"type":"method","name":"copy_tasks","children":[],"call":[" template "]}," Annotate true?":{"type":"method","name":"true?","children":[],"call":[]}," Annotate fallback":{"type":"method","name":"fallback","children":[],"call":[]}," Annotate bootstrap_rake":{"type":"method","name":"bootstrap_rake","children":[],"call":[]}," Annotate eager_load":{"type":"method","name":"eager_load","children":[],"call":[]}," Annotate load_requires":{"type":"method","name":"load_requires","children":[],"call":[" require ","options [] each ","options [] ","options [] count > ","options [] count "]}," Annotate loaded_tasks":{"type":"method","name":"loaded_tasks","children":[],"call":[]}," Annotate loaded_tasks=":{"type":"method","name":"loaded_tasks=","children":[],"call":[]}," Annotate skip_on_migration?":{"type":"method","name":"skip_on_migration?","children":[],"call":[]}," Annotate setup_options":{"type":"method","name":"setup_options","children":[],"call":[]}," Annotate set_defaults":{"type":"method","name":"set_defaults","children":[],"call":[]}," AnnotateRoutes strip_on_removal":{"type":"method","name":"strip_on_removal","children":[],"call":["content pop ","content last == ","content last ","where_header_found == ","content shift ","content first == ","content first ","content << ","header_position == "]}," AnnotateRoutes strip_annotations":{"type":"method","name":"strip_annotations","children":[],"call":[" where_header_found ","real_content << ","line_number + ","line =~ ","mode == ","line blank? ","line !~ ","content split each_with_index ","content split "," real_content_and_header_position "," real_content_and_line_number +  "]}," AnnotateRoutes write_contents":{"type":"method","name":"write_contents","children":[],"call":[]}," AnnotateRoutes routes_exists?":{"type":"method","name":"routes_exists?","children":[],"call":[" puts ","File  exists? "," routes_file "]}," AnnotateRoutes routes_file":{"type":"method","name":"routes_file","children":[],"call":["File  join "]}," AnnotateRoutes remove_annotations":{"type":"method","name":"remove_annotations","children":[],"call":[" puts "," routes_file "," write_contents "," strip_on_removal "," strip_annotations ","File  read "," routes_exists? "," rewrite_contents ","new_content join "," routes_file_exist? ","Helpers  strip_annotations "," write_ strip_on_removal s "," rewrite_ strip_on_removal s ","new_ strip_on_removal  join "," strip_on_removal  join "]}," AnnotateRoutes do_annotations":{"type":"method","name":"do_annotations","children":[],"call":[" puts "," routes_file "," write_contents "," header ","File  read "," routes_exists? "," rewrite_contents_with_header "," rewrite_contents ","new_content join "," annotate_routes "," strip_annotations "," routes_file_exist? ","Helpers  strip_annotations ","HeaderGenerator  generate "," annotate_routes  join "]}," AnnotateModels resolve_filename":{"type":"method","name":"resolve_filename","children":[],"call":["filename_template gsub gsub ","model_name pluralize ","filename_template gsub ","filename_template gsub gsub gsub "]}," AnnotateModels classified_sort":{"type":"method","name":"classified_sort","children":[],"call":["(send\n  (send\n    (send\n      (array\n        (lvar :id)) :<<\n      (lvar :rest_cols)) :<<\n    (lvar :timestamps)) :<<\n  (lvar :associations)) flatten ","(lvar :id) << << << ","(lvar :id) << << ","(lvar :id) << ","a sort_by! ","(lvar :rest_cols) each ","rest_cols << ","associations << ","c name [] eql? ","c name [] ","c name ","timestamps << ","c name eql? ","cols each ","(send\n  (send\n    (send\n      (array\n        (lvar :id)) :<<\n      (lvar :rest_cols)) :<<\n    (lvar :timestamps)) :<<\n  (lvar :associations)) flatten compact "]}," AnnotateModels get_foreign_key_info":{"type":"method","name":"get_foreign_key_info","children":[],"call":["fk_info << "," sprintf rstrip + "," sprintf rstrip "," sprintf ","fk name ","options [] ","fk primary_key ","fk to_table ","fk column ","(send\n  (lvar :foreign_keys) :sort_by) each ","foreign_keys sort_by ","(send\n  (lvar :foreign_keys) :collect) max + ","(send\n  (lvar :foreign_keys) :collect) max ","fk name size ","foreign_keys collect ","foreign_keys empty? ","klass connection foreign_keys ","klass table_name ","klass connection ","klass connection respond_to? ","klass connection supports_foreign_keys? ","constraints_info blank? ","constraints_info strip! ","fk on_update ","fk on_delete ","foreign_keys sort_by each ","format_name call ","foreign_keys map map max + ","foreign_keys map map max ","foreign_keys map map ","foreign_keys map ","fk name gsub "," lambda ","fk options [] ","fk options ","fk name blank? ","(send\n  (lvar :klass connection foreign_keys ) :sort_by) each ","klass connection foreign_keys  sort_by ","(send\n  (lvar :klass connection foreign_keys ) :collect) max + ","(send\n  (lvar :klass connection foreign_keys ) :collect) max ","klass connection foreign_keys  collect ","klass connection foreign_keys  empty? ","klass connection klass connection foreign_keys  ","klass connection supports_klass connection foreign_keys ? ","klass connection foreign_keys  sort_by each ","klass connection foreign_keys  map map max + ","klass connection foreign_keys  map map max ","klass connection foreign_keys  map map ","klass connection foreign_keys  map "]}," AnnotateModels schema_default":{"type":"method","name":"schema_default","children":[],"call":[" quote ","klass column_defaults [] ","column name ","klass column_defaults ","(send\n  (send\n    (lvar :klass) :columns) :find) try ","x name to_s == ","column name to_s ","x name to_s ","x name ","klass columns find ","klass columns "]}," Annotate include_models?":{"type":"method","name":"include_models?","children":[],"call":[]}," Annotate include_routes?":{"type":"method","name":"include_routes?","children":[],"call":[]}," Annotate reset_options":{"type":"method","name":"reset_options","children":[],"call":[]}," AnnotateModels BadModelFileError to_s":{"type":"method","name":"to_s","children":[],"call":[]}," AnnotateModels silence_warnings":{"type":"method","name":"silence_warnings","children":[],"call":[]}," AnnotateModels hide_limit?":{"type":"method","name":"hide_limit?","children":[],"call":["excludes include? ","options [] split ","options [] ","options [] blank? ","options [] split  include? "]}," AnnotateModels get_patterns":{"type":"method","name":"get_patterns","children":[],"call":["p sub ","current_patterns map ","File  join "," Array each "," Array "," root_dir each "," root_dir "," files_by_pattern ","patterns map ","pattern_type to_sym == ","pattern_type to_sym ","FilePatterns  generate ","current_ files_by_pattern  map ","current_FilePatterns  generate  map "," files_by_pattern  map ","FilePatterns  generate  map "]}," AnnotateModels root_dir=":{"type":"method","name":"root_dir=","children":[],"call":[]}," AnnotateModels root_dir":{"type":"method","name":"root_dir","children":[],"call":["@root_dir is_a? ","@root_dir split ","@root_dir blank? "]}," AnnotateRoutes where_header_found":{"type":"method","name":"where_header_found","children":[],"call":["header_found_at >= ","real_content count ","header_found_at == "]}," AnnotateRoutes annotate_routes":{"type":"method","name":"annotate_routes","children":[],"call":["magic_comments_map + + ","magic_comments_map + ","content shift ","content first == ","content first ","where_header_found == ","content << ","content last == ","content last ","magic_comments_map << ","magic_comments_map any? ","header << ","content first != ","(str \"before\") include? ","options [] "," extract_magic_comments_from_array ","new_content << ","new_content last == ","new_content last ","header_position == ","Helpers  extract_magic_comments_from_array ","where_header << _found == ","header <<  << ","magic_comments_map + +  << ","magic_comments_map + +  last == ","magic_comments_map + +  last ","header << _position == "]}," AnnotateRoutes app_routes_map":{"type":"method","name":"app_routes_map","children":[],"call":["line =~ ","options [] ","routes_map reject! ","routes_map shift ","routes_map first =~ ","routes_map first ","(str \"rake routes\") chomp split ","(str \"rake routes\") chomp ","(str \"rake routes\") chomp split  reject! ","(str \"rake routes\") chomp split  shift ","(str \"rake routes\") chomp split  first =~ ","(str \"rake routes\") chomp split  first "]}," AnnotateModels parse_options":{"type":"method","name":"parse_options","children":[],"call":[" root_dir= ","options [] "," model_dir= "," split_model_dir "," skip_subdirectory_model_load= ","options [] present? "]}," AnnotateModels matched_types":{"type":"method","name":"matched_types","children":[],"call":["types << ","types include? ! ","types include? ","options [] =~ ","options [] ","options [] present? ","MATCHED_TYPES  dup ","MATCHED_TYPES  dup  << ","MATCHED_TYPES  dup  include? ! ","MATCHED_TYPES  dup  include? "]}," AnnotateModels files_by_pattern":{"type":"method","name":"files_by_pattern","children":[],"call":["File  join "," serialize_files "," factory_files "," scaffold_files "," fixture_files "," test_files ","(or\n  (send\n    (lvar :options) :[]\n    (sym :additional_file_patterns))\n  (array)) flatten ","options [] "]}," AnnotateModels serialize_files":{"type":"method","name":"serialize_files","children":[],"call":["File  join "]}," AnnotateModels factory_files":{"type":"method","name":"factory_files","children":[],"call":["File  join "]}," AnnotateModels scaffold_files":{"type":"method","name":"scaffold_files","children":[],"call":["File  join "]}," AnnotateModels fixture_files":{"type":"method","name":"fixture_files","children":[],"call":["File  join "]}," AnnotateModels test_files":{"type":"method","name":"test_files","children":[],"call":["File  join "]}," AnnotateModels annotate_pattern":{"type":"method","name":"annotate_pattern","children":[],"call":["options [] "]}," Annotate all_options":{"type":"method","name":"all_options","children":[],"call":[]}," AnnotateRoutes header":{"type":"method","name":"header","children":[],"call":["out + "," content ","line split ","options [] ","routes_map [] map ","routes_map [] ","- * ","maxs map compact max ","maxs map compact ","maxs map ","(send\n  (const nil :HEADER_ROW) :map\n  (block-pass\n    (sym :size))) + ","line split map ","HEADER_ROW  map ","routes_map size zero? ","routes_map size ","(str \"# \") + ","Time  now strftime ","Time  now "," app_routes_map ","out << ","magic_comments_map any? ","magic_comments_map each "," extract_magic_comments_from_array "," comment "," comment + ","Helpers  extract_magic_comments_from_array "," app_routes_map  [] map "," app_routes_map  [] ","maxs map compact max s map compact maxs map compact max  ","(send\n  (const nil :HEADER_ROW) :map\n  (block-pass\n    (sym :size))) +  map compact max ","maxs map compact max s map compact ","(send\n  (const nil :HEADER_ROW) :map\n  (block-pass\n    (sym :size))) +  map compact ","maxs map compact max s map ","(send\n  (const nil :HEADER_ROW) :map\n  (block-pass\n    (sym :size))) +  map "," app_routes_map  size zero? "," app_routes_map  size "," app_ app_routes_map  "]}," AnnotateRoutes content":{"type":"method","name":"content","children":[],"call":["(send\n  (send\n    (lvar :line) :each_with_index) :map) join "," sprintf ","elem tr ","(send\n  (lvar :maxs) :map) max ","arr [] ","maxs map ","line each_with_index map ","line each_with_index ","line rstrip ","options [] "]}," AnnotateModels hide_default?":{"type":"method","name":"hide_default?","children":[],"call":["excludes include? ","options [] split ","options [] ","options [] blank? ","options [] split  include? "]}," AnnotateModels get_schema_footer_text":{"type":"method","name":"get_schema_footer_text","children":[],"call":["info << ","options [] "]}," AnnotateModels get_schema_header_text":{"type":"method","name":"get_schema_header_text","children":[],"call":["info << ","klass table_name ","options [] "]}," AnnotateModels retrieve_indexes_from_table":{"type":"method","name":"retrieve_indexes_from_table","children":[],"call":["klass connection indexes ","klass connection ","table_name to_s slice! ","klass table_name_prefix ","table_name to_s ","klass table_name_prefix ! ","indexes any? ","klass table_name ","table_name to_s sub ","klass connection klass connection indexes  ","klass table_name  to_s slice! ","klass klass table_name _prefix ","klass table_name  to_s ","klass klass table_name _prefix ! ","klass connection indexes  any? ","klass klass table_name  ","klass table_name  to_s sub "]}," AnnotateRoutes rewrite_contents_with_header":{"type":"method","name":"rewrite_contents_with_header","children":[],"call":["f puts ","File  open "," routes_file "," puts ","existing_text == ","new_content join ","new_content << ","new_content last == ","new_content last "," annotate_routes "," strip_annotations "," annotate_routes  join "," annotate_routes  << "," annotate_routes  last == "," annotate_routes  last "]}," AnnotateRoutes rewrite_contents":{"type":"method","name":"rewrite_contents","children":[],"call":["f puts ","File  open "," routes_file "," puts ","existing_text == ","new_content join ","new_content << ","new_content last == ","new_content last "]}," AnnotateRoutes extract_magic_comments_from_array":{"type":"method","name":"extract_magic_comments_from_array","children":[],"call":["new_content << ","magic_comments << ","row strip ","row =~ "," magic_comment_matcher ","content_array map ","content_array each "]}," AnnotateRoutes magic_comment_matcher":{"type":"method","name":"magic_comment_matcher","children":[],"call":["Regexp  new "]}," AnnotateModels max_schema_info_width":{"type":"method","name":"max_schema_info_width","children":[],"call":["options [] ","klass column_names map max ","klass column_names map ","klass column_names ","(send\n  (send\n    (lvar :klass) :columns) :map) max ","column name size + ","column comment size ","column comment ","column name size ","column name ","klass columns map ","klass columns "," with_comments? "," width ","cols map map max ","cols map map ","cols map ","(send\n  (lvar :cols) :map) max "," columns "," columns  map map max "," columns  map map "," columns  map ","(send\n  (lvar : columns ) :map) max "]}," AnnotateModels with_comments?":{"type":"method","name":"with_comments?","children":[],"call":["col comment nil? ! ","col comment nil? ","col comment ","klass columns any? ","klass columns ","klass columns first respond_to? ","klass columns first ","options [] "]}," AnnotateModels split_model_dir":{"type":"method","name":"split_model_dir","children":[],"call":["option_value map reject ","option_value map ","option_value split ","option_value is_a? ","option_value split  map reject ","option_value split  map ","option_value split  split ","option_value split  is_a? "]}," AnnotateModels get_loaded_model_by_path":{"type":"method","name":"get_loaded_model_by_path","children":[],"call":["ActiveSupport Inflector  underscore == ","ActiveSupport Inflector  underscore ","c to_s ","(send\n  (send\n    (const nil :ObjectSpace) :each_object\n    (const\n      (cbase) :Class)) :select) detect ","c ancestors include? ","c ancestors ","c ancestors respond_to? ","Class  === ","ObjectSpace  each_object select ","ObjectSpace  each_object ","ActiveSupport Inflector  constantize ","ActiveSupport Inflector  camelize "]}," AnnotateModels list_model_files_from_argument":{"type":"method","name":"list_model_files_from_argument","children":[],"call":[" exit "," puts "," model_dir join "," model_dir ","model_files size != ","specified_files size ","model_files size ","file sub ","(send\n  (lvar :specified_files) :find_all) map ","file start_with? ","specified_files find_all ","File  expand_path "," model_dir flat_map ","ARGV  map ","ARGV  empty? "]}," AnnotateModels magic_comments_as_string":{"type":"method","name":"magic_comments_as_string","children":[],"call":["magic_comments join + ","magic_comments join ","magic_comments any? ","content scan flatten compact ","content scan flatten ","content scan "," magic_comment_matcher ","content scan flatten compact  join + ","content scan flatten compact  join ","content scan flatten compact  any? "]}," AnnotateModels magic_comment_matcher":{"type":"method","name":"magic_comment_matcher","children":[],"call":["Regexp  new "]}," AnnotateModels final_index_string":{"type":"method","name":"final_index_string","children":[],"call":[" sprintf rstrip + "," sprintf rstrip "," sprintf "," index_using_info "," index_where_info "," index_unique_info "," index_columns_info join "," index_columns_info ","index name "]}," AnnotateModels final_index_string_in_markdown":{"type":"method","name":"final_index_string_in_markdown","children":[],"call":[" sprintf "," index_columns_info join "," index_columns_info ","index name ","details blank? "," sprintf strip "," index_using_info "," index_where_info "," index_unique_info "," sprintf strip  blank? "]}," AnnotateModels index_using_info":{"type":"method","name":"index_using_info","children":[],"call":["INDEX_CLAUSES  [] [] ","INDEX_CLAUSES  [] ","value != ","value blank? ! ","value blank? ","index using try ","index using ","index try "]}," AnnotateModels index_where_info":{"type":"method","name":"index_where_info","children":[],"call":["INDEX_CLAUSES  [] [] ","INDEX_CLAUSES  [] ","value blank? ","index try try ","index try ","index try try  blank? "]}," AnnotateModels index_unique_info":{"type":"method","name":"index_unique_info","children":[],"call":["INDEX_CLAUSES  [] [] ","INDEX_CLAUSES  [] ","index unique "]}," AnnotateModels index_columns_info":{"type":"method","name":"index_columns_info","children":[],"call":["col to_s gsub gsub ","col to_s gsub ","col to_s ","index orders [] upcase ","index orders [] ","index orders ","index try "," Array map "," Array ","index columns "]}," AnnotateModels get_col_type":{"type":"method","name":"get_col_type","children":[],"call":["(or\n  (send\n    (lvar :col) :type)\n  (send\n    (lvar :col) :sql_type)) to_s ","col sql_type ","col type ","col bigint? ","col respond_to? "]}," AnnotateModels mb_chars_ljust":{"type":"method","name":"mb_chars_ljust","children":[],"call":["string + ","  * ","length - "," width ","string to_s ","string [] ","padding > ","string to_s  + ","string to_s  to_s ","string to_s  [] ","length -  > "]}," AnnotateModels width":{"type":"method","name":"width","children":[],"call":["acc + ","elem bytesize == ","elem bytesize ","string chars inject ","string chars "]}," AnnotateModels format_default":{"type":"method","name":"format_default","children":[],"call":[" sprintf rstrip + "," sprintf rstrip "," sprintf ","attrs join "," mb_chars_ljust "]}," AnnotateModels expand_glob_into_files":{"type":"method","name":"expand_glob_into_files","children":[],"call":["Dir  glob "]}," Annotate Parser default_options":{"type":"method","name":"default_options","children":[],"call":[]}," Annotate Parser add_options_to_parser":{"type":"method","name":"add_options_to_parser","children":[],"call":[" env []= "," env ","option_parser on ","values to_s ","exclusions each "," env [] + "," env [] "," env [] blank? ! "," env [] blank? ","@options []= "," puts ","Annotate  version ","has_set_position []= ","has_set_position [] ","FILE_TYPE_POSITIONS  each ","ENV  []= ","option_parser banner= "," env [] present? "]}," Annotate Parser parser":{"type":"method","name":"parser","children":[],"call":[" add_options_to_parser ","OptionParser  new "]}," Annotate Parser commit":{"type":"method","name":"commit","children":[],"call":["ENV  []= "," env each_pair "," env "]}," Annotate Parser parse":{"type":"method","name":"parse","children":[],"call":[" options "," commit "," parser parse! "," args "," parser "]}," Annotate Parser initialize":{"type":"method","name":"initialize","children":[],"call":[" default_options ","DEFAULT_OPTIONS  dup "]}," Annotate Helpers reset_options":{"type":"method","name":"reset_options","children":[],"call":["ENV  []= ","key to_s ","options flatten each ","options flatten "]}," Annotate Helpers fallback":{"type":"method","name":"fallback","children":[],"call":["args detect "]}," Annotate Helpers true?":{"type":"method","name":"true?","children":[],"call":["Constants TRUE_RE  match? ","val present? "]}," Annotate Helpers include_models?":{"type":"method","name":"include_models?","children":[],"call":["ENV  [] =~ ","ENV  [] "]}," Annotate Helpers include_routes?":{"type":"method","name":"include_routes?","children":[],"call":["ENV  [] =~ ","ENV  [] "]}," Annotate Helpers skip_on_migration?":{"type":"method","name":"skip_on_migration?","children":[],"call":["ENV  [] =~ ","ENV  [] "]}," AnnotateRoutes real_content_and_header_position":{"type":"method","name":"real_content_and_header_position","children":[],"call":["header_position >= ","real_content count ","header_position == "]}," AnnotateRoutes comment":{"type":"method","name":"comment","children":[],"call":["row == "]}," AnnotateRoutes routes_file_exist?":{"type":"method","name":"routes_file_exist?","children":[],"call":["File  exist? "," routes_file "]}," AnnotateModels ignored_translation_table_colums":{"type":"method","name":"ignored_translation_table_colums","children":[],"call":["(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :klass) :translation_class) :to_s) :gsub\n      (str \"::Translation\")\n      (str \"\")) :gsub\n    (str \"::\")\n    (str \"_\")) :downcase) join to_sym ","(send\n  (send\n    (send\n      (send\n        (send\n          (lvar :klass) :translation_class) :to_s) :gsub\n      (str \"::Translation\")\n      (str \"\")) :gsub\n    (str \"::\")\n    (str \"_\")) :downcase) join ","klass translation_class to_s gsub gsub downcase ","klass translation_class to_s gsub gsub ","klass translation_class to_s gsub ","klass translation_class to_s ","klass translation_class ","(send\n  (send\n    (send\n      (lvar :klass) :table_name) :to_s) :singularize) join to_sym ","(send\n  (send\n    (send\n      (lvar :klass) :table_name) :to_s) :singularize) join ","klass table_name to_s singularize ","klass table_name to_s ","klass table_name "]}," AnnotateModels translated_columns":{"type":"method","name":"translated_columns","children":[],"call":["ignored_cols include? ","col name to_sym ","col name ","klass translation_class columns reject ","klass translation_class columns ","klass translation_class "," ignored_translation_table_colums ","klass respond_to? "," ignored_translation_table_colums  include? "]}," AnnotateModels columns":{"type":"method","name":"columns","children":[],"call":[" classified_sort ","options [] ","cols sort_by ","col name match ","col name ","cols reject "," translated_columns ","klass columns "," classified_sort  sort_by ","cols sort_by  sort_by ","klass columns  sort_by "," classified_sort  reject ","cols sort_by  reject ","klass columns  reject "]}," AnnotateModels map_col_type_to_ruby_classes":{"type":"method","name":"map_col_type_to_ruby_classes","children":[],"call":["Hash  to_s ","String  to_s ","Date  to_s ","Time  to_s ","BigDecimal  to_s ","Float  to_s ","Integer  to_s "]}," AnnotateModels non_ascii_length":{"type":"method","name":"non_ascii_length","children":[],"call":["string to_s chars reject length ","string to_s chars reject ","string to_s chars ","string to_s "]}," AnnotateRoutes Helpers real_content_and_header_position":{"type":"method","name":"real_content_and_header_position","children":[],"call":["header_position >= ","real_content count ","header_position == "]}," AnnotateRoutes Helpers extract_magic_comments_from_array":{"type":"method","name":"extract_magic_comments_from_array","children":[],"call":["new_content << ","magic_comments << ","row strip ","row =~ ","content_array each "]}," AnnotateRoutes Helpers strip_annotations":{"type":"method","name":"strip_annotations","children":[],"call":[" real_content_and_header_position ","real_content << ","line_number + ","line =~ ","mode == ","line blank? ","line !~ ","content split each_with_index ","content split "," real_content_and_line_number +  "]}," AnnotateRoutes HeaderGenerator timestamp_if_required":{"type":"method","name":"timestamp_if_required","children":[],"call":["time strftime "," options [] "," options "]}," AnnotateRoutes HeaderGenerator markdown?":{"type":"method","name":"markdown?","children":[],"call":[" options [] "," options "]}," AnnotateRoutes HeaderGenerator format_line_element":{"type":"method","name":"format_line_element","children":[],"call":[" format ","elem tr ","(send\n  (lvar :maxs) :map) max ","arr [] ","maxs map "]}," AnnotateRoutes HeaderGenerator content":{"type":"method","name":"content","children":[],"call":["(send\n  (send\n    (lvar :line) :each_with_index) :map) join "," format_line_element ","line each_with_index map ","line each_with_index ","line rstrip "," markdown? "]}," AnnotateRoutes HeaderGenerator comment":{"type":"method","name":"comment","children":[],"call":["row == "]}," AnnotateRoutes HeaderGenerator generate":{"type":"method","name":"generate","children":[],"call":["out << "," comment "," options [] "," options "," content ","line split "," markdown? ","contents_without_magic_comments [] map ","contents_without_magic_comments [] ","- * ","maxs map compact max ","maxs map compact ","maxs map ","(send\n  (const nil :HEADER_ROW) :map\n  (block-pass\n    (sym :size))) + ","line split map ","HEADER_ROW  map ","contents_without_magic_comments size zero? ","contents_without_magic_comments size "," comment + "," timestamp_if_required ","magic_comments_map any? ","magic_comments_map each ","Helpers  extract_magic_comments_from_array "," routes_map "," new generate "," new ","maxs map compact max s map compact maxs map compact max  ","(send\n  (const nil :HEADER_ROW) :map\n  (block-pass\n    (sym :size))) +  map compact max ","maxs map compact max s map compact ","(send\n  (const nil :HEADER_ROW) :map\n  (block-pass\n    (sym :size))) +  map compact ","maxs map compact max s map ","(send\n  (const nil :HEADER_ROW) :map\n  (block-pass\n    (sym :size))) +  map "]}," AnnotateRoutes HeaderGenerator initialize":{"type":"method","name":"initialize","children":[],"call":[]}," AnnotateRoutes HeaderGenerator routes_map":{"type":"method","name":"routes_map","children":[],"call":["line =~ ","result reject ","options [] ","result shift ","result first =~ ","result first ","(str \"rake routes\") chomp split ","(str \"rake routes\") chomp ","(str \"rake routes\") chomp split  reject ","(str \"rake routes\") chomp split  shift ","(str \"rake routes\") chomp split  first =~ ","(str \"rake routes\") chomp split  first "]}," AnnotateModels get_attributes":{"type":"method","name":"get_attributes","children":[],"call":["attrs << ","ind join ","ind empty? ","i == ","column name ","ind columns reject! ","ind columns ","ind columns is_a? ","indices sort_by each ","indices sort_by ","ind columns include? ","indices select "," retrieve_indexes_from_table ","klass table_exists? ","options [] ","(send\n  (send\n    (send\n      (lvar :column) :geometric_type) :to_s) :downcase) compact join ","(send\n  (send\n    (send\n      (lvar :column) :geometric_type) :to_s) :downcase) compact ","column try ","column geometric_type to_s downcase ","column geometric_type to_s ","column geometric_type ","column geometric_type present? ","column respond_to? ","(send\n  (lvar :column) :geometry_type) compact join ","(send\n  (lvar :column) :geometry_type) compact ","column geometry_type ","column array ","column_type << ","column limit "," hide_limit? ","column limit join ","column limit is_a? ","options [] ! ","(str \"spatial\") include? ! ","(str \"spatial\") include? ","column scale ","column precision ","column_type == ","column name to_sym == ","klass primary_key to_sym ","klass primary_key ","column name to_sym ","klass primary_key collect include? ","klass primary_key collect ","klass primary_key is_a? ","column null ","column unsigned? "," schema_default "," hide_default? ","column default nil? ","column default "," retrieve_indexes_from_table  sort_by each "," retrieve_indexes_from_table  sort_by "," retrieve_indexes_from_table  select "]}," AnnotateModels skip_subdirectory_model_load":{"type":"method","name":"skip_subdirectory_model_load","children":[],"call":["@skip_subdirectory_model_load blank? "]}," AnnotateModels FilePatterns serialize_files":{"type":"method","name":"serialize_files","children":[],"call":["File  join "]}," AnnotateModels FilePatterns factory_files":{"type":"method","name":"factory_files","children":[],"call":["File  join "]}," AnnotateModels FilePatterns scaffold_files":{"type":"method","name":"scaffold_files","children":[],"call":["File  join "]}," AnnotateModels FilePatterns fixture_files":{"type":"method","name":"fixture_files","children":[],"call":["File  join "]}," AnnotateModels FilePatterns test_files":{"type":"method","name":"test_files","children":[],"call":["File  join "]}," AnnotateModels FilePatterns generate":{"type":"method","name":"generate","children":[],"call":["File  join ","(or\n  (send\n    (lvar :options) :[]\n    (sym :additional_file_patterns))\n  (array)) flatten ","options [] "," serialize_files "," factory_files "," scaffold_files "," fixture_files "," test_files "]}}