{" Whenever bundler?":{"type":"method","name":"bundler?","children":[],"call":[]}," Whenever script_rails?":{"type":"method","name":"script_rails?","children":[],"call":[]}," Whenever bin_rails?":{"type":"method","name":"bin_rails?","children":[],"call":[]}," Whenever path":{"type":"method","name":"path","children":[],"call":[]}," Whenever seconds":{"type":"method","name":"seconds","children":[],"call":[]}," Whenever cron":{"type":"method","name":"cron","children":[],"call":[]}," Whenever Output Redirection redirect_from_string":{"type":"method","name":"redirect_from_string","children":[],"call":[]}," Whenever Output Redirection redirect_from_hash":{"type":"method","name":"redirect_from_hash","children":[],"call":[" stdout "," stdout == "," stderr "," stderr == "]}," Whenever Output Redirection stderr":{"type":"method","name":"stderr","children":[],"call":["@output [] ","@output [] nil? ","@output has_key? "]}," Whenever Output Redirection stdout":{"type":"method","name":"stdout","children":[],"call":["@output [] ","@output [] nil? ","@output has_key? "]}," Whenever Output Redirection to_s":{"type":"method","name":"to_s","children":[],"call":["@output call "," redirect_from_hash "," redirect_from_string "]}," Whenever Output Redirection initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Whenever OS solaris?":{"type":"method","name":"solaris?","children":[],"call":[]}," Whenever NumericSeconds years":{"type":"method","name":"years","children":[],"call":[" number * "," number "]}," Whenever NumericSeconds months":{"type":"method","name":"months","children":[],"call":[" number * "," number "]}," Whenever NumericSeconds weeks":{"type":"method","name":"weeks","children":[],"call":[" number * "," number "]}," Whenever NumericSeconds days":{"type":"method","name":"days","children":[],"call":[" number * "," number "]}," Whenever NumericSeconds hours":{"type":"method","name":"hours","children":[],"call":[" number * "," number "]}," Whenever NumericSeconds minutes":{"type":"method","name":"minutes","children":[],"call":[" number * "," number "]}," Whenever NumericSeconds seconds":{"type":"method","name":"seconds","children":[],"call":[" number "]}," Whenever NumericSeconds initialize":{"type":"method","name":"initialize","children":[],"call":["number to_i "]}," Numeric method_missing":{"type":"method","name":"method_missing","children":[],"call":["Whenever NumericSeconds  new send ","Whenever NumericSeconds  new ","Whenever NumericSeconds  public_method_defined? "]}," Numeric respond_to?":{"type":"method","name":"respond_to?","children":[],"call":["Whenever NumericSeconds  public_method_defined? "]}," Whenever JobList cron_jobs":{"type":"method","name":"cron_jobs","children":[],"call":["output join ","output << ","output_jobs empty? ","output_job empty? ","output_jobs reject! ","output_jobs << "," cron_jobs_of_time ","time_and_jobs each ","@jobs each ","(send\n  (ivar :@jobs) :delete\n  (sym :default_mailto)) each ","Hash  new ","@jobs delete ","@jobs empty? ","shortcut_jobs join + "," combine join "," combine ","shortcut_jobs join ","regular_jobs << ","shortcut_jobs << ","cron starts_with? ","cron << ","job cron_log ","Whenever Output Cron  output ","jobs each ","job has_role? "," roles any? "," roles "," roles empty? ","cron [] == ","cron [] "]}," Whenever JobList cron_jobs_of_time":{"type":"method","name":"cron_jobs_of_time","children":[],"call":["shortcut_jobs join + "," combine join "," combine ","shortcut_jobs join ","regular_jobs << ","shortcut_jobs << ","cron [] == ","cron [] ","cron << ","Whenever Output Cron  output ","job has_role? "," roles any? "," roles "," roles empty? ","jobs each "]}," Whenever JobList combine":{"type":"method","name":"combine","children":[],"call":["entry join ","entries map ","entries delete_at ",", + ","entries [] [] ","entries [] ","comparison == ","entries [] [] + ","f + ","entries [] [] == ","(send\n  (lvar :i) :-\n  (int 1)) downto ","i - ","(send\n  (send\n    (lvar :entries) :length) :-\n  (int 1)) downto ","entries length - ","entries length ","0 upto ","entry split ","entries map! ","entries [] [] +  == "]}," Whenever JobList environment_variables":{"type":"method","name":"environment_variables","children":[],"call":["output join ","output << ","val == ","val nil? ","@env each ","@env empty? ","val blank? "]}," Whenever JobList pre_set":{"type":"method","name":"pre_set","children":[],"call":["@pre_set_variables []= "," set ","value strip ","variable strip to_sym ","variable strip ","value == ","value nil? ","variable == ","variable nil? ","pair split ","pair index ","pairs each ","variable_string split ","variable_string == ","variable_string nil? ","value blank? ","variable blank? ","variable_string blank? ","@pre_set_variable strip to_sym s []= ","variable strip to_sym  strip to_sym ","variable strip to_sym  strip ","variable strip to_sym  == ","variable strip to_sym  nil? ","variable_string split  each ","variable strip to_sym _string split ","variable strip to_sym _string == ","variable strip to_sym _string nil? ","variable strip to_sym  blank? ","variable strip to_sym _string blank? "]}," Whenever JobList generate_cron_output":{"type":"method","name":"generate_cron_output","children":[],"call":["(send nil :environment_variables) compact join ","(send nil :environment_variables) compact "," cron_jobs "," environment_variables "," set_path_environment_variable "]}," Whenever JobList job_type":{"type":"method","name":"job_type","children":[],"call":["@jobs [] [] << ","Whenever Job  new ","@options merge merge ","@options merge ","@jobs [] [] ","@jobs [] ","options fetch ","options []= ","options has_key? ! ","options has_key? ","options [] ","@options fetch ","options merge! ","args [] ","args [] is_a? "," define_method "," singleton_class class_eval "," singleton_class ","@jobs [] << "," class_eval "," singleton_class_shim class_eval "," singleton_class_shim "]}," Whenever JobList every":{"type":"method","name":"every","children":[],"call":[]}," Whenever JobList env":{"type":"method","name":"env","children":[],"call":["@env []= ","variable to_s "]}," Whenever JobList respond_to?":{"type":"method","name":"respond_to?","children":[],"call":[]}," Whenever JobList method_missing":{"type":"method","name":"method_missing","children":[],"call":["@set_variables [] ","@set_variables has_key? "]}," Whenever JobList set":{"type":"method","name":"set","children":[],"call":["@set_variables []= "," instance_variable_set ","(str \"@\") to_sym ","@pre_set_variables [] ","variable to_sym "," class send "," class "," instance_variable_defined? ","@set_variable to_sym s []= "," instance_variable to_sym _set ","@pre_set_variable to_sym s [] ","variable to_sym  to_sym "," instance_variable to_sym _defined? "]}," Whenever JobList initialize":{"type":"method","name":"initialize","children":[],"call":[" instance_eval ","options [] ","File  read ","File  expand_path "," pre_set ","options is_a? "," eval ","Hash  new ","Dir  [] each ","Dir  [] ","File  dirname ","setup + ","Whenever NumericSeconds  process_string ","File  read  + "]}," Whenever Job escape_double_quotes":{"type":"method","name":"escape_double_quotes","children":[],"call":["str gsub "]}," Whenever Job escape_single_quotes":{"type":"method","name":"escape_single_quotes","children":[],"call":["str gsub "]}," Whenever Job process_template":{"type":"method","name":"process_template","children":[],"call":["(send\n  (lvar :template) :gsub\n  (regexp\n    (str \":\\\\w+\")\n    (regopt))) gsub strip ","(send\n  (lvar :template) :gsub\n  (regexp\n    (str \":\\\\w+\")\n    (regopt))) gsub "," escape_double_quotes ","c == ","before_and_after all? "," escape_single_quotes ","options [] ","key sub to_sym ","key sub ","$' [] ","$` [] ","template gsub ","(send\n  (lvar :template) :gsub\n  (regexp\n    (str \":\\\\w+\")\n    (regopt))) squish ","options [] s [] "]}," Whenever Job has_role?":{"type":"method","name":"has_role?","children":[],"call":[" roles include? "," roles "," roles empty? "]}," Whenever Job output":{"type":"method","name":"output","children":[],"call":["out gsub "," process_template ","@options merge ","@options [] ","key sub to_sym ","key sub ","@options [] gsub "," escape_double_quotes ","c == ","before_and_after all? "," escape_single_quotes ","$' [] ","$` [] ","@options [] dup gsub ","@options [] dup "," process_template strip "," raise ","out =~ "," process_template  gsub "," process_template strip  gsub ","@@options [] s merge ","@@options [] s [] ","@@options [] s [] gsub ","@@options [] s [] dup gsub ","@@options [] s [] dup "," process_template  =~ "," process_template strip  =~ "]}," Whenever Job initialize":{"type":"method","name":"initialize","children":[],"call":["@options []= ","Shellwords  shellescape ","Whenever  path ","@options [] ","Whenever Output Redirection  new to_s ","Whenever Output Redirection  new ","options [] ","options has_key? "," Array ","options delete ","options fetch ","Array  wrap "]}," Whenever Output Cron comma_separated_timing":{"type":"method","name":"comma_separated_timing","children":[],"call":["output [] join ","output [] ","original_start zero? ","(send\n  (send\n    (lvar :max) :to_f) :/\n  (begin\n    (send\n      (lvar :frequency) :to_f))) round ","max to_f / ","frequency to_f ","max to_f ","(irange\n  (lvar :start)\n  (lvar :max)) step to_a ","(irange\n  (lvar :start)\n  (lvar :max)) step ","start > ","(send\n  (lvar :max) :+\n  (int 1)) modulo zero? ","(send\n  (lvar :max) :+\n  (int 1)) modulo ","max + ","frequency > ","(send\n  (lvar :max) :*\n  (float 0.5)) ceil ","max * ","frequency == ","frequency zero? ","frequency nil? ","frequency blank? ","(irange\n  (lvar :start)\n  (lvar :max)) step to_a  [] join ","(irange\n  (lvar :start)\n  (lvar :max)) step to_a  [] "]}," Whenever Output Cron parse_as_string":{"type":"method","name":"parse_as_string","children":[],"call":[" raise ","(send\n  (lvar :timing) :<<\n  (lvar :i)) * ","timing << ","string downcase index ","string downcase ","DAYS  each_with_index ","(send\n  (lvar :timing) :<<\n  (str \"6,0\")) * ","(send\n  (lvar :timing) :<<\n  (str \"1-5\")) * ","timing []= ","@at hour ","@at is_a? ","@at min ","Array  new ","@time to_s ","@time inspect ","(str \"sun\") each_with_index ","(send\n  (lvar :Array  new ) :<<\n  (lvar :i)) * ","Array  new  << ","@time to_s  downcase index ","@time to_s  downcase ","(send\n  (lvar :Array  new ) :<<\n  (str \"6,0\")) * ","(send\n  (lvar :Array  new ) :<<\n  (str \"1-5\")) * ","Array  new  []= "]}," Whenever Output Cron parse_time":{"type":"method","name":"parse_time","children":[],"call":["timing join "," parse_as_string "," raise ","timing [] ","(irange\n  (int 1)\n  (int 12)) include? ","timing []= ","@at zero? ","@at month "," day_given? ","@at is_a? ","@at day ","@at hour ","@at min ","Whenever  seconds ","(irange\n  (int 1)\n  (int 31)) include? "," comma_separated_timing ","(send\n  (send\n    (send\n      (send\n        (ivar :@time) :/\n        (int 30)) :/\n      (int 24)) :/\n    (int 60)) :/\n  (int 60)) round ","@time / / / / ","@time / / / ","@time / / ","@time / ","(irange\n  (int 0)\n  (int 23)) include? ","(send\n  (send\n    (send\n      (ivar :@time) :/\n      (int 24)) :/\n    (int 60)) :/\n  (int 60)) round ","(irange\n  (int 0)\n  (int 59)) include? ","(send\n  (send\n    (ivar :@time) :/\n    (int 60)) :/\n  (int 60)) round ","Array  new "," range_or_integer ","@at == ","12 months ","1 month ","1 day ","1 hour ","1 minute ","0 seconds ","Array  new  join ","Array  new  [] ","Array  new  []= "," comma_separated_Array  new  "]}," Whenever Output Cron parse_symbol":{"type":"method","name":"parse_symbol","children":[],"call":[" parse_as_string "," raise ","@at > ","@at is_a? "," parse_time ","shortcut is_a? ","Whenever  seconds ","1 hour ","1 week ","1 month ","1 day ","12 months "]}," Whenever Output Cron day_given?":{"type":"method","name":"day_given?","children":[],"call":["@at_given [] ","@at_given downcase index ","@at_given downcase ","MONTHS  any? ","@at_given is_a? ","months any? "]}," Whenever Output Cron time_in_cron_syntax":{"type":"method","name":"time_in_cron_syntax","children":[],"call":[" parse_time "," parse_as_string "," parse_symbol ","@time to_i ","@time is_a? ","@time to_i  to_i ","@time to_i  is_a? "]}," Whenever Output Cron output":{"type":"method","name":"output","children":[],"call":["(send nil :time_in_cron_syntax) compact join strip ","(send nil :time_in_cron_syntax) compact join ","(send nil :time_in_cron_syntax) compact "," task "," time_in_cron_syntax "," output_redirection "]}," Whenever Output Cron enumerate":{"type":"method","name":"enumerate","children":[],"call":[]}," Whenever Output Cron initialize":{"type":"method","name":"initialize","children":[],"call":["Chronic  parse ","at is_a? ","options [] "]}," Whenever CommandLine timestamp_regex":{"type":"method","name":"timestamp_regex","children":[],"call":[]}," Whenever CommandLine comment_close_regex":{"type":"method","name":"comment_close_regex","children":[],"call":[" timestamp_regex "," comment_close "]}," Whenever CommandLine comment_open_regex":{"type":"method","name":"comment_open_regex","children":[],"call":[" timestamp_regex "," comment_open "]}," Whenever CommandLine comment_close":{"type":"method","name":"comment_close","children":[],"call":[" comment_base "]}," Whenever CommandLine comment_open":{"type":"method","name":"comment_open","children":[],"call":[" comment_base "]}," Whenever CommandLine comment_base":{"type":"method","name":"comment_base","children":[],"call":["@options [] "]}," Whenever CommandLine prepare":{"type":"method","name":"prepare","children":[],"call":["stripped_contents gsub! ","contents split [] join ","contents split [] ","@options [] ","contents split ","stripped_contents split [] join + ","stripped_contents split [] join ","stripped_contents split [] ","stripped_contents split ","contents [] ","stripped_contents length ","contents strip ","contents split [] join  gsub! ","contents strip  gsub! ","contents split [] join  split [] join + ","contents strip  split [] join + ","contents split [] join  split [] join ","contents strip  split [] join ","contents split [] join  split [] ","contents strip  split [] ","contents split [] join  split ","contents strip  split ","contents split [] join  length ","contents strip  length "]}," Whenever CommandLine updated_crontab":{"type":"method","name":"updated_crontab","children":[],"call":["(and\n  (send\n    (send nil :read_crontab) :=~\n    (send\n      (const nil :Regexp) :new\n      (dstr\n        (str \"^\")\n        (begin\n          (send nil :comment_open_regex))\n        (str \" *$\"))))\n  (send\n    (send nil :read_crontab) :=~\n    (send\n      (const nil :Regexp) :new\n      (dstr\n        (str \"^\")\n        (begin\n          (send nil :comment_close_regex))\n        (str \" *$\"))))) gsub ","(send nil :read_crontab) join "," whenever_cron "," read_crontab "," read_crontab gsub "," whenever_cron chomp gsub "," whenever_cron chomp ","Regexp  new "," comment_close_regex "," comment_open_regex "," read_crontab =~ "," exit "," warn "," comment_open "," comment_close ","(send\n  (send nil :read_crontab) :=~\n  (send\n    (const nil :Regexp) :new\n    (dstr\n      (str \"^\")\n      (begin\n        (send nil :comment_open_regex))\n      (str \" *$\")))) nil? ","(send\n  (send nil :read_crontab) :=~\n  (send\n    (const nil :Regexp) :new\n    (dstr\n      (str \"^\")\n      (begin\n        (send nil :comment_close_regex))\n      (str \" *$\")))) nil? "," read_crontab index "," read_crontab index ! ","(send\n  (send nil :read_crontab) :=~\n  (send\n    (const nil :Regexp) :new\n    (dstr\n      (str \"^\")\n      (begin\n        (send nil :comment_open))\n      (str \"$\")))) nil? ","(send\n  (send nil :read_crontab) :=~\n  (send\n    (const nil :Regexp) :new\n    (dstr\n      (str \"^\")\n      (begin\n        (send nil :comment_close))\n      (str \"$\")))) nil? ","(and\n  (send\n    (send nil :read_crontab) :=~\n    (send\n      (const nil :Regexp) :new\n      (dstr\n        (str \"^\")\n        (begin\n          (send nil :comment_open))\n        (str \"$\"))))\n  (send\n    (send nil :read_crontab) :=~\n    (send\n      (const nil :Regexp) :new\n      (dstr\n        (str \"^\")\n        (begin\n          (send nil :comment_close))\n        (str \"$\"))))) gsub ","(send\n  (send nil :read_crontab) :=~\n  (send\n    (const nil :Regexp) :new\n    (dstr\n      (str \"^\")\n      (begin\n        (send nil :comment_close))))) nil? ","(and\n  (send\n    (send nil :read_crontab) :=~\n    (send\n      (const nil :Regexp) :new\n      (dstr\n        (str \"^\")\n        (begin\n          (send nil :comment_open))\n        (str \" *$\"))))\n  (send\n    (send nil :read_crontab) :=~\n    (send\n      (const nil :Regexp) :new\n      (dstr\n        (str \"^\")\n        (begin\n          (send nil :comment_close))\n        (str \" *$\"))))) gsub ","(send\n  (send nil :read_crontab) :=~\n  (send\n    (const nil :Regexp) :new\n    (dstr\n      (str \"^\")\n      (begin\n        (send nil :comment_open))\n      (str \" *$\")))) nil? ","(send\n  (send nil :read_crontab) :=~\n  (send\n    (const nil :Regexp) :new\n    (dstr\n      (str \"^\")\n      (begin\n        (send nil :comment_close))\n      (str \" *$\")))) nil? "]}," Whenever CommandLine write_crontab":{"type":"method","name":"write_crontab","children":[],"call":[" exit "," warn "," puts ","@options [] ","$? exitstatus zero? ","$? exitstatus ","crontab close_write ","crontab write ","IO  popen ","command join ","command << ","OS  solaris? "," system ","file << ","File  open ","File WRONLY  | ","Tempfile  new path ","Tempfile  new ","tmp_cron_file close! ","tmp_cron_file path ","tmp_cron_file fsync ","tmp_cron_file << ","Tempfile  open ","Tempfile  new path  close! ","Tempfile  open  close! ","Tempfile  new path  path ","Tempfile  open  path ","Tempfile  new path  fsync ","Tempfile  open  fsync ","Tempfile  new path  << ","Tempfile  open  << "]}," Whenever CommandLine read_crontab":{"type":"method","name":"read_crontab","children":[],"call":[" prepare ","$? exitstatus zero? ","$? exitstatus ","command join ","command << ","@options [] "," instance_variable_defined? "]}," Whenever CommandLine whenever_cron":{"type":"method","name":"whenever_cron","children":[],"call":["(send nil :comment_open) compact join + ","(send nil :comment_open) compact join ","(send nil :comment_open) compact "," comment_close ","Whenever  cron "," comment_open ","@options [] ","(send nil :comment_open) join + ","(send nil :comment_open) join "]}," Whenever CommandLine default_identifier":{"type":"method","name":"default_identifier","children":[],"call":["File  expand_path ","@options [] "]}," Whenever CommandLine run":{"type":"method","name":"run","children":[],"call":[" exit "," puts ","Whenever  cron "," write_crontab "," whenever_cron ","@options [] "," updated_crontab "]}," Whenever CommandLine initialize":{"type":"method","name":"initialize","children":[],"call":["Time  now to_s ","Time  now ","@options []= ","@options [] to_i ","@options [] "," exit "," warn ","options [] ","@options [] to_s =~ ","@options [] to_s ","(send\n  (ivar :@options) :[]\n  (sym :update)) compact length > ","(send\n  (ivar :@options) :[]\n  (sym :update)) compact length ","(send\n  (ivar :@options) :[]\n  (sym :update)) compact ","@options [] nil? ","File  exist? ! ","File  exist? "," default_identifier ","File  exists? ","File  exists? ! "]}," Whenever CommandLine execute":{"type":"method","name":"execute","children":[],"call":[]}," Whenever CapistranoSupport load_into":{"type":"method","name":"load_into","children":[{"type":"method","name":"whenever_options","children":[],"asgn":[],"call":[" fetch "]},{"type":"method","name":"whenever_roles","children":[],"asgn":[],"call":[" Array "," whenever_options [] "," whenever_options "]},{"type":"method","name":"whenever_servers","children":[],"asgn":[],"call":[" find_servers "," whenever_options "]},{"type":"method","name":"whenever_server_roles","children":[],"asgn":[],"call":["map []= "," role_names_for_host & "," whenever_roles "," role_names_for_host "," whenever_servers inject "," whenever_servers "]},{"type":"method","name":"whenever_prepare_for_rollback","children":[],"asgn":[],"call":["args []= "," fetch ","args []= "," fetch ","args []= "," fetch "," fetch "]},{"type":"method","name":"whenever_run_commands","children":[],"asgn":[null,null],"call":[" run "," whenever_options merge "," whenever_options ","args [] ","args [] ","args [] ","roles join ","roles empty? "," whenever_server_roles each "," whenever_server_roles "," raise ","args include? ","(sym :command) all? "]}],"call":[]}," method_missing":{"type":"method","name":"method_missing","children":[],"call":["Whenever NumericSeconds  new send ","Whenever NumericSeconds  new ","Whenever NumericSeconds  public_method_defined? "]}," respond_to?":{"type":"method","name":"respond_to?","children":[],"call":["Whenever NumericSeconds  public_method_defined? "]}," Whenever Output Cron range_or_integer":{"type":"method","name":"range_or_integer","children":[],"call":[" raise ","valid_range include? ","at max ","at min ","at is_a? ","valid_range max ","valid_range min "]}," Whenever Job Runner output":{"type":"method","name":"output","children":[],"call":[" task inspect "," task ","File  join "," path_required "]}," Whenever Job RakeTask output":{"type":"method","name":"output","children":[],"call":[" task "," path_required "]}," Whenever Job Default path_required":{"type":"method","name":"path_required","children":[],"call":[" raise ","@path blank? "]}," Whenever Job Default output":{"type":"method","name":"output","children":[],"call":[" task "]}," Whenever Job Default initialize":{"type":"method","name":"initialize","children":[],"call":["Whenever  path ","options [] ","options has_key? "]}," Whenever JobList path_should_not_be_set_automatically?":{"type":"method","name":"path_should_not_be_set_automatically?","children":[],"call":["@env [] ","@set_path_automatically === "]}," Whenever JobList read_path":{"type":"method","name":"read_path","children":[],"call":["ENV  [] "]}," Whenever JobList set_path_environment_variable":{"type":"method","name":"set_path_environment_variable","children":[],"call":["@env []= "," read_path "," read_path blank? "," path_should_not_be_set_automatically? "]}," Whenever JobList rake":{"type":"method","name":"rake","children":[],"call":[" command ","options []= ","options reverse_merge! "]}," Whenever JobList runner":{"type":"method","name":"runner","children":[],"call":[" command ","options []= ","options reverse_merge! "]}," Whenever JobList command":{"type":"method","name":"command","children":[],"call":["@jobs [] << ","options [] new ","@options merge merge ","@options merge ","options [] ","@jobs [] ","options [] === ","options []= ","options has_key? ! ","options has_key? "]}," Whenever Output Cron output_redirection":{"type":"method","name":"output_redirection","children":[],"call":["OutputRedirection  new to_s ","OutputRedirection  new ","@output_redirection == ","Whenever Output Cron OutputRedirection  new to_s ","Whenever Output Cron OutputRedirection  new "]}," Whenever Output Cron OutputRedirection redirect_from_string":{"type":"method","name":"redirect_from_string","children":[],"call":[]}," Whenever Output Cron OutputRedirection redirect_from_hash":{"type":"method","name":"redirect_from_hash","children":[],"call":[" stdout "," stderr "," stderr == "," stdout == "]}," Whenever Output Cron OutputRedirection stderr":{"type":"method","name":"stderr","children":[],"call":["@output [] ","@output [] nil? ","@output has_key? "]}," Whenever Output Cron OutputRedirection stdout":{"type":"method","name":"stdout","children":[],"call":["@output [] ","@output [] nil? ","@output has_key? "]}," Whenever Output Cron OutputRedirection to_s":{"type":"method","name":"to_s","children":[],"call":[" redirect_from_hash "," redirect_from_string "]}," Whenever Output Cron OutputRedirection initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Whenever rails3?":{"type":"method","name":"rails3?","children":[],"call":[]}," runner_for_app":{"type":"method","name":"runner_for_app","children":[],"call":["Whenever  script_rails? ","Whenever  bin_rails? "]}," Whenever NumericSeconds process_string":{"type":"method","name":"process_string","children":[],"call":[]}," Whenever JobList singleton_class_shim":{"type":"method","name":"singleton_class_shim","children":[],"call":[" singleton_class "," respond_to? "]}}