{" retryable":{"type":"method","name":"retryable","children":[],"call":["(op-asgn\n  (lvasgn :tries) :-\n  (int 1)) > ","opts [] ","(send\n  (lvar :opts) :[]\n  (sym :on)) flatten ","opts [] == ","(pair\n  (sym :tries)\n  (int 1)) merge ","(pair\n  (sym :tries)\n  (int 1)) merge  [] ","(send\n  (lvar :(pair\n  (sym :tries)\n  (int 1)) merge ) :[]\n  (sym :on)) flatten ","(pair\n  (sym :tries)\n  (int 1)) merge  [] == "]}," Kernel retryable":{"type":"method","name":"retryable","children":[],"call":[" sleep ","opts [] ","opts [] call ","opts [] respond_to? "," raise ","retries + >= ","retries + ","(send\n  (lvar :opts) :[]\n  (sym :on)) flatten ","opts [] == ","(pair\n  (sym :tries)\n  (int 2)) merge ","exception message =~ ","exception message ","opts merge! "," check_for_invalid_options ","Proc  new ","Retryable  enabled? ","(pair\n  (sym :tries)\n  (int 2)) merge  [] ","(pair\n  (sym :tries)\n  (int 2)) merge  [] call ","(pair\n  (sym :tries)\n  (int 2)) merge  [] respond_to? ","(send\n  (lvar :(pair\n  (sym :tries)\n  (int 2)) merge ) :[]\n  (sym :on)) flatten ","(pair\n  (sym :tries)\n  (int 2)) merge  [] == ","(pair\n  (sym :tries)\n  (int 2)) merge  merge! "]}," Kernel check_for_invalid_options":{"type":"method","name":"check_for_invalid_options","children":[],"call":[" raise ","InvalidRetryableOptions  new ","invalid_options join ","invalid_options empty? ","default_options merge keys - ","default_options keys ","default_options merge keys ","default_options merge ","ArgumentError  new ","default_options merge keys -  join ","default_options merge keys -  empty? "]}," Retryable Version to_s":{"type":"method","name":"to_s","children":[],"call":["(const nil :MAJOR) compact join ","(const nil :MAJOR) compact "," to_a join "," to_a "]}," Retryable enabled?":{"type":"method","name":"enabled?","children":[],"call":[" configuration enabled? "," configuration "]}," Retryable disable":{"type":"method","name":"disable","children":[],"call":[" configuration disable "," configuration "]}," Retryable enable":{"type":"method","name":"enable","children":[],"call":[" configuration enable "," configuration "]}," Retryable check_for_invalid_options":{"type":"method","name":"check_for_invalid_options","children":[],"call":[" raise ","ArgumentError  new ","invalid_options join ","invalid_options empty? ","default_options merge keys - ","default_options keys ","default_options merge keys ","default_options merge ","default_options merge keys -  join ","default_options merge keys -  empty? "]}," Retryable retryable":{"type":"method","name":"retryable","children":[],"call":["opts [] call ","opts [] ","Kernel  sleep ","opts [] respond_to? "," raise ","retries + >= ","retries + ","exception message =~ ","exception message "," configuration enabled? "," configuration ","(send\n  (lvar :opts) :[]\n  (sym :on)) flatten ","opts [] == ","opts merge! "," check_for_invalid_options "," configuration exception_cb "," configuration ensure "," configuration matching "," configuration on "," configuration sleep "," configuration tries ","(send\n  (lvar :opts) :[]\n  (sym :not)) flatten "," configuration not ","tries != "," configuration sleep_method "," configuration to_hash "," matches? ","(send\n  (lvar :opts) :[]\n  (sym :matching)) flatten ","opts [] is_a? ","retries > ","tries infinite? ","tries respond_to? "," configuration to_hash  [] call "," configuration to_hash  [] "," configuration to_hash  [] respond_to? ","reopts []  + >= ","reopts []  + ","(send\n  (lvar : configuration to_hash ) :[]\n  (sym :on)) flatten "," configuration to_hash  [] == "," configuration to_hash  merge! "," configuration (send\n  (lvar :opts) :[]\n  (sym :matching)) flatten  "," configuration opts []  ","(send\n  (lvar : configuration to_hash ) :[]\n  (sym :not)) flatten ","opts []  != ","(send\n  (lvar : configuration to_hash ) :[]\n  (sym :matching)) flatten ","(send\n  (lvar :opts) :[]\n  (sym :(send\n  (lvar :opts) :[]\n  (sym :matching)) flatten )) flatten ","(send\n  (lvar :opts) :[]\n  (sym :opts [] )) flatten "," configuration to_hash  [] is_a? ","reopts []  > ","opts []  infinite? ","opts []  respond_to? "]}," Retryable configuration":{"type":"method","name":"configuration","children":[],"call":["Configuration  new "]}," Retryable configure":{"type":"method","name":"configure","children":[],"call":[" configuration "]}," Retryable Configuration merge":{"type":"method","name":"merge","children":[],"call":[" to_hash merge "," to_hash "]}," Retryable Configuration to_hash":{"type":"method","name":"to_hash","children":[],"call":["hash []= "," send ","option to_sym ","OPTIONS  inject ","memo []= "," instance_variable_get ","VALID_OPTION_KEYS  each_with_object "]}," Retryable Configuration []":{"type":"method","name":"[]","children":[],"call":[" send "]}," Retryable Configuration disable":{"type":"method","name":"disable","children":[],"call":[]}," Retryable Configuration enable":{"type":"method","name":"enable","children":[],"call":[]}," Retryable Configuration initialize":{"type":"method","name":"initialize","children":[],"call":["Proc  new ","Kernel  sleep "," lambda "," proc "]}," Retryable with_context":{"type":"method","name":"with_context","children":[],"call":[" retryable "," configuration contexts [] merge "," configuration contexts [] "," configuration contexts "," configuration "," raise "," configuration contexts keys "," configuration contexts keys include? "," configuration contexts key? "]}," Retryable Version to_a":{"type":"method","name":"to_a","children":[],"call":["(send nil :major) compact "," patch "," minor "," major "]}," Retryable Version to_h":{"type":"method","name":"to_h","children":[],"call":[" patch "," minor "," major "]}," Retryable Version patch":{"type":"method","name":"patch","children":[],"call":[]}," Retryable Version minor":{"type":"method","name":"minor","children":[],"call":[]}," Retryable Version major":{"type":"method","name":"major","children":[],"call":[]}," Retryable matches?":{"type":"method","name":"matches?","children":[],"call":[" raise ","message =~ ","message include? ","candidates any? "]}}