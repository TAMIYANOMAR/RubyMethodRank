{" MimeType root_types":{"type":"method","name":"root_types","children":[],"call":["(send\n  (send\n    (send\n      (const\n        (const nil :MimeMagic) :TYPES) :[]\n      (lvar :type)) :[]\n    (int 1)) :map) flatten "," root_types ","MimeMagic TYPES  [] [] map ","MimeMagic TYPES  [] [] ","MimeMagic TYPES  [] ","MimeMagic TYPES  [] [] empty? ","MimeMagic TYPES  [] nil? "]}," MimeType most_specific_type":{"type":"method","name":"most_specific_type","children":[],"call":["(send\n  (send nil :root_types\n    (lvar :from_magic_type)) :&\n  (send nil :root_types\n    (lvar :fallback_type))) any? "," root_types & "," root_types "]}," MimeType parse_media_type":{"type":"method","name":"parse_media_type","children":[],"call":["result index ","content_type downcase split first ","content_type downcase split ","content_type downcase ","content_type downcase split first  index "]}," MimeType with_io":{"type":"method","name":"with_io","children":[],"call":["pathname_or_io open "]}," MimeType for_declared_type":{"type":"method","name":"for_declared_type","children":[],"call":["type != "," parse_media_type ","type downcase ","type nil? ! ","type nil? "," parse_media_type  != "," parse_media_ parse_media_type  "," parse_media_type  downcase "," parse_media_type  nil? ! "," parse_media_type  nil? "]}," MimeType for_extension":{"type":"method","name":"for_extension","children":[],"call":["MimeMagic  by_extension ","magic type downcase ","magic type ","MimeMagic  by_extension  type downcase ","MimeMagic  by_extension  type "]}," MimeType for_name":{"type":"method","name":"for_name","children":[],"call":["MimeMagic  by_path ","magic type downcase ","magic type ","MimeMagic  by_path  type downcase ","MimeMagic  by_path  type "]}," MimeType for_data":{"type":"method","name":"for_data","children":[],"call":["MimeMagic  by_magic "," with_io ","magic type downcase ","magic type ","MimeMagic  by_MimeMagic  by_magic  ","MimeMagic  by_magic  type downcase ","MimeMagic  by_magic  type "]}," MimeType for":{"type":"method","name":"for","children":[],"call":[" most_specific_type "," for_extension "," for_name "," for_declared_type "," for_data "]}," MimeType extend":{"type":"method","name":"extend","children":[],"call":["MimeMagic  add ","existing [] ","(send\n  (send nil :Array\n    (lvar :parents)) :+\n  (send\n    (lvar :existing) :[]\n    (int 1))) uniq "," Array + "," Array ","(send\n  (send nil :Array\n    (lvar :extensions)) :+\n  (send\n    (lvar :existing) :[]\n    (int 0))) uniq ","MimeMagic TYPES  [] ","(send\n  (send nil :Array\n    (lvar :(send\n  (send nil :Array\n    (lvar :parents)) :+\n  (send\n    (lvar :existing) :[]\n    (int 1))) uniq )) :+\n  (send\n    (lvar :existing) :[]\n    (int 1))) uniq ","(send\n  (send nil :Array\n    (lvar :(send\n  (send nil :Array\n    (lvar :extensions)) :+\n  (send\n    (lvar :existing) :[]\n    (int 0))) uniq )) :+\n  (send\n    (lvar :existing) :[]\n    (int 0))) uniq "]}," Marcel MimeType root_types":{"type":"method","name":"root_types","children":[],"call":["(send\n  (send\n    (send\n      (const nil :TYPES) :[]\n      (lvar :type)) :[]\n    (int 1)) :map) flatten "," root_types ","TYPES  [] [] map ","TYPES  [] [] ","TYPES  [] ","TYPES  [] [] empty? ","TYPES  [] nil? "]}," Marcel MimeType most_specific_type":{"type":"method","name":"most_specific_type","children":[],"call":["(send\n  (send nil :root_types\n    (lvar :from_magic_type)) :&\n  (send nil :root_types\n    (lvar :fallback_type))) any? "," root_types & "," root_types "]}," Marcel MimeType parse_media_type":{"type":"method","name":"parse_media_type","children":[],"call":["result index ","content_type downcase split first ","content_type downcase split ","content_type downcase ","content_type downcase split first  index "]}," Marcel MimeType with_io":{"type":"method","name":"with_io","children":[],"call":["pathname_or_io open ","pathname_or_io is_a? "]}," Marcel MimeType for_declared_type":{"type":"method","name":"for_declared_type","children":[],"call":["type downcase ","type nil? ! ","type nil? ","type != "," parse_media_type "," parse_media_type  downcase "," parse_media_type  nil? ! "," parse_media_type  nil? "," parse_media_type  != "," parse_media_ parse_media_type  "]}," Marcel MimeType for_extension":{"type":"method","name":"for_extension","children":[],"call":["magic type downcase ","magic type ","Marcel Magic  by_extension ","Marcel Magic  by_extension  type downcase ","Marcel Magic  by_extension  type "]}," Marcel MimeType for_name":{"type":"method","name":"for_name","children":[],"call":["magic type downcase ","magic type ","Marcel Magic  by_path ","Marcel Magic  by_path  type downcase ","Marcel Magic  by_path  type "]}," Marcel MimeType for_data":{"type":"method","name":"for_data","children":[],"call":["magic type downcase ","magic type ","Marcel Magic  by_magic "," with_io ","Marcel Magic  by_magic  type downcase ","Marcel Magic  by_magic  type ","Marcel Magic  by_Marcel Magic  by_magic  "]}," Marcel MimeType for":{"type":"method","name":"for","children":[],"call":[" most_specific_type "," for_extension "," for_name "," for_declared_type "," for_data "]}," Marcel MimeType extend":{"type":"method","name":"extend","children":[],"call":["Magic  add ","existing [] ","(send\n  (send nil :Array\n    (lvar :parents)) :+\n  (send\n    (lvar :existing) :[]\n    (int 1))) uniq "," Array + "," Array ","(send\n  (send nil :Array\n    (lvar :extensions)) :+\n  (send\n    (lvar :existing) :[]\n    (int 0))) uniq ","Marcel TYPES  [] ","(send\n  (send nil :Array\n    (lvar :(send\n  (send nil :Array\n    (lvar :parents)) :+\n  (send\n    (lvar :existing) :[]\n    (int 1))) uniq )) :+\n  (send\n    (lvar :existing) :[]\n    (int 1))) uniq ","(send\n  (send nil :Array\n    (lvar :(send\n  (send nil :Array\n    (lvar :extensions)) :+\n  (send\n    (lvar :existing) :[]\n    (int 0))) uniq )) :+\n  (send\n    (lvar :existing) :[]\n    (int 0))) uniq "]}," Marcel Magic magic_match_io":{"type":"method","name":"magic_match_io","children":[],"call":[]}," Marcel Magic magic_match":{"type":"method","name":"magic_match","children":[],"call":[]}," Marcel Magic child?":{"type":"method","name":"child?","children":[],"call":[]}," Marcel Magic hash":{"type":"method","name":"hash","children":[],"call":[" type hash "," type "]}," Marcel Magic eql?":{"type":"method","name":"eql?","children":[],"call":[" type == ","other to_s "," type "]}," Marcel Magic to_s":{"type":"method","name":"to_s","children":[],"call":[" type "]}," Marcel Magic all_by_magic":{"type":"method","name":"all_by_magic","children":[],"call":[]}," Marcel Magic by_magic":{"type":"method","name":"by_magic","children":[],"call":[]}," Marcel Magic by_path":{"type":"method","name":"by_path","children":[],"call":[]}," Marcel Magic by_extension":{"type":"method","name":"by_extension","children":[],"call":[]}," Marcel Magic comment":{"type":"method","name":"comment","children":[],"call":["(if\n  (send\n    (const nil :TYPES) :key?\n    (send nil :type))\n  (send\n    (send\n      (const nil :TYPES) :[]\n      (send nil :type)) :[]\n    (int 2))\n  (nil)) to_s ","TYPES  [] [] ","TYPES  [] "," type ","TYPES  key? "]}," Marcel Magic extensions":{"type":"method","name":"extensions","children":[],"call":["TYPES  [] [] ","TYPES  [] "," type ","TYPES  key? "]}," Marcel Magic child_of?":{"type":"method","name":"child_of?","children":[],"call":[" class child? "," type "," class "]}," Marcel Magic video?":{"type":"method","name":"video?","children":[],"call":[" mediatype == "," mediatype "]}," Marcel Magic audio?":{"type":"method","name":"audio?","children":[],"call":[" mediatype == "," mediatype "]}," Marcel Magic image?":{"type":"method","name":"image?","children":[],"call":[" mediatype == "," mediatype "]}," Marcel Magic text?":{"type":"method","name":"text?","children":[],"call":[" child_of? "," mediatype == "," mediatype "]}," Marcel Magic remove":{"type":"method","name":"remove","children":[],"call":[]}," Marcel Magic add":{"type":"method","name":"add","children":[],"call":[]}," Marcel Magic initialize":{"type":"method","name":"initialize","children":[],"call":["type split "]}}