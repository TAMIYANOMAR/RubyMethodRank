{" RubyPriorityQueueTest test_private_delete_first":{"type":"method","name":"test_private_delete_first","children":[],"call":["tc assert_equal "," delete_first ","r left ","r right ","tc assert_not_equal ","@rootlist right ","@rootlist left ","2 times ","q instance_eval ","q []= ","RubyPriorityQueue  new ","tc assert_eRubyPriorityQueue  new ual ","tc assert_not_eRubyPriorityQueue  new ual ","RubyPriorityQueue  new  instance_eval ","RubyPriorityQueue  new  []= "]}," RubyPriorityQueueTest test_private_link_nodes":{"type":"method","name":"test_private_link_nodes","children":[],"call":["tc assert_equal ","n1 right ","n0 right ","n1 left ","n0 left ","n1 child ","n0 child "," link_nodes ","n1 right= ","n1 left= ","n0 right= ","n0 left= ","@nodes [] ","q instance_eval ","q []= ","RubyPriorityQueue  new ","tc assert_eRubyPriorityQueue  new ual ","@nodes []  right ","@nodes []  left ","@nodes []  child ","@nodes []  right= ","@nodes []  left= ","RubyPriorityQueue  new  instance_eval ","RubyPriorityQueue  new  []= "]}," RubyPriorityQueueTest setup":{"type":"method","name":"setup","children":[],"call":["RubyPriorityQueue  new "]}," PoorPriorityQueueTest setup":{"type":"method","name":"setup","children":[],"call":["PoorPriorityQueue  new "]}," CPriorityQueueTest test_to_dot":{"type":"method","name":"test_to_dot","children":[],"call":[" assert_equal ","@q to_dot gsub ","@q to_dot ","(str \"digraph fibonacci_heap {\") join ","@q delete_min ","@q push ","5 times "]}," CPriorityQueueTest setup":{"type":"method","name":"setup","children":[],"call":["CPriorityQueue  new "]}," PriorityQueueTest test_each":{"type":"method","name":"test_each","children":[],"call":[" assert_equal ","@q to_a sort ","@q to_a ","queue sort ","r << ","n [] ","(irange\n  (str \"a\")\n  (str \"z\")) inject ","@q []= ","(irange\n  (str \"a\")\n  (str \"z\")) each "]}," PriorityQueueTest test_dup":{"type":"method","name":"test_dup","children":[],"call":[" assert_equal ","qq delete_min ","@q delete_min ","@q empty? ","@q dup ","@q []= ","n [] ","(irange\n  (str \"a\")\n  (str \"z\")) each ","@q dup  delete_min "]}," PriorityQueueTest test_example_1":{"type":"method","name":"test_example_1","children":[],"call":[" assert_equal ","@q delete ","@q []= ","@q [] ","@q delete_min ","@q min_priority ","@q min_key "]}," PriorityQueueTest test_delete":{"type":"method","name":"test_delete","children":[],"call":[" assert_equal ","@q delete ","@q min ","@q [] ","@q []= "]}," PriorityQueueTest test_increase_priority":{"type":"method","name":"test_increase_priority","children":[],"call":[" assert_equal ","@q delete_min ","@q []= ","20 times "]}," PriorityQueueTest test_decrease_priority":{"type":"method","name":"test_decrease_priority","children":[],"call":[" assert_equal ","@q delete_min ","(int 10) flatten each ","(int 10) flatten ","(irange\n  (int 12)\n  (int 19)) to_a ","(irange\n  (int 1)\n  (int 9)) to_a ","@q []= ","@q push ","i / ","20 times "]}," PriorityQueueTest test_min":{"type":"method","name":"test_min","children":[],"call":[" assert_equal ","@q min ","@q []= "]}," PriorityQueueTest test_access":{"type":"method","name":"test_access","children":[],"call":[" assert_equal ","@q min_key ","@q [] ","@q []= ","@q min "]}," PriorityQueueTest test_min_priority":{"type":"method","name":"test_min_priority","children":[],"call":[" assert_equal ","@q min_priority ","@q []= "]}," PriorityQueueTest test_min_key":{"type":"method","name":"test_min_key","children":[],"call":[" assert_equal ","@q min_key ","@q []= "]}," PriorityQueueTest test_push_decrease_pop":{"type":"method","name":"test_push_decrease_pop","children":[],"call":[" assert_equal ","@q delete_min ","i + ","30 times ","10 times ","@q []= ","@q push ","50 times "]}," PriorityQueueTest test_push_pop":{"type":"method","name":"test_push_pop","children":[],"call":[" assert_equal ","@q delete_min ","20 times ","@q push "]}," PriorityQueueTest test_push":{"type":"method","name":"test_push","children":[],"call":[" assert_equal ","@q delete_min ","20 times ","@q push ","i + "]}," PriorityQueueTest test_empty?":{"type":"method","name":"test_empty?","children":[],"call":[" assert_equal ","@q empty? ","@q []= "]}," PriorityQueueTest test_has_key?":{"type":"method","name":"test_has_key?","children":[],"call":[" assert ","@q has_key? ","@q []= ","@q has_key? ! "]}," PriorityQueueTest test_delete_min_return_priority":{"type":"method","name":"test_delete_min_return_priority","children":[],"call":[" assert_equal ","@q delete_min_return_priority ","@q []= "]}," PriorityQueueTest test_delete_min_return_key":{"type":"method","name":"test_delete_min_return_key","children":[],"call":[" assert_equal ","@q delete_min_return_key ","@q []= "]}," PriorityQueueTest test_delete_min":{"type":"method","name":"test_delete_min","children":[],"call":[" assert_equal ","@q delete_min ","@q []= "]}," PriorityQueueTest test_merge":{"type":"method","name":"test_merge","children":[],"call":["@q2 []= ","i + ","@q1 []= ","20 times ","@q class new ","@q class ","@q class new  []= "]}," PriorityQueueTest test_length":{"type":"method","name":"test_length","children":[],"call":[" assert_equal ","@q length ","@q delete ","@q []= ","10 + ","10 times ","@q delete_min ","20 - ","20 times "]}," PriorityQueueTest teardown":{"type":"method","name":"teardown","children":[],"call":[" assert_operator ","@q delete_min_return_priority ","@q min_priority ","@q delete_min_return_@q delete_min_return_priority  ","@q min_@q delete_min_return_priority  "]}," setup_rb_error":{"type":"method","name":"setup_rb_error","children":[],"call":[" raise "]}," Installer run_hook":{"type":"method","name":"run_hook","children":[],"call":[" setup_rb_error ","(str \"hook \") + ","$! message "," raise "," instance_eval ","File  read ","File  file? ","(dstr\n  (begin\n    (send nil :curr_srcdir))\n  (str \"/\")\n  (begin\n    (lvar :id))) detect "," curr_srcdir "]}," Installer dive_into":{"type":"method","name":"dive_into","children":[],"call":["File  dirname ","$stderr puts ","<---  + "," verbose? ","Dir  chdir ","--->  + ","Dir  pwd ","Dir  mkdir ","File  dir? ","File  basename ","File  File  basename name ","Dir  chFile  basename  ","Dir  mkFile  basename  ","File  File  basename ? "]}," Installer traverse":{"type":"method","name":"traverse","children":[],"call":[" run_hook "," traverse "," directories_of each "," directories_of "," curr_srcdir "," __send__ ","rel sub "," dive_into "]}," Installer exec_task_traverse":{"type":"method","name":"exec_task_traverse","children":[],"call":[" run_hook "," traverse ","$stderr puts "," verbose? ","type == "," config == "," config ","FILETYPES  each "]}," Installer distclean_dir_conf":{"type":"method","name":"distclean_dir_conf","children":[],"call":[]}," Installer distclean_dir_data":{"type":"method","name":"distclean_dir_data","children":[],"call":[]}," Installer distclean_dir_ext":{"type":"method","name":"distclean_dir_ext","children":[],"call":[" make ","File  file? "," extdir? "," curr_srcdir "]}," Installer distclean_dir_lib":{"type":"method","name":"distclean_dir_lib","children":[],"call":[]}," Installer distclean_dir_bin":{"type":"method","name":"distclean_dir_bin","children":[],"call":[]}," Installer exec_distclean":{"type":"method","name":"exec_distclean","children":[],"call":[" rm_f ","@config savefile "," exec_task_traverse "]}," Installer clean_dir_conf":{"type":"method","name":"clean_dir_conf","children":[],"call":[]}," Installer clean_dir_data":{"type":"method","name":"clean_dir_data","children":[],"call":[]}," Installer clean_dir_ext":{"type":"method","name":"clean_dir_ext","children":[],"call":[" make ","File  file? "," extdir? "," curr_srcdir "]}," Installer clean_dir_lib":{"type":"method","name":"clean_dir_lib","children":[],"call":[]}," Installer clean_dir_bin":{"type":"method","name":"clean_dir_bin","children":[],"call":[]}," Installer exec_clean":{"type":"method","name":"exec_clean","children":[],"call":[" rm_f ","@config savefile "," exec_task_traverse "]}," Installer exec_test":{"type":"method","name":"exec_test","children":[],"call":["runner run ","runner to_run << ","runner to_run ","Test Unit AutoRunner  new "," require ","$stderr puts "," verbose? ","File  directory? ","Test Unit AutoRunner  new  run ","Test Unit AutoRunner  new  to_run << ","Test Unit AutoRunner  new  to_run "]}," Installer globs2re":{"type":"method","name":"globs2re","children":[],"call":["(send\n  (lvar :pats) :map) join ","GLOB2REGEX  [] ","pat gsub ","pats map "]}," Installer glob_reject":{"type":"method","name":"glob_reject","children":[],"call":["re =~ ","ents reject "," globs2re "," globs2re  =~ ","ents  globs2re ject "," globs2 globs2re  "]}," Installer glob_select":{"type":"method","name":"glob_select","children":[],"call":["re =~ ","ents select "," globs2re "," globs2re  =~ "," globs2 globs2re  "]}," Installer hookfiles":{"type":"method","name":"hookfiles","children":[],"call":["(send\n  (array\n    (str \"pre-%s\")\n    (str \"post-%s\")\n    (str \"pre-%s.rb\")\n    (str \"post-%s.rb\")) :map) flatten "," sprintf ","(str \"config\") map ","(str \"pre-%s\") map "]}," Installer existfiles":{"type":"method","name":"existfiles","children":[],"call":[" glob_reject "," files_of | "," files_of "," curr_srcdir "]}," Installer mapdir":{"type":"method","name":"mapdir","children":[],"call":[" curr_srcdir ","File  exist? ","ents map "]}," Installer targetfiles":{"type":"method","name":"targetfiles","children":[],"call":[" mapdir "," existfiles - "," hookfiles "," existfiles "]}," Installer rubyextentions":{"type":"method","name":"rubyextentions","children":[],"call":[" setup_rb_error ","ents empty? "," glob_select "," targetfiles ","@config dllext "," glob_select  empty? "]}," Installer rubyscripts":{"type":"method","name":"rubyscripts","children":[],"call":[" glob_select "," targetfiles ","@config libsrc_pattern "]}," Installer install_files":{"type":"method","name":"install_files","children":[],"call":[" install ","@config install_prefix ","list each "," mkdir_p "]}," Installer install_dir_man":{"type":"method","name":"install_dir_man","children":[],"call":[" install_files "," config "," targetfiles "]}," Installer install_dir_conf":{"type":"method","name":"install_dir_conf","children":[],"call":[" install_files "," config "," targetfiles "]}," Installer install_dir_data":{"type":"method","name":"install_dir_data","children":[],"call":[" install_files "," config "," targetfiles "]}," Installer install_dir_ext":{"type":"method","name":"install_dir_ext","children":[],"call":[" install_files ","File  dirname "," config "," rubyextentions "," extdir? "," curr_srcdir "]}," Installer install_dir_lib":{"type":"method","name":"install_dir_lib","children":[],"call":[" install_files "," config "," rubyscripts "]}," Installer install_dir_bin":{"type":"method","name":"install_dir_bin","children":[],"call":[" install_files "," config "," targetfiles "]}," Installer exec_install":{"type":"method","name":"exec_install","children":[],"call":[" exec_task_traverse "," rm_f "]}," Installer setup_dir_conf":{"type":"method","name":"setup_dir_conf","children":[],"call":[]}," Installer setup_dir_data":{"type":"method","name":"setup_dir_data","children":[],"call":[]}," Installer setup_dir_ext":{"type":"method","name":"setup_dir_ext","children":[],"call":[" make "," extdir? "," curr_srcdir "]}," Installer setup_dir_man":{"type":"method","name":"setup_dir_man","children":[],"call":[]}," Installer setup_dir_lib":{"type":"method","name":"setup_dir_lib","children":[],"call":[]}," Installer adjust_shebang":{"type":"method","name":"adjust_shebang","children":[],"call":["File  unlink ","File  exist? "," move_file ","File  basename ","w write ","r read ","w print ","first sub ","#!  + "," config ","File  open ","$stderr puts "," verbose? ","File  basename == ","first sub split [] to_s ","first sub split [] ","first sub split ","r gets ","File  basename + "," no_harm? ","r gets  sub ","r gets  sub split [] to_s ","r gets  sub split [] ","r gets  sub split "]}," Installer setup_dir_bin":{"type":"method","name":"setup_dir_bin","children":[],"call":[" adjust_shebang "," curr_srcdir "," files_of each "," files_of "]}," Installer exec_setup":{"type":"method","name":"exec_setup","children":[],"call":[" exec_task_traverse "]}," Installer config_dir_conf":{"type":"method","name":"config_dir_conf","children":[],"call":[]}," Installer config_dir_data":{"type":"method","name":"config_dir_data","children":[],"call":[]}," Installer extconf":{"type":"method","name":"extconf","children":[],"call":[" ruby ","@config config_opt "," curr_srcdir "]}," Installer config_dir_ext":{"type":"method","name":"config_dir_ext","children":[],"call":[" extconf "," extdir? "," curr_srcdir "]}," Installer config_dir_man":{"type":"method","name":"config_dir_man","children":[],"call":[]}," Installer config_dir_lib":{"type":"method","name":"config_dir_lib","children":[],"call":[]}," Installer config_dir_bin":{"type":"method","name":"config_dir_bin","children":[],"call":[]}," Installer exec_config":{"type":"method","name":"exec_config","children":[],"call":[" exec_task_traverse "]}," Installer verbose_off":{"type":"method","name":"verbose_off","children":[],"call":["@config verbose= ","@config verbose? "]}," Installer no_harm?":{"type":"method","name":"no_harm?","children":[],"call":["@config no_harm? "]}," Installer verbose?":{"type":"method","name":"verbose?","children":[],"call":["@config verbose? "]}," Installer relpath":{"type":"method","name":"relpath","children":[],"call":[]}," Installer objdir_root":{"type":"method","name":"objdir_root","children":[],"call":[]}," Installer srcdir_root":{"type":"method","name":"srcdir_root","children":[],"call":[]}," Installer inspect":{"type":"method","name":"inspect","children":[],"call":["File  basename "," class "]}," Installer initialize":{"type":"method","name":"initialize","children":[],"call":["File  expand_path "]}," ToplevelInstallerMulti no_harm?":{"type":"method","name":"no_harm?","children":[],"call":["@config no_harm? "]}," ToplevelInstallerMulti verbose?":{"type":"method","name":"verbose?","children":[],"call":["@config verbose? "]}," ToplevelInstallerMulti run_hook":{"type":"method","name":"run_hook","children":[],"call":["@root_installer run_hook "]}," ToplevelInstallerMulti each_selected_installers":{"type":"method","name":"each_selected_installers","children":[],"call":["Dir  chdir ","@installers [] ","Dir  mkdir ","File  dir? ","$stderr puts "," verbose? ","@selected each "]}," ToplevelInstallerMulti exec_distclean":{"type":"method","name":"exec_distclean","children":[],"call":[" run_hook ","inst exec_distclean "," each_selected_installers "," rm_f ","@config savefile "]}," ToplevelInstallerMulti exec_clean":{"type":"method","name":"exec_clean","children":[],"call":[" run_hook ","inst exec_clean "," each_selected_installers "," rm_f ","@config savefile "]}," ToplevelInstallerMulti exec_test":{"type":"method","name":"exec_test","children":[],"call":[" run_hook ","inst exec_test "," each_selected_installers "]}," ToplevelInstallerMulti exec_install":{"type":"method","name":"exec_install","children":[],"call":[" run_hook ","inst exec_install "," each_selected_installers "]}," ToplevelInstallerMulti exec_setup":{"type":"method","name":"exec_setup","children":[],"call":[" run_hook ","inst exec_setup "," each_selected_installers "]}," ToplevelInstallerMulti exec_config":{"type":"method","name":"exec_config","children":[],"call":["@config save "," run_hook ","inst exec_config "," each_selected_installers "]}," ToplevelInstallerMulti print_usage":{"type":"method","name":"print_usage","children":[],"call":["f puts ","   + ","@packages sort join ","@packages sort "]}," ToplevelInstallerMulti extract_selection":{"type":"method","name":"extract_selection","children":[],"call":[" setup_rb_error ","@installers key? ","a each ","list split ","@instlist split llers key? ","list split  elist split ch "]}," ToplevelInstallerMulti init_installers":{"type":"method","name":"init_installers","children":[],"call":["without include? ! ","without include? ","with include? ","with empty? ","@installers keys select ","@installers keys "," extract_selection "," config ","@installers []= ","Installer  new ","@packages each "," extract_selection  include? ! "," extract_selection out include? ! "," extract_selection  include? "," extract_selection out include? "," extract_selection  empty? "]}," ToplevelInstallerMulti packages=":{"type":"method","name":"packages=","children":[],"call":[" raise ","File  dir? ","list each ","list empty? "]}," ToplevelInstallerMulti run_metaconfigs":{"type":"method","name":"run_metaconfigs","children":[],"call":["@config load_script ","@packages each "]}," ToplevelInstallerMulti initialize":{"type":"method","name":"initialize","children":[],"call":["Installer  new ","File  expand_path "," raise ","@packages empty? "," directories_of "," directories_of  empty? "]}," ToplevelInstaller exec_distclean":{"type":"method","name":"exec_distclean","children":[],"call":["@installer exec_distclean "]}," ToplevelInstaller exec_clean":{"type":"method","name":"exec_clean","children":[],"call":["@installer exec_clean "]}," ToplevelInstaller exec_show":{"type":"method","name":"exec_show","children":[],"call":[" printf ","i value ","i name ","i value? ","@config each "]}," ToplevelInstaller exec_test":{"type":"method","name":"exec_test","children":[],"call":["@installer exec_test "]}," ToplevelInstaller exec_install":{"type":"method","name":"exec_install","children":[],"call":["@installer exec_install "]}," ToplevelInstaller exec_setup":{"type":"method","name":"exec_setup","children":[],"call":["@installer exec_setup "]}," ToplevelInstaller exec_config":{"type":"method","name":"exec_config","children":[],"call":["@config save ","@installer exec_config "]}," ToplevelInstaller print_usage":{"type":"method","name":"print_usage","children":[],"call":["out puts ","out printf ","item help_default ","item description ","item help_opt ","@config each ","TASKS  each ","File  basename "]}," ToplevelInstaller parsearg_install":{"type":"method","name":"parsearg_install","children":[],"call":[" setup_rb_error ","@config install_prefix= ","File  expand_path ","path [] == ","path [] ","a split [] ","a split ","@config no_harm= ","ARGV  shift ","@config instARGV  shift ll_prefix= ","File  expand_File  expand_path  ","File  expand_a split []  ","File  expARGV  shift nd_pARGV  shift th ","File  expand_path  [] == ","a split []  [] == ","pARGV  shift th [] == ","File  expand_path  [] ","a split []  [] ","pARGV  shift th [] ","ARGV  shift  split [] ","ARGV  shift  split ","@config no_hARGV  shift rm= "]}," ToplevelInstaller parsearg_config":{"type":"method","name":"parsearg_config","children":[],"call":["@config [] ","@config value_config? ","set each ","@config lookup evaluate ","@config lookup ","evalopt each ","set push ","evalopt push ","@config []= ","@config parse_opt ","@config config_opt= ","ARGV  dup ","ARGV  shift ","@confARGV  shift g [] ","@confARGV  shift g value_confARGV  shift g? ","@confARGV  shift g lookup evaluate ","@confARGV  shift g lookup ","@confARGV  shift g []= ","@confARGV  shift g parse_opt ","@confARGV  shift g confARGV  shift g_opt= ","ARGV  shARGV  shift ft "]}," ToplevelInstaller parsearg_no_options":{"type":"method","name":"parsearg_no_options","children":[],"call":[" setup_rb_error ","ARGV  join "," task ","ARGV  empty? "]}," ToplevelInstaller valid_task_re":{"type":"method","name":"valid_task_re","children":[],"call":["(send\n  (const nil :TASKS) :map) join ","TASKS  map "]}," ToplevelInstaller valid_task?":{"type":"method","name":"valid_task?","children":[],"call":[" valid_task_re =~ "," valid_task_re "]}," ToplevelInstaller parsearg_global":{"type":"method","name":"parsearg_global","children":[],"call":[" setup_rb_error "," exit "," puts ","File  basename "," print_usage ","@config verbose= "," valid_task? ","ARGV  shift "]}," ToplevelInstaller relpath":{"type":"method","name":"relpath","children":[],"call":[]}," ToplevelInstaller objdir_root":{"type":"method","name":"objdir_root","children":[],"call":[]}," ToplevelInstaller srcdir_root":{"type":"method","name":"srcdir_root","children":[],"call":[]}," ToplevelInstaller init_installers":{"type":"method","name":"init_installers","children":[],"call":["Installer  new ","File  expand_path "]}," ToplevelInstaller run_metaconfigs":{"type":"method","name":"run_metaconfigs","children":[],"call":["@config load_script "]}," ToplevelInstaller invoke":{"type":"method","name":"invoke","children":[],"call":[" __send__ "," init_installers ","@config load_savefile ","File  exist? ","@config savefile "," exec_install "," exec_setup "," exec_config "," parsearg_config "," parsearg_global "," run_metaconfigs "]}," ToplevelInstaller inspect":{"type":"method","name":"inspect","children":[],"call":[" __id__ "," class "]}," ToplevelInstaller config":{"type":"method","name":"config","children":[],"call":["@config [] "]}," ToplevelInstaller initialize":{"type":"method","name":"initialize","children":[],"call":["File  expand_path "]}," ToplevelInstaller load_rbconfig":{"type":"method","name":"load_rbconfig","children":[],"call":[]}," ToplevelInstaller multipackage?":{"type":"method","name":"multipackage?","children":[],"call":[]}," HookScriptAPI srcdirectories":{"type":"method","name":"srcdirectories","children":[],"call":["File  dir? ","File  join "," curr_srcdir "," srcentries select "," srcentries "]}," HookScriptAPI srcfiles":{"type":"method","name":"srcfiles","children":[],"call":["File  file? ","File  join "," curr_srcdir "," srcentries select "," srcentries "]}," HookScriptAPI srcentries":{"type":"method","name":"srcentries","children":[],"call":["d to_a - ","d to_a ","Dir  open "," curr_srcdir "]}," HookScriptAPI srcfile?":{"type":"method","name":"srcfile?","children":[],"call":["File  file? "," srcfile "]}," HookScriptAPI srcdirectory?":{"type":"method","name":"srcdirectory?","children":[],"call":["File  dir? "," srcfile "]}," HookScriptAPI srcexist?":{"type":"method","name":"srcexist?","children":[],"call":["File  exist? "," srcfile "]}," HookScriptAPI srcfile":{"type":"method","name":"srcfile","children":[],"call":[" curr_srcdir "]}," HookScriptAPI curr_objdir":{"type":"method","name":"curr_objdir","children":[],"call":[" relpath "," objdir_root "]}," HookScriptAPI curr_srcdir":{"type":"method","name":"curr_srcdir","children":[],"call":[" relpath "," srcdir_root "]}," HookScriptAPI set_config":{"type":"method","name":"set_config","children":[],"call":["@config []= "]}," HookScriptAPI get_config":{"type":"method","name":"get_config","children":[],"call":["@config [] "]}," FileOperations directories_of":{"type":"method","name":"directories_of","children":[],"call":["(send\n  (lvar :d) :select) - ","File  dir? ","d select ","Dir  open "]}," FileOperations files_of":{"type":"method","name":"files_of","children":[],"call":["File  file? ","d select ","Dir  open "]}," FileOperations extdir?":{"type":"method","name":"extdir?","children":[],"call":["File  exist? "]}," FileOperations make":{"type":"method","name":"make","children":[],"call":[" command ","(send nil :config\n  (str \"makeprog\")) compact "," config "]}," FileOperations ruby":{"type":"method","name":"ruby","children":[],"call":[" command "," config "]}," FileOperations command":{"type":"method","name":"command","children":[],"call":[" raise ","(send\n  (lvar :args) :map) join ","a inspect ","args map "," system ","$stderr puts ","args join "," verbose? "]}," FileOperations diff?":{"type":"method","name":"diff?","children":[],"call":["new_content != ","File  binread ","File  exist? "]}," FileOperations install":{"type":"method","name":"install","children":[],"call":["f puts ","realdest sub ","File  open "," objdir_root ","File  chmod ","f write "," rm_f ","File  exist? "," verbose_off "," diff? ","File  binread ","File  join ","File  basename ","File  dir? ","prefix + ","File  expand_path "," no_harm? ","$stderr puts "," verbose? ","File  join  sub ","prefix +  sub "]}," FileOperations remove_file":{"type":"method","name":"remove_file","children":[],"call":["File  unlink ","File  chmod "]}," FileOperations force_remove_file":{"type":"method","name":"force_remove_file","children":[],"call":[" remove_file "]}," FileOperations move_file":{"type":"method","name":"move_file","children":[],"call":["File  unlink ","File  chmod ","File  stat mode ","File  stat ","f write ","File  binread ","File  open ","File  rename "," force_remove_file "]}," FileOperations remove_tree0":{"type":"method","name":"remove_tree0","children":[],"call":["Dir  rmdir "," force_remove_file "," remove_tree0 ","File  dir? "," remove_file ","File  symlink? ","ent == ","Dir  foreach "]}," FileOperations remove_tree":{"type":"method","name":"remove_tree","children":[],"call":[" force_remove_file "," remove_tree0 ","File  dir? "," remove_file ","File  symlink? "]}," FileOperations rm_rf":{"type":"method","name":"rm_rf","children":[],"call":[" remove_tree "," no_harm? ","$stderr puts "," verbose? "]}," FileOperations rm_f":{"type":"method","name":"rm_f","children":[],"call":[" force_remove_file "," no_harm? ","$stderr puts "," verbose? "]}," FileOperations mkdir_p":{"type":"method","name":"mkdir_p","children":[],"call":["Dir  mkdir ","File  dir? ","dirs [] join ","dirs [] ","dirs each_index ","dirs []= ","disk + ","dirs shift ","File  expand_path split ","File  expand_path "," no_harm? ","$stderr puts "," verbose? ","prefix + ","File  expand_path split  [] join ","File  expand_path split  [] ","File  expand_path split  each_index ","File  expand_path split  []= ","dirs shift  + ","File  expand_path split  shift ","File  expand_dirs [] join  split ","File  expand_dirs [] join  "]}," ConfigTable MetaConfigEnvironment declare_packages":{"type":"method","name":"declare_packages","children":[],"call":["@installer packages= "," raise "]}," ConfigTable MetaConfigEnvironment packages":{"type":"method","name":"packages","children":[],"call":["@installer packages "," raise "]}," ConfigTable MetaConfigEnvironment remove_config":{"type":"method","name":"remove_config","children":[],"call":["@config remove "]}," ConfigTable MetaConfigEnvironment set_config_default":{"type":"method","name":"set_config_default","children":[],"call":["@config lookup default= ","@config lookup "]}," ConfigTable MetaConfigEnvironment add_path_config":{"type":"method","name":"add_path_config","children":[],"call":["@config add ","PathItem  new "]}," ConfigTable MetaConfigEnvironment add_bool_config":{"type":"method","name":"add_bool_config","children":[],"call":["@config add ","BoolItem  new "]}," ConfigTable MetaConfigEnvironment add_config":{"type":"method","name":"add_config","children":[],"call":["@config add "]}," ConfigTable MetaConfigEnvironment value_config?":{"type":"method","name":"value_config?","children":[],"call":["@config lookup config_type != ","@config lookup config_type ","@config lookup "]}," ConfigTable MetaConfigEnvironment path_config?":{"type":"method","name":"path_config?","children":[],"call":["@config lookup config_type == ","@config lookup config_type ","@config lookup "]}," ConfigTable MetaConfigEnvironment bool_config?":{"type":"method","name":"bool_config?","children":[],"call":["@config lookup config_type == ","@config lookup config_type ","@config lookup "]}," ConfigTable MetaConfigEnvironment config?":{"type":"method","name":"config?","children":[],"call":["@config key? "]}," ConfigTable MetaConfigEnvironment config_names":{"type":"method","name":"config_names","children":[],"call":["@config names "]}," ConfigTable MetaConfigEnvironment intiailize":{"type":"method","name":"intiailize","children":[],"call":[]}," ConfigTable PackageSelectionItem check":{"type":"method","name":"check","children":[],"call":[" setup_rb_error ","File  dir? "]}," ConfigTable PackageSelectionItem config_type":{"type":"method","name":"config_type","children":[],"call":[]}," ConfigTable PackageSelectionItem initialize":{"type":"method","name":"initialize","children":[],"call":[]}," ConfigTable ExecItem evaluate":{"type":"method","name":"evaluate","children":[],"call":["@action call "," setup_rb_error ","@ok include? ","val strip downcase ","val strip ","val strip downcase al strip downcase ","val strip downcase al strip "]}," ConfigTable ExecItem resolve":{"type":"method","name":"resolve","children":[],"call":[" setup_rb_error "," name "]}," ConfigTable ExecItem value?":{"type":"method","name":"value?","children":[],"call":[]}," ConfigTable ExecItem config_type":{"type":"method","name":"config_type","children":[],"call":[]}," ConfigTable ExecItem initialize":{"type":"method","name":"initialize","children":[],"call":["selection split "]}," ConfigTable SelectItem check":{"type":"method","name":"check","children":[],"call":["val strip "," setup_rb_error ","@ok include? "]}," ConfigTable SelectItem config_type":{"type":"method","name":"config_type","children":[],"call":[]}," ConfigTable SelectItem initialize":{"type":"method","name":"initialize","children":[],"call":["selection split "]}," ConfigTable ProgramItem config_type":{"type":"method","name":"config_type","children":[],"call":[]}," ConfigTable PathItem check":{"type":"method","name":"check","children":[],"call":["File  expand_path ","path [] == ","path [] "," setup_rb_error "]}," ConfigTable PathItem config_type":{"type":"method","name":"config_type","children":[],"call":[]}," ConfigTable BoolItem check":{"type":"method","name":"check","children":[],"call":[" value "," setup_rb_error "]}," ConfigTable BoolItem help_opt":{"type":"method","name":"help_opt","children":[],"call":[]}," ConfigTable BoolItem config_type":{"type":"method","name":"config_type","children":[],"call":[]}," ConfigTable Item check":{"type":"method","name":"check","children":[],"call":[" setup_rb_error "," name "]}," ConfigTable Item set":{"type":"method","name":"set","children":[],"call":[" check "]}," ConfigTable Item resolve":{"type":"method","name":"resolve","children":[],"call":["table [] ","@value gsub "]}," ConfigTable Item value":{"type":"method","name":"value","children":[],"call":[]}," ConfigTable Item value?":{"type":"method","name":"value?","children":[],"call":[]}," ConfigTable Item help_opt":{"type":"method","name":"help_opt","children":[],"call":[]}," ConfigTable Item initialize":{"type":"method","name":"initialize","children":[],"call":["name freeze "]}," ConfigTable value_config?":{"type":"method","name":"value_config?","children":[],"call":[" lookup value? "," lookup "]}," ConfigTable dllext":{"type":"method","name":"dllext","children":[],"call":["@rbconfig [] "]}," ConfigTable parse_opt":{"type":"method","name":"parse_opt","children":[],"call":["m to_a [] ","m to_a "," setup_rb_error ","@options_re match ","@options_re match  to_a [] ","@options_re match  to_a ","@options_re @options_re match atch "]}," ConfigTable fixup":{"type":"method","name":"fixup","children":[],"call":["@table keys join ","@table keys ","@table freeze ","@items freeze ","@table []= ","@table [] ","ALIASES  each "]}," ConfigTable multipackage_entries":{"type":"method","name":"multipackage_entries","children":[],"call":["PackageSelectionItem  new "]}," ConfigTable load_multipackage_entries":{"type":"method","name":"load_multipackage_entries","children":[],"call":[" add "," multipackage_entries each "," multipackage_entries "]}," ConfigTable standard_entries":{"type":"method","name":"standard_entries","children":[],"call":["BoolItem  new ","SelectItem  new ","ProgramItem  new ","PathItem  new ","parameterize call ","c [] ","table []= ","ENV  [] "," setup_rb_error ","ExecItem  new ","arg sub split [] ","arg sub split ","arg sub ","c [] split detect ","c [] split ","path sub ","Regexp  quote "," lambda ","teeny >= ","minor == ","minor >= ","major == ","major >= ","c [] to_i ","c [] + + ","c [] + ","c [] to_i  >= ","c [] to_i  == "]}," ConfigTable load_standard_entries":{"type":"method","name":"load_standard_entries","children":[],"call":[" add "," standard_entries each "," standard_entries "]}," ConfigTable save":{"type":"method","name":"save","children":[],"call":["f printf ","i value ","i name ","i value? ","@items each ","File  open "," savefile "]}," ConfigTable load_savefile":{"type":"method","name":"load_savefile","children":[],"call":[" setup_rb_error ","$! message + ","File  basename ","$! message "," []= ","v strip ","line split ","File  foreach "," savefile "]}," ConfigTable savefile":{"type":"method","name":"savefile","children":[],"call":[]}," ConfigTable load_script":{"type":"method","name":"load_script","children":[],"call":["MetaConfigEnvironment  new instance_eval ","File  read ","MetaConfigEnvironment  new ","File  file? "]}," ConfigTable remove":{"type":"method","name":"remove","children":[],"call":["i name == ","i name ","@table delete_if ","@items delete_if "," lookup ","@ lookup s delete_if "]}," ConfigTable add":{"type":"method","name":"add","children":[],"call":["@table []= ","item name ","@items push "]}," ConfigTable lookup":{"type":"method","name":"lookup","children":[],"call":[" setup_rb_error ","@table [] "]}," ConfigTable key?":{"type":"method","name":"key?","children":[],"call":["@table key? "]}," ConfigTable each":{"type":"method","name":"each","children":[],"call":["@items each "]}," ConfigTable names":{"type":"method","name":"names","children":[],"call":["i name ","@items map "]}," ConfigTable []=":{"type":"method","name":"[]=","children":[],"call":[" lookup set "," lookup "]}," ConfigTable []":{"type":"method","name":"[]","children":[],"call":[" lookup resolve "," lookup "]}," ConfigTable no_harm?":{"type":"method","name":"no_harm?","children":[],"call":[]}," ConfigTable verbose?":{"type":"method","name":"verbose?","children":[],"call":[]}," ConfigTable initialize":{"type":"method","name":"initialize","children":[],"call":[]}," dir?":{"type":"method","name":"dir?","children":[],"call":[]}," binread":{"type":"method","name":"binread","children":[],"call":[]}," read":{"type":"method","name":"read","children":[],"call":[]}," PoorPriorityQueue delete":{"type":"method","name":"delete","children":[],"call":[" [] "," has_key? "]}," PoorPriorityQueue delete_min_return_priority":{"type":"method","name":"delete_min_return_priority","children":[],"call":[" delete_min [] "," delete_min "]}," PoorPriorityQueue delete_min_return_key":{"type":"method","name":"delete_min_return_key","children":[],"call":[" delete_min [] "," delete_min "]}," PoorPriorityQueue delete_min":{"type":"method","name":"delete_min","children":[],"call":[" delete "," min "," empty? "]}," PoorPriorityQueue min_priority":{"type":"method","name":"min_priority","children":[],"call":[" min [] "," min "]}," PoorPriorityQueue min_key":{"type":"method","name":"min_key","children":[],"call":[" min [] "," min "]}," PoorPriorityQueue min":{"type":"method","name":"min","children":[],"call":["p < "," each "," [] "," keys first "," keys "," empty? "]}," PoorPriorityQueue push":{"type":"method","name":"push","children":[],"call":[" []= "]}," dijkstra":{"type":"method","name":"dijkstra","children":[],"call":["parents []= ","active []= ","distances []= ","d < ","distances [] ","u neighbours each ","u neighbours ","distance + ","active delete_min ","active empty? ","Hash  new ","1.0 / ","queue_klass new ","Hash  new  []= ","queue_klass new  []= ","distance + istances []= ","distance +  < ","distance + istances [] ","distance + istance + ","active distance + elete_min ","queue_klass new  delete_min ","queue_klass new  empty? "]}," draw_graph":{"type":"method","name":"draw_graph","children":[],"call":[" system ","dot << ","n2 id ","n1 id ","n1 id <= ","n1 neighbours each ","n1 neighbours ","nodes each "," << "," <<  << "]}," make_graph":{"type":"method","name":"make_graph","children":[],"call":["n neighbours << ","n neighbours ","n1 neighbours << ","n1 neighbours ","nodes [] "," rand ","nodes length ","(lvasgn :n1\n  (send\n    (lvar :nodes) :[]\n    (send nil :rand\n      (send\n        (lvar :nodes) :length)))) == ","(send\n  (lvar :degree) :/\n  (int 2)) times ","degree / ","nodes each ","Node  new ","i to_s ","Array  new ","nodes []  neighbours << ","nodes []  neighbours ","(lvasgn :nodes [] \n  (send\n    (lvar :nodes) :[]\n    (send nil :rand\n      (send\n        (lvar :nodes) :length)))) == "]}," Node to_s":{"type":"method","name":"to_s","children":[],"call":[]}," Node inspect":{"type":"method","name":"inspect","children":[],"call":[" to_s "]}," Node initialize":{"type":"method","name":"initialize","children":[],"call":[]}," GRATR UndirectedMultiGraph initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","(or\n  (send\n    (lvar :p) :kind_of?\n    (const nil :Graph))\n  (send\n    (lvar :p) :kind_of?\n    (const nil :Array))) ! ","p kind_of? ","params any? "]}," GRATR UndirectedPseudoGraph initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","(or\n  (send\n    (lvar :p) :kind_of?\n    (const nil :Graph))\n  (send\n    (lvar :p) :kind_of?\n    (const nil :Array))) ! ","p kind_of? ","params any? "]}," GRATR UndirectedGraph triangulated_chromatic_number":{"type":"method","name":"triangulated_chromatic_number","children":[],"call":["(lvar :chi) max ","x size + ","x size ","s [] < ","s [] ","s []= ","(send\n  (lvar :s) :[]\n  (lvar :u)) max ","x size - ","sigma [] ","(send\n  (lvar :x) :map) min ","inv_sigma [] ","x map ","x empty? ","inv_sigma [] < "," adjacent select "," adjacent ","sigma each ","acc []= ","sigma index ","sigma inject "," lexicograph_bfs ","h []= ","Hash  new ","(lvar :(lvar :chi) max ) max ","(send\n  (lvar :s) :[]\n  (lvar :sigma [] )) max "," lexicograph_bfs  [] ","inv_ lexicograph_bfs  [] ","inv_ lexicograph_bfs  [] < "," lexicograph_bfs  each "," lexicograph_bfs  index "," lexicograph_bfs  inject "]}," GRATR UndirectedGraph split?":{"type":"method","name":"split?","children":[],"call":[" complement triangulated? "," complement "," triangulated? "]}," GRATR UndirectedGraph permutation?":{"type":"method","name":"permutation?","children":[],"call":[" complement comparability? "," complement "," comparability? "]}," GRATR UndirectedGraph interval?":{"type":"method","name":"interval?","children":[],"call":[" complement comparability? "," complement "," triangulated? "]}," GRATR UndirectedGraph chromatic_number":{"type":"method","name":"chromatic_number","children":[],"call":[" raise "," triangulated_chromatic_number "," triangulated? "]}," GRATR UndirectedGraph triangulated?":{"type":"method","name":"triangulated?","children":[],"call":[" adjacent? ","a [] all? ","a [] ","a [] merge ","x - ","sigma [] ","(send\n  (lvar :x) :map) min ","inv_sigma [] ","x map ","x empty? ","inv_sigma [] < "," adjacent select "," adjacent ","sigma [] each ","acc []= ","sigma index ","sigma inject "," lexicograph_bfs ","h []= ","Set  new ","Hash  new "," lexicograph_bfs  [] ","inv_ lexicograph_bfs  [] ","inv_ lexicograph_bfs  [] < "," lexicograph_bfs  [] each "," lexicograph_bfs  index "," lexicograph_bfs  inject "]}," GRATR UndirectedGraph remove_edge!":{"type":"method","name":"remove_edge!","children":[],"call":["u reverse ","u source == ","u target ","u source "," edge_class [] "," edge_class "," raise ","u kind_of? "," edge_class []  reverse "," edge_class []  so edge_class [] rce == "," edge_class []  target "," edge_class []  so edge_class [] rce "," edge_class []  kind_of? "]}," GRATR UndirectedGraph edge_class":{"type":"method","name":"edge_class","children":[],"call":[]}," GRATR UndirectedGraph balanced?":{"type":"method","name":"balanced?","children":[],"call":[]}," GRATR UndirectedGraph degree":{"type":"method","name":"degree","children":[],"call":[" in_degree "]}," GRATR UndirectedGraph directed?":{"type":"method","name":"directed?","children":[],"call":[]}," GRATR UndirectedGraph initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","(or\n  (send\n    (lvar :p) :kind_of?\n    (const\n      (const nil :GRATR) :Graph))\n  (send\n    (lvar :p) :kind_of?\n    (const nil :Array))) ! ","p kind_of? ","params any? "," class == "," class "]}," GRATR Graph StrongComponents gratr_inner_transitive_closure!":{"type":"method","name":"gratr_inner_transitive_closure!","children":[],"call":[" add_edge! "," edge? "," adjacent each "," adjacent "," topsort reverse each "," topsort reverse "," topsort "]}," GRATR Graph StrongComponents transitive_closure":{"type":"method","name":"transitive_closure","children":[],"call":[" class new transitive_closure! "," class new "," class "]}," GRATR Graph StrongComponents transitive_closure!":{"type":"method","name":"transitive_closure!","children":[],"call":[" add_edge! ","adj each ","cgv each ","cgtc adjacent each ","cgtc adjacent ","cgtc each "," condensation gratr_inner_transitive_closure! "," condensation "," condensation gratr_inner_transitive_closure!  adjacent each "," condensation gratr_inner_transitive_closure!  adjacent "," condensation gratr_inner_transitive_closure!  each "]}," GRATR Graph StrongComponents condensation":{"type":"method","name":"condensation","children":[],"call":["cg add_edge! ","map [] ","c == "," adjacent each "," adjacent ","c each ","sc each ","a []= ","sc inject "," class new "," class "," strong_components "," class new  add_edge! "," strong_components  each "," strong_components  inject "]}," GRATR Graph StrongComponents strong_components":{"type":"method","name":"strong_components","children":[],"call":[" dfs ","result << ","component << ","comp []= ","stack pop ","w == ","root [] == ","root [] ","root []= ","number [] < ","number [] ","comp [] == ","comp [] "," adjacent each "," adjacent ","Proc  new ","stack push ","number []= ","stack pop  == ","Proc  nestack pop  "]}," GRATR Graph Search cyclic?":{"type":"method","name":"cyclic?","children":[],"call":[" acyclic? ! "," acyclic? "]}," GRATR Graph Search acyclic?":{"type":"method","name":"acyclic?","children":[],"call":[" topsort size == "," size "," topsort size "," topsort "]}," GRATR Graph Search topsort":{"type":"method","name":"topsort","children":[],"call":["block call ","result each "," dfs "," vertices [] "," vertices ","result unshift ","Proc  new "]}," GRATR Graph Search gratr_search_iteration":{"type":"method","name":"gratr_search_iteration","children":[],"call":["color_map []= ","options handle_vertex ","options handle_edge "," gratr_search_iteration ","waiting push ","color_map [] ","visited_edges []= ","e target ","e reverse ","e source == ","e source "," directed? ","(send\n  (send\n    (lvar :adj_proc) :call\n    (lvar :u)\n    (hash\n      (pair\n        (sym :type)\n        (sym :edges))\n      (pair\n        (sym :direction)\n        (sym :out)))) :reject) each ","visited_edges [] ","adj_proc call reject ","adj_proc call "," method to_proc "," method ","options [] ","result << ","waiting next ","options handle_e target ertex ","options handle reverse _ve reverse rte reverse x ","options handle reverse _e reverse dge reverse  "," gratr_se reverse arch_ite reverse ration ","waiting pwaiting next sh ","e target isited_edges []= ","visite reverse d_e reverse dge reverse s []= ","e reverse  targe reverse t ","e ree target erse ","e reverse  re reverse ve reverse rse reverse  ","e reverse  source reverse  == ","e sowaiting next rce == ","e reverse  source reverse  ","e sowaiting next rce "," dire reverse cte reverse d? ","(send\n  (send\n    (le target ar :adj_proc) :call\n    (le target ar :u)\n    (hash\n      (pair\n        (sym :type)\n        (sym :edges))\n      (pair\n        (sym :direction)\n        (sym :out)))) :reject) each ","(se reverse nd\n  (se reverse nd\n    (lvar :adj_proc) :call\n    (lvar :u)\n    (hash\n      (pair\n        (sym :type reverse )\n        (sym :e reverse dge reverse s))\n      (pair\n        (sym :dire reverse ction)\n        (sym :out)))) :re reverse je reverse ct) e reverse ach ","(send\n  (send\n    (lvar :adj_proc) :call\n    (lvar :waiting next )\n    (hash\n      (pair\n        (sym :type)\n        (sym :edges))\n      (pair\n        (sym :direction)\n        (sym :owaiting next t)))) :reject) each ","e target isited_edges [] ","visite reverse d_e reverse dge reverse s [] ","adj_proc call re reverse je reverse ct "," me reverse thod to_proc "," me reverse thod ","re reverse sult << ","reswaiting next lt << ","waiting ne reverse xt "]}," GRATR Graph Search gratr_search_helper":{"type":"method","name":"gratr_search_helper","children":[],"call":["options handle_vertex ","u [] ","waiting push ","value == ","color_map detect "," gratr_search_iteration ","op == ","waiting empty? ","waiting [] ","color_map merge! ","a []= "," vertices inject "," vertices ","waiting instance_eval ","op to_s ","options [] ","options instance_eval ","(pair\n  (sym :enter_vertex)\n  (lvar :block)) merge "," to_a [] "," to_a "," size == "," size ","(pair\n  (sym :enter_vertex)\n  (lvar :block)) merge  handle_vertex ","(pair\n  (sym :enter_vertex)\n  (lvar :block)) merge  [] ","(pair\n  (sym :enter_vertex)\n  (lvar :block)) merge  instance_eval "]}," GRATR Graph Search method_missing":{"type":"method","name":"method_missing","children":[],"call":[" pre_search_method_missing "," bfs ","(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge ","m2 captures [] to_sym ","m2 captures [] ","m2 captures ","args [] ","(str \"^bfs_(\\\\w+)$\") match ","sym to_s "," dfs ","m1 captures [] to_sym ","m1 captures [] ","m1 captures ","(str \"^dfs_(\\\\w+)$\") match ","(str \"^bfs_(\\w+)$\") match  captures [] to_sym ","(str \"^bfs_(\\w+)$\") match  captures [] ","(str \"^bfs_(\\w+)$\") match  captures ","(str \"^dfs_(\\w+)$\") match  captures [] to_sym ","(str \"^dfs_(\\w+)$\") match  captures [] ","(str \"^dfs_(\\w+)$\") match  captures "]}," GRATR Graph Search best_first":{"type":"method","name":"best_first","children":[],"call":[" astar ","Proc  new "]}," GRATR Graph Search astar":{"type":"method","name":"astar","children":[],"call":["options handle_callback ","color []= ","block call ","queue push ","f [] ","color [] == ","color [] ","parent []= ","f []= ","d [] + ","func call ","d [] ","d []= ","w + ","(send\n  (lvar :w) :+\n  (send\n    (lvar :d) :[]\n    (lvar :u))) < ","d [] nil? "," raise "," cost ","options [] ","e source ","e target ","e source == "," adjacent each "," adjacent ","solution reverse ","parent [] ","solution << ","u != ","u == ","queue delete_min ","queue empty? ","PriorityQueue  new push ","PriorityQueue  new ","Hash  new ","options instance_eval ","qparent [] eparent [] e pparent [] sh ","PriorityQueue  new push  push ","fparent [] nc call "," cost  + ","(send\n  (lvar : cost ) :+\n  (send\n    (lvar :d) :[]\n    (lvar :u))) < ","(send\n  (le source ar :w) :+\n  (send\n    (le source ar :d) :[]\n    (le source ar :u))) < ","(send\n  (le target ar :w) :+\n  (send\n    (le target ar :d) :[]\n    (le target ar :u))) < ","(send\n  (lvar :w) :+\n  (send\n    (lvar :d) :[]\n    (lvar :parent [] ))) < ","e soparent [] rce ","e soparent [] rce == ","solution ree source erse ","solution ree target erse ","solparent [] tion reverse ","solparent [] tion << ","parent []  != ","parent []  == ","qparent [] eparent [] e delete_min ","PriorityQueue  new push  delete_min ","qparent [] eparent [] e empty? ","PriorityQueue  new push  empty? ","PriorityQueue  ne cost  push ","PriorityQparent [] eparent [] e  new pparent [] sh ","PriorityQueue  ne cost  ","PriorityQparent [] eparent [] e  new ","Hash  ne cost  ","options instance_ee source al ","options instance_ee target al "]}," GRATR Graph Search lexicograph_bfs":{"type":"method","name":"lexicograph_bfs","children":[],"call":["block call ","result each ","lex_q add_lexeme "," adjacent ","result unshift ","lex_q pop "," num_vertices times "," num_vertices ","GRATR Graph Search LexicographicQueue  new "," vertices ","GRATR Graph Search LexicographicQueue  new  add_lexeme ","GRATR Graph Search LexicographicQueue  new  pop "," num_lex_q pop ertices times "," num_lex_q pop ertices "," lex_q pop ertices "]}," GRATR Graph Search LexicographicQueue add_lexeme":{"type":"method","name":"add_lexeme","children":[],"call":["e [] []= ","e [] ","(send\n  (send\n    (lvar :fix) :keys) :select) each ","n [] size == ","n [] size ","n [] ","fix keys select ","fix keys ","@set []= ","sw [] delete ","sw [] ","s_prime [] << ","s_prime [] ","fix []= ","sw []= ","sw [] []= ","@tail == ","s_prime instance_eval ","@node new ","fix [] ","@set [] ","(send\n  (lvar :values) :select) each ","values select ","@set []  [] delete ","@set []  [] ","@node new  [] << ","sw []  [] << ","@node new  [] ","sw []  [] ","@set []  []= ","@set []  [] []= ","@node new  instance_eval ","sw []  instance_eval "]}," GRATR Graph Search LexicographicQueue pop":{"type":"method","name":"pop","children":[],"call":["@set delete ","@tail [] ","@tail [] size == ","@tail [] size ","@tail [] pop ","@tail []  [] ","@tail []  [] size == ","@tail []  [] size ","@tail []  [] pop "]}," GRATR Graph Search LexicographicQueue initialize":{"type":"method","name":"initialize","children":[{"type":"method","name":"hash","children":[],"asgn":[],"call":[]}],"call":["@set []= ","values each ","@tail instance_eval ","@node new ","Array  new ","@node class_eval ","Struct  new ","@node new  instance_eval ","Struct  new  new ","Struct  new  class_eval "]}," GRATR Graph Search bfs_tree_from_vertex":{"type":"method","name":"bfs_tree_from_vertex","children":[],"call":[" tree_from_vertex "]}," GRATR Graph Search dfs_tree_from_vertex":{"type":"method","name":"dfs_tree_from_vertex","children":[],"call":[" tree_from_vertex "]}," GRATR Graph Search tree_from_vertex":{"type":"method","name":"tree_from_vertex","children":[],"call":[" send ","v == ","Proc  new ","predecessor []= ","e source ","e target "]}," GRATR Graph Search bfs_spanning_forest":{"type":"method","name":"bfs_spanning_forest","children":[],"call":[" spanning_forest "]}," GRATR Graph Search dfs_spanning_forest":{"type":"method","name":"dfs_spanning_forest","children":[],"call":[" spanning_forest "]}," GRATR Graph Search spanning_forest":{"type":"method","name":"spanning_forest","children":[],"call":[" send ","roots << ","Proc  new ","predecessor []= ","e source ","e target "]}," GRATR Graph Search dfs":{"type":"method","name":"dfs","children":[],"call":[" gratr_search_helper "]}," GRATR Graph Search bfs":{"type":"method","name":"bfs","children":[],"call":[" gratr_search_helper "]}," GRATR GraphAPI chromatic_number":{"type":"method","name":"chromatic_number","children":[],"call":[" raise "]}," GRATR GraphAPI edge_class":{"type":"method","name":"edge_class","children":[],"call":[" raise "]}," GRATR GraphAPI edges":{"type":"method","name":"edges","children":[],"call":[" raise "]}," GRATR GraphAPI vertices":{"type":"method","name":"vertices","children":[],"call":[" raise "]}," GRATR GraphAPI remove_edge!":{"type":"method","name":"remove_edge!","children":[],"call":[" raise "]}," GRATR GraphAPI remove_vertex!":{"type":"method","name":"remove_vertex!","children":[],"call":[" raise "]}," GRATR GraphAPI add_edge!":{"type":"method","name":"add_edge!","children":[],"call":[" raise "]}," GRATR GraphAPI add_vertex!":{"type":"method","name":"add_vertex!","children":[],"call":[" raise "]}," GRATR GraphAPI directed?":{"type":"method","name":"directed?","children":[],"call":[" raise "]}," GRATR ArcNumber included":{"type":"method","name":"included","children":[{"type":"method","name":"[]","children":[],"asgn":[],"call":[]}],"call":[]}," GRATR ArcNumber ==":{"type":"method","name":"==","children":[],"call":[" eql? "]}," GRATR ArcNumber eql?":{"type":"method","name":"eql?","children":[],"call":[" number == ","rhs number "," number "," number nil? ","rhs number nil? "]}," GRATR ArcNumber inspect":{"type":"method","name":"inspect","children":[],"call":[" label inspect "," label "," number inspect "," number "," target inspect "," target "," source inspect "," source "," class to_s "," class "]}," GRATR ArcNumber <=>":{"type":"method","name":"<=>","children":[],"call":[" number <=> ","rhs number "," number ","(lvasgn :result\n  (super\n    (lvar :rhs))) == "]}," GRATR ArcNumber to_s":{"type":"method","name":"to_s","children":[],"call":[" + "," number "]}," GRATR ArcNumber hash":{"type":"method","name":"hash","children":[],"call":[" ^ "," number hash "," number "]}," GRATR ArcNumber reverse":{"type":"method","name":"reverse","children":[],"call":[" class new "," label "," number "," source "," target "," class "]}," GRATR ArcNumber initialize":{"type":"method","name":"initialize","children":[],"call":[" number= "]}," GRATR Edge to_s":{"type":"method","name":"to_s","children":[],"call":["(lvar :s) max ","(lvar :s) min "," target to_s "," target "," source to_s "," source "," label to_s "," label ","(lvar : source to_s ) max ","(lvar : source to_s ) min ","  target to_s arge target to_s   target to_s o_s "," target to_ source to_s  ","  target to_s arge target to_s  "," source  target to_s o_s ","  source to_s ource to_ source to_s  ","  source to_s ource "," label  target to_s o_s "," label to_ source to_s  "]}," GRATR Edge <=>":{"type":"method","name":"<=>","children":[],"call":["(send\n  (array\n    (send nil :source)\n    (send nil :target)) :max) <=> ","(send\n  (lvar :rhs) :source) min ","rhs target ","rhs source ","(send\n  (lvar :rhs) :source) max ","(send nil :source) min "," target "," source ","(send nil :source) max "]}," GRATR Edge hash":{"type":"method","name":"hash","children":[],"call":[" source hash ^ "," target hash "," target "," source hash "," source "]}," GRATR Edge eql?":{"type":"method","name":"eql?","children":[],"call":[" source == ","other target "," source "," target == ","other source "," target "," class == ","other class "," class "]}," GRATR Arc inspect":{"type":"method","name":"inspect","children":[],"call":[" label inspect "," label "," target inspect "," target "," source inspect "," source "," class to_s "," class "]}," GRATR Arc []":{"type":"method","name":"[]","children":[],"call":[]}," GRATR Arc hash":{"type":"method","name":"hash","children":[],"call":[" source hash ^ "," target hash + "," target hash "," target "," source hash "," source "]}," GRATR Arc to_s":{"type":"method","name":"to_s","children":[],"call":[" target "," source "," label to_s "," label "]}," GRATR Arc <=>":{"type":"method","name":"<=>","children":[],"call":["(send nil :source) <=> ","rhs target ","rhs source "," target "," source "]}," GRATR Arc reverse":{"type":"method","name":"reverse","children":[],"call":[" class new "," label "," source "," target "," class "]}," GRATR Arc eql?":{"type":"method","name":"eql?","children":[],"call":[" source == ","other source "," source "," target == ","other target "," target "," class == ","other class "," class "]}," GRATR Arc initialize":{"type":"method","name":"initialize","children":[],"call":[]}," GRATR Graph write_to_graphic_file":{"type":"method","name":"write_to_graphic_file","children":[],"call":[" system ","f << << ","f << "," to_dot ","File  open ","dotfile + + ","dotfile + "," to_dotfile + +  ","dotfile + + file + + ","dotfile + + file + "]}," GRATR Graph dotty":{"type":"method","name":"dotty","children":[],"call":[" system ","f << "," to_dot ","File  open "]}," GRATR Graph to_dot":{"type":"method","name":"to_dot","children":[],"call":[" to_dot_graph to_s "," to_dot_graph "]}," GRATR Graph to_dot_graph":{"type":"method","name":"to_dot_graph","children":[],"call":["graph << ","edge_klass new ","params merge! ","e_label kind_of? "," edge_label ","\" + + ","\" + ","e target to_s ","e target ","e source to_s ","e source "," edges each "," edges ","DOT DOTNode  new ","v_label kind_of? "," vertex_label ","v to_s "," vertices each "," vertices "," directed? ","(if\n  (send nil :directed?)\n  (const\n    (const nil :DOT) :DOTDigraph)\n  (const\n    (const nil :DOT) :DOTSubgraph)) new ","params [] "," class name gsub "," class name "," class ","(if\n  (send nil :directed?)\n  (const\n    (const nil :DOT) :DOTDigraph)\n  (const\n    (const nil :DOT) :DOTSubgraph)) new  << "," edge_label  kind_of? "," edg edge_label  "," vertex_label  kind_of? ","(if\n  (send nil :directed?)\n  (const\n    (const nil :DOT) :DOTDi(if\n  (send nil :directed?)\n  (const\n    (const nil :DOT) :DOTDigraph)\n  (const\n    (const nil :DOT) :DOTSubgraph)) new )\n  (const\n    (const nil :DOT) :DOTSub(if\n  (send nil :directed?)\n  (const\n    (const nil :DOT) :DOTDigraph)\n  (const\n    (const nil :DOT) :DOTSubgraph)) new )) new "," class v to_s  gsub "," class v to_s  "]}," GRATR Graph Distance floyd_warshall":{"type":"method","name":"floyd_warshall","children":[],"call":["c [] [] < ","c [] [] ","c [] ","i == ","c [] []= ","c [] [] + ","path [] []= ","path [] [] ","path [] ","c [] [] > ","c [] [] nil? "," vertices each "," vertices "," cost ","e target ","e source ","delta [] "," edges each "," edges ","h []= ","Hash  new "]}," GRATR Graph Distance bellman_ford_moore":{"type":"method","name":"bellman_ford_moore","children":[],"call":["path []= ","distance []= ","c < ","distance [] ","distance [] nil? "," cost + "," cost ","e [] "," edges each "," edges ","2 upto "," vertices size "," vertices ","distan cost + e []= "," cost +  < ","distan cost + e [] ","distan cost + e [] nil? ","  cost + ost + ","  cost + ost "," edges ea cost + h "," verti cost + es size "," verti cost + es "]}," GRATR Graph Distance dijkstras_algorithm":{"type":"method","name":"dijkstras_algorithm","children":[],"call":["path []= ","distance []= ","c + ","distance [] ","distance [] > ","distance [] nil? "," cost ","(send\n  (lvar :q) :&\n  (send nil :adjacent\n    (lvar :v))) each ","q & "," adjacent ","q delete ","distance [] < ","a nil? ! ","a nil? ","(send\n  (lvar :q) :&\n  (send\n    (lvar :distance) :keys)) inject ","distance keys ","q empty? ! ","q empty? "," vertices ","distan cost e []= "," cost  + ","distan cost e [] ","distan cost e [] > ","distan cost e [] nil? ","  cost ost ","(send\n  (lvar :q) :&\n  (send nil :adja cost ent\n    (lvar :v))) ea cost h ","(send\n  (lvar : vertices ) :&\n  (send nil :adjacent\n    (lvar :v))) each "," vertices  & "," adja cost ent "," vertices  delete ","distan cost e [] < ","(send\n  (lvar :q) :&\n  (send\n    (lvar :distan cost e) :keys)) inje cost t ","(send\n  (lvar : vertices ) :&\n  (send\n    (lvar :distance) :keys)) inject ","distan cost e keys "," vertices  empty? ! "," vertices  empty? "," verti cost es "]}," GRATR Graph Distance shortest_path":{"type":"method","name":"shortest_path","children":[],"call":["dist keys size == "," vertices size "," vertices ","dist keys size ","dist keys ","a [] <=> ","b [] ","a [] ","(send\n  (send nil :adjacent\n    (lvar :vi)\n    (hash\n      (pair\n        (sym :direction)\n        (sym :in)))) :map) min ","dist [] + "," cost ","dist [] "," adjacent map "," adjacent ","path []= ","dist []= ","vi == "," topsort "]}," GRATR DirectedMultiGraph initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","(or\n  (send\n    (lvar :p) :kind_of?\n    (const\n      (const nil :GRATR) :Graph))\n  (send\n    (lvar :p) :kind_of?\n    (const nil :Array))) ! ","p kind_of? ","params any? "]}," GRATR DirectedPseudoGraph initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","(or\n  (send\n    (lvar :p) :kind_of?\n    (const\n      (const nil :GRATR) :Graph))\n  (send\n    (lvar :p) :kind_of?\n    (const nil :Array))) ! ","p kind_of? ","params any? "]}," GRATR Digraph delta":{"type":"method","name":"delta","children":[],"call":[" out_degree - "," in_degree "," out_degree "]}," GRATR Digraph balanced?":{"type":"method","name":"balanced?","children":[],"call":[" out_degree == "," in_degree "," out_degree "]}," GRATR Digraph oriented?":{"type":"method","name":"oriented?","children":[],"call":["(send\n  (lvar :e) :any?) ! ","re include? ","e any? ","x reverse ","e map "," edges ","(s edges nd\n  (lvar : edges ) :any?) ! ","r edges  includ edges ? "," edges  any? ","x r edges v edges rs edges  "," edges  map ","  edges dg edges s "]}," GRATR Digraph reversal":{"type":"method","name":"reversal","children":[],"call":["result add_vertex! ","result vertex? "," vertices each "," vertices ","a << ","e reverse "," edges inject "," edges "," class new "," class "," class new  add_vertex! "," class new  vertex? "]}," GRATR Digraph edge_class":{"type":"method","name":"edge_class","children":[],"call":[]}," GRATR Digraph directed?":{"type":"method","name":"directed?","children":[],"call":[]}," GRATR Digraph initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","(or\n  (send\n    (lvar :p) :kind_of?\n    (const\n      (const nil :GRATR) :Graph))\n  (send\n    (lvar :p) :kind_of?\n    (const nil :Array))) ! ","p kind_of? ","params any? "," class == "," class "]}," GRATR Graph Comparability gratr_comparability_explore_inner":{"type":"method","name":"gratr_comparability_explore_inner","children":[],"call":[" gratr_comparability_explore ","   + ","classification []= ","classification [] == ","k -@ ","classification [] ","e reverse ","classification [] nil? ","edge [] ","direction == ","(send\n  (send nil :adjacent\n    (send\n      (lvar :edge) :[]\n      (int 0))) :select) each ","(send\n  (lvar :adj_target) :any?) ! ","adj_t == ","adj_target any? ","(or\n  (send\n    (lvar :classification) :[]\n    (array\n      (send\n        (lvar :edge) :[]\n        (int 1))\n      (lvar :mt)))\n  (lvar :k)) abs < ","(or\n  (send\n    (lvar :classification) :[]\n    (array\n      (send\n        (lvar :edge) :[]\n        (int 1))\n      (lvar :mt)))\n  (lvar :k)) abs "," adjacent select "," adjacent ","(send\n  (lvar : adjacent ) :any?) ! "," adjacent  any? "]}," GRATR Graph Comparability gratr_comparability_explore":{"type":"method","name":"gratr_comparability_explore","children":[],"call":[" gratr_comparability_explore_inner ","edge reverse "]}," GRATR Graph Comparability transitive_orientation":{"type":"method","name":"transitive_orientation","children":[],"call":[" raise "]}," GRATR Graph Comparability gamma_decomposition":{"type":"method","name":"gamma_decomposition","children":[],"call":[" gratr_comparability_explore ","classification []= ","k -@ ","e reverse ","classification [] nil? ","classification [] ","(send\n  (send nil :edges) :map) each ","edge target ","edge source "," edges map "," edges "]}," GRATR Graph Comparability comparability?":{"type":"method","name":"comparability?","children":[],"call":[" gamma_decomposition [] "," gamma_decomposition "]}," GRATR Complete edge?":{"type":"method","name":"edge?","children":[],"call":[" vertex? ","v target ","u source ","u kind_of? "]}," GRATR Complete edges":{"type":"method","name":"edges","children":[],"call":["@edges << ","GRATR Edge  [] ","v + ","u + ","@size times "]}," GRATR Complete initialize":{"type":"method","name":"initialize","children":[],"call":[]}," GRATR Cycle edges":{"type":"method","name":"edges","children":[],"call":["GRATR Edge  [] ","i + ","(send\n  (lvar :i) :+\n  (int 1)) == ","Array  new "]}," GRATR Cycle edge?":{"type":"method","name":"edge?","children":[],"call":["u == ","v - == ","v - "," vertex? ","v target ","u source ","u kind_of? "]}," GRATR Cycle vertex?":{"type":"method","name":"vertex?","children":[],"call":["v <= ","v > "]}," GRATR Cycle vertices":{"type":"method","name":"vertices","children":[],"call":["(irange\n  (int 1)\n  (ivar :@size)) to_a "]}," GRATR Cycle directed?":{"type":"method","name":"directed?","children":[],"call":[]}," GRATR Cycle initialize":{"type":"method","name":"initialize","children":[],"call":[]}," GRATR Graph ChinesePostman cp_unbalanced":{"type":"method","name":"cp_unbalanced","children":[],"call":["positive << ","delta [] > ","delta [] ","negative << ","delta [] < "," vertices each "," vertices "]}," GRATR Graph ChinesePostman cp_valid_least_cost?":{"type":"method","name":"cp_valid_least_cost?","children":[],"call":["c [] [] >= ","c [] [] ","c [] "," vertices each "," vertices "]}," GRATR Graph ChinesePostman cp_find_feasible":{"type":"method","name":"cp_find_feasible","children":[],"call":["f [] [] ","f [] ","delta [] ","f [] []= ","delta [] -@ ","delta [] -@ < ","positive each ","negative each ","h []= ","Hash  new "]}," GRATR Graph ChinesePostman cp_improve":{"type":"method","name":"cp_improve","children":[],"call":[" cp_cancel_cycle ","r_cost [] [] < ","r_cost [] [] ","r_cost [] ","residual vertices detect ","residual vertices ","residual floyd_warshall ","residual add_edge! ","cost [] [] -@ ","cost [] [] ","cost [] ","f [] [] != ","f [] [] ","f [] ","positive each ","negative each "," class new "," class "," class new  vertices detect "," class new  vertices "," class new  floyd_warshall "," class new  add_edge! "]}," GRATR Graph ChinesePostman cp_cancel_cycle":{"type":"method","name":"cp_cancel_cycle","children":[],"call":["f [] [] ","f [] ","cost [] [] < ","cost [] [] ","cost [] ","path [] [] ","path [] ","(lvasgn :u\n  (lvar :v)) != ","k > ","k nil? ","(lpath [] [] asgn :u\n  (lpath [] [] ar :path [] [] )) != ","f [] []  > ","f [] []  nil? "]}," GRATR Graph ChinesePostman cp_euler_circuit":{"type":"method","name":"cp_euler_circuit","children":[],"call":["circuit << ","bridge_taken [] []= ","bridge_taken [] ","bridge_taken [] [] ! ","bridge_taken [] [] "," edge? ","v1 != "," vertices detect "," vertices ","path [] [] ","path [] ","u != ","f [] [] ","f [] ","f [] [] > ","f [] keys detect ","f [] keys ","v nil? ","h []= ","Hash  new ","circpath [] [] it << ","path [] [] _taken [] []= ","path [] [] _taken [] ","path [] [] _taken [] [] ! ","path [] [] _taken [] [] ","path [] []  != "]}," GRATR Graph ChinesePostman closed_chinese_postman_tour":{"type":"method","name":"closed_chinese_postman_tour","children":[],"call":[" cp_euler_circuit "," cp_improve "," cp_find_feasible "," cp_unbalanced "," cp_valid_least_cost? "," floyd_warshall "," cp_ cp_find_feasible ind_ cp_find_feasible easible ","  cp_find_feasible loyd_warshall "]}," GRATR Graph Biconnected biconnected":{"type":"method","name":"biconnected","children":[],"call":[" dfs ","articulation << ","predecessor []= ","stack empty? ","component add_edge! ","stack pop ","number [] >= ","number [] ","stack [] source ","stack [] ","result << "," class new "," class ","predecessor [] ","number [] > ","low_point [] >= ","low_point [] ","low_point []= ","(send\n  (lvar :low_point) :[]\n  (lvar :parent)) min ","(send\n  (send\n    (lvar :number) :[]\n    (lvar :u)) :+\n  (int 1)) == ","number [] + ","parent == ","Proc  new ","(send\n  (lvar :low_point) :[]\n  (send\n    (lvar :e) :source)) min ","e target ","e source ","stack push ","e target != ","number []= "," class new  add_edge! ","(send\n  (lvar :low_point) :[]\n  (lvar :predecessor [] )) min ","predecessor []  == "]}," GRATR AdjacencyGraph included":{"type":"method","name":"included","children":[{"type":"method","name":"[]","children":[],"asgn":[],"call":[]}],"call":[]}," GRATR AdjacencyGraph adjacent":{"type":"method","name":"adjacent","children":[],"call":[" graph_adjacent ","@vertex_dict [] to_a ","@vertex_dict [] ","e label= "," [] "," edge_class [] "," edge_class ","@vertex_dict [] map ","@edge_number [] [] ","@edge_number [] ","options [] == ","options [] "," directed? ! "," directed? ","x kind_of? ! ","x kind_of? "," graph_adjac edge_class [] nt ","@v edge_class [] rt edge_class [] x_dict [] to_a ","@v edge_class [] rt edge_class [] x_dict [] "," edge_class []  lab edge_class [] l= ","  edge_class [] dg edge_class [] _class [] ","  edge_class [] dg edge_class [] _class ","@v edge_class [] rt edge_class [] x_dict [] map ","@ edge_class [] dg edge_class [] _numb edge_class [] r [] [] ","@ edge_class [] dg edge_class [] _numb edge_class [] r [] "," dir edge_class [] ct edge_class [] d? ! "," dir edge_class [] ct edge_class [] d? "]}," GRATR AdjacencyGraph edges":{"type":"method","name":"edges","children":[],"call":["(send\n  (send\n    (ivar :@vertex_dict) :keys) :inject\n  (send\n    (const nil :Set) :new)) to_a ","a add "," edge_class [] "," edge_label "," edge_class ","@vertex_dict [] each ","@vertex_dict [] ","w [] ","@vertex_dict [] zip each ","@vertex_dict [] zip ","@edge_number [] ","@vertex_dict keys inject ","Set  new ","@vertex_dict keys "]}," GRATR AdjacencyGraph vertices":{"type":"method","name":"vertices","children":[],"call":["@vertex_dict keys "]}," GRATR AdjacencyGraph remove_edge!":{"type":"method","name":"remove_edge!","children":[],"call":["@vertex_dict [] delete ","u target ","@vertex_dict [] ","u source ","@edge_number [] delete_at ","@edge_number [] ","@vertex_dict [] delete_at "," raise ","@edge_number [] index ","u number "," delete_label ","(or\n  (send\n    (lvar :u) :number)\n  (int 0)) == "," edge_class [] "," edge_class ","u kind_of? "," edge_class []  target "," edge_class []  so edge_class [] rce ","@edge_n edge_class [] mber [] delete_at ","@edge_n edge_class [] mber [] ","@edge_number [] @edge_number [] index  ","@edge_n edge_class [] mber [] index "," edge_class []  n edge_class [] mber ","(or\n  (send\n    (lvar : edge_class [] ) :n edge_class [] mber)\n  (int 0)) == "," edge_class []  kind_of? "]}," GRATR AdjacencyGraph remove_vertex!":{"type":"method","name":"remove_vertex!","children":[],"call":[" delete_label "," edge_class [] "," edge_class ","@vertex_dict keys each ","@vertex_dict keys ","adjList delete ","@vertex_dict each_value ","@vertex_dict delete "]}," GRATR AdjacencyGraph add_edge!":{"type":"method","name":"add_edge!","children":[],"call":[" []= "," edge_class [] "," edge_class ","(or-asgn\n  (send\n    (ivar :@edge_number) :[]\n    (lvar :v))\n  (send\n    (ivar :@edgelist_class) :new)) add ","@edgelist_class new ","@edge_number [] ","@vertex_dict [] add ","@vertex_dict [] "," directed? ","(or-asgn\n  (send\n    (ivar :@edge_number) :[]\n    (lvar :u))\n  (send\n    (ivar :@edgelist_class) :new)) add "," add_vertex! ","u == ","@allow_loops ! ","u label ","u target ","u source ","u kind_of? ","u number ","n nil? ","u class include? ","u class ","(or-asgu number \n  (seu number d\n    (ivar :@edge_u number umber) :[]\n    (lvar :v))\n  (seu number d\n    (ivar :@edgelist_class) :u number ew)) add ","@edgelist_class u number ew ","@edge_u number umber [] ","(or-asgu number \n  (seu number d\n    (ivar :@edge_u number umber) :[]\n    (lvar :u))\n  (seu number d\n    (ivar :@edgelist_class) :u number ew)) add ","u kiu number d_of? ","u u number umber ","u number  u number il? ","u class iu number clude? "]}," GRATR AdjacencyGraph add_vertex!":{"type":"method","name":"add_vertex!","children":[],"call":[" []= ","@edgelist_class new ","@vertex_dict [] "]}," GRATR AdjacencyGraph edge?":{"type":"method","name":"edge?","children":[],"call":["@vertex_dict [] include? ","@vertex_dict [] "," vertex? ","u target ","u source ","u kind_of? "]}," GRATR AdjacencyGraph vertex?":{"type":"method","name":"vertex?","children":[],"call":["@vertex_dict has_key? "]}," GRATR AdjacencyGraph initialize":{"type":"method","name":"initialize","children":[],"call":[" add_edge! ","a [] ","i + ","0 step ","a size - ","a size ","(send\n  (lvar :params) :select) each ","p kind_of? ","params select "," vertex_label_set "," vertex_label ","g vertices each ","g vertices "," edge_label_set "," edge_label ","g edges each ","g edges ","Hash  new ","p == ","params any? "," clear_all_labels "," raise ","(or\n  (or\n    (or\n      (send\n        (lvar :p) :kind_of?\n        (const\n          (const nil :GRATR) :Graph))\n      (send\n        (lvar :p) :kind_of?\n        (const nil :Array)))\n    (send\n      (lvar :p) :==\n      (sym :parallel_edges)))\n  (send\n    (lvar :p) :==\n    (sym :loops))) ! "]}," GRATR Labels property_set":{"type":"method","name":"property_set","children":[],"call":[" [] []= "," [] "," []= ","name call "]}," GRATR Labels cost":{"type":"method","name":"cost","children":[],"call":[" [] [] "," [] ","weight call "," edge_class [] "," edge_class ","u kind_of? "," edge_class []  kind_of? "]}," GRATR Labels edge_label_dict":{"type":"method","name":"edge_label_dict","children":[],"call":[]}," GRATR Labels vertex_label_dict":{"type":"method","name":"vertex_label_dict","children":[],"call":[]}," GRATR Labels vertex_label_delete":{"type":"method","name":"vertex_label_delete","children":[],"call":[" vertex_label_dict delete "," vertex_label_dict "]}," GRATR Labels edge_label_delete":{"type":"method","name":"edge_label_delete","children":[],"call":[" edge_label_dict delete "," edge_label_dict "," edge_convert "]}," GRATR Labels clear_all_labels":{"type":"method","name":"clear_all_labels","children":[],"call":[]}," GRATR Labels edge_label_set":{"type":"method","name":"edge_label_set","children":[],"call":[" edge_label_dict []= "," edge_label_dict "," edge_convert ","u kind_of? "," edge_convert  kind_of? "]}," GRATR Labels edge_label":{"type":"method","name":"edge_label","children":[],"call":[" edge_label_dict [] "," edge_label_dict "," edge_convert "]}," GRATR Labels vertex_label_set":{"type":"method","name":"vertex_label_set","children":[],"call":[" vertex_label_dict []= "," vertex_label_dict "]}," GRATR Labels vertex_label":{"type":"method","name":"vertex_label","children":[],"call":[" vertex_label_dict [] "," vertex_label_dict "]}," GRATR Labels delete_label":{"type":"method","name":"delete_label","children":[],"call":[" vertex_label_delete "," edge_label_delete ","u kind_of? "]}," GRATR Labels []=":{"type":"method","name":"[]=","children":[],"call":[" vertex_label_set "," edge_label_set ","u kind_of? "]}," GRATR Labels []":{"type":"method","name":"[]","children":[],"call":[" vertex_label "," edge_label ","u kind_of? "]}," GRATR Graph edge_convert":{"type":"method","name":"edge_convert","children":[],"call":[" edge_class [] "," edge_class ","args [] ","args [] kind_of? "]}," GRATR Graph inspect":{"type":"method","name":"inspect","children":[],"call":[" class to_s + + + + ",". + "," class to_s + + + "," class to_s + + ","(send\n  (send nil :edges) :map) join ","e inspect "," edges map "," edges "," class to_s + "," class to_s "," class ","(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join "," [] inspect "," [] ","u inspect ","(send\n  (send nil :vertices) :select) map "," vertices select "," vertices "," c(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join ass to_s + + + + "," c(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join ass to_s + + + "," c(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join ass to_s + + ","(send\n  (send ni(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join  :edges) :map) join "," c(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join ass to_s + "," c(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join ass to_s "," c(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join ass ","(send\n  (b(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join ock\n    (send\n      (send ni(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join  :vertices) :se(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join ect)\n    (args\n      (arg :v))\n    (send\n      (se(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join f) :[]\n      ((send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join var :v))) :map) join ","(send\n  (send ni(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join  :vertices) :se(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join ect) map "," vertices se(send\n  (block\n    (send\n      (send nil :vertices) :select)\n    (args\n      (arg :v))\n    (send\n      (self) :[]\n      (lvar :v))) :map) join ect "]}," GRATR Graph induced_subgraph":{"type":"method","name":"induced_subgraph","children":[],"call":["a << ","v include? ","e target ","e source "," edges inject "," class new "," class "," edges "]}," GRATR Graph complement":{"type":"method","name":"complement","children":[],"call":["a add_edge! "," edge? "," vertices each "," vertices ","a add_vertex! "," vertices inject "," class new "," class "]}," GRATR Graph <<":{"type":"method","name":"<<","children":[],"call":[" add_edge! "]}," GRATR Graph -":{"type":"method","name":"-","children":[],"call":[" class new remove_vertex! "," class new "," class "," class new remove_edge! "," induced_subgraph "," vertices - ","other vertices "," vertices "]}," GRATR Graph +":{"type":"method","name":"+","children":[],"call":["result add_vertex! ","result add_edge! ","result merge "," class new "," class "," class new  add_vertex! "," class new  add_edge! "," class new  merge "]}," GRATR Graph merge":{"type":"method","name":"merge","children":[],"call":[" add_edge! ","e reverse ","other edges each ","other edges ","other directed? ! ","other directed? "," directed? "," add_vertex! ","other vertices each ","other vertices "]}," GRATR Graph ==":{"type":"method","name":"==","children":[],"call":[" eql? "]}," GRATR Graph eql?":{"type":"method","name":"eql?","children":[],"call":["g edges sort == "," edges sort "," edges ","g edges sort ","g edges "," vertices sort == ","g vertices sort ","g vertices "," vertices sort "," vertices ","g directed? == "," directed? ","g directed? ","g kind_of? "]}," GRATR Graph to_s":{"type":"method","name":"to_s","children":[],"call":[" edges to_s "," edges "]}," GRATR Graph num_edges":{"type":"method","name":"num_edges","children":[],"call":[" edges size "," edges "]}," GRATR Graph num_vertices":{"type":"method","name":"num_vertices","children":[],"call":[" vertices size "," vertices "]}," GRATR Graph size":{"type":"method","name":"size","children":[],"call":[" vertices size "," vertices "]}," GRATR Graph regular?":{"type":"method","name":"regular?","children":[],"call":[" min_degree == "," max_degree "," min_degree "]}," GRATR Graph max_degree":{"type":"method","name":"max_degree","children":[],"call":["(send nil :max_in_degree) max "," max_out_degree "," max_in_degree "]}," GRATR Graph max_out_degree":{"type":"method","name":"max_out_degree","children":[],"call":["(send\n  (send nil :vertices) :map) max "," out_degree "," vertices map "," vertices "]}," GRATR Graph max_in_degree":{"type":"method","name":"max_in_degree","children":[],"call":["(send\n  (send nil :vertices) :map) max "," in_degree "," vertices map "," vertices "]}," GRATR Graph min_degree":{"type":"method","name":"min_degree","children":[],"call":["(send nil :min_in_degree) min "," min_out_degree "," min_in_degree "]}," GRATR Graph min_out_degree":{"type":"method","name":"min_out_degree","children":[],"call":["(send\n  (send nil :to_a) :map) min "," out_degree "," to_a map "," to_a "]}," GRATR Graph min_in_degree":{"type":"method","name":"min_in_degree","children":[],"call":["(send\n  (send nil :to_a) :map) min "," in_degree "," to_a map "," to_a "]}," GRATR Graph degree":{"type":"method","name":"degree","children":[],"call":[" in_degree + "," out_degree "," in_degree "]}," GRATR Graph in_degree":{"type":"method","name":"in_degree","children":[],"call":[" adjacent size "," adjacent "]}," GRATR Graph out_degree":{"type":"method","name":"out_degree","children":[],"call":[" adjacent size "," adjacent "]}," GRATR Graph open_pth_neighborhood":{"type":"method","name":"open_pth_neighborhood","children":[],"call":[" set_neighborhood - "," closed_pth_neighborhood ","p - "," set_neighborhood "," open_pth_neighborhood ","p == ","p <= "]}," GRATR Graph closed_pth_neighborhood":{"type":"method","name":"closed_pth_neighborhood","children":[],"call":["(send\n  (send\n    (lvar :w) :+\n    (lvar :n)) :+\n  (send nil :closed_pth_neighborhood\n    (lvar :n)\n    (send\n      (lvar :p) :-\n      (int 1))\n    (lvar :direction))) uniq ","w + + "," closed_pth_neighborhood ","p - ","w + "," set_neighborhood ","(send\n  (lvar :w) :+\n  (send nil :set_neighborhood\n    (lvar :w)\n    (lvar :direction))) uniq ","p == ","p <= ","(se set_neighborhood d\n  (se set_neighborhood d\n    (lvar :w) :+\n    (lvar : set_neighborhood )) :+\n  (se set_neighborhood d  set_neighborhood il :closed_pth_ set_neighborhood eighborhood\n    (lvar : set_neighborhood )\n    (se set_neighborhood d\n      (lvar :p) :-\n      (i set_neighborhood t 1))\n    (lvar :directio set_neighborhood ))) u set_neighborhood iq "," closed_pth_ set_neighborhood eighborhood "," set_ set_neighborhood eighborhood ","(se set_neighborhood d\n  (lvar :w) :+\n  (se set_neighborhood d  set_neighborhood il :set_ set_neighborhood eighborhood\n    (lvar :w)\n    (lvar :directio set_neighborhood ))) u set_neighborhood iq "]}," GRATR Graph set_neighborhood":{"type":"method","name":"set_neighborhood","children":[],"call":["x include? ","(send\n  (lvar :x) :inject\n  (send\n    (const nil :Set) :new)) reject ","a merge "," neighborhood ","x inject ","Set  new "]}," GRATR Graph neighborhood":{"type":"method","name":"neighborhood","children":[],"call":[" adjacent ","x kind_of? "]}," GRATR Graph include?":{"type":"method","name":"include?","children":[],"call":[" vertex? "," edge? ","x kind_of? "]}," GRATR Graph empty?":{"type":"method","name":"empty?","children":[],"call":[" vertices size zero? "," vertices size "," vertices "]}," GRATR Graph adjacent?":{"type":"method","name":"adjacent?","children":[],"call":[" edge? ","direction != "," raise "," vertex? ","source == ","target source ","target target ","target kind_of? ","source target == ","source target ","source source == ","source source ","source kind_of? "]}," GRATR Graph edge?":{"type":"method","name":"edge?","children":[],"call":[" edges include? "," edge_convert "," args "," edges "]}," GRATR Graph vertex?":{"type":"method","name":"vertex?","children":[],"call":[" vertices include? "," vertices "]}," GRATR Graph each":{"type":"method","name":"each","children":[],"call":[" vertices each "," vertices "]}," GRATR Graph remove_edges":{"type":"method","name":"remove_edges","children":[],"call":["x remove_edges "," class new "," class "," class new  remove_edges "]}," GRATR Graph remove_edges!":{"type":"method","name":"remove_edges!","children":[],"call":[" remove_edges! ","a each "]}," GRATR Graph remove_vertices":{"type":"method","name":"remove_vertices","children":[],"call":["x remove_vertices "," class new "," class "," class new  remove_vertices "]}," GRATR Graph remove_vertices!":{"type":"method","name":"remove_vertices!","children":[],"call":[" remove_vertex! ","a each "]}," GRATR Graph add_edges":{"type":"method","name":"add_edges","children":[],"call":["x add_edges! "," class new "," class "," class new  add_edges! "]}," GRATR Graph add_edges!":{"type":"method","name":"add_edges!","children":[],"call":[" add_edge! ","args each "]}," GRATR Graph add_vertices":{"type":"method","name":"add_vertices","children":[],"call":["x add_vertices "," class new "," class "," class new  add_vertices "]}," GRATR Graph add_vertices!":{"type":"method","name":"add_vertices!","children":[],"call":[" add_vertex! ","a each "]}," GRATR Graph adjacent":{"type":"method","name":"adjacent","children":[],"call":[" adjacent? ","(if\n  (send\n    (send\n      (lvar :options) :[]\n      (sym :type)) :==\n    (sym :edges))\n  (send nil :edges)\n  (send nil :to_a)) select "," to_a "," edges ","options [] == ","options [] ","x target ","x source ","d == ","options [] != ","x kind_of? "," directed? "]}," GRATR Graph remove_edge":{"type":"method","name":"remove_edge","children":[],"call":["x remove_edge! "," class new "," class "," class new  remove_edge! "]}," GRATR Graph remove_vertex":{"type":"method","name":"remove_vertex","children":[],"call":["x remove_vertex! "," class new "," class "," class new  remove_verte class new ! "]}," GRATR Graph add_edge":{"type":"method","name":"add_edge","children":[],"call":["x add_edge! "," class new "," class "," class new  add_edge! "]}," GRATR Graph add_vertex":{"type":"method","name":"add_vertex","children":[],"call":["x add_vertex! "," class new "," class "," class new  add_verte class new ! "]}}