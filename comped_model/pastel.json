{" Pastel new":{"type":"method","name":"new","children":[],"call":["Delegator  for ","DecoratorChain  empty ","ColorResolver  new ","Color  new ","importer import ","AliasImporter  new ","options merge! ","TTY Color  color? ","options key? ","TTY Color  windows? ","options []= ","Delegator  wrap ","enabled nil? ","AliasImporter  new  import ","TTY Color  Color  new ? "]}," Pastel Delegator respond_to_missing?":{"type":"method","name":"respond_to_missing?","children":[],"call":["@color respond_to? ","@resolver color respond_to? ","@resolver color "," valid? "," resolver color respond_to? "," resolver color "," resolver "," resolver color valid? "]}," Pastel Delegator method_missing":{"type":"method","name":"method_missing","children":[],"call":[" resolver resolve "," resolver ","args empty? "," class new "," class "," base add "," base "," wrap ","string << "," evaluate_block "," block_given? ","args join ","(send\n  (send\n    (lvar :method_name) :to_sym) :==\n  (sym :detach)) ! ","method_name to_sym == ","method_name to_sym ","strings join ","strings << ","args dup ","method_name to_sym != "," class wrap "," chain add "," chain ","args join  << ","args join s join ","args dup  join ","args join s << ","args dup  << "]}," Pastel Delegator for":{"type":"method","name":"for","children":[],"call":[]}," Pastel Delegator initialize":{"type":"method","name":"initialize","children":[],"call":["ColorResolver  new ","Color  new "]}," Pastel DecoratorChain empty":{"type":"method","name":"empty","children":[],"call":[]}," Pastel DecoratorChain each":{"type":"method","name":"each","children":[],"call":[" decorators each "," decorators "]}," Pastel DecoratorChain add":{"type":"method","name":"add","children":[],"call":[" class new "," decorators + "," decorators "," class "," decorators include? "]}," Pastel DecoratorChain initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Pastel ColorResolver resolve":{"type":"method","name":"resolve","children":[],"call":[" color decorate "," color ","base reduce ","args join ","Detached  new ","base to_a [] ","base to_a ","base to_a last == ","base to_a last "]}," Pastel ColorResolver initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Pastel Color validate":{"type":"method","name":"validate","children":[],"call":[" fail "," style_names join "," style_names "," valid? "," raise "]}," Pastel Color valid?":{"type":"method","name":"valid?","children":[],"call":[" style_names include? ","color to_sym "," style_names ","colors all? "]}," Pastel Color style_names":{"type":"method","name":"style_names","children":[],"call":[" styles keys "," styles "]}," Pastel Color styles":{"type":"method","name":"styles","children":[],"call":["acc []= "," lookup ","col to_sym downcase ","col to_sym ","ANSI  constants each_with_object ","ANSI  constants ","ANSI ATTRIBUTES  merge "]}," Pastel Color lookup":{"type":"method","name":"lookup","children":[],"call":[" class const_get ","color to_s upcase ","color to_s "," class ","attribute join "," code ","@cache []= "," code join ","@cache fetch "," code  join "]}," Pastel Color code":{"type":"method","name":"code","children":[],"call":[" lookup ","colors map "," validate ","attribute << ","ALIASES  [] ","ANSI ATTRIBUTES  [] ","colors each "]}," Pastel Color strip":{"type":"method","name":"strip","children":[],"call":["string to_s gsub ","string to_s ","modified [] ","modified size == ","modified size ","string dup gsub ","string dup ","strings map "]}," Pastel Color decorate":{"type":"method","name":"decorate","children":[],"call":["ansi_string sub! ","ansi_colors join ","Regexp  quote ","matches length >= ","matches length ","ansi_string scan ","ansi_string gsub! ","ansi_string =~ "," lookup ","colors map "," validate ","string empty? "," enabled ! "," enabled "," nest_color "," collapse_reset "," clear "," wrap_eachline "," blank? "," apply_codes ","string dup ","(send\n  (send\n    (send\n      (lvar :string) :dup) :split\n    (send nil :eachline)) :map!) join "," eachline ","string dup split map! ","string dup split ","colors empty? ","colors dup uniq ","colors dup "," nest_color  sub! "," wrap_eachline  sub! "," lookup  join ","ansi_string scan  length >= ","ansi_string scan  length "," nest_color  scan "," wrap_eachline  scan "," nest_color  gsub! "," wrap_eachline  gsub! "," nest_color  =~ "," wrap_eachline  =~ "]}," Pastel Color disable!":{"type":"method","name":"disable!","children":[],"call":[]}," Pastel Color initialize":{"type":"method","name":"initialize","children":[],"call":[" supports? ","options fetch "," freeze ","TTY Screen  color? ","options [] "]}," Pastel Delegator wrap":{"type":"method","name":"wrap","children":[],"call":[" class new "," resolver "," class ","DecoratorChain  empty "]}," Pastel Color supports?":{"type":"method","name":"supports?","children":[],"call":["ENV  include? ","ENV  [] =~ ","ENV  [] ","ENV  [] == ","$stdout tty? "]}," Pastel Delegator inspect":{"type":"method","name":"inspect","children":[],"call":[" class name "," class "," base map "," base "," chain map "," chain "]}," Pastel Color alias_color":{"type":"method","name":"alias_color","children":[],"call":["ALIASES  []= ","ANSI ATTRIBUTES  [] ","alias_name to_sym "," fail ","(send\n  (send\n    (lvar :alias_name) :to_s) :=~\n  (regexp\n    (str \"^[\\\\w]+$\")\n    (regopt))) ! ","alias_name to_s =~ ","alias_name to_s "," validate ","colors map ","ANSI ATTRIBUTES  method "," raise "]}," Pastel Color nest_color":{"type":"method","name":"nest_color","children":[],"call":["ansi_string sub! ","Regexp  quote "," clear ","matches length > ","matches length ","ansi_string scan ","string dup "," eachline ! "," eachline ","string dup  sub! ","ansi_string scan  length > ","ansi_string scan  length ","string dup  scan "]}," Pastel Color collapse_reset":{"type":"method","name":"collapse_reset","children":[],"call":["ansi_string gsub! "," clear ","Regexp  quote ","ansi_string =~ ","string dup ","string dup  gsub! ","string dup  =~ "]}," Pastel Color clear":{"type":"method","name":"clear","children":[],"call":[" lookup "]}," Pastel AliasImporter import":{"type":"method","name":"import","children":[],"call":[" color alias_color "," color "," output puts "," output ","old_color ! ","new_color ! ","color_alias split map ","color_alias split ","color_aliases split each ","color_aliases split ","ENV  [] "," env [] "," env ","old_colors split map ","old_colors split ","new_color to_sym ","old_colors ! ","ENV  []  split each "," env []  split each ","ENV  []  split "," env []  split "]}," Pastel AliasImporter initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Pastel Detached call":{"type":"method","name":"call","children":[],"call":["@color decorate "," styles ","args join "]}," Pastel Detached initialize":{"type":"method","name":"initialize","children":[],"call":[" freeze ","styles dup "]}," Pastel Delegator evaluate_block":{"type":"method","name":"evaluate_block","children":[],"call":["delegator instance_eval "," class new ","DecoratorChain  empty "," resolver "," class "," class wrap "," class new  instance_eval "," class wrap  instance_eval "]}," Pastel Color colored?":{"type":"method","name":"colored?","children":[],"call":["ANSI_REGEX  match nil? ! ","ANSI_REGEX  match nil? ","ANSI_REGEX  match ","ANSI_COLOR_REGEXP  match nil? ! ","ANSI_COLOR_REGEXP  match nil? ","ANSI_COLOR_REGEXP  match "]}," Pastel Color wrap_eachline":{"type":"method","name":"wrap_eachline","children":[],"call":[" clear ","(send\n  (send\n    (lvar :string) :split\n    (send nil :eachline)) :map) join "," eachline ","string split map ","string split "]}," Pastel Detached to_proc":{"type":"method","name":"to_proc","children":[],"call":[]}," Pastel Color blank?":{"type":"method","name":"blank?","children":[],"call":["BLANK_REGEX  =~ ","value empty? ","value respond_to? ","value nil? ","value to_s == ","value to_s ","value respond_to? ! "]}," Pastel ColorParser ansi_for":{"type":"method","name":"ansi_for","children":[],"call":[]}," Pastel ColorParser attribute_for":{"type":"method","name":"attribute_for","children":[],"call":[]}," Pastel ColorParser unpack_ansi":{"type":"method","name":"unpack_ansi","children":[],"call":[]}," Pastel ColorParser parse":{"type":"method","name":"parse","children":[],"call":[]}," Pastel Color apply_codes":{"type":"method","name":"apply_codes","children":[],"call":["string gsub "]}," Pastel ANSI style?":{"type":"method","name":"style?","children":[],"call":["(irange\n  (int 1)\n  (int 9)) include? ","code to_i "]}," Pastel ANSI background?":{"type":"method","name":"background?","children":[],"call":["(splat\n  (begin\n    (irange\n      (int 40)\n      (int 47)))) include? ","code to_i "]}," Pastel ANSI foreground?":{"type":"method","name":"foreground?","children":[],"call":["(splat\n  (begin\n    (irange\n      (int 30)\n      (int 37)))) include? ","code to_i "]}," Pastel Detached hash":{"type":"method","name":"hash","children":[],"call":["(send\n  (self) :class) hash "," styles "," class "]}," Pastel Detached inspect":{"type":"method","name":"inspect","children":[],"call":[" styles inspect "," styles "," class name "," class "]}," Pastel Detached ==":{"type":"method","name":"==","children":[],"call":[" styles == ","other styles "," styles ","other is_a? "," class "]}," Pastel Detached eql?":{"type":"method","name":"eql?","children":[],"call":[" styles eql? ","other styles "," styles "," instance_of? ","other class "]}," Pastel Delegator hash":{"type":"method","name":"hash","children":[],"call":["(send\n  (self) :class) hash "," chain "," class "]}," Pastel Delegator ==":{"type":"method","name":"==","children":[],"call":[" chain == ","other chain "," chain ","other is_a? "," class "]}," Pastel Delegator eql?":{"type":"method","name":"eql?","children":[],"call":[" chain eql? ","other chain "," chain "," instance_of? ","other class "]}," Pastel DecoratorChain hash":{"type":"method","name":"hash","children":[],"call":["(send\n  (self) :class) hash "," decorators "," class "]}," Pastel DecoratorChain inspect":{"type":"method","name":"inspect","children":[],"call":[" decorators inspect "," decorators "," class name "," class "]}," Pastel DecoratorChain ==":{"type":"method","name":"==","children":[],"call":[" decorators == ","other decorators "," decorators ","other is_a? "," class "]}," Pastel DecoratorChain eql?":{"type":"method","name":"eql?","children":[],"call":[" decorators eql? ","other decorators "," decorators "," instance_of? ","other class "]}," Pastel ColorParser color_name":{"type":"method","name":"color_name","children":[],"call":[]}," Pastel ColorParser attribute_name":{"type":"method","name":"attribute_name","children":[],"call":[]}," Pastel Color hash":{"type":"method","name":"hash","children":[],"call":["(send\n  (self) :class) hash "," eachline "," enabled "," class "]}," Pastel Color inspect":{"type":"method","name":"inspect","children":[],"call":[" eachline inspect "," eachline "," enabled inspect "," enabled "," class name "," class "]}," Pastel Color ==":{"type":"method","name":"==","children":[],"call":[" eachline == ","other eachline "," eachline "," enabled == ","other enabled "," enabled ","other is_a? "," class "]}," Pastel Color eql?":{"type":"method","name":"eql?","children":[],"call":[" eachline eql? ","other eachline "," eachline "," enabled eql? ","other enabled "," enabled "," instance_of? ","other class "]}}