{" Groupdate inherited_with_groupdate":{"type":"method","name":"inherited_with_groupdate","children":[],"call":["kls send ","kls superclass == ","kls superclass "," inherited_without_groupdate "]}," ActiveRecord Calculations column_alias_for_with_hack":{"type":"method","name":"column_alias_for_with_hack","children":[],"call":[" column_alias_for_without_hack ","keys first is_a? ","keys first ","keys first field "]}," Groupdate OrderHack initialize":{"type":"method","name":"initialize","children":[],"call":["field to_s "]}," Groupdate Series method_missing":{"type":"method","name":"method_missing","children":[],"call":[" raise ","ActiveRecord Calculations  instance_methods join ","ActiveRecord Calculations  instance_methods "," build_series ","@relation send ","ActiveRecord Calculations  method_defined? ","(sym :joins) include? ","@relation respond_to? ","Groupdate Series  new ","relation send ","relation reverse_order ","relation reverse_order_value ","@relation where ","@time_range last ","@time_range first ","@time_range is_a? ","series relation= "," clone "," clone perform "," relation send "," relation "," magic "," magic perform "," relation respond_to? ","@calculations include? "," build_ clone  ","@relation send  send ","@relation reverse_order  send ","@@relation where  send ","@relation send  respond_to? ","@relation reverse_order  respond_to? ","@@relation where  respond_to? ","relation reverse_order  send ","@relation where  send ","relation reverse_order  reverse_order ","@relation where  reverse_order ","relation reverse_order  reverse_order_value ","@relation where  reverse_order_value ","@relation send  where ","@relation reverse_order  where ","@@relation where  where ","series relation reverse_order = ","series @relation where = "," clone  relation= "," relation reverse_order  send "," @relation where  send "," relation reverse_order  "," @relation where  "," relation reverse_order  respond_to? "," @relation where  respond_to? "]}," Groupdate Series build_series":{"type":"method","name":"build_series","children":[],"call":["Hash  [] ","count [] ","series map ","s to_time ","series << ","series last + ","series last ","time_range cover? ","1 send ","time beginning_of_year ","time beginning_of_month ","time beginning_of_week ","time beginning_of_day ","time change ","time_range first in_time_zone ","time_range first ","sorted_keys last ","sorted_keys first ","count keys sort ","count keys ","@time_range is_a? ","cast_method call ","count map ","Time  parse ","k is_a? "," lambda ","k to_i ","s to_time utc ","(send\n  (lvar :time) :-\n  (send\n    (send\n      (lvar :time) :wday) :days)) midnight ","time - ","time wday days ","time wday ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :Time))\n  (lvar :k)\n  (send\n    (lvar :utc) :parse\n    (lvar :k))) utc ","utc parse ","ActiveSupport TimeZone  [] ","(send\n  (lvar :time) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (ivar :@week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","(send\n  (begin\n    (send\n      (send\n        (int 7) :-\n        (ivar :@week_start)) :+\n      (lvar :weekday))) :%\n  (int 7)) days ","(send\n  (send\n    (int 7) :-\n    (ivar :@week_start)) :+\n  (lvar :weekday)) % ","7 - + ","7 - ","(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ","time wday - ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :utc) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time)) utc ","k to_time ","time_range first to_time in_time_zone ","time_range first to_time ","@day_start hours ","time_range first to_time in_time_zone - ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :utc) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time)) in_time_zone ","series to_a reverse ","series to_a ","multiple_groups ! ","k [] + + ","k [] ","k [] + ","keys flat_map ","series reverse ","(send\n  (send\n    (lvar :count) :keys) :map) uniq ","@group_index + ","count keys map ","(send\n  (send\n    (lvar :count) :keys) :map) sort ","@relation group_values size > ","@relation group_values size ","@relation group_values ","reverse ! ","parts [] to_s downcase == ","parts [] to_s downcase ","parts [] to_s ","parts [] ","parts [] == ","parts size == ","parts size ","order split ","order is_a? ","@relation order_values first ","@relation order_values ","Hash  []  [] ","series to_a reverse  map ","series reverse  map ","s to_time_range first in_time_zone  ","s to_time_range first to_time in_time_zone  ","s to_time_range first to_time in_time_zone -  ","series to_a reverse  << ","series reverse  << ","series to_a reverse  last + ","series reverse  last + ","series to_a reverse  last ","series reverse  last ","time_range first in_time_zone _range cover? ","time_range first to_time in_time_zone _range cover? ","time_range first to_time in_time_zone - _range cover? ","time_range first in_time_zone  beginning_of_year ","time_range first to_time in_time_zone  beginning_of_year ","time_range first to_time in_time_zone -  beginning_of_year ","time_range first in_time_zone  beginning_of_month ","time_range first to_time in_time_zone  beginning_of_month ","time_range first to_time in_time_zone -  beginning_of_month ","time_range first in_time_zone  beginning_of_week ","time_range first to_time in_time_zone  beginning_of_week ","time_range first to_time in_time_zone -  beginning_of_week ","time_range first in_time_zone  beginning_of_day ","time_range first to_time in_time_zone  beginning_of_day ","time_range first to_time in_time_zone -  beginning_of_day ","time_range first in_time_zone  change ","time_range first to_time in_time_zone  change ","time_range first to_time in_time_zone -  change ","time_range first in_time_zone _range first in_time_range first in_time_zone _zone ","time_range first to_time in_time_zone _range first in_time_range first to_time in_time_zone _zone ","time_range first to_time in_time_zone - _range first in_time_range first to_time in_time_zone - _zone ","time_range first in_time_zone _range first ","time_range first to_time in_time_zone _range first ","time_range first to_time in_time_zone - _range first ","count keys sort  last ","(send\n  (send\n    (lvar :count) :keys) :map) sort  last ","sorted_(send\n  (send\n    (lvar :count) :keys) :map) uniq  last ","count keys sort  first ","(send\n  (send\n    (lvar :count) :keys) :map) sort  first ","sorted_(send\n  (send\n    (lvar :count) :keys) :map) uniq  first ","Hash  []  keys sort ","count (send\n  (send\n    (lvar :count) :keys) :map) uniq  sort ","Hash  []  keys ","count (send\n  (send\n    (lvar :count) :keys) :map) uniq  ","@time_range first in_time_zone _range is_a? ","@time_range first to_time in_time_zone _range is_a? ","@time_range first to_time in_time_zone - _range is_a? ","Hash  []  map ","s to_time_range first in_time_zone  utc ","s to_time_range first to_time in_time_zone  utc ","s to_time_range first to_time in_time_zone -  utc ","s to_time ActiveSupport TimeZone  []  ","(send\n  (lvar :time_range first in_time_zone ) :-\n  (send\n    (send\n      (lvar :time_range first in_time_zone ) :wday) :days)) midnight ","(send\n  (lvar :time_range first to_time in_time_zone ) :-\n  (send\n    (send\n      (lvar :time_range first to_time in_time_zone ) :wday) :days)) midnight ","(send\n  (lvar :time_range first to_time in_time_zone - ) :-\n  (send\n    (send\n      (lvar :time_range first to_time in_time_zone - ) :wday) :days)) midnight ","time_range first in_time_zone  - ","time_range first to_time in_time_zone  - ","time_range first to_time in_time_zone -  - ","time_range first in_time_zone  wday days ","time_range first to_time in_time_zone  wday days ","time_range first to_time in_time_zone -  wday days ","time_range first in_time_zone  wday ","time_range first to_time in_time_zone  wday ","time_range first to_time in_time_zone -  wday ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :Time))\n  (lvar :k)\n  (send\n    (lvar :ActiveSupport TimeZone  [] ) :parse\n    (lvar :k))) ActiveSupport TimeZone  []  ","ActiveSupport TimeZone  []  parse ","(send\n  (lvar :time_range first in_time_zone ) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (ivar :@week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","(send\n  (lvar :time_range first to_time in_time_zone ) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (ivar :@week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","(send\n  (lvar :time_range first to_time in_time_zone - ) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (ivar :@week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","(send\n  (lvar :time) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (ivar :@week_start)) :+\n            (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ))) :%\n        (int 7))) :days)) midnight ","(send\n  (begin\n    (send\n      (send\n        (int 7) :-\n        (ivar :@week_start)) :+\n      (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ))) :%\n  (int 7)) days ","(send\n  (send\n    (int 7) :-\n    (ivar :@week_start)) :+\n  (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % )) % ","(send\n  (send\n    (lvar :time_range first in_time_zone ) :wday) :-\n  (int 1)) % ","(send\n  (send\n    (lvar :time_range first to_time in_time_zone ) :wday) :-\n  (int 1)) % ","(send\n  (send\n    (lvar :time_range first to_time in_time_zone - ) :wday) :-\n  (int 1)) % ","time_range first in_time_zone  wday - ","time_range first to_time in_time_zone  wday - ","time_range first to_time in_time_zone -  wday - ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :utc) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time_range first in_time_zone )) utc ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :utc) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time_range first to_time in_time_zone )) utc ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :utc) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time_range first to_time in_time_zone - )) utc ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :ActiveSupport TimeZone  [] ) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time)) ActiveSupport TimeZone  []  ","k to_time_range first in_time_zone  ","k to_time_range first to_time in_time_zone  ","k to_time_range first to_time in_time_zone -  ","time_range first in_time_zone _range first to_time_range first in_time_zone  in_time_range first in_time_zone _zone ","time_range first to_time in_time_zone _range first to_time_range first to_time in_time_zone  in_time_range first to_time in_time_zone _zone ","time_range first to_time in_time_zone - _range first to_time_range first to_time in_time_zone -  in_time_range first to_time in_time_zone - _zone ","time_range first in_time_zone _range first to_time_range first in_time_zone  ","time_range first to_time in_time_zone _range first to_time_range first to_time in_time_zone  ","time_range first to_time in_time_zone - _range first to_time_range first to_time in_time_zone -  ","time_range first in_time_zone _range first to_time_range first in_time_zone  in_time_range first in_time_zone _zone - ","time_range first to_time in_time_zone _range first to_time_range first to_time in_time_zone  in_time_range first to_time in_time_zone _zone - ","time_range first to_time in_time_zone - _range first to_time_range first to_time in_time_zone -  in_time_range first to_time in_time_zone - _zone - ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :utc) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time_range first in_time_zone )) in_time_range first in_time_zone _zone ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :utc) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time_range first to_time in_time_zone )) in_time_range first to_time in_time_zone _zone ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :utc) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time_range first to_time in_time_zone - )) in_time_range first to_time in_time_zone - _zone ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :ActiveSupport TimeZone  [] ) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time)) in_time_zone ","series to_a reverse  to_a reverse ","series reverse  to_a reverse ","series to_a reverse !  ","series to_a reverse  to_a ","series reverse  to_a ","@relation group_values size >  ! ","(send\n  (send\n    (lvar :count) :keys) :map) uniq  flat_map ","series to_a reverse  reverse ","series reverse  reverse ","series reverse !  ","(send\n  (send\n    (lvar :Hash  [] ) :keys) :map) uniq ","(send\n  (send\n    (lvar :count) :(send\n  (send\n    (lvar :count) :keys) :map) uniq ) :map) uniq ","Hash  []  keys map ","count (send\n  (send\n    (lvar :count) :keys) :map) uniq  map ","(send\n  (send\n    (lvar :Hash  [] ) :keys) :map) sort ","(send\n  (send\n    (lvar :count) :(send\n  (send\n    (lvar :count) :keys) :map) uniq ) :map) sort ","reverse !  ! ","order split  [] to_s downcase == ","order split  [] to_s downcase ","order split  [] to_s ","order split  [] ","order split  [] == ","order split  size == ","order split  size ","@relation order_values first  split ","@relation order_values first  is_a? ","@relation @relation order_values first _values first ","@relation @relation order_values first _values "]}," Groupdate Series initialize":{"type":"method","name":"initialize","children":[],"call":["relation where ","time_range last ","time_range first ","time_range is_a? ","Groupdate Calculations  new "]}," Groupdate Scopes inherited_with_groupdate":{"type":"method","name":"inherited_with_groupdate","children":[],"call":["kls send ","kls superclass == ","kls superclass "," inherited_without_groupdate "]}," Groupdate Series respond_to?":{"type":"method","name":"respond_to?","children":[],"call":["@relation respond_to? ","ActiveRecord Calculations  method_defined? "," relation respond_to? "," relation ","@calculations include? "]}," Groupdate Series clone":{"type":"method","name":"clone","children":[],"call":["Groupdate Series  new "]}," Groupdate Series round_time":{"type":"method","name":"round_time","children":[],"call":["time + ","@day_start hours ","time beginning_of_year ","time beginning_of_month ","(send\n  (lvar :time) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (ivar :@week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","time - ","(send\n  (begin\n    (send\n      (send\n        (int 7) :-\n        (ivar :@week_start)) :+\n      (lvar :weekday))) :%\n  (int 7)) days ","(send\n  (send\n    (int 7) :-\n    (ivar :@week_start)) :+\n  (lvar :weekday)) % ","7 - + ","7 - ","(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ","time wday - ","time wday ","time beginning_of_day ","time change ","time to_time in_time_zone - ","time to_time in_time_zone ","time to_time ","time to_time in_time_zone -  + ","time to_time in_time_zone -  beginning_of_year ","time to_time in_time_zone -  beginning_of_month ","(send\n  (lvar :time) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (ivar :@week_start)) :+\n            (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ))) :%\n        (int 7))) :days)) midnight ","(send\n  (lvar :time to_time in_time_zone - ) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (ivar :@week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","time to_time in_time_zone -  - ","(send\n  (begin\n    (send\n      (send\n        (int 7) :-\n        (ivar :@week_start)) :+\n      (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ))) :%\n  (int 7)) days ","(send\n  (send\n    (int 7) :-\n    (ivar :@week_start)) :+\n  (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % )) % ","(send\n  (send\n    (lvar :time to_time in_time_zone - ) :wday) :-\n  (int 1)) % ","time to_time in_time_zone -  wday - ","time to_time in_time_zone -  wday ","time to_time in_time_zone -  beginning_of_day ","time to_time in_time_zone -  change ","time to_time in_time_zone -  to_time to_time in_time_zone -  in_time to_time in_time_zone - _zone - ","time to_time in_time_zone -  to_time to_time in_time_zone -  in_time to_time in_time_zone - _zone ","time to_time in_time_zone -  to_time to_time in_time_zone -  "]}," Groupdate Series perform":{"type":"method","name":"perform","children":[],"call":["Hash  [] ","count [] ","key_format call ","series map "," lambda ","key strftime ","@options [] to_s ","@options [] ","sunday + ","key days ","sunday + + ","@day_start hours ","key hours ","@time_zone parse ","@options [] respond_to? ","series to_a reverse ","series to_a ","multiple_groups ! ","k [] + + ","k [] ","k [] + ","keys flat_map ","series reverse ","(send\n  (send\n    (lvar :count) :keys) :map) uniq ","@group_index + ","count keys map ","count keys ","series << ","series last + ","series last ","time_range cover? ","1 send "," round_time ","time_range first ","sorted_keys last ","sorted_keys first ","count keys sort ","(send\n  (send\n    (lvar :count) :keys) :map) sort ","time_range is_a? ","cast_method call ","relation send map ","relation send ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :utc) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time)) in_time_zone ","k to_time ","utc parse ","k is_a? ","k to_i ","relation group_values size > ","relation group_values size ","relation group_values ","reverse ! ","parts [] to_s downcase == ","parts [] to_s downcase ","parts [] to_s ","parts [] ","parts [] == ","parts size == ","parts size ","order split ","order is_a? ","relation order_values first ","relation order_values ","relation reverse_order ","relation reverse_order_value ","@relation where ","time_range last ","now - ","(send\n  (send\n    (send\n      (ivar :@options) :[]\n      (sym :last)) :to_i) :-\n  (int 1)) send ","@options [] to_i - ","@options [] to_i ","Time  now ","1 respond_to? ","time_range is_a? ! ","ActiveSupport TimeZone  [] "," raise ","Hash  []  [] ","sunday + _format call ","sunday + + _format call ","series to_a reverse  map ","series reverse  map ","sunday +  strftime ","sunday + +  strftime ","@time_zone parse  + ","sunday +  days ","sunday + +  days ","@time_zone parse  + + ","sunday +  hours ","sunday + +  hours ","series to_a reverse  to_a reverse ","series reverse  to_a reverse ","series to_a reverse !  ","series to_a relation reverse_order_value  ","series to_a reverse  to_a ","series reverse  to_a ","relation group_values size >  ! ","sunday + s flat_map ","sunday + + s flat_map ","(send\n  (send\n    (lvar :count) :keys) :map) uniq  flat_map ","series to_a reverse  reverse ","series reverse  reverse ","series reverse !  ","series relation reverse_order_value  ","(send\n  (send\n    (lvar :count) :sunday + s) :map) uniq ","(send\n  (send\n    (lvar :count) :sunday + + s) :map) uniq ","(send\n  (send\n    (lvar :count) :(send\n  (send\n    (lvar :count) :keys) :map) uniq ) :map) uniq ","(send\n  (send\n    (lvar :Hash  [] ) :keys) :map) uniq ","count sunday + s map ","count sunday + + s map ","count (send\n  (send\n    (lvar :count) :keys) :map) uniq  map ","Hash  []  keys map ","count sunday + s ","count sunday + + s ","count (send\n  (send\n    (lvar :count) :keys) :map) uniq  ","Hash  []  keys ","series to_a reverse  << ","series reverse  << ","series to_a reverse  last + ","series reverse  last + ","series to_a reverse  last ","series reverse  last ","sorted_sunday + s last ","sorted_sunday + + s last ","sorted_(send\n  (send\n    (lvar :count) :keys) :map) uniq  last ","count keys sort  last ","(send\n  (send\n    (lvar :count) :keys) :map) sort  last ","sorted_sunday + s first ","sorted_sunday + + s first ","sorted_(send\n  (send\n    (lvar :count) :keys) :map) uniq  first ","count keys sort  first ","(send\n  (send\n    (lvar :count) :keys) :map) sort  first ","count sunday + s sort ","count sunday + + s sort ","count (send\n  (send\n    (lvar :count) :keys) :map) uniq  sort ","Hash  []  keys sort ","(send\n  (send\n    (lvar :count) :sunday + s) :map) sort ","(send\n  (send\n    (lvar :count) :sunday + + s) :map) sort ","(send\n  (send\n    (lvar :count) :(send\n  (send\n    (lvar :count) :keys) :map) uniq ) :map) sort ","(send\n  (send\n    (lvar :Hash  [] ) :keys) :map) sort ","relation reverse_order  send map ","@relation where  send map ","relation reverse_order  send ","@relation where  send ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :ActiveSupport TimeZone  [] ) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time)) in_time_zone ","ActiveSupport TimeZone  []  parse ","relation reverse_order  group_values size > ","@relation where  group_values size > ","relation reverse_order  group_values size ","@relation where  group_values size ","relation reverse_order  group_values ","@relation where  group_values ","reverse !  ! ","relation reverse_order_value  ! ","order split  [] to_s downcase == ","order split  [] to_s downcase ","order split  [] to_s ","order split  [] ","order split  [] == ","order split  size == ","order split  size ","relation order_values first  split ","relation order_values first  is_a? ","relation relation order_values first _values first ","relation reverse_order  order_values first ","@relation where  order_values first ","relation relation order_values first _values ","relation reverse_order  order_values ","@relation where  order_values ","relation reverse ! _order ","relation relation reverse_order_value _order ","relation reverse_relation order_values first  ","relation reverse_order  reverse_order ","@relation where  reverse_order ","relation reverse ! _order_value ","relation relation reverse_order_value _order_value ","relation reverse_relation order_values first _value ","relation reverse_order  reverse_order_value ","@relation where  reverse_order_value ","@relation reverse_order  where ","@@relation where  where ","Time  now  - ","Time  Time  now  "]}," Groupdate Magic round_time":{"type":"method","name":"round_time","children":[],"call":["time + "," day_start hours "," day_start ","time is_a? "," raise ","7 - + ","(send\n  (begin\n    (send\n      (send\n        (lvar :time) :wday) :-\n      (int 1))) :%\n  (int 7)) % ","(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ","time wday - ","time wday ","7 - "," week_start ","time hour ","time beginning_of_year ","time beginning_of_month ","(send\n  (lvar :time) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (send nil :week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","time - ","(send\n  (begin\n    (send\n      (send\n        (int 7) :-\n        (send nil :week_start)) :+\n      (lvar :weekday))) :%\n  (int 7)) days ","(send\n  (send\n    (int 7) :-\n    (send nil :week_start)) :+\n  (lvar :weekday)) % ","time beginning_of_day ","time change "," field ","time to_time in_time_zone - ","time to_time in_time_zone "," time_zone ","time to_time ","time month ","time day ","time beginning_of_quarter "," day_start seconds ","time min "," period ","(send\n  (send\n    (send\n      (lvar :time) :wday) :-\n    (int 1)) :-\n  (send nil :week_start)) % ","time wday - - ","time to_time in_time_zone -  + ","time to_time in_time_zone -  is_a? ","(send\n  (begin\n    (send\n      (send\n        (lvar :time to_time in_time_zone - ) :wday) :-\n      (int 1))) :%\n  (int 7)) % ","(send\n  (send\n    (lvar :time to_time in_time_zone - ) :wday) :-\n  (int 1)) % ","time to_time in_time_zone -  wday - ","time to_time in_time_zone -  wday ","time to_time in_time_zone -  hour ","time to_time in_time_zone -  beginning_of_year ","time to_time in_time_zone -  beginning_of_month ","(send\n  (lvar :time) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (send nil :week_start)) :+\n            (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ))) :%\n        (int 7))) :days)) midnight ","(send\n  (lvar :time to_time in_time_zone - ) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (send nil :week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","time to_time in_time_zone -  - ","(send\n  (begin\n    (send\n      (send\n        (int 7) :-\n        (send nil :week_start)) :+\n      (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ))) :%\n  (int 7)) days ","(send\n  (send\n    (int 7) :-\n    (send nil :week_start)) :+\n  (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % )) % ","time to_time in_time_zone -  beginning_of_day ","time to_time in_time_zone -  change ","time to_time in_time_zone -  to_time to_time in_time_zone -  in_time to_time in_time_zone - _zone - ","time to_time in_time_zone -  to_time to_time in_time_zone -  in_time to_time in_time_zone - _zone "," time to_time in_time_zone - _zone ","time to_time in_time_zone -  to_time to_time in_time_zone -  ","time to_time in_time_zone -  month ","time to_time in_time_zone -  day ","time to_time in_time_zone -  beginning_of_quarter ","time to_time in_time_zone -  min ","(send\n  (send\n    (send\n      (lvar :time to_time in_time_zone - ) :wday) :-\n    (int 1)) :-\n  (send nil :week_start)) % ","time to_time in_time_zone -  wday - - "]}," Groupdate Magic series":{"type":"method","name":"series","children":[],"call":["Hash  [] ","count [] ","key_format call ","k [] + + ","k [] ","@group_index + ","k [] + ","series map "," lambda ","key strftime "," options [] to_s "," options [] "," options ","sunday + ","key days ","sunday + + "," day_start hours "," day_start ","key hours "," field "," time_zone parse "," time_zone "," options [] respond_to? ","series to_a reverse ","series to_a ","multiple_groups ! ","keys flat_map ","series reverse ","(send\n  (send\n    (lvar :count) :keys) :map) uniq ","count keys map ","count keys ","series << ","series last + ","series last ","time_range cover? ","1 send "," round_time ","time_range first ","sorted_keys last ","sorted_keys first ","count keys sort ","(send\n  (send\n    (lvar :count) :keys) :map) sort ","time_range is_a? "," time_range ","reverse ! ","Date  new to_time ","Date  new ","@options [] ","I18n  localize ","I18n  locale ","3 months "," field == ","k to_date ","(sym :day) include? "," options key? ! "," options key? ","Groupdate  dates "," day_start seconds ","series select ","use_series == ","next_step == ","last_step + "," period ","key minutes "," period == ","(send\n  (send nil :week_start) :+\n  (int 1)) days "," week_start + "," week_start ","sunday + _format call ","sunday + + _format call ","Date  new to_time _format call ","series to_a reverse  map ","series reverse  map ","sunday +  strftime ","sunday + +  strftime ","Date  new to_time  strftime "," time_zone parse  + ","sunday +  days ","sunday + +  days ","Date  new to_time  days "," time_zone parse  + + ","sunday +  hours ","sunday + +  hours ","Date  new to_time  hours ","series to_a reverse  to_a reverse ","series reverse  to_a reverse ","series to_a reverse !  ","series to_a reverse  to_a ","series reverse  to_a ","sunday + s flat_map ","sunday + + s flat_map ","Date  new to_time s flat_map ","(send\n  (send\n    (lvar :count) :keys) :map) uniq  flat_map ","series to_a reverse  reverse ","series reverse  reverse ","series reverse !  ","(send\n  (send\n    (lvar :count) :sunday + s) :map) uniq ","(send\n  (send\n    (lvar :count) :sunday + + s) :map) uniq ","(send\n  (send\n    (lvar :count) :Date  new to_time s) :map) uniq ","(send\n  (send\n    (lvar :count) :(send\n  (send\n    (lvar :count) :keys) :map) uniq ) :map) uniq ","count sunday + s map ","count sunday + + s map ","count Date  new to_time s map ","count (send\n  (send\n    (lvar :count) :keys) :map) uniq  map ","count sunday + s ","count sunday + + s ","count Date  new to_time s ","count (send\n  (send\n    (lvar :count) :keys) :map) uniq  ","series to_a reverse  << ","series reverse  << ","series to_a reverse  last + ","series reverse  last + ","series to_a reverse  last ","series reverse  last "," time_range  cover? "," time_range  first ","sorted_sunday + s last ","sorted_sunday + + s last ","sorted_Date  new to_time s last ","sorted_(send\n  (send\n    (lvar :count) :keys) :map) uniq  last ","count keys sort  last ","(send\n  (send\n    (lvar :count) :keys) :map) sort  last ","sorted_sunday + s first ","sorted_sunday + + s first ","sorted_Date  new to_time s first ","sorted_(send\n  (send\n    (lvar :count) :keys) :map) uniq  first ","count keys sort  first ","(send\n  (send\n    (lvar :count) :keys) :map) sort  first ","count sunday + s sort ","count sunday + + s sort ","count Date  new to_time s sort ","count (send\n  (send\n    (lvar :count) :keys) :map) uniq  sort ","(send\n  (send\n    (lvar :count) :sunday + s) :map) sort ","(send\n  (send\n    (lvar :count) :sunday + + s) :map) sort ","(send\n  (send\n    (lvar :count) :Date  new to_time s) :map) sort ","(send\n  (send\n    (lvar :count) :(send\n  (send\n    (lvar :count) :keys) :map) uniq ) :map) sort "," time_range  is_a? ","  time_range  ","reverse !  ! "," options sunday + ? ! "," options sunday + + ? ! "," options Date  new to_time ? ! "," options sunday + ? "," options sunday + + ? "," options Date  new to_time ? ","series to_a reverse  select ","series reverse  select ","use_series to_a reverse  == ","use_series reverse  == "," options []  == ","next_1 send  == ","next_3 months  == "," round_time  == ","last_1 send  + ","last_3 months  + ","series last  + ","sunday +  minutes ","sunday + +  minutes ","Date  new to_time  minutes "]}," Groupdate Magic time_range":{"type":"method","name":"time_range","children":[],"call":[" round_time ","now - ","(send\n  (send\n    (send\n      (send nil :options) :[]\n      (sym :last)) :to_i) :-\n  (int 1)) send "," field "," options [] to_i - "," options [] to_i "," options [] "," options ","Time  now ","1 send ","1 respond_to? ","time_range ! "," options [] == ","Range  new "," time_zone parse ","time_range first to_s ","time_range first "," time_zone ","1 day ","time_range exclude_end? ","time_range last to_s ","time_range last ","time_range first is_a? ","time_range is_a? ","start_at - ","(send\n  (send\n    (send\n      (send nil :options) :[]\n      (sym :last)) :to_i) :-\n  (int 1)) times "," raise ","3 months "," field == "," period "," period == "," series_builder time_range "," series_builder ","Time  now  - ","(send\n  (send\n    (send\n      (send nil :options) :[]\n      (sym : time_zone parse )) :to_i) :-\n  (int 1)) send ","Time  Time  now  "," options []  ! ","Range  new  ! "," options []  first to_s ","Range  new  first to_s "," options []  first ","Range  new  first "," options []  exclude_end? ","Range  new  exclude_end? "," options []  last to_s ","Range  new  last to_s ","time_range  time_zone parse  to_s "," options []  last ","Range  new  last ","time_range  time_zone parse  "," options []  first is_a? ","Range  new  first is_a? "," options []  is_a? ","Range  new  is_a? ","(send\n  (send\n    (send\n      (send nil :options) :[]\n      (sym : time_zone parse )) :to_i) :-\n  (int 1)) times "," series_builder  options []  "," series_builder Range  new  "]}," Groupdate Magic day_start":{"type":"method","name":"day_start","children":[],"call":["(or\n  (send\n    (send nil :options) :[]\n    (sym :day_start))\n  (send\n    (const nil :Groupdate) :day_start)) to_i ","Groupdate  day_start "," options [] "," options ","(send\n  (send\n    (begin\n      (or\n        (send\n          (send nil :options) :[]\n          (sym :day_start))\n        (send\n          (const nil :Groupdate) :day_start))) :to_f) :*\n  (int 3600)) round ","(or\n  (send\n    (send nil :options) :[]\n    (sym :day_start))\n  (send\n    (const nil :Groupdate) :day_start)) to_f * ","(or\n  (send\n    (send nil :options) :[]\n    (sym :day_start))\n  (send\n    (const nil :Groupdate) :day_start)) to_f "]}," Groupdate Magic week_start":{"type":"method","name":"week_start","children":[],"call":["(sym :mon) index ","(or\n  (or\n    (send\n      (send nil :options) :[]\n      (sym :week_start))\n    (send\n      (send nil :options) :[]\n      (sym :start)))\n  (send\n    (const nil :Groupdate) :week_start)) to_sym ","Groupdate  week_start "," options [] "," options ","DAYS  index ","(or\n  (send\n    (send nil :options) :[]\n    (sym :week_start))\n  (send\n    (const nil :Groupdate) :week_start)) to_sym "]}," Groupdate Magic time_zone":{"type":"method","name":"time_zone","children":[],"call":["ActiveSupport TimeZone  [] ","time_zone is_a? ","Time  zone ","Groupdate  time_zone "," options [] "," options "," options [] == ","Groupdate  time_zone == "]}," Groupdate Magic perform":{"type":"method","name":"perform","children":[],"call":[" series "," raise ","Hash  [] ","cast_method call ","k [] + + ","k [] ","@group_index + ","k [] + ","relation send map ","relation send ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :utc) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time)) in_time_zone "," time_zone ","k to_time ","utc parse ","k is_a? "," lambda ","ActiveSupport TimeZone  [] ","k to_i "," field ","relation group_values size > ","relation group_values size ","relation group_values ","reverse ! ","parts [] to_s downcase == ","parts [] to_s downcase ","parts [] to_s ","parts [] ","parts [] to_sym == ","parts [] to_sym ","parts size == ","parts size ","order split ","order is_a? ","relation order_values first ","relation order_values ","relation reverse_order ","relation reverse_order_value ","relation reorder ","relation order_values [] ","parts [] == ","relation quoted_primary_key ","relation quoted_table_name "," activerecord42? ","relation except "," options [] "," options "," options key? ","(if\n  (or\n    (send\n      (lvar :k) :is_a?\n      (const nil :String))\n    (send\n      (send\n        (lvar :k) :respond_to?\n        (sym :to_time)) :!))\n  (send\n    (lvar :utc) :parse\n    (send\n      (lvar :k) :to_s))\n  (send\n    (lvar :k) :to_time)) in_time_zone ","k to_s ","k respond_to? ! ","k respond_to? ","result map ","result key? ","result keys first [] nil? ","result keys first [] ","result keys first ","result keys ","result is_a? "," period ","relation reverse_order  send map ","relation reorder  send map ","relation except  send map ","relation reverse_order  send ","relation reorder  send ","relation except  send ","(if\n  (send\n    (lvar :k) :is_a?\n    (const nil :String))\n  (send\n    (lvar :ActiveSupport TimeZone  [] ) :parse\n    (lvar :k))\n  (send\n    (lvar :k) :to_time)) in_time_zone ","ActiveSupport TimeZone  []  parse ","relation reverse_order  group_values size > ","relation reorder  group_values size > ","relation except  group_values size > ","relation reverse_order  group_values size ","relation reorder  group_values size ","relation except  group_values size ","relation reverse_order  group_values ","relation reorder  group_values ","relation except  group_values ","reverse !  ! ","relation reverse_order_value  ! ","relation send  ! ","order split  [] to_s downcase == ","order split  [] to_s downcase ","order split  [] to_s ","order split  [] ","order split  [] to_sym == ","order split  [] to_sym ","order split  size == ","order split  size ","relation order_values first  split ","relation order_values first  is_a? ","relation relation order_values first _values first ","relation reverse_order  order_values first ","relation reorder  order_values first ","relation except  order_values first ","relation relation order_values first _values ","relation reverse_order  order_values ","relation reorder  order_values ","relation except  order_values ","relation reverse ! _order ","relation relation reverse_order_value _order ","relation relation send _order ","relation reverse_relation order_values first  ","relation reverse_order  reverse_order ","relation reorder  reverse_order ","relation except  reverse_order ","relation reverse ! _order_value ","relation relation reverse_order_value _order_value ","relation relation send _order_value ","relation reverse_relation order_values first _value ","relation reverse_order  reverse_order_value ","relation reorder  reverse_order_value ","relation except  reverse_order_value ","relation rerelation order_values first  ","relation reverse_order  reorder ","relation reorder  reorder ","relation except  reorder ","relation relation order_values first _values [] ","relation reverse_order  order_values [] ","relation reorder  order_values [] ","relation except  order_values [] ","order split  [] == ","relation reverse_order  quoted_primary_key ","relation reorder  quoted_primary_key ","relation except  quoted_primary_key ","relation reverse_order  quoted_table_name ","relation reorder  quoted_table_name ","relation except  quoted_table_name ","relation reverse_order  except ","relation reorder  except ","relation except  except ","(if\n  (or\n    (send\n      (lvar :k) :is_a?\n      (const nil :String))\n    (send\n      (send\n        (lvar :k) :respond_to?\n        (sym :to_time)) :!))\n  (send\n    (lvar :ActiveSupport TimeZone  [] ) :parse\n    (send\n      (lvar :k) :to_s))\n  (send\n    (lvar :k) :to_time)) in_time_zone ","Hash  []  map ","relation send  map ","Hash  []  key? ","relation send  key? ","Hash  []  keys first [] nil? ","relation send  keys first [] nil? ","Hash  []  keys first [] ","relation send  keys first [] ","Hash  []  keys first ","relation send  keys first ","Hash  []  keys ","relation send  keys ","Hash  []  is_a? ","relation send  is_a? "]}," Groupdate Magic relation":{"type":"method","name":"relation","children":[],"call":["Groupdate Series  new ","group group_values size - ","group group_values size ","group group_values ","group where "," time_range last "," time_range "," time_range first "," time_range is_a? "," options [] == "," options [] "," options ","relation group ","Groupdate OrderHack  new "," field ","relation send "," raise "," day_start "," week_start ","7 - ","relation connection adapter_name ","relation connection "," time_zone tzinfo name "," time_zone tzinfo "," time_zone ","relation connection quote_table_name ","relation default_timezone == ","relation default_timezone ","query []= ","query [] "," field == ","adapter_name == "," day_start / ","format gsub "," week_start == "," day_start zero? "," time_zone utc_offset zero? "," time_zone utc_offset "," period "," period == ","relation group  relation group _values size - ","relation group  relation group _values size ","relation group  relation group _values ","relation group  where ","group where  group ","relation relation group  ","group where  send ","group where  connection adapter_name ","relation connection relation connection adapter_name  ","group where  connection ","  time_zone tzinfo name  tzinfo name ","  time_zone tzinfo name  tzinfo ","  time_zone tzinfo name  ","group where  connection quote_table_name ","group where  default_timezone == ","group where  default_timezone ","relation connection adapter_name  == ","  time_zone tzinfo name  utc_offset zero? ","  time_zone tzinfo name  utc_offset "]}," Groupdate Magic group_by":{"type":"method","name":"group_by","children":[],"call":[" series "," round_time ","enum group_by "," options [] == "," options [] "," options "]}," Groupdate Magic initialize":{"type":"method","name":"initialize","children":[],"call":[" raise "," week_start ! "," week_start ","field == "," time_zone ! "," time_zone ","period == ","unknown_keywords join ","unknown_keywords any? ","options keys - ","options keys ","options [] end ! ","options [] end ","options [] ","options [] is_a? "," validate_arguments "," validate_keywords ","options [] to_i ","options [] < ","options [] is_a? ! ","options keys -  join ","options keys -  any? "]}," ActiveRecord Relation method_missing_with_hack":{"type":"method","name":"method_missing_with_hack","children":[],"call":[" method_missing_without_hack ","@klass send "," scoping ","Groupdate METHODS  include? "]}," Groupdate Magic activerecord42?":{"type":"method","name":"activerecord42?","children":[],"call":["ActiveRecord VERSION STRING  starts_with? "]}," Groupdate Scopes group_by_period":{"type":"method","name":"group_by_period","children":[],"call":[" raise "," send ","permitted_periods include? ","period to_s ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :FIELDS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :FIELDS)) map ","(or\n  (send\n    (lvar :options) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :FIELDS)) map & ","(or\n  (send\n    (lvar :options) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :FIELDS)) map ","options [] ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(or\n  (send\n    (lvar :options) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map & ","(or\n  (send\n    (lvar :options) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :FIELDS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :FIELDS)) map  include? ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map  include? "]}," Enumerable group_by_period":{"type":"method","name":"group_by_period","children":[],"call":[" raise "," send ","permitted_periods include? ","period to_s ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :FIELDS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :FIELDS)) map ","(or\n  (send\n    (lvar :options) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :FIELDS)) map & ","(or\n  (send\n    (lvar :options) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :FIELDS)) map ","options [] ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(or\n  (send\n    (lvar :options) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map & ","(or\n  (send\n    (lvar :options) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","@klass send "," scoping ","args [] "," respond_to? ! "," respond_to? ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options) :delete\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(or\n  (send\n    (lvar :options) :delete\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map & ","(or\n  (send\n    (lvar :options) :delete\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","options delete ","options dup ","(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge "," warn ","args any? ","@klass group_by_period ","Groupdate Magic  validate_period ","args size + ","args size ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :FIELDS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :FIELDS)) map  include? ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map  include? ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options) :delete\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map  include? ","permitted_args [] s include? ","args []  to_s ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options dup ) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :FIELDS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :FIELDS)) map ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge ) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :FIELDS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :FIELDS)) map ","(or\n  (send\n    (lvar :options dup ) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :FIELDS)) map & ","(or\n  (send\n    (lvar :(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge ) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :FIELDS)) map & ","(or\n  (send\n    (lvar :options dup ) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :FIELDS)) map ","(or\n  (send\n    (lvar :(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge ) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :FIELDS)) map ","options dup  [] ","(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge  [] ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options dup ) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge ) :[]\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(or\n  (send\n    (lvar :options dup ) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map & ","(or\n  (send\n    (lvar :(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge ) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map & ","(or\n  (send\n    (lvar :options dup ) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(or\n  (send\n    (lvar :(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge ) :[]\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :options dup ) :delete\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(send\n  (send\n    (begin\n      (or\n        (send\n          (lvar :(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge ) :delete\n          (sym :permit))\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(or\n  (send\n    (lvar :options dup ) :delete\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map & ","(or\n  (send\n    (lvar :(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge ) :delete\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map & ","(or\n  (send\n    (lvar :options dup ) :delete\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(or\n  (send\n    (lvar :(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge ) :delete\n    (sym :permit))\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","options dup  delete ","(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge  delete ","options dup  dup ","(or\n  (send\n    (lvar :args) :[]\n    (int 0))\n  (hash)) merge  dup ","@klass group_by_args []  ","Groupdate Magic  validate_args []  "]}," Groupdate Series reverse_order_value":{"type":"method","name":"reverse_order_value","children":[],"call":[]}," Groupdate Calculations model":{"type":"method","name":"model","children":[],"call":[" relation klass "," relation "," relation respond_to? ! "," relation respond_to? "]}," Groupdate Calculations custom_calculations":{"type":"method","name":"custom_calculations","children":[],"call":[" model groupdate_calculation_methods "," model "," model respond_to? ! "," model respond_to? "]}," Groupdate Calculations include?":{"type":"method","name":"include?","children":[],"call":[" custom_calculations include? "," custom_calculations ","ActiveRecord Calculations  method_defined? "]}," Groupdate Calculations initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Groupdate Series unscoped":{"type":"method","name":"unscoped","children":[],"call":["@relation unscoped "]}," Groupdate Relation calculate":{"type":"method","name":"calculate","children":[],"call":["Groupdate Magic Relation  process_result "," groupdate_values ","Groupdate  process_result ","(sym :count) include? ","args [] "," has_include? ","ActiveRecord VERSION STRING  to_f >= ","ActiveRecord VERSION STRING  to_f "]}," Groupdate QueryMethods group_by_period":{"type":"method","name":"group_by_period","children":[],"call":[" raise "," send ","permitted_periods include? ","period to_s ","(send\n  (send\n    (begin\n      (or\n        (lvar :permit)\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","(or\n  (lvar :permit)\n  (const\n    (const nil :Groupdate) :PERIODS)) map & ","(or\n  (lvar :permit)\n  (const\n    (const nil :Groupdate) :PERIODS)) map ","Groupdate Magic  validate_period ","(send\n  (send\n    (begin\n      (or\n        (lvar :permit)\n        (const\n          (const nil :Groupdate) :PERIODS))) :map\n    (block-pass\n      (sym :to_sym))) :&\n  (const\n    (const nil :Groupdate) :PERIODS)) map  include? "]}," Groupdate Magic Relation process_result":{"type":"method","name":"process_result","children":[],"call":[]}," Groupdate Magic Relation generate_relation":{"type":"method","name":"generate_relation","children":[],"call":[]}," Groupdate Magic Relation perform":{"type":"method","name":"perform","children":[],"call":[" series "," options [] "," options "," options key? ","Hash  [] ","cast_method call ","k [] + + ","k [] ","@group_index + ","k [] + ","result map "," raise ","result key? ","result keys first [] nil? ","result keys first [] ","result keys first ","result keys ","(if\n  (or\n    (send\n      (lvar :k) :is_a?\n      (const nil :String))\n    (send\n      (send\n        (lvar :k) :respond_to?\n        (sym :to_time)) :!))\n  (send\n    (lvar :utc) :parse\n    (send\n      (lvar :k) :to_s))\n  (send\n    (lvar :k) :to_time)) in_time_zone "," time_zone ","k to_time ","utc parse ","k to_s ","k respond_to? ! ","k respond_to? ","k is_a? "," lambda ","ActiveSupport TimeZone  [] ","k to_i ","(send\n  (send\n    (send\n      (lvar :k) :to_i) :-\n    (int 1)) :-\n  (send nil :week_start)) % ","k to_i - - "," week_start ","k to_i - "," period ","relation group_values size > ","relation group_values size ","relation group_values "," series_builder generate "," group_index "," series_builder "," cast_result "," check_time_zone_support "," check_nils "," perform ","result then ","result is_a? ","Hash  []  map "," cast_result  map ","Hash  []  key? "," cast_result  key? ","Hash  []  keys first [] nil? "," cast_result  keys first [] nil? ","Hash  []  keys first [] "," cast_result  keys first [] ","Hash  []  keys first "," cast_result  keys first ","Hash  []  keys "," cast_result  keys ","(if\n  (or\n    (send\n      (lvar :k) :is_a?\n      (const nil :String))\n    (send\n      (send\n        (lvar :k) :respond_to?\n        (sym :to_time)) :!))\n  (send\n    (lvar :ActiveSupport TimeZone  [] ) :parse\n    (send\n      (lvar :k) :to_s))\n  (send\n    (lvar :k) :to_time)) in_time_zone ","ActiveSupport TimeZone  []  parse "," cast_Hash  []  "," cast_ cast_result  ","Hash  []  then "," cast_result  then ","Hash  []  is_a? "," cast_result  is_a? "]}," Groupdate Magic Relation relation":{"type":"method","name":"relation","children":[],"call":["group group_values size - ","group group_values size ","group group_values ","group where "," time_range last "," time_range "," time_range first "," time_range is_a? ","relation group ","group_str [] ","group_str end_with? ","group_str start_with? ","group_str gsub ","relation send ","query []= ","query [] "," period == "," period ","adapter_name == "," raise "," day_start "," week_start ","format gsub "," week_start == "," day_start zero? "," time_zone utc_offset zero? "," time_zone utc_offset "," time_zone ","7 - "," day_start / ","relation connection adapter_name ","relation connection "," time_zone tzinfo name "," time_zone tzinfo ","relation default_timezone == ","relation default_timezone ","relation group  relation group _values size - ","relation group  relation group _values size ","relation group  relation group _values ","relation group  where ","group where  group ","relation relation group  ","relation group _str [] ","group_str []  [] ","group_str gsub  [] ","relation send  [] ","relation group _str end_with? ","group_str []  end_with? ","group_str gsub  end_with? ","relation send  end_with? ","relation group _str start_with? ","group_str []  start_with? ","group_str gsub  start_with? ","relation send  start_with? ","relation group _str gsub ","group_str []  gsub ","group_str gsub  gsub ","relation send  gsub ","group where  send ","relation connection adapter_name  == ","  time_zone tzinfo name  utc_offset zero? ","  time_zone tzinfo name  utc_offset ","  time_zone tzinfo name  ","group where  connection adapter_name ","relation connection relation connection adapter_name  ","group where  connection ","  time_zone tzinfo name  tzinfo name ","  time_zone tzinfo name  tzinfo ","group where  default_timezone == ","group where  default_timezone "]}," Groupdate Magic Relation initialize":{"type":"method","name":"initialize","children":[],"call":["(sym :default_value) include? ","options reject "]}," Groupdate Magic Enumerable group_by":{"type":"method","name":"group_by","children":[],"call":[" series "," round_time ","enum group_by "," series_builder generate "," series_builder "," series_builder round_time "," raise ","v respond_to? "]}," Groupdate SeriesBuilder entire_series?":{"type":"method","name":"entire_series?","children":[],"call":[" options [] "," options "," options key? "]}," Groupdate SeriesBuilder handle_multiple":{"type":"method","name":"handle_multiple","children":[],"call":["series to_a reverse ","series to_a ","k [] + + ","k [] ","k [] + ","series map ","keys flat_map ","(send\n  (send\n    (lvar :data) :keys) :map) uniq ","group_index + ","data keys map ","data keys "," options [] "," options ","series to_a reverse  to_a reverse ","series to_a  options []  ","series to_a reverse  to_a ","series to_a reverse  map ","(send\n  (send\n    (lvar :data) :keys) :map) uniq  flat_map ","(send\n  (send\n    (lvar :data) :(send\n  (send\n    (lvar :data) :keys) :map) uniq ) :map) uniq ","data (send\n  (send\n    (lvar :data) :keys) :map) uniq  map ","data (send\n  (send\n    (lvar :data) :keys) :map) uniq  "]}," Groupdate SeriesBuilder key_format":{"type":"method","name":"key_format","children":[],"call":[" lambda ","k to_date ","(sym :day) include? "," period ","I18n  localize "," options [] "," options ","Date  new to_time ","Date  new ","sunday + + ","(send\n  (send nil :week_start) :+\n  (int 1)) days "," week_start + "," week_start ","sunday + ","key days "," day_start seconds "," day_start ","key minutes ","key hours "," time_zone parse "," time_zone "," options [] respond_to? ","Groupdate  dates "," options key? ","I18n  locale "," time_zone parse  + + "," time_zone parse  + ","Date  new to_time  days ","sunday + +  days ","Date  new to_time  minutes ","sunday + +  minutes ","Date  new to_time  hours ","sunday + +  hours "," options Date  new to_time ? "," options sunday + + ? "]}," Groupdate SeriesBuilder generate_series":{"type":"method","name":"generate_series","children":[],"call":["series << ","next_step == ","time_range cover? "," round_time ","last_step + ","series last ","1 send "," period ","3 months "," period == ","time_range first ","sorted_keys last ","sorted_keys first ","data keys sort ","data keys ","(send\n  (send\n    (lvar :data) :keys) :map) sort ","k [] ","data keys map ","time_range is_a? "," time_range "," now ","tr first "," round_time >= ","tr last "," options [] == "," options [] "," options ","next_step hour != ","next_step hour "," loop "," day_start ","sorted_keys any? ","time_range begin "," day_start / "," n_seconds ","Range  new ","time_range exclude_end? ","time_range end "," step "," round_time  == ","last_step +  == ","next_1 send  == ","next_3 months  == ","next_ n_seconds  == ","next_ step  == "," time_range  cover? ","series last  + ","last_1 send  + ","last_3 months  + ","last_ n_seconds  + ","last_ step  + "," time_range  first ","data keys sort  last ","(send\n  (send\n    (lvar :data) :keys) :map) sort  last ","data keys sort  first ","(send\n  (send\n    (lvar :data) :keys) :map) sort  first "," time_range  is_a? ","  time_range  "," round_time  hour != ","last_step +  hour != ","next_1 send  hour != ","next_3 months  hour != ","next_ n_seconds  hour != ","next_ step  hour != "," round_time  hour ","last_step +  hour ","next_1 send  hour ","next_3 months  hour ","next_ n_seconds  hour ","next_ step  hour ","data keys sort  any? ","(send\n  (send\n    (lvar :data) :keys) :map) sort  any? "," time_range  begin "," time_range  exclude_end? "," time_range  end "," 1 send  "," 3 months  ","  n_seconds  ","  step  "]}," Groupdate SeriesBuilder time_range":{"type":"method","name":"time_range","children":[],"call":[" round_time ","start_at - "," options [] == "," options [] "," options ","(send\n  (send\n    (send\n      (send nil :options) :[]\n      (sym :last)) :to_i) :-\n  (int 1)) times "," options [] to_i - "," options [] to_i "," time_zone now "," time_zone "," raise "," period ","1 send ","1 respond_to? ","3 months "," period == ","time_range ! ","Range  new "," time_zone parse ","time_range first to_s ","time_range first ","1 day ","time_range exclude_end? ","time_range last to_s ","time_range last ","time_range first is_a? ","time_range is_a? "," now "," round_time + ","time_range first in_time_zone ","time_range last in_time_zone "," n_seconds ","time_range end ","time_range begin ","time_range end is_a? ","time_range begin is_a? ","exclude_end ! ","finish in_time_zone ","start in_time_zone ","v class name ","v class "," warn ","(send\n  (lvar :time_range) :begin) each "," step ","(and\n  (send\n    (lvar :finish) :==\n    (send nil :round_time\n      (lvar :finish)))\n  (lvar :exclude_end)) ! ","finish == ","time_range end is_a? ! "," now  - "," time_zone parse _at - ","start in_time_zone _at - ","time_range begin _at - "," round_time _at - ","(send\n  (send\n    (send\n      (send nil :options) :[]\n      (sym : time_zone parse )) :to_i) :-\n  (int 1)) times ","(send\n  (send\n    (send\n      (send nil :options) :[]\n      (sym :time_range last in_time_zone )) :to_i) :-\n  (int 1)) times "," time_zone  time_zone now  ","Range  new  ! "," options []  ! ","Range  new  first to_s "," options []  first to_s ","Range  new  first "," options []  first ","Range  new  exclude_end? "," options []  exclude_end? ","time_range time_range exclude_end? ? ","Range  new  last to_s "," options []  last to_s ","time_range  time_zone parse  to_s ","time_range time_range last in_time_zone  to_s ","Range  new  last "," options []  last ","time_range  time_zone parse  ","time_range time_range last in_time_zone  ","Range  new  first is_a? "," options []  first is_a? ","Range  new  is_a? "," options []  is_a? ","  time_zone now  ","Range  new  first in_time_zone "," options []  first in_time_zone ","Range  new  last in_time_zone "," options []  last in_time_zone ","time_range  time_zone parse  in_time_zone ","time_range time_range last in_time_zone  in_time_zone ","Range  new  end "," options []  end ","Range  new  begin "," options []  begin ","Range  new  end is_a? "," options []  end is_a? ","Range  new  begin is_a? "," options []  begin is_a? ","time_range exclude_end?  ! ","finish in_time_zone  in_time_zone ","time_range end  in_time_zone "," round_time +  in_time_zone "," time_zone parse  in_time_zone ","start in_time_zone  in_time_zone ","time_range begin  in_time_zone "," round_time  in_time_zone ","(send\n  (lvar :Range  new ) :begin) each ","(send\n  (lvar : options [] ) :begin) each "," 1 send  "," 3 months  ","  n_seconds  ","  step  ","(and\n  (send\n    (lvar :finish in_time_zone ) :==\n    (send nil :round_time\n      (lvar :finish in_time_zone )))\n  (lvar :exclude_end)) ! ","(and\n  (send\n    (lvar :time_range end ) :==\n    (send nil :round_time\n      (lvar :time_range end )))\n  (lvar :exclude_end)) ! ","(and\n  (send\n    (lvar : round_time + ) :==\n    (send nil :round_time\n      (lvar : round_time + )))\n  (lvar :exclude_end)) ! ","(and\n  (send\n    (lvar :finish) :==\n    (send nil :round_time\n      (lvar :finish)))\n  (lvar :time_range exclude_end? )) ! ","finish in_time_zone  == ","time_range end  == "," round_time +  == ","Range  new  end is_a? ! "," options []  end is_a? ! "]}," Groupdate SeriesBuilder round_time":{"type":"method","name":"round_time","children":[],"call":["time + "," day_start seconds "," day_start ","time is_a? "," raise ","time month ","time day ","(send\n  (send\n    (send\n      (lvar :time) :wday) :-\n    (int 1)) :-\n  (send nil :week_start)) % ","time wday - - "," week_start ","time wday - ","time wday ","time min ","time hour ","time beginning_of_year ","time beginning_of_quarter ","time beginning_of_month ","(send\n  (lvar :time) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (send nil :week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","time - ","(send\n  (begin\n    (send\n      (send\n        (int 7) :-\n        (send nil :week_start)) :+\n      (lvar :weekday))) :%\n  (int 7)) days ","(send\n  (send\n    (int 7) :-\n    (send nil :week_start)) :+\n  (lvar :weekday)) % ","7 - + ","7 - ","(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ","time beginning_of_day ","time change "," period ","time to_time in_time_zone - ","time to_time in_time_zone "," time_zone ","time to_time "," day_start != ","time yday "," change_zone call "," change_zone ","time days_to_week_start ","time beginning_of_week "," utc "," time_zone at ","(send\n  (send\n    (send\n      (lvar :time) :to_time) :to_i) :/\n  (send nil :n_seconds)) * "," n_seconds ","time to_time to_i / ","time to_time to_i "," period == ","time to_time in_time_zone -  + ","time to_time in_time_zone  + "," change_zone call  + ","time change  + ","time to_time in_time_zone -  is_a? ","time to_time in_time_zone  is_a? "," change_zone call  is_a? ","time change  is_a? ","time to_time in_time_zone -  month ","time to_time in_time_zone  month "," change_zone call  month ","time change  month ","time to_time in_time_zone -  day ","time to_time in_time_zone  day "," change_zone call  day ","time change  day ","(send\n  (send\n    (send\n      (lvar :time to_time in_time_zone - ) :wday) :-\n    (int 1)) :-\n  (send nil :week_start)) % ","(send\n  (send\n    (send\n      (lvar :time to_time in_time_zone ) :wday) :-\n    (int 1)) :-\n  (send nil :week_start)) % ","(send\n  (send\n    (send\n      (lvar : change_zone call ) :wday) :-\n    (int 1)) :-\n  (send nil :week_start)) % ","(send\n  (send\n    (send\n      (lvar :time change ) :wday) :-\n    (int 1)) :-\n  (send nil :week_start)) % ","time to_time in_time_zone -  wday - - ","time to_time in_time_zone  wday - - "," change_zone call  wday - - ","time change  wday - - ","time to_time in_time_zone -  wday - ","time to_time in_time_zone  wday - "," change_zone call  wday - ","time change  wday - ","time to_time in_time_zone -  wday ","time to_time in_time_zone  wday "," change_zone call  wday ","time change  wday ","time to_time in_time_zone -  min ","time to_time in_time_zone  min "," change_zone call  min ","time change  min ","time to_time in_time_zone -  hour ","time to_time in_time_zone  hour "," change_zone call  hour ","time change  hour ","time to_time in_time_zone -  beginning_of_year ","time to_time in_time_zone  beginning_of_year "," change_zone call  beginning_of_year ","time change  beginning_of_year ","time to_time in_time_zone -  beginning_of_quarter ","time to_time in_time_zone  beginning_of_quarter "," change_zone call  beginning_of_quarter ","time change  beginning_of_quarter ","time to_time in_time_zone -  beginning_of_month ","time to_time in_time_zone  beginning_of_month "," change_zone call  beginning_of_month ","time change  beginning_of_month ","(send\n  (lvar :time) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (send nil :week_start)) :+\n            (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ))) :%\n        (int 7))) :days)) midnight ","(send\n  (lvar :time to_time in_time_zone - ) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (send nil :week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","(send\n  (lvar :time to_time in_time_zone ) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (send nil :week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","(send\n  (lvar : change_zone call ) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (send nil :week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","(send\n  (lvar :time change ) :-\n  (send\n    (begin\n      (send\n        (begin\n          (send\n            (send\n              (int 7) :-\n              (send nil :week_start)) :+\n            (lvar :weekday))) :%\n        (int 7))) :days)) midnight ","time to_time in_time_zone -  - ","time to_time in_time_zone  - "," change_zone call  - ","time change  - ","(send\n  (begin\n    (send\n      (send\n        (int 7) :-\n        (send nil :week_start)) :+\n      (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % ))) :%\n  (int 7)) days ","(send\n  (send\n    (int 7) :-\n    (send nil :week_start)) :+\n  (lvar :(send\n  (send\n    (lvar :time) :wday) :-\n  (int 1)) % )) % ","(send\n  (send\n    (lvar :time to_time in_time_zone - ) :wday) :-\n  (int 1)) % ","(send\n  (send\n    (lvar :time to_time in_time_zone ) :wday) :-\n  (int 1)) % ","(send\n  (send\n    (lvar : change_zone call ) :wday) :-\n  (int 1)) % ","(send\n  (send\n    (lvar :time change ) :wday) :-\n  (int 1)) % ","time to_time in_time_zone -  beginning_of_day ","time to_time in_time_zone  beginning_of_day "," change_zone call  beginning_of_day ","time change  beginning_of_day ","time to_time in_time_zone -  change ","time to_time in_time_zone  change "," change_zone call  change ","time change  change ","time to_time in_time_zone -  to_time to_time in_time_zone -  in_time to_time in_time_zone - _zone - ","time to_time in_time_zone  to_time to_time in_time_zone  in_time to_time in_time_zone _zone - "," change_zone call  to_ change_zone call  in_ change_zone call _zone - ","time change  to_time change  in_time change _zone - ","time to_time in_time_zone -  to_time to_time in_time_zone -  in_time to_time in_time_zone - _zone ","time to_time in_time_zone  to_time to_time in_time_zone  in_time to_time in_time_zone _zone "," change_zone call  to_ change_zone call  in_ change_zone call _zone ","time change  to_time change  in_time change _zone "," time to_time in_time_zone - _zone "," time to_time in_time_zone _zone ","  change_zone call _zone "," time change _zone ","time to_time in_time_zone -  to_time to_time in_time_zone -  ","time to_time in_time_zone  to_time to_time in_time_zone  "," change_zone call  to_ change_zone call  ","time change  to_time change  ","time to_time in_time_zone -  yday ","time to_time in_time_zone  yday "," change_zone call  yday ","time change  yday ","time to_time in_time_zone -  days_to_week_start ","time to_time in_time_zone  days_to_week_start "," change_zone call  days_to_week_start ","time change  days_to_week_start ","time to_time in_time_zone -  beginning_of_week ","time to_time in_time_zone  beginning_of_week "," change_zone call  beginning_of_week ","time change  beginning_of_week "," time to_time in_time_zone - _zone at "," time to_time in_time_zone _zone at ","  change_zone call _zone at "," time change _zone at ","(send\n  (send\n    (send\n      (lvar :time to_time in_time_zone - ) :to_time to_time in_time_zone - ) :to_i) :/\n  (send nil :n_seconds)) * ","(send\n  (send\n    (send\n      (lvar :time to_time in_time_zone ) :to_time to_time in_time_zone ) :to_i) :/\n  (send nil :n_seconds)) * ","(send\n  (send\n    (send\n      (lvar : change_zone call ) :to_ change_zone call ) :to_i) :/\n  (send nil :n_seconds)) * ","(send\n  (send\n    (send\n      (lvar :time change ) :to_time change ) :to_i) :/\n  (send nil :n_seconds)) * ","time to_time in_time_zone -  to_time to_time in_time_zone -  to_i / ","time to_time in_time_zone  to_time to_time in_time_zone  to_i / "," change_zone call  to_ change_zone call  to_i / ","time change  to_time change  to_i / ","time to_time in_time_zone -  to_time to_time in_time_zone -  to_i ","time to_time in_time_zone  to_time to_time in_time_zone  to_i "," change_zone call  to_ change_zone call  to_i ","time change  to_time change  to_i "]}," Groupdate SeriesBuilder generate":{"type":"method","name":"generate","children":[],"call":["Hash  [] "," key_format call "," key_format ","k [] + + ","k [] ","group_index + ","k [] + ","@options [] ","data [] ","series map ","series select "," entire_series? "," handle_multiple "," generate_series "," check_consistent_time_zone_info ","CHECK_PERIODS  include? "," period ","data delete ","verified_data [] "," raise ","key != "," round_time ","verified_data []= ","k []= ","1 hour ","series include? ","key - ","key hour == ","(send\n  (lvar :key) :-\n  (send\n    (int 1) :hour)) hour ","key hour ","data each ","series each ","series to_h ","  key_format call _format call "," k [] + + _format call "," k [] _format call ","  key_format call _format "," k [] + + _format "," k [] _format "," handle_multiple  map "," generate_series  map "," handle_multiple  select "," generate_series  select "," entire_ handle_multiple ? "," entire_ generate_series ? "," generate_ handle_multiple  "," generate_ generate_series  "," key_format call  != ","k [] + +  != ","k []  != "," handle_multiple  include? "," generate_series  include? "," key_format call  - ","k [] + +  - ","k []  - "," key_format call  hour == ","k [] + +  hour == ","k []  hour == ","(send\n  (lvar : key_format call ) :-\n  (send\n    (int 1) :hour)) hour ","(send\n  (lvar :k [] + + ) :-\n  (send\n    (int 1) :hour)) hour ","(send\n  (lvar :k [] ) :-\n  (send\n    (int 1) :hour)) hour "," key_format call  hour ","k [] + +  hour ","k []  hour "," handle_multiple  each "," generate_series  each "," handle_multiple  to_h "," generate_series  to_h "]}," Groupdate SeriesBuilder initialize":{"type":"method","name":"initialize","children":[],"call":["Groupdate Magic DAYS  [] "]}," Groupdate RelationBuilder where_clause":{"type":"method","name":"where_clause","children":[],"call":[" column ","@time_range last ","@time_range first ","@time_range is_a? ","@time_range exclude_end? ","@time_range begin ","@time_range end "]}," Groupdate RelationBuilder clean_group_clause_mysql":{"type":"method","name":"clean_group_clause_mysql","children":[],"call":["clause [] ","clause end_with? ","clause start_with? ","clause gsub "," column ","clause []  [] ","clause gsub  [] ","clause []  end_with? ","clause gsub  end_with? ","clause []  start_with? ","clause gsub  start_with? ","clause []  gsub ","clause gsub  gsub "]}," Groupdate RelationBuilder clean_group_clause_postgresql":{"type":"method","name":"clean_group_clause_postgresql","children":[],"call":["clause gsub "]}," Groupdate RelationBuilder group_clause":{"type":"method","name":"group_clause","children":[],"call":[" clean_group_clause_mysql "," clean_group_clause_postgresql ","@relation send ","query []= ","query [] "," period == "," period ","adapter_name == "," raise "," day_start "," column "," week_start ","format gsub "," week_start == "," day_start zero? ","@time_zone utc_offset zero? ","@time_zone utc_offset ","7 - "," day_start / ","@relation connection adapter_name ","@relation connection ","@time_zone tzinfo name ","@time_zone tzinfo ","(send\n  (send nil :week_start) :+\n  (int 1)) % "," week_start + "," day_start == ","13 - ","12 - "," n_seconds "," clean_group_ clean_group_clause_postgresql _mysql "," clean_group_@relation send _mysql "," clean_group_ clean_group_clause_postgresql _postgresql "," clean_group_@relation send _postgresql ","@relation connection adapter_name  == ","@@time_zone tzinfo name  utc_offset zero? ","@@time_zone tzinfo name  utc_offset ","@relation connection @relation connection adapter_name  ","@@time_zone tzinfo name  tzinfo name ","@@time_zone tzinfo name  tzinfo "]}," Groupdate RelationBuilder generate":{"type":"method","name":"generate","children":[],"call":["@relation group where "," where_clause ","@relation group "," group_clause "]}," Groupdate RelationBuilder initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","relation default_timezone == ","relation default_timezone "," resolve_column "," validate_column "]}," Groupdate Magic Relation check_time_zone_support":{"type":"method","name":"check_time_zone_support","children":[],"call":[" raise ","result key? ","result keys first [] nil? ","result keys first [] "," group_index ","result keys first ","result keys "]}," Groupdate Magic Relation cast_result":{"type":"method","name":"cast_result","children":[],"call":["Hash  [] "," cast_method call "," cast_method ","k [] + + ","k [] "," group_index + "," group_index ","k [] + ","result map ","new_result []= ","k []= ","result each "," cast_method call  [] + + "," cast_method call  [] "," cast_method call  [] + "," cast_method call  []= "]}," Groupdate Magic Relation cast_method":{"type":"method","name":"cast_method","children":[],"call":["(if\n  (or\n    (send\n      (lvar :k) :is_a?\n      (const nil :String))\n    (send\n      (send\n        (lvar :k) :respond_to?\n        (sym :to_time)) :!))\n  (send\n    (lvar :utc) :parse\n    (send\n      (lvar :k) :to_s))\n  (send\n    (lvar :k) :to_time)) in_time_zone "," time_zone ","k to_time ","utc parse ","k to_s ","k respond_to? ! ","k respond_to? ","k is_a? "," lambda ","ActiveSupport TimeZone  [] ","k to_i ","(send\n  (send\n    (send\n      (lvar :k) :to_i) :-\n    (int 1)) :-\n  (send nil :week_start)) % ","k to_i - - "," week_start ","k to_i - "," period ","k in_time_zone ","k in_time_zone change ","(send\n  (send nil :day_start) :%\n  (int 3600)) % "," day_start % "," day_start ","(send\n  (send nil :day_start) :%\n  (int 3600)) / "," day_start / "," day_start != ","(if\n  (or\n    (send\n      (lvar :k) :is_a?\n      (const nil :String))\n    (send\n      (send\n        (lvar :k) :respond_to?\n        (sym :to_time)) :!))\n  (send\n    (lvar :ActiveSupport TimeZone  [] ) :parse\n    (send\n      (lvar :k) :to_s))\n  (send\n    (lvar :k) :to_time)) in_time_zone ","ActiveSupport TimeZone  []  parse "]}," Groupdate Magic series_builder":{"type":"method","name":"series_builder","children":[],"call":["SeriesBuilder  new "," week_start "," day_start "," time_zone "," period "," options "," n_seconds "," range "]}," Groupdate process_result":{"type":"method","name":"process_result","children":[],"call":[]}," Groupdate SeriesBuilder now":{"type":"method","name":"now","children":[],"call":[" time_zone now "," time_zone "]}," Groupdate SeriesBuilder check_consistent_time_zone_info":{"type":"method","name":"check_consistent_time_zone_info","children":[],"call":[" raise ","key != "," round_time ","keys each ","keys uniq! ","k [] ","keys map! ","data keys ","data keys  each ","data keys  uniq! ","data keys  map! ","data data keys  "]}," Groupdate Magic Relation check_nils":{"type":"method","name":"check_nils","children":[],"call":[" raise "," time_zone tzinfo name "," time_zone tzinfo "," time_zone "," time_zone_support? ","result key? ","result keys first [] nil? ","result keys first [] "," group_index ","result keys first ","result keys "]}," Groupdate Magic Relation time_zone_support?":{"type":"method","name":"time_zone_support?","children":[],"call":["relation connection select_all first values first nil? ! ","relation connection select_all first values first nil? ","relation connection select_all first values first ","relation connection select_all first values ","relation connection select_all first ","relation connection select_all ","relation connection ","relation send "," time_zone tzinfo name "," time_zone tzinfo "," time_zone ","relation connection adapter_name =~ ","relation connection adapter_name ","relation klass send ","relation klass "]}," Groupdate RelationBuilder resolve_column":{"type":"method","name":"resolve_column","children":[],"call":["relation connection visitor accept value ","relation connection visitor accept ","Arel Collectors SQLString  new ","relation connection visitor ","relation connection ","Arel Nodes SqlLiteral  new ","node is_a? ","relation send send first ","relation send send ","relation send ","Arel Nodes SqlLiteral  new  is_a? ","relation send send first  is_a? "]}," Groupdate SeriesBuilder utc":{"type":"method","name":"utc","children":[],"call":["ActiveSupport TimeZone  [] "]}," Groupdate SeriesBuilder change_zone":{"type":"method","name":"change_zone","children":[],"call":["zone parse ","time strftime "," lambda ","time change ","ActiveSupport VERSION STRING  >= "]}," Groupdate Magic validate_period":{"type":"method","name":"validate_period","children":[],"call":[]}," Groupdate Magic validate_arguments":{"type":"method","name":"validate_arguments","children":[],"call":[" raise ","(send\n  (send nil :day_start) :/\n  (int 3600)) >= "," day_start / "," day_start ","(send\n  (send nil :day_start) :/\n  (int 3600)) < "," options [] end ! "," options [] end "," options [] "," options "," options [] is_a? "," week_start "," time_zone "]}," Groupdate Magic validate_keywords":{"type":"method","name":"validate_keywords","children":[],"call":[" raise ","unknown_keywords join ","unknown_keywords any? "," options keys - "," options keys "," options ","known_keywords << ","(sym :day) include? "," period ","(sym :week) include? ","(sym :second) include? "," options keys -  join "," options keys -  any? "]}," Groupdate RelationBuilder validate_column":{"type":"method","name":"validate_column","children":[],"call":[" warn ","(str \"\\\\A\\\\w+(\\\\.\\\\w+)?\\\\z\") match ","column to_s ","column is_a? "]}," Groupdate register_adapter":{"type":"method","name":"register_adapter","children":[],"call":[]}," Groupdate adapters":{"type":"method","name":"adapters","children":[],"call":[]}," Groupdate Magic range":{"type":"method","name":"range","children":[],"call":["time_range end nil? ","time_range end ","time_range begin nil? ","time_range begin ","time_range is_a? "," options [] "," options "," options []  end nil? "," options []  end "," options []  begin nil? "," options []  begin "," options []  is_a? "]}," Groupdate Adapters SQLiteAdapter group_clause":{"type":"method","name":"group_clause","children":[],"call":["@relation send "," column "," raise "," period "," n_seconds "," period == ","(send\n  (send nil :week_start) :+\n  (int 1)) % "," week_start + "," week_start "," day_start zero? "," day_start ","@time_zone utc_offset zero? ","@time_zone utc_offset "]}," Groupdate Adapters RedshiftAdapter group_clause":{"type":"method","name":"group_clause","children":[],"call":["@relation send "," period "," raise "," week_start "," day_start "," column ","@time_zone tzinfo name ","@time_zone tzinfo ","@@time_zone tzinfo name  tzinfo name ","@@time_zone tzinfo name  tzinfo "]}," Groupdate Adapters PostgreSQLAdapter clean_group_clause":{"type":"method","name":"clean_group_clause","children":[],"call":["clause gsub "]}," Groupdate Adapters PostgreSQLAdapter group_clause":{"type":"method","name":"group_clause","children":[],"call":[" clean_group_clause ","@relation send "," period "," day_start == "," day_start "," n_seconds "," column ","13 - "," week_start ","@time_zone tzinfo name ","@time_zone tzinfo ","@relation connection adapter_name == ","@relation connection adapter_name ","@relation connection ","@@time_zone tzinfo name  tzinfo name ","@@time_zone tzinfo name  tzinfo "]}," Groupdate Adapters MySQLAdapter clean_group_clause":{"type":"method","name":"clean_group_clause","children":[],"call":["clause gsub ","clause gsub gsub "]}," Groupdate Adapters MySQLAdapter group_clause":{"type":"method","name":"group_clause","children":[],"call":[" clean_group_clause ","@relation send "," day_start "," period "," n_seconds "," column ","12 - "," week_start ","@time_zone tzinfo name ","@time_zone tzinfo ","@@time_zone tzinfo name  tzinfo name ","@@time_zone tzinfo name  tzinfo "]}," Groupdate Adapters BaseAdapter resolve_column":{"type":"method","name":"resolve_column","children":[],"call":["relation connection visitor accept value ","relation connection visitor accept ","Arel Collectors SQLString  new ","relation connection visitor ","relation connection ","Arel Nodes SqlLiteral  new ","node is_a? ","relation send send first ","relation send send ","relation send ","Arel Nodes SqlLiteral  new  is_a? ","relation send send first  is_a? "]}," Groupdate Adapters BaseAdapter validate_column":{"type":"method","name":"validate_column","children":[],"call":[" warn ","(str \"\\\\A\\\\w+(\\\\.\\\\w+)?\\\\z\") match ","column to_s ","column is_a? ","column to_s  to_s ","column to_s  is_a? "]}," Groupdate Adapters BaseAdapter where_clause":{"type":"method","name":"where_clause","children":[],"call":[" column ","@time_range begin ","@time_range end ","@time_range exclude_end? ","@time_range is_a? "]}," Groupdate Adapters BaseAdapter generate":{"type":"method","name":"generate","children":[],"call":["@relation group where "," where_clause ","@relation group "," group_clause "]}," Groupdate Adapters BaseAdapter initialize":{"type":"method","name":"initialize","children":[],"call":[" raise ","relation default_timezone == ","relation default_timezone "," resolve_column "," validate_column ","ActiveRecord  default_timezone == ","ActiveRecord  default_timezone ","ActiveRecord VERSION MAJOR  >= "," resolve_ validate_column  "," validate_ validate_column  "]}," Groupdate Magic Relation resolve_column":{"type":"method","name":"resolve_column","children":[],"call":["relation connection visitor accept value ","relation connection visitor accept ","Arel Collectors SQLString  new ","relation connection visitor ","relation connection ","Arel Nodes SqlLiteral  new ","node is_a? ","relation send send first ","relation send send ","relation send ","Arel Nodes SqlLiteral  new  is_a? ","relation send send first  is_a? "]}," Groupdate Magic Relation validate_column":{"type":"method","name":"validate_column","children":[],"call":[" raise ","column inspect ","(str \"\\\\A\\\\w+(\\\\.\\\\w+)?\\\\z\") match ","column to_s ","column is_a? ","column to_s  inspect ","column to_s  to_s ","column to_s  is_a? "]}," Groupdate SeriesBuilder step":{"type":"method","name":"step","children":[],"call":["1 send "," period ","1 respond_to? "," n_seconds "," period == ","3 months "]}}