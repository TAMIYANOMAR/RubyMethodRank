{" Kernel require_relative":{"type":"method","name":"require_relative","children":[],"call":[" require ","File  expand_path ","File  dirname "," raise "," caller first split first "," caller first split "," caller first "," caller ","Backports  convert_path "]}," Symbol to_proc":{"type":"method","name":"to_proc","children":[],"call":["args shift __send__ ","args shift ","Proc  new "]}," String demodulize":{"type":"method","name":"demodulize","children":[],"call":["class_name_in_module to_s gsub ","class_name_in_module to_s "," gsub "]}," String dasherize":{"type":"method","name":"dasherize","children":[],"call":["underscored_word gsub "," gsub "]}," String constantize":{"type":"method","name":"constantize","children":[],"call":["constant const_missing ","constant const_get ","constant const_defined? ","names each ","names shift ","names first empty? ","names first ","names empty? ","camel_cased_word split "," split ","constant const_missing  const_missing ","constant const_get  const_missing ","constant const_missing  const_get ","constant const_get  const_get ","constant const_missing  const_defined? ","constant const_get  const_defined? ","camel_cased_word split  each "," split  each ","camel_cased_word split  shift "," split  shift ","camel_cased_word split  first empty? "," split  first empty? ","camel_cased_word split  first "," split  first ","camel_cased_word split  empty? "," split  empty? "]}," String underscore":{"type":"method","name":"underscore","children":[],"call":["camel_cased_word to_s gsub gsub gsub tr downcase ","camel_cased_word to_s gsub gsub gsub tr ","camel_cased_word to_s gsub gsub gsub ","camel_cased_word to_s gsub gsub ","camel_cased_word to_s gsub ","camel_cased_word to_s "," gsub gsub gsub tr downcase "," gsub gsub gsub tr "," gsub gsub gsub "," gsub gsub "," gsub "]}," String camelize":{"type":"method","name":"camelize","children":[],"call":[" first downcase + "," camelize [] "," camelize "," first downcase "," first ","1 upcase ","(send nil :gsub\n  (regexp\n    (str \"/(.?)\")\n    (regopt))) gsub "," gsub ","first_letter == "," [] downcase + "," [] downcase "," [] "]}," String getbyte":{"type":"method","name":"getbyte","children":[],"call":[" [] "]}," String end_with?":{"type":"method","name":"end_with?","children":[],"call":[" [] == "," [] ","suffix length ","suffix length -@ ","suffix to_s ","suffix to_str ","suffix respond_to? ","suffixes each ","suffixes any? ","suffix to_s  length ","suffix to_str  length ","suffix to_s  length -@ ","suffix to_str  length -@ ","suffix to_s  to_s ","suffix to_str  to_s ","suffix to_s  to_str ","suffix to_str  to_str ","suffix to_s  respond_to? ","suffix to_str  respond_to? ","suffix to_s es each ","suffix to_str es each ","suffix to_s es any? ","suffix to_str es any? "]}," String start_with?":{"type":"method","name":"start_with?","children":[],"call":[" [] == "," [] ","prefix length ","prefix to_s ","prefix to_str ","prefix respond_to? ","prefixes each ","prefixes any? ","prefix to_s  length ","prefix to_str  length ","prefix to_s  to_s ","prefix to_str  to_s ","prefix to_s  to_str ","prefix to_str  to_str ","prefix to_s  respond_to? ","prefix to_str  respond_to? ","prefix to_s es each ","prefix to_str es each ","prefix to_s es any? ","prefix to_str es any? "]}," Object returning":{"type":"method","name":"returning","children":[],"call":[]}," Object tap":{"type":"method","name":"tap","children":[],"call":[]}," Object try":{"type":"method","name":"try","children":[],"call":[" send "," nil? "," try! "," respond_to? ","a first ","a empty? "," public_send "," instance_eval ","b arity == ","b arity "," block_given? "]}," Module alias_method_chain":{"type":"method","name":"alias_method_chain","children":[],"call":[" private "," private_method_defined? "," protected "," protected_method_defined? "," public "," public_method_defined? "," alias_method "," block_given? ","target to_s sub ","target to_s ","Backports  alias_method_chain "]}," Hash symbolize_keys!":{"type":"method","name":"symbolize_keys!","children":[],"call":[" replace "," symbolize_keys "]}," Hash symbolize_keys":{"type":"method","name":"symbolize_keys","children":[],"call":["Hash  [] ","key to_sym "," map "]}," Hash []":{"type":"method","name":"[]","children":[],"call":["h []= ","arg first each ","arg first "," returning "," original_constructor ","arg first is_a? ","arg length == ","arg length ","arr at ","(irange\n  (int 1)\n  (int 2)) include? ","arr size ","arr to_ary ","arr respond_to? ","args first each ","args first "," tap ","args first is_a? ","args length == ","args length "," constructor_without_key_value_pair_form ","arr == ","Backports  is_array? ","arr to_ary  at ","arr to_ary  size ","arr to_ary  to_ary ","arr to_ary  respond_to? ","arr to_ary  == ","Backports  is_arr to_ary ay? "]}," Fixnum even?":{"type":"method","name":"even?","children":[],"call":[" & == "," & "]}," Fixnum odd?":{"type":"method","name":"odd?","children":[],"call":[" & == "," & "]}," Enumerable first":{"type":"method","name":"first","children":[],"call":[" take ","arg first "," take [] ","arg empty? "," each ","n == ","array size >= ","array size ","array << "," raise ","n < ","Backports  coerce_to_int ","Backports  coerce_to_int  == ","Backports  coerce_to_int  < ","Backports  coerce_to_iBackports  coerce_to_int t "]}," Enumerable drop_while":{"type":"method","name":"drop_while","children":[],"call":["array drop ","array each_with_index "," to_a "," raise "," block_given? ","ary << "," each "," to_enum "," to_a  drop "," to_a  each_with_index "]}," Enumerable drop":{"type":"method","name":"drop","children":[],"call":["array [] ","array size "," to_a ","ary [] ","ary size ","n > "," raise ","n < ","Backports  coerce_to ","Backports  coerce_to_int ","Type  coerce_to "," to_a  [] "," to_a  size ","Backports  coerce_to  > ","Backports  coerce_to_int  > ","Type  coerce_to  > ","Backports  coerce_to  < ","Backports  coerce_to_int  < ","Type  coerce_to  < ","Backports  coerce_to_iBackports  coerce_to t ","Backports  coerce_to_iBackports  coerce_to_int t ","Backports  coerce_to_iType  coerce_to t "]}," Enumerable take_while":{"type":"method","name":"take_while","children":[],"call":["array << "," inject "," raise "," block_given? "," to_enum "]}," Enumerable take":{"type":"method","name":"take","children":[],"call":["array size >= ","array size ","array << "," each ","n <= "," returning "," tap "," raise ","n < ","Backports  coerce_to ","Backports  coerce_to_int ","Type  coerce_to "," first ","Backports  coerce_to  <= ","Backports  coerce_to_int  <= ","Type  coerce_to  <= "," returBackports  coerce_to iBackports  coerce_to g "," returBackports  coerce_to_int iBackports  coerce_to_int g "," returType  coerce_to iType  coerce_to g ","Backports  coerce_to  < ","Backports  coerce_to_int  < ","Type  coerce_to  < ","Backports  coerce_to_iBackports  coerce_to t ","Backports  coerce_to_iBackports  coerce_to_int t ","Backports  coerce_to_iType  coerce_to t "]}," Enumerable find_index":{"type":"method","name":"find_index","children":[],"call":[" each_with_index "," index "," block_given? "," raise ","args size ","element == ","args first ","args size == "," to_enum ","obj != ","args size > ","args first  != "]}," Enumerable sum":{"type":"method","name":"sum","children":[],"call":["sum + "," inject "," map sum "," map "," block_given? "," size > "," size ","values inject "," map  inject "]}," Hash reverse_merge!":{"type":"method","name":"reverse_merge!","children":[],"call":[" replace "," reverse_merge "]}," Hash reverse_merge":{"type":"method","name":"reverse_merge","children":[],"call":["other_hash merge "]}," Array index_with_block":{"type":"method","name":"index_with_block","children":[],"call":[" each_with_index "," index_without_block ","arg empty? "," block_given? "," to_enum "," block_given? ! "]}," Array recursively_flatten_finite":{"type":"method","name":"recursively_flatten_finite","children":[],"call":["out << "," recursively_flatten_finite ","level - ","o to_ary ","o respond_to? ","array each ","out concat ","level <= ","Backports  is_array? ","o to_Backports  is_array?  "]}," Array flatten_with_optional_argument!":{"type":"method","name":"flatten_with_optional_argument!","children":[],"call":[" replace "," recursively_flatten_finite "," flatten_without_optional_argument! ","level == ","1 / ","level >= ","Backports  coerce_to ","Backports  coerce_to_int ","Type  coerce_to ","level < ","Backports  coerce_to  == ","Backports  coerce_to_int  == ","Type  coerce_to  == ","Backports  coerce_to  >= ","Backports  coerce_to_int  >= ","Type  coerce_to  >= ","Backports  coerce_to  < ","Backports  coerce_to_int  < ","Type  coerce_to  < "]}," Array flatten_with_optional_argument":{"type":"method","name":"flatten_with_optional_argument","children":[],"call":[" dup flatten! "," dup "," flatten_without_optional_argument ","level == ","1 / "]}," Backports Yielder yield":{"type":"method","name":"yield","children":[],"call":["@final_block yield "]}," Backports Yielder each":{"type":"method","name":"each","children":[],"call":["@main_block call "]}," Backports Yielder initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Backports coerce_to_comparison":{"type":"method","name":"coerce_to_comparison","children":[],"call":["a <=> "]}," Backports coerce_to":{"type":"method","name":"coerce_to","children":[],"call":[]}," Backports alias_method_chain":{"type":"method","name":"alias_method_chain","children":[],"call":[]}," Backports convert_to_path":{"type":"method","name":"convert_to_path","children":[],"call":[]}," Backports convert_all_arguments_to_path":{"type":"method","name":"convert_all_arguments_to_path","children":[],"call":[]}," Backports convert_first_argument_to_path":{"type":"method","name":"convert_first_argument_to_path","children":[],"call":[]}," Backports make_block_optional":{"type":"method","name":"make_block_optional","children":[],"call":[]}," Backports require_relative":{"type":"method","name":"require_relative","children":[],"call":[]}," Kernel returning":{"type":"method","name":"returning","children":[],"call":[]}," Kernel try":{"type":"method","name":"try","children":[],"call":[" send "," nil? "]}," Hash stringify_keys!":{"type":"method","name":"stringify_keys!","children":[],"call":[" replace "," stringify_keys "]}," Hash stringify_keys":{"type":"method","name":"stringify_keys","children":[],"call":["Hash  [] ","key to_s "," map "]}," Array extract_options!":{"type":"method","name":"extract_options!","children":[],"call":[" pop "," last is_a? "," last "]}," BasicObject inherited":{"type":"method","name":"inherited","children":[],"call":[" undef_method "," instance_method owner == ","Object  instance_method owner ","Object  instance_method "," instance_method owner "," instance_method ","Object  method_defined? ","(send\n  (send nil :instance_methods) :-\n  (const nil :KEEP)) each "," instance_methods - "," instance_methods ","BasicObject  class_eval "]}," BasicObject ===":{"type":"method","name":"===","children":[],"call":[]}," Symbol casecmp":{"type":"method","name":"casecmp","children":[],"call":[" to_s casecmp ","with to_s "," to_s ","with is_a? "]}," Symbol <=>":{"type":"method","name":"<=>","children":[],"call":[" to_s <=> ","with to_s "," to_s ","with is_a? "]}," String codepoints":{"type":"method","name":"codepoints","children":[],"call":["(send\n  (lvar :result) :<<\n  (int 6)) + ","b & ","result << ","utf8 inject ","255 >> ","utf8 size ","utf8 [] ","s each_byte to_a ","s each_byte "," each_char each "," each_char "," to_enum "," block_given? "," unpack each "," unpack ","s each_byte to_a  inject ","s each_byte to_a  size ","s each_byte to_a  [] "]}," String clear":{"type":"method","name":"clear","children":[],"call":[" []= "," length "]}," String ascii_only?":{"type":"method","name":"ascii_only?","children":[],"call":["(send\n  (self) :=~\n  (regexp\n    (str \"[^\\\\x00-\\\\x7f]\")\n    (regopt))) ! "," =~ "]}," String try_convert":{"type":"method","name":"try_convert","children":[],"call":["x to_str ","x respond_do ","Backports  try_convert "]}," Kernel public_method_with_new_repond_to_missing":{"type":"method","name":"public_method_with_new_repond_to_missing","children":[],"call":[" raise ","MissingMethod  new "," respond_to_missing? "," public_method_without_new_repond_to_missing "]}," Kernel method_with_new_repond_to_missing":{"type":"method","name":"method_with_new_repond_to_missing","children":[],"call":[" raise ","MissingMethod  new "," respond_to_missing? "," method_without_new_repond_to_missing "]}," Kernel respond_to_with_call_to_respond_to_missing?":{"type":"method","name":"respond_to_with_call_to_respond_to_missing?","children":[],"call":[" respond_to_missing? "," respond_to_without_call_to_respond_to_missing? "]}," Kernel respond_to_missing?":{"type":"method","name":"respond_to_missing?","children":[],"call":[]}," MissingUnboundMethod bind":{"type":"method","name":"bind","children":[],"call":["MissingMethod  new "," raise ","to is_a? "]}," MissingUnboundMethod source_location":{"type":"method","name":"source_location","children":[],"call":[]}," MissingUnboundMethod arity":{"type":"method","name":"arity","children":[],"call":[]}," MissingUnboundMethod new":{"type":"method","name":"new","children":[],"call":[]}," MissingMethod get_block":{"type":"method","name":"get_block","children":[],"call":[]}," MissingMethod new":{"type":"method","name":"new","children":[],"call":[]}," MissingMethod unbind":{"type":"method","name":"unbind","children":[],"call":["MissingUnboundMethod  new "," name "," owner "]}," MissingMethod to_proc":{"type":"method","name":"to_proc","children":[],"call":["@receiver send "," get_block "]}," MissingMethod source_location":{"type":"method","name":"source_location","children":[],"call":[]}," MissingMethod owner":{"type":"method","name":"owner","children":[],"call":["@receiver class "]}," MissingMethod arity":{"type":"method","name":"arity","children":[],"call":[]}," MissingMethod eql?":{"type":"method","name":"eql?","children":[],"call":[" name == ","method name "," name "," receiver == ","method receiver "," receiver ","method is_a? "]}," MissingMethod call":{"type":"method","name":"call","children":[],"call":[" receiver send "," receiver "]}," IO binread":{"type":"method","name":"binread","children":[],"call":["f read ","File  open ","Backports  convert_to_path "," raise ","1 + ","arg size ","arg size < "]}," Hash default_proc=":{"type":"method","name":"default_proc=","children":[],"call":[" replace ","Hash  new merge! ","Hash  new ","Backports  coerce_to ","Type  coerce_to "," default= ","proc == "]}," Hash try_convert":{"type":"method","name":"try_convert","children":[],"call":["x to_hash ","x respond_to? ","Backports  try_convert "]}," File size":{"type":"method","name":"size","children":[],"call":[" stat size "," stat "]}," Enumerator initialize_with_optional_block":{"type":"method","name":"initialize_with_optional_block","children":[],"call":[" initialize_without_optional_block ","Backports Yielder  new ","arg empty? ","Yielder  new ","arg first ","Generator  new ","GeneratorBP  new "]}," Enumerable chunk":{"type":"method","name":"chunk","children":[],"call":["yielder yield ","accumulate empty? ","accumulate << ","block yield "," each ","original_block yield ","initial_state clone ","Proc  new ","initial_state nil? ","Enumerator  new ","previous == ","previous nil? "," raise ","key to_s [] == ","key to_s [] ","key to_s ","key is_a? ","key nil? "," Enumerator  new "," block_given? ","block call ","original_block call ","block yield  to_s [] == ","block call  to_s [] == ","block yield  to_s [] ","block call  to_s [] ","block yield  to_s ","block call  to_s ","block yield  is_a? ","block call  is_a? ","block yield  nil? ","block call  nil? "]}," Enumerable each_with_object":{"type":"method","name":"each_with_object","children":[],"call":["block call "," each "," to_enum "," block_given? "]}," Array try_convert":{"type":"method","name":"try_convert","children":[],"call":["Backports  coerce_to ","obj respond_to? ","x to_ary ","x respond_to? ","Type  coerce_to ","Backports  coerce_to_ary ","Backports  try_convert "]}," String upto_with_exclusive":{"type":"method","name":"upto_with_exclusive","children":[],"call":["enum each "," block_given? ","Range  new to_enum ","Range  new "," upto_without_exclusive ","excl ! ","r each ","r to_enum ","Range  new to_enum  each ","Range  new to_Range  new to_enum  ","Range  new  each ","r to_Range  new to_enum  ","Range  new  to_enum "]}," String rpartition":{"type":"method","name":"rpartition","children":[],"call":[" [] "," length ","i + ","pattern length ","match post_match ","match [] ","match pre_match ","Regexp  last_match ","pattern is_a? "," rindex ","Backports  coerce_to ","Type  coerce_to "," rindex  + ","Backports  coerce_to  length ","Type  coerce_to  length ","Regexp  last_match  post_Regexp  last_match  ","Regexp  last_match  [] ","Regexp  last_match  pre_Regexp  last_match  ","Regexp  i + _match ","Regexp  last_Regexp  last_match  ","pattern  rindex s_a? ","Backports  coerce_to  is_a? ","Type  coerce_to  is_a? "," r rindex ndex "]}," String partition_with_new_meaning":{"type":"method","name":"partition_with_new_meaning","children":[],"call":[" [] "," length ","i + ","pattern length ","match post_match ","match [] ","match pre_match ","Regexp  last_match ","pattern is_a? "," index ","Backports  coerce_to "," partition_without_new_meaning ","pattern == ","args first ","args length == ","args length ","Type  coerce_to "," index  + ","Backports  coerce_to  length ","args first  length ","Type  coerce_to  length ","Regexp  last_match  post_Regexp  last_match  ","Regexp  last_match  [] ","Regexp  last_match  pre_Regexp  last_match  ","Regexp  i + _match ","Regexp  last_Regexp  last_match  ","pattern  index s_a? ","Backports  coerce_to  is_a? ","args first  is_a? ","Type  coerce_to  is_a? ","  index ndex "," part index t index on_w index thout_new_mean index ng ","Backports  coerce_to  == ","args first  == ","Type  coerce_to  == ","args f index rst "]}," String each_char":{"type":"method","name":"each_char","children":[],"call":[" scan "," to_enum "," block_given? "]}," String chr":{"type":"method","name":"chr","children":[],"call":[" chars first "," chars "]}," Regexp union_with_array_argument":{"type":"method","name":"union_with_array_argument","children":[],"call":[" union_without_array_argument ","arg first ","arg size == ","arg size "]}," Module module_exec":{"type":"method","name":"module_exec","children":[],"call":[" instance_exec "]}," Module instance_method_with_additional_info":{"type":"method","name":"instance_method_with_additional_info","children":[],"call":["unbound owner= ","mod instance_methods include? ","name to_s ","mod instance_methods "," ancestors find "," ancestors ","unbound name= ","name to_sym "," instance_method_without_additional_info tap "," instance_method_without_additional_info ","unbound name "," returning "," instance_method_without_additional_info  owner= "," instance_method_without_additional_info  name= "," instance_method_without_additional_info  name "]}," Kernel method_with_additional_info":{"type":"method","name":"method_with_additional_info","children":[],"call":["bound owner= ","mod instance_methods include? ","name to_s ","mod instance_methods "," class ancestors find "," class ancestors "," class ","bound receiver= ","bound name= ","name to_sym "," method_without_additional_info tap "," method_without_additional_info ","bound name "," method_without_additional_info  owner= "," method_without_additional_info  receiver= "," method_without_additional_info  name= "," method_without_additional_info  name "]}," UnboundMethod bind_with_additional_info":{"type":"method","name":"bind_with_additional_info","children":[],"call":["bound receiver= ","bound owner= "," owner ","bound name= "," name "," bind_without_additional_info tap "," bind_without_additional_info "," returning "," bind_without_additional_info  receiver= "," bind_without_additional_info  owner= "," bind_without_additional_info  name= "]}," Method unbind_with_additional_info":{"type":"method","name":"unbind_with_additional_info","children":[],"call":["unbound owner= "," owner ","unbound name= "," name "," unbind_without_additional_info tap "," unbind_without_additional_info "," returning "," unbind_without_additional_info  owner= "," unbind_without_additional_info  name= "]}," Kernel tap":{"type":"method","name":"tap","children":[],"call":[]}," Kernel loop_with_stop_iteration":{"type":"method","name":"loop_with_stop_iteration","children":[],"call":[" loop_without_stop_iteration "]}," Kernel instance_exec":{"type":"method","name":"instance_exec","children":[],"call":[" send "," define_singleton_method ","(self) send "]}," Kernel define_singleton_method":{"type":"method","name":"define_singleton_method","children":[],"call":["(self) send "]}," Kernel __method__":{"type":"method","name":"__method__","children":[],"call":["m to_sym "," caller first [] "," caller first "," caller "," caller first []  to_sy caller first []  "]}," IO lines":{"type":"method","name":"lines","children":[],"call":[" to_enum "]}," IO each_char":{"type":"method","name":"each_char","children":[],"call":[" read ","c + ","6 - ","n [] zero? ","n [] ","lookup find ","c [] ","7 downto ","$KCODE == "," to_enum "," block_given? "," read  + ","c []  [] zero? ","c []  [] ","lookup fic [] d ","7 downto  find "," read  [] ","7 dowc [] to "," to_ec [] um "," block_givec [] ? "," blo read k_given? "]}," IO chars":{"type":"method","name":"chars","children":[],"call":[" to_enum "]}," IO bytes":{"type":"method","name":"bytes","children":[],"call":[" to_enum "]}," Integer pred":{"type":"method","name":"pred","children":[],"call":[" - "]}," Integer ord":{"type":"method","name":"ord","children":[],"call":[]}," Integer odd?":{"type":"method","name":"odd?","children":[],"call":[" even? ! "," even? "," [] zero? ! "," [] zero? "," [] "]}," Integer even?":{"type":"method","name":"even?","children":[],"call":[" [] zero? "," [] "]}," GC stress=":{"type":"method","name":"stress=","children":[],"call":[" raise "]}," GC stress":{"type":"method","name":"stress","children":[],"call":[]}," Fixnum fdiv":{"type":"method","name":"fdiv","children":[],"call":[" to_f / "," to_f "]}," Fixnum div":{"type":"method","name":"div","children":[],"call":["(send\n  (self) :/\n  (lvar :n)) to_i "," / ","(send\n  (self) :/\n  (lvar :n)) round "]}," Enumerable Enumerator rewind":{"type":"method","name":"rewind","children":[],"call":["@generator rewind ","Generator  new "," require ","@object rewind ","@object respond_to? "," Generator  new "]}," Enumerable Enumerator next":{"type":"method","name":"next","children":[],"call":["@generator next "," raise ","@generator next? ","Generator  new "," require "," Generator  new "]}," Enumerable entries_with_optional_arguments":{"type":"method","name":"entries_with_optional_arguments","children":[],"call":[" to_enum entries "," to_enum "," entries_without_optional_arguments ","args empty? "]}," Enumerable to_a_with_optional_arguments":{"type":"method","name":"to_a_with_optional_arguments","children":[],"call":[" to_enum to_a "," to_enum "," to_a_without_optional_arguments ","args empty? "]}," Enumerable reverse_each":{"type":"method","name":"reverse_each","children":[],"call":[" to_a reverse_each "," to_a "," to_enum "," block_given? "]}," Enumerable one?":{"type":"method","name":"one?","children":[],"call":[" each "," block_given? ","1 == "," count "," one? "]}," Enumerable none?":{"type":"method","name":"none?","children":[],"call":[" any? ! "," any? "]}," Enumerable minmax_by":{"type":"method","name":"minmax_by","children":[],"call":["max_result < ","min_result > "," each "," to_enum "," block_given? "]}," Enumerable minmax":{"type":"method","name":"minmax","children":[],"call":["Backports  coerce_to_comparison < ","Backports  coerce_to_comparison ","Backports  coerce_to_comparison > "," each ","a <=> "," minmax "," block_given? ","(lvar :max) < ","(lvar :min) > ","Type  coerce_to_comparison < ","Type  coerce_to_comparison ","Type  coerce_to_comparison > "]}," Enumerable min_by":{"type":"method","name":"min_by","children":[],"call":[" minmax_by first "," minmax_by "," to_enum "," block_given? ","min_result > "," each "]}," Enumerable max_by":{"type":"method","name":"max_by","children":[],"call":[" minmax_by [] "," minmax_by "," to_enum "," block_given? ","max_result < "," each "]}," Enumerable >":{"type":"method","name":">","children":[],"call":[]}," Enumerable <":{"type":"method","name":"<","children":[],"call":[]}," Enumerable inject_with_symbol":{"type":"method","name":"inject_with_symbol","children":[],"call":["memo send "," inject_without_symbol ","args pop ","args size <= ","args size "," block_given? ","method to_sym "," raise ","method respond_to? ","args pop  to_sym ","method to_sym  to_sym ","args pop  respond_to? ","method to_sym  respond_to? "]}," Enumerable group_by":{"type":"method","name":"group_by","children":[],"call":["(send\n  (lvar :result) :fetch\n  (yield\n    (lvar :o))) << ","result []= ","result fetch "," each "," tap "," to_enum "," block_given? "," returning "]}," Enumerable each_with_index_with_optional_args_and_block":{"type":"method","name":"each_with_index_with_optional_args_and_block","children":[],"call":[" each "," to_enum "," block_given? "," to_enum each_with_index_without_optional_args_and_block "]}," Enumerable cycle":{"type":"method","name":"cycle","children":[],"call":["cache cycle ","n - ","block call ","cache << "," each ","n >= ","Backports  coerce_to "," loop "," == "," to_enum "," block_given? ","Backports  coerce_to_int "," to_a cycle "," to_a ","Type  coerce_to ","cache each ","(send\n  (lvar :n) :-\n  (int 1)) times ","n nil? ","cache empty? ","n == ","Backports  coerce_to  - ","Backports  coerce_to_int  - ","Type  coerce_to  - ","Backports  coerce_to  >= ","Backports  coerce_to_int  >= ","Type  coerce_to  >= "," to_eBackports  coerce_to um "," to_eBackports  coerce_to_int um "," to_eType  coerce_to um "," block_giveBackports  coerce_to ? "," block_giveBackports  coerce_to_int ? "," block_giveType  coerce_to ? ","Backports  coerce_to_iBackports  coerce_to t ","Backports  coerce_to_iBackports  coerce_to_int t ","Backports  coerce_to_iType  coerce_to t ","(seBackports  coerce_to d\n  (lvar :Backports  coerce_to ) :-\n  (iBackports  coerce_to t 1)) times ","(seBackports  coerce_to_int d\n  (lvar :Backports  coerce_to_int ) :-\n  (iBackports  coerce_to_int t 1)) times ","(seType  coerce_to d\n  (lvar :Type  coerce_to ) :-\n  (iType  coerce_to t 1)) times ","Backports  coerce_to  Backports  coerce_to il? ","Backports  coerce_to_int  Backports  coerce_to_int il? ","Type  coerce_to  Type  coerce_to il? ","Backports  coerce_to  == ","Backports  coerce_to_int  == ","Type  coerce_to  == "]}," Enumerable count":{"type":"method","name":"count","children":[],"call":[" each "," block_given? ","item == ","item != ","obj == ","arg first ","arg empty? ","arg first  == "]}," Dir mktmpdir":{"type":"method","name":"mktmpdir","children":[],"call":["FileUtils  remove_entry_secure "," block_given? ","Dir  mkdir ","path << "," rand to_s "," rand ","Time  now strftime ","Time  now ","Dir  tmpdir "," raise ","prefix_suffix inspect ","prefix_suffix [] "," respond_to? ","Kernel  rand to_s ","Kernel  rand ","Dir  method_defined? "," method_defined? ","FileUTime  now strftime ils  remove_enTime  now strftime ry_secure ","paTime  now strftime h << "," rand Time  now strftime o_s ","Time  now sTime  now strftime rfTime  now strftime ime ","Dir  Time  now strftime mpdir ","prefix_suffix inspecTime  now strftime  ","prefix_prefix_suffix []  inspect ","prefix_suffix [] _suffix inspect ","prefix_prefix_suffix []  [] ","prefix_suffix [] _suffix [] "," respond_Time  now strftime o? ","Kernel  rand Time  now strftime o_s ","Dir  meTime  now strftime hod_defined? "," meTime  now strftime hod_defined? "]}," Binding eval":{"type":"method","name":"eval","children":[],"call":["Kernel  eval "]}," Array shuffle!":{"type":"method","name":"shuffle!","children":[],"call":[" [] "," []= ","i + "," rand "," size - "," size "," size times ","Kernel  rand "," replace "," sample "," raise "," frozen? "," i + and ","Kei + nel  i + and "," i + eplace "," i + aise "," fi + ozen? "]}," Array shuffle":{"type":"method","name":"shuffle","children":[],"call":[" dup shuffle! "," dup "," sample "," size "]}," Array shift_with_optional_argument":{"type":"method","name":"shift_with_optional_argument","children":[],"call":[" slice! "," raise ","n < ","Backports  coerce_to "," shift_without_optional_argument ","n == ","Backports  coerce_to_int ","arg first to_i ","arg first ","arg empty? ","Type  coerce_to ","Backports  coerce_to  < ","Backports  coerce_to_int  < ","arg first to_i  < ","Type  coerce_to  < "," shift_without_optioBackports  coerce_to al_argumeBackports  coerce_to t "," shift_without_optioBackports  coerce_to_int al_argumeBackports  coerce_to_int t "," shift_without_optioarg first to_i al_argumearg first to_i t "," shift_without_optioType  coerce_to al_argumeType  coerce_to t ","Backports  coerce_to  == ","Backports  coerce_to_int  == ","arg first to_i  == ","Type  coerce_to  == ","Backports  coerce_to_iBackports  coerce_to t ","Backports  coerce_to_iBackports  coerce_to_int t ","Backports  coerce_to_iarg first to_i t ","Backports  coerce_to_iType  coerce_to t "]}," Array sample":{"type":"method","name":"sample","children":[],"call":["result []= "," size ","result [] ","i + "," rand "," size - ","n times ","Array  new ","n > "," raise ","n < ","Backports  coerce_to "," [] ","n == ","Kernel  rand ","Backports  coerce_to_int "," values_at ","index first ","index [] ","index []= ","(send\n  (send\n    (lvar :arg) :first) :to_i) min ","arg first to_i ","arg first ","arg empty? ","Type  coerce_to ","generator call ","Kernel  method ","r >= ","r < ","rng rand ","Proc  new ","rng respond_to? ","Backports  coerce_to_option ","options == ","n respond_to? ","i + esult []= ","Backports  coerce_to_int esult []= ","Array  new  []= ","i + esult [] ","Backports  coerce_to_int esult [] ","Array  new  [] "," i + and "," Backports  coerce_to_int and "," ra size d "," raBackports  coerce_to d "," raBackports  coerce_to_int d "," ra(send\n  (send\n    (lvar :arg) :first) :to_i) min d "," raType  coerce_to d "," size  times ","Backports  coerce_to  times ","Backports  coerce_to_int  times ","(send\n  (send\n    (lvar :arg) :first) :to_i) min  times ","Type  coerce_to  times ","Ai + i + ay  new ","ABackports  coerce_to_int Backports  coerce_to_int ay  new ","Array   size ew ","Array  Backports  coerce_to ew ","Array  Backports  coerce_to_int ew ","Array  (send\n  (send\n    (lvar :arg) :first) :to_i) min ew ","Array  Type  coerce_to ew "," size  > ","Backports  coerce_to  > ","Backports  coerce_to_int  > ","(send\n  (send\n    (lvar :arg) :first) :to_i) min  > ","Type  coerce_to  > "," i + aise "," Backports  coerce_to_int aise "," size  < ","Backports  coerce_to  < ","Backports  coerce_to_int  < ","(send\n  (send\n    (lvar :arg) :first) :to_i) min  < ","Type  coerce_to  < ","Backpoi + ts  coei + ce_to ","BackpoBackports  coerce_to_int ts  coeBackports  coerce_to_int ce_to "," size  == ","Backports  coerce_to  == ","Backports  coerce_to_int  == ","(send\n  (send\n    (lvar :arg) :first) :to_i) min  == ","Type  coerce_to  == ","Kei + nel  i + and ","KeBackports  coerce_to_int nel  Backports  coerce_to_int and ","Ker size el  ra size d ","KerBackports  coerce_to el  raBackports  coerce_to d ","KerBackports  coerce_to_int el  raBackports  coerce_to_int d ","Ker(send\n  (send\n    (lvar :arg) :first) :to_i) min el  ra(send\n  (send\n    (lvar :arg) :first) :to_i) min d ","KerType  coerce_to el  raType  coerce_to d ","Backpoi + ts  coei + ce_to_int ","BackpoBackports  coerce_to_int ts  coeBackports  coerce_to_int ce_to_int ","Backports  coerce_to_i size t ","Backports  coerce_to_iBackports  coerce_to t ","Backports  coerce_to_iBackports  coerce_to_int t ","Backports  coerce_to_i(send\n  (send\n    (lvar :arg) :first) :to_i) min t ","Backports  coerce_to_iType  coerce_to t ","index fii + st ","index fiBackports  coerce_to_int st ","i size dex first ","iBackports  coerce_to dex first ","iBackports  coerce_to_int dex first ","i(send\n  (send\n    (lvar :arg) :first) :to_i) min dex first ","iType  coerce_to dex first ","Array  new  first ","i size dex [] ","iBackports  coerce_to dex [] ","iBackports  coerce_to_int dex [] ","i(send\n  (send\n    (lvar :arg) :first) :to_i) min dex [] ","iType  coerce_to dex [] ","i size dex []= ","iBackports  coerce_to dex []= ","iBackports  coerce_to_int dex []= ","i(send\n  (send\n    (lvar :arg) :first) :to_i) min dex []= ","iType  coerce_to dex []= ","(send\n  (send\n    (lvai +  :ai + g) :fii + st) :to_i) min ","(send\n  (send\n    (lvaBackports  coerce_to_int  :aBackports  coerce_to_int g) :fiBackports  coerce_to_int st) :to_i) min ","(se size d\n  (se size d\n    (lvar :arg) :first) :to_i) mi size  ","(seBackports  coerce_to d\n  (seBackports  coerce_to d\n    (lvar :arg) :first) :to_i) miBackports  coerce_to  ","(seBackports  coerce_to_int d\n  (seBackports  coerce_to_int d\n    (lvar :arg) :first) :to_i) miBackports  coerce_to_int  ","(se(send\n  (send\n    (lvar :arg) :first) :to_i) min d\n  (se(send\n  (send\n    (lvar :arg) :first) :to_i) min d\n    (lvar :arg) :first) :to_i) mi(send\n  (send\n    (lvar :arg) :first) :to_i) min  ","(seType  coerce_to d\n  (seType  coerce_to d\n    (lvar :arg) :first) :to_i) miType  coerce_to  ","ai + g fii + st to_i ","aBackports  coerce_to_int g fiBackports  coerce_to_int st to_i ","ai + g fii + st ","aBackports  coerce_to_int g fiBackports  coerce_to_int st ","ai + g empty? ","aBackports  coerce_to_int g empty? ","Type  coei + ce_to ","Type  coeBackports  coerce_to_int ce_to ","genei + atoi +  call ","geneBackports  coerce_to_int atoBackports  coerce_to_int  call ","ge size erator call ","geBackports  coerce_to erator call ","geBackports  coerce_to_int erator call ","ge(send\n  (send\n    (lvar :arg) :first) :to_i) min erator call ","geType  coerce_to erator call ","Kernel  method  call ","Kei + nel  method ","KeBackports  coerce_to_int nel  method ","Ker size el  method ","KerBackports  coerce_to el  method ","KerBackports  coerce_to_int el  method ","Ker(send\n  (send\n    (lvar :arg) :first) :to_i) min el  method ","KerType  coerce_to el  method ","i +  >= ","Backports  coerce_to_int  >= ","i +  < ","i + ng i + and ","Backports  coerce_to_int ng Backports  coerce_to_int and ","r size g ra size d ","rBackports  coerce_to g raBackports  coerce_to d ","rBackports  coerce_to_int g raBackports  coerce_to_int d ","r(send\n  (send\n    (lvar :arg) :first) :to_i) min g ra(send\n  (send\n    (lvar :arg) :first) :to_i) min d ","rType  coerce_to g raType  coerce_to d ","Backports  coerce_to_option  rand ","Pi + oc  new ","PBackports  coerce_to_int oc  new ","Proc   size ew ","Proc  Backports  coerce_to ew ","Proc  Backports  coerce_to_int ew ","Proc  (send\n  (send\n    (lvar :arg) :first) :to_i) min ew ","Proc  Type  coerce_to ew ","i + ng i + espond_to? ","Backports  coerce_to_int ng Backports  coerce_to_int espond_to? ","r size g respo size d_to? ","rBackports  coerce_to g respoBackports  coerce_to d_to? ","rBackports  coerce_to_int g respoBackports  coerce_to_int d_to? ","r(send\n  (send\n    (lvar :arg) :first) :to_i) min g respo(send\n  (send\n    (lvar :arg) :first) :to_i) min d_to? ","rType  coerce_to g respoType  coerce_to d_to? ","Backports  coerce_to_option  respond_to? ","Backpoi + ts  coei + ce_to_option ","BackpoBackports  coerce_to_int ts  coeBackports  coerce_to_int ce_to_option ","Backports  coerce_to_optio size  ","Backports  coerce_to_optioBackports  coerce_to  ","Backports  coerce_to_optioBackports  coerce_to_int  ","Backports  coerce_to_optio(send\n  (send\n    (lvar :arg) :first) :to_i) min  ","Backports  coerce_to_optioType  coerce_to  ","optio size s == ","optioBackports  coerce_to s == ","optioBackports  coerce_to_int s == ","optio(send\n  (send\n    (lvar :arg) :first) :to_i) min s == ","optioType  coerce_to s == ","n i + espond_to? ","n Backports  coerce_to_int espond_to? "," size  respo size d_to? ","Backports  coerce_to  respoBackports  coerce_to d_to? ","Backports  coerce_to_int  respoBackports  coerce_to_int d_to? ","(send\n  (send\n    (lvar :arg) :first) :to_i) min  respo(send\n  (send\n    (lvar :arg) :first) :to_i) min d_to? ","Type  coerce_to  respoType  coerce_to d_to? "]}," Array rindex_with_block":{"type":"method","name":"rindex_with_block","children":[],"call":[" size - - "," size - "," size "," reverse_each each_with_index "," reverse_each "," rindex_without_block ","arg empty? "," block_given? "," to_enum "," block_given? ! "]}," Array product":{"type":"method","name":"product","children":[],"call":["(send\n  (block\n    (send\n      (array\n        (self)\n        (splat\n          (lvar :arg))) :map)\n    (args\n      (arg :x))\n    (send\n      (const nil :Backports) :coerce_to\n      (lvar :x)\n      (const nil :Array)\n      (sym :to_ary))) :inject\n  (lvar :trivial_enum)) to_a ","Enumerator  new ","yielder yield ","partial_product + ","array each ","enum each ","Backports Yielder  new ","(send\n  (array\n    (self)\n    (splat\n      (lvar :arg))) :map) inject ","Backports  coerce_to ","(self) map ","outer_lambda call ","proc call ","partial dup << ","partial dup ","values each "," lambda ","arg inject ","result method ","arg push ","arg reverse! ","Type  coerce_to ","arg map! ","Backports  method ","Backports  coerce_to_ary ","arg _partial_cartesian_product ","Array  new ","arg size ","arg size - ","arg unshift ","(send\n  (lvar :arrays) :inject\n  (lvar :first_enum)) to_a ","(lvar :obj) + ","arrays inject ","(self) reverse ","(send\n  (array\n    (self)\n    (splat\n      (lvar :arg))) :inject\n  (lvar :trivial_enum)) to_a ","(self) inject ","(send\n  (block\n    (send\n      (array\n        (self)\n        (splat\n          (lvar :arg))) :map)\n    (args\n      (arg :x))\n    (send\n      (const nil :Type) :coerce_to\n      (lvar :x)\n      (const nil :Array)\n      (sym :to_ary))) :inject\n  (lvar :trivial_enum)) to_a "," raise ","n > ","1 << ","n == ","p * ","a size "," size ","(send\n  (block\n    (send\n      (array\n        (self)\n        (splat\n          (lvar :arg))) :map)\n    (args\n      (arg :x))\n    (send\n      (const nil :Backports) :coerce_to\n      (lvar :x)\n      (const nil :Array)\n      (sym :to_ary))) :inject\n  (lvar :Enumerator  new )) to_a ","(send\n  (lvar :(self) reverse ) :inject\n  (lvar :first_enum)) to_a ","(self) reverse  inject ","(send\n  (array\n    (self)\n    (splat\n      (lvar :arg))) :inject\n  (lvar :Enumerator  new )) to_a ","(send\n  (block\n    (send\n      (array\n        (self)\n        (splat\n          (lvar :arg))) :map)\n    (args\n      (arg :x))\n    (send\n      (const nil :Type) :coerce_to\n      (lvar :x)\n      (const nil :Array)\n      (sym :to_ary))) :inject\n  (lvar :Enumerator  new )) to_a "]}," Array pop_with_optional_argument":{"type":"method","name":"pop_with_optional_argument","children":[],"call":[" slice! to_a "," slice! "," size ","first < "," size - "," raise ","n < ","Backports  coerce_to "," pop_without_optional_argument ","n == ","Backports  coerce_to_int ","(int 0) max ","arg first to_i ","arg first ","arg empty? ","Type  coerce_to "," size -  < ","Backports  coerce_to  < ","Backports  coerce_to_int  < ","arg first to_i  < ","Type  coerce_to  < "," pop_without_optioBackports  coerce_to al_argumeBackports  coerce_to t "," pop_without_optioBackports  coerce_to_int al_argumeBackports  coerce_to_int t "," pop_without_optioarg first to_i al_argumearg first to_i t "," pop_without_optioType  coerce_to al_argumeType  coerce_to t ","Backports  coerce_to  == ","Backports  coerce_to_int  == ","arg first to_i  == ","Type  coerce_to  == ","Backports  coerce_to_iBackports  coerce_to t ","Backports  coerce_to_iBackports  coerce_to_int t ","Backports  coerce_to_iarg first to_i t ","Backports  coerce_to_iType  coerce_to t ","(iBackports  coerce_to t 0) max ","(iBackports  coerce_to_int t 0) max ","(iarg first to_i t 0) max ","(iType  coerce_to t 0) max ","arg  size -  to_i ","arg  size -  "]}," Array cycle":{"type":"method","name":"cycle","children":[],"call":[" each ","n times ","Backports  coerce_to "," loop ","n nil? "," to_enum "," block_given? ","Backports  coerce_to_int ","nb to_i times ","nb to_i ","arg first ","1 / ","arg empty? ","Type  coerce_to ","Backports  coerce_to  times ","Backports  coerce_to_int  times ","Type  coerce_to  times ","Backports  coerce_to  Backports  coerce_to il? ","Backports  coerce_to_int  Backports  coerce_to_int il? ","Type  coerce_to  Type  coerce_to il? "," to_eBackports  coerce_to um "," to_eBackports  coerce_to_int um "," to_eType  coerce_to um "," block_giveBackports  coerce_to ? "," block_giveBackports  coerce_to_int ? "," block_giveType  coerce_to ? ","Backports  coerce_to_iBackports  coerce_to t ","Backports  coerce_to_iBackports  coerce_to_int t ","Backports  coerce_to_iType  coerce_to t ","Backports  coerce_to b to_i times ","Backports  coerce_to_int b to_i times ","Type  coerce_to b to_i times ","arg first  to_i times ","Backports  coerce_to b to_i ","Backports  coerce_to_int b to_i ","Type  coerce_to b to_i ","arg first  to_i "]}," Array combination":{"type":"method","name":"combination","children":[],"call":["picks []= ","(erange\n  (lvar :new_index)\n  (begin\n    (send\n      (send\n        (lvar :new_index) :+\n        (lvar :num)) :-\n      (lvar :move)))) to_a ","new_index + - ","new_index + ","picks [] + ","picks [] ","(send\n  (lvar :lookup) :each) first ","picks [] < ","lookup each "," values_at "," loop ","pick_max_pairs find ","Proc  new ","picks zip reverse ","picks zip ","(erange\n  (begin\n    (send\n      (send nil :size) :-\n      (lvar :num)))\n  (send nil :size)) to_a "," size "," size - ","(erange\n  (int 0)\n  (lvar :num)) to_a ","(irange\n  (int 0)\n  (send nil :size)) include? "," to_enum "," block_given? ","Backports  coerce_to ","Backports  coerce_to_int ","num to_i ","Type  coerce_to ","(send\n  (lvar :pick_max_pairs) :find\n  (lvar :leave)) first ","(erange\n  (int 0)\n  (lvar :num)) to_a  []= ","(erange\n  (lvar :picks [] + )\n  (begin\n    (send\n      (send\n        (lvar :picks [] + ) :+\n        (lvar :num)) :-\n      (lvar :move)))) to_a ","(erange\n  (lvar :new_index)\n  (begin\n    (send\n      (send\n        (lvar :new_index) :+\n        (lvar :num)) :-\n      (lvar :(send\n  (lvar :lookup) :each) first )))) to_a ","(erange\n  (lvar :new_index)\n  (begin\n    (send\n      (send\n        (lvar :new_index) :+\n        (lvar :num)) :-\n      (lvar :(send\n  (lvar :pick_max_pairs) :find\n  (lvar :leave)) first )))) to_a ","(erange\n  (lvar :new_index)\n  (begin\n    (send\n      (send\n        (lvar :new_index) :+\n        (lvar :Backports  coerce_to )) :-\n      (lvar :move)))) to_a ","(erange\n  (lvar :new_index)\n  (begin\n    (send\n      (send\n        (lvar :new_index) :+\n        (lvar :Backports  coerce_to_int )) :-\n      (lvar :move)))) to_a ","(erange\n  (lvar :new_index)\n  (begin\n    (send\n      (send\n        (lvar :new_index) :+\n        (lvar :num to_i )) :-\n      (lvar :move)))) to_a ","(erange\n  (lvar :new_index)\n  (begin\n    (send\n      (send\n        (lvar :new_index) :+\n        (lvar :Type  coerce_to )) :-\n      (lvar :move)))) to_a ","picks [] +  + - ","picks [] +  + ","(erange\n  (int 0)\n  (lvar :num)) to_a  [] + ","(erange\n  (int 0)\n  (lvar :num)) to_a  [] ","(send\n  (lvar :pick_max_pairs find ) :each) first ","(erange\n  (int 0)\n  (lvar :num)) to_a  [] < ","pick_max_pairs find  each ","picks zip reverse  find ","pick_(erange\n  (begin\n    (send\n      (send nil :size) :-\n      (lvar :num)))\n  (send nil :size)) to_a _pairs find ","(erange\n  (int 0)\n  (lvar :num)) to_a  zip reverse ","(erange\n  (int 0)\n  (lvar :num)) to_a  zip ","(erange\n  (begin\n    (send\n      (send nil :size) :-\n      (lvar :Backports  coerce_to )))\n  (send nil :size)) to_a ","(erange\n  (begin\n    (send\n      (send nil :size) :-\n      (lvar :Backports  coerce_to_int )))\n  (send nil :size)) to_a ","(erange\n  (begin\n    (send\n      (send nil :size) :-\n      (lvar :num to_i )))\n  (send nil :size)) to_a ","(erange\n  (begin\n    (send\n      (send nil :size) :-\n      (lvar :Type  coerce_to )))\n  (send nil :size)) to_a ","(erange\n  (int 0)\n  (lvar :Backports  coerce_to )) to_a ","(erange\n  (int 0)\n  (lvar :Backports  coerce_to_int )) to_a ","(erange\n  (int 0)\n  (lvar :num to_i )) to_a ","(erange\n  (int 0)\n  (lvar :Type  coerce_to )) to_a "," to_eBackports  coerce_to  "," to_eBackports  coerce_to_int  "," to_enum to_i  "," to_eType  coerce_to  ","Backports  coerce_to  to_i ","Backports  coerce_to_int  to_i ","num to_i  to_i ","Type  coerce_to  to_i ","(send\n  (lvar :picks zip reverse ) :find\n  (lvar :leave)) first ","(send\n  (lvar :pick_(erange\n  (begin\n    (send\n      (send nil :size) :-\n      (lvar :num)))\n  (send nil :size)) to_a _pairs) :find\n  (lvar :leave)) first "]}," lines":{"type":"method","name":"lines","children":[],"call":[" to_enum "]}," each_char":{"type":"method","name":"each_char","children":[],"call":[" read ","c + ","6 - ","n [] zero? ","n [] ","lookup find ","c [] ","7 downto ","$KCODE == "," to_enum "," block_given? "," read  + ","c []  [] zero? ","c []  [] ","lookup fic [] d ","7 downto  find "," read  [] ","7 dowc [] to "," to_ec [] um "," block_givec [] ? "," blo read k_given? "]}," chars":{"type":"method","name":"chars","children":[],"call":[" to_enum "]}," bytes":{"type":"method","name":"bytes","children":[],"call":[" to_enum "]}," Kernel public_send":{"type":"method","name":"public_send","children":[],"call":[" method_missing ","method to_sym ","foo generate_a_no_method_error_in_preparation_for_method_missing "," send "," protected_methods include? ! "," protected_methods include? ","method to_s "," protected_methods "," respond_to? "]}," Kernel public_method":{"type":"method","name":"public_method","children":[],"call":[" raise "," class "," method "," protected_methods include? ! "," protected_methods include? ","meth to_s "," protected_methods "," respond_to? "]}," Enumerable flat_map":{"type":"method","name":"flat_map","children":[],"call":[" map flatten "," map "," to_enum "," block_given? ","r push ","r concat ","result respond_to? "," each "]}," Backports require_relative_dir":{"type":"method","name":"require_relative_dir","children":[],"call":[]}," String ord":{"type":"method","name":"ord","children":[],"call":[" codepoints first "," codepoints "," raise "]}," Regexp try_convert":{"type":"method","name":"try_convert","children":[],"call":["Backports  coerce_to ","obj respond_to? ","obj is_a? ","Backports  try_convert "]}," IO try_convert":{"type":"method","name":"try_convert","children":[],"call":["Backports  coerce_to ","obj respond_to? ","Backports  try_convert "]}," Array permutation":{"type":"method","name":"permutation","children":[],"call":["outer_lambda call ","proc call ","partial dup << ","partial dup ","new_remain delete_at ","remain dup ","remain each_with_index "," lambda ","num times inject ","num times ","(irange\n  (int 0)\n  (send nil :size)) include? "," size ","Backports  coerce_to ","num equal? "," to_enum "," block_given? ","Backports  coerce_to_int "," dup ","(irange\n  (int 1)\n  (lvar :num)) inject ","remain dup  delete_at ","Backports  coerce_to  times inject "," size  times inject ","Backports  coerce_to_int  times inject ","Backports  coerce_to  times "," size  times ","Backports  coerce_to_int  times ","Backports  coerce_to  equal? "," size  equal? ","Backports  coerce_to_int  equal? "," to_eBackports  coerce_to  "," to_e size  "," to_eBackports  coerce_to_int  ","(irange\n  (int 1)\n  (lvar :Backports  coerce_to )) inject ","(irange\n  (int 1)\n  (lvar : size )) inject ","(irange\n  (int 1)\n  (lvar :Backports  coerce_to_int )) inject "]}," Hash eql?":{"type":"method","name":"eql?","children":[],"call":["(send\n  (lvar :other) :fetch\n  (lvar :key)) eql? ","other fetch "," all? "," size == ","other size "," size ","other is_a? ","value eql? "]}," Hash hash":{"type":"method","name":"hash","children":[],"call":["key hash ^ ","value hash ","key hash "," each "]}," Backports alias_method":{"type":"method","name":"alias_method","children":[],"call":[]}," Enumerable slice_before":{"type":"method","name":"slice_before","children":[],"call":["yielder yield ","accumulator << ","block yield "," each ","arg dup ","Enumerator  new ","arg === ","Proc  new "," raise ","arg equal? ","arg equal? ! "," block_given? ","(send\n  (lvar :arg) :equal?\n  (const\n    (const nil :Backports) :Undefined)) ! ","block call "]}," Enumerable join":{"type":"method","name":"join","children":[],"call":[" to_a join "," to_a "]}," Enumerable each_entry":{"type":"method","name":"each_entry","children":[],"call":["args [] ","args size == ","args size "," each "," to_enum "," block_given? "]}," Array sort_by!":{"type":"method","name":"sort_by!","children":[],"call":[" replace "," sort_by "," to_enum "," block_given? "," raise "," frozen? "]}," Array select!":{"type":"method","name":"select!","children":[],"call":["(lvar :elem) ! "," reject! "," to_enum "," block_given? "]}," Array rotate!":{"type":"method","name":"rotate!","children":[],"call":[" concat "," slice! "," size "," empty? "," shift ","Backports  coerce_to_int % ","Backports  coerce_to_int "," coBackports  coerce_to_int % cat ","Backports  coerce_to_iBackports  coerce_to_int % t % ","Backports  coerce_to_iBackports  coerce_to_int % t "]}," Array rotate":{"type":"method","name":"rotate","children":[],"call":[" dup rotate! "," dup ","Array  new rotate! ","Array  new "]}," Array keep_if":{"type":"method","name":"keep_if","children":[],"call":["(lvar :elem) ! "," delete_if "," to_enum "," block_given? "]}," Kernel singleton_class":{"type":"method","name":"singleton_class","children":[],"call":[]}," Backports coerce_to_ary":{"type":"method","name":"coerce_to_ary","children":[],"call":[]}," Backports coerce_to_int":{"type":"method","name":"coerce_to_int","children":[],"call":[]}," Random new_seed":{"type":"method","name":"new_seed","children":[],"call":[]}," Random Implementation _rand_range":{"type":"method","name":"_rand_range","children":[],"call":["from + ","@mt random_integer ","range <= ","to - ","limit exclude_end? ","(send\n  (lvar :limit) :begin) map ","Backports  method ","limit end ","limit begin ","r > ","@mt random_float * * ","@mt random_float * ","@mt random_float "," loop ","range < ","Backports  coerce_to ","limit end is_a? ","limit begin + ","Backports  coerce_to_int ","range respond_to? ","range is_a? ! ","range is_a? ","limit end - ","f@mt random_float * * om + ","Backports  coerce_to  + ","@mt @mt random_float * * andom_intege@mt random_float * *  ","to -  <= ","Backports  coerce_to  <= ","Backports  coerce_to_int  <= ","limit end -  <= ","@mt random_float * * ange <= ","limit end  - ","(send\n  (lva@mt random_float * *  :limit) :begin) map ","Backpo@mt random_float * * ts  method ","@mt random_float * *  > ","@mt @mt random_float * * andom_float * * ","@mt @mt random_float * * andom_float * ","@mt @mt random_float * * andom_float ","to -  < ","Backports  coerce_to  < ","Backports  coerce_to_int  < ","limit end -  < ","@mt random_float * * ange < ","Backpo@mt random_float * * ts  coe@mt random_float * * ce_to ","Backports  coerce_limit end  ","Backpo@mt random_float * * ts  coe@mt random_float * * ce_to_int ","Backports  coerce_limit end _int ","to -  respond_to? ","Backports  coerce_to  respond_to? ","Backports  coerce_to_int  respond_to? ","limit end -  respond_to? ","@mt random_float * * ange @mt random_float * * espond_to? ","range respond_limit end ? ","to -  is_a? ! ","Backports  coerce_to  is_a? ! ","Backports  coerce_to_int  is_a? ! ","limit end -  is_a? ! ","@mt random_float * * ange is_a? ! ","to -  is_a? ","Backports  coerce_to  is_a? ","Backports  coerce_to_int  is_a? ","limit end -  is_a? ","@mt random_float * * ange is_a? "]}," Random Implementation left":{"type":"method","name":"left","children":[],"call":["MT19937 STATE_SIZE  - ","@mt last_read ","@mt left "]}," Random Implementation state":{"type":"method","name":"state","children":[],"call":["@mt to_bignum ","@mt state_as_bignum "]}," Random Implementation ==":{"type":"method","name":"==","children":[],"call":[" state == ","other send "," state "," left == "," left "," seed == ","other seed "," seed ","other is_a? "]}," Random Implementation bytes":{"type":"method","name":"bytes","children":[],"call":["@mt random_bytes "," raise ","nb < ","Backports  coerce_to_int ","Backports  coerce_to_int  < "]}," Random Implementation rand":{"type":"method","name":"rand","children":[],"call":[" raise ","@mt random_integer ","limit <= ","Backports  coerce_to_int "," _rand_range ","limit * ","@mt random_float ","Backports  coerce_to_int  <= ","Backports  coerce_to_int  * "]}," Random Implementation srand":{"type":"method","name":"srand","children":[],"call":["MT19937  [] ","Random  new_seed ","new_seed nonzero? ","Backports  coerce_to_int ","Random  Backports  coerce_to_int  ","Backports  coerce_to_int  nonzero? "]}," Random Implementation initialize":{"type":"method","name":"initialize","children":[],"call":[" srand "]}," Random MT19937 mask_32_bits":{"type":"method","name":"mask_32_bits","children":[],"call":["n >> ","MASK_BY  each "]}," Random MT19937 []":{"type":"method","name":"[]","children":[],"call":[]}," Random MT19937 convert_seed":{"type":"method","name":"convert_seed","children":[],"call":[]}," Random MT19937 to_bignum":{"type":"method","name":"to_bignum","children":[],"call":["val << ","32 * "," state each_with_index "," state "]}," Random MT19937 random_bytes":{"type":"method","name":"random_bytes","children":[],"call":["random pack [] ","random pack ","L * "," random_32_bits ","nb_32_bits times map ","nb_32_bits times ","(send\n  (lvar :nb) :+\n  (int 3)) / ","nb + ","(send\n  (lvar :nb) :+\n  (int 3)) /  times map ","(send\n  (lvar :nb) :+\n  (int 3)) /  times "]}," Random MT19937 random_integer":{"type":"method","name":"random_integer","children":[],"call":[" random_32_bits ","nb_full_32 times "," random_32_bits & ","rand < "," mask_32_bits ","n > ","upto - ","  random_32_bits & om_32_bits "," raupto - dom_32_bits ","upto - b_full_32 times ","  random_32_bits & om_32_bits & "," raupto - dom_32_bits & "," random_32_bits &  < ","raupto - d < ","  mask_32_bits _32_bits ","upto -  > "]}," Random MT19937 random_float":{"type":"method","name":"random_float","children":[],"call":["(send\n  (send\n    (begin\n      (send\n        (send nil :random_32_bits) :>>\n        (int 5))) :*\n    (float 67108864.0)) :+\n  (begin\n    (send\n      (send nil :random_32_bits) :>>\n      (int 6)))) * ","(send\n  (send nil :random_32_bits) :>>\n  (int 5)) * + "," random_32_bits >> "," random_32_bits ","(send\n  (send nil :random_32_bits) :>>\n  (int 5)) * "]}," Random MT19937 random_32_bits":{"type":"method","name":"random_32_bits","children":[],"call":["y >> ","(send\n  (lvar :y) :<<\n  (int 15)) & ","y << ","(send\n  (lvar :y) :<<\n  (int 7)) & ","@state [] "," next_state ","@last_read >= ","@state []  >> ","(send\n  (lvar :@state [] ) :<<\n  (int 15)) & ","@state []  << ","(send\n  (lvar :@state [] ) :<<\n  (int 7)) & "]}," Random MT19937 seed=":{"type":"method","name":"seed=","children":[],"call":[" raise ","@state []= ","@state [] ","(op-asgn\n  (lvasgn :i) :+\n  (int 1)) >= ","(send\n  (send\n    (ivar :@state) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1566083941))) - & ","(send\n  (send\n    (ivar :@state) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1566083941))) - ","@state [] ^ ","(send\n  (send\n    (ivar :@state) :[]\n    (send\n      (lvar :i) :-\n      (int 1))) :^\n  (send\n    (send\n      (ivar :@state) :[]\n      (send\n        (lvar :i) :-\n        (int 1))) :>>\n    (int 30))) * ","@state [] >> ","i - ","(send\n  (const nil :STATE_SIZE) :-\n  (int 1)) times ","STATE_SIZE  - ","(op-asgn\n  (lvasgn :j) :+\n  (int 1)) >= ","seed size ","(send\n  (send\n    (ivar :@state) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + + & ","(send\n  (send\n    (ivar :@state) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + + ","seed [] ","(send\n  (send\n    (ivar :@state) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + ","(const nil :STATE_SIZE) max times ","(const nil :STATE_SIZE) max "," seed= ","(send\n  (send\n    (int 1812433253) :*\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30))))) :+\n  (lvar :i)) & ","1812433253 * + ","1812433253 * ","(irange\n  (int 1)\n  (const nil :LAST_STATE)) each ","seed & ","Array  new ","Array  new  []= ","Array  new  [] ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1566083941))) - & ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1566083941))) - ","Array  new  [] ^ ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (send\n      (lvar :i) :-\n      (int 1))) :^\n  (send\n    (send\n      (ivar :Array  new ) :[]\n      (send\n        (lvar :i) :-\n        (int 1))) :>>\n    (int 30))) * ","Array  new  [] >> ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + + & ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + + ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + ","(send\n  (send\n    (int 1812433253) :*\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30))))) :+\n  (lvar :i)) & "]}," Random MT19937 next_state":{"type":"method","name":"next_state","children":[],"call":["@state [] ","mix odd? ","@state []= ","@state [] ^ ","mix >> ","i + - ","i + ","@state [] & | ","@state [] & ","STATE_SIZE  times ","@state [] & |  odd? ","@state [] & |  >> "]}," Random MT19937 initialize":{"type":"method","name":"initialize","children":[],"call":[" seed= "]}," Hash select!":{"type":"method","name":"select!","children":[],"call":["(lvar :key) ! "," reject! "," to_enum "," block_given? "," raise "," frozen? "]}," Hash keep_if":{"type":"method","name":"keep_if","children":[],"call":["(lvar :key) ! "," delete_if "," to_enum "," block_given? "]}," home":{"type":"method","name":"home","children":[],"call":["File  expand_path "]}," Array uniq_with_block":{"type":"method","name":"uniq_with_block","children":[],"call":["h values ","h [] "," each "," uniq_without_block "," block_given? ","h []= ","h has_key? "]}," Array uniq_with_block!":{"type":"method","name":"uniq_with_block!","children":[],"call":[" replace ","u size == "," size ","u size "," uniq "," uniq_without_block! "," block_given? "," frozen? "," uniq  size == "," uniq  size ","  uniq niq ","  uniq niq_witho uniq t_block! "]}," Array product_with_block":{"type":"method","name":"product_with_block","children":[],"call":["outer_lambda call ","proc call ","partial dup << ","partial dup ","values each "," lambda ","arg inject ","arg push ","arg reverse! ","Backports  coerce_to_ary ","arg map! "," product_without_block "," block_given? "]}," Random Implementation inspect":{"type":"method","name":"inspect","children":[],"call":[" object_id "," class name "," class "]}," Random inspect":{"type":"method","name":"inspect","children":[],"call":[" object_id "," class name "," class "]}," Random Implementation marshal_load":{"type":"method","name":"marshal_load","children":[],"call":["@mt marshal_load ","MT19937  allocate ","ary pop ","MT19937  allocate  marshal_load "]}," Random Implementation marshal_dump":{"type":"method","name":"marshal_dump","children":[],"call":["@mt marshal_dump << ","@mt marshal_dump "]}," Random MT19937 marshal_load":{"type":"method","name":"marshal_load","children":[],"call":["@state []= ","b & ","STATE_SIZE  times ","Array  new ","MT19937 STATE_SIZE  - ","Array  new  []= "]}," Random MT19937 marshal_dump":{"type":"method","name":"marshal_dump","children":[],"call":[" left "," state_as_bignum "]}," Random MT19937 left":{"type":"method","name":"left","children":[],"call":["MT19937 STATE_SIZE  - "]}," Random MT19937 state_as_bignum":{"type":"method","name":"state_as_bignum","children":[],"call":["val << ","32 * ","@state each_with_index "]}," Array repeated_permutation":{"type":"method","name":"repeated_permutation","children":[],"call":[" values_at ","indices [] ","indices []= ","Array  new "," size - "," size ","indices find_index ","num == ","num <= ","Backports  coerce_to_int "," to_enum "," block_given? ","copy values_at ","indices fill ","x != ","indices index "," dup ","Array  new  [] ","Array  new  []= ","Array  new  find_index ","Backports  coerce_to_int  == ","Backports  coerce_to_int  <= "," to_eBackports  coerce_to_int  "," dup  values_at ","Array  new  fill ","Array  new  index "]}," Array repeated_combination":{"type":"method","name":"repeated_combination","children":[],"call":[" values_at ","indices []= ","Array  new ","indices [] - ","indices [] ","dec + ","indices find_index "," size ","num == ","num <= ","Backports  coerce_to_int "," to_enum "," block_given? ","copy values_at ","indices fill ","x != ","indices index "," dup ","Array  new  []= ","Array  new  [] - ","Array  new  [] ","indices find_index  + ","Array  new  find_index ","Backports  coerce_to_int  == ","Backports  coerce_to_int  <= "," to_eBackports  coerce_to_int  "," dup  values_at ","Array  new  fill ","Array  new  index "]}," Math log2":{"type":"method","name":"log2","children":[],"call":[" log "]}," Math log_with_optional_base":{"type":"method","name":"log_with_optional_base","children":[],"call":[" log_without_optional_base / "," log_without_optional_base "," raise ","base is_a? ","numeric is_a? ","base equal? "]}," Enumerable each_cons_with_optional_block":{"type":"method","name":"each_cons_with_optional_block","children":[],"call":[" each_cons_without_optional_block "," to_enum "," block_given? "," raise ","len <= "]}," Enumerable each_slice_with_optional_block":{"type":"method","name":"each_slice_with_optional_block","children":[],"call":[" each_slice_without_optional_block "," to_enum "," block_given? "," raise ","len <= "]}," Array reverse_each_with_optional_block":{"type":"method","name":"reverse_each_with_optional_block","children":[],"call":[" to_enum "," reverse_each_without_optional_block "," block_given? "]}," Fixnum succ":{"type":"method","name":"succ","children":[],"call":[" + "]}," Enumerable detect_with_optional_block":{"type":"method","name":"detect_with_optional_block","children":[],"call":[" detect_without_optional_block "," to_enum "," block_given? "]}," Array _partial_cartesian_product":{"type":"method","name":"_partial_cartesian_product","children":[],"call":["action call ","combi []= "," [] each "," [] ","Proc  new "," _sub "," block ","iterate_index - ","result << ","combi dup ","iterate_index zero? ","Proc  new  call "]}," String gsub_with_optional_block":{"type":"method","name":"gsub_with_optional_block","children":[],"call":[" gsub_without_optional_block "," to_enum ","arg size > ","arg size "," block_given? "]}," Module make_block_optional":{"type":"method","name":"make_block_optional","children":[],"call":[" module_eval "," alias_method_chain ","test_on send ","options fetch "," new ","options [] ","options empty? "," method_defined? ","methods each ","methods extract_options! ","(send\n  (send\n    (block\n      (send\n        (begin\n          (erange\n            (int 0)\n            (lvar :arity))) :map)\n      (args\n        (arg :i))\n      (dstr\n        (str \"arg_\")\n        (begin\n          (lvar :i)))) :+\n    (lvar :last_arg)) :+\n  (array\n    (str \"&block\"))) join ","(send\n  (begin\n    (erange\n      (int 0)\n      (lvar :arity))) :map) + + ","(send\n  (begin\n    (erange\n      (int 0)\n      (lvar :arity))) :map) + ","(erange\n  (int 0)\n  (lvar :arity)) map ","-1 - ","arity < "," instance_method arity "," instance_method ","methods extract_options!  fetch ","methods extract_options!  [] ","methods extract_options!  empty? ","methods extract_methods extract_options! ! ","(send\n  (send\n    (block\n      (send\n        (begin\n          (erange\n            (int 0)\n            (lvar :-1 - ))) :map)\n      (args\n        (arg :i))\n      (dstr\n        (str \"arg_\")\n        (begin\n          (lvar :i)))) :+\n    (lvar :last_arg)) :+\n  (array\n    (str \"&block\"))) join ","(send\n  (send\n    (block\n      (send\n        (begin\n          (erange\n            (int 0)\n            (lvar : instance_method arity ))) :map)\n      (args\n        (arg :i))\n      (dstr\n        (str \"arg_\")\n        (begin\n          (lvar :i)))) :+\n    (lvar :last_arg)) :+\n  (array\n    (str \"&block\"))) join ","(send\n  (begin\n    (erange\n      (int 0)\n      (lvar :-1 - ))) :map) + + ","(send\n  (begin\n    (erange\n      (int 0)\n      (lvar : instance_method arity ))) :map) + + ","(send\n  (begin\n    (erange\n      (int 0)\n      (lvar :-1 - ))) :map) + ","(send\n  (begin\n    (erange\n      (int 0)\n      (lvar : instance_method arity ))) :map) + ","(erange\n  (int 0)\n  (lvar :-1 - )) map ","(erange\n  (int 0)\n  (lvar : instance_method arity )) map ","-1 -  < "," instance_method arity  < "," instance_method -1 -  "," instance_method  instance_method arity  "]}," Object method_with_additional_info":{"type":"method","name":"method_with_additional_info","children":[],"call":["bound owner= ","mod instance_methods include? ","name to_s ","mod instance_methods "," class ancestors find "," class ancestors "," class ","bound receiver= ","bound name= ","name to_sym "," returning "," method_without_additional_info "," method_without_additional_info tap "]}," Kernel __callee__":{"type":"method","name":"__callee__","children":[],"call":[" caller first [] try "," caller first [] "," caller first "," caller "]}," Integer succ":{"type":"method","name":"succ","children":[],"call":[" + "]}," Enumerator Yielder yield":{"type":"method","name":"yield","children":[],"call":["@final_block yield ","@final_block call "]}," Enumerator Yielder each":{"type":"method","name":"each","children":[],"call":["@main_block call "]}," Enumerator Yielder initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Enumerator rewind":{"type":"method","name":"rewind","children":[],"call":["@generator rewind ","Generator  new "," require ","@object rewind ","@object respond_to? "," Generator  new "]}," Enumerator next":{"type":"method","name":"next","children":[],"call":["@generator next "," raise ","@generator next? ","Generator  new "," require "," Generator  new "]}," Process exec":{"type":"method","name":"exec","children":[],"call":[]}," Type coerce_to_comparison":{"type":"method","name":"coerce_to_comparison","children":[],"call":["a <=> "]}," Type coerce_to":{"type":"method","name":"coerce_to","children":[],"call":[" raise ","ret class ","ret kind_of? ","e message ","obj inspect ","obj __send__ ","obj kind_of? ","obj __send__  class ","obj __send__  kind_of? "]}," Backports track_lambda":{"type":"method","name":"track_lambda","children":[],"call":[]}," Proc curry":{"type":"method","name":"curry","children":[],"call":["block call "," send "," call ","args count >= ","args count "," lambda? "," raise ","argc != "," arity ","argc < "," arity < "," arity -@ - "," arity -@ ","args size >= ","args size "]}," Kernel proc_with_lambda_tracking":{"type":"method","name":"proc_with_lambda_tracking","children":[],"call":["Backports  track_lambda "," proc_without_lambda_tracking ","l send ","block send == ","block send ","Backports  track_ proc_without_lambda_tracking ambda "," proc_without_ proc_without_lambda_tracking ambda_tracking "," proc_without_lambda_tracking  send ","b proc_without_lambda_tracking ock send == ","b proc_without_lambda_tracking ock send "]}," Kernel lambda_with_lambda_tracking":{"type":"method","name":"lambda_with_lambda_tracking","children":[],"call":["Backports  track_lambda "," lambda_without_lambda_tracking ","l send ","block send == ","block send ","Backports  track_ lambda_without_lambda_tracking ambda ","  lambda_without_lambda_tracking ambda_without_ lambda_without_lambda_tracking ambda_tracking "," lambda_without_lambda_tracking  send ","b lambda_without_lambda_tracking ock send == ","b lambda_without_lambda_tracking ock send "]}," Method to_proc_with_lambda_tracking":{"type":"method","name":"to_proc_with_lambda_tracking","children":[],"call":["proc instance_variable_set "," to_proc_without_lambda_tracking ","proc send "," to_proc_without_lambda_tracking  instance_variable_set "," to_ to_proc_without_lambda_tracking _without_lambda_tracking "," to_proc_without_lambda_tracking  send "]}," Proc lambda?":{"type":"method","name":"lambda?","children":[],"call":["@is_lambda ! ! ","@is_lambda ! "," __is_lambda__ ! ! "," __is_lambda__ ! "," __is_lambda__ "]}," Enumerator Yielder <<":{"type":"method","name":"<<","children":[],"call":["@final_block yield ","@final_block call "]}," Kernel require_with_backports":{"type":"method","name":"require_with_backports","children":[],"call":[" require_without_backports ","paths each ","Backports StdLib LoadedFeatures  mark_as_loaded "," raise ","Backports StdLib  extended_lib fetch ","Backports StdLib  extended_lib ","Backports StdLib LoadedFeatures  new include? ","Backports StdLib LoadedFeatures  new ","Backports StdLib  extended_lib fetch  each "]}," Backports write":{"type":"method","name":"write","children":[],"call":[]}," Backports combine_mode_perm_and_option":{"type":"method","name":"combine_mode_perm_and_option","children":[],"call":[]}," Backports combine_mode_and_option":{"type":"method","name":"combine_mode_and_option","children":[],"call":[]}," Backports try_convert":{"type":"method","name":"try_convert","children":[],"call":[]}," Backports StdLib extend_relative":{"type":"method","name":"extend_relative","children":[],"call":["@extended_lib [] << ","@extended_lib [] "," require ","loaded include? ","File  expand_path ","(send\n  (send\n    (const nil :Dir) :entries\n    (lvar :dir)) :map) compact each ","(send\n  (send\n    (const nil :Dir) :entries\n    (lvar :dir)) :map) compact ","Regexp  last_match ","Dir  entries map ","Dir  entries ","File  dirname "," caller first split first "," caller first split "," caller first "," caller ","Backports StdLib LoadedFeatures  new ","Backports StdLib LoadedFeatures  new  include? ","File  expand_File  expand_path  ","(send\n  (send\n    (const nil :Dir) :entries\n    (lvar :File  expand_path )) :map) compact each ","(send\n  (send\n    (const nil :Dir) :entries\n    (lvar :File  expand_path )) :map) compact ","File  File  expand_path name "]}," Backports StdLib LoadedFeatures mark_as_loaded":{"type":"method","name":"mark_as_loaded","children":[],"call":[]}," Backports StdLib LoadedFeatures include?":{"type":"method","name":"include?","children":[],"call":["$LOADED_FEATURES include? ","File  basename ","$LOAD_PATH include? ","fullpath partition ","fullpaths any? ","@loaded [] ","$LOADED_FEATURES group_by ","@@our_loads [] ","@loaded []  any? "]}," Backports StdLib LoadedFeatures initialize":{"type":"method","name":"initialize","children":[],"call":["File  basename ","$LOADED_FEATURES group_by "]}," String length":{"type":"method","name":"length","children":[],"call":[" unpack length "," unpack "]}," Hash select_with_hash_return":{"type":"method","name":"select_with_hash_return","children":[],"call":["Hash  [] "," select_without_hash_return "," to_enum "," block_given? "]}," binwrite":{"type":"method","name":"binwrite","children":[],"call":["Backports  write "]}," write":{"type":"method","name":"write","children":[],"call":["Backports  write "]}," Set keep_if":{"type":"method","name":"keep_if","children":[],"call":["@hash delete "," to_a each "," to_a "," enum_for "," __method__ "," block_given? "]}," Set delete_if":{"type":"method","name":"delete_if","children":[],"call":["@hash delete "," to_a each "," to_a "," enum_for "," __method__ "," block_given? "]}," Vector inspect":{"type":"method","name":"inspect","children":[],"call":["Vector + ","@elements inspect "]}," Vector to_s":{"type":"method","name":"to_s","children":[],"call":["Vector[ + + ","Vector[ + ","@elements join "]}," Vector coerce":{"type":"method","name":"coerce","children":[],"call":[" raise ","other class "," class ","Matrix Scalar  new "]}," Vector elements_to_r":{"type":"method","name":"elements_to_r","children":[],"call":[" map "," warn "," caller [] "," caller "]}," Vector elements_to_i":{"type":"method","name":"elements_to_i","children":[],"call":[" map "," warn "," caller [] "," caller "]}," Vector elements_to_f":{"type":"method","name":"elements_to_f","children":[],"call":[" map "," warn "," caller [] "," caller "]}," Vector to_a":{"type":"method","name":"to_a","children":[],"call":["@elements dup "]}," Vector covector":{"type":"method","name":"covector","children":[],"call":["Matrix  row_vector "]}," Vector normalize":{"type":"method","name":"normalize","children":[],"call":[" / "," raise ","n == "," magnitude "," magnitude  == "," mag magnitude itude "]}," Vector map2":{"type":"method","name":"map2","children":[],"call":[" class elements "," class "," collect2 "," to_enum "," block_given? "]}," Vector magnitude":{"type":"method","name":"magnitude","children":[],"call":["Math  sqrt ","v + ","e * ","@elements inject "]}," Vector collect":{"type":"method","name":"collect","children":[],"call":[" class elements "," class ","@elements collect "," to_enum "," block_given? "]}," Vector inner_product":{"type":"method","name":"inner_product","children":[],"call":["v1 * "," each2 ","Vector  Raise "," size != ","v size "," size "]}," Vector /":{"type":"method","name":"/","children":[],"call":[" apply_through_coercion "," __method__ ","Vector  Raise ","x class "," class "," class elements ","e / ","@elements collect "]}," Vector -":{"type":"method","name":"-","children":[],"call":[" apply_through_coercion "," __method__ ","Matrix  column_vector - ","Matrix  column_vector "," class elements "," class ","v1 - "," collect2 ","Vector  Raise "," size != ","v size "," size "]}," Vector +":{"type":"method","name":"+","children":[],"call":[" apply_through_coercion "," __method__ ","Matrix  column_vector + ","Matrix  column_vector "," class elements "," class ","v1 + "," collect2 ","Vector  Raise "," size != ","v size "," size "]}," Vector *":{"type":"method","name":"*","children":[],"call":[" apply_through_coercion "," __method__ ","Vector  Raise ","x class "," class ","Matrix  column_vector * ","Matrix  column_vector "," class elements ","e * ","@elements collect "]}," Vector hash":{"type":"method","name":"hash","children":[],"call":["@elements hash "]}," Vector clone":{"type":"method","name":"clone","children":[],"call":[" class elements "," class "]}," Vector eql?":{"type":"method","name":"eql?","children":[],"call":["@elements eql? ","other elements ","Vector  === "]}," Vector ==":{"type":"method","name":"==","children":[],"call":["@elements == ","other elements ","Vector  === "]}," Vector collect2":{"type":"method","name":"collect2","children":[],"call":["v [] ","@elements [] ","Array  new "," size "," to_enum "," block_given? ","Vector  Raise "," size != ","v size "," raise ","v kind_of? "]}," Vector each2":{"type":"method","name":"each2","children":[],"call":["v [] ","@elements [] "," size times "," size "," to_enum "," block_given? ","Vector  Raise "," size != ","v size "," raise ","v kind_of? "]}," Vector each":{"type":"method","name":"each","children":[],"call":["@elements each "," to_enum "," block_given? "]}," Vector size":{"type":"method","name":"size","children":[],"call":["@elements size "]}," Vector []=":{"type":"method","name":"[]=","children":[],"call":["@elements []= "]}," Vector []":{"type":"method","name":"[]","children":[],"call":["@elements [] "]}," Vector initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Vector elements":{"type":"method","name":"elements","children":[],"call":[]}," Matrix Scalar **":{"type":"method","name":"**","children":[],"call":[" apply_through_coercion "," __method__ ","Scalar  Raise ","other class ","@value class ","Scalar  new ","@value ** "]}," Matrix Scalar /":{"type":"method","name":"/","children":[],"call":[" apply_through_coercion "," __method__ "," * ","other inverse ","Scalar  Raise ","other class ","@value class ","Scalar  new ","@value / "]}," Matrix Scalar *":{"type":"method","name":"*","children":[],"call":[" apply_through_coercion "," __method__ ","@value * ","other collect ","Scalar  new "]}," Matrix Scalar -":{"type":"method","name":"-","children":[],"call":[" apply_through_coercion "," __method__ ","Scalar  Raise ","other class ","@value class ","Scalar  new ","@value - "]}," Matrix Scalar +":{"type":"method","name":"+","children":[],"call":[" apply_through_coercion "," __method__ ","Scalar  Raise ","other class ","@value class ","Scalar  new ","@value + "]}," Matrix Scalar initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Matrix CoercionHelper coerce_to_int":{"type":"method","name":"coerce_to_int","children":[],"call":[]}," Matrix CoercionHelper coerce_to":{"type":"method","name":"coerce_to","children":[],"call":[]}," Matrix CoercionHelper apply_through_coercion":{"type":"method","name":"apply_through_coercion","children":[],"call":[" raise "," class ","obj inspect ","coercion [] public_send ","coercion [] ","coercion length == ","coercion length ","coercion is_a? ","obj coerce ","obj coerce  [] public_send ","obj coerce  [] ","obj coerce  length == ","obj coerce  length ","obj coerce  is_a? "]}," Matrix ConversionHelper convert_to_array":{"type":"method","name":"convert_to_array","children":[],"call":[" raise ","obj class ","converted is_a? ","e message ","obj to_ary ","obj to_a ","obj dup ","obj to_ary  is_a? "]}," Matrix inspect":{"type":"method","name":"inspect","children":[],"call":["@rows inspect "," class "," column_size "," row_size "," empty? "]}," Matrix to_s":{"type":"method","name":"to_s","children":[],"call":["(begin\n  (send\n    (self) :class)) + + ","(begin\n  (send\n    (self) :class)) + ","(send\n  (ivar :@rows) :collect) join ","[ + + ","[ + ","(send\n  (lvar :row) :collect) join ","e to_s ","row collect ","@rows collect "," class "," column_size "," row_size "," empty? "]}," Matrix elements_to_r":{"type":"method","name":"elements_to_r","children":[],"call":[" map "," warn "," caller [] "," caller "]}," Matrix elements_to_i":{"type":"method","name":"elements_to_i","children":[],"call":[" map "," warn "," caller [] "," caller "]}," Matrix elements_to_f":{"type":"method","name":"elements_to_f","children":[],"call":[" map "," warn "," caller [] "," caller "]}," Matrix to_a":{"type":"method","name":"to_a","children":[],"call":["@rows collect "]}," Matrix column_vectors":{"type":"method","name":"column_vectors","children":[],"call":[" column ","Array  new "," column_size "]}," Matrix row_vectors":{"type":"method","name":"row_vectors","children":[],"call":[" row ","Array  new "," row_size "]}," Matrix coerce":{"type":"method","name":"coerce","children":[],"call":[" raise ","other class "," class ","Scalar  new "]}," Matrix rect":{"type":"method","name":"rect","children":[],"call":[" imag "," real "]}," Matrix real":{"type":"method","name":"real","children":[],"call":[" collect "]}," Matrix imaginary":{"type":"method","name":"imaginary","children":[],"call":[" collect "]}," Matrix conjugate":{"type":"method","name":"conjugate","children":[],"call":[" collect "]}," Matrix lup":{"type":"method","name":"lup","children":[],"call":["LUPDecomposition  new "]}," Matrix eigensystem":{"type":"method","name":"eigensystem","children":[],"call":["EigenvalueDecomposition  new "]}," Matrix transpose":{"type":"method","name":"transpose","children":[],"call":[" new_matrix "," row_size ","@rows transpose "," class empty "," column_size "," class "," row_size zero? "]}," Matrix trace":{"type":"method","name":"trace","children":[],"call":["tr + ","@rows [] [] ","@rows [] ","(erange\n  (int 0)\n  (send nil :column_size)) inject "," column_size ","Matrix  Raise "," square? "]}," Matrix round":{"type":"method","name":"round","children":[],"call":["e round "," map "]}," Matrix rank_e":{"type":"method","name":"rank_e","children":[],"call":[" rank "," warn "," caller [] "," caller "]}," Matrix rank":{"type":"method","name":"rank","children":[],"call":["ai []= ","(send\n  (send\n    (lvar :pivot) :*\n    (send\n      (lvar :ai) :[]\n      (lvar :j))) :-\n  (send\n    (send\n      (lvar :ai) :[]\n      (lvar :k)) :*\n    (send\n      (send\n        (lvar :a) :[]\n        (lvar :pivot_row)) :[]\n      (lvar :j)))) / ","pivot * - ","ai [] * ","a [] [] ","a [] ","ai [] ","pivot * ","(send\n  (lvar :k) :+\n  (int 1)) upto ","k + ","(send\n  (lvar :pivot_row) :+\n  (int 1)) upto ","pivot_row + ","a []= ","pivot_row == ","a [] [] != ","(irange\n  (lvar :pivot_row)\n  (lvar :last_row)) find ","0 upto "," row_size - "," row_size "," column_size - "," column_size "," to_a ","a []  []= "," to_a i []= ","(send\n  (send\n    (lvar :pivot) :*\n    (send\n      (lvar :a [] ) :[]\n      (lvar :j))) :-\n  (send\n    (send\n      (lvar :a [] ) :[]\n      (lvar :k)) :*\n    (send\n      (send\n        (lvar :a) :[]\n        (lvar :pivot_row)) :[]\n      (lvar :j)))) / ","(send\n  (send\n    (lvar :a [] [] ) :*\n    (send\n      (lvar :ai) :[]\n      (lvar :j))) :-\n  (send\n    (send\n      (lvar :ai) :[]\n      (lvar :k)) :*\n    (send\n      (send\n        (lvar :a) :[]\n        (lvar :a [] [] _row)) :[]\n      (lvar :j)))) / ","(send\n  (send\n    (lv to_a r :pivot) :*\n    (send\n      (lv to_a r : to_a i) :[]\n      (lv to_a r :j))) :-\n  (send\n    (send\n      (lv to_a r : to_a i) :[]\n      (lv to_a r :k)) :*\n    (send\n      (send\n        (lv to_a r : to_a ) :[]\n        (lv to_a r :pivot_row)) :[]\n      (lv to_a r :j)))) / ","a [] []  * - ","a []  [] * "," to_a i [] * "," to_a  [] [] "," to_a  [] ","a []  [] "," to_a i [] ","a [] []  * ","(send\n  (lv to_a r :k) :+\n  (int 1)) upto ","(send\n  (lvar :a [] [] _row) :+\n  (int 1)) upto ","(send\n  (lv to_a r :pivot_row) :+\n  (int 1)) upto ","a [] [] _row + "," to_a  []= ","a [] [] _row == "," to_a  [] [] != ","(irange\n  (lvar :a [] [] _row)\n  (lvar :last_row)) find ","(irange\n  (lvar :pivot_row)\n  (lvar : row_size - )) find ","(ir to_a nge\n  (lv to_a r :pivot_row)\n  (lv to_a r :l to_a st_row)) find "," to_ to_a  "]}," Matrix determinant_e":{"type":"method","name":"determinant_e","children":[],"call":[" rank "," warn "," caller [] "," caller "]}," Matrix determinant_bareiss":{"type":"method","name":"determinant_bareiss","children":[],"call":["sign * ","ai []= ","(send\n  (send\n    (lvar :pivot) :*\n    (send\n      (lvar :ai) :[]\n      (lvar :j))) :-\n  (send\n    (send\n      (lvar :ai) :[]\n      (lvar :k)) :*\n    (send\n      (send\n        (lvar :a) :[]\n        (lvar :k)) :[]\n      (lvar :j)))) / ","pivot * - ","ai [] * ","a [] [] ","a [] ","ai [] ","pivot * ","(send\n  (lvar :k) :+\n  (int 1)) upto ","k + ","sign -@ ","a []= ","a [] [] != ","(erange\n  (send\n    (lvar :k) :+\n    (int 1))\n  (lvar :size)) find ","(lvasgn :pivot\n  (send\n    (send\n      (lvar :a) :[]\n      (lvar :k)) :[]\n    (lvar :k))) == ","size times ","Proc  new "," to_a ","size - "," row_size ","sign -@  * ","a []  []= "," to_a i []= ","(send\n  (send\n    (lvar :pivot) :*\n    (send\n      (lvar :a [] ) :[]\n      (lvar :j))) :-\n  (send\n    (send\n      (lvar :a [] ) :[]\n      (lvar :k)) :*\n    (send\n      (send\n        (lvar :a) :[]\n        (lvar :k)) :[]\n      (lvar :j)))) / ","(send\n  (send\n    (lvar :a [] [] ) :*\n    (send\n      (lvar :ai) :[]\n      (lvar :j))) :-\n  (send\n    (send\n      (lvar :ai) :[]\n      (lvar :k)) :*\n    (send\n      (send\n        (lvar :a) :[]\n        (lvar :k)) :[]\n      (lvar :j)))) / ","(send\n  (send\n    (lv to_a r :pivot) :*\n    (send\n      (lv to_a r : to_a i) :[]\n      (lv to_a r :j))) :-\n  (send\n    (send\n      (lv to_a r : to_a i) :[]\n      (lv to_a r :k)) :*\n    (send\n      (send\n        (lv to_a r : to_a ) :[]\n        (lv to_a r :k)) :[]\n      (lv to_a r :j)))) / ","a [] []  * - ","a []  [] * "," to_a i [] * "," to_a  [] [] "," to_a  [] ","a []  [] "," to_a i [] ","a [] []  * ","(send\n  (lv to_a r :k) :+\n  (int 1)) upto ","sign -@  -@ "," to_a  []= "," to_a  [] [] != ","(er to_a nge\n  (send\n    (lv to_a r :k) :+\n    (int 1))\n  (lv to_a r :size)) find ","(erange\n  (send\n    (lvar :k) :+\n    (int 1))\n  (lvar : row_size )) find ","(lvasgn :a [] [] \n  (send\n    (send\n      (lvar :a) :[]\n      (lvar :k)) :[]\n    (lvar :k))) == ","(lv to_a sgn :pivot\n  (send\n    (send\n      (lv to_a r : to_a ) :[]\n      (lv to_a r :k)) :[]\n    (lv to_a r :k))) == "," row_size  times "," to_ to_a  "," row_size  - "," row_ row_size  "]}," Matrix determinant":{"type":"method","name":"determinant","children":[],"call":[" determinant_bareiss ","m0 [] +@ * * * - - + + - - + + - - + + - - + + - - + + - - + ","m0 [] * * * ","m3 [] ","m0 [] * * ","m2 [] ","m0 [] * ","m1 [] ","m0 [] ","m0 [] +@ * * * - - + + - - + + - - + + - - + + - - + + - - ","m0 [] +@ * * * - - + + - - + + - - + + - - + + - - + + - ","m0 [] +@ * * * - - + + - - + + - - + + - - + + - - + + ","m0 [] +@ * * * - - + + - - + + - - + + - - + + - - + ","m0 [] +@ * * * - - + + - - + + - - + + - - + + - - ","m0 [] +@ * * * - - + + - - + + - - + + - - + + - ","m0 [] +@ * * * - - + + - - + + - - + + - - + + ","m0 [] +@ * * * - - + + - - + + - - + + - - + ","m0 [] +@ * * * - - + + - - + + - - + + - - ","m0 [] +@ * * * - - + + - - + + - - + + - ","m0 [] +@ * * * - - + + - - + + - - + + ","m0 [] +@ * * * - - + + - - + + - - + ","m0 [] +@ * * * - - + + - - + + - - ","m0 [] +@ * * * - - + + - - + + - ","m0 [] +@ * * * - - + + - - + + ","m0 [] +@ * * * - - + + - - + ","m0 [] +@ * * * - - + + - - ","m0 [] +@ * * * - - + + - ","m0 [] +@ * * * - - + + ","m0 [] +@ * * * - - + ","m0 [] +@ * * * - - ","m0 [] +@ * * * - ","m0 [] +@ * * * ","m0 [] +@ * * ","m0 [] +@ * ","m0 [] +@ ","m0 [] +@ * * - - + + - ","m0 [] +@ * * - - + + ","m0 [] +@ * * - - + ","m0 [] +@ * * - - ","m0 [] +@ * * - ","m [] [] +@ * - ","m [] [] * ","m [] [] ","m [] ","m [] [] +@ * ","m [] [] +@ "," row_size ","Matrix  Raise "," square? "]}," Matrix **":{"type":"method","name":"**","children":[],"call":["Matrix  Raise ","other class "," class ","v * * ","v * "," class diagonal ","e ** ","d each map ","d each "," eigensystem ","(op-asgn\n  (lvasgn :other) :>>\n  (int 1)) zero? ","z * ","other [] == ","other [] "," loop ","other -@ "," class identity "," column_size ","other == "," inverse ","other <= ","Matri inverse   Raise ","other -@  class ","(op-asgn\n  (lvasgn :other) :>>\n  (int 1)) z * ero? ","(op-asgn\n  (lvasgn :other -@ ) :>>\n  (int 1)) zero? ","z *  * ","other -@  [] == ","other -@  [] ","other -@  -@ "," column_siz * e ","other -@  == ","other -@  <= "]}," Matrix inverse_from":{"type":"method","name":"inverse_from","children":[],"call":["@rows [] []= ","@rows [] [] quo ","@rows [] [] ","@rows [] ","0 upto ","a [] []= ","a [] [] quo ","a [] [] ","a [] ","(send\n  (lvar :k) :+\n  (int 1)) upto ","k + ","@rows [] [] * ","a [] [] * ","ii == ","@rows []= ","a []= ","i != ","Matrix  Raise ","akk == ","v > ","a [] [] abs ","src to_a "," row_size - "," row_size ","@rows [] [] a [] [] quo uo ","src to_a  [] []= ","a [] [] a [] [] quo uo ","src to_a  [] [] quo ","src to_a  [] [] ","src to_a  [] ","(send\n  (la [] [] abs ar :k) :+\n  (int 1)) upto ","(send\n  (lvsrc to_a r :k) :+\n  (int 1)) upto ","src to_a  [] [] * ","src to_a  []= ","Msrc to_a trix  Rsrc to_a ise ","a [] []  == ","a [] [] abs  == ","src to_a kk == ","a [] [] abs  > ","src to_a  [] [] src to_a bs ","src to_src to_a  "]}," Matrix inverse":{"type":"method","name":"inverse","children":[],"call":[" class I send "," class I "," row_size "," class ","Matrix  Raise "," square? "]}," Matrix /":{"type":"method","name":"/","children":[],"call":[" apply_through_coercion "," __method__ "," * ","other inverse "," new_matrix "," column_size ","e / ","row collect ","@rows collect "]}," Matrix -":{"type":"method","name":"-","children":[],"call":[" new_matrix "," column_size "," [] - ","m [] "," [] ","Array  new "," row_size ","Matrix  Raise "," column_size == ","m column_size "," row_size == ","m row_size "," apply_through_coercion "," __method__ "," class column_vector "," class ","m class "," new_ class column_vector atrix "," colu class column_vector n_size "," class column_vector  [] "," colu class column_vector n_size == "," class column_vector  colu class column_vector n_size "," class column_vector  row_size "," __ class column_vector ethod__ "," class colu class column_vector n_vector "," class column_vector  class "]}," Matrix +":{"type":"method","name":"+","children":[],"call":[" new_matrix "," column_size "," [] + ","m [] "," [] ","Array  new "," row_size ","Matrix  Raise "," column_size == ","m column_size "," row_size == ","m row_size "," apply_through_coercion "," __method__ "," class column_vector "," class ","m class "," new_ class column_vector atrix "," colu class column_vector n_size "," class column_vector  [] "," colu class column_vector n_size == "," class column_vector  colu class column_vector n_size "," class column_vector  row_size "," __ class column_vector ethod__ "," class colu class column_vector n_vector "," class column_vector  class "]}," Matrix *":{"type":"method","name":"*","children":[],"call":[" apply_through_coercion "," __method__ "," new_matrix ","m column_size ","vij + "," [] * ","m [] "," [] ","(erange\n  (int 0)\n  (send nil :column_size)) inject "," column_size ","Array  new "," row_size ","Matrix  Raise "," column_size != ","m row_size ","r column "," * "," class column_vector "," class ","e * ","row collect ","@rows collect "," apply_th * ough_coe * cion "," __ class column_vector ethod__ "," new_mat * ix "," new_ class column_vector atrix "," class column_vector  colu class column_vector n_size "," class column_vector  [] ","(e * ange\n  (int 0)\n  (send nil :column_size)) inject ","(erange\n  (int 0)\n  (send nil :colu class column_vector n_size)) inject "," colu class column_vector n_size ","A *  * ay  new ","  * ow_size ","Mat * ix  Raise "," colu class column_vector n_size != ","m  * ow_size "," class column_vector  row_size "," *  column ","r colu class column_vector n "," class column_vecto *  "," class colu class column_vector n_vector "," * ow collect ","@ * ows collect "]}," Matrix hash":{"type":"method","name":"hash","children":[],"call":["@rows hash "]}," Matrix clone":{"type":"method","name":"clone","children":[],"call":[" new_matrix "," column_size ","@rows map "]}," Matrix eql?":{"type":"method","name":"eql?","children":[],"call":[" rows eql? ","other rows "," rows "," column_size == ","other column_size "," column_size ","Matrix  === "]}," Matrix ==":{"type":"method","name":"==","children":[],"call":[" rows == ","other rows "," rows "," column_size == ","other column_size "," column_size ","Matrix  === "]}," Matrix zero?":{"type":"method","name":"zero?","children":[],"call":[" all? "]}," Matrix upper_triangular?":{"type":"method","name":"upper_triangular?","children":[],"call":[" each all? "," each "]}," Matrix unitary?":{"type":"method","name":"unitary?","children":[],"call":["s == ","i == ","row [] conj * "," rows [] [] "," rows [] "," rows ","row [] conj ","row [] "," row_size times "," row_size "," column_size times "," column_size "," rows each_with_index ","Matrix  Raise "," square? "]}," Matrix symmetric?":{"type":"method","name":"symmetric?","children":[],"call":["e != "," rows [] [] "," rows [] "," rows "," each_with_index ","Matrix  Raise "," square? "]}," Matrix square?":{"type":"method","name":"square?","children":[],"call":[" column_size == "," row_size "," column_size "]}," Matrix singular?":{"type":"method","name":"singular?","children":[],"call":[" determinant == "," determinant "]}," Matrix regular?":{"type":"method","name":"regular?","children":[],"call":[" singular? ! "," singular? "]}," Matrix real?":{"type":"method","name":"real?","children":[],"call":[" all? "]}," Matrix permutation?":{"type":"method","name":"permutation?","children":[],"call":["e != ","cols []= ","cols [] ","e == ","row each_with_index "," rows each_with_index "," rows ","Array  new "," column_size ","Matrix  Raise "," square? ","Array  new  []= ","Array  new  [] "]}," Matrix orthogonal?":{"type":"method","name":"orthogonal?","children":[],"call":["s == ","i == ","row [] * "," rows [] [] "," rows [] "," rows ","row [] "," row_size times "," row_size "," column_size times "," column_size "," rows each_with_index ","Matrix  Raise "," square? "]}," Matrix normal?":{"type":"method","name":"normal?","children":[],"call":["s == ","row_i [] * - ","row_k [] conj * ","row_k [] ","row_k [] conj ","row_i [] * ","row_j [] conj ","row_j [] ","row_i [] "," rows each_with_index "," rows ","Matrix  Raise "," square? "]}," Matrix lower_triangular?":{"type":"method","name":"lower_triangular?","children":[],"call":[" each all? "," each "]}," Matrix hermitian?":{"type":"method","name":"hermitian?","children":[],"call":["e == "," rows [] [] conj "," rows [] [] "," rows [] "," rows "," each_with_index all? "," each_with_index ","Matrix  Raise "," square? "]}," Matrix empty?":{"type":"method","name":"empty?","children":[],"call":[" row_size == "," row_size "," column_size == "," column_size "]}," Matrix diagonal?":{"type":"method","name":"diagonal?","children":[],"call":[" each all? "," each ","Matrix  Raise "," square? "]}," Matrix minor":{"type":"method","name":"minor","children":[],"call":[" new_matrix ","(send\n  (send nil :column_size) :-\n  (lvar :from_col)) min "," column_size - "," column_size ","row [] ","@rows [] collect ","@rows [] ","from_col < ","from_row < ","from_col > ","from_row > "," row_size ","Matrix  Raise ","param inspect ","size_col < ","size_row < ","to_col - ","col_range exclude_end? ","to_col < ","col_range end ","col_range first ","to_row - ","row_range exclude_end? ","to_row < ","row_range end ","row_range first ","param size ","(send\n  (send nil :column_size) :-\n  (lvar :col_range first )) min ","col_range first  < ","row_range first  < ","col_range first  > ","row_range first  > ","to_col -  < ","to_row -  < ","col_range end  - ","col_range end  < ","row_range end  - ","row_range end  < "]}," Matrix index":{"type":"method","name":"index","children":[],"call":[" each_with_index ","e == ","args first ","args size == ","args size "," to_enum "," block_given? ","args pop ","SELECTORS  include? ","args last "," raise ","args size > "]}," Matrix each_with_index":{"type":"method","name":"each_with_index","children":[],"call":["Matrix  Raise ","which inspect ","row [] ","row_index upto ","@rows each_with_index ","(send\n  (lvar :row_index) :+\n  (int 1)) upto ","row_index + ","(lvar :row_index) min times ","(lvar :row_index) min "," column_size ","0 upto ","row_index == "," column_size times ","row fetch ","row each_with_index "," column_size - "," to_enum "," block_given? "]}," Matrix each":{"type":"method","name":"each","children":[],"call":["Matrix  Raise ","which inspect ","row [] ","row_index upto ","@rows each_with_index ","(send\n  (lvar :row_index) :+\n  (int 1)) upto ","row_index + ","(lvar :row_index) min times ","(lvar :row_index) min "," column_size ","0 upto ","row_index == "," column_size times ","row fetch ","row each ","@rows each ","Proc  new "," column_size - "," to_enum "," block_given? "," Proc  new _given? "]}," Matrix collect":{"type":"method","name":"collect","children":[],"call":[" new_matrix "," column_size ","row collect ","@rows collect "," to_enum "," block_given? "]}," Matrix column":{"type":"method","name":"column","children":[],"call":["Vector  elements ","@rows [] [] ","@rows [] ","Array  new "," row_size ","j < "," column_size -@ "," column_size ","j >= "," row_size times "," block_given? "]}," Matrix row":{"type":"method","name":"row","children":[],"call":["Vector  elements ","@rows fetch ","(send\n  (ivar :@rows) :fetch\n  (lvar :i)) each "," block_given? "]}," Matrix row_size":{"type":"method","name":"row_size","children":[],"call":["@rows size "]}," Matrix []=":{"type":"method","name":"[]=","children":[],"call":["@rows [] []= ","@rows [] "]}," Matrix []":{"type":"method","name":"[]","children":[],"call":["(send\n  (ivar :@rows) :fetch\n  (lvar :i)) [] ","@rows fetch "]}," Matrix new_matrix":{"type":"method","name":"new_matrix","children":[],"call":[" class send "," class "]}," Matrix initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Matrix empty":{"type":"method","name":"empty","children":[],"call":[]}," Matrix column_vector":{"type":"method","name":"column_vector","children":[],"call":[]}," Matrix row_vector":{"type":"method","name":"row_vector","children":[],"call":[]}," Matrix zero":{"type":"method","name":"zero","children":[],"call":[]}," Matrix identity":{"type":"method","name":"identity","children":[],"call":[]}," Matrix scalar":{"type":"method","name":"scalar","children":[],"call":[]}," Matrix diagonal":{"type":"method","name":"diagonal","children":[],"call":[]}," Matrix build":{"type":"method","name":"build","children":[],"call":[]}," Matrix columns":{"type":"method","name":"columns","children":[],"call":[]}," Matrix rows":{"type":"method","name":"rows","children":[],"call":[]}," Matrix LUPDecomposition initialize":{"type":"method","name":"initialize","children":[],"call":["@lu [] []= ","@lu [] [] quo ","@lu [] [] ","@lu [] ","(send\n  (lvar :j) :+\n  (int 1)) upto ","@row_size - ","j + ","@lu [] [] != ","j < ","@pivot_sign -@ ","@pivots []= ","@pivots [] ","@col_size times ","p != ","lu_col_j [] abs > ","lu_col_j [] abs ","lu_col_j [] ","lu_row_i []= ","lu_row_i [] * ","lu_row_i [] ","kmax times ","(lvar :i) min ","@row_size times ","lu_col_j []= ","Array  new ","a column_size ","a row_size ","a to_a "," raise ","a class ","a is_a? ","a to_a  [] []= ","a to_a  [] [] quo ","a to_a  [] [] ","a to_a  [] ","(send\n  (lvar :j) :+\n  (in@lu [] []  1)) up@lu [] [] o ","a row_size  - ","a to_a  [] [] != ","@pivot_sign -@  -@ ","@pivo@lu [] [] _sign -@ ","@pivo@lu [] [] s []= ","Array  new  []= ","@pivo@lu [] [] s [] ","Array  new  [] ","@col_size @lu [] [] imes ","a column_size  times ","Array  new  [] abs > ","Array  new  [] abs ","@lu []  []= ","@lu []  [] * ","@lu []  [] ","@pivots [] max times ","kmax @lu [] [] imes ","(lvar :i) min  times ","@row_size @lu [] [] imes ","a row_size  times ","a @lu [] [] o_a "]}," Matrix LUPDecomposition solve":{"type":"method","name":"solve","children":[],"call":["Vector  elements ","m [] * ","@lu [] [] ","@lu [] ","m [] ","k times ","m []= ","m [] quo ","(send\n  (ivar :@col_size) :-\n  (int 1)) downto ","@col_size - ","(send\n  (lvar :k) :+\n  (int 1)) upto ","k + ","@col_size times ","b values_at ","Matrix  Raise ","b size != ","b size "," convert_to_array ","Matrix  send ","m [] [] * ","m [] [] ","nx times ","m [] []= ","m [] [] quo ","b row to_a ","b row ","@pivots map ","b column_size ","b row_size != ","b row_size ","b is_a? "," singular? ","Vector  eleb values_at ents ","b values_at  [] * ","b values_at  [] ","k tib values_at es ","b values_at  []= ","b values_at  [] quo ","@col_size tib values_at es "," convert_to_array  values_at "," convert_to_array  size != "," convert_to_array  size ","b values_at  [] [] * ","b values_at  [] [] ","nx tib values_at es ","b column_size  times ","b values_at  [] []= ","b values_at  [] [] quo "," convert_to_array  row to_a "," convert_to_array  row ","@pivots b values_at ap ","b colub values_at n_size "," convert_to_array  column_size "," convert_to_array  row_size != "," convert_to_array  row_size "," convert_to_array  is_a? "]}," Matrix LUPDecomposition det":{"type":"method","name":"det","children":[],"call":["@lu [] [] ","@lu [] ","@col_size times ","Matrix  Raise "," square? ","@row_size != "]}," Matrix LUPDecomposition singular?":{"type":"method","name":"singular?","children":[],"call":["@lu [] [] == ","@lu [] [] ","@lu [] ","@col_size times "]}," Matrix LUPDecomposition to_ary":{"type":"method","name":"to_ary","children":[],"call":[" p "," u "," l "]}," Matrix LUPDecomposition p":{"type":"method","name":"p","children":[],"call":["Matrix  send ","rows [] []= ","rows [] ","@pivots each_with_index ","Array  new "]}," Matrix LUPDecomposition u":{"type":"method","name":"u","children":[],"call":["@lu [] [] ","@lu [] ","i <= ","Matrix  build "]}," Matrix LUPDecomposition l":{"type":"method","name":"l","children":[],"call":["i == ","@lu [] [] ","@lu [] ","i > ","Matrix  build "]}," Matrix EigenvalueDecomposition hessenberg_to_real_schur":{"type":"method","name":"hessenberg_to_real_schur","children":[],"call":["@v [] []= ","@v [] ","@v [] [] * ","@h [] [] ","@h [] ","@v [] [] ","low upto ","(lvar :j) min ","(send\n  (lvar :nn) :-\n  (int 1)) downto ","nn - ","i upto ","i > ","i < ","nn times ","@h [] []= ","@h [] [] / ","n - ","(send\n  (lvar :eps) :*\n  (lvar :t)) * > ","(send\n  (lvar :eps) :*\n  (lvar :t)) * ","eps * ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max ","@h [] [] abs ","i + "," cdiv ","s -@ - ","y * ","s -@ ","r -@ - ","r -@ ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (int 1))))) / ","sa -@ - - ","q * ","sa -@ - ","w * ","sa -@ ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (int 1))))) :+\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","ra -@ - + ","ra -@ - ","ra -@ ","x abs > ","z abs + ","q abs ","z abs ","x abs ","x * - - ","x * - ","z * ","x * ","x * - + ","eps * * ","w abs + + + + ","w abs + + + ","y abs ","w abs + + ","w abs + ","w abs ","vi == ","vr == ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * ","@d [] - ","@d [] ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + - ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ","@e [] * ","@e [] ","@e [] == ","@e [] < ","@h [] [] - ","sa + ","@h [] [] * ","ra + ","l upto ","(send\n  (lvar :n) :-\n  (int 2)) downto ","@h [] [] -@ ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ ","q / ","@h [] [] abs > ","q < ","(send\n  (send\n    (lvar :s) :-@) :-\n  (send\n    (lvar :y) :*\n    (lvar :t))) / ","(send\n  (send\n    (lvar :r) :-@) :-\n  (send\n    (lvar :w) :*\n    (lvar :t))) / ","(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / ","r -@ / ","w != ","(send\n  (lvar :n) :-\n  (int 1)) downto ","q == ","norm == ","@v [] [] - ","p * ","k + ","x * + ","0 upto ","(lvar :n) min ","r * ","@h [] [] + ","k upto ","r / ","p / ","k - ","l != ","s -@ * ","k != ","s != ","p < ","Math  sqrt ","p * + + ","p * + ","x == ","x != ","p abs + + ","r abs ","p abs + ","p abs ","m upto ","i - ","m + ","(send\n  (lvar :m) :+\n  (int 2)) upto ","@h [] [] abs * < ","p abs * ","@h [] [] abs + + ","@h [] [] abs + ","m - ","@h [] [] abs * ","q abs + ","m == ","@h [] [] - - - ","@h [] [] - - ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / ","r * - ","y - ","x - ","m >= ","iter + ","w / ","(send\n  (lvar :y) :-\n  (lvar :x)) / + ","(send\n  (lvar :y) :-\n  (lvar :x)) / ","y < ","s > ","s + ","iter == ","-0.4375 * * ","-0.4375 * ","0.75 * ","l < ","@e []= ","z -@ ","@d []= ","x + ","q * - ","q * + ","(send\n  (lvar :n) :-\n  (int 1)) upto ","z / ","x / ","x abs + ","z != ","p - ","p + ","p >= ","q >= ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","l == ","@h [] [] abs < ","l - ","s == ","l > ","n >= ","norm + ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(send\n  (lvar :i) :-\n  (int 1)) max ","low up(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","low up@h [] [] abs o ","low up(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","lo@h [] [] -  upto ","lo-0.4375 * *  upto ","lo@h [] [] *  upto ","n - ow upto ","low u@d [] to ","low ux * + to ","low u@h [] [] + to ","low u@h [] [] to ","low u(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + to ","low ux / to ","low u(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / to ","(n - var :j) min ","(lva@h [] []  :j) min ","(lvax -  :j) min ","(lvaMath  sqrt  :j) min ","(lvar :j) n - in ","(lvar :j) minn -  ","(send\n  (lvar :nn) :-\n  (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  1)) down(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","(send\n  (lvar :nn) :-\n  (in@h [] [] abs  1)) down@h [] [] abs o ","(send\n  (lvar :nn) :-\n  (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  1)) down(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","(send\n  (lvar :nn) :-\n  (int 1)) do@h [] [] - nto ","(send\n  (lvar :nn) :-\n  (int 1)) do-0.4375 * * nto ","(send\n  (lvar :nn) :-\n  (int 1)) do@h [] [] * nto ","(send\n  (n - var :nn) :-\n  (int 1)) downto ","(s -@ end\n  (lvar :nn) :-\n  (int 1)) downto ","(Math  sqrt end\n  (lvar :nn) :-\n  (int 1)) downto ","(p abs + + end\n  (lvar :nn) :-\n  (int 1)) downto ","(y - end\n  (lvar :nn) :-\n  (int 1)) downto ","(x - end\n  (lvar :nn) :-\n  (int 1)) downto ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  (lvar :nn) :-\n  (int 1)) downto ","(@h [] [] abs + end\n  (lvar :nn) :-\n  (int 1)) downto ","(x abs + end\n  (lvar :nn) :-\n  (int 1)) downto ","(send\n  (lva@h [] []  :nn) :-\n  (int 1)) downto ","(send\n  (lvax -  :nn) :-\n  (int 1)) downto ","(send\n  (lvaMath  sqrt  :nn) :-\n  (int 1)) downto ","(senn - d\n  (lvar :nn - nn - ) :-\n  (inn - t 1)) downn - to ","nn - nn -  - ","i up(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","i up@h [] [] abs o ","i up(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","i u@d [] to ","i ux * + to ","i u@h [] [] + to ","i u@h [] [] to ","i u(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + to ","i ux / to ","i u(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / to ","nn (send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max imes ","nn @h [] [] abs imes ","nn (send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / imes ","nn times -@  ","nn timeMath  sqrt  ","nn timep abs + +  ","nn timey -  ","nn timex -  ","nn time(send\n  (lvar :y) :-\n  (lvar :x)) /  ","nn time@h [] [] abs +  ","nn timex abs +  ","nn tin - es ","nn - nn -  times ","nn -  - ","(send\n  (lvar :eps) :*\n  (lvar :(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max )) * > ","(send\n  (lvar :eps) :*\n  (lvar :@h [] [] abs )) * > ","(send\n  (lvar :eps) :*\n  (lvar :(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / )) * > ","(send\n  (n - var :eps) :*\n  (n - var :t)) * > ","(send\n  (lvar :e@d [] s) :*\n  (lvar :t)) * > ","(send\n  (lvar :ex * + s) :*\n  (lvar :t)) * > ","(send\n  (lvar :e@h [] [] + s) :*\n  (lvar :t)) * > ","(send\n  (lvar :e@h [] [] s) :*\n  (lvar :t)) * > ","(send\n  (lvar :e(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + s) :*\n  (lvar :t)) * > ","(send\n  (lvar :ex / s) :*\n  (lvar :t)) * > ","(send\n  (lvar :e(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / s) :*\n  (lvar :t)) * > ","(s -@ end\n  (lvar :eps -@ ) :*\n  (lvar :t)) * > ","(Math  sqrt end\n  (lvar :epMath  sqrt ) :*\n  (lvar :t)) * > ","(p abs + + end\n  (lvar :epp abs + + ) :*\n  (lvar :t)) * > ","(y - end\n  (lvar :epy - ) :*\n  (lvar :t)) * > ","(x - end\n  (lvar :epx - ) :*\n  (lvar :t)) * > ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  (lvar :ep(send\n  (lvar :y) :-\n  (lvar :x)) / ) :*\n  (lvar :t)) * > ","(@h [] [] abs + end\n  (lvar :ep@h [] [] abs + ) :*\n  (lvar :t)) * > ","(x abs + end\n  (lvar :epx abs + ) :*\n  (lvar :t)) * > ","(send\n  (lva@h [] []  :eps) :*\n  (lva@h [] []  :t)) * > ","(send\n  (lvax -  :eps) :*\n  (lvax -  :t)) * > ","(send\n  (lvaMath  sqrt  :eps) :*\n  (lvaMath  sqrt  :t)) * > ","(senn - d\n  (lvar :eps) :*\n  (lvar :t)) * > ","(send\n  (lvar :eps) :*\n  (lvar :(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max )) * ","(send\n  (lvar :eps) :*\n  (lvar :@h [] [] abs )) * ","(send\n  (lvar :eps) :*\n  (lvar :(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / )) * ","(send\n  (n - var :eps) :*\n  (n - var :t)) * ","(send\n  (lvar :e@d [] s) :*\n  (lvar :t)) * ","(send\n  (lvar :ex * + s) :*\n  (lvar :t)) * ","(send\n  (lvar :e@h [] [] + s) :*\n  (lvar :t)) * ","(send\n  (lvar :e@h [] [] s) :*\n  (lvar :t)) * ","(send\n  (lvar :e(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + s) :*\n  (lvar :t)) * ","(send\n  (lvar :ex / s) :*\n  (lvar :t)) * ","(send\n  (lvar :e(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / s) :*\n  (lvar :t)) * ","(s -@ end\n  (lvar :eps -@ ) :*\n  (lvar :t)) * ","(Math  sqrt end\n  (lvar :epMath  sqrt ) :*\n  (lvar :t)) * ","(p abs + + end\n  (lvar :epp abs + + ) :*\n  (lvar :t)) * ","(y - end\n  (lvar :epy - ) :*\n  (lvar :t)) * ","(x - end\n  (lvar :epx - ) :*\n  (lvar :t)) * ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  (lvar :ep(send\n  (lvar :y) :-\n  (lvar :x)) / ) :*\n  (lvar :t)) * ","(@h [] [] abs + end\n  (lvar :ep@h [] [] abs + ) :*\n  (lvar :t)) * ","(x abs + end\n  (lvar :epx abs + ) :*\n  (lvar :t)) * ","(send\n  (lva@h [] []  :eps) :*\n  (lva@h [] []  :t)) * ","(send\n  (lvax -  :eps) :*\n  (lvax -  :t)) * ","(send\n  (lvaMath  sqrt  :eps) :*\n  (lvaMath  sqrt  :t)) * ","(senn - d\n  (lvar :eps) :*\n  (lvar :t)) * ","e@d [] s * ","ex * + s * ","e@h [] [] + s * ","e@h [] [] s * ","e(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + s * ","ex / s * ","e(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / s * ","eps -@  * ","epMath  sqrt  * ","epp abs + +  * ","epy -  * ","epx -  * ","ep(send\n  (lvar :y) :-\n  (lvar :x)) /  * ","ep@h [] [] abs +  * ","epx abs +  * ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  1))) :abs) max ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (in@h [] [] abs  1))) :abs) max ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  1))) :abs) max ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) ma@h [] []  ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) map /  ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) map abs + +  ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (n - var :i)) :[]\n    (send\n      (n - var :n) :-\n      (int 1))) :abs) max ","(s -@ end\n  (s -@ end\n    (s -@ end\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (s -@ end\n      (lvar :n) :-\n      (int 1))) :abs -@ ) max ","(Math  sqrt end\n  (Math  sqrt end\n    (Math  sqrt end\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (Math  sqrt end\n      (lvar :n) :-\n      (int 1))) :abMath  sqrt ) max ","(p abs + + end\n  (p abs + + end\n    (p abs + + end\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (p abs + + end\n      (lvar :n) :-\n      (int 1))) :abp abs + + ) max ","(y - end\n  (y - end\n    (y - end\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (y - end\n      (lvar :n) :-\n      (int 1))) :aby - ) max ","(x - end\n  (x - end\n    (x - end\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (x - end\n      (lvar :n) :-\n      (int 1))) :abx - ) max ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (lvar :n) :-\n      (int 1))) :ab(send\n  (lvar :y) :-\n  (lvar :x)) / ) max ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (@h [] [] abs + end\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (@h [] [] abs + end\n      (lvar :n) :-\n      (int 1))) :ab@h [] [] abs + ) max ","(x abs + end\n  (x abs + end\n    (x abs + end\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (x abs + end\n      (lvar :n) :-\n      (int 1))) :abx abs + ) max ","(send\n  (send\n    (send\n      (iva@h [] []  :@h) :[]\n      (lva@h [] []  :i)) :[]\n    (send\n      (lva@h [] []  :n) :-\n      (int 1))) :abs) max ","(send\n  (send\n    (send\n      (ivax -  :@h) :[]\n      (lvax -  :i)) :[]\n    (send\n      (lvax -  :n) :-\n      (int 1))) :abs) max ","(send\n  (send\n    (send\n      (ivaMath  sqrt  :@h) :[]\n      (lvaMath  sqrt  :i)) :[]\n    (send\n      (lvaMath  sqrt  :n) :-\n      (int 1))) :abs) max ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) n - ax ","(senn - d\n  (senn - d\n    (senn - d\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (senn - d\n      (lvar :nn - ) :-\n      (inn - t 1))) :abs) max ","@h [] [] abs -@  ","@h [] [] abMath  sqrt  ","@h [] [] abp abs + +  ","@h [] [] aby -  ","@h [] [] abx -  ","@h [] [] ab(send\n  (lvar :y) :-\n  (lvar :x)) /  ","@h [] [] ab@h [] [] abs +  ","@h [] [] abx abs +  ","s -@  -@ - ","Math  sqrt  -@ - ","p abs + +  -@ - ","y -  -@ - ","x -  -@ - ","(send\n  (lvar :y) :-\n  (lvar :x)) /  -@ - ","@h [] [] abs +  -@ - ","x abs +  -@ - ","@h [] []  * ","q /  * ","0.75 *  * ","s -@  -@ ","Math  sqrt  -@ ","p abs + +  -@ ","y -  -@ ","x -  -@ ","(send\n  (lvar :y) :-\n  (lvar :x)) /  -@ ","@h [] [] abs +  -@ ","x abs +  -@ ","@h [] []  -@ - ","@h [] []  -@ ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  1))))) / ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (in@h [] [] abs  1))))) / ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  1))))) / ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :@h [] [] - ) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :-0.4375 * * ) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :@h [] [] * ) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lvar :sa + ) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (n - var :sa) :-@) :-\n    (send\n      (n - var :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (n - var :i)) :[]\n        (n - var :n)))) :-\n  (send\n    (n - var :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (n - var :i)) :[]\n      (send\n        (n - var :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :@e [] ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :@h [] [] ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :@h [] [] - - - ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :z / ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lvar :sa) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (send\n    (lvar :p * + ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (send\n        (lvar :n) :-\n        (int 1))))) / ","(s -@ end\n  (s -@ end\n    (s -@ end\n      (lvar :s -@ a) :-@) :-\n    (s -@ end\n      (lvar :w) :*\n      (s -@ end\n        (s -@ end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (s -@ end\n    (lvar :q) :*\n    (s -@ end\n      (s -@ end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (s -@ end\n        (lvar :n) :-\n        (int 1))))) / ","(Math  sqrt end\n  (Math  sqrt end\n    (Math  sqrt end\n      (lvar :Math  sqrt a) :-@) :-\n    (Math  sqrt end\n      (lvar :w) :*\n      (Math  sqrt end\n        (Math  sqrt end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (Math  sqrt end\n    (lvar :q) :*\n    (Math  sqrt end\n      (Math  sqrt end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (Math  sqrt end\n        (lvar :n) :-\n        (int 1))))) / ","(p abs + + end\n  (p abs + + end\n    (p abs + + end\n      (lvar :p abs + + a) :-@) :-\n    (p abs + + end\n      (lvar :w) :*\n      (p abs + + end\n        (p abs + + end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (p abs + + end\n    (lvar :q) :*\n    (p abs + + end\n      (p abs + + end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (p abs + + end\n        (lvar :n) :-\n        (int 1))))) / ","(y - end\n  (y - end\n    (y - end\n      (lvar :y - a) :-@) :-\n    (y - end\n      (lvar :w) :*\n      (y - end\n        (y - end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (y - end\n    (lvar :q) :*\n    (y - end\n      (y - end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (y - end\n        (lvar :n) :-\n        (int 1))))) / ","(x - end\n  (x - end\n    (x - end\n      (lvar :x - a) :-@) :-\n    (x - end\n      (lvar :w) :*\n      (x - end\n        (x - end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (x - end\n    (lvar :q) :*\n    (x - end\n      (x - end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (x - end\n        (lvar :n) :-\n        (int 1))))) / ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (lvar :(send\n  (lvar :y) :-\n  (lvar :x)) / a) :-@) :-\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (lvar :w) :*\n      ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n        ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (lvar :q) :*\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n        (lvar :n) :-\n        (int 1))))) / ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (@h [] [] abs + end\n      (lvar :@h [] [] abs + a) :-@) :-\n    (@h [] [] abs + end\n      (lvar :w) :*\n      (@h [] [] abs + end\n        (@h [] [] abs + end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (@h [] [] abs + end\n    (lvar :q) :*\n    (@h [] [] abs + end\n      (@h [] [] abs + end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (@h [] [] abs + end\n        (lvar :n) :-\n        (int 1))))) / ","(x abs + end\n  (x abs + end\n    (x abs + end\n      (lvar :x abs + a) :-@) :-\n    (x abs + end\n      (lvar :w) :*\n      (x abs + end\n        (x abs + end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :n)))) :-\n  (x abs + end\n    (lvar :q) :*\n    (x abs + end\n      (x abs + end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (x abs + end\n        (lvar :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lva@h [] []  :sa) :-@) :-\n    (send\n      (lva@h [] []  :w) :*\n      (send\n        (send\n          (iva@h [] []  :@h) :[]\n          (lva@h [] []  :i)) :[]\n        (lva@h [] []  :n)))) :-\n  (send\n    (lva@h [] []  :q) :*\n    (send\n      (send\n        (iva@h [] []  :@h) :[]\n        (lva@h [] []  :i)) :[]\n      (send\n        (lva@h [] []  :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lvax -  :sa) :-@) :-\n    (send\n      (lvax -  :w) :*\n      (send\n        (send\n          (ivax -  :@h) :[]\n          (lvax -  :i)) :[]\n        (lvax -  :n)))) :-\n  (send\n    (lvax -  :q) :*\n    (send\n      (send\n        (ivax -  :@h) :[]\n        (lvax -  :i)) :[]\n      (send\n        (lvax -  :n) :-\n        (int 1))))) / ","(send\n  (send\n    (send\n      (lvaMath  sqrt  :sa) :-@) :-\n    (send\n      (lvaMath  sqrt  :w) :*\n      (send\n        (send\n          (ivaMath  sqrt  :@h) :[]\n          (lvaMath  sqrt  :i)) :[]\n        (lvaMath  sqrt  :n)))) :-\n  (send\n    (lvaMath  sqrt  :q) :*\n    (send\n      (send\n        (ivaMath  sqrt  :@h) :[]\n        (lvaMath  sqrt  :i)) :[]\n      (send\n        (lvaMath  sqrt  :n) :-\n        (int 1))))) / ","(senn - d\n  (senn - d\n    (senn - d\n      (lvar :sa) :-@) :-\n    (senn - d\n      (lvar :w) :*\n      (senn - d\n        (senn - d\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (lvar :nn - )))) :-\n  (senn - d\n    (lvar :q) :*\n    (senn - d\n      (senn - d\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (senn - d\n        (lvar :nn - ) :-\n        (inn - t 1))))) / ","sa +  -@ - - ","s -@ a -@ - - ","Math  sqrt a -@ - - ","p abs + + a -@ - - ","y - a -@ - - ","x - a -@ - - ","(send\n  (lvar :y) :-\n  (lvar :x)) / a -@ - - ","@h [] [] abs + a -@ - - ","x abs + a -@ - - ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * +  * ","@e []  * ","@h [] [] - - -  * ","z /  * ","p * +  * ","sa +  -@ - ","s -@ a -@ - ","Math  sqrt a -@ - ","p abs + + a -@ - ","y - a -@ - ","x - a -@ - ","(send\n  (lvar :y) :-\n  (lvar :x)) / a -@ - ","@h [] [] abs + a -@ - ","x abs + a -@ - ","@h [] [] -  * ","-0.4375 * *  * ","@h [] [] *  * ","sa +  -@ ","s -@ a -@ ","Math  sqrt a -@ ","p abs + + a -@ ","y - a -@ ","x - a -@ ","(send\n  (lvar :y) :-\n  (lvar :x)) / a -@ ","@h [] [] abs + a -@ ","x abs + a -@ ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  1))))) :+\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (in@h [] [] abs  1))))) :+\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  1))))) :+\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :@h [] [] - ) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (int 1))))) :+\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :-0.4375 * * ) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (int 1))))) :+\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :@h [] [] * ) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (int 1))))) :+\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra + ) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (int 1))))) :+\n  (send\n    (lvar :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (n - var :ra) :-@) :-\n    (send\n      (n - var :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (n - var :i)) :[]\n        (send\n          (n - var :n) :-\n          (int 1))))) :+\n  (send\n    (n - var :q) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (n - var :i)) :[]\n      (n - var :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (int 1))))) :+\n  (send\n    (lvar :(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (int 1))))) :+\n  (send\n    (lvar :@e [] ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (int 1))))) :+\n  (send\n    (lvar :@h [] [] ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (int 1))))) :+\n  (send\n    (lvar :@h [] [] - - - ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (int 1))))) :+\n  (send\n    (lvar :z / ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lvar :ra) :-@) :-\n    (send\n      (lvar :w) :*\n      (send\n        (send\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (send\n          (lvar :n) :-\n          (int 1))))) :+\n  (send\n    (lvar :p * + ) :*\n    (send\n      (send\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(s -@ end\n  (s -@ end\n    (s -@ end\n      (lvar :ra) :-@) :-\n    (s -@ end\n      (lvar :w) :*\n      (s -@ end\n        (s -@ end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (s -@ end\n          (lvar :n) :-\n          (int 1))))) :+\n  (s -@ end\n    (lvar :q) :*\n    (s -@ end\n      (s -@ end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(Math  sqrt end\n  (Math  sqrt end\n    (Math  sqrt end\n      (lvar :ra) :-@) :-\n    (Math  sqrt end\n      (lvar :w) :*\n      (Math  sqrt end\n        (Math  sqrt end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (Math  sqrt end\n          (lvar :n) :-\n          (int 1))))) :+\n  (Math  sqrt end\n    (lvar :q) :*\n    (Math  sqrt end\n      (Math  sqrt end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(p abs + + end\n  (p abs + + end\n    (p abs + + end\n      (lvar :ra) :-@) :-\n    (p abs + + end\n      (lvar :w) :*\n      (p abs + + end\n        (p abs + + end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (p abs + + end\n          (lvar :n) :-\n          (int 1))))) :+\n  (p abs + + end\n    (lvar :q) :*\n    (p abs + + end\n      (p abs + + end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(y - end\n  (y - end\n    (y - end\n      (lvar :ra) :-@) :-\n    (y - end\n      (lvar :w) :*\n      (y - end\n        (y - end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (y - end\n          (lvar :n) :-\n          (int 1))))) :+\n  (y - end\n    (lvar :q) :*\n    (y - end\n      (y - end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(x - end\n  (x - end\n    (x - end\n      (lvar :ra) :-@) :-\n    (x - end\n      (lvar :w) :*\n      (x - end\n        (x - end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (x - end\n          (lvar :n) :-\n          (int 1))))) :+\n  (x - end\n    (lvar :q) :*\n    (x - end\n      (x - end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (lvar :ra) :-@) :-\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (lvar :w) :*\n      ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n        ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n          (lvar :n) :-\n          (int 1))))) :+\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (lvar :q) :*\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (@h [] [] abs + end\n      (lvar :ra) :-@) :-\n    (@h [] [] abs + end\n      (lvar :w) :*\n      (@h [] [] abs + end\n        (@h [] [] abs + end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (@h [] [] abs + end\n          (lvar :n) :-\n          (int 1))))) :+\n  (@h [] [] abs + end\n    (lvar :q) :*\n    (@h [] [] abs + end\n      (@h [] [] abs + end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(x abs + end\n  (x abs + end\n    (x abs + end\n      (lvar :ra) :-@) :-\n    (x abs + end\n      (lvar :w) :*\n      (x abs + end\n        (x abs + end\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (x abs + end\n          (lvar :n) :-\n          (int 1))))) :+\n  (x abs + end\n    (lvar :q) :*\n    (x abs + end\n      (x abs + end\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :n)))) / ","(send\n  (send\n    (send\n      (lva@h [] []  :@h [] [] a) :-@) :-\n    (send\n      (lva@h [] []  :w) :*\n      (send\n        (send\n          (iva@h [] []  :@h) :[]\n          (lva@h [] []  :i)) :[]\n        (send\n          (lva@h [] []  :n) :-\n          (int 1))))) :+\n  (send\n    (lva@h [] []  :q) :*\n    (send\n      (send\n        (iva@h [] []  :@h) :[]\n        (lva@h [] []  :i)) :[]\n      (lva@h [] []  :n)))) / ","(send\n  (send\n    (send\n      (lvax -  :x - a) :-@) :-\n    (send\n      (lvax -  :w) :*\n      (send\n        (send\n          (ivax -  :@h) :[]\n          (lvax -  :i)) :[]\n        (send\n          (lvax -  :n) :-\n          (int 1))))) :+\n  (send\n    (lvax -  :q) :*\n    (send\n      (send\n        (ivax -  :@h) :[]\n        (lvax -  :i)) :[]\n      (lvax -  :n)))) / ","(send\n  (send\n    (send\n      (lvaMath  sqrt  :Math  sqrt a) :-@) :-\n    (send\n      (lvaMath  sqrt  :w) :*\n      (send\n        (send\n          (ivaMath  sqrt  :@h) :[]\n          (lvaMath  sqrt  :i)) :[]\n        (send\n          (lvaMath  sqrt  :n) :-\n          (int 1))))) :+\n  (send\n    (lvaMath  sqrt  :q) :*\n    (send\n      (send\n        (ivaMath  sqrt  :@h) :[]\n        (lvaMath  sqrt  :i)) :[]\n      (lvaMath  sqrt  :n)))) / ","(senn - d\n  (senn - d\n    (senn - d\n      (lvar :ra) :-@) :-\n    (senn - d\n      (lvar :w) :*\n      (senn - d\n        (senn - d\n          (ivar :@h) :[]\n          (lvar :i)) :[]\n        (senn - d\n          (lvar :nn - ) :-\n          (inn - t 1))))) :+\n  (senn - d\n    (lvar :q) :*\n    (senn - d\n      (senn - d\n        (ivar :@h) :[]\n        (lvar :i)) :[]\n      (lvar :nn - )))) / ","ra +  -@ - + ","@h [] [] a -@ - + ","x - a -@ - + ","Math  sqrt a -@ - + ","ra +  -@ - ","@h [] [] a -@ - ","ra +  -@ ","@h [] [] a -@ ","@h [] []  abs > ","p /  abs > ","p abs + +  abs > ","x abs -@  > ","x abMath  sqrt  > ","x abp abs + +  > ","x aby -  > ","x abx -  > ","x ab(send\n  (lvar :y) :-\n  (lvar :x)) /  > ","x ab@h [] [] abs +  > ","x abx abs +  > ","r /  abs + ","@h [] []  abs + ","@v [] []  abs + ","p -  abs + ","p +  abs + ","Math  sqrt  abs + ","z abs -@  + ","z abMath  sqrt  + ","z abp abs + +  + ","z aby -  + ","z abx -  + ","z ab(send\n  (lvar :y) :-\n  (lvar :x)) /  + ","z ab@h [] [] abs +  + ","z abx abs +  + ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * +  abs ","@e []  abs ","@h [] []  abs ","@h [] [] - - -  abs ","z /  abs ","p * +  abs ","q abs -@  ","q abMath  sqrt  ","q abp abs + +  ","q aby -  ","q abx -  ","q ab(send\n  (lvar :y) :-\n  (lvar :x)) /  ","q ab@h [] [] abs +  ","q abx abs +  ","r /  abs ","@v [] []  abs ","p -  abs ","p +  abs ","Math  sqrt  abs ","z abs -@  ","z abMath  sqrt  ","z abp abs + +  ","z aby -  ","z abx -  ","z ab(send\n  (lvar :y) :-\n  (lvar :x)) /  ","z ab@h [] [] abs +  ","z abx abs +  ","p /  abs ","p abs + +  abs ","x abs -@  ","x abMath  sqrt  ","x abp abs + +  ","x aby -  ","x abx -  ","x ab(send\n  (lvar :y) :-\n  (lvar :x)) /  ","x ab@h [] [] abs +  ","x abx abs +  ","@h [] []  * - - ","p /  * - - ","p abs + +  * - - ","@h [] []  * - ","p /  * - ","p abs + +  * - ","r /  * ","@v [] []  * ","p -  * ","p +  * ","Math  sqrt  * ","p /  * ","p abs + +  * ","@h [] []  * - + ","p /  * - + ","p abs + +  * - + ","e@d [] s * * ","ex * + s * * ","e@h [] [] + s * * ","e@h [] [] s * * ","e(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + s * * ","ex / s * * ","e(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / s * * ","eps -@  * * ","epMath  sqrt  * * ","epp abs + +  * * ","epy -  * * ","epx -  * * ","ep(send\n  (lvar :y) :-\n  (lvar :x)) /  * * ","ep@h [] [] abs +  * * ","epx abs +  * * ","@h [] [] -  abs + + + + ","-0.4375 * *  abs + + + + ","@h [] [] *  abs + + + + ","w abs -@  + + + + ","w abMath  sqrt  + + + + ","w abp abs + +  + + + + ","w aby -  + + + + ","w abx -  + + + + ","w ab(send\n  (lvar :y) :-\n  (lvar :x)) /  + + + + ","w ab@h [] [] abs +  + + + + ","w abx abs +  + + + + ","@h [] [] -  abs + + + ","-0.4375 * *  abs + + + ","@h [] [] *  abs + + + ","w abs -@  + + + ","w abMath  sqrt  + + + ","w abp abs + +  + + + ","w aby -  + + + ","w abx -  + + + ","w ab(send\n  (lvar :y) :-\n  (lvar :x)) /  + + + ","w ab@h [] [] abs +  + + + ","w abx abs +  + + + ","q /  abs ","0.75 *  abs ","y abs -@  ","y abMath  sqrt  ","y abp abs + +  ","y aby -  ","y abx -  ","y ab(send\n  (lvar :y) :-\n  (lvar :x)) /  ","y ab@h [] [] abs +  ","y abx abs +  ","@h [] [] -  abs + + ","-0.4375 * *  abs + + ","@h [] [] *  abs + + ","w abs -@  + + ","w abMath  sqrt  + + ","w abp abs + +  + + ","w aby -  + + ","w abx -  + + ","w ab(send\n  (lvar :y) :-\n  (lvar :x)) /  + + ","w ab@h [] [] abs +  + + ","w abx abs +  + + ","@h [] [] -  abs + ","-0.4375 * *  abs + ","@h [] [] *  abs + ","w abs -@  + ","w abMath  sqrt  + ","w abp abs + +  + ","w aby -  + ","w abx -  + ","w ab(send\n  (lvar :y) :-\n  (lvar :x)) /  + ","w ab@h [] [] abs +  + ","w abx abs +  + ","@h [] [] -  abs ","-0.4375 * *  abs ","@h [] [] *  abs ","w abs -@  ","w abMath  sqrt  ","w abp abs + +  ","w aby -  ","w abx -  ","w ab(send\n  (lvar :y) :-\n  (lvar :x)) /  ","w ab@h [] [] abs +  ","w abx abs +  ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * *  == ","eps * *  == ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + -  == ","v@h [] []  == ","vx -  == ","vMath  sqrt  == ","(send\n  (send\n    (ivar :@d) :[]\n    (n - var :i)) :-\n  (n - var :p)) * * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@d [] )) * * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :x * + )) * * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@h [] [] + )) * * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@h [] [] )) * * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + )) * * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :x / )) * * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / )) * * ","(s -@ end\n  (s -@ end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * * ","(Math  sqrt end\n  (Math  sqrt end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * * ","(p abs + + end\n  (p abs + + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * * ","(y - end\n  (y - end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * * ","(x - end\n  (x - end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * * ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * * ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * * ","(x abs + end\n  (x abs + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * * ","(send\n  (send\n    (iva@h [] []  :@d) :[]\n    (lva@h [] []  :i)) :-\n  (lva@h [] []  :p)) * * ","(send\n  (send\n    (ivax -  :@d) :[]\n    (lvax -  :i)) :-\n  (lvax -  :p)) * * ","(send\n  (send\n    (ivaMath  sqrt  :@d) :[]\n    (lvaMath  sqrt  :i)) :-\n  (lvaMath  sqrt  :p)) * * ","(senn - d\n  (senn - d\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * * ","(send\n  (send\n    (ivar :@d) :[]\n    (n - var :i)) :-\n  (n - var :p)) * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@d [] )) * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :x * + )) * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@h [] [] + )) * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@h [] [] )) * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + )) * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :x / )) * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / )) * ","(s -@ end\n  (s -@ end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * ","(Math  sqrt end\n  (Math  sqrt end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * ","(p abs + + end\n  (p abs + + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * ","(y - end\n  (y - end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * ","(x - end\n  (x - end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * ","(x abs + end\n  (x abs + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * ","(send\n  (send\n    (iva@h [] []  :@d) :[]\n    (lva@h [] []  :i)) :-\n  (lva@h [] []  :p)) * ","(send\n  (send\n    (ivax -  :@d) :[]\n    (lvax -  :i)) :-\n  (lvax -  :p)) * ","(send\n  (send\n    (ivaMath  sqrt  :@d) :[]\n    (lvaMath  sqrt  :i)) :-\n  (lvaMath  sqrt  :p)) * ","(senn - d\n  (senn - d\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * ","(send\n  (send\n    (ivar :@d) :[]\n    (n - var :i)) :-\n  (n - var :p)) * + - ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@d [] )) * + - ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :x * + )) * + - ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@h [] [] + )) * + - ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@h [] [] )) * + - ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + )) * + - ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :x / )) * + - ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / )) * + - ","(s -@ end\n  (s -@ end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + - ","(Math  sqrt end\n  (Math  sqrt end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + - ","(p abs + + end\n  (p abs + + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + - ","(y - end\n  (y - end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + - ","(x - end\n  (x - end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + - ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + - ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + - ","(x abs + end\n  (x abs + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + - ","(send\n  (send\n    (iva@h [] []  :@d) :[]\n    (lva@h [] []  :i)) :-\n  (lva@h [] []  :p)) * + - ","(send\n  (send\n    (ivax -  :@d) :[]\n    (lvax -  :i)) :-\n  (lvax -  :p)) * + - ","(send\n  (send\n    (ivaMath  sqrt  :@d) :[]\n    (lvaMath  sqrt  :i)) :-\n  (lvaMath  sqrt  :p)) * + - ","(senn - d\n  (senn - d\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + - ","(send\n  (send\n    (ivar :@d) :[]\n    (n - var :i)) :-\n  (n - var :p)) * + ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@d [] )) * + ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :x * + )) * + ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@h [] [] + )) * + ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :@h [] [] )) * + ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + )) * + ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :x / )) * + ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / )) * + ","(s -@ end\n  (s -@ end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ","(Math  sqrt end\n  (Math  sqrt end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ","(p abs + + end\n  (p abs + + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ","(y - end\n  (y - end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ","(x - end\n  (x - end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ","(x abs + end\n  (x abs + end\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ","(send\n  (send\n    (iva@h [] []  :@d) :[]\n    (lva@h [] []  :i)) :-\n  (lva@h [] []  :p)) * + ","(send\n  (send\n    (ivax -  :@d) :[]\n    (lvax -  :i)) :-\n  (lvax -  :p)) * + ","(send\n  (send\n    (ivaMath  sqrt  :@d) :[]\n    (lvaMath  sqrt  :i)) :-\n  (lvaMath  sqrt  :p)) * + ","(senn - d\n  (senn - d\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + ","sa +  + ","s -@ a + ","Math  sqrt a + ","p abs + + a + ","y - a + ","x - a + ","(send\n  (lvar :y) :-\n  (lvar :x)) / a + ","@h [] [] abs + a + ","x abs + a + ","ra +  + ","@h [] [] a + ","l up(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","l up@h [] [] abs o ","l up(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","n -  upto ","l u@d [] to ","l ux * + to ","l u@h [] [] + to ","l u@h [] [] to ","l u(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + to ","l ux / to ","l u(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / to ","(send\n  (lvar :n) :-\n  (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  2)) down(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","(send\n  (lvar :n) :-\n  (in@h [] [] abs  2)) down@h [] [] abs o ","(send\n  (lvar :n) :-\n  (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  2)) down(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","(send\n  (lvar :n) :-\n  (int 2)) do@h [] [] - nto ","(send\n  (lvar :n) :-\n  (int 2)) do-0.4375 * * nto ","(send\n  (lvar :n) :-\n  (int 2)) do@h [] [] * nto ","(send\n  (n - var :n) :-\n  (int 2)) downto ","(s -@ end\n  (lvar :n) :-\n  (int 2)) downto ","(Math  sqrt end\n  (lvar :n) :-\n  (int 2)) downto ","(p abs + + end\n  (lvar :n) :-\n  (int 2)) downto ","(y - end\n  (lvar :n) :-\n  (int 2)) downto ","(x - end\n  (lvar :n) :-\n  (int 2)) downto ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  (lvar :n) :-\n  (int 2)) downto ","(@h [] [] abs + end\n  (lvar :n) :-\n  (int 2)) downto ","(x abs + end\n  (lvar :n) :-\n  (int 2)) downto ","(send\n  (lva@h [] []  :n) :-\n  (int 2)) downto ","(send\n  (lvax -  :n) :-\n  (int 2)) downto ","(send\n  (lvaMath  sqrt  :n) :-\n  (int 2)) downto ","(senn - d\n  (lvar :nn - ) :-\n  (inn - t 2)) downn - to ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (n - var :n)) :[]\n    (n - var :n)) :-\n  (n - var :p)) -@ / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :@d [] )) -@ / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :x * + )) -@ / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :@h [] [] + )) -@ / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :@h [] [] )) -@ / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + )) -@ / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :x / )) -@ / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / )) -@ / ","(s -@ end\n  (s -@ end\n    (s -@ end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ / ","(Math  sqrt end\n  (Math  sqrt end\n    (Math  sqrt end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ / ","(p abs + + end\n  (p abs + + end\n    (p abs + + end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ / ","(y - end\n  (y - end\n    (y - end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ / ","(x - end\n  (x - end\n    (x - end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ / ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ / ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (@h [] [] abs + end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ / ","(x abs + end\n  (x abs + end\n    (x abs + end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ / ","(send\n  (send\n    (send\n      (iva@h [] []  :@h) :[]\n      (lva@h [] []  :n)) :[]\n    (lva@h [] []  :n)) :-\n  (lva@h [] []  :p)) -@ / ","(send\n  (send\n    (send\n      (ivax -  :@h) :[]\n      (lvax -  :n)) :[]\n    (lvax -  :n)) :-\n  (lvax -  :p)) -@ / ","(send\n  (send\n    (send\n      (ivaMath  sqrt  :@h) :[]\n      (lvaMath  sqrt  :n)) :[]\n    (lvaMath  sqrt  :n)) :-\n  (lvaMath  sqrt  :p)) -@ / ","(senn - d\n  (senn - d\n    (senn - d\n      (ivar :@h) :[]\n      (lvar :nn - )) :[]\n    (lvar :nn - )) :-\n  (lvar :p)) -@ / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (n - var :n)) :[]\n    (n - var :n)) :-\n  (n - var :p)) -@ ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :@d [] )) -@ ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :x * + )) -@ ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :@h [] [] + )) -@ ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :@h [] [] )) -@ ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + )) -@ ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :x / )) -@ ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / )) -@ ","(s -@ end\n  (s -@ end\n    (s -@ end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ ","(Math  sqrt end\n  (Math  sqrt end\n    (Math  sqrt end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ ","(p abs + + end\n  (p abs + + end\n    (p abs + + end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ ","(y - end\n  (y - end\n    (y - end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ ","(x - end\n  (x - end\n    (x - end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (@h [] [] abs + end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ ","(x abs + end\n  (x abs + end\n    (x abs + end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n)) :-\n  (lvar :p)) -@ ","(send\n  (send\n    (send\n      (iva@h [] []  :@h) :[]\n      (lva@h [] []  :n)) :[]\n    (lva@h [] []  :n)) :-\n  (lva@h [] []  :p)) -@ ","(send\n  (send\n    (send\n      (ivax -  :@h) :[]\n      (lvax -  :n)) :[]\n    (lvax -  :n)) :-\n  (lvax -  :p)) -@ ","(send\n  (send\n    (send\n      (ivaMath  sqrt  :@h) :[]\n      (lvaMath  sqrt  :n)) :[]\n    (lvaMath  sqrt  :n)) :-\n  (lvaMath  sqrt  :p)) -@ ","(senn - d\n  (senn - d\n    (senn - d\n      (ivar :@h) :[]\n      (lvar :nn - )) :[]\n    (lvar :nn - )) :-\n  (lvar :p)) -@ ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * +  / ","@e []  / ","@h [] []  / ","@h [] [] - - -  / ","z /  / ","p * +  / ","@h [] [] abs -@  > ","@h [] [] abMath  sqrt  > ","@h [] [] abp abs + +  > ","@h [] [] aby -  > ","@h [] [] abx -  > ","@h [] [] ab(send\n  (lvar :y) :-\n  (lvar :x)) /  > ","@h [] [] ab@h [] [] abs +  > ","@h [] [] abx abs +  > ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * +  < ","@e []  < ","@h [] []  < ","@h [] [] - - -  < ","z /  < ","p * +  < ","(send\n  (send\n    (lvar :s) :-@) :-\n  (send\n    (lvar :y) :*\n    (lvar :(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max ))) / ","(send\n  (send\n    (lvar :s) :-@) :-\n  (send\n    (lvar :y) :*\n    (lvar :@h [] [] abs ))) / ","(send\n  (send\n    (lvar :s) :-@) :-\n  (send\n    (lvar :y) :*\n    (lvar :(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / ))) / ","(send\n  (send\n    (lvar :s) :-@) :-\n  (send\n    (lvar :@h [] [] ) :*\n    (lvar :t))) / ","(send\n  (send\n    (lvar :s) :-@) :-\n  (send\n    (lvar :q / ) :*\n    (lvar :t))) / ","(send\n  (send\n    (lvar :s) :-@) :-\n  (send\n    (lvar :0.75 * ) :*\n    (lvar :t))) / ","(send\n  (send\n    (n - var :s) :-@) :-\n  (send\n    (n - var :y) :*\n    (n - var :t))) / ","(s -@ end\n  (s -@ end\n    (lvar :s -@ ) :-@) :-\n  (s -@ end\n    (lvar :y) :*\n    (lvar :t))) / ","(Math  sqrt end\n  (Math  sqrt end\n    (lvar :Math  sqrt ) :-@) :-\n  (Math  sqrt end\n    (lvar :y) :*\n    (lvar :t))) / ","(p abs + + end\n  (p abs + + end\n    (lvar :p abs + + ) :-@) :-\n  (p abs + + end\n    (lvar :y) :*\n    (lvar :t))) / ","(y - end\n  (y - end\n    (lvar :y - ) :-@) :-\n  (y - end\n    (lvar :y) :*\n    (lvar :t))) / ","(x - end\n  (x - end\n    (lvar :x - ) :-@) :-\n  (x - end\n    (lvar :y) :*\n    (lvar :t))) / ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (lvar :(send\n  (lvar :y) :-\n  (lvar :x)) / ) :-@) :-\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (lvar :y) :*\n    (lvar :t))) / ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (lvar :@h [] [] abs + ) :-@) :-\n  (@h [] [] abs + end\n    (lvar :y) :*\n    (lvar :t))) / ","(x abs + end\n  (x abs + end\n    (lvar :x abs + ) :-@) :-\n  (x abs + end\n    (lvar :y) :*\n    (lvar :t))) / ","(send\n  (send\n    (lva@h [] []  :s) :-@) :-\n  (send\n    (lva@h [] []  :y) :*\n    (lva@h [] []  :t))) / ","(send\n  (send\n    (lvax -  :s) :-@) :-\n  (send\n    (lvax -  :y) :*\n    (lvax -  :t))) / ","(send\n  (send\n    (lvaMath  sqrt  :s) :-@) :-\n  (send\n    (lvaMath  sqrt  :y) :*\n    (lvaMath  sqrt  :t))) / ","(senn - d\n  (senn - d\n    (lvar :s) :-@) :-\n  (senn - d\n    (lvar :y) :*\n    (lvar :t))) / ","(send\n  (send\n    (lvar :r) :-@) :-\n  (send\n    (lvar :w) :*\n    (lvar :(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max ))) / ","(send\n  (send\n    (lvar :r) :-@) :-\n  (send\n    (lvar :w) :*\n    (lvar :@h [] [] abs ))) / ","(send\n  (send\n    (lvar :r) :-@) :-\n  (send\n    (lvar :w) :*\n    (lvar :(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / ))) / ","(send\n  (send\n    (lvar :r) :-@) :-\n  (send\n    (lvar :@h [] [] - ) :*\n    (lvar :t))) / ","(send\n  (send\n    (lvar :r) :-@) :-\n  (send\n    (lvar :-0.4375 * * ) :*\n    (lvar :t))) / ","(send\n  (send\n    (lvar :r) :-@) :-\n  (send\n    (lvar :@h [] [] * ) :*\n    (lvar :t))) / ","(send\n  (send\n    (n - var :r) :-@) :-\n  (send\n    (n - var :w) :*\n    (n - var :t))) / ","(s -@ end\n  (s -@ end\n    (lvar :r) :-@) :-\n  (s -@ end\n    (lvar :w) :*\n    (lvar :t))) / ","(Math  sqrt end\n  (Math  sqrt end\n    (lvar :r) :-@) :-\n  (Math  sqrt end\n    (lvar :w) :*\n    (lvar :t))) / ","(p abs + + end\n  (p abs + + end\n    (lvar :r) :-@) :-\n  (p abs + + end\n    (lvar :w) :*\n    (lvar :t))) / ","(y - end\n  (y - end\n    (lvar :r) :-@) :-\n  (y - end\n    (lvar :w) :*\n    (lvar :t))) / ","(x - end\n  (x - end\n    (lvar :r) :-@) :-\n  (x - end\n    (lvar :w) :*\n    (lvar :t))) / ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (lvar :r) :-@) :-\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (lvar :w) :*\n    (lvar :t))) / ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (lvar :r) :-@) :-\n  (@h [] [] abs + end\n    (lvar :w) :*\n    (lvar :t))) / ","(x abs + end\n  (x abs + end\n    (lvar :r) :-@) :-\n  (x abs + end\n    (lvar :w) :*\n    (lvar :t))) / ","(send\n  (send\n    (lva@h [] []  :@h [] [] ) :-@) :-\n  (send\n    (lva@h [] []  :w) :*\n    (lva@h [] []  :t))) / ","(send\n  (send\n    (lvax -  :x - ) :-@) :-\n  (send\n    (lvax -  :w) :*\n    (lvax -  :t))) / ","(send\n  (send\n    (lvaMath  sqrt  :Math  sqrt ) :-@) :-\n  (send\n    (lvaMath  sqrt  :w) :*\n    (lvaMath  sqrt  :t))) / ","(senn - d\n  (senn - d\n    (lvar :r) :-@) :-\n  (senn - d\n    (lvar :w) :*\n    (lvar :t))) / ","(send\n  (send\n    (lvar :@h [] [] ) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / ","(send\n  (send\n    (lvar :p / ) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / ","(send\n  (send\n    (lvar :p abs + + ) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / ","(send\n  (send\n    (n - var :x) :*\n    (n - var :s)) :-\n  (send\n    (n - var :z) :*\n    (n - var :r))) / ","(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :r / ) :*\n    (lvar :r))) / ","(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :@h [] [] ) :*\n    (lvar :r))) / ","(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :@v [] [] ) :*\n    (lvar :r))) / ","(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :p - ) :*\n    (lvar :r))) / ","(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :p + ) :*\n    (lvar :r))) / ","(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :Math  sqrt ) :*\n    (lvar :r))) / ","(s -@ end\n  (s -@ end\n    (lvar :x) :*\n    (lvar :s -@ )) :-\n  (s -@ end\n    (lvar :z) :*\n    (lvar :r))) / ","(Math  sqrt end\n  (Math  sqrt end\n    (lvar :x) :*\n    (lvar :Math  sqrt )) :-\n  (Math  sqrt end\n    (lvar :z) :*\n    (lvar :r))) / ","(p abs + + end\n  (p abs + + end\n    (lvar :x) :*\n    (lvar :p abs + + )) :-\n  (p abs + + end\n    (lvar :z) :*\n    (lvar :r))) / ","(y - end\n  (y - end\n    (lvar :x) :*\n    (lvar :y - )) :-\n  (y - end\n    (lvar :z) :*\n    (lvar :r))) / ","(x - end\n  (x - end\n    (lvar :x) :*\n    (lvar :x - )) :-\n  (x - end\n    (lvar :z) :*\n    (lvar :r))) / ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (lvar :x) :*\n    (lvar :(send\n  (lvar :y) :-\n  (lvar :x)) / )) :-\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (lvar :z) :*\n    (lvar :r))) / ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (lvar :x) :*\n    (lvar :@h [] [] abs + )) :-\n  (@h [] [] abs + end\n    (lvar :z) :*\n    (lvar :r))) / ","(x abs + end\n  (x abs + end\n    (lvar :x) :*\n    (lvar :x abs + )) :-\n  (x abs + end\n    (lvar :z) :*\n    (lvar :r))) / ","(send\n  (send\n    (lva@h [] []  :x) :*\n    (lva@h [] []  :s)) :-\n  (send\n    (lva@h [] []  :z) :*\n    (lva@h [] []  :@h [] [] ))) / ","(send\n  (send\n    (lvax -  :x) :*\n    (lvax -  :s)) :-\n  (send\n    (lvax -  :z) :*\n    (lvax -  :x - ))) / ","(send\n  (send\n    (lvaMath  sqrt  :x) :*\n    (lvaMath  sqrt  :s)) :-\n  (send\n    (lvaMath  sqrt  :z) :*\n    (lvaMath  sqrt  :Math  sqrt ))) / ","(senn - d\n  (senn - d\n    (lvar :x) :*\n    (lvar :s)) :-\n  (senn - d\n    (lvar :z) :*\n    (lvar :r))) / ","@h [] []  -@ / ","x -  -@ / ","Math  sqrt  -@ / ","@h [] [] -  != ","-0.4375 * *  != ","@h [] [] *  != ","(send\n  (lvar :n) :-\n  (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  1)) down(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","(send\n  (lvar :n) :-\n  (in@h [] [] abs  1)) down@h [] [] abs o ","(send\n  (lvar :n) :-\n  (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  1)) down(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","(send\n  (lvar :n) :-\n  (int 1)) do@h [] [] - nto ","(send\n  (lvar :n) :-\n  (int 1)) do-0.4375 * * nto ","(send\n  (lvar :n) :-\n  (int 1)) do@h [] [] * nto ","(send\n  (n - var :n) :-\n  (int 1)) downto ","(s -@ end\n  (lvar :n) :-\n  (int 1)) downto ","(Math  sqrt end\n  (lvar :n) :-\n  (int 1)) downto ","(p abs + + end\n  (lvar :n) :-\n  (int 1)) downto ","(y - end\n  (lvar :n) :-\n  (int 1)) downto ","(x - end\n  (lvar :n) :-\n  (int 1)) downto ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  (lvar :n) :-\n  (int 1)) downto ","(@h [] [] abs + end\n  (lvar :n) :-\n  (int 1)) downto ","(x abs + end\n  (lvar :n) :-\n  (int 1)) downto ","(send\n  (lva@h [] []  :n) :-\n  (int 1)) downto ","(send\n  (lvax -  :n) :-\n  (int 1)) downto ","(send\n  (lvaMath  sqrt  :n) :-\n  (int 1)) downto ","(senn - d\n  (lvar :nn - ) :-\n  (inn - t 1)) downn - to ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * +  == ","@e []  == ","@h [] []  == ","@h [] [] - - -  == ","z /  == ","p * +  == ","no@h [] [] m == ","nox - m == ","noMath  sqrt m == ","norn -  == ","norm +  == ","nn - orm == ","@d []  * ","x * +  * ","@h [] [] +  * ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  * ","x /  * ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  * ","@h [] []  * + ","p /  * + ","p abs + +  * + ","0 up(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","0 up@h [] [] abs o ","0 up(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","0 u@d [] to ","0 ux * + to ","0 u@h [] [] + to ","0 u@h [] [] to ","0 u(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + to ","0 ux / to ","0 u(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / to ","(n - var :n) min ","(lva@h [] []  :n) min ","(lvax -  :n) min ","(lvaMath  sqrt  :n) min ","(lvar :n) n - in ","(lvar :nn - ) minn -  ","x -  * ","k up(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","k up@h [] [] abs o ","k up(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","k u@d [] to ","k ux * + to ","k u@h [] [] + to ","k u@h [] [] to ","k u(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + to ","k ux / to ","k u(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / to ","x -  / ","Math  sqrt  / ","@d []  / ","x * +  / ","@h [] [] +  / ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  / ","x /  / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  / ","n -  != ","s -@  -@ * ","Math  sqrt  -@ * ","p abs + +  -@ * ","y -  -@ * ","x -  -@ * ","(send\n  (lvar :y) :-\n  (lvar :x)) /  -@ * ","@h [] [] abs +  -@ * ","x abs +  -@ * ","s -@  != ","Math  sqrt  != ","p abs + +  != ","y -  != ","x -  != ","(send\n  (lvar :y) :-\n  (lvar :x)) /  != ","@h [] [] abs +  != ","x abs +  != ","@d []  < ","x * +  < ","@h [] [] +  < ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  < ","x /  < ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  < ","Ma(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max h  sqr(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  ","Ma@h [] [] abs h  sqr@h [] [] abs  ","Ma(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / h  sqr(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  ","Math  s(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * + rt ","Math  s@e [] rt ","Math  s@h [] [] rt ","Math  s@h [] [] - - - rt ","Math  sz / rt ","Math  sp * + rt ","Math  s -@ qrt ","Math  Math  sqrt qrt ","Math  p abs + + qrt ","Math  y - qrt ","Math  x - qrt ","Math  (send\n  (lvar :y) :-\n  (lvar :x)) / qrt ","Math  @h [] [] abs + qrt ","Math  x abs + qrt ","Math  sq@h [] [] t ","Math  sqx - t ","Math  sqMath  sqrt t ","@d []  * + + ","x * +  * + + ","@h [] [] +  * + + ","@h [] []  * + + ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  * + + ","x /  * + + ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  * + + ","@d []  * + ","x * +  * + ","@h [] [] +  * + ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  * + ","x /  * + ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  * + ","p /  == ","p abs + +  == ","@h [] []  != ","p /  != ","@d []  abs + + ","x * +  abs + + ","@h [] [] +  abs + + ","@h [] []  abs + + ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  abs + + ","x /  abs + + ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  abs + + ","p abs -@  + + ","p abMath  sqrt  + + ","p abp abs + +  + + ","p aby -  + + ","p abx -  + + ","p ab(send\n  (lvar :y) :-\n  (lvar :x)) /  + + ","p ab@h [] [] abs +  + + ","p abx abs +  + + ","r abs -@  ","r abMath  sqrt  ","r abp abs + +  ","r aby -  ","r abx -  ","r ab(send\n  (lvar :y) :-\n  (lvar :x)) /  ","r ab@h [] [] abs +  ","r abx abs +  ","x -  abs ","@d []  abs + ","x * +  abs + ","@h [] [] +  abs + ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  abs + ","x /  abs + ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  abs + ","p abs -@  + ","p abMath  sqrt  + ","p abp abs + +  + ","p aby -  + ","p abx -  + ","p ab(send\n  (lvar :y) :-\n  (lvar :x)) /  + ","p ab@h [] [] abs +  + ","p abx abs +  + ","@d []  abs ","x * +  abs ","@h [] [] +  abs ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  abs ","x /  abs ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  abs ","p abs -@  ","p abMath  sqrt  ","p abp abs + +  ","p aby -  ","p abx -  ","p ab(send\n  (lvar :y) :-\n  (lvar :x)) /  ","p ab@h [] [] abs +  ","p abx abs +  ","m up(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","m up@h [] [] abs o ","m up(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","m u@d [] to ","m ux * + to ","m u@h [] [] + to ","m u@h [] [] to ","m u(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + to ","m ux / to ","m u(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / to ","n -  + ","(send\n  (lvar :m) :+\n  (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  2)) up(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","(send\n  (lvar :m) :+\n  (in@h [] [] abs  2)) up@h [] [] abs o ","(send\n  (lvar :m) :+\n  (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  2)) up(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","(send\n  (n - var :m) :+\n  (int 2)) upto ","(send\n  (lvar :m) :+\n  (int 2)) u@d [] to ","(send\n  (lvar :m) :+\n  (int 2)) ux * + to ","(send\n  (lvar :m) :+\n  (int 2)) u@h [] [] + to ","(send\n  (lvar :m) :+\n  (int 2)) u@h [] [] to ","(send\n  (lvar :m) :+\n  (int 2)) u(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + to ","(send\n  (lvar :m) :+\n  (int 2)) ux / to ","(send\n  (lvar :m) :+\n  (int 2)) u(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / to ","(s -@ end\n  (lvar :m) :+\n  (int 2)) upto ","(Math  sqrt end\n  (lvar :m) :+\n  (int 2)) upto ","(p abs + + end\n  (lvar :m) :+\n  (int 2)) upto ","(y - end\n  (lvar :m) :+\n  (int 2)) upto ","(x - end\n  (lvar :m) :+\n  (int 2)) upto ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  (lvar :m) :+\n  (int 2)) upto ","(@h [] [] abs + end\n  (lvar :m) :+\n  (int 2)) upto ","(x abs + end\n  (lvar :m) :+\n  (int 2)) upto ","(send\n  (lva@h [] []  :m) :+\n  (int 2)) upto ","(send\n  (lvax -  :m) :+\n  (int 2)) upto ","(send\n  (lvaMath  sqrt  :m) :+\n  (int 2)) upto ","(send\n  (lvar :n - ) :+\n  (int 2)) upto ","(senn - d\n  (lvar :m) :+\n  (inn - t 2)) upto ","@h [] [] abs -@  * < ","@h [] [] abMath  sqrt  * < ","@h [] [] abp abs + +  * < ","@h [] [] aby -  * < ","@h [] [] abx -  * < ","@h [] [] ab(send\n  (lvar :y) :-\n  (lvar :x)) /  * < ","@h [] [] ab@h [] [] abs +  * < ","@h [] [] abx abs +  * < ","@d []  abs * ","x * +  abs * ","@h [] [] +  abs * ","@h [] []  abs * ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  abs * ","x /  abs * ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  abs * ","p abs -@  * ","p abMath  sqrt  * ","p abp abs + +  * ","p aby -  * ","p abx -  * ","p ab(send\n  (lvar :y) :-\n  (lvar :x)) /  * ","p ab@h [] [] abs +  * ","p abx abs +  * ","@h [] [] abs -@  + + ","@h [] [] abMath  sqrt  + + ","@h [] [] abp abs + +  + + ","@h [] [] aby -  + + ","@h [] [] abx -  + + ","@h [] [] ab(send\n  (lvar :y) :-\n  (lvar :x)) /  + + ","@h [] [] ab@h [] [] abs +  + + ","@h [] [] abx abs +  + + ","@h [] [] abs -@  + ","@h [] [] abMath  sqrt  + ","@h [] [] abp abs + +  + ","@h [] [] aby -  + ","@h [] [] abx -  + ","@h [] [] ab(send\n  (lvar :y) :-\n  (lvar :x)) /  + ","@h [] [] ab@h [] [] abs +  + ","@h [] [] abx abs +  + ","n -  - ","@h [] [] abs -@  * ","@h [] [] abMath  sqrt  * ","@h [] [] abp abs + +  * ","@h [] [] aby -  * ","@h [] [] abx -  * ","@h [] [] ab(send\n  (lvar :y) :-\n  (lvar :x)) /  * ","@h [] [] ab@h [] [] abs +  * ","@h [] [] abx abs +  * ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * +  abs + ","@e []  abs + ","@h [] [] - - -  abs + ","z /  abs + ","p * +  abs + ","q abs -@  + ","q abMath  sqrt  + ","q abp abs + +  + ","q aby -  + ","q abx -  + ","q ab(send\n  (lvar :y) :-\n  (lvar :x)) /  + ","q ab@h [] [] abs +  + ","q abx abs +  + ","n -  == ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :@h [] [] - )) / + ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :-0.4375 * * )) / + ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :@h [] [] * )) / + ","(send\n  (send\n    (n - var :r) :*\n    (n - var :s)) :-\n  (n - var :w)) / + ","(s -@ end\n  (s -@ end\n    (lvar :r) :*\n    (lvar :s -@ )) :-\n  (lvar :w)) / + ","(Math  sqrt end\n  (Math  sqrt end\n    (lvar :r) :*\n    (lvar :Math  sqrt )) :-\n  (lvar :w)) / + ","(p abs + + end\n  (p abs + + end\n    (lvar :r) :*\n    (lvar :p abs + + )) :-\n  (lvar :w)) / + ","(y - end\n  (y - end\n    (lvar :r) :*\n    (lvar :y - )) :-\n  (lvar :w)) / + ","(x - end\n  (x - end\n    (lvar :r) :*\n    (lvar :x - )) :-\n  (lvar :w)) / + ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (lvar :r) :*\n    (lvar :(send\n  (lvar :y) :-\n  (lvar :x)) / )) :-\n  (lvar :w)) / + ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (lvar :r) :*\n    (lvar :@h [] [] abs + )) :-\n  (lvar :w)) / + ","(x abs + end\n  (x abs + end\n    (lvar :r) :*\n    (lvar :x abs + )) :-\n  (lvar :w)) / + ","(send\n  (send\n    (lva@h [] []  :@h [] [] ) :*\n    (lva@h [] []  :s)) :-\n  (lva@h [] []  :w)) / + ","(send\n  (send\n    (lvax -  :x - ) :*\n    (lvax -  :s)) :-\n  (lvax -  :w)) / + ","(send\n  (send\n    (lvaMath  sqrt  :Math  sqrt ) :*\n    (lvaMath  sqrt  :s)) :-\n  (lvaMath  sqrt  :w)) / + ","(senn - d\n  (senn - d\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :@h [] [] - )) / ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :-0.4375 * * )) / ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :@h [] [] * )) / ","(send\n  (send\n    (n - var :r) :*\n    (n - var :s)) :-\n  (n - var :w)) / ","(s -@ end\n  (s -@ end\n    (lvar :r) :*\n    (lvar :s -@ )) :-\n  (lvar :w)) / ","(Math  sqrt end\n  (Math  sqrt end\n    (lvar :r) :*\n    (lvar :Math  sqrt )) :-\n  (lvar :w)) / ","(p abs + + end\n  (p abs + + end\n    (lvar :r) :*\n    (lvar :p abs + + )) :-\n  (lvar :w)) / ","(y - end\n  (y - end\n    (lvar :r) :*\n    (lvar :y - )) :-\n  (lvar :w)) / ","(x - end\n  (x - end\n    (lvar :r) :*\n    (lvar :x - )) :-\n  (lvar :w)) / ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    (lvar :r) :*\n    (lvar :(send\n  (lvar :y) :-\n  (lvar :x)) / )) :-\n  (lvar :w)) / ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (lvar :r) :*\n    (lvar :@h [] [] abs + )) :-\n  (lvar :w)) / ","(x abs + end\n  (x abs + end\n    (lvar :r) :*\n    (lvar :x abs + )) :-\n  (lvar :w)) / ","(send\n  (send\n    (lva@h [] []  :@h [] [] ) :*\n    (lva@h [] []  :s)) :-\n  (lva@h [] []  :w)) / ","(send\n  (send\n    (lvax -  :x - ) :*\n    (lvax -  :s)) :-\n  (lvax -  :w)) / ","(send\n  (send\n    (lvaMath  sqrt  :Math  sqrt ) :*\n    (lvaMath  sqrt  :s)) :-\n  (lvaMath  sqrt  :w)) / ","(senn - d\n  (senn - d\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / ","x -  * - ","Math  sqrt  * - ","@h [] []  - ","q /  - ","0.75 *  - ","p /  - ","p abs + +  - ","n -  >= ","i(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max er + ","i@h [] [] abs er + ","i(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / er + ","ite@h [] []  + ","itex -  + ","iteMath  sqrt  + ","iter +  + ","@h [] [] -  / ","-0.4375 * *  / ","@h [] [] *  / ","(send\n  (lvar :@h [] [] ) :-\n  (lvar :x)) / + ","(send\n  (lvar :q / ) :-\n  (lvar :x)) / + ","(send\n  (lvar :0.75 * ) :-\n  (lvar :x)) / + ","(send\n  (lvar :y) :-\n  (lvar :@h [] [] )) / + ","(send\n  (lvar :y) :-\n  (lvar :p / )) / + ","(send\n  (lvar :y) :-\n  (lvar :p abs + + )) / + ","(send\n  (n - var :y) :-\n  (n - var :x)) / + ","(s -@ end\n  (lvar :y) :-\n  (lvar :x)) / + ","(Math  sqrt end\n  (lvar :y) :-\n  (lvar :x)) / + ","(p abs + + end\n  (lvar :y) :-\n  (lvar :x)) / + ","(y - end\n  (lvar :y) :-\n  (lvar :x)) / + ","(x - end\n  (lvar :y) :-\n  (lvar :x)) / + ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  (lvar :y) :-\n  (lvar :x)) / + ","(@h [] [] abs + end\n  (lvar :y) :-\n  (lvar :x)) / + ","(x abs + end\n  (lvar :y) :-\n  (lvar :x)) / + ","(send\n  (lva@h [] []  :y) :-\n  (lva@h [] []  :x)) / + ","(send\n  (lvax -  :y) :-\n  (lvax -  :x)) / + ","(send\n  (lvaMath  sqrt  :y) :-\n  (lvaMath  sqrt  :x)) / + ","(senn - d\n  (lvar :y) :-\n  (lvar :x)) / + ","(send\n  (lvar :@h [] [] ) :-\n  (lvar :x)) / ","(send\n  (lvar :q / ) :-\n  (lvar :x)) / ","(send\n  (lvar :0.75 * ) :-\n  (lvar :x)) / ","(send\n  (lvar :y) :-\n  (lvar :@h [] [] )) / ","(send\n  (lvar :y) :-\n  (lvar :p / )) / ","(send\n  (lvar :y) :-\n  (lvar :p abs + + )) / ","(send\n  (n - var :y) :-\n  (n - var :x)) / ","(s -@ end\n  (lvar :y) :-\n  (lvar :x)) / ","(Math  sqrt end\n  (lvar :y) :-\n  (lvar :x)) / ","(p abs + + end\n  (lvar :y) :-\n  (lvar :x)) / ","(y - end\n  (lvar :y) :-\n  (lvar :x)) / ","(x - end\n  (lvar :y) :-\n  (lvar :x)) / ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  (lvar :y) :-\n  (lvar :x)) / ","(@h [] [] abs + end\n  (lvar :y) :-\n  (lvar :x)) / ","(x abs + end\n  (lvar :y) :-\n  (lvar :x)) / ","(send\n  (lva@h [] []  :y) :-\n  (lva@h [] []  :x)) / ","(send\n  (lvax -  :y) :-\n  (lvax -  :x)) / ","(send\n  (lvaMath  sqrt  :y) :-\n  (lvaMath  sqrt  :x)) / ","(senn - d\n  (lvar :y) :-\n  (lvar :x)) / ","q /  < ","0.75 *  < ","s -@  > ","Math  sqrt  > ","p abs + +  > ","y -  > ","x -  > ","(send\n  (lvar :y) :-\n  (lvar :x)) /  > ","@h [] [] abs +  > ","x abs +  > ","s -@  + ","Math  sqrt  + ","p abs + +  + ","y -  + ","x -  + ","(send\n  (lvar :y) :-\n  (lvar :x)) /  + ","@h [] [] abs +  + ","x abs +  + ","i(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max er == ","i@h [] [] abs er == ","i(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / er == ","ite@h [] []  == ","itex -  == ","iteMath  sqrt  == ","iter +  == ","n -  < ","r /  -@ ","@v [] []  -@ ","p -  -@ ","p +  -@ ","@h [] []  + ","p /  + ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * +  * - ","@e []  * - ","@h [] [] - - -  * - ","z /  * - ","p * +  * - ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * +  * + ","@e []  * + ","@h [] [] - - -  * + ","z /  * + ","p * +  * + ","(send\n  (lvar :n) :-\n  (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  1)) up(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","(send\n  (lvar :n) :-\n  (in@h [] [] abs  1)) up@h [] [] abs o ","(send\n  (lvar :n) :-\n  (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  1)) up(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","(send\n  (n - var :n) :-\n  (int 1)) upto ","(send\n  (lvar :n) :-\n  (int 1)) u@d [] to ","(send\n  (lvar :n) :-\n  (int 1)) ux * + to ","(send\n  (lvar :n) :-\n  (int 1)) u@h [] [] + to ","(send\n  (lvar :n) :-\n  (int 1)) u@h [] [] to ","(send\n  (lvar :n) :-\n  (int 1)) u(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + to ","(send\n  (lvar :n) :-\n  (int 1)) ux / to ","(send\n  (lvar :n) :-\n  (int 1)) u(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / to ","(s -@ end\n  (lvar :n) :-\n  (int 1)) upto ","(Math  sqrt end\n  (lvar :n) :-\n  (int 1)) upto ","(p abs + + end\n  (lvar :n) :-\n  (int 1)) upto ","(y - end\n  (lvar :n) :-\n  (int 1)) upto ","(x - end\n  (lvar :n) :-\n  (int 1)) upto ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  (lvar :n) :-\n  (int 1)) upto ","(@h [] [] abs + end\n  (lvar :n) :-\n  (int 1)) upto ","(x abs + end\n  (lvar :n) :-\n  (int 1)) upto ","(send\n  (lva@h [] []  :n) :-\n  (int 1)) upto ","(send\n  (lvax -  :n) :-\n  (int 1)) upto ","(send\n  (lvaMath  sqrt  :n) :-\n  (int 1)) upto ","(senn - d\n  (lvar :nn - ) :-\n  (inn - t 1)) upto ","r /  / ","@v [] []  / ","p -  / ","p +  / ","p /  / ","p abs + +  / ","p /  abs + ","p abs + +  abs + ","x abs -@  + ","x abMath  sqrt  + ","x abp abs + +  + ","x aby -  + ","x abx -  + ","x ab(send\n  (lvar :y) :-\n  (lvar :x)) /  + ","x ab@h [] [] abs +  + ","x abx abs +  + ","r /  != ","@v [] []  != ","p -  != ","p +  != ","@d []  - ","x * +  - ","@h [] [] +  - ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  - ","x /  - ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  - ","@d []  + ","x * +  + ","@h [] [] +  + ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  + ","x /  + ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  + ","@d []  >= ","x * +  >= ","@h [] [] +  >= ","@h [] []  >= ","(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / +  >= ","x /  >= ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) /  >= ","(send\n  (send\n    (ivar :@d) :[]\n    (lvar :i)) :-\n  (lvar :p)) * +  >= ","@e []  >= ","@h [] [] - - -  >= ","z /  >= ","p * +  >= ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  1))) :[]\n    (send\n      (lvar :n) :-\n      (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (in@h [] [] abs  1))) :[]\n    (send\n      (lvar :n) :-\n      (in@h [] [] abs  1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  1))) :[]\n    (send\n      (lvar :n) :-\n      (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (n - var :n) :-\n        (int 1))) :[]\n    (send\n      (n - var :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (n - var :n)) :[]\n    (n - var :n))) / ","(s -@ end\n  (s -@ end\n    (s -@ end\n      (ivar :@h) :[]\n      (s -@ end\n        (lvar :n) :-\n        (int 1))) :[]\n    (s -@ end\n      (lvar :n) :-\n      (int 1))) :-\n  (s -@ end\n    (s -@ end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","(Math  sqrt end\n  (Math  sqrt end\n    (Math  sqrt end\n      (ivar :@h) :[]\n      (Math  sqrt end\n        (lvar :n) :-\n        (int 1))) :[]\n    (Math  sqrt end\n      (lvar :n) :-\n      (int 1))) :-\n  (Math  sqrt end\n    (Math  sqrt end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","(p abs + + end\n  (p abs + + end\n    (p abs + + end\n      (ivar :@h) :[]\n      (p abs + + end\n        (lvar :n) :-\n        (int 1))) :[]\n    (p abs + + end\n      (lvar :n) :-\n      (int 1))) :-\n  (p abs + + end\n    (p abs + + end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","(y - end\n  (y - end\n    (y - end\n      (ivar :@h) :[]\n      (y - end\n        (lvar :n) :-\n        (int 1))) :[]\n    (y - end\n      (lvar :n) :-\n      (int 1))) :-\n  (y - end\n    (y - end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","(x - end\n  (x - end\n    (x - end\n      (ivar :@h) :[]\n      (x - end\n        (lvar :n) :-\n        (int 1))) :[]\n    (x - end\n      (lvar :n) :-\n      (int 1))) :-\n  (x - end\n    (x - end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (ivar :@h) :[]\n      ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n        (lvar :n) :-\n        (int 1))) :[]\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (lvar :n) :-\n      (int 1))) :-\n  ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","(@h [] [] abs + end\n  (@h [] [] abs + end\n    (@h [] [] abs + end\n      (ivar :@h) :[]\n      (@h [] [] abs + end\n        (lvar :n) :-\n        (int 1))) :[]\n    (@h [] [] abs + end\n      (lvar :n) :-\n      (int 1))) :-\n  (@h [] [] abs + end\n    (@h [] [] abs + end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","(x abs + end\n  (x abs + end\n    (x abs + end\n      (ivar :@h) :[]\n      (x abs + end\n        (lvar :n) :-\n        (int 1))) :[]\n    (x abs + end\n      (lvar :n) :-\n      (int 1))) :-\n  (x abs + end\n    (x abs + end\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / ","(send\n  (send\n    (send\n      (iva@h [] []  :@h) :[]\n      (send\n        (lva@h [] []  :n) :-\n        (int 1))) :[]\n    (send\n      (lva@h [] []  :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (iva@h [] []  :@h) :[]\n      (lva@h [] []  :n)) :[]\n    (lva@h [] []  :n))) / ","(send\n  (send\n    (send\n      (ivax -  :@h) :[]\n      (send\n        (lvax -  :n) :-\n        (int 1))) :[]\n    (send\n      (lvax -  :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivax -  :@h) :[]\n      (lvax -  :n)) :[]\n    (lvax -  :n))) / ","(send\n  (send\n    (send\n      (ivaMath  sqrt  :@h) :[]\n      (send\n        (lvaMath  sqrt  :n) :-\n        (int 1))) :[]\n    (send\n      (lvaMath  sqrt  :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivaMath  sqrt  :@h) :[]\n      (lvaMath  sqrt  :n)) :[]\n    (lvaMath  sqrt  :n))) / ","(senn - d\n  (senn - d\n    (senn - d\n      (ivar :@h) :[]\n      (senn - d\n        (lvar :nn - ) :-\n        (inn - t 1))) :[]\n    (senn - d\n      (lvar :nn - ) :-\n      (inn - t 1))) :-\n  (senn - d\n    (senn - d\n      (ivar :@h) :[]\n      (lvar :nn - )) :[]\n    (lvar :nn - ))) / ","@h [] [] abs -@  < ","@h [] [] abMath  sqrt  < ","@h [] [] abp abs + +  < ","@h [] [] aby -  < ","@h [] [] abx -  < ","@h [] [] ab(send\n  (lvar :y) :-\n  (lvar :x)) /  < ","@h [] [] ab@h [] [] abs +  < ","@h [] [] abx abs +  < ","s -@  == ","Math  sqrt  == ","y -  == ","x -  == ","(send\n  (lvar :y) :-\n  (lvar :x)) /  == ","@h [] [] abs +  == ","x abs +  == ","n -  > ","nn -  >= ","no@h [] [] m + ","nox - m + ","noMath  sqrt m + ","norn -  + ","norm +  + ","nn - orm + ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  1))\n    (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  0)) :max) up(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max o ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (in@h [] [] abs  1))\n    (in@h [] [] abs  0)) :max) up@h [] [] abs o ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  1))\n    (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  0)) :max) up(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) / o ","(send\n  (arra@h [] [] \n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(send\n  (arraq / \n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(send\n  (arra0.75 * \n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :ma@h [] [] ) upto ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :map / ) upto ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :map abs + + ) upto ","(send\n  (arra + y\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(send\n  (array\n    (send\n      (n - var :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) u@d [] to ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) ux * + to ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) u@h [] [] + to ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) u@h [] [] to ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) u(send\n  (send\n    (lvar :r) :*\n    (lvar :s)) :-\n  (lvar :w)) / + to ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) ux / to ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) u(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (send\n        (lvar :n) :-\n        (int 1))) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :-\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :n)) :[]\n    (lvar :n))) / to ","(s -@ end\n  (array\n    (s -@ end\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(Math  sqrt end\n  (array\n    (Math  sqrt end\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(p abs + + end\n  (array\n    (p abs + + end\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(y - end\n  (array\n    (y - end\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(x - end\n  (array\n    (x - end\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  (array\n    ((send\n  (lvar :y) :-\n  (lvar :x)) / end\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(@h [] [] abs + end\n  (array\n    (@h [] [] abs + end\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(x abs + end\n  (array\n    (x abs + end\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(send\n  (a@h [] [] @h [] [] ay\n    (send\n      (lva@h [] []  :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(send\n  (ax - x - ay\n    (send\n      (lvax -  :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(send\n  (aMath  sqrt Math  sqrt ay\n    (send\n      (lvaMath  sqrt  :i) :-\n      (int 1))\n    (int 0)) :max) upto ","(send\n  (array\n    (send\n      (lvar :i) :-\n      (int 1))\n    (int 0)) :n - ax) upto ","(senn - d\n  (array\n    (senn - d\n      (lvar :i) :-\n      (inn - t 1))\n    (inn - t 0)) :max) upto ","(send\n  (lvar :i) :-\n  (in(send\n  (send\n    (send\n      (ivar :@h) :[]\n      (lvar :i)) :[]\n    (send\n      (lvar :n) :-\n      (int 1))) :abs) max  1)) max ","(send\n  (lvar :i) :-\n  (in@h [] [] abs  1)) max ","(send\n  (lvar :i) :-\n  (in(send\n  (send\n    (lvar :x) :*\n    (lvar :s)) :-\n  (send\n    (lvar :z) :*\n    (lvar :r))) /  1)) max ","(send\n  (lvar :i) :-\n  (int 1)) ma@h [] []  ","(send\n  (lvar :i) :-\n  (int 1)) map /  ","(send\n  (lvar :i) :-\n  (int 1)) map abs + +  ","(send\n  (n - var :i) :-\n  (int 1)) max ","(s -@ end\n  (lvar :i) :-\n  (int 1)) max ","(Math  sqrt end\n  (lvar :i) :-\n  (int 1)) max ","(p abs + + end\n  (lvar :i) :-\n  (int 1)) max ","(y - end\n  (lvar :i) :-\n  (int 1)) max ","(x - end\n  (lvar :i) :-\n  (int 1)) max ","((send\n  (lvar :y) :-\n  (lvar :x)) / end\n  (lvar :i) :-\n  (int 1)) max ","(@h [] [] abs + end\n  (lvar :i) :-\n  (int 1)) max ","(x abs + end\n  (lvar :i) :-\n  (int 1)) max ","(send\n  (lva@h [] []  :i) :-\n  (int 1)) max ","(send\n  (lvax -  :i) :-\n  (int 1)) max ","(send\n  (lvaMath  sqrt  :i) :-\n  (int 1)) max ","(send\n  (lvar :i) :-\n  (int 1)) n - ax ","(senn - d\n  (lvar :i) :-\n  (inn - t 1)) max "]}," Matrix EigenvalueDecomposition reduce_to_hessenberg":{"type":"method","name":"reduce_to_hessenberg","children":[],"call":["g * ","@ort [] ","@v [] [] ","@v [] ","m upto ","(send\n  (lvar :g) :/\n  (send\n    (ivar :@ort) :[]\n    (lvar :m))) / ","@h [] [] ","m - ","@h [] ","g / ","@ort [] * ","@ort []= ","(send\n  (lvar :m) :+\n  (int 1)) upto ","m + ","@h [] [] != ","(send\n  (lvar :high) :-\n  (int 1)) downto ","low + ","high - ","@v [] []= ","i == ","@size times ","@h [] []= ","scale * ","f * ","f / ","high downto ","0 upto ","@size - ","@ort [] - ","g -@ ","@ort [] > ","Math  sqrt ","@h [] [] / ","scale != ","scale + ","@h [] [] abs ","(send\n  (lvar :low) :+\n  (int 1)) upto ","(send\n  (lvar :g) :/\n  (send\n    (ivar :@ort) :[]\n    (lvar :m))) /  * ","g -@  * ","Math  sqrt  * ","(send\n  (lvar :(send\n  (lvar :g) :/\n  (send\n    (ivar :@ort) :[]\n    (lvar :m))) / ) :/\n  (send\n    (ivar :@ort) :[]\n    (lvar :m))) / ","(send\n  (lvar :g -@ ) :/\n  (send\n    (ivar :@ort) :[]\n    (lvar :m))) / ","(send\n  (lvar :Math  sqrt ) :/\n  (send\n    (ivar :@ort) :[]\n    (lvar :m))) / ","(send\n  (lvar :g) :/\n  (send\n    (ivar :@ort) :[]\n    (lvar :m))) /  / ","g -@  / ","Math  sqrt  / ","(send\n  (lvar :hi(send\n  (lvar :g) :/\n  (send\n    (ivar :@ort) :[]\n    (lvar :m))) / h) :-\n  (int 1)) downto ","(send\n  (lvar :hig -@ h) :-\n  (int 1)) downto ","(send\n  (lvar :hiMath  sqrt h) :-\n  (int 1)) downto ","(send\n  (lvar :@size - ) :-\n  (int 1)) downto ","hi(send\n  (lvar :g) :/\n  (send\n    (ivar :@ort) :[]\n    (lvar :m))) / h - ","hig -@ h - ","hiMath  sqrt h - ","@size -  - ","scale +  * ","f /  * ","f /  / ","hi(send\n  (lvar :g) :/\n  (send\n    (ivar :@ort) :[]\n    (lvar :m))) / h downto ","hig -@ h downto ","hiMath  sqrt h downto ","@size -  downto ","(send\n  (lvar :g) :/\n  (send\n    (ivar :@ort) :[]\n    (lvar :m))) /  -@ ","g -@  -@ ","Math  sqrt  -@ ","scale +  != ","scale +  + "]}," Matrix EigenvalueDecomposition diagonalize":{"type":"method","name":"diagonalize","children":[],"call":["@v [] []= ","@v [] ","@v [] [] ","@size times ","@d []= ","@d [] ","k != ","@d [] < ","(send\n  (lvar :i) :+\n  (int 1)) upto ","@size - ","i + ","0 upto ","@e []= ","@d [] + ","c * ","s * ","s -@ * * * * / ","s -@ * * * * ","@e [] ","s -@ * * * ","s -@ * * ","s -@ * ","s -@ ","c * - ","s * + ","h + ","c * + ","p / ","@e [] / ","Math  hypot ","(send\n  (lvar :m) :-\n  (int 1)) downto ","m - ","l + ","(send\n  (lvar :l) :+\n  (int 2)) upto ","g - ","@e [] * ","p + ","r -@ ","p < ","(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :g)) / ","2.0 * ","@d [] - ","iter + ","@e [] abs > ","eps * ","@e [] abs ","m > ","@e [] abs <= ","m < ","(lvar :tst1) max ","@d [] abs + ","@d [] abs ","i - ","1 upto ","@@e [] / ize time@e [] /  ","(send\n  (lvar :i) :+\n  (int 1)) u@v [] [] to ","(send\n  (lvar :i) :+\n  (int 1)) u@d [] to ","(send\n  (lvar :i) :+\n  (int 1)) us -@ * * * * / to ","(send\n  (lvar :i) :+\n  (int 1)) uc * - to ","(send\n  (lvar :i) :+\n  (int 1)) u(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :g)) / to ","(@e [] / end\n  (lvar :i) :+\n  (int 1)) upto ","(send\n  (lvaMath  hypot  :i) :+\n  (int 1)) upto ","(send\n  (lvar -@  :i) :+\n  (int 1)) upto ","@@e [] / ize - ","0 u@v [] [] to ","0 u@d [] to ","0 us -@ * * * * / to ","0 uc * - to ","0 u(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :g)) / to ","p /  * ","@e [] /  * ","@e [] /  -@ * * * * / ","@e [] /  -@ * * * * ","@e [] /  -@ * * * ","@e [] /  -@ * * ","@e [] /  -@ * ","@e [] /  -@ ","p /  * - ","@e [] /  * + ","@v [] []  + ","c *  + ","g -  + ","p /  * + ","@v [] []  / ","@d []  / ","s -@ * * * * /  / ","c * -  / ","(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :g)) /  / ","Math  hy@v [] [] ot ","Math  hy@d [] ot ","Math  hys -@ * * * * / ot ","Math  hyc * - ot ","Math  hy(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :g)) / ot ","Mat@v [] []   @v [] [] ypot ","Matc *   c * ypot ","Matg -   g - ypot ","(@e [] / end\n  (lvar :m) :-\n  (int 1)) downto ","(send\n  (lvaMath  hypot  :m) :-\n  (int 1)) downto ","(send\n  (lvar -@  :m) :-\n  (int 1)) downto ","(send\n  (lvar :l) :+\n  (int 2)) u@v [] [] to ","(send\n  (lvar :l) :+\n  (int 2)) u@d [] to ","(send\n  (lvar :l) :+\n  (int 2)) us -@ * * * * / to ","(send\n  (lvar :l) :+\n  (int 2)) uc * - to ","(send\n  (lvar :l) :+\n  (int 2)) u(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :g)) / to ","(@e [] / end\n  (lvar :l) :+\n  (int 2)) upto ","(send\n  (lvaMath  hypot  :l) :+\n  (int 2)) upto ","(send\n  (lvar -@  :l) :+\n  (int 2)) upto ","c *  - ","@d []  - ","@d []  + ","s -@ * * * * /  + ","c * -  + ","(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :g)) /  + ","Math  hypot  -@ ","r -@  -@ ","@v [] []  < ","@d []  < ","s -@ * * * * /  < ","c * -  < ","(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :g)) /  < ","(@e [] / end\n  (@e [] / end\n    (ivar :@d) :[]\n    (@e [] / end\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :g)) / ","(send\n  (send\n    (ivaMath  hypot  :@d) :[]\n    (send\n      (lvaMath  hypot  :l) :+\n      (int 1))) :-\n  (lvaMath  hypot  :g)) / ","(send\n  (send\n    (ivar -@  :@d) :[]\n    (send\n      (lvar -@  :l) :+\n      (int 1))) :-\n  (lvar -@  :g)) / ","(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :c * )) / ","(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :@d [] )) / ","iteMath  hypot  + ","iter -@  + ","iter +  + ","@e [] ab@e [] /  > ","e@v [] [] s * ","e@d [] s * ","es -@ * * * * / s * ","ec * - s * ","e(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :g)) / s * ","ep@e [] /  * ","@e [] ab@e [] /  ","@e [] ab@e [] /  <= ","(lvar :t@e [] / t1) max ","(lvaMath  hypot  :tst1) max ","(lvar -@  :tst1) max ","(lvar :(lvar :tst1) max ) max ","@d [] ab@e [] /  + ","@d [] ab@e [] /  ","1 u@v [] [] to ","1 u@d [] to ","1 us -@ * * * * / to ","1 uc * - to ","1 u(send\n  (send\n    (ivar :@d) :[]\n    (send\n      (lvar :l) :+\n      (int 1))) :-\n  (lvar :g)) / to "]}," Matrix EigenvalueDecomposition tridiagonalize":{"type":"method","name":"tridiagonalize","children":[],"call":["@e []= ","@v [] []= ","@size - ","@v [] ","@d []= ","@v [] [] ","@size times ","i + ","0 upto ","g * ","@d [] ","@v [] [] * ","@v [] [] / ","h != ","@size - - ","i - ","f * + ","f * ","@e [] ","j upto ","i times ","hh * ","f / ","h + ","@e [] * ","(send\n  (lvar :j) :+\n  (int 1)) upto ","j + ","@e [] + ","f - ","scale * ","g -@ ","f > ","Math  sqrt ","@d [] * ","scale == ","scale + ","@d [] abs ","(send\n  (ivar :@size) :-\n  (int 1)) downto ","0 + ","@e []  * ","@e [] +  * ","g -@  * ","Math  sqrt  * ","@d []  != ","@d []  * + ","@d []  * ","@d [] @d []  * ","f /  * ","@d []  / ","@d []  + ","@d []  - ","scale +  * ","@e []  -@ ","@e [] +  -@ ","g -@  -@ ","Math  sqrt  -@ ","@d []  > ","Mat@d []   sqrt ","scale +  == ","scale +  + "]}," Matrix EigenvalueDecomposition cdiv":{"type":"method","name":"cdiv","children":[],"call":["(send\n  (send\n    (lvar :r) :*\n    (lvar :xi)) :-\n  (lvar :xr)) / ","r * - ","r * ","(send\n  (send\n    (lvar :r) :*\n    (lvar :xr)) :+\n  (lvar :xi)) / ","r * + ","yi + ","yr / ","(send\n  (lvar :xi) :-\n  (send\n    (lvar :r) :*\n    (lvar :xr))) / ","xi - ","(send\n  (lvar :xr) :+\n  (send\n    (lvar :r) :*\n    (lvar :xi))) / ","xr + ","yr + ","yi / ","yr abs > ","yi abs ","yr abs ","(senyi + \n  (senyi + \n    (lvar :r) :*\n    (lvar :xi)) :-\n  (lvar :xr)) / ","(senyr + \n  (senyr + \n    (lvar :r) :*\n    (lvar :xi)) :-\n  (lvar :xr)) / ","(send\n  (send\n    (lvayr /  :yr / ) :*\n    (lvayr /  :xi)) :-\n  (lvayr /  :xyr / )) / ","(send\n  (send\n    (lvayi /  :yi / ) :*\n    (lvayi /  :xi)) :-\n  (lvayi /  :xyi / )) / ","yr /  * - ","yi /  * - ","yr /  * ","yi /  * ","(senyi + \n  (senyi + \n    (lvar :r) :*\n    (lvar :xr)) :+\n  (lvar :xi)) / ","(senyr + \n  (senyr + \n    (lvar :r) :*\n    (lvar :xr)) :+\n  (lvar :xi)) / ","(send\n  (send\n    (lvayr /  :yr / ) :*\n    (lvayr /  :xyr / )) :+\n  (lvayr /  :xi)) / ","(send\n  (send\n    (lvayi /  :yi / ) :*\n    (lvayi /  :xyi / )) :+\n  (lvayi /  :xi)) / ","yr /  * + ","yi /  * + ","yyr /  / ","yyi /  / ","(senyi + \n  (lvar :xi) :-\n  (senyi + \n    (lvar :r) :*\n    (lvar :xr))) / ","(senyr + \n  (lvar :xi) :-\n  (senyr + \n    (lvar :r) :*\n    (lvar :xr))) / ","(send\n  (lvayr /  :xi) :-\n  (send\n    (lvayr /  :yr / ) :*\n    (lvayr /  :xyr / ))) / ","(send\n  (lvayi /  :xi) :-\n  (send\n    (lvayi /  :yi / ) :*\n    (lvayi /  :xyi / ))) / ","(senyi + \n  (lvar :xr) :+\n  (senyi + \n    (lvar :r) :*\n    (lvar :xi))) / ","(senyr + \n  (lvar :xr) :+\n  (senyr + \n    (lvar :r) :*\n    (lvar :xi))) / ","(send\n  (lvayr /  :xyr / ) :+\n  (send\n    (lvayr /  :yr / ) :*\n    (lvayr /  :xi))) / ","(send\n  (lvayi /  :xyi / ) :+\n  (send\n    (lvayi /  :yi / ) :*\n    (lvayi /  :xi))) / ","xyr /  + ","xyi /  + ","yyr /  + ","yyi /  + ","yyr /  abs > ","yyi /  abs > ","yyr /  abs ","yyi /  abs "]}," Matrix EigenvalueDecomposition build_eigenvectors":{"type":"method","name":"build_eigenvectors","children":[],"call":[" Complex ","@v [] [] -@ ","@v [] [] ","i - ","@v [] ","Array  new ","i + ","imag > ","imag == ","@e each_with_index map ","@e each_with_index "]}," Matrix EigenvalueDecomposition to_ary":{"type":"method","name":"to_ary","children":[],"call":[" v_inv "," d "," v "]}," Matrix EigenvalueDecomposition eigenvalue_matrix":{"type":"method","name":"eigenvalue_matrix","children":[],"call":["Matrix  diagonal "," eigenvalues "]}," Matrix EigenvalueDecomposition eigenvectors":{"type":"method","name":"eigenvectors","children":[],"call":["Vector  send "," build_eigenvectors map "," build_eigenvectors "]}," Matrix EigenvalueDecomposition eigenvalues":{"type":"method","name":"eigenvalues","children":[],"call":["values []= "," Complex ","values [] ","imag == ","@e each_with_index ","@d dup ","@d dup  []= ","@d dup  [] "]}," Matrix EigenvalueDecomposition eigenvector_matrix_inv":{"type":"method","name":"eigenvector_matrix_inv","children":[],"call":["r transpose inverse ","r transpose ","Matrix  send "," build_eigenvectors ","r transpose inverse  tr transpose inverse anspose inver transpose inverse se ","Matrix  send  tMatrix  send anspose inveMatrix  send se ","r transpose inverse  tr transpose inverse anspose ","Matrix  send  tMatrix  send anspose ","Matr transpose inverse ix  send ","MatMatrix  send ix  send "," build_eigenvector transpose inverse s "," build_eigenvectoMatrix  send s "]}," Matrix EigenvalueDecomposition eigenvector_matrix":{"type":"method","name":"eigenvector_matrix","children":[],"call":["Matrix  send "," build_eigenvectors transpose "," build_eigenvectors "]}," Matrix EigenvalueDecomposition initialize":{"type":"method","name":"initialize","children":[],"call":[" hessenberg_to_real_schur "," reduce_to_hessenberg ","Array  new ","a to_a "," diagonalize "," tridiagonalize ","a symmetric? ","a row_size "," raise ","a class ","a is_a? "]}," Complex to_r":{"type":"method","name":"to_r","children":[],"call":[" real to_r "," real "," raise "," imag eql? "," imag "]}," Prime OldCompatibility each":{"type":"method","name":"each","children":[],"call":[" succ "," loop ","@generator dup "," block_given? "]}," Prime OldCompatibility succ":{"type":"method","name":"succ","children":[],"call":["@generator succ "]}," Prime EratosthenesSieve extend_table":{"type":"method","name":"extend_table","children":[],"call":["@tables << ","new_table freeze ","FILLED_ENTRY  ^ ","1 << ","new_table [] "," indices ","(erange\n  (lvar :start)\n  (lvar :ubound)) step ","2 * ","start even? ","(send\n  (send\n    (lvar :lbound) :div\n    (lvar :p)) :+\n  (int 1)) * ","lbound div + ","lbound div ","@tables [] [] [] zero? ","@tables [] [] [] ","@tables [] [] ","@tables [] ","(irange\n  (int 3)\n  (send nil :Integer\n    (send\n      (const nil :Math) :sqrt\n      (lvar :ubound)))) step "," Integer ","Math  sqrt ","(const nil :FILLED_ENTRY) * ","lbound + ","NUMS_PER_TABLE  * ","@tables length ","(const nil :FILLED_ENTRY) *  freeze ","(const nil :FILLED_ENTRY) *  [] ","(erange\n  (lvar :(send\n  (send\n    (lvar :lbound) :div\n    (lvar :p)) :+\n  (int 1)) * )\n  (lvar :ubound)) step ","(erange\n  (lvar :start)\n  (lvar :lbound + )) step ","(send\n  (send\n    (lvar :lbound) :div\n    (lvar :p)) :+\n  (int 1)) *  even? ","(send\n  (send\n    (lvar :NUMS_PER_TABLE  * ) :div\n    (lvar :p)) :+\n  (int 1)) * ","NUMS_PER_TABLE  *  div + ","NUMS_PER_TABLE  *  div ","(irange\n  (int 3)\n  (send nil :Integer\n    (send\n      (const nil :Math) :sqrt\n      (lvar :lbound + )))) step ","NUMS_PER_TABLE  *  + "]}," Prime EratosthenesSieve indices":{"type":"method","name":"indices","children":[],"call":["n >> ","(send\n  (lvar :n) :&\n  (int 224)) >> ","n & ","(send\n  (lvar :n) :&\n  (int 31)) >> ","(send\n  (lvar :n) :&\n  (n >> nt 224)) >> ","(send\n  (lvar :n) :&\n  (n >> nt 31)) >> "]}," Prime EratosthenesSieve next_to":{"type":"method","name":"next_to","children":[],"call":["NUMS_PER_TABLE  * + + + ","NUMS_PER_TABLE  * + + ","2 * ","NUMS_PER_TABLE  * + ","NUMS_PER_ENTRY  * ","NUMS_PER_TABLE  * ","@tables [] [] [] zero? ! ","@tables [] [] [] zero? ","@tables [] [] [] ","@tables [] [] ","@tables [] ","@tables [] [] zero? ! ","@tables [] [] zero? "," extend_table ","@tables length > ","@tables length "," loop "," indices ","(send\n  (lvar :n) :-\n  (int 1)) div * + ","(send\n  (lvar :n) :-\n  (int 1)) div * ","(send\n  (lvar :n) :-\n  (int 1)) div ","n - "," exte(send\n  (lvar :n) :-\n  (int 1)) div * + d_table ","@tables le(send\n  (lvar :n) :-\n  (int 1)) div * + gth > ","@tables le(send\n  (lvar :n) :-\n  (int 1)) div * + gth "," i(send\n  (lvar :n) :-\n  (int 1)) div * + dices ","(se(send\n  (lvar :n) :-\n  (int 1)) div * + d\n  (lvar :(send\n  (lvar :n) :-\n  (int 1)) div * + ) :-\n  (i(send\n  (lvar :n) :-\n  (int 1)) div * + t 1)) div * + ","(se(send\n  (lvar :n) :-\n  (int 1)) div * + d\n  (lvar :(send\n  (lvar :n) :-\n  (int 1)) div * + ) :-\n  (i(send\n  (lvar :n) :-\n  (int 1)) div * + t 1)) div * ","(se(send\n  (lvar :n) :-\n  (int 1)) div * + d\n  (lvar :(send\n  (lvar :n) :-\n  (int 1)) div * + ) :-\n  (i(send\n  (lvar :n) :-\n  (int 1)) div * + t 1)) div ","(send\n  (lvar :n) :-\n  (int 1)) div * +  - "]}," Prime EratosthenesSieve initialize":{"type":"method","name":"initialize","children":[],"call":["(int 52078) freeze ","@primes last + ","@primes last "]}," Prime TrialDivision []":{"type":"method","name":"[]","children":[],"call":["@primes [] ","@primes push ","(send\n  (send\n    (ivar :@primes) :[]\n    (irange\n      (int 2)\n      (ivar :@ulticheck_index))) :find) nil? ","@next_to_check % == ","@next_to_check % ","@primes [] find ","@primes at ** ","@primes at ","@ulticheck_index + ","@next_to_check + > ","@next_to_check + ","index >= ","@primes length "]}," Prime TrialDivision cache":{"type":"method","name":"cache","children":[],"call":[]}," Prime TrialDivision initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Prime Generator23 rewind":{"type":"method","name":"rewind","children":[],"call":[" initialize "]}," Prime Generator23 succ":{"type":"method","name":"succ","children":[],"call":["6 - "," loop "]}," Prime Generator23 initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Prime TrialDivisionGenerator rewind":{"type":"method","name":"rewind","children":[],"call":[" initialize "]}," Prime TrialDivisionGenerator succ":{"type":"method","name":"succ","children":[],"call":["TrialDivision  instance [] ","TrialDivision  instance "]}," Prime TrialDivisionGenerator initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Prime EratosthenesGenerator rewind":{"type":"method","name":"rewind","children":[],"call":[" initialize "]}," Prime EratosthenesGenerator succ":{"type":"method","name":"succ","children":[],"call":["EratosthenesSieve  instance next_to ","EratosthenesSieve  instance ","EratosthenesSieve  instance get_nth_prime "]}," Prime EratosthenesGenerator initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Prime PseudoPrimeGenerator with_object":{"type":"method","name":"with_object","children":[],"call":[" each "," enum_for "," block_given? "]}," Prime PseudoPrimeGenerator each":{"type":"method","name":"each","children":[],"call":["block call "," succ "," loop ","prime > "," dup "," block_given? "," succ  > "]}," Prime PseudoPrimeGenerator rewind":{"type":"method","name":"rewind","children":[],"call":[" raise "]}," Prime PseudoPrimeGenerator next":{"type":"method","name":"next","children":[],"call":[" raise "]}," Prime PseudoPrimeGenerator succ":{"type":"method","name":"succ","children":[],"call":[" raise "]}," Prime PseudoPrimeGenerator upper_bound":{"type":"method","name":"upper_bound","children":[],"call":[]}," Prime PseudoPrimeGenerator upper_bound=":{"type":"method","name":"upper_bound=","children":[],"call":[]}," Prime PseudoPrimeGenerator initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Prime prime_division":{"type":"method","name":"prime_division","children":[],"call":["pv push ","value > ","value1 <= ","count != ","(masgn\n  (mlhs\n    (lvasgn :value1)\n    (lvasgn :mod))\n  (send\n    (lvar :value) :divmod\n    (lvar :prime))) == ","value divmod ","value -@ ","value < "," raise ","value == ","generator each ","value -@  > ","value -@ 1 <= ","(masgn\n  (mlhs\n    (lvasgn :value -@ 1)\n    (lvasgn :mod))\n  (send\n    (lvar :value -@ ) :divmod\n    (lvar :prime))) == ","value -@  divmod ","value -@  -@ ","value -@  < ","value -@  == "]}," Prime int_from_prime_division":{"type":"method","name":"int_from_prime_division","children":[],"call":["prime ** ","pd inject ","value * "]}," Prime prime?":{"type":"method","name":"prime?","children":[],"call":["r == ","q < ","value divmod ","value < ","value -@ ","generator each "," raise ","value integer? ","value respond_to? ","generator respond_to? ","value -@  divmod ","value -@  < ","value -@  -@ ","value -@  integer? ","value -@  respond_to? "]}," Prime each":{"type":"method","name":"each","children":[],"call":["generator each ","generator upper_bound= "]}," Prime method_added":{"type":"method","name":"method_added","children":[],"call":["(sclass\n  (self)\n  (self)) def_delegator "]}," Prime instance":{"type":"method","name":"instance","children":[],"call":[]}," Prime initialize":{"type":"method","name":"initialize","children":[],"call":[" warn "," extend ","EratosthenesGenerator  new "]}," Integer each_prime":{"type":"method","name":"each_prime","children":[],"call":[]}," Integer prime?":{"type":"method","name":"prime?","children":[],"call":["Prime  prime? "," % == "," % ","i + ","(irange\n  (int 5)\n  (send\n    (begin\n      (send\n        (self) :**\n        (float 0.5))) :floor)) step each ","(irange\n  (int 5)\n  (send\n    (begin\n      (send\n        (self) :**\n        (float 0.5))) :floor)) step ","(send\n  (self) :**\n  (float 0.5)) floor "," ** "," >= "," <= "]}," Integer prime_division":{"type":"method","name":"prime_division","children":[],"call":["Prime  prime_division "]}," Integer from_prime_division":{"type":"method","name":"from_prime_division","children":[],"call":[]}," Numeric round_with_digits":{"type":"method","name":"round_with_digits","children":[],"call":[" Float round "," Float "," round_without_digits ","ndigits zero? ","Backports  coerce_to_int ","Backports  coerce_to_int  zero? "]}," IO open_with_options_hash":{"type":"method","name":"open_with_options_hash","children":[],"call":[" open_without_options_hash "," block_given? ","Backports  combine_mode_and_option ","args << ","args [] is_a? ","args [] ","args size > ","args size ","Backports  combine_Backports  combine_mode_and_option _and_option "]}," Integer round_with_digits":{"type":"method","name":"round_with_digits","children":[],"call":[" - ","remain send ","pow / "," < "," % ","10 ** ","ndigits -@ "," Float ","ndigits > ","ndigits zero? ","Backports  coerce_to_int ","pow is_a? "," raise ","ndigits >= ","1 << "," %  send ","10 **  / ","Backports  coerce_to_int  -@ ","Backports  coerce_to_int  > ","Backports  coerce_to_int  zero? ","10 **  is_a? ","Backports  coerce_to_int  >= "]}," Hash rassoc":{"type":"method","name":"rassoc","children":[],"call":[" fetch ","v == "," key ","  key ey "]}," Hash assoc":{"type":"method","name":"assoc","children":[],"call":["k == "," find "," fetch "]}," Float round_with_digits":{"type":"method","name":"round_with_digits","children":[],"call":["prod round fdiv ","prod round ","prod infinite? "," * ","10 ** ","(send\n  (self) :/\n  (lvar :p)) round * ","(send\n  (self) :/\n  (lvar :p)) round "," / ","p > "," abs ","ndigits -@ ","ndigits < "," round_without_digits ","ndigits zero? ","Backports  coerce_to_int ","prod round to_f / ","prod round to_f ","prod nan? ","ndigits == "," *  round fdiv ","10 ** rod round fdiv "," *  round ","10 ** rod round "," *  infinite? ","10 ** rod infinite? ","(send\n  (self) :/\n  (lvar :10 ** )) round * ","(send\n  (self) :/\n  (lvar :10 ** )) round ","10 **  > ","Backports  coerce_to_int  -@ ","Backports  coerce_to_int  < ","Backports  coerce_to_int  zero? ","Back10 ** orts  coerce_to_int "," *  round to_f / ","10 ** rod round to_f / "," *  round to_f ","10 ** rod round to_f "," *  nan? ","10 ** rod nan? ","Backports  coerce_to_int  == "]}," File open_with_options_hash":{"type":"method","name":"open_with_options_hash","children":[],"call":[" open_without_options_hash "," block_given? ","Backports  combine_mode_perm_and_option "]}," Backports coerce_to_str":{"type":"method","name":"coerce_to_str","children":[],"call":[]}," String prepend":{"type":"method","name":"prepend","children":[],"call":[" replace ","Backports  coerce_to_str + ","Backports  coerce_to_str "]}," String byteslice":{"type":"method","name":"byteslice","children":[],"call":["str force_encoding "," encoding "," dup replace "," dup "," instance_of? "," unpack first "," unpack ","len < ","start > "," bytesize ","start < ","Backports  coerce_to_int ","start >= ","last - ","range exclude_end? ","last < ","range end ","range begin ","start is_a? ","Backports Undefined  == "," respond_to? "," dup replace  force_encoding "," unpack first  force_encoding ","Backports  coerce_to_int  < ","last -  < ","Backports  coerce_to_int  > ","Backports  coerce_to_int  >= ","Backports  coerce_to_int  - ","Backports  coerce_to_int  is_a? "]}," IO advise":{"type":"method","name":"advise","children":[],"call":[" raise "," closed? ","Backports  coerce_to_int >= ","1 << ","Backports  coerce_to_int "]}," Backports is_array?":{"type":"method","name":"is_array?","children":[],"call":[]}," Enumerator Lazy zip":{"type":"method","name":"zip","children":[],"call":["yielder << ","others unshift ","arg next ","enums map ","values first ","values size > ","values size ","args map ","yielder backports_memo ","Lazy  new ","data [] ","(send\n  (lvar :arys) :map) unshift ","ary [] ","arys map ","arys all? ","Backports  is_array? "," block_given? ","(send\n  (lvar :arys) :all?) __set_inspect "," raise ","a class ","a respond_to? ","args each ","values first  first ","values first  size > ","values first  size "]}," Enumerator Lazy cycle":{"type":"method","name":"cycle","children":[],"call":["Lazy  new ","@@cycler new "," block_given? "]}," Enumerator Lazy flat_map":{"type":"method","name":"flat_map","children":[],"call":["yielder << ","ary each ","result respond_to? ","Backports  is_array? ","Lazy  new "," raise "," block_given? ","(or\n  (lvar :ary)\n  (lvar :result)) each ","(send\n  (const nil :Lazy) :new\n  (self)) __set_inspect ","Backports  is_array?  each ","(or\n  (lvar :Backports  is_array? )\n  (lvar :result)) each "]}," Enumerator Lazy take_while":{"type":"method","name":"take_while","children":[],"call":["yielder yield "," throw ","Lazy  new "," raise "," block_given? ","(send\n  (const nil :Lazy) :new\n  (self)) __set_inspect "]}," Enumerator Lazy take":{"type":"method","name":"take","children":[],"call":[" throw ","(op-asgn\n  (send\n    (lvar :data) :[]\n    (sym :remain)) :-\n  (int 1)) == ","data [] ","yielder yield ","yielder backports_memo ","Lazy  new ","n == "," raise ","n < ","Backports  coerce_to_int ","(send\n  (const nil :Lazy) :new\n  (if\n    (send\n      (lvar :n) :==\n      (int 0))\n    (array)\n    (self))) __set_inspect ","(op-asgBackports  coerce_to_int \n  (seBackports  coerce_to_int d\n    (lvar :data) :[]\n    (sym :remaiBackports  coerce_to_int )) :-\n  (iBackports  coerce_to_int t 1)) == ","Lazy  Backports  coerce_to_int ew ","Backports  coerce_to_int  == ","Backports  coerce_to_int  < ","Backports  coerce_to_iBackports  coerce_to_int t ","(seBackports  coerce_to_int d\n  (coBackports  coerce_to_int st Backports  coerce_to_int il :Lazy) :Backports  coerce_to_int ew\n  (if\n    (seBackports  coerce_to_int d\n      (lvar :Backports  coerce_to_int ) :==\n      (iBackports  coerce_to_int t 0))\n    (array)\n    (self))) __set_iBackports  coerce_to_int spect "]}," Enumerator Lazy drop_while":{"type":"method","name":"drop_while","children":[],"call":["yielder yield ","data [] ","yielder backports_memo ","Lazy  new "," raise "," block_given? ","(send\n  (const nil :Lazy) :new\n  (self)) __set_inspect "]}," Enumerator Lazy drop":{"type":"method","name":"drop","children":[],"call":["yielder yield ","data [] ","data [] > ","yielder backports_memo ","Lazy  new ","Backports  coerce_to_int ","(send\n  (const nil :Lazy) :new\n  (self)) __set_inspect ","Lazy  Backports  coerce_to_int ew ","Backports  coerce_to_iBackports  coerce_to_int t ","(seBackports  coerce_to_int d\n  (coBackports  coerce_to_int st Backports  coerce_to_int il :Lazy) :Backports  coerce_to_int ew\n  (self)) __set_iBackports  coerce_to_int spect "]}," Enumerator Lazy grep":{"type":"method","name":"grep","children":[],"call":["yielder yield ","pattern === ","values first ","values size > ","values size ","Lazy  new "," block_given? ","(send nil :block_given?) __set_inspect ","values first  first ","values first  size > ","values first  size "]}," Enumerator Lazy reject":{"type":"method","name":"reject","children":[],"call":["yielder yield ","values first ","values size > ","values size ","Lazy  new "," raise "," block_given? ","(send\n  (const nil :Lazy) :new\n  (self)) __set_inspect ","values first  first ","values first  size > ","values first  size "]}," Enumerator Lazy select":{"type":"method","name":"select","children":[],"call":["yielder yield ","values first ","values size > ","values size ","Lazy  new "," raise "," block_given? ","(send\n  (const nil :Lazy) :new\n  (self)) __set_inspect ","values first  first ","values first  size > ","values first  size "]}," Enumerator Lazy map":{"type":"method","name":"map","children":[],"call":["yielder << ","Lazy  new "," raise "," block_given? ","(send\n  (const nil :Lazy) :new\n  (self)) __set_inspect "]}," Enumerator Lazy lazy":{"type":"method","name":"lazy","children":[],"call":[]}," Enumerator Lazy initialize":{"type":"method","name":"initialize","children":[],"call":["obj each "," catch "," raise "," block_given? ","obj n ","obj object ","obj is_a? "," caller [] [] "," caller [] "," caller ","obj args ","obj method "]}," Enumerable lazy":{"type":"method","name":"lazy","children":[],"call":["yielder << ","Enumerator Lazy  new ","klass new ","Enumerator Lazy  send ","Enumerator Lazy  send  new "]}," Range bsearch":{"type":"method","name":"bsearch","children":[],"call":["midpoint + ","midpoint - "," raise ","result class ","result < ","result == ","convert call ","(send\n  (lvar :from) :+\n  (lvar :to)) div ","from + ","from <= "," exclude_end? ","i2f [] "," lambda ","f2i [] ","to to_f ","from to_f ","map [] ","(send nil :lambda) curry ","result -@ ","nb < ","(send\n  (lvar :nb) :abs) pack unpack ","(send\n  (lvar :nb) :abs) pack ","nb abs ","to is_a? ","from is_a? ","from class "," end "," begin "," to_enum "," __method__ "," block_given? ","Proc  new ","(send\n  (const nil :Proc) :new) curry ","Backport  integer_to_float ","Backports  float_to_integer ","(send\n  (lvar :from) :+\n  (lvar :to)) div  + ","(send\n  (lvar :from) :+\n  (lvar :to)) div  - ","result <  class ","result <  < ","result <  == ","(send\n  (lvar :midpoint + ) :+\n  (lvar :to)) div ","(send\n  (lvar :f2i [] ) :+\n  (lvar :to)) div ","(send\n  (lvar : begin ) :+\n  (lvar :to)) div ","(send\n  (lvar :map [] ) :+\n  (lvar :to)) div ","(send\n  (lvar :Backports  float_to_integer ) :+\n  (lvar :to)) div ","(send\n  (lvar :from) :+\n  (lvar :midpoint - )) div ","(send\n  (lvar :from) :+\n  (lvar :f2i [] )) div ","(send\n  (lvar :from) :+\n  (lvar : end )) div ","(send\n  (lvar :from) :+\n  (lvar :map [] )) div ","(send\n  (lvar :from) :+\n  (lvar :Backports  float_to_integer )) div ","midpoint +  + ","f2i []  + "," begin  + ","map []  + ","Backports  float_to_integer  + ","midpoint +  <= ","f2i []  <= "," begin  <= ","map []  <= ","Backports  float_to_integer  <= ","map []  [] ","midpoint -  midpoint - _f ","f2i []  f2i [] _f "," end   end _f ","map []  map [] _f ","Backports  float_to_integer  Backports  float_to_integer _f ","midpoint +  to_f ","f2i []  to_f "," begin  to_f ","map []  to_f ","Backports  float_to_integer  to_f ","from midpoint - _f ","from f2i [] _f ","from  end _f ","from map [] _f ","from Backports  float_to_integer _f ","(send nil :lambda) curry  [] ","(send\n  (const nil :Proc) :new) curry  [] ","(send nil :lambda) convert call ry ","result <  -@ ","midpoint -  is_a? ","f2i []  is_a? "," end  is_a? ","map []  is_a? ","Backports  float_to_integer  is_a? ","midpoint +  is_a? "," begin  is_a? ","midpoint +  class ","f2i []  class "," begin  class ","map []  class ","Backports  float_to_integer  class "," midpoint - _enum "," f2i [] _enum ","  end _enum "," map [] _enum "," Backports  float_to_integer _enum ","(send\n  (const nil :Proc) :new) convert call ry ","Backport  integer_midpoint - _float ","Backport  integer_f2i [] _float ","Backport  integer_ end _float ","Backport  integer_map [] _float ","Backport  integer_Backports  float_to_integer _float ","Backports  float_midpoint - _integer ","Backports  float_f2i [] _integer ","Backports  float_ end _integer ","Backports  float_map [] _integer ","Backports  float_Backports  float_to_integer _integer "]}," Array bsearch":{"type":"method","name":"bsearch","children":[],"call":["midpoint + ","midpoint - "," raise ","result class ","result < ","result == "," [] ","(send\n  (lvar :from) :+\n  (lvar :to)) div ","from + ","from <= "," size - "," size "," to_enum "," __method__ "," block_given? ","(send\n  (lvar :from) :+\n  (lvar :to)) div  + ","(send\n  (lvar :from) :+\n  (lvar :to)) div  - ","result <  class ","result <  < ","result <  == ","(send\n  (lvar :midpoint + ) :+\n  (lvar :to)) div ","(send\n  (lvar :from) :+\n  (lvar :midpoint - )) div ","(send\n  (lvar :from) :+\n  (lvar : size - )) div ","midpoint +  + ","midpoint +  <= "," midpoint - _enum ","  size - _enum "]}," Enumerator Generator each":{"type":"method","name":"each","children":[],"call":["@main_block call ","Yielder  new "]}," Enumerator Generator initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Struct to_h":{"type":"method","name":"to_h","children":[],"call":["Hash  [] "," [] ","m to_sym "," class members each "," class members "," class ","h []= "]}," OpenStruct to_h":{"type":"method","name":"to_h","children":[],"call":["@table dup "]}," OpenStruct each_pair":{"type":"method","name":"each_pair","children":[],"call":["@table each_pair "," to_enum "," __method__ "," block_given? "]}," OpenStruct hash":{"type":"method","name":"hash","children":[],"call":["@table hash "]}," OpenStruct eql?":{"type":"method","name":"eql?","children":[],"call":["@table eql? ","other table ","other kind_of? "]}," OpenStruct []=":{"type":"method","name":"[]=","children":[],"call":[" modifiable []= "," new_ostruct_member "," modifiable "]}," OpenStruct []":{"type":"method","name":"[]","children":[],"call":["@table [] ","name to_sym "]}," NilClass to_h":{"type":"method","name":"to_h","children":[],"call":[]}," Hash default_proc_with_nil=":{"type":"method","name":"default_proc_with_nil=","children":[],"call":[" default_proc_without_nil= "," default= ","proc == "]}," Hash to_h":{"type":"method","name":"to_h","children":[],"call":[" replace "," class == "," class "]}," Enumerator Lazy __set_inspect":{"type":"method","name":"__set_inspect","children":[],"call":[]}," Enumerator Lazy chunk":{"type":"method","name":"chunk","children":[],"call":[" lazy "]}," Enumerator Lazy inspect":{"type":"method","name":"inspect","children":[],"call":["@receiver inspect "," class ","suff << ","@args inspect [] ","@args inspect ","@args empty? ! ","@args empty? ","@method == ","@method nil? "]}," Enumerator Lazy to_enum":{"type":"method","name":"to_enum","children":[],"call":["Lazy  new ","@@lazy_with_no_block new "]}," Enumerator GeneratorBP each":{"type":"method","name":"each","children":[],"call":["@main_block call ","Yielder  new "]}," Enumerator GeneratorBP initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Enumerable Enumerator with_index":{"type":"method","name":"with_index","children":[],"call":[" index ","args [] ","args size == ","args size "," each "," to_enum "," block_given? "]}," Backports suppress_verbose_warnings":{"type":"method","name":"suppress_verbose_warnings","children":[],"call":[]}," Backports convert_path":{"type":"method","name":"convert_path","children":[],"call":[]}," Backports >":{"type":"method","name":">","children":[],"call":[]}," Backports <":{"type":"method","name":"<","children":[],"call":[]}," Symbol upcase":{"type":"method","name":"upcase","children":[],"call":[" to_s upcase to_sym "," to_s upcase "," to_s "]}," Symbol swapcase":{"type":"method","name":"swapcase","children":[],"call":[" to_s swapcase to_sym "," to_s swapcase "," to_s "]}," Symbol succ":{"type":"method","name":"succ","children":[],"call":[" to_s succ to_sym "," to_s succ "," to_s "]}," Symbol size":{"type":"method","name":"size","children":[],"call":[" to_s size "," to_s "]}," Symbol match":{"type":"method","name":"match","children":[],"call":[" to_s =~ "," to_s "]}," Symbol length":{"type":"method","name":"length","children":[],"call":[" to_s length "," to_s "]}," Symbol empty?":{"type":"method","name":"empty?","children":[],"call":[" to_s empty? "," to_s "]}," Symbol []":{"type":"method","name":"[]","children":[],"call":[" to_s [] "," to_s "]}," Symbol downcase":{"type":"method","name":"downcase","children":[],"call":[" to_s downcase to_sym "," to_s downcase "," to_s "]}," Symbol capitalize":{"type":"method","name":"capitalize","children":[],"call":[" to_s capitalize to_sym "," to_s capitalize "," to_s "]}," try_convert":{"type":"method","name":"try_convert","children":[],"call":[]}," log2":{"type":"method","name":"log2","children":[],"call":[]}," log_with_optional_base":{"type":"method","name":"log_with_optional_base","children":[],"call":[" log_without_optional_base / "," log_without_optional_base "," raise ","base is_a? ","numeric is_a? ","base equal? "]}," open_with_options_hash":{"type":"method","name":"open_with_options_hash","children":[],"call":[" open_without_options_hash "," block_given? ","Backports  combine_mode_and_option ","args << ","args [] respond_to? ","args [] ","args size > ","args size ","Backports  combine_mode_perm_and_option "]}," binread":{"type":"method","name":"binread","children":[],"call":[]}," expand_path_with_potential_to_path":{"type":"method","name":"expand_path_with_potential_to_path","children":[],"call":[" expand_path_without_potential_to_path ","Backports  convert_path ","dir == "," raise ","ENV  [] == ","ENV  [] ","file == "]}," union_with_array_argument":{"type":"method","name":"union_with_array_argument","children":[],"call":[" union_without_array_argument ","arg first ","arg size == ","arg size "]}," []":{"type":"method","name":"[]","children":[],"call":[" constructor_without_key_value_pair_form ","h []= ","arr at ","(irange\n  (int 1)\n  (int 2)) include? ","arr size ","Backports  is_array? ","kvps each "," allocate replace "," allocate ","Backports  try_convert ","args first ","args length == ","args length "," constructor_witBackports  try_convert out_key_value_pair_form ","Backports  try_convert  []= ","Backports  is_array?  at ","Backports  is_array?  size ","Backports  is_Backports  is_array? ay? ","Backports  is_array?  each ","kvps eacBackports  try_convert  ","args first s first ","args lengtBackports  try_convert  == ","args first s length == ","args lengtBackports  try_convert  ","args first s length "]}," stress=":{"type":"method","name":"stress=","children":[],"call":[]}," stress":{"type":"method","name":"stress","children":[],"call":[]}," Enumerator with_index":{"type":"method","name":"with_index","children":[],"call":["args [] ","args size == ","args size "," each "," to_enum "," block_given? "]}," UnicodeNormalize normalized?":{"type":"method","name":"normalized?","children":[],"call":[]}," UnicodeNormalize normalize":{"type":"method","name":"normalize","children":[],"call":[]}," UnicodeNormalize nfc_one":{"type":"method","name":"nfc_one","children":[],"call":[]}," UnicodeNormalize nfd_one":{"type":"method","name":"nfd_one","children":[],"call":[]}," UnicodeNormalize canonical_ordering_one":{"type":"method","name":"canonical_ordering_one","children":[],"call":[]}," UnicodeNormalize hangul_comp_one":{"type":"method","name":"hangul_comp_one","children":[],"call":[]}," UnicodeNormalize hangul_decomp_one":{"type":"method","name":"hangul_decomp_one","children":[],"call":[]}," Backports map_via_packing":{"type":"method","name":"map_via_packing","children":[],"call":["result -@ ","nb < ","(send\n  (lvar :nb) :abs) pack unpack ","(send\n  (lvar :nb) :abs) pack ","nb abs "]}," Backports integer_to_float":{"type":"method","name":"integer_to_float","children":[],"call":[" map_via_packing "]}," Backports float_to_integer":{"type":"method","name":"float_to_integer","children":[],"call":[" map_via_packing "]}," Backports coerce_to_option":{"type":"method","name":"coerce_to_option","children":[],"call":[]}," Backports coerce_to_options":{"type":"method","name":"coerce_to_options","children":[],"call":[]}," Backports coerce_to_hash":{"type":"method","name":"coerce_to_hash","children":[],"call":[]}," Backports Random Implementation _rand_range":{"type":"method","name":"_rand_range","children":[],"call":["limit begin + ","limit begin ","r > ","@mt random_float * * ","@mt random_float * ","@mt random_float "," loop ","range <= ","limit exclude_end? ","range < ","Backports  coerce_to ","@mt random_integer ","Backports  coerce_to_int ","range respond_to? ","range is_a? ! ","range is_a? ","limit end - ","limit end ","@mt random_float * *  > ","@mt @mt random_float * * andom_float * * ","@mt @mt random_float * * andom_float * ","@mt @mt random_float * * andom_float ","@mt random_float * * ange <= ","Backports  coerce_to  <= ","Backports  coerce_to_int  <= ","limit end -  <= ","@mt random_float * * ange < ","Backports  coerce_to  < ","Backports  coerce_to_int  < ","limit end -  < ","Backpo@mt random_float * * ts  coe@mt random_float * * ce_to ","@mt @mt random_float * * andom_intege@mt random_float * *  ","Backpo@mt random_float * * ts  coe@mt random_float * * ce_to_int ","@mt random_float * * ange @mt random_float * * espond_to? ","Backports  coerce_to  respond_to? ","Backports  coerce_to_int  respond_to? ","limit end -  respond_to? ","@mt random_float * * ange is_a? ! ","Backports  coerce_to  is_a? ! ","Backports  coerce_to_int  is_a? ! ","limit end -  is_a? ! ","@mt random_float * * ange is_a? ","Backports  coerce_to  is_a? ","Backports  coerce_to_int  is_a? ","limit end -  is_a? "]}," Backports Random Implementation left":{"type":"method","name":"left","children":[],"call":["@mt left "]}," Backports Random Implementation state":{"type":"method","name":"state","children":[],"call":["@mt state_as_bignum "]}," Backports Random Implementation marshal_load":{"type":"method","name":"marshal_load","children":[],"call":["@mt marshal_load ","MT19937  allocate ","ary pop ","MT19937  allocate  marshal_load "]}," Backports Random Implementation marshal_dump":{"type":"method","name":"marshal_dump","children":[],"call":["@mt marshal_dump << ","@mt marshal_dump "]}," Backports Random Implementation ==":{"type":"method","name":"==","children":[],"call":[" state == ","other send "," state "," left == "," left "," seed == ","other seed "," seed ","other is_a? "]}," Backports Random Implementation bytes":{"type":"method","name":"bytes","children":[],"call":["@mt random_bytes "," raise ","nb < ","Backports  coerce_to_int ","Backports  coerce_to_int  < "]}," Backports Random Implementation rand":{"type":"method","name":"rand","children":[],"call":[" raise ","@mt random_integer ","limit <= ","Backports  coerce_to_int "," _rand_range ","limit * ","@mt random_float ","Backports  coerce_to_int  <= ","Backports  coerce_to_int  * "]}," Backports Random Implementation srand":{"type":"method","name":"srand","children":[],"call":["MT19937  [] "," Random  new_seed ","new_seed nonzero? ","Backports  coerce_to_int ","Random  new_seed "," Random  Backports  coerce_to_int  ","Backports  coerce_to_int  nonzero? ","Random  Backports  coerce_to_int  "]}," Backports Random Implementation initialize":{"type":"method","name":"initialize","children":[],"call":[" srand "]}," Backports Random MT19937 mask_32_bits":{"type":"method","name":"mask_32_bits","children":[],"call":["n >> ","MASK_BY  each "]}," Backports Random MT19937 []":{"type":"method","name":"[]","children":[],"call":[]}," Backports Random MT19937 convert_seed":{"type":"method","name":"convert_seed","children":[],"call":[]}," Backports Random MT19937 marshal_load":{"type":"method","name":"marshal_load","children":[],"call":["@state []= ","b & ","STATE_SIZE  times ","Array  new ","MT19937 STATE_SIZE  - ","Array  new  []= "]}," Backports Random MT19937 marshal_dump":{"type":"method","name":"marshal_dump","children":[],"call":[" left "," state_as_bignum "]}," Backports Random MT19937 left":{"type":"method","name":"left","children":[],"call":["MT19937 STATE_SIZE  - "]}," Backports Random MT19937 state_as_bignum":{"type":"method","name":"state_as_bignum","children":[],"call":["val << ","32 * ","@state each_with_index "]}," Backports Random MT19937 random_bytes":{"type":"method","name":"random_bytes","children":[],"call":["random pack [] ","random pack ","L * "," random_32_bits ","nb_32_bits times map ","nb_32_bits times ","(send\n  (lvar :nb) :+\n  (int 3)) / ","nb + ","(send\n  (lvar :nb) :+\n  (int 3)) /  times map ","(send\n  (lvar :nb) :+\n  (int 3)) /  times "]}," Backports Random MT19937 random_integer":{"type":"method","name":"random_integer","children":[],"call":[" random_32_bits ","nb_full_32 times "," random_32_bits & ","rand < "," mask_32_bits ","n > ","upto - ","  random_32_bits & om_32_bits "," raupto - dom_32_bits ","upto - b_full_32 times ","  random_32_bits & om_32_bits & "," raupto - dom_32_bits & "," random_32_bits &  < ","raupto - d < ","  mask_32_bits _32_bits ","upto -  > "]}," Backports Random MT19937 random_float":{"type":"method","name":"random_float","children":[],"call":["(send\n  (send\n    (begin\n      (send\n        (send nil :random_32_bits) :>>\n        (int 5))) :*\n    (float 67108864.0)) :+\n  (begin\n    (send\n      (send nil :random_32_bits) :>>\n      (int 6)))) * ","(send\n  (send nil :random_32_bits) :>>\n  (int 5)) * + "," random_32_bits >> "," random_32_bits ","(send\n  (send nil :random_32_bits) :>>\n  (int 5)) * "]}," Backports Random MT19937 random_32_bits":{"type":"method","name":"random_32_bits","children":[],"call":["y >> ","(send\n  (lvar :y) :<<\n  (int 15)) & ","y << ","(send\n  (lvar :y) :<<\n  (int 7)) & ","@state [] "," next_state ","@last_read >= ","@state []  >> ","(send\n  (lvar :@state [] ) :<<\n  (int 15)) & ","@state []  << ","(send\n  (lvar :@state [] ) :<<\n  (int 7)) & "]}," Backports Random MT19937 seed=":{"type":"method","name":"seed=","children":[],"call":[" raise ","@state []= ","@state [] ","(op-asgn\n  (lvasgn :i) :+\n  (int 1)) >= ","(send\n  (send\n    (ivar :@state) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1566083941))) - & ","(send\n  (send\n    (ivar :@state) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1566083941))) - ","@state [] ^ ","(send\n  (send\n    (ivar :@state) :[]\n    (send\n      (lvar :i) :-\n      (int 1))) :^\n  (send\n    (send\n      (ivar :@state) :[]\n      (send\n        (lvar :i) :-\n        (int 1))) :>>\n    (int 30))) * ","@state [] >> ","i - ","(send\n  (const nil :STATE_SIZE) :-\n  (int 1)) times ","STATE_SIZE  - ","(op-asgn\n  (lvasgn :j) :+\n  (int 1)) >= ","seed size ","(send\n  (send\n    (ivar :@state) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + + & ","(send\n  (send\n    (ivar :@state) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + + ","seed [] ","(send\n  (send\n    (ivar :@state) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + ","(const nil :STATE_SIZE) max times ","(const nil :STATE_SIZE) max "," seed= ","(send\n  (send\n    (int 1812433253) :*\n    (begin\n      (send\n        (send\n          (ivar :@state) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :@state) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30))))) :+\n  (lvar :i)) & ","1812433253 * + ","1812433253 * ","(irange\n  (int 1)\n  (const nil :LAST_STATE)) each ","seed & ","Array  new ","Array  new  []= ","Array  new  [] ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1566083941))) - & ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1566083941))) - ","Array  new  [] ^ ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (send\n      (lvar :i) :-\n      (int 1))) :^\n  (send\n    (send\n      (ivar :Array  new ) :[]\n      (send\n        (lvar :i) :-\n        (int 1))) :>>\n    (int 30))) * ","Array  new  [] >> ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + + & ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + + ","(send\n  (send\n    (ivar :Array  new ) :[]\n    (lvar :i)) :^\n  (send\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30)))) :*\n    (int 1664525))) + ","(send\n  (send\n    (int 1812433253) :*\n    (begin\n      (send\n        (send\n          (ivar :Array  new ) :[]\n          (send\n            (lvar :i) :-\n            (int 1))) :^\n        (send\n          (send\n            (ivar :Array  new ) :[]\n            (send\n              (lvar :i) :-\n              (int 1))) :>>\n          (int 30))))) :+\n  (lvar :i)) & "]}," Backports Random MT19937 next_state":{"type":"method","name":"next_state","children":[],"call":["@state [] ","mix odd? ","@state []= ","@state [] ^ ","mix >> ","i + - ","i + ","@state [] & | ","@state [] & ","STATE_SIZE  times ","@state [] & |  odd? ","@state [] & |  >> "]}," Backports Random MT19937 initialize":{"type":"method","name":"initialize","children":[],"call":[" seed= "]}," TrueClass dup":{"type":"method","name":"dup","children":[],"call":[]}," String match?":{"type":"method","name":"match?","children":[],"call":["f resume "," match nil? ! "," match nil? "," match ","Fiber  new "]}," Regexp match?":{"type":"method","name":"match?","children":[],"call":["f resume "," match nil? ! "," match nil? "," match ","Fiber  new "]}," NilClass dup":{"type":"method","name":"dup","children":[],"call":[]}," Hash transform_values!":{"type":"method","name":"transform_values!","children":[],"call":[" replace "," transform_values "," size "," to_enum "," block_given? "," []= "," each "," reject! "," frozen? "]}," Hash transform_values":{"type":"method","name":"transform_values","children":[],"call":["h []= "," each "," size "," to_enum "," block_given? "]}," Hash compact!":{"type":"method","name":"compact!","children":[],"call":["value == "," reject! "]}," Hash compact":{"type":"method","name":"compact","children":[],"call":["h []= ","value == "," each "]}," Float dup":{"type":"method","name":"dup","children":[],"call":[]}," Fixnum dup":{"type":"method","name":"dup","children":[],"call":[]}," FalseClass dup":{"type":"method","name":"dup","children":[],"call":[]}," Enumerable uniq":{"type":"method","name":"uniq","children":[],"call":[" to_a uniq "," to_a "]}," Comparable clamp":{"type":"method","name":"clamp","children":[],"call":[" > ","Backports  coerce_to_comparison "," raise ","Backports  coerce_to_comparison > "," <=> ","Ba <=> kports   <=> oer <=> e_to_ <=> omparison ","Ba <=> kports   <=> oer <=> e_to_ <=> omparison > "]}," Struct dig":{"type":"method","name":"dig","children":[],"call":["val dig "," raise ","val class ","val respond_to? ","val == ","rest empty? "," public_send "," respond_to? "," [] ","key respond_to? "," public_send  dig "," public_send  class "," public_send  respond_to? "," public_send  == "]}," String +@":{"type":"method","name":"+@","children":[],"call":[" dup "," frozen? "]}," String -@":{"type":"method","name":"-@","children":[],"call":[" dup freeze "," dup "," frozen? "]}," Numeric positive?":{"type":"method","name":"positive?","children":[],"call":[" > "]}," Numeric negative?":{"type":"method","name":"negative?","children":[],"call":[" < "]}," Hash to_proc":{"type":"method","name":"to_proc","children":[],"call":["h [] ","Proc  new "," proc "]}," Hash <=":{"type":"method","name":"<=","children":[],"call":["v2 == ","hash fetch "," each "," size <= ","hash size "," size ","Backports  coerce_to_hash ","Backports  coerce_to_hash  fetch ","Backports  coerce_to_hash  size ","Backports  coerce_to_Backports  coerce_to_hash  "]}," Hash <":{"type":"method","name":"<","children":[],"call":["v2 == ","hash fetch "," each "," size < ","hash size "," size ","Backports  coerce_to_hash ","Backports  coerce_to_hash  fetch ","Backports  coerce_to_hash  size ","Backports  coerce_to_Backports  coerce_to_hash  "]}," Hash >=":{"type":"method","name":">=","children":[],"call":["hash <= ","Backports  coerce_to_hash ","Backports  coerce_to_hash  <= ","Backports  coerce_to_Backports  coerce_to_hash  "]}," Hash >":{"type":"method","name":">","children":[],"call":["hash < ","Backports  coerce_to_hash ","Backports  coerce_to_hash  < ","Backports  coerce_to_Backports  coerce_to_hash  "]}," Hash fetch_values":{"type":"method","name":"fetch_values","children":[],"call":[" fetch ","keys map "]}," Hash dig":{"type":"method","name":"dig","children":[],"call":["val dig "," raise ","val class ","val respond_to? ","val == ","rest empty? "," [] "," []  dig "," []  class "," []  respond_to? "," []  == "]}," Enumerable grep_v":{"type":"method","name":"grep_v","children":[],"call":["pattern === "," reject ","acc << "," each_entry "," block_given? "]}," Enumerable chunk_while":{"type":"method","name":"chunk_while","children":[],"call":["y yield ","acc empty? ","acc << ","block call ","prev == ","elem first ","elem length == ","elem length ","enum each ","Enumerator  new "," raise ","elem first  first ","elem first  length == ","elem first  length "]}," Array dig":{"type":"method","name":"dig","children":[],"call":["val dig "," raise ","val class ","val respond_to? ","val == ","rest empty? "," [] "," []  dig "," []  class "," []  respond_to? "," []  == "]}," Array bsearch_index":{"type":"method","name":"bsearch_index","children":[],"call":["midpoint + ","midpoint - "," raise ","result class ","result < ","result == "," [] ","(send\n  (lvar :from) :+\n  (lvar :to)) div ","from + ","from <= "," size - "," size "," to_enum "," __method__ "," block_given? ","(send\n  (lvar :from) :+\n  (lvar :to)) div  + ","(send\n  (lvar :from) :+\n  (lvar :to)) div  - ","result <  class ","result <  < ","result <  == ","(send\n  (lvar :midpoint + ) :+\n  (lvar :to)) div ","(send\n  (lvar :from) :+\n  (lvar :midpoint - )) div ","(send\n  (lvar :from) :+\n  (lvar : size - )) div ","midpoint +  + ","midpoint +  <= "," midpoint - _enum ","  size - _enum "]}," String unicode_normalized?":{"type":"method","name":"unicode_normalized?","children":[],"call":["UnicodeNormalize  normalized? "," require "]}," String unicode_normalize!":{"type":"method","name":"unicode_normalize!","children":[],"call":[" replace "," unicode_normalize "," require "]}," String unicode_normalize":{"type":"method","name":"unicode_normalize","children":[],"call":["UnicodeNormalize  normalize "," require "]}," Method super_method":{"type":"method","name":"super_method","children":[],"call":["call_chain [] instance_method bind "," receiver ","call_chain [] instance_method "," name ","call_chain [] ","c method_defined? ","call_chain find_index ","call_chain drop ","skip + ","c == "," owner ","singleton_klass ancestors ","call_chain drop  [] instance_method bind ","singleton_klass ancestors  [] instance_method bind ","call_chain drop  [] instance_method ","singleton_klass ancestors  [] instance_method ","call_chain drop  [] ","singleton_klass ancestors  [] ","call_chain drop  find_index ","singleton_klass ancestors  find_index ","call_chain drop  drop ","singleton_klass ancestors  drop "]}," Method curry":{"type":"method","name":"curry","children":[],"call":[" to_proc curry "," to_proc "]}," Kernel itself":{"type":"method","name":"itself","children":[],"call":[]}," Float prev_float":{"type":"method","name":"prev_float","children":[],"call":["Backports  integer_to_float ","Backports  float_to_integer - ","Backports  float_to_integer ","Float INFINITY  -@ "," == "]}," Float next_float":{"type":"method","name":"next_float","children":[],"call":["r == ","Backports  integer_to_float ","Backports  float_to_integer + ","Backports  float_to_integer "," == ","Backports  integer_to_float  == ","BackpoBackports  integer_to_float ts  integeBackports  integer_to_float _to_float ","BackpoBackports  integer_to_float ts  float_to_integeBackports  integer_to_float  + ","BackpoBackports  integer_to_float ts  float_to_integeBackports  integer_to_float  "]}," Enumerable slice_when":{"type":"method","name":"slice_when","children":[],"call":["y yield ","acc empty? ","acc << ","block call ","prev == ","elem first ","elem length == ","elem length ","enum each ","Enumerator  new "," raise ","elem first  first ","elem first  length == ","elem first  length "]}," Enumerable slice_after":{"type":"method","name":"slice_after","children":[],"call":["y yield ","acc empty? ","block call ","acc << ","elem first ","elem length == ","elem length ","enum each ","Enumerator  new ","pattern === ","Proc  new "," raise ","block ! ","pattern == ","pattern != "," proc ","elem first  first ","elem first  length == ","elem first  length "]}," Fixnum bit_length":{"type":"method","name":"bit_length","children":[],"call":["n <= ","1 << ","(erange\n  (int 0)\n  (send\n    (int 8) :*\n    (send nil :size))) bsearch ","8 * "," size "," -@ "," + "," >= "," -@  <= "," +  <= ","(era -@ ge\n  (i -@ t 0)\n  (se -@ d\n    (i -@ t 8) :*\n    (se -@ d  -@ il :size))) bsearch ","(era + ge\n  (i + t 0)\n  (se + d\n    (i + t 8) :*\n    (se + d  + il :size))) bsearch "]}," Enumerable to_h":{"type":"method","name":"to_h","children":[],"call":["h []= ","key_value [] "," raise ","key_value size ","key_value size != ","Backports  coerce_to_ary "," each_entry ","Backports  coerce_to_ary  [] ","Backports  coerce_to_ary  size ","Backports  coerce_to_ary  size != "]}," Bignum bit_length":{"type":"method","name":"bit_length","children":[],"call":["n + ","smaller <= ","1 << ","(irange\n  (int 1)\n  (send\n    (int 8) :*\n    (send\n      (int 42) :size))) bsearch ","8 * ","42 size ","smaller -@ ","smaller >= "," >> "," size - "," size ","(erange\n  (int 0)\n  (send\n    (int 8) :*\n    (send\n      (int 42) :size))) bsearch ","(irange\n  (int 1)\n  (int 8)) bsearch ","8 *  + ","smaller -@  <= "," >>  <= ","(ira8 * ge\n  (i8 * t 1)\n  (se8 * d\n    (i8 * t 8) :*\n    (se8 * d\n      (i8 * t 42) :size))) bsearch ","smaller -@  -@ "," >>  -@ ","smaller -@  >= "," >>  >= ","(era8 * ge\n  (i8 * t 0)\n  (se8 * d\n    (i8 * t 8) :*\n    (se8 * d\n      (i8 * t 42) :size))) bsearch ","(ira8 * ge\n  (i8 * t 1)\n  (i8 * t 8)) bsearch "]}," Range size":{"type":"method","name":"size","children":[],"call":["size floor + ","size floor ","size ceil "," exclude_end? ","size == ","size <= "," end - "," begin "," end "," end is_a? "," begin is_a? "," end -  floor + "," end -  floor "," end -  ceil "," end -  == "," end -  <= "]}," Prime EratosthenesSieve compute_primes":{"type":"method","name":"compute_primes","children":[],"call":["@primes concat ","segment compact! ","segment []= ","composite_index < ","segment size ","(send\n  (send\n    (begin\n      (send\n        (send\n          (lvar :segment_min) :+\n          (int 1)) :+\n        (lvar :prime))) :-@) :/\n  (int 2)) % ","(send\n  (send\n    (lvar :segment_min) :+\n    (int 1)) :+\n  (lvar :prime)) -@ / ","(send\n  (send\n    (lvar :segment_min) :+\n    (int 1)) :+\n  (lvar :prime)) -@ ","segment_min + + ","segment_min + ","prime > ","@primes [] ","(irange\n  (int 1)\n  (const\n    (const nil :Float) :INFINITY)) each ","(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a ","(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step "," Integer ","Math  sqrt floor ","Math  sqrt ","(send\n  (lvar :segment_min) :+\n  (lvar :max_segment_size)) min ","max_cached_prime * ","max_cached_prime + ","max_cached_prime > ","@primes last ","1000000.0 to_i ","@@primes [] s concat ","(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a  compact! ","(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a  []= ","(send\n  (send\n    (begin\n      (send\n        (send\n          (lvar :segment_min) :+\n          (int 1)) :+\n        (lvar :prime))) :-@) :/\n  (int 2)) %  < ","(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a  size ","(send\n  (send\n    (begin\n      (send\n        (send\n          (lvar :segment_min) :+\n          (int 1)) :+\n        (lvar :@primes [] ))) :-@) :/\n  (int 2)) % ","(send\n  (send\n    (begin\n      (send\n        (send\n          (lvar :(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a _min) :+\n          (int 1)) :+\n        (lvar :prime))) :-@) :/\n  (int 2)) % ","(send\n  (send\n    (lvar :segment_min) :+\n    (int 1)) :+\n  (lvar :@primes [] )) -@ / ","(send\n  (send\n    (lvar :(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a _min) :+\n    (int 1)) :+\n  (lvar :prime)) -@ / ","(send\n  (send\n    (lvar :segment_min) :+\n    (int 1)) :+\n  (lvar :@primes [] )) -@ ","(send\n  (send\n    (lvar :(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a _min) :+\n    (int 1)) :+\n  (lvar :prime)) -@ ","(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a _min + + ","(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a _min + ","@primes []  > ","@@primes [] s [] ","(irange\n  (begin\n    (send\n      (lvar :(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a _min) :+\n      (int 1)))\n  (lvar :(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a _max)) step to_a ","(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :(send\n  (lvar :segment_min) :+\n  (lvar :max_segment_size)) min )) step to_a ","(irange\n  (begin\n    (send\n      (lvar :(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a _min) :+\n      (int 1)))\n  (lvar :(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a _max)) step ","(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :(send\n  (lvar :segment_min) :+\n  (lvar :max_segment_size)) min )) step ","(send\n  (lvar :(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a _min) :+\n  (lvar :max_(irange\n  (begin\n    (send\n      (lvar :segment_min) :+\n      (int 1)))\n  (lvar :segment_max)) step to_a _size)) min ","(send\n  (lvar :segment_min) :+\n  (lvar :1000000.0 to_i )) min ","max_cached_@primes []  * ","@primes last  * ","max_cached_@primes []  + ","@primes last  + ","max_cached_@primes []  > ","@primes last  > ","@@primes [] s last "]}," Prime EratosthenesSieve get_nth_prime":{"type":"method","name":"get_nth_prime","children":[],"call":["@primes [] "," compute_primes ","@primes size <= ","@primes size "]}," Prime PseudoPrimeGenerator size":{"type":"method","name":"size","children":[],"call":[]}," Prime PseudoPrimeGenerator with_index":{"type":"method","name":"with_index","children":[],"call":[" each "," each_with_index "," proc ","offset == "," enum_for "," block_given? "]}," mktmpdir":{"type":"method","name":"mktmpdir","children":[],"call":["FileUtils  remove_entry_secure "," block_given? ","Dir  mkdir ","path << ","Kernel  rand to_s ","Kernel  rand ","Time  now strftime ","Time  now ","Dir  tmpdir "," raise ","prefix_suffix inspect ","prefix_suffix [] "," respond_to? ","FileUTime  now strftime ils  remove_enTime  now strftime ry_secure ","paTime  now strftime h << ","Kernel  rand Time  now strftime o_s ","Time  now sTime  now strftime rfTime  now strftime ime ","Dir  Time  now strftime mpdir ","prefix_suffix inspecTime  now strftime  ","prefix_prefix_suffix []  inspect ","prefix_suffix [] _suffix inspect ","prefix_prefix_suffix []  [] ","prefix_suffix [] _suffix [] "," respond_Time  now strftime o? "]}," String delete_suffix!":{"type":"method","name":"delete_suffix!","children":[],"call":[" []= ","len -@ "," index ","len > ","suffix length "," chomp! "," frozen? ","Backports  coerce_to_str ","suffix length  -@ ","suffix length  > ","suffix suffix length gth ","Backports  coerce_to_str  length "]}," String delete_suffix":{"type":"method","name":"delete_suffix","children":[],"call":[" dup "," [] ","len -@ "," index ","len > ","suffix length ","Backports  coerce_to_str ","suffix length  -@ ","suffix length  > ","suffix suffix length gth ","Backports  coerce_to_str  length "]}," String delete_prefix!":{"type":"method","name":"delete_prefix!","children":[],"call":[" []= ","prefix length "," rindex ","len > "," chomp! "," frozen? ","Backports  coerce_to_str ","prefix prefix length gth ","Backports  coerce_to_str  length ","prefix length  > "]}," String delete_prefix":{"type":"method","name":"delete_prefix","children":[],"call":[" dup "," [] ","prefix length "," rindex ","Backports  coerce_to_str ","Backports  coerce_to_str  length "]}," Kernel yield_self":{"type":"method","name":"yield_self","children":[],"call":[" to_enum "," __method__ "," block_given? "]}," Integer sqrt":{"type":"method","name":"sqrt","children":[],"call":[]}," Integer nobits?":{"type":"method","name":"nobits?","children":[],"call":["n & == ","n & ","Backports  coerce_to_int ","Backports  coerce_to_int  & == ","Backports  coerce_to_int  & ","Backports  coerce_to_iBackports  coerce_to_int t "]}," Integer anybits?":{"type":"method","name":"anybits?","children":[],"call":["n & != ","n & ","Backports  coerce_to_int ","Backports  coerce_to_int  & != ","Backports  coerce_to_int  & ","Backports  coerce_to_iBackports  coerce_to_int t "]}," Integer allbits?":{"type":"method","name":"allbits?","children":[],"call":["n & == ","n & ","Backports  coerce_to_int ","Backports  coerce_to_int  & == ","Backports  coerce_to_int  & ","Backports  coerce_to_iBackports  coerce_to_int t "]}," Hash transform_keys!":{"type":"method","name":"transform_keys!","children":[],"call":[" []= "," delete "," keys each "," keys "," merge! "," frozen? "," size "," enum_for "," block_given? "," replace ","h []= "," each "]}," Hash transform_keys":{"type":"method","name":"transform_keys","children":[],"call":["h []= "," each "," size "," to_enum "," block_given? "]}," Hash slice":{"type":"method","name":"slice","children":[],"call":["h []= "," [] "," key? ","keys each "]}," Enumerable one_with_pattern?":{"type":"method","name":"one_with_pattern?","children":[],"call":["pattern === "," each_entry "," one_without_pattern? ","Backports Undefined  == "]}," Enumerable none_with_pattern?":{"type":"method","name":"none_with_pattern?","children":[],"call":["pattern === "," each_entry "," none_without_pattern? ","Backports Undefined  == "]}," Hash any_with_pattern?":{"type":"method","name":"any_with_pattern?","children":[],"call":["pattern === "," each_entry "," any_without_pattern? ","Backports Undefined  == "]}," Array any_with_pattern?":{"type":"method","name":"any_with_pattern?","children":[],"call":["pattern === "," each_entry "," any_without_pattern? ","Backports Undefined  == "]}," Enumerable any_with_pattern?":{"type":"method","name":"any_with_pattern?","children":[],"call":["pattern === "," each_entry "," any_without_pattern? ","Backports Undefined  == "]}," Enumerable all_with_pattern?":{"type":"method","name":"all_with_pattern?","children":[],"call":["pattern === "," each_entry "," all_without_pattern? ","Backports Undefined  == "]}," Dir each_child":{"type":"method","name":"each_child","children":[],"call":["Dir  each_child "," path "," to_enum "," __method__ "," block_given? "]}," Dir children":{"type":"method","name":"children","children":[],"call":[" class children "," path "," class "]}," NilClass try":{"type":"method","name":"try","children":[],"call":[]}," Enumerable to_h_with_block":{"type":"method","name":"to_h_with_block","children":[],"call":[" map to_h_without_block "," map "," to_h_without_block "]}," Chain rewind":{"type":"method","name":"rewind","children":[],"call":["enum rewind ","enum respond_to? ","@enums [] ","@rewindable downto ","@enums []  rewind ","@enums []  respond_to? ","@@enums [] s [] "]}," Chain inspect":{"type":"method","name":"inspect","children":[],"call":["@enums map join ","@enums map "]}," Chain size":{"type":"method","name":"size","children":[],"call":["s == ","enum size ","@enums each ","enum size  == ","enum enum size ize ","@enumenum size  each "]}," Chain each":{"type":"method","name":"each","children":[],"call":["enum each ","@enums each_with_index "]}," Chain initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Enumerable chain":{"type":"method","name":"chain","children":[],"call":["Enumerator Chain  new "]}," Array union":{"type":"method","name":"union","children":[],"call":["(self) inject "]}," Array to_h_with_block":{"type":"method","name":"to_h_with_block","children":[],"call":["receiver to_h_without_block "," map "," map  to_h_without_block "]}," Array difference":{"type":"method","name":"difference","children":[],"call":["arrays inject ","Array  new "]}," String undump":{"type":"method","name":"undump","children":[],"call":["result force_encoding "," raise ","Encoding  find ","e backtrace ","e message "," eval ","string gsub ","string [] ","Regexp  new ","(?<!\\)(?:\\\\)*\\x(?![0-9a-f]{2}) gsub ","RUBY_VERSION  >= ","nb_unescaped_quote > ","string [] != ","nb_unescaped_quote == ","(send\n  (send\n    (lvar :string) :scan\n    (regexp\n      (str \"\\\\\\\\*\\\"\")\n      (regopt))) :select) size ","s size odd? ","s size ","string scan select ","string scan ","string encoding to_s ","string encoding ","match [] ","string match ","string ascii_only? "," to_s ","result force_encoding  force_encoding ","result force_match []  ","string []  gsub ","match []  gsub "," to_s  gsub ","string []  [] ","match []  [] "," to_s  [] ","(send\n  (send\n    (lvar :string) :scan\n    (regexp\n      (str \"\\\\*\\\"\")\n      (regopt))) :select) size  > ","string []  [] != ","match []  [] != "," to_s  [] != ","(send\n  (send\n    (lvar :string) :scan\n    (regexp\n      (str \"\\\\*\\\"\")\n      (regopt))) :select) size  == ","(send\n  (send\n    (lvar :string) :scan\n    (Regexp  new p\n      (str \"\\\\\\\\*\\\"\")\n      (regopt))) :select) size ","(send\n  (send\n    (lvar :string [] ) :scan\n    (regexp\n      (str \"\\\\\\\\*\\\"\")\n      (regopt))) :select) size ","(send\n  (send\n    (lvar :match [] ) :scan\n    (regexp\n      (str \"\\\\\\\\*\\\"\")\n      (regopt))) :select) size ","(send\n  (send\n    (lvar : to_s ) :scan\n    (regexp\n      (str \"\\\\\\\\*\\\"\")\n      (regopt))) :select) size ","string []  scan select ","match []  scan select "," to_s  scan select ","string []  scan ","match []  scan "," to_s  scan ","string []  encoding to_s ","match []  encoding to_s "," to_s  encoding to_s ","string match []  to_s ","string []  encoding ","match []  encoding "," to_s  encoding ","string match []  ","string match  [] ","string []  match ","match []  match "," to_s  match ","string string match  ","string []  ascii_only? ","match []  ascii_only? "," to_s  ascii_only? "]}," Hash merge_with_backports!":{"type":"method","name":"merge_with_backports!","children":[],"call":[" merge_without_backports! ","hashes each "]}," Hash merge_with_backports":{"type":"method","name":"merge_with_backports","children":[],"call":[" merge_without_backports merge! "," merge_without_backports "]}," Hash to_h_with_block":{"type":"method","name":"to_h_with_block","children":[],"call":[" map to_h "," map "," to_h_without_block "]}," Proc >>":{"type":"method","name":">>","children":[],"call":["g call "," call "," proc "," lambda "," lambda? "]}," Proc <<":{"type":"method","name":"<<","children":[],"call":[" call ","g call "," proc "," lambda "," lambda? "]}," Method >>":{"type":"method","name":">>","children":[],"call":[" to_proc >> "," to_proc "]}," Method <<":{"type":"method","name":"<<","children":[],"call":[" to_proc << "," to_proc "]}," Time floor":{"type":"method","name":"floor","children":[],"call":[" - "," subsec modulo ","10 ** ","ndigits -@ "," subsec "]}," Time ceil":{"type":"method","name":"ceil","children":[],"call":[" + ","sceil - "," subsec ","(send\n  (send nil :subsec) :*\n  (send\n    (int 10) :**\n    (lvar :ndigits))) ceil to_r / ","10 ** ","(send\n  (send nil :subsec) :*\n  (send\n    (int 10) :**\n    (lvar :ndigits))) ceil to_r ","(send\n  (send nil :subsec) :*\n  (send\n    (int 10) :**\n    (lvar :ndigits))) ceil "," subsec * ","(send\n  (send nil :subsec) :*\n  (send\n    (int 10) :**\n    (lvar :ndigits))) ceil to_r /  - "]}," Enumerator produce":{"type":"method","name":"produce","children":[],"call":[]}," Enumerable tally":{"type":"method","name":"tally","children":[],"call":["h default= ","(send nil :each_with_object\n  (send\n    (const nil :Hash) :new\n    (int 0))) tap ","res [] "," each_with_object ","Hash  new ","h []= ","h fetch + ","h fetch "," each_entry "]}," Enumerable filter_map":{"type":"method","name":"filter_map","children":[],"call":["res << "," each_with_object "," to_enum "," block_given? "]}," Complex <=>":{"type":"method","name":"<=>","children":[],"call":[" real <=> "," real ","other real ","other imaginary zero? ","other imaginary ","other is_a? "," imaginary zero? "," imaginary "]}," Comparable clamp_with_range":{"type":"method","name":"clamp_with_range","children":[],"call":[" clamp_without_range ","range_or_min end ","range_or_min begin "," raise ","range_or_min exclude_end? "," < ","range_or_min end nil? ","range_or_min class ","range_or_min is_a? ","max == "]}," Array intersection":{"type":"method","name":"intersection","children":[],"call":["arrays inject ","Array  new "]}," Backports deprecate":{"type":"method","name":"deprecate","children":[],"call":[" deprecation_warned []= "," deprecation_warned "," warn "," deprecation_warned [] "]}," Backports warn":{"type":"method","name":"warn","children":[],"call":[" warned []= "," warned "," warned [] "]}," Backports frown_upon":{"type":"method","name":"frown_upon","children":[],"call":[" warn "]}," Range cover_with_range_compatibility?":{"type":"method","name":"cover_with_range_compatibility?","children":[],"call":[" cover_without_range_compatibility? ","what end - ","what end ","what end is_a? ","what begin is_a? ","what begin ","what exclude_end? "," exclude_end? ! "," exclude_end? ","right == ","right >= ","left <= "," end <=> "," end "," begin <=> "," begin ","what is_a? "," end <=>  == "," end <=>  >= "," begin <=>  <= "]}," Symbol name":{"type":"method","name":"name","children":[],"call":[" to_s freeze "," to_s ","Backports  symbol_names [] ","Backports  symbol_names "]}," symbol_names":{"type":"method","name":"symbol_names","children":[],"call":[]}," Hash transform_keys_with_hash_arg!":{"type":"method","name":"transform_keys_with_hash_arg!","children":[],"call":[" replace ","h []= ","hash fetch "," each "," block_given? "," transform_keys_without_hash_arg! "," size "," enum_for ","block ! "]}," Hash transform_keys_with_hash_arg":{"type":"method","name":"transform_keys_with_hash_arg","children":[],"call":["h []= ","hash fetch "," each "," block_given? "," transform_keys_without_hash_arg "," size "," to_enum ","block ! "]}," Hash except":{"type":"method","name":"except","children":[],"call":["keys include? "," reject ","h []= ","keys each "," size > "," size ","keys size > ","keys size "]}," except":{"type":"method","name":"except","children":[],"call":["keys include? "," reject ","h []= ","keys each "," size > "," size ","keys size > ","keys size "]}," Bignum dup":{"type":"method","name":"dup","children":[],"call":[]}," Queue closed?":{"type":"method","name":"closed?","children":[],"call":["(ivar :@closed) ! ! ","(ivar :@closed) ! "]}," Queue close":{"type":"method","name":"close","children":[],"call":[" push_without_close "," num_waiting times "," num_waiting ","Thread  pass ","2 times "]}," Queue pop_with_close":{"type":"method","name":"pop_with_close","children":[],"call":[" raise "," closed? ! "," closed? ","CLOSE_MESSAGE  == "," pop_without_close ","  pop_without_close aise "]}," Queue push_with_close":{"type":"method","name":"push_with_close","children":[],"call":[" push_without_close "," raise "," closed? "]}," Backports FilteredQueue ensure_open":{"type":"method","name":"ensure_open","children":[],"call":[" raise "," class "]}," Backports FilteredQueue available!":{"type":"method","name":"available!","children":[],"call":["msg reserved ! ","msg reserved ","exclude include? ","@queue find "]}," Backports FilteredQueue acquire!":{"type":"method","name":"acquire!","children":[],"call":["@received wait "," timeout_value ","remaining_time <= ","timeout_time - "," Time  now to_f "," Time  now "," closed_queue_value ","exclude << ","msg reserved= "," available! ","timeout_time -  <= "," available!  reserved= "]}," Backports FilteredQueue current_filtered_queues":{"type":"method","name":"current_filtered_queues","children":[],"call":["t thread_variable_set "," compare_by_identity ","t thread_variable_get ","Thread  current ","Thread  current  Thread  current hread_variable_seThread  current  "," compare_by_idenThread  current iThread  current y ","Thread  current  Thread  current hread_variable_geThread  current  ","Thread  currenThread  current  "]}," Backports FilteredQueue reentrant?":{"type":"method","name":"reentrant?","children":[],"call":[" current_filtered_queues [] ! ! "," current_filtered_queues [] ! "," current_filtered_queues [] "," current_filtered_queues "]}," Backports FilteredQueue consume_on_reentry":{"type":"method","name":"consume_on_reentry","children":[],"call":["q_map delete ! ","q_map delete ","q_map []= "," commit "," reenter ","q_map [] "," current_filtered_queues "," current_filtered_queues  delete ! "," current_filtered_queues  delete "," current_filtered_queues  []= "," current_filtered_queues  [] "]}," Backports FilteredQueue commit":{"type":"method","name":"commit","children":[],"call":[" reject! "," consume! ","@mutex synchronize "]}," Backports FilteredQueue reject!":{"type":"method","name":"reject!","children":[],"call":["@received broadcast ","msg reserved= "]}," Backports FilteredQueue consume!":{"type":"method","name":"consume!","children":[],"call":["@queue delete "]}," Backports FilteredQueue filter?":{"type":"method","name":"filter?","children":[],"call":[" commit "," reenter ","(yield\n  (send\n    (lvar :msg) :value)) ! ! ","(yield\n  (send\n    (lvar :msg) :value)) ! ","msg value "," consume_on_reentry "," class "," (yield\n  (send\n    (lvar :msg) :value)) ! ! _on_reentry "]}," Backports FilteredQueue reenter":{"type":"method","name":"reenter","children":[],"call":[]}," Backports FilteredQueue closed_queue_value":{"type":"method","name":"closed_queue_value","children":[],"call":[" ensure_open "]}," Backports FilteredQueue timeout_value":{"type":"method","name":"timeout_value","children":[],"call":[" raise "," class "]}," Backports FilteredQueue empty?":{"type":"method","name":"empty?","children":[],"call":["avail ! "," available! ","@mutex synchronize "]}," Backports FilteredQueue pop":{"type":"method","name":"pop","children":[],"call":["msg value "," filter? "," consume! value "," consume! "," acquire! "," reenter "," reentrant? ","@mutex synchronize ","timeout + ","Time  now to_f ","Time  now "," acquire!  value "]}," Backports FilteredQueue clear":{"type":"method","name":"clear","children":[],"call":["@queue clear ","@mutex synchronize "]}," Backports FilteredQueue <<":{"type":"method","name":"<<","children":[],"call":["@received signal ","@queue << ","Message  new "," ensure_open ","@mutex synchronize "]}," Backports FilteredQueue closed?":{"type":"method","name":"closed?","children":[],"call":[]}," Backports FilteredQueue close":{"type":"method","name":"close","children":[],"call":["@received broadcast ","@mutex synchronize "]}," Backports FilteredQueue initialize":{"type":"method","name":"initialize","children":[],"call":[" ConditionVariable  new "," Mutex  new "]}," Backports FilteredQueue Message initialize":{"type":"method","name":"initialize","children":[],"call":[]}," Ractor ractor_shareable_by_nature?":{"type":"method","name":"ractor_shareable_by_nature?","children":[],"call":["freeze_all ! "]}," Ractor ractor_traverse":{"type":"method","name":"ractor_traverse","children":[],"call":["obj instance_variable_get ","obj instance_variables each ","obj instance_variables ","obj denominator ","obj numerator ","obj imaginary ","obj real ","obj each ","obj end ","obj begin ","obj default_proc "," Hash ","obj default "]}," Ractor ractor_mark_set_shareable":{"type":"method","name":"ractor_mark_set_shareable","children":[],"call":["@ractor_shareable []= ","visited each "]}," Ractor ractor_shareable_parts?":{"type":"method","name":"ractor_shareable_parts?","children":[],"call":[" ractor_shareable_parts? "," ractor_shareable_self? "," ractor_traverse ","visited []= ","visited key? "]}," Ractor ractor_shareable_self?":{"type":"method","name":"ractor_shareable_self?","children":[],"call":["obj freeze ","obj frozen? "," ractor_shareable_by_nature? ","@ractor_shareable key? "]}," Ractor ractor_check_shareability?":{"type":"method","name":"ractor_check_shareability?","children":[],"call":[" ractor_mark_set_shareable "," ractor_shareable_parts? "," ractor_shareable_self? "]}," Ractor ractor_isolate":{"type":"method","name":"ractor_isolate","children":[],"call":["Cloner  deep_clone "]}," Ractor ractor_live?":{"type":"method","name":"ractor_live?","children":[],"call":["@ractor_thread status ","(ivar :@ractor_thread) ! "]}," Ractor ractor_init":{"type":"method","name":"ractor_init","children":[],"call":["Ractor  new "," ObjectSpace WeakMap  new ","RactorThreadGroups  []= "]}," Ractor ractor_reset":{"type":"method","name":"ractor_reset","children":[],"call":["Ractor  current ractor_incoming_queue clear ","Ractor  current ractor_incoming_queue ","Ractor  current ","th join ","th kill ","r ractor_thread ","r == ","ObjectSpace  each_object each ","ObjectSpace  each_object ","r ractor_thread  join ","r ractor_thread  kill ","r ractor_r ractor_thread read "]}," Ractor count":{"type":"method","name":"count","children":[],"call":["ObjectSpace  each_object count ","ObjectSpace  each_object "]}," Ractor current":{"type":"method","name":"current","children":[],"call":["Thread  current thread_variable_get ","Thread  current ","Thread  current thread_variable_set "," ractor_find_current "]}," Ractor shareable?":{"type":"method","name":"shareable?","children":[],"call":[" ractor_check_shareability? "]}," Ractor make_shareable":{"type":"method","name":"make_shareable","children":[],"call":[" raise "," ractor_check_shareability? "]}," Ractor select":{"type":"method","name":"select","children":[],"call":[" sleep ","out push ","out num_waiting > ","out num_waiting ","r == ","ractors [] ","q pop_non_blocking ","queues each_with_index "," raise ","ractors empty? "," ractor_isolate "," current ractor_outgoing_queue "," current ","not_given ! ","r ractor_outgoing_queue ","r ractor_incoming_queue ","ractors map ","Ractor  current "," current ractor_outgoing_queue  push "," current ractor_outgoing_queue  num_waiting > "," current ractor_outgoing_queue  num_waiting ","ractors []  == ","ractors [] actoractors [] s [] "," ractors [] aise ","ractors [] actoractors [] s empty? "," ractors [] actoractors [] _isolate "," curactors [] ractors [] ent ractors [] actoractors [] _outgoing_queue "," current ractor_ current ractor_outgoing_queue going_queue "," Ractor  current rent ractor_outgoing_queue "," curactors [] ractors [] ent "," Ractor  current rent ","ractors []  ractors [] actoractors [] _outgoing_queue ","r ractor_ current ractor_outgoing_queue going_queue ","ractors []  ractors [] actoractors [] _incoming_queue ","ractors [] actoractors [] s map ","Ractoractors []   curactors [] ractors [] ent ","Ractor  Ractor  current rent "]}," Ractor receive_if":{"type":"method","name":"receive_if","children":[],"call":[" current __send__ "," current "," ractor_incoming_queue pop "," ractor_incoming_queue "," raise "]}," Ractor receive":{"type":"method","name":"receive","children":[],"call":[" current __send__ "," current "," ractor_incoming_queue pop "," ractor_incoming_queue "]}," Ractor yield":{"type":"method","name":"yield","children":[],"call":[" raise "," current ractor_outgoing_queue push "," current ractor_outgoing_queue "," current "," ractor_isolate "]}," Ractor close_outgoing":{"type":"method","name":"close_outgoing","children":[],"call":[" ractor_outgoing_queue close "," ractor_outgoing_queue "," ractor_outgoing_queue closed? ","  ractor_outgoing_queue closed? acto ractor_outgoing_queue closed? _outgoing_queue close ","  ractor_outgoing_queue closed? acto ractor_outgoing_queue closed? _outgoing_queue ","  ractor_outgoing_queue closed? acto ractor_outgoing_queue closed? _outgoing_queue closed? "]}," Ractor close_incoming":{"type":"method","name":"close_incoming","children":[],"call":[" ractor_incoming_queue close "," ractor_incoming_queue "," ractor_incoming_queue closed? ","  ractor_incoming_queue closed? acto ractor_incoming_queue closed? _incoming_queue close ","  ractor_incoming_queue closed? acto ractor_incoming_queue closed? _incoming_queue ","  ractor_incoming_queue closed? acto ractor_incoming_queue closed? _incoming_queue closed? "]}," Ractor inspect":{"type":"method","name":"inspect","children":[],"call":["(str \"Ractor:#1\") compact join ","(str \"Ractor:#1\") compact "," name ","RACTOR_STATE  [] ","@ractor_thread status "]}," Ractor name":{"type":"method","name":"name","children":[],"call":[]}," Ractor take":{"type":"method","name":"take","children":[],"call":[" ractor_outgoing_queue pop "," ractor_outgoing_queue "]}," Ractor send":{"type":"method","name":"send","children":[],"call":[" raise "," ractor_incoming_queue << ","Ractor  ractor_isolate "," ractor_incoming_queue "]}," Ractor ractor_thread_terminate":{"type":"method","name":"ractor_thread_terminate","children":[],"call":["thread kill ","thread == ","Thread  current ","@ractor_thread_group list each ","@ractor_thread_group list "," ractor_outgoing_queue close "," ractor_outgoing_queue "," ractor_incoming_queue close "," ractor_incoming_queue "," ractor_outgoing_queue push "," ractor_outgoing_queue closed? "]}," Ractor ractor_thread_start":{"type":"method","name":"ractor_thread_start","children":[],"call":[" ractor_thread_terminate ","OutgoingQueue WrappedException  new "," raise ","err message "," instance_exec "," Thread  current thread_variable_set "," Thread  current ","ThreadGroup  new add ","ThreadGroup  new ","Thread  current ","Thread  new ","@ractor_thread_group add ","RactorThreadGroups  []= "," Thread  new ","ThreadGroup  new add  add ","ThreadGroup  new  add ","Thread  current _group add "]}," Ractor initialize":{"type":"method","name":"initialize","children":[],"call":[" ractor_thread_start ","Ractor  ractor_isolate ","args map! "," caller first split first "," caller first split "," caller first "," caller ","@ractor_thread thread_variable_set "," Thread  current ","Ractor  main == ","Ractor  main ","Backports  coerce_to_str ","kw [] ","args pop ","kw key? ","kw size == ","kw size ","kw is_a? ","args last "," raise ","OutgoingQueue  new ","IncomingQueue  new "," Thread  current  thread_variable_set ","args last  [] ","args last  key? ","args last  size == ","args last  size ","args last  is_a? "]}," Ractor OutgoingQueue push":{"type":"method","name":"push","children":[],"call":[" raise "," class ","r == ","@ack_queue pop "," @ack_queue pop aise ","@ack_queue pop  == "]}," Ractor OutgoingQueue close":{"type":"method","name":"close","children":[],"call":["@ack_queue close "," clear ","how == "]}," Ractor OutgoingQueue pop":{"type":"method","name":"pop","children":[],"call":[" raise ","r exception ","WrappedException  === ","@ack_queue << "]}," Ractor OutgoingQueue initialize":{"type":"method","name":"initialize","children":[],"call":[" Queue  new "]}," Ractor IncomingQueue reenter":{"type":"method","name":"reenter","children":[],"call":[" raise "]}," Ractor BaseQueue pop_non_blocking":{"type":"method","name":"pop_non_blocking","children":[],"call":[" pop "]}," Ractor RemoteError initialize":{"type":"method","name":"initialize","children":[],"call":["Ractor  current "]}," Ractor Cloner copy_contents":{"type":"method","name":"copy_contents","children":[],"call":["obj instance_variable_set "," clone_deeper ","obj instance_variable_get ","obj instance_variables each ","obj instance_variables ","obj []= ","obj each_pair ","obj map! ","obj transform_values! ","obj transform_keys! ","obj default= ","obj default "]}," Ractor Cloner track_change":{"type":"method","name":"track_change","children":[],"call":[]}," Ractor Cloner process":{"type":"method","name":"process","children":[],"call":["result freeze ","obj frozen? ","changed ! "," track_change ","@processed []= ","obj dup ","@processed fetch ","obj dup  freeze "]}," Ractor Cloner clone_deeper":{"type":"method","name":"clone_deeper","children":[],"call":[" block_given? "," copy_contents "," process ","Ractor  ractor_shareable_self? "]}," Ractor Cloner deep_clone":{"type":"method","name":"deep_clone","children":[],"call":["Ractor  ractor_mark_set_shareable "," copy_contents "," process "," compare_by_identity ","Ractor  ractor_shareable_self? "]}," Ractor ractor_find_current":{"type":"method","name":"ractor_find_current","children":[],"call":["RactorThreadGroups  [] ","Thread  current group ","Thread  current "]}," Ractor ractor_locals":{"type":"method","name":"ractor_locals","children":[],"call":[" compare_by_identity "]}," Ractor []=":{"type":"method","name":"[]=","children":[],"call":["Ractor  current ractor_locals []= ","Ractor  current ractor_locals ","Ractor  current "]}," Ractor []":{"type":"method","name":"[]","children":[],"call":["Ractor  current ractor_locals [] ","Ractor  current ractor_locals ","Ractor  current "]}," Backports Ractor ractor_shareable_by_nature?":{"type":"method","name":"ractor_shareable_by_nature?","children":[],"call":["freeze_all ! "]}," Backports Ractor ractor_traverse":{"type":"method","name":"ractor_traverse","children":[],"call":["obj instance_variable_get ","obj instance_variables each ","obj instance_variables ","obj denominator ","obj numerator ","obj imaginary ","obj real ","obj each ","obj end ","obj begin ","obj default_proc "," Hash ","obj default "]}," Backports Ractor ractor_mark_set_shareable":{"type":"method","name":"ractor_mark_set_shareable","children":[],"call":["@ractor_shareable []= ","visited each "]}," Backports Ractor ractor_shareable_parts?":{"type":"method","name":"ractor_shareable_parts?","children":[],"call":[" ractor_shareable_parts? "," ractor_shareable_self? "," ractor_traverse ","visited []= ","visited key? "]}," Backports Ractor ractor_shareable_self?":{"type":"method","name":"ractor_shareable_self?","children":[],"call":["obj freeze ","obj frozen? "," ractor_shareable_by_nature? ","@ractor_shareable key? "]}," Backports Ractor ractor_check_shareability?":{"type":"method","name":"ractor_check_shareability?","children":[],"call":[" ractor_mark_set_shareable "," ractor_shareable_parts? "," ractor_shareable_self? "]}," Backports Ractor ractor_isolate":{"type":"method","name":"ractor_isolate","children":[],"call":["Cloner  deep_clone "]}," Backports Ractor ractor_live?":{"type":"method","name":"ractor_live?","children":[],"call":["@ractor_thread status ","(ivar :@ractor_thread) ! "]}," Backports Ractor ractor_find_current":{"type":"method","name":"ractor_find_current","children":[],"call":["RactorThreadGroups  [] ","Thread  current group ","Thread  current "]}," Backports Ractor ractor_init":{"type":"method","name":"ractor_init","children":[],"call":["RactorThreadGroups  []= ","Ractor  new "," ObjectSpace WeakMap  new "]}," Backports Ractor ractor_next_id":{"type":"method","name":"ractor_next_id","children":[],"call":[]}," Backports Ractor ractor_reset":{"type":"method","name":"ractor_reset","children":[],"call":["Ractor  current ractor_incoming_queue clear ","Ractor  current ractor_incoming_queue ","Ractor  current ","th join ","th kill ","r ractor_thread ","r == "," ObjectSpace  each_object each "," ObjectSpace  each_object ","r ractor_thread  join ","r ractor_thread  kill ","r ractor_r ractor_thread read "]}," Backports Ractor count":{"type":"method","name":"count","children":[],"call":[" ObjectSpace  each_object count "," ObjectSpace  each_object "]}," Backports Ractor current":{"type":"method","name":"current","children":[],"call":[" Thread  current thread_variable_set "," ractor_find_current "," Thread  current "," Thread  current thread_variable_get "]}," Backports Ractor shareable?":{"type":"method","name":"shareable?","children":[],"call":[" ractor_check_shareability? "]}," Backports Ractor make_shareable":{"type":"method","name":"make_shareable","children":[],"call":[" raise "," ractor_check_shareability? "]}," Backports Ractor select":{"type":"method","name":"select","children":[],"call":[" sleep ","out push ","out num_waiting > ","out num_waiting ","r == ","ractors [] ","q pop_non_blocking ","queues each_with_index "," raise ","ractors empty? "," ractor_isolate "," current ractor_outgoing_queue "," current ","not_given ! ","r ractor_outgoing_queue ","r ractor_incoming_queue ","ractors map ","Ractor  current "," current ractor_outgoing_queue  push "," current ractor_outgoing_queue  num_waiting > "," current ractor_outgoing_queue  num_waiting ","ractors []  == ","ractors [] actoractors [] s [] "," ractors [] aise ","ractors [] actoractors [] s empty? "," ractors [] actoractors [] _isolate "," curactors [] ractors [] ent ractors [] actoractors [] _outgoing_queue "," current ractor_ current ractor_outgoing_queue going_queue "," Ractor  current rent ractor_outgoing_queue "," curactors [] ractors [] ent "," Ractor  current rent ","ractors []  ractors [] actoractors [] _outgoing_queue ","r ractor_ current ractor_outgoing_queue going_queue ","ractors []  ractors [] actoractors [] _incoming_queue ","ractors [] actoractors [] s map ","Ractoractors []   curactors [] ractors [] ent ","Ractor  Ractor  current rent "]}," Backports Ractor receive_if":{"type":"method","name":"receive_if","children":[],"call":[" current __send__ "," current "," ractor_incoming_queue pop "," ractor_incoming_queue "," raise "]}," Backports Ractor receive":{"type":"method","name":"receive","children":[],"call":[" current __send__ "," current "," ractor_incoming_queue pop "," ractor_incoming_queue "]}," Backports Ractor yield":{"type":"method","name":"yield","children":[],"call":[" raise "," current ractor_outgoing_queue push "," current ractor_outgoing_queue "," current "," ractor_isolate "]}," Backports Ractor ractor_locals":{"type":"method","name":"ractor_locals","children":[],"call":[" compare_by_identity "]}," Backports Ractor []=":{"type":"method","name":"[]=","children":[],"call":["Ractor  current ractor_locals []= ","Ractor  current ractor_locals ","Ractor  current "]}," Backports Ractor []":{"type":"method","name":"[]","children":[],"call":["Ractor  current ractor_locals [] ","Ractor  current ractor_locals ","Ractor  current "]}," Backports Ractor close_outgoing":{"type":"method","name":"close_outgoing","children":[],"call":[" ractor_outgoing_queue close "," ractor_outgoing_queue "," ractor_outgoing_queue closed? ","  ractor_outgoing_queue closed? acto ractor_outgoing_queue closed? _outgoing_queue close ","  ractor_outgoing_queue closed? acto ractor_outgoing_queue closed? _outgoing_queue ","  ractor_outgoing_queue closed? acto ractor_outgoing_queue closed? _outgoing_queue closed? "]}," Backports Ractor close_incoming":{"type":"method","name":"close_incoming","children":[],"call":[" ractor_incoming_queue close "," ractor_incoming_queue "," ractor_incoming_queue closed? ","  ractor_incoming_queue closed? acto ractor_incoming_queue closed? _incoming_queue close ","  ractor_incoming_queue closed? acto ractor_incoming_queue closed? _incoming_queue ","  ractor_incoming_queue closed? acto ractor_incoming_queue closed? _incoming_queue closed? "]}," Backports Ractor inspect":{"type":"method","name":"inspect","children":[],"call":["(dstr\n  (str \"Ractor:#\")\n  (begin\n    (ivar :@id))) compact join ","(dstr\n  (str \"Ractor:#\")\n  (begin\n    (ivar :@id))) compact "," name ","RACTOR_STATE  [] ","@ractor_thread status "]}," Backports Ractor name":{"type":"method","name":"name","children":[],"call":[]}," Backports Ractor take":{"type":"method","name":"take","children":[],"call":[" ractor_outgoing_queue pop "," ractor_outgoing_queue "]}," Backports Ractor send":{"type":"method","name":"send","children":[],"call":[" raise "," ractor_incoming_queue << ","Ractor  ractor_isolate "," ractor_incoming_queue "]}," Backports Ractor ractor_thread_terminate":{"type":"method","name":"ractor_thread_terminate","children":[],"call":["thread kill ","thread == ","Thread  current ","@ractor_thread_group list each ","@ractor_thread_group list "," ractor_outgoing_queue close "," ractor_outgoing_queue "," ractor_incoming_queue close "," ractor_incoming_queue "," ractor_outgoing_queue push "," ractor_outgoing_queue closed? "]}," Backports Ractor ractor_thread_start":{"type":"method","name":"ractor_thread_start","children":[],"call":[" ractor_thread_terminate ","OutgoingQueue WrappedException  new "," raise ","err message "," instance_exec "," Thread  current thread_variable_set "," Thread  current ","@ractor_thread_group add ","RactorThreadGroups  []= "," ThreadGroup  new "," Thread  new "," ThreadGroup  new  add "," Thread  current _group add "]}," Backports Ractor initialize":{"type":"method","name":"initialize","children":[],"call":[" ractor_thread_start ","Ractor  ractor_isolate ","args map! "," caller first split first "," caller first split "," caller first "," caller ","@ractor_thread thread_variable_set "," Thread  current ","Ractor  main == ","Ractor  main ","Ractor  ractor_next_id ","Backports  coerce_to_str ","kw [] ","args pop ","kw key? ","kw size == ","kw size ","kw is_a? ","args last "," raise ","OutgoingQueue  new ","IncomingQueue  new "," Thread  current  thread_variable_set ","args last  [] ","args last  key? ","args last  size == ","args last  size ","args last  is_a? "]}," Backports Ractor OutgoingQueue push":{"type":"method","name":"push","children":[],"call":[" raise "," class ","r == ","@ack_queue pop "," @ack_queue pop aise ","@ack_queue pop  == "]}," Backports Ractor OutgoingQueue close":{"type":"method","name":"close","children":[],"call":["@ack_queue close "," clear ","how == "]}," Backports Ractor OutgoingQueue pop":{"type":"method","name":"pop","children":[],"call":[" raise ","r exception ","WrappedException  === ","@ack_queue << "]}," Backports Ractor OutgoingQueue initialize":{"type":"method","name":"initialize","children":[],"call":[" Queue  new "]}," Backports Ractor IncomingQueue reenter":{"type":"method","name":"reenter","children":[],"call":[" raise "]}," Backports Ractor BaseQueue pop_non_blocking":{"type":"method","name":"pop_non_blocking","children":[],"call":[" pop "]}," Backports Ractor RemoteError initialize":{"type":"method","name":"initialize","children":[],"call":["Ractor  current "]}," Backports Ractor Cloner copy_contents":{"type":"method","name":"copy_contents","children":[],"call":["obj instance_variable_set "," clone_deeper ","obj instance_variable_get ","obj instance_variables each ","obj instance_variables ","obj []= ","obj each_pair ","obj map! ","obj transform_values! ","obj transform_keys! ","obj default= ","obj default "]}," Backports Ractor Cloner track_change":{"type":"method","name":"track_change","children":[],"call":[]}," Backports Ractor Cloner process":{"type":"method","name":"process","children":[],"call":["result freeze ","obj frozen? ","changed ! "," track_change ","@processed []= ","obj dup ","@processed fetch ","obj dup  freeze "]}," Backports Ractor Cloner clone_deeper":{"type":"method","name":"clone_deeper","children":[],"call":[" block_given? "," copy_contents "," process ","Ractor  ractor_shareable_self? "]}," Backports Ractor Cloner deep_clone":{"type":"method","name":"deep_clone","children":[],"call":["Ractor  ractor_mark_set_shareable "," copy_contents "," process "," compare_by_identity ","Ractor  ractor_shareable_self? "," new deep_clone "," new "]}," Backports Ractor Cloner initialize":{"type":"method","name":"initialize","children":[],"call":[" compare_by_identity "]}," String unpack1":{"type":"method","name":"unpack1","children":[],"call":[" unpack [] "," unpack "]}," keyword_init?":{"type":"method","name":"keyword_init?","children":[],"call":[]}," MatchData match_length":{"type":"method","name":"match_length","children":[],"call":["m length "," [] "," []  length "]}," MatchData match":{"type":"method","name":"match","children":[],"call":[" [] "]}," Integer try_convert":{"type":"method","name":"try_convert","children":[],"call":[]}," File dirname_with_depth":{"type":"method","name":"dirname_with_depth","children":[],"call":[]}," Enumerable tally_with_hash_argument":{"type":"method","name":"tally_with_hash_argument","children":[],"call":["h []= ","h fetch + ","h fetch "," each_entry "," Backports  coerce_to_hash "," tally_without_hash_argument ","h equal? "," Backports  coerce_to_hash  []= "," Backports  coerce_to_hash  fetc Backports  coerce_to_hash  + "," Backports  coerce_to_hash  fetc Backports  coerce_to_hash  "," eac Backports  coerce_to_hash _entry "," Backports  coerce_to_ Backports  coerce_to_hash as Backports  coerce_to_hash  "," tally_wit Backports  coerce_to_hash out_ Backports  coerce_to_hash as Backports  coerce_to_hash _argument "," Backports  coerce_to_hash  equal? "]}," Enumerable compact":{"type":"method","name":"compact","children":[],"call":[" == "," reject "]}," Class subclasses":{"type":"method","name":"subclasses","children":[],"call":["klass singleton_class? ","klass superclass != ","klass superclass ","ObjectSpace  each_object reject ","ObjectSpace  each_object "," singleton_class "]}," Class descendants":{"type":"method","name":"descendants","children":[],"call":["klass == ","klass singleton_class? ","ObjectSpace  each_object reject ","ObjectSpace  each_object "," singleton_class "]}," Array intersect?":{"type":"method","name":"intersect?","children":[],"call":["(send\n  (lvar :array) :&\n  (lvar :smaller)) size > ","(send\n  (lvar :array) :&\n  (lvar :smaller)) size ","array & "," size < ","array size "," size ","Backports  coerce_to_ary ","(send\n  (lvar :Backports  coerce_to_ary ) :&\n  (lvar :smaller)) size > ","(send\n  (lvar :Backports  coerce_to_ary ) :&\n  (lvar :smaller)) size ","Backports  coerce_to_ary  & ","Backports  coerce_to_ary  size "]}," Module singleton_class?":{"type":"method","name":"singleton_class?","children":[],"call":[" inspect start_with? "," inspect "]}," Symbol end_with?":{"type":"method","name":"end_with?","children":[],"call":[" to_s end_with? "," to_s "]}," MatchData byteoffset":{"type":"method","name":"byteoffset","children":[],"call":[" string [] bytesize "," string [] "," string "," end "," begin "]}," Integer ceildiv":{"type":"method","name":"ceildiv","children":[],"call":[" fdiv ceil "," fdiv "]}," Hash shift_with_correct_behaviour_when_empty":{"type":"method","name":"shift_with_correct_behaviour_when_empty","children":[],"call":[" shift_without_correct_behaviour_when_empty "," empty? "]}," Product rewind":{"type":"method","name":"rewind","children":[],"call":["enum rewind ","enum respond_to? ","@__enums reverse_each "]}," Product size":{"type":"method","name":"size","children":[],"call":["size == ","enum size ","@__enums each ","enum size  == ","enum enum size  "]}," Product __execute":{"type":"method","name":"__execute","children":[],"call":[" __execute ","enum each ","block yield ","enums empty? "]}," Product each":{"type":"method","name":"each","children":[],"call":[" __execute "]}," Product initialize":{"type":"method","name":"initialize","children":[],"call":[]}," product":{"type":"method","name":"product","children":[],"call":[]}," Data with":{"type":"method","name":"with","children":[],"call":[" class new ","@__members__ merge "," class ","update empty? "]}," Data to_h":{"type":"method","name":"to_h","children":[],"call":["@__members__ to_h "]}," Data members":{"type":"method","name":"members","children":[],"call":[" class members "," class "]}," Data marshal_load":{"type":"method","name":"marshal_load","children":[],"call":[" freeze "]}," Data marshal_dump":{"type":"method","name":"marshal_dump","children":[],"call":[]}," Data inspect":{"type":"method","name":"inspect","children":[],"call":[" class name "," class ","data != ","(send\n  (ivar :@__members__) :map) join ","v inspect ","@__members__ map ","(send\n  (ivar :@__members__) :map) join  != "]}," Data initialize_copy":{"type":"method","name":"initialize_copy","children":[],"call":[" freeze ","other to_h "]}," Data initialize":{"type":"method","name":"initialize","children":[],"call":[" freeze ","named_values freeze "," raise ","(send\n  (lvar :given) :-\n  (send nil :members)) map join ","(send\n  (lvar :given) :-\n  (send nil :members)) map ","given - "," members "," members size < ","given size "," members size ","missing map join ","missing map ","missing empty? "," members - ","named_values keys ","(send\n  (lvar :named_values keys ) :-\n  (send nil :members)) map join ","(send\n  (lvar :named_values keys ) :-\n  (send nil :members)) map ","named_values keys  - ","named_values keys  size ","missing map join  map join "," members -  map join ","missing map join  map "," members -  map ","missing map join  empty? "," members -  empty? "]}," Data hash":{"type":"method","name":"hash","children":[],"call":["@__members__ hash "]}," Data ==":{"type":"method","name":"==","children":[],"call":["@__members__ == ","other to_h ","other instance_of? "," class "]}," Data eql?":{"type":"method","name":"eql?","children":[],"call":["@__members__ eql? ","other to_h ","other instance_of? "," class "]}," Data define":{"type":"method","name":"define","children":[{"type":"method","name":"new","children":[],"asgn":[{"type":"local","name":"missing","value":" members [] map join "},[" members [] map join "]],"call":[" raise ","values size ","values empty? "," members zip to_h "," members zip "," members "," raise "," members size "," members ","values size "," raise "," members [] map join "," members [] map "," members [] ","values size "," members ","values size <=> "," members size "," members ","values size ","named_values empty? "]}],"call":[]}," Data deconstruct_keys":{"type":"method","name":"deconstruct_keys","children":[],"call":["@__members__ slice "," raise ","s is_a? ","keys_or_nil all? ","keys_or_nil is_a? "]}," Data deconstruct":{"type":"method","name":"deconstruct","children":[],"call":["@__members__ values "]}," Class attached_object":{"type":"method","name":"attached_object","children":[],"call":["ObjectSpace  each_object first ","ObjectSpace  each_object "," raise "," singleton_class? "]}," Symbol start_with?":{"type":"method","name":"start_with?","children":[],"call":[" to_s start_with? "," to_s "]}}