{" PowerAssert start":{"type":"method","name":"start","children":[],"call":["Context  new "," clear_global_method_cache "," respond_to? ","BlockContext  new "]}," PowerAssert Context extract_idents":{"type":"method","name":"extract_idents","children":[],"call":[" with "," _ ","Ident  [] "," s to_s "," s "," s & "," column "," method_name "," _ [] "," ref_name "," Or "," extract_idents "," ss flat_map "," ss ","(send nil :s0) flat_map "," s1 "," s2 "," s0 "," name ","@proc_local_variables include? ","(send\n  (send nil :ss0) :+\n  (send nil :ss1)) flat_map "," ss0 + "," ss1 "," ss0 ","s0_methods [] + + ","s0_methods [] ","s0_methods [] + ","assertion_method to_s "," match ","s0_idents [] + + ","s0_idents [] ","s0_idents [] + ","ref_name == ","tag == ","sexp [] flat_map ","sexp [] ","(send\n  (lvar :ss0) :+\n  (lvar :ss1)) flat_map ","ss0 + ","idents [] + + ","idents [] ","idents [] + ","ss flat_map ","tag4 == ","mname == ","tag3 == ","tag2 == ","tag1 == ","tag0 == "," handle_columnless_ident ","(send\n  (lvar :sexp) :[]\n  (int 1)) flat_map ","idents empty? ","sexp [] == "," extract_ extract_idents  "," extract_idents  [] + + "," extract_idents  [] "," extract_idents  [] + ","s0_ extract_idents  [] + + ","s0_ extract_idents  [] ","s0_ extract_idents  [] + "," extract_idents  empty? "]}," PowerAssert Context set_column":{"type":"method","name":"set_column","children":[],"call":["val column= ","line index ","return_values [] column + ","return_values [] column ","return_values [] ","Regexp  escape ","val name ","i column ","i name == ","i name ","return_values rindex ","m column ","(lvasgn :m\n  (send\n    (lvar :methods) :delete_at\n    (lvar :idx))) column ","methods delete_at ","method name == ","method name ","methods index ","return_values each ","methods dup ","methods delete_at column ","val columethods delete_at n= ","return_values [] columethods delete_at n + ","return_values [] columethods delete_at n ","val namethods delete_at e ","i columethods delete_at n ","i namethods delete_at e == ","i namethods delete_at e ","methods delete_at  columethods delete_at n ","(lvasgn :methods delete_at \n  (send\n    (lvar :methods delete_at ethods) :delete_at\n    (lvar :idx))) columethods delete_at n ","(lvasgn :m\n  (send\n    (lvar :methods dup ) :delete_at\n    (lvar :idx))) column ","methods delete_at ethods delete_at ","methods dup  delete_at ","methods delete_at ethod namethods delete_at e == ","methods delete_at ethod namethods delete_at e ","methods delete_at ethods index ","methods dup  index ","methods delete_at ethods dup ","methods dup  dup ","methods delete_at ethods delete_at columethods delete_at n ","methods dup  delete_at column "]}," PowerAssert Context assertion_message":{"type":"method","name":"assertion_message","children":[],"call":["ret join ","ret << "," sprintf rstrip "," sprintf ","h []= ","(send\n  (send\n    (lvar :i) :value) :inspect) [] ","i column <=> ","j column ","i column ","i value inspect ","i value ","j column to_s to_sym ","j column to_s ","vals each_with_object ","vals each "," sprintf chomp ","v column to_s to_sym ","v column to_s ","v column ","line chomp ","(send\n  (send\n    (begin\n      (send\n        (send\n          (send\n            (lvar :vals) :[]\n            (int 0)) :column) :+\n        (int 1))) :times) :map) join ","v column == ","vals find ","(send\n  (send\n    (send\n      (lvar :vals) :[]\n      (int 0)) :column) :+\n  (int 1)) times map ","(send\n  (send\n    (send\n      (lvar :vals) :[]\n      (int 0)) :column) :+\n  (int 1)) times ","vals [] column + ","vals [] column ","vals [] ","vals empty? ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all ","return_values + ","Value  [] ","proc_binding eval ","i name ","refs map "," set_column ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  each_with_object ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  each ","(send\n  (send\n    (begin\n      (send\n        (send\n          (send\n            (lvar :(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ) :[]\n            (int 0)) :column) :+\n        (int 1))) :times) :map) join ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  find ","(send\n  (send\n    (send\n      (lvar :(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ) :[]\n      (int 0)) :column) :+\n  (int 1)) times map ","(send\n  (send\n    (send\n      (lvar :(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ) :[]\n      (int 0)) :column) :+\n  (int 1)) times ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  [] column + ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  [] column ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  [] ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  empty? "]}," PowerAssert Context do_yield":{"type":"method","name":"do_yield","children":[],"call":[" caller_locations length "," caller_locations ","@trace enable "]}," PowerAssert Context yield":{"type":"method","name":"yield","children":[],"call":[" do_yield ","@trace_call enable "]}," PowerAssert Context initialize":{"type":"method","name":"initialize","children":[],"call":["return_values << ","Value  [] ","tp return_value ","tp method_id to_s ","tp method_id ","lineno == ","locs [] lineno ","locs [] ","path == ","locs [] path ","methods map map uniq ","methods map map ","methods map ","i type == ","i type ","idents partition "," extract_idents ","Ripper  sexp "," open each_line drop first "," open each_line drop ","lineno - "," open each_line "," open ","TARGET_CALLER_INDEX  [] ","tp event ","locs length - == ","TARGET_CALLER_DIFF  [] ","locs length - ","locs length ","tp binding eval ","tp binding ","method_ids include? ! ","method_ids include? ","TracePoint  new ","assertion_proc binding eval map ","assertion_proc binding eval ","assertion_proc binding "," assertion_message freeze "," assertion_message ","@assertion_proc binding ","@base_caller_length > "," lambda ","assertion_method to_s ","InspectedValue  new ","tp return_value inspect ","PowerAssert  configuration lazy_inspection ","PowerAssert  configuration ","target_diff - ","TARGET_INDEX_OFFSET  [] ","Thread  current == ","Thread  current ","current_diff == ","current_diff < "," build_assertion_message freeze "," build_assertion_message ","@base_caller_length < ","SafeInspectable  new inspect ","SafeInspectable  new ","@assertion_proc binding eval map ","@assertion_proc binding eval ","source_binding eval ","assertion_proc_or_source kind_of? ","method_id to_s ","(send\n  (ivar :@base_caller_length) :+\n  (const nil :TARGET_INDEX_OFFSET)) -@ ","@base_caller_length + ","current_diff <= ","loc [] ","tp event == ","method_ids [] ! ","method_ids [] ","PowerAssert  configuration _trace_alias_method ","@trace_call disable ","h []= ","methods map map each_with_object ","locs length >= "," caller_locations "," raise ","(and\n  (send\n    (lvar :lineno) :==\n    (send\n      (lvar :tp) :lineno))\n  (send\n    (lvar :path) :==\n    (send\n      (lvar :tp) :path))) ! ","tp path ","tp lineno ","tp callee_id ","@parser binding ","@parser idents ","@parser line "," fired? ","@parser lineno == ","@parser lineno ","@parser path == ","@parser path ","(send\n  (lvar :base_caller_length) :+\n  (int 1)) -@ ","base_caller_length + ","diff <= ","diff == ","PowerAssert  app_caller_locations ","(and\n  (send\n    (send\n      (ivar :@parser) :lineno) :==\n    (send\n      (lvar :tp) :lineno))\n  (send\n    (send\n      (ivar :@parser) :path) :==\n    (send\n      (lvar :tp) :path))) ! ","method_id_set [] ! ","method_id_set [] ","@parser method_id_set ","@return_values << "," warn ","e message ","e class ","e full_message gsub ","e full_message ","e respond_to? ","return_InspectedValue  new ues << ","return_tp return_value ues << ","tp return_InspectedValue  new ue ","tp return_tp return_value ue ","tp tp callee_id  to_s ","tp tp callee_id  ","locs [] lineno  == ","tp binding eval  [] lineno "," caller_locations  [] lineno ","PowerAssert  app_caller_locations  [] lineno ","locs [] locs [] lineno  ","tp binding eval s [] lineno ","tp binding eval  [] "," caller_locations  [] ","PowerAssert  app_caller_locations  [] ","tp binding eval s [] ","locs [] path  == ","tp binding eval  [] path "," caller_locations  [] path ","PowerAssert  app_caller_locations  [] path ","locs [] locs [] path  ","tp binding eval s [] path "," extract_idents  partition "," extract_ extract_idents  ","locs [] lineno  - ","tp binding eval  length - == "," caller_locations  length - == ","PowerAssert  app_caller_locations  length - == ","tp binding eval s length - == ","tp binding eval  length - "," caller_locations  length - ","PowerAssert  app_caller_locations  length - ","tp binding eval s length - ","tp binding eval  length "," caller_locations  length ","PowerAssert  app_caller_locations  length ","tp binding eval s length ","tp binding eInspectedValue  new  ","tp binding etp return_value  ","methods map map uniq  include? ! ","tp callee_id s include? ! ","methods map map uniq  include? ","tp callee_id s include? ","assertion_proc binding eInspectedValue  new  map ","assertion_proc binding etp return_value  map ","assertion_proc binding eInspectedValue  new  ","assertion_proc binding etp return_value  ","source_binding eval  binding ","tp return_InspectedValue  new ue inspect ","tp return_tp return_value ue inspect ","TARGET_CALLER_DIFF  []  - ","target_locs length -  - ","locs length -  == ","current_locs length -  == ","locs length -  < ","current_locs length -  < ","@assertion_proc binding eInspectedValue  new  map ","@assertion_proc binding etp return_value  map ","source_binding eval  binding eval map ","@assertion_proc binding eInspectedValue  new  ","@assertion_proc binding etp return_value  ","source_binding eval  binding eval ","source_binding eInspectedValue  new  ","source_binding etp return_value  ","tp callee_id  to_s ","locs length -  <= ","current_locs length -  <= ","methods map map uniq  [] ! ","tp callee_id s [] ! ","methods map map uniq  [] ","tp callee_id s [] ","PowerAssert  configuration _PowerAssert  configuration _trace_alias_method  ","tp binding eval  length >= "," caller_locations  length >= ","PowerAssert  app_caller_locations  length >= ","tp binding eval s length >= "," caller_tp binding eval ations ","(and\n  (send\n    (lvar :locs [] lineno ) :==\n    (send\n      (lvar :tp) :locs [] lineno ))\n  (send\n    (lvar :path) :==\n    (send\n      (lvar :tp) :path))) ! ","(and\n  (send\n    (lvar :lineno) :==\n    (send\n      (lvar :tp) :lineno))\n  (send\n    (lvar :locs [] path ) :==\n    (send\n      (lvar :tp) :locs [] path ))) ! ","tp locs [] path  ","tp locs [] lineno  ","@parser  extract_idents  ","@parser locs [] lineno  == ","@parser locs [] lineno  ","@parser locs [] path  == ","@parser locs [] path  ","PowerAssert  app_caller_tp binding eval ations ","(and\n  (send\n    (send\n      (ivar :@parser) :locs [] lineno ) :==\n    (send\n      (lvar :tp) :locs [] lineno ))\n  (send\n    (send\n      (ivar :@parser) :path) :==\n    (send\n      (lvar :tp) :path))) ! ","(and\n  (send\n    (send\n      (ivar :@parser) :lineno) :==\n    (send\n      (lvar :tp) :lineno))\n  (send\n    (send\n      (ivar :@parser) :locs [] path ) :==\n    (send\n      (lvar :tp) :locs [] path ))) ! ","tp callee_id _set [] ! ","@parser method_id_set  [] ! ","tp callee_id _set [] ","@parser method_id_set  [] ","@parser tp callee_id _set ","@parser @parser method_id_set  ","@return_InspectedValue  new ues << ","@return_tp return_value ues << "]}," accept_self_instance_only":{"type":"method","name":"accept_self_instance_only","children":[],"call":[" raise ","val kind_of? "]}," deconstruct":{"type":"method","name":"deconstruct","children":[],"call":[" accept_self_instance_only "]}," PowerAssert Context handle_columnless_ident":{"type":"method","name":"handle_columnless_ident","children":[],"call":["left_idents + + ","Ident  [] ","indices first ","left_idents + ","indices last ","left_idents empty? ","right_idents empty? "," str_indices ","Regexp  escape ","MID2SRCTXT  [] ","mid to_s ","@line length - ","@line length ","right_min column - ","right_min column ","left_max column + ","left_max name length ","left_max name ","left_max column ","right_idents min_by ","left_idents max_by "," str_indices  first "," str_indices  last "," str_ str_indices  ","right_idents min_by  column - ","right_idents min_by  column ","left_idents max_by  column + ","left_idents max_by  name length ","left_idents max_by  name ","left_idents max_by  column "]}," PowerAssert Context str_indices":{"type":"method","name":"str_indices","children":[],"call":[" str_indices ","idx + ","idx <= ","str index ","str index  + ","str index  <= "]}," PowerAssert Context build_assertion_message":{"type":"method","name":"build_assertion_message","children":[],"call":["ret join ","ret << "," sprintf rstrip "," sprintf ","h []= ","(send\n  (send\n    (lvar :i) :value) :inspect) [] ","i column <=> ","j column ","i column ","i value inspect ","i value ","j column to_s to_sym ","j column to_s ","vals each_with_object ","vals each "," sprintf chomp ","v column to_s to_sym ","v column to_s ","v column ","line chomp ","(send\n  (send\n    (begin\n      (send\n        (send\n          (send\n            (lvar :vals) :[]\n            (int 0)) :column) :+\n        (int 1))) :times) :map) join ","v column == ","vals find ","(send\n  (send\n    (send\n      (lvar :vals) :[]\n      (int 0)) :column) :+\n  (int 1)) times map ","(send\n  (send\n    (send\n      (lvar :vals) :[]\n      (int 0)) :column) :+\n  (int 1)) times ","vals [] column + ","vals [] column ","vals [] ","vals empty? ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all ","return_values + ","Value  [] ","proc_binding eval ","i name ","refs map "," set_column ","(send\n  (send\n    (const nil :SafeInspectable) :new\n    (send\n      (lvar :i) :value)) :inspect) [] ","SafeInspectable  new inspect ","SafeInspectable  new ","l rstrip ","l valid_encoding? ","(send\n  (begin\n    (irange\n      (int 0)\n      (send\n        (send\n          (lvar :vals) :[]\n          (int 0)) :column))) :map) join ","(irange\n  (int 0)\n  (send\n    (send\n      (lvar :vals) :[]\n      (int 0)) :column)) map "," encoding_safe_rstrip ","lines join ","lines << ","(lvar :l) [] ","inspected_val each_line ","Formatter  new ","i column= "," warn ","i name == ","j name ","return_values zip ","i type == ","i type ","path partition "," delete_unidentified_calls "," detect_path ","Pry Code  new highlighted ","Pry Code  new ","PowerAssert  configuration _colorize_message ","PowerAssert  configuration ","parser lineno ","parser binding eval ","parser binding ","refs_in_path map ","path find_all "," find_all_identified_calls ","parser line ","line [] == ","line [] ","i display_offset <=> ","j display_offset ","i display_offset ","j display_offset to_s to_sym ","j display_offset to_s ","v display_offset to_s to_sym ","v display_offset to_s ","v display_offset ","(send\n  (begin\n    (irange\n      (int 0)\n      (send\n        (send\n          (lvar :vals) :[]\n          (int 0)) :display_offset))) :map) join ","v display_offset == ","(irange\n  (int 0)\n  (send\n    (send\n      (lvar :vals) :[]\n      (int 0)) :display_offset)) map ","vals [] display_offset ","c2d [] ","i display_offset= "," column2display_offset ","Inspector  new ","IRB Color  colorize_code ","PowerAssert  configuration colorize_message ","(send\n  (send\n    ( sprintf var :i) :va sprintf ue) :inspect) [] ","i co sprintf umn <=> ","j co sprintf umn ","i co sprintf umn ","i va sprintf ue inspect ","i va sprintf ue ","j co sprintf umn to_s to_sym ","j co sprintf umn to_s ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  each_with_object ","va sprintf s each_with_object ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  each ","va sprintf s each ","v co sprintf umn to_s to_sym ","v co sprintf umn to_s ","v co sprintf umn "," sprintf ine chomp ","Pry Code  new highlighted  chomp ","parser line  chomp ","IRB Color  colorize_code  chomp ","(send\n  (send\n    (begin\n      (send\n        (send\n          (send\n            (lvar :(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ) :[]\n            (int 0)) :column) :+\n        (int 1))) :times) :map) join ","(send\n  (send\n    (begin\n      (send\n        (send\n          (send\n            ( sprintf var :va sprintf s) :[]\n            (int 0)) :co sprintf umn) :+\n        (int 1))) :times) :map) join ","v co sprintf umn == ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  find ","va sprintf s find ","(send\n  (send\n    (send\n      (lvar :(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ) :[]\n      (int 0)) :column) :+\n  (int 1)) times map ","(send\n  (send\n    (send\n      ( sprintf var :va sprintf s) :[]\n      (int 0)) :co sprintf umn) :+\n  (int 1)) times map ","(send\n  (send\n    (send\n      (lvar :(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ) :[]\n      (int 0)) :column) :+\n  (int 1)) times ","(send\n  (send\n    (send\n      ( sprintf var :va sprintf s) :[]\n      (int 0)) :co sprintf umn) :+\n  (int 1)) times ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  [] column + ","va sprintf s [] co sprintf umn + ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  [] column ","va sprintf s [] co sprintf umn ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  [] ","va sprintf s [] ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  empty? ","va sprintf s empty? ","(send\n  ( sprintf var :return_va sprintf ues) :+\n  ( sprintf var :ref_va sprintf ues)) find_a sprintf  sprintf  sort_by reverse ","(send\n  ( sprintf var :return_va sprintf ues) :+\n  ( sprintf var :ref_va sprintf ues)) find_a sprintf  sprintf  sort_by ","(send\n  ( sprintf var :return_va sprintf ues) :+\n  ( sprintf var :ref_va sprintf ues)) find_a sprintf  sprintf  ","return_va sprintf ues + ","Va sprintf ue  [] ","proc_binding eva sprintf  "," set_co sprintf umn ","(send\n  (send\n    (const ni sprintf  :SafeInspectab sprintf e) :new\n    (send\n      ( sprintf var :i) :va sprintf ue)) :inspect) [] ","SafeInspectab sprintf e  new inspect ","SafeInspectab sprintf e  new "," sprintf  rstrip "," sprintf  va sprintf id_encoding? ","(send\n  (begin\n    (irange\n      (int 0)\n      (send\n        (send\n          (lvar :(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ) :[]\n          (int 0)) :column))) :map) join ","(send\n  (begin\n    (irange\n      (int 0)\n      (send\n        (send\n          ( sprintf var :va sprintf s) :[]\n          (int 0)) :co sprintf umn))) :map) join ","(irange\n  (int 0)\n  (send\n    (send\n      (lvar :(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ) :[]\n      (int 0)) :column)) map ","(irange\n  (int 0)\n  (send\n    (send\n      ( sprintf var :va sprintf s) :[]\n      (int 0)) :co sprintf umn)) map "," sprintf ines join ","Pry Code  new highlighted s join ","parser line s join ","IRB Color  colorize_code s join "," sprintf ines << ","Pry Code  new highlighted s << ","parser line s << ","IRB Color  colorize_code s << ","( sprintf var : sprintf ) [] ","inspected_va sprintf  each_ sprintf ine ","SafeInspectable  new inspect  each_line ","inspected_val each_Pry Code  new highlighted  ","inspected_val each_parser line  ","inspected_val each_IRB Color  colorize_code  ","i co sprintf umn= ","return_va sprintf ues zip "," detect_path  partition "," de sprintf ete_unidentified_ca sprintf  sprintf s "," detect_ detect_path  ","Pry Code  new high sprintf ighted ","PowerAssert  configuration _co sprintf orize_message ","parser  sprintf ineno ","parser Pry Code  new highlighted no ","parser parser line no ","parser IRB Color  colorize_code no ","parser binding eva sprintf  ","refs_in_ detect_path  map ","path find_a sprintf  sprintf  "," detect_path  find_all "," find_a sprintf  sprintf _identified_ca sprintf  sprintf s ","parser  sprintf ine ","parser Pry Code  new highlighted  ","parser parser line  ","parser IRB Color  colorize_code  "," sprintf ine [] == ","Pry Code  new highlighted  [] == ","parser line  [] == ","IRB Color  colorize_code  [] == "," sprintf ine [] ","Pry Code  new highlighted  [] ","parser line  [] ","IRB Color  colorize_code  [] ","i disp sprintf ay_offset <=> ","j disp sprintf ay_offset ","i disp sprintf ay_offset ","j disp sprintf ay_offset to_s to_sym ","j disp sprintf ay_offset to_s ","v disp sprintf ay_offset to_s to_sym ","v disp sprintf ay_offset to_s ","v disp sprintf ay_offset ","(send\n  (begin\n    (irange\n      (int 0)\n      (send\n        (send\n          (lvar :(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ) :[]\n          (int 0)) :display_offset))) :map) join ","(send\n  (begin\n    (irange\n      (int 0)\n      (send\n        (send\n          ( sprintf var :va sprintf s) :[]\n          (int 0)) :disp sprintf ay_offset))) :map) join ","v disp sprintf ay_offset == ","(irange\n  (int 0)\n  (send\n    (send\n      (lvar :(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse ) :[]\n      (int 0)) :display_offset)) map ","(irange\n  (int 0)\n  (send\n    (send\n      ( sprintf var :va sprintf s) :[]\n      (int 0)) :disp sprintf ay_offset)) map ","(send\n  (lvar :return_values) :+\n  (lvar :ref_values)) find_all sort_by reverse  [] display_offset ","va sprintf s [] disp sprintf ay_offset "," column2display_offset  [] ","i disp sprintf ay_offset= "," co sprintf umn2disp sprintf ay_offset ","IRB Co sprintf or  co sprintf orize_code ","PowerAssert  configuration co sprintf orize_message "]}," PowerAssert InspectedValue inspect":{"type":"method","name":"inspect","children":[],"call":[]}," PowerAssert InspectedValue initialize":{"type":"method","name":"initialize","children":[],"call":[]}," PowerAssert configure":{"type":"method","name":"configure","children":[],"call":[" configuration "]}," PowerAssert configuration":{"type":"method","name":"configuration","children":[],"call":["Configuration  [] "]}," PowerAssert SafeInspectable inspect":{"type":"method","name":"inspect","children":[],"call":["@value inspect ","e message each_line first ","e message each_line ","e message ","e class ","inspect force_encoding ","Encoding  default_external ","inspect encoding ","inspect encode ","Encoding  compatible? ","inspected force_encoding ","inspected encoding ","inspected encode ","@value @value inspect  ","@value inspect  force_encoding ","@value inspect  encoding ","@value inspect  encode ","@value inspect ed force_encoding ","@value inspect ed encoding ","@value inspect ed encode "]}," PowerAssert SafeInspectable initialize":{"type":"method","name":"initialize","children":[],"call":[]}," PowerAssert clear_global_method_cache":{"type":"method","name":"clear_global_method_cache","children":[],"call":[" using ","Object  new "," eval ","CLEAR_CACHE_ISEQ  eval "]}," PowerAssert ==":{"type":"method","name":"==","children":[],"call":[]}," PowerAssert !":{"type":"method","name":"!","children":[],"call":[]}," PowerAssert Context encoding_safe_rstrip":{"type":"method","name":"encoding_safe_rstrip","children":[],"call":["str b rstrip force_encoding ","str b rstrip ","str b ","enc ascii_compatible? ","str encoding ","str rstrip ","str b rstrip force_str encoding oding ","str encoding  ascii_compatible? ","str str encoding oding "]}," PowerAssert Context message":{"type":"method","name":"message","children":[],"call":["@message_proc call "," build_assertion_message freeze "," build_assertion_message "," raise "," fired? "]}," PowerAssert fixed?":{"type":"method","name":"fixed?","children":[],"call":[]}," PowerAssert Bug11182 fixed?":{"type":"method","name":"fixed?","children":[],"call":[]}," PowerAssert Configuration _trace_alias_method=":{"type":"method","name":"_trace_alias_method=","children":[],"call":[" warn "]}," PowerAssert lib_dir":{"type":"method","name":"lib_dir","children":[],"call":["File  expand_path ","obj method source_location [] ","obj method source_location ","obj method ","../ * "]}," PowerAssert ignored_file?":{"type":"method","name":"ignored_file?","children":[],"call":["file start_with? ","IGNORED_LIB_DIRS  find ","IGNORED_LIB_DIRS  []= "," lib_dir ","IGNORED_LIB_DIRS  [] ! ","IGNORED_LIB_DIRS  [] "," setup_ignored_lib_dir "]}," PowerAssert app_context?":{"type":"method","name":"app_context?","children":[],"call":[" ignored_file? ! "," ignored_file? ","top_frame path ","(send\n  (send nil :caller_locations) :drop_while) first ","i path start_with? ","i path "," caller_locations drop_while "," caller_locations "," internal_file? ! "," internal_file? ","(send\n  (send nil :caller_locations) :drop_while) first  path "]}," PowerAssert app_caller_locations":{"type":"method","name":"app_caller_locations","children":[],"call":[" ignored_file? ! "," ignored_file? ","i path ","(send\n  (send nil :caller_locations) :drop_while) take_while "," caller_locations drop_while "," caller_locations "," internal_file? ! "," internal_file? "]}," PowerAssert trace":{"type":"method","name":"trace","children":[],"call":["ctx enable ","TraceContext  new ","frame _binding "," raise "," __method__ ","Byebug  started? ","TraceContext  new  enable "]}," PowerAssert Parser DummyParser call_paths":{"type":"method","name":"call_paths","children":[],"call":[]}," PowerAssert Parser DummyParser idents":{"type":"method","name":"idents","children":[],"call":[]}," PowerAssert Parser DummyParser initialize":{"type":"method","name":"initialize","children":[],"call":[]}," PowerAssert Parser collect_paths":{"type":"method","name":"collect_paths","children":[],"call":[" collect_paths ","index + ","prefix + ","prefixes map ","prefixes empty? ","node flat_map ","node kind_of? ","idents [] ","index < ","idents length ","idents []  flat_map ","idents []  kind_of? "]}," PowerAssert Parser handle_columnless_ident":{"type":"method","name":"handle_columnless_ident","children":[],"call":["left_idents + ","left_idents + + ","Branch  [] ","Ident  [] ","indices last ","indices first ","right_idents empty? ","(and\n  (send\n    (lvar :right_idents) :empty?)\n  (send\n    (lvar :left_idents) :empty?)) ! ","left_idents empty? ","indices length == ","indices length "," str_indices ","Regexp  escape ","MID2SRCTXT  [] ","mid to_s ","@line_for_parsing length - ","@line_for_parsing length ","right_min column - ","right_min column ","left_max column + ","left_max name length ","left_max name ","left_max column ","right_idents flatten min_by ","right_idents flatten ","left_idents flatten max_by ","left_idents flatten ","left_Ident  [] s + ","left_Ident  [] s + + "," str_indices  last "," str_indices  first ","right_Ident  [] s empty? ","(and\n  (send\n    (lvar :right_Ident  [] s) :empty?)\n  (send\n    (lvar :left_Ident  [] s) :empty?)) ! ","left_Ident  [] s empty? "," str_indices  length == "," str_indices  length "," str_ str_indices  ","right_idents flatten min_by  column - ","right_idents flatten min_by  column ","left_idents flatten max_by  column + ","left_idents flatten max_by  name length ","left_idents flatten max_by  name ","left_idents flatten max_by  column ","right_Ident  [] s flatten min_by ","right_Ident  [] s flatten ","left_Ident  [] s flatten max_by ","left_Ident  [] s flatten "]}," PowerAssert Parser str_indices":{"type":"method","name":"str_indices","children":[],"call":[" str_indices ","idx + ","idx <= ","str index ","str index  + ","str index  <= "]}," PowerAssert Parser extract_idents":{"type":"method","name":"extract_idents","children":[],"call":["Ident  [] ","ref_name == ","Branch  [] "," extract_idents ","ss flat_map ","tag4 == ","mname == ","tag3 == ","tag2 == ","tag1 == ","tag0 == ","@proc_local_variables include? ","tag == ","sexp [] flat_map ","sexp [] ","(send\n  (lvar :ss0) :+\n  (lvar :ss1)) flat_map ","ss0 + ","idents [] + + ","idents [] ","idents [] + "," extract_idents + ","idents [] [] ","idents [] [] empty? ","idents [] kind_of? ","idents empty? "," handle_columnless_ident ","(send\n  (lvar :sexp) :[]\n  (int 1)) flat_map ","sexp [] == ","AND_OR_OPS  include? ","(send\n  (lvar :sexp) :[]\n  (int 2)) flat_map ","op_name sub ","ss1 flat_map ","ss0 flat_map ","method == ","op_sym == ","op_name == ","sexp [] [] kind_of? ","sexp [] [] "," extract_ extract_idents  "," extract_idents  [] + + "," extract_idents  [] "," extract_idents  [] + "," extract_ extract_idents  + "," extract_idents  [] [] "," extract_idents  [] [] empty? "," extract_idents  [] kind_of? "," extract_idents  empty? ","sexp [] _name sub ","sexp [] _sym == ","sexp [] _name == "]}," PowerAssert Parser slice_expression":{"type":"method","name":"slice_expression","children":[],"call":["str sub! ","  * ","i length ","str chomp ","str chomp  sub! ","str chomp  chomp "]}," PowerAssert Parser valid_syntax?":{"type":"method","name":"valid_syntax?","children":[],"call":["RubyVM InstructionSequence  compile "]}," PowerAssert Parser method_id_set":{"type":"method","name":"method_id_set","children":[],"call":["h []= ","methods map map each_with_object ","methods map map ","methods map ","i type == ","i type "," idents flatten find_all "," idents flatten "," idents "]}," PowerAssert Parser call_paths":{"type":"method","name":"call_paths","children":[],"call":[" collect_paths uniq "," collect_paths "," idents "]}," PowerAssert Parser idents":{"type":"method","name":"idents","children":[],"call":[" extract_idents ","Ripper  sexp "]}," PowerAssert Parser initialize":{"type":"method","name":"initialize","children":[],"call":["binding eval map ","binding eval "," slice_expression "," valid_syntax? ","(if\n  (send nil :valid_syntax?\n    (lvar :line))\n  (lvar :line)\n  (send nil :slice_expression\n    (lvar :line))) b "]}," PowerAssert Formatter inspect":{"type":"method","name":"inspect","children":[],"call":["@value inspect ","PP  pp ","PowerAssert  configuration _use_pp ","PowerAssert  configuration ","Pry Code  new highlighted ","Pry Code  new ","Pry ColorPrinter  pp ","(send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max ","Pry Terminal  width! - - ","Pry Terminal  width! - ","Pry Terminal  width! ","PowerAssert  configuration _colorize_message ","(send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max ","(if\n  (defined?\n    (const\n      (const nil :Pry) :Terminal))\n  (send\n    (const\n      (const nil :Pry) :Terminal) :width!)\n  (send\n    (send\n      (send\n        (const nil :Pry) :new\n        (hash\n          (pair\n            (sym :output)\n            (send\n              (const nil :StringIO) :new)))) :output) :width)) - - ","(if\n  (defined?\n    (const\n      (const nil :Pry) :Terminal))\n  (send\n    (const\n      (const nil :Pry) :Terminal) :width!)\n  (send\n    (send\n      (send\n        (const nil :Pry) :new\n        (hash\n          (pair\n            (sym :output)\n            (send\n              (const nil :StringIO) :new)))) :output) :width)) - ","Pry  new output width ","Pry  new output ","Pry  new ","StringIO  new ","(send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :(send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max !) :-\n    (int 1)) :-\n  (ivar :@indent)) max ","(send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :(send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max !) :-\n    (int 1)) :-\n  (ivar :@indent)) max ","Pry Terminal  (send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max ! - - ","Pry Terminal  (send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max ! - - ","Pry Terminal  (send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max ! - ","Pry Terminal  (send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max ! - ","Pry Terminal  (send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max ! ","Pry Terminal  (send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max ! ","(send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :(send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max !)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :(send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max ))) :-\n    (int 1)) :-\n  (ivar :@indent)) max ","(send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :(send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max !)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :(send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max ))) :-\n    (int 1)) :-\n  (ivar :@indent)) max ","(if\n  (defined?\n    (const\n      (const nil :Pry) :Terminal))\n  (send\n    (const\n      (const nil :Pry) :Terminal) :(send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max !)\n  (send\n    (send\n      (send\n        (const nil :Pry) :new\n        (hash\n          (pair\n            (sym :output)\n            (send\n              (const nil :StringIO) :new)))) :output) :(send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max )) - - ","(if\n  (defined?\n    (const\n      (const nil :Pry) :Terminal))\n  (send\n    (const\n      (const nil :Pry) :Terminal) :(send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max !)\n  (send\n    (send\n      (send\n        (const nil :Pry) :new\n        (hash\n          (pair\n            (sym :output)\n            (send\n              (const nil :StringIO) :new)))) :output) :(send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max )) - - ","(if\n  (defined?\n    (const\n      (const nil :Pry) :Terminal))\n  (send\n    (const\n      (const nil :Pry) :Terminal) :(send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max !)\n  (send\n    (send\n      (send\n        (const nil :Pry) :new\n        (hash\n          (pair\n            (sym :output)\n            (send\n              (const nil :StringIO) :new)))) :output) :(send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max )) - ","(if\n  (defined?\n    (const\n      (const nil :Pry) :Terminal))\n  (send\n    (const\n      (const nil :Pry) :Terminal) :(send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max !)\n  (send\n    (send\n      (send\n        (const nil :Pry) :new\n        (hash\n          (pair\n            (sym :output)\n            (send\n              (const nil :StringIO) :new)))) :output) :(send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max )) - ","Pry  new output (send\n  (send\n    (send\n      (const\n        (const nil :Pry) :Terminal) :width!) :-\n    (int 1)) :-\n  (ivar :@indent)) max  ","Pry  new output (send\n  (send\n    (begin\n      (if\n        (defined?\n          (const\n            (const nil :Pry) :Terminal))\n        (send\n          (const\n            (const nil :Pry) :Terminal) :width!)\n        (send\n          (send\n            (send\n              (const nil :Pry) :new\n              (hash\n                (pair\n                  (sym :output)\n                  (send\n                    (const nil :StringIO) :new)))) :output) :width))) :-\n    (int 1)) :-\n  (ivar :@indent)) max  "]}," PowerAssert Formatter initialize":{"type":"method","name":"initialize","children":[],"call":[]}," PowerAssert TraceContext enabled?":{"type":"method","name":"enabled?","children":[],"call":["@trace_return enabled? "]}," PowerAssert TraceContext disable":{"type":"method","name":"disable","children":[],"call":["@trace_return disable "]}," PowerAssert TraceContext enable":{"type":"method","name":"enable","children":[],"call":["@trace_return enable "]}," PowerAssert TraceContext initialize":{"type":"method","name":"initialize","children":[],"call":["Parser  new "," open each_line drop first "," open each_line drop ","lineno - "," open each_line "," open ","target_frame lineno ","target_frame path ","base length ","PowerAssert  app_caller_locations ","File  exist? ","fp each_line drop first ","fp each_line drop ","fp each_line ","File  open "," open each_ open each_line drop first  drop first "," open each_ open each_line drop first  drop "," open each_line drop first no - ","target_frame lineno  - "," open each_ open each_line drop first  ","target_frame  open each_line drop first no ","target_frame target_frame lineno  ","target_frame target_frame path  ","fp each_ open each_line drop first  drop first ","fp each_ open each_line drop first  drop ","fp each_ open each_line drop first  "]}," PowerAssert BlockContext invoke_yield":{"type":"method","name":"invoke_yield","children":[],"call":["@trace_call enable ","@trace_return enable "]}," PowerAssert BlockContext yield":{"type":"method","name":"yield","children":[],"call":[" invoke_yield "]}," PowerAssert BlockContext initialize":{"type":"method","name":"initialize","children":[],"call":["Parser  new ","assertion_method to_s ","@assertion_proc binding "," open each_line drop first "," open each_line drop ","lineno - "," open each_line "," open ","locs last lineno ","locs last ","locs last path ","PowerAssert  app_caller_locations ","@trace_call disable ","Thread  current == ","Thread  current ","PowerAssert  app_context? ","TracePoint  new ","source_binding eval ","assertion_proc_or_source to_proc ","assertion_proc_or_source respond_to? ","File  exist? ","fp each_line drop first ","fp each_line drop ","fp each_line ","File  open ","source_binding eval  binding ","assertion_proc_or_source to_proc  binding ","locs last lineno  - ","locs last locs last lineno  ","PowerAssert  app_caller_locations  last lineno ","PowerAssert  app_caller_locations  last ","locs last locs last path  ","PowerAssert  app_caller_locations  last path "]}," PowerAssert Context enum_count_by":{"type":"method","name":"enum_count_by","children":[],"call":["Hash  [] ","v length ","enum group_by map ","enum group_by "]}," PowerAssert Context delete_unidentified_calls":{"type":"method","name":"delete_unidentified_calls","children":[],"call":["identified_calls include? ! ","identified_calls include? ","ident name ","ident type == ","ident type ","path delete_if ","val name ","return_values delete_if ","(send\n  (lvar :return_value_num_of_calls) :find_all) map ","path_num_of_calls [] == ","path_num_of_calls [] ","return_value_num_of_calls find_all "," enum_count_by ","path find_all ","(send\n  (lvar :return_value_num_of_calls) :find_all) map  include? ! ","(send\n  (lvar :return_value_num_of_calls) :find_all) map  include? ","(send\n  (lvar : enum_count_by ) :find_all) map "," enum_count_by  [] == "," enum_count_by  [] "," enum_count_by  find_all "]}," PowerAssert Context uniq_calls":{"type":"method","name":"uniq_calls","children":[],"call":["(send\n  (lvar :all_calls) :find_all) map ","call_count == ","all_calls find_all "," enum_count_by ","(send\n  (lvar :paths) :map) flatten ","(send\n  (lvar :path) :find_all) map uniq ","(send\n  (lvar :path) :find_all) map ","ident type == ","ident type ","path find_all ","paths map "]}," PowerAssert Context detect_path":{"type":"method","name":"detect_path","children":[],"call":["detected_paths [] ","detected_paths length == ","detected_paths length ","return_value_names == ","method_names include? ","(send\n  (lvar :path) :find_all) map ","ident type == ","ident type ","path find_all ","all_paths find_all ","uniq_calls include? ","return_value_names find "," uniq_calls ","return_values map ","@parser call_paths ","@parser call_paths flatten uniq ","@parser call_paths flatten ","@parser method_id_set empty? ","@parser method_id_set ","parser call_paths ","parser call_paths flatten uniq ","parser call_paths flatten ","parser method_id_set empty? ","parser method_id_set ","return_values map  == ","(send\n  (lvar :path) :find_all) map  include? ","@parser call_paths  find_all ","parser call_paths  find_all "," uniq_calls  include? ","return_values map  find ","  uniq_calls  ","@parser c@parser call_paths  ","@parser cparser call_paths  ","@parser c@parser call_paths  flatten uniq ","@parser cparser call_paths  flatten uniq ","@parser c@parser call_paths  flatten ","@parser cparser call_paths  flatten ","parser c@parser call_paths  ","parser cparser call_paths  ","parser c@parser call_paths  flatten uniq ","parser cparser call_paths  flatten uniq ","parser c@parser call_paths  flatten ","parser cparser call_paths  flatten "]}," PowerAssert Context fired?":{"type":"method","name":"fired?","children":[],"call":[]}," PowerAssert Configuration _use_pp=":{"type":"method","name":"_use_pp=","children":[],"call":[" require "," raise "," lazy_inspection "]}," PowerAssert Configuration lazy_inspection=":{"type":"method","name":"lazy_inspection=","children":[],"call":[" raise "," _use_pp "," inspector == "," inspector "]}," PowerAssert Configuration _colorize_message=":{"type":"method","name":"_colorize_message=","children":[],"call":[" require "]}," PowerAssert setup_ignored_lib_dir":{"type":"method","name":"setup_ignored_lib_dir","children":[],"call":["IGNORED_LIB_DIRS  []= "," lib_dir ","IGNORED_LIB_DIRS  key? "]}," PowerAssert setup_internal_lib_dir":{"type":"method","name":"setup_internal_lib_dir","children":[],"call":["INTERNAL_LIB_DIRS  []= "," lib_dir ","INTERNAL_LIB_DIRS  key? "]}," PowerAssert internal_file?":{"type":"method","name":"internal_file?","children":[],"call":["file start_with? ","INTERNAL_LIB_DIRS  find "," setup_internal_lib_dir "]}," PowerAssert Context find_all_identified_calls":{"type":"method","name":"find_all_identified_calls","children":[],"call":["identified_calls include? ","ident name ","ident type == ","ident type ","path find_all ","val name ","return_values find_all ","(send\n  (lvar :return_value_num_of_calls) :find_all) map ","path_num_of_calls [] == ","path_num_of_calls [] ","return_value_num_of_calls find_all "," enum_count_by ","(send\n  (lvar :return_value_num_of_calls) :find_all) map  include? ","(send\n  (lvar : enum_count_by ) :find_all) map "," enum_count_by  [] == "," enum_count_by  [] "," enum_count_by  find_all "]}," PowerAssert Context message_proc":{"type":"method","name":"message_proc","children":[],"call":[" message "," lambda "]}," PowerAssert Context column2display_offset":{"type":"method","name":"column2display_offset","children":[],"call":["c ascii_only? ","r << ","c bytesize times ","c bytesize ","str each_char with_object ","str each_char "]}," PowerAssert Inspector inspect":{"type":"method","name":"inspect","children":[],"call":["@value inspect ","PP  pp ","PowerAssert  configuration inspector == ","PowerAssert  configuration inspector ","PowerAssert  configuration ","IRB Color  colorize_code ","@value to_s ","IRB ColorPrinter  pp ","(send\n  (send\n    (send\n      (send\n        (const nil :IO) :console_size) :[]\n      (int 1)) :-\n    (int 1)) :-\n  (ivar :@indent)) max ","IO  console_size [] - - ","IO  console_size [] - ","IO  console_size [] ","IO  console_size ","PowerAssert  configuration colorize_message ","(send\n  (send\n    (lvar :console_width) :-\n    (int 1)) :-\n  (ivar :@indent)) max ","console_width - - ","console_width - ","IO  respond_to? ","(send\n  (send\n    (lvar :console_(send\n  (send\n    (send\n      (send\n        (const nil :IO) :console_size) :[]\n      (int 1)) :-\n    (int 1)) :-\n  (ivar :@indent)) max ) :-\n    (int 1)) :-\n  (ivar :@indent)) max ","(send\n  (send\n    (lvar :console_(send\n  (send\n    (lvar :console_width) :-\n    (int 1)) :-\n  (ivar :@indent)) max ) :-\n    (int 1)) :-\n  (ivar :@indent)) max ","(send\n  (send\n    (lvar :IO  console_size [] ) :-\n    (int 1)) :-\n  (ivar :@indent)) max ","console_(send\n  (send\n    (send\n      (send\n        (const nil :IO) :console_size) :[]\n      (int 1)) :-\n    (int 1)) :-\n  (ivar :@indent)) max  - - ","console_(send\n  (send\n    (lvar :console_width) :-\n    (int 1)) :-\n  (ivar :@indent)) max  - - ","IO  console_size []  - - ","console_(send\n  (send\n    (send\n      (send\n        (const nil :IO) :console_size) :[]\n      (int 1)) :-\n    (int 1)) :-\n  (ivar :@indent)) max  - ","console_(send\n  (send\n    (lvar :console_width) :-\n    (int 1)) :-\n  (ivar :@indent)) max  - ","IO  console_size []  - "]}," PowerAssert Inspector initialize":{"type":"method","name":"initialize","children":[],"call":[]}," PowerAssert Configuration inspector=":{"type":"method","name":"inspector=","children":[],"call":[" raise "," require "," colorize_message "," lazy_inspection "]}," PowerAssert Configuration colorize_message=":{"type":"method","name":"colorize_message=","children":[],"call":[" require "," inspector == "," inspector "]}}